      subroutine closeUnits
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each ele
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
 
      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (norma
 
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be act
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
 
      character dump_fname (0:nele)*(getfields_l_max_string)
 
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      integer i
      logical lopen
!-----------------------------------------------------------------------
!--CLOSE(DATA FILES
      close(2,err=2)
 2    continue
      close(3,err=3)
 3    continue
      close(4,err=4)
 4    continue
      close(7,err=7)
 7    continue
      close(8,err=8)
 8    continue
      close(9,err=9)
 9    continue
      close(10,err=10)
 10    continue
      close(11,err=11)
 11    continue
      close(12,err=12)
 12    continue
      close(13,err=13)
 13    continue
      close(14,err=14)
 14    continue
      close(15,err=15)
 15    continue
      close(16,err=16)
 16    continue
      close(17,err=17)
 17    continue
      close(18,err=18)
 18    continue
      close(19,err=19)
 19    continue
      close(20,err=20)
 20    continue
      close(21,err=21)
 21    continue
      close(22,err=22)
 22    continue
      close(23,err=23)
 23    continue
      close(24,err=24)
 24    continue
      close(25,err=25)
 25    continue
      close(26,err=26)
 26    continue
      close(27,err=27)
 27    continue
      close(28,err=28)
 28    continue
      close(29,err=29)
 29    continue
      close(30,err=30)
 30    continue
      close(31,err=31)
 31    continue
      close(32,err=32)
 32    continue
      close(33,err=33)
 33    continue
      close(34,err=34)
 34    continue
      close(35,err=35)
 35    continue
      close(59,err=59)
 59    continue
      close(60,err=60)
 60    continue
      close(61,err=61)
 61    continue
      close(62,err=62)
 62    continue
      close(63,err=63)
 63    continue
      close(64,err=64)
 64    continue
      close(65,err=65)
 65    continue
      close(66,err=66)
 66    continue
      close(67,err=67)
 67    continue
      close(68,err=68)
 68    continue
      close(69,err=69)
 69    continue
      close(70,err=70)
 70    continue
      close(71,err=71)
 71    continue
      close(72,err=72)
 72    continue
      close(73,err=73)
 73    continue
      close(74,err=74)
 74    continue
      close(75,err=75)
 75    continue
      close(76,err=76)
 76    continue
      close(77,err=77)
 77    continue
      close(78,err=78)
 78    continue
      close(79,err=79)
 79    continue
      close(80,err=80)
 80    continue
      close(81,err=81)
 81    continue
      close(82,err=82)
 82    continue
      close(83,err=83)
 83    continue
      close(84,err=84)
 84    continue
      close(85,err=85)
 85    continue
      close(86,err=86)
 86    continue
      close(87,err=87)
 87    continue
      close(88,err=88)
 88    continue
      close(89,err=89)
 89    continue
      close(90,err=90)
 90    continue
      close(98,err=98)
 98    continue
!Eric....and more to come
      close(110,err=110)
 110    continue
      close(111,err=111)
 111    continue
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-09-2014
!     close units for dumping particle population or statistics or beam matrix
!     always in main code
      do i=0,il
        if ( ldump(i) ) then
!         the same file could be used by more than one SINGLE ELEMENT
          inquire( unit=dumpunit(i), opened=lopen )
          if ( lopen ) close(dumpunit(i))
        endif
      enddo
!     A.Mereghetti, for the FLUKA Team
!     last modified: 02-09-2014
!     close units for logging dynks
!     always in main code
      if (ldynk) then
         ! dynksets.dat
         inquire(unit=665, opened=lopen)
         if (lopen) close(665,err=665)
 665     continue
 
         do i=1,nfuncs_dynk
            if ( funcs_dynk(i,2).eq.3) then !PIPE FUN
               ! InPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)), opened=lopen)
               if ( lopen ) close(iexpr_dynk(funcs_dynk(i,3)))
 
               ! OutPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)+1), opened=lopen)
               if ( lopen ) then
                  write(iexpr_dynk(funcs_dynk(i,3))+1,"(a)")
     &                 "CLOSEUNITS"
                  close(iexpr_dynk(funcs_dynk(i,3))+1)
               endif
            endif
         end do
      end if
 
 
      return
      end subroutine
      subroutine errf(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! purpose:                                                             *
!   modification of wwerf, double precision complex error function,    *
!   written at cern by k. koelbig.                                     *
!   taken from mad8                                                    *
! input:                                                               *
!   xx, yy    (real)    argument to cerf.                              *
! output:                                                              *
!   wx, wy    (real)    function result.                               *
!----------------------------------------------------------------------*
!---- double precision version.
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer n,nc,nu
      double precision cc,h,one,q,rx,ry,saux,sx,sy,tn,two,tx,ty,wx,wy,x,&
     &xh,xl,xlim,xx,y,yh,ylim,yy
      parameter(cc = 1.12837916709551d0)
      parameter(one = 1.d0)
      parameter(two = 2.d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension rx(33),ry(33)
      save
!-----------------------------------------------------------------------
      x=abs(xx)
      y=abs(yy)
      if(y.lt.ylim.and.x.lt.xlim) then
        q=(one-y/ylim)*sqrt(one-(x/xlim)**2)
        h=one/(3.2d0*q)
!hr05   nc=7+int(23.0*q)
        nc=7+int(23.0d0*q)                                               !hr05
!       xl=h**(1-nc)
        xl=exp_rn((1-nc)*log_rn(h))                                      !yil11
        xh=y+0.5d0/h
        yh=x
        nu=10+int(21d0*q)
        rx(nu+1)=0d0
        ry(nu+1)=0d0
        do 10 n=nu,1,-1
!hr05     tx=xh+n*rx(n+1)
          tx=xh+dble(n)*rx(n+1)                                          !hr05
!hr05     ty=yh-n*ry(n+1)
          ty=yh-dble(n)*ry(n+1)                                          !hr05
!hr05     tn=tx*tx+ty*ty
          tn=tx**2+ty**2                                                 !hr05
!hr05     rx(n)=0.5d0*tx/tn
          rx(n)=(0.5d0*tx)/tn                                            !hr05
!hr05     ry(n)=0.5d0*ty/tn
          ry(n)=(0.5d0*ty)/tn                                            !hr05
   10   continue
        sx=0d0
        sy=0d0
        do 20 n=nc,1,-1
          saux=sx+xl
          sx=rx(n)*saux-ry(n)*sy
          sy=rx(n)*sy+ry(n)*saux
          xl=h*xl
   20   continue
        wx=cc*sx
        wy=cc*sy
      else
        xh=y
        yh=x
        rx(1)=0d0
        ry(1)=0d0
        do 30 n=9,1,-1
!hr05     tx=xh+n*rx(1)
          tx=xh+dble(n)*rx(1)                                            !hr05
!hr05     ty=yh-n*ry(1)
          ty=yh-dble(n)*ry(1)                                            !hr05
!hr05     tn=tx*tx+ty*ty
          tn=tx**2+ty**2                                                 !hr05
!hr05     rx(1)=0.5d0*tx/tn
          rx(1)=(0.5d0*tx)/tn                                            !hr05
!hr05     ry(1)=0.5d0*ty/tn
          ry(1)=(0.5d0*ty)/tn                                            !hr05
   30   continue
        wx=cc*rx(1)
        wy=cc*ry(1)
      endif
!      if(y.eq.0.) wx=exp(-x**2)
      if(yy.lt.0.d0) then
!hr05   wx=two*exp_rn(y*y-x*x)*cos_rn(two*x*y)-wx
        wx=(two*exp_rn(y**2-x**2))*cos_rn((two*x)*y)-wx                  !hr05
!hr05   wy=-two*exp_rn(y*y-x*x)*sin_rn(two*x*y)-wy
        wy=((-1d0*two)*exp_rn(y**2-x**2))*sin_rn((two*x)*y)-wy           !hr05
!hr05   if(xx.gt.0.) wy=-wy
        if(xx.gt.0.d0) wy=-1d0*wy                                        !hr05
      else
!hr05   if(xx.lt.0.) wy=-wy
        if(xx.lt.0.d0) wy=-1d0*wy
      endif
      end
      subroutine wzsubv(n,vx,vy,vu,vv)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!  Vectorised for up to 64 argument values by E.McIntosh, 30.10.1997.
!  Much impoved using short vector buffers Eric 1st May, 2014.
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
!  *********************************************************************
      implicit none
      dimension vx(*),vy(*),vu(*),vv(*)
      integer i,j,k,n,vmu,vnu
      double precision a1,a2,b1,b2,vd12i,vd12r,vd23i,vd23r,             &
     &vd34i,vd34r,vp,vq,vqsq,vr,vsimag,vsreal,vt,vtdd13i,vtdd13r,       &
     &vtdd24i,vtdd24r,vtdddi,vtdddr,vti,vtr,vu,vusum,vusum3,vv,         &
     &vvsum,vvsum3,vw1i,vw1r,vw2i,vw2r,vw3i,vw3r,vw4i,vw4r,vx,          &
     &vxh,vxhrel,vy,vyh,vyhrel
      integer npart
      parameter(npart = 64)
      integer idim,kstep,nx,ny
      double precision h,half,hrecip,one,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77d0, ycut = 7.46d0 )
      parameter ( h = 1.d0/63.d0 )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      parameter ( half = 0.5d0, one = 1.d0 )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      parameter ( a1 = 0.5124242248d0, a2 = 0.0517653588d0 )
      parameter ( b1 = 0.2752551286d0, b2 = 2.7247448714d0 )
      double precision xm,xx,yy
      parameter (xm=1d120)
!     temporary arrays to facilitate vectorisation
      integer in,out,ins,outs
      dimension ins(npart),outs(npart)
!-----------------------------------------------------------------------
      save
      in=0
      out=0
      do i=1,n
        if (vx(i).ge.xcut.or.vy(i).ge.ycut) then
          out=out+1
          outs(out)=i
          if (out.eq.npart) then
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
            do j=1,out
              xx=vx(outs(j))
              yy=vy(outs(j))
              if (xx.ge.xm) xx=xm
              if (yy.ge.xm) yy=xm
              vp=xx**2-yy**2
              vq=(2.d0*xx)*yy
              vqsq=vq**2
!  First term.
              vt=vp-b1
              vr=a1/(vt**2+vqsq)
              vsreal=vr*vt
              vsimag=-vr*vq
!  Second term
              vt=vp-b2
              vr=a2/(vt**2+vqsq)
              vsreal=vsreal+vr*vt
              vsimag=vsimag-vr*vq
!  Multiply by i*z.
              vu(outs(j))=-(yy*vsreal+xx*vsimag)
              vv(outs(j))=xx*vsreal-yy*vsimag
            enddo
            out=0
          endif
        else
          in=in+1
          ins(in)=i
          if (in.eq.npart) then
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
            do j=1,in
              vxh = hrecip*vx(ins(j))
              vyh = hrecip*vy(ins(j))
              vmu = int(vxh)
              vnu = int(vyh)
!  Compute divided differences.
              k = 2 + vmu + vnu*kstep
              vw4r = wtreal(k)
              vw4i = wtimag(k)
              k = k - 1
              vw3r = wtreal(k)
              vw3i = wtimag(k)
              vd34r = vw4r - vw3r
              vd34i = vw4i - vw3i
              k = k + kstep
              vw2r = wtreal(k)
              vw2i = wtimag(k)
              vd23r = vw2i - vw3i
              vd23i = vw3r - vw2r
              vtr = vd23r - vd34r
              vti = vd23i - vd34i
              vtdd24r = vti - vtr
!hr05 vtdd24i(j) = - ( vtr(j) + vti(j) )
              vtdd24i = -1d0* ( vtr + vti )                             !hr05
              k = k + 1
              vw1r = wtreal(k)
              vw1i = wtimag(k)
              vd12r = vw1r - vw2r
              vd12i = vw1i - vw2i
              vtr = vd12r - vd23r
              vti = vd12i - vd23i
              vtdd13r = vtr + vti
              vtdd13i = vti - vtr
              vtdddr = vtdd13i - vtdd24i
              vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
              vxhrel = vxh - dble(vmu)
              vyhrel = vyh - dble(vnu)
              vusum3=half*(vtdd13r+                                     &
     &       (vxhrel*vtdddr-vyhrel*vtdddi))
              vvsum3=half*(vtdd13i+                                     &
     &       (vxhrel*vtdddi+vyhrel*vtdddr))
              vyhrel = vyhrel - one
              vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
              vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
              vxhrel = vxhrel - one
              vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
              vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
            enddo
            in=0
          endif
        endif
      enddo
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
      do j=1,out
        xx=vx(outs(j))
        yy=vy(outs(j))
        if (xx.ge.xm) xx=xm
        if (yy.ge.xm) yy=xm
        vp=xx**2-yy**2
        vq=(2.d0*xx)*yy
        vqsq=vq**2
!  First term.
        vt=vp-b1
        vr=a1/(vt**2+vqsq)
        vsreal=vr*vt
        vsimag=-vr*vq
!  Second term
        vt=vp-b2
        vr=a2/(vt**2+vqsq)
        vsreal=vsreal+vr*vt
        vsimag=vsimag-vr*vq
!  Multiply by i*z.
        vu(outs(j))=-(yy*vsreal+xx*vsimag)
        vv(outs(j))=xx*vsreal-yy*vsimag
      enddo
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
      do j=1,in
        vxh = hrecip*vx(ins(j))
        vyh = hrecip*vy(ins(j))
        vmu = int(vxh)
        vnu = int(vyh)
!  Compute divided differences.
        k = 2 + vmu + vnu*kstep
        vw4r = wtreal(k)
        vw4i = wtimag(k)
        k = k - 1
        vw3r = wtreal(k)
        vw3i = wtimag(k)
        vd34r = vw4r - vw3r
        vd34i = vw4i - vw3i
        k = k + kstep
        vw2r = wtreal(k)
        vw2i = wtimag(k)
        vd23r = vw2i - vw3i
        vd23i = vw3r - vw2r
        vtr = vd23r - vd34r
        vti = vd23i - vd34i
        vtdd24r = vti - vtr
!hr05 vtdd24i(j) = - ( vtr(j) + vti(j) )
        vtdd24i = -1d0* ( vtr + vti )                             !hr05
        k = k + 1
        vw1r = wtreal(k)
        vw1i = wtimag(k)
        vd12r = vw1r - vw2r
        vd12i = vw1i - vw2i
        vtr = vd12r - vd23r
        vti = vd12i - vd23i
        vtdd13r = vtr + vti
        vtdd13i = vti - vtr
        vtdddr = vtdd13i - vtdd24i
        vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
        vxhrel = vxh - dble(vmu)
        vyhrel = vyh - dble(vnu)
        vusum3=half*(vtdd13r+                                           &
     & (vxhrel*vtdddr-vyhrel*vtdddi))
        vvsum3=half*(vtdd13i+                                           &
     & (vxhrel*vtdddi+vyhrel*vtdddr))
        vyhrel = vyhrel - one
        vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
        vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
        vxhrel = vxhrel - one
        vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
        vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
      enddo
      return
      end
      subroutine wzsub(x,y,u,v)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!  *********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer k,mu,nu
      double precision a1,a2,b1,b2,d12i,d12r,d23i,d23r,d34i,d34r,p,     &
     &q,qsq,r,simag,sreal,t,tdd13i,tdd13r,tdd24i,tdd24r,tdddi,tdddr,ti, &
     &tr,u,usum,usum3,v,vsum,vsum3,w1i,w1r,w2i,w2r,w3i,w3r,w4i,w4r,x,xh,&
     &xhrel,y,yh,yhrel
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer idim,kstep,nx,ny
      double precision h,half,hrecip,one,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77d0, ycut = 7.46d0 )
      parameter ( h = 1.d0/63.d0 )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      parameter ( half = 0.5d0, one = 1.d0 )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      parameter ( a1 = 0.5124242248d0, a2 = 0.0517653588d0 )
      parameter ( b1 = 0.2752551286d0, b2 = 2.7247448714d0 )
      save
!-----------------------------------------------------------------------
      if ( x.ge.xcut .or. y.ge.ycut ) goto 1000
      xh = hrecip*x
      yh = hrecip*y
      mu = int(xh)
      nu = int(yh)
!  Compute divided differences.
      k = 2 + mu + nu*kstep
      w4r = wtreal(k)
      w4i = wtimag(k)
      k = k - 1
      w3r = wtreal(k)
      w3i = wtimag(k)
      d34r = w4r - w3r
      d34i = w4i - w3i
      k = k + kstep
      w2r = wtreal(k)
      w2i = wtimag(k)
      d23r = w2i - w3i
      d23i = w3r - w2r
      tr = d23r - d34r
      ti = d23i - d34i
      tdd24r = ti - tr
!hr05 tdd24i = - ( tr + ti )
      tdd24i = -1d0* ( tr + ti )                                         !hr05
      k = k + 1
      w1r = wtreal(k)
      w1i = wtimag(k)
      d12r = w1r - w2r
      d12i = w1i - w2i
      tr = d12r - d23r
      ti = d12i - d23i
      tdd13r = tr + ti
      tdd13i = ti - tr
      tdddr = tdd13i - tdd24i
      tdddi = tdd24r - tdd13r
!  Evaluate polynomial.
      xhrel = xh - dble(mu)
      yhrel = yh - dble(nu)
      usum3 = half*( tdd13r + ( xhrel*tdddr - yhrel*tdddi ) )
      vsum3 = half*( tdd13i + ( xhrel*tdddi + yhrel*tdddr ) )
      yhrel = yhrel - one
      usum = d12r + ( xhrel*usum3 - yhrel*vsum3 )
      vsum = d12i + ( xhrel*vsum3 + yhrel*usum3 )
      xhrel = xhrel - one
      u = w1r + ( xhrel*usum - yhrel*vsum )
      v = w1i + ( xhrel*vsum + yhrel*usum )
      return
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
 1000 p=x**2-y**2
!hr05 q=2.d0*x*y
      q=(2.d0*x)*y                                                       !hr05
      qsq=q**2
!  First term.
      t=p-b1
      r=a1/(t**2+qsq)
      sreal=r*t
!hr05 simag=-r*q
      simag=(-1d0*r)*q                                                   !hr05
!  Second term
      t=p-b2
      r=a2/(t**2+qsq)
      sreal=sreal+r*t
      simag=simag-r*q
!  Multiply by i*z.
!hr05 u=-(y*sreal+x*simag)
      u=-1d0*(y*sreal+x*simag)                                           !hr05
      v=x*sreal-y*simag
      return
!
      end
      subroutine adia(numx,e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-INCREASE
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer numx
      double precision e0f
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      save
!-----------------------------------------------------------------------
      if(numx.eq.1) phas0=phas
      if(numx.le.nde(1)) phas=zero
      if(numx.le.nde(1)) return
      if(numx.gt.nde(2)) phas=zero
      if(numx.gt.nde(2)) return
      phas=phas0
      e0=e0+hsy(1)*sin_rn(phas)
!hr05 e0f=sqrt(e0*e0-pma*pma)
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
      subroutine adib(e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-DECREASE
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      double precision e0f
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      save
!-----------------------------------------------------------------------
      if(abs(phas0).le.pieni) return
      e0=e0+hsy(1)*sin_rn(phas)
!hr05 e0f=sqrt(e0*e0-pma*pma)
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
      subroutine daten
!-----------------------------------------------------------------------
!  READS INPUT DATA FROM FILE FORT.3 AND/OR FORT.2
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,i1,i2,i3,ia,icc,ichrom0,iclr,ico,icy,idi,iexnum,iexread,&
     &ifiend16,ifiend8,ii,il1,ilin0,im,imo,imod,imtr0,irecuin,iw,iw0,ix,&
     &izu,j,j0,j1,j2,jj,k,k0,k10,k11,ka,ke,ki,kk,kpz,kzz,l,l1,l2,l3,l4, &
     &ll,m,mblozz,mout,mout1,mout3,mout4,nac,nbidu,ncy2,ndum,nfb,nft,   &
     &i4,i5
      double precision ak0d,akad,alc,alignx,alignz,apxx,apzz,bk0d,bkad, &
     &cosy,dummy,emitnx,emitny,extaux,halc,halc2,halc3,harm,phag,pmat,  &
     &qbet,qigam,r0,r0a,rdev,rmean,rsqsum,rsum,rv,tilt,u0,              &
     &xang,xstr,xpl0,xplane,xrms0,zpl0,zrms0
      character*16 sing,stru,prin,trac,diff,sync,ende,bloc,comm
      character*16 fluc,chro,tune,iter,limi,orbi,deco
      character*16 beze,bez0,go,rect,elli,comb,sear,subr
      character*16 free,geom,cavi,disp,reso,bezext
      character*16 idat,next,mult,line,init,ic0,imn,icel,irel
      character*16 iss,iqq,iele,ilm,ilm0,idum,corr,norm
      character*16 kl,kr,orga,post,ripp,beam,trom
      character*16 coll
      character*60 ihead
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,nf
      double precision fround
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
!
!
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each ele
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
 
      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (norma
 
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be act
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
 
      character dump_fname (0:nele)*(getfields_l_max_string)
 
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
!     M. Fitterer, for CERN BE-ABP/HSS and Fermilab
!     Common block for the FMA analysis postprocessing
      integer, parameter :: fma_max       = 200              !max. number of FMA
      integer, parameter :: fma_nturn_max = 10000            !max. number of tur
      integer fma_numfiles                                   !number of FMAs
      logical fma_flag                                       !FMA input block ex
      character fma_fname  (fma_max)*(getfields_l_max_string)!name of input file
      character fma_method (fma_max)*(getfields_l_max_string)!method used to fin
      integer fma_nturn    (fma_max)                         !number of turns us
      integer fma_norm_flag(fma_max)                         !fma_norm_flag=0, d
      common /fma_var/ fma_fname,fma_method,fma_numfiles,fma_flag,
     &fma_norm_flag,fma_nturn
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      dimension icel(ncom,20),iss(2),iqq(5)
      dimension beze(nblo,nelb),ilm(nelb),ilm0(40),bez0(nele),ic0(10)
      dimension extaux(40),bezext(nblz)
      data sing,stru,prin,sync,ende,next,comm                           &
     &/'SING','STRU','PRIN','SYNC','ENDE','NEXT','COMM'/
      data fluc,mult,chro,iter,tune,line,trac,diff                      &
     &/'FLUC','MULT','CHRO','ITER','TUNE','LINE','TRAC','DIFF'/
      data limi,orbi,bloc,init,go,sear,subr,reso,disp,post,ripp,deco    &
     &/'LIMI','ORBI','BLOC','INIT','GO','SEAR','SUBR',                  &
     &'RESO','DISP','POST','RIPP','DECO'/
      data rect,elli,comb,free,geom,cavi,beam,trom                      &
     &/'RE','EL','COMB','FREE','GEOM','CAV','BEAM','TROM'/
      data idum,kl,kr,orga,norm,corr/' ','(',')','ORGA','NORM','CORR'/
      data coll /'COLL'/
!     - dump beam population:
      character*16 dump
      data dump /'DUMP'/
!     - dynamic kicks
      character*16 dynk
      data dynk /'DYNK'/
!     - fma
      character*16 fma
      data fma /'FMA'/
 
      save
!-----------------------------------------------------------------------
      if(mmul.lt.10.or.mmul.gt.20) call prror(85)
      irecuin=0
      iss(1)=' '
      iss(2)=' '
      do 10 i=1,5
        iqq(i)=' '
   10 continue
      do 20 i=1,nele
        bez0(i)=' '
   20 continue
      do 30 i=1,nblo
        do 30 j=1,nelb
          beze(i,j)=' '
   30 continue
      do 40 i=1,40
        ilm0(i)=' '
        extaux(i)=zero
   40 continue
      do 50 i=1,10
        coel(i)=' '
   50 continue
      do 60 i=1,ncom
        do 60 j=1,20
          icel(i,j)=' '
   60 continue
      do 70 i=1,10
        ic0(i)=' '
   70 continue
      do 80 i=1,nelb
        ilm(i)=' '
   80 continue
      emitnx=zero
      emitny=zero
      ihead=' '
      sixtit=' '
      nbidu=0
      iclo6=0
      iclo6r=0
      iclr=0
      icy=0
      ncy=0
      ncy2=0
      ndum=0
      numl=1
!  Initialise new input parameters
      numlmax=1000000
      numlcp=0
      napx=0
      amp(1)=c1m3
      amp0=zero
      ird=0
      imc=0
      idial=0
      idz(1)=1
      idz(2)=1
      idfor=0
      irew=0
      nde(1)=0
      nde(2)=0
      nwr(1)=1
      nwr(2)=1
      nwr(3)=1
      nwr(4)=10000
      ntwin=1
      harm=one
      alc=c1m3
      phag=zero
      tlen=one
      pma=pmap
      ition=0
      dpscor=one
      sigcor=one
      iconv=0
      imad=0
      iskip=1
      cma1=one
      cma2=one
      qs=zero
      itra=0
      chi0=zero
      chid=zero
      rat=zero
      rv=one
      ipos=0
      iav=1
      iwg=1
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      ivox=1
      ivoz=1
      ires=1
      dres=one
      ifh=0
      dfft=one
      idis=0
      icow=0
      istw=0
      iffw=0
      nprint=1
      ndafi=1
      itco=50
      dma=c1m12
      dmap=c1m15
      itcro=10
      dech=c1m10
      de0=c1m9
      ded=c1m9
      dsi=c1m9
      dsm0=c1m10
      itqv=10
      dkq=c1m10
      dqq=c1m10
      ichrom=0
      iqmod=0
      im=0
      imtr0=0
      ilin=0
      nlin=0
      iout=0
      idp=0
      izu0=0
      mmac=1
      mcut=0
      mout=0
      mout1=0
      mout2=0
      mout3=0
      mout4=0
      kanf=1
      iclo=0
      isub=0
      irmod2=0
      iorg=0
      ise=0
      iskew=0
      preda=c1m38
   90 read(3,10010,end=1530,iostat=ierro) idat,ihead
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 90
      if(idat.ne.free.and.idat.ne.geom) call prror(1)
      imod=1
      if(idat.eq.geom) imod=2
      write(*,10130)
      write(*,10030)
      write(*,10180) ihead
      sixtit(1:60)=ihead
      if(imod.eq.1) write(*,10190)
      if(imod.eq.2) write(*,10200)
      write(*,10130)
      if(imod.eq.2) then
  100   read(2,10000,end=1520,iostat=ierro) idat
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(idat(1:1).eq.'/') goto 100
        if(idat.eq.sing) goto 120
          write(*,*)    "idat = '"//idat//""
          call prror(15)
        endif
  110 read(3,10000,end=1530,iostat=ierro) idat
      if(ierro.gt.0) call prror(58)
      nunit=3
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 110
      if(idat.eq.sing) goto 120
      if(idat.eq.bloc) goto 190
      if(idat.eq.stru) goto 320
      if(idat.eq.prin) goto 550
      if(idat.eq.disp) goto 170
      if(idat.eq.tune) goto 600
      if(idat.eq.sync) goto 710
      if(idat.eq.iter) goto 940
      if(idat.eq.fluc) goto 790
      if(idat.eq.mult) goto 740
      if(idat.eq.chro) goto 560
      if(idat.eq.trac) goto 510
      if(idat.eq.diff) goto 520
      if(idat.eq.line) goto 660
      if(idat.eq.limi) goto 950
      if(idat.eq.orbi) goto 980
      if(idat.eq.init) goto 500
      if(idat.eq.comb) goto 1030
      if(idat.eq.subr) goto 1110
      if(idat.eq.reso) goto 1120
      if(idat.eq.sear) goto 1200
      if(idat.eq.orga) goto 880
      if(idat.eq.post) goto 1280
      if(idat.eq.ripp) goto 1290
      if(idat.eq.deco) goto 1320
      if(idat.eq.comm) goto 1390
      if(idat.eq.norm) goto 1400
      if(idat.eq.corr) goto 1410
      if(idat.eq.beam) goto 1600
      if(idat.eq.trom) goto 1700
!GRD
      if(idat.eq.coll) goto 1285
!GRD
 
!     - dump beam population:
      if(idat.eq.dump) goto 2000
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     brand new input block for dynamic kicks
!     always in main code
      if(idat.eq.dynk) goto 2200
      if(idat.eq.fma) goto 2300
 
      if(idat.eq.next) goto 110
      if(idat.eq.ende) goto 771
      write(*,*)    "idat = '"//idat//"'"
      call prror(15)
!-----------------------------------------------------------------------
!  DATENBLOCK SINGLE ELEMENTS
!  ELLEMENTLISTE
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  120 i=1
  130 if(imod.eq.1) then
  140   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 140
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  150   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 150
        if(ch(:4).eq.next) then
  160     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 160
          if(idat.ne.bloc) then
            write(*,*)    "idat = '"//idat//""
            call prror(15)
          endif
          goto 190
        endif
      endif
!      if(ch(17:17).ne." ") call prror(104)
      i2=0
      do i1=1,80
        if(ch(i1:i1).ne." ".and.i2.eq.0) then
          i2=i1
        elseif(i2.gt.0) then
          if(ch(i1:i1).eq." ") then
            if(i1-i2.gt.16) then
              call prror(104)
            else
              goto 165
            endif
          endif
        endif
      enddo
 165  if(i1.gt.72) call prror(104)
      call intepr(1,1,ch,ch1)
!     write (*,*) 'ch1:'//ch1//':'
!     write(*,*) 'eric'
      if (nunit.eq.2) then
        call splitfld(errno,nunit,lineno2,nofields,nf,ch1,fields)
      elseif (nunit.eq.3) then
        call splitfld(errno,nunit,lineno3,nofields,nf,ch1,fields)
      else
      call abend('ERIC!!! daten nunit NOT 2 nor 3!!!                ')
      endif
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) kz(i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ed(i)=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ek(i)=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        el(i)=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbx(i)=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbby(i)=fround(errno,fields,7)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbs(i)=fround(errno,fields,8)
        nf=nf-1
      endif
      !Check that the name is unique
      do j=1,i-1
         if ( bez(j).eq.idat ) then
            write(*,*)    "ERROR in DATEN:"
            write(*,*)    "Got multiple copies of element ", bez(j)
            call prror(-1)
         endif
      enddo
 
      if(kz(i).eq.25) then
        ed(i)=ed(i)/two
        ek(i)=ek(i)/two
      endif
!--CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
      if((kz(i).eq.4.or.kz(i).eq.5).and.abs(el(i)).gt.pieni)            &
     &ed(i)=-1d0*ed(i)                                                   !hr05
!hr05&ed(i)=-ed(i)
!--CAVITIES
      if(abs(kz(i)).eq.12) then
        if(abs(ed(i)).gt.pieni.and.abs(ek(i)).gt.pieni) then
          ncy2=ncy2+1
          itionc(i)=kz(i)/abs(kz(i))
          kp(i)=6
        endif
      endif
!--WIRE
      if(abs(kz(i)).eq.15) then
        if(abs(ed(i)*el(i)).le.pieni.or.el(i).le.pieni                  &
     &.or.ek(i).le.pieni) then
           kz(i)=0
!hr05      ed(i)=0
           ed(i)=0d0                                                     !hr05
!hr05      ek(i)=0
           ek(i)=0d0                                                     !hr05
!hr05      el(i)=0
           el(i)=0d0                                                     !hr05
        else
           wirel(i)=el(i)
!hr05      el(i)=0
           el(i)=0d0                                                     !hr05
        endif
      endif
!----------------------------------------
! Handled by initialize_element subroutine:
!-----------------------------------------
!-- CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
!-- THIN LENS (+/- 1-10)
!-- MULTIPOLES (11)
!-- CAVITY (+/- 12)
!-- CRABCAVITY (23/-23) / CC multipoles order 2/3/4 (+/- 23/26/27/28)
      call initialize_element(i,.true.)
 
!--ACDIPOLE
      if(abs(kz(i)).eq.16) then
        if(abs(ed(i)).le.pieni) then
           kz(i)=0
!hr05      ed(i)=0
           ed(i)=0d0                                                     !hr05
!hr05      ek(i)=0
           ek(i)=0d0                                                     !hr05
!hr05      el(i)=0
           el(i)=0d0                                                     !hr05
        else
           acdipph(i)=el(i)
!hr05      el(i)=0
           el(i)=0d0                                                     !hr05
        endif
      endif
!--BEAM-BEAM
      if(kz(i).eq.20) then
        ptnfac(i)=el(i)
        el(i)=zero
      endif
!--General
      if(abs(el(i)).gt.pieni.and.kz(i).ne.0) ithick=1
      if(i.gt.nele-1) call prror(16)
      if(abs(kz(i)).ne.12 .or. (abs(kz(i)).eq.12.and.ncy2.eq.0) )kp(i)=0
      bez(i)=idat
      bez0(i)=idat
      if(ncy2.eq.0) then
        !If no active RF cavities are seen so far in the single element list,
        ! add a CAV element to the end of the list.
        ! This is then overwritten when reading the next element, so that if
        ! and only if no active RF cavities are found, a CAV element can be
        ! used in the structure to enable 6D tracking using the parameters
        ! from the SYNC block.
        i=i+1
        il=i
        bez(i)=cavi
        bez0(i)=cavi
        kp(i)=6
      else
        il=i
        i=i+1
      endif
      goto 130
!-----------------------------------------------------------------------
!  DATENBLOCK DISPLACEMENT OF ELEMENTS
!-----------------------------------------------------------------------
  170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 170
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      xpl0=zero
      xrms0=zero
      zpl0=zero
      zrms0=zero
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        xpl0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        xrms0=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zpl0=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zrms0=fround(errno,fields,5)
        nf=nf-1
      endif
      do 180 j=1,il
        if(idat.ne.bez(j)) goto 180
        xpl(j)=xpl0
        xrms(j)=xrms0
        zpl(j)=zpl0
        zrms(j)=zrms0
!----Insertion for AC dipole
        if(abs(kz(j)).eq.16) then
          nturn1(j)=int(xpl0)
          nturn2(j)=int(xrms0)
          nturn3(j)=int(zpl0)
          nturn4(j)=int(zrms0)
          xpl(j)=0d0
          xrms(j)=0d0
          zpl(j)=0d0
          zrms(j)=0d0
!hr05     if(xrms0.eq.0.and.zpl0.eq.0.and.zrms0.eq.0) then
          if(xrms0.eq.0d0.and.zpl0.eq.0d0.and.zrms0.eq.0d0) then         !hr05
            write(*,*) "ac dipole disregarded (0 length)"
            kz(j)=0
!hr05       ed(j)=0
            ed(j)=0d0                                                    !hr05
!hr05       ek(j)=0
            ek(j)=0d0                                                    !hr05
          endif
        endif
  180 continue
      goto 170
!-----------------------------------------------------------------------
!  BLOCK DEFINITIONS
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  190 if(imod.eq.1) then
  200   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 200
      endif
      if(imod.eq.2) then
  210   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 210
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) mper,(msym(k),k=1,mper)
      if(mper.gt.nper) call prror(17)
      i=0
  220 do 230 m=1,40
  230 ilm0(m)=idum
      if(imod.eq.1) then
  240   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 240
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  250   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 250
        if(ch(:4).eq.next) then
  260     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 260
          if(idat.ne.stru) then
            write(*,*)    "idat = '"//idat//""
            call prror(15)
          endif
          goto 320
        endif
      endif
      call intepr(2,1,ch,ch1)
! reading character strings so OK
      read(ch1,*) idat,(ilm0(m),m=1,40)
      if(idat.eq.idum) goto 270
      i=i+1 ! Current BLOC number
      if(i.gt.nblo-1) call prror(18)
      bezb(i)=idat
      k0=0
      mblo=i ! Update total number of BLOCs
  270 ka=k0+1
      ke=k0+40
      do 300 l=ka,ke
        if(l.gt.nelb) call prror(26)
        ilm(l)=ilm0(l-k0)
        if(ilm(l).eq.idum) goto 310
        mel(i)=l         ! Number of single elements in this block
        beze(i,l)=ilm(l) ! Name of the current single element
        do 280 j=1,il    ! Search for the single element idx j
          if(bez0(j).eq.ilm(l)) goto 290
  280   continue
        erbez=ilm(l)
        call prror(19)
  290   mtyp(i,l)=j ! Block i / sub-element l has single element index j
        if(kz(j).ne.8) elbe(i)=elbe(i)+el(j) ! Count block length (kz=8 -> edge
  300 continue
  310 k0=l-1
      goto 220
!-----------------------------------------------------------------------
!  STRUCTURE INPUT
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  320 i=0
  330 do 340 k=1,40
  340 ilm0(k)=idum
      if(imod.eq.1) then
  350   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 350
      endif
      if(imod.eq.2) then
  360   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 360
      endif
      if(ch(:4).eq.next) goto 110
      i2=1
      ! Look for repetition with syntax N( ... )
      do 420 ii=1,80
        if(ch(ii:ii).eq.kl) then !kl='('
          if(ii.gt.1) then
            do 370 jj=1,ii-1
  370       if(ch(jj:jj).ne.' ') goto 380
          endif
          iw=1
          goto 390
  380     read(ch(:ii-1),*) iw
  390     ia=i
          iw0=iw-1
          i2=ii+1
          goto 430
        endif
        if(ch(ii:ii).eq.kr) then !kr=')'
          if(iw0.le.0) goto 330
          idi=i-ia
          do 410 k=1,iw0
            do 400 j=1,idi
  400       ic(i+j)=ic(i+j-idi)
            i=i+idi
  410     continue
          mbloz=i
          goto 330
        endif
  420 continue
      ! Create the structure
  430 call intepr(3,i2,ch,ch1)
! reading character strings so OK
      read(ch1,*) (ilm0(k),k=1,40)
      do 490 k=1,40
        if(ilm0(k).eq.idum) goto 490
        if(ilm0(k).eq.go) goto 480
        i=i+1
        do 440 j=1,mblo !is it a BLOC?
          if(bezb(j).eq.ilm0(k)) goto 470
  440   continue
        do 450 l=1,il   !is it a SINGLE ELEMENT?
          if(bez0(l).eq.ilm0(k)) goto 460
  450   continue
        ! It was neither BLOC or SINGLE ELEMENT! ERROR!
        erbez=ilm0(k)
        call prror(20)
 
        ! Handle SINGLE ELEMENT
  460   continue
        ic(i)=l+nblo
        if(bez0(l).eq.cavi) icy=icy+1
        goto 490
 
        !Handle BLOC
  470   ic(i)=j
        goto 490
        !Handle GO
  480   kanf=i+1
  490 continue
      mbloz=i
      if(mbloz.gt.nblz-2) call prror(21)
      goto 330
!-----------------------------------------------------------------------
!  INITIAL COORDINATES
!-----------------------------------------------------------------------
  500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
        iclr=iclr+1
      else
        goto 500
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itra
          nf=nf-1
        endif
        if (nf.gt.0) then
          chi0=fround(errno,fields,2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          chid=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          rat=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
            read (fields(5),*) iver
            nf=nf-1
        endif
        if(itra.gt.2) call prror(40)
      endif
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.5) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.6) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.7) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.8) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.9) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.10) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.11) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.12) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.13) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.14) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          e0=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.15) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.eq.16) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
      if(iclr.ne.16) goto 500
      dp1=exz(1,6)
      iclr=0
      if(iver.ne.0.and.iver.ne.1) iver=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  TRACKING PARAMETERS
!-----------------------------------------------------------------------
  510 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
        iclr=iclr+1
      else
        goto 510
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) numl
        nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) numlr
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) napx
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp0=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(6),*) ird
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) imc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) niu(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) niu(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(10),*) numlcp
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(11),*) numlmax
          nf=nf-1
        endif
! and default nnmul to numl
        nnuml=numl
! and numlcp to 1000
        if(numlcp.eq.0) numlcp=1000
      endif
      if(iclr.eq.2) read(ch1,*) idz(1),idz(2),idfor,irew,iclo6
      if(iclr.eq.3) read(ch1,*) nde(1),nde(2),                          &
     &nwr(1),nwr(2),nwr(3),nwr(4),ntwin,ibidu,iexact
      if(iclo6.eq.5.or.iclo6.eq.6) then
        iclo6=iclo6-4
        iclo6r=1
      endif
      if(iclo6.eq.2.and.idfor.eq.0) idfor=1
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(iclr.ne.3) goto 510
      iclr=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  DIFFERENTIAL ALGEBRA
!-----------------------------------------------------------------------
  520 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 520
      ndum=ndum+1
      if(ch(:4).eq.next) then
        ndum=0
        goto 110
      endif
      if(ndum.eq.1) then
        ch1(:nchars+3)=ch(:nchars)//' / '
        idial=1
        numlr=0
        napx=1
        imc=1
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) nord
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(2),*) nvar
          nf=nf-1
        endif
        if (nf.gt.0) then
          preda=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(4),*) nsix
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(5),*) ncor
          nf=nf-1
        endif
        if(nvar.le.4) ition=0
        if(nord.le.0.or.nvar.le.0) call prror(91)
      else
        call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
        read(ch1,*) (ilm0(i),i=1,ncor)
      endif
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(nvar.ne.6) then
      nsix=0
      iclo6=0
      endif
      if(nvar.eq.5) then
        idp=1
        ition=1
        hsy(1)=zero
      endif
      if(ndum.eq.1) then
      if(nsix.ne.1) nsix=0
      if(nord.gt.nema) call prror(52)
      nvar2=nvar
      goto 520
      else
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
        do 540 j1=1,ncor
          do 530 j2=1,il
            if(ilm0(j1).eq.bez(j2)) then
              if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
              ipar(j1)=j2
              goto 540
            endif
  530     continue
          call prror(66)
  540   continue
      else
        ncor=0
        write(*,*)' '
        write(*,*)'NO EXTRA PARAMETERS FOR THE MAP SPECIFIED'
        write(*,*)' '
      endif
      ndum=0
      nvar=nvar2+ncor
      goto 110
      endif
!-----------------------------------------------------------------------
!  PRINTOUT INPUT PARAMETERS
!-----------------------------------------------------------------------
  550 iout=1
      goto 110
!-----------------------------------------------------------------------
!  CHROMATCITY ADJUSTMENT
!-----------------------------------------------------------------------
  560 ichrom=1
      ichrom0=0
      do 580 l=1,2
  570 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 570
      call intepr(1,1,ch,ch1)
      if(l.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) iss(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(3),*) ichrom0
          nf=nf-1
        endif
      endif
      if (l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iss(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
  580 continue
      do 590 j=1,il
      if(iss(1).eq.bez(j)) is(1)=j
  590 if(iss(2).eq.bez(j)) is(2)=j
      if(ichrom0.ge.1.and.ichrom0.le.3) ichrom=ichrom0
      goto 110
!-----------------------------------------------------------------------
!  TUNE ADJUSTMENT
!-----------------------------------------------------------------------
  600 iqmod=1
      do 630 l=1,3
  610 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 610
      if(ch(:4).eq.next) then
        if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni) then
          do 620 j=1,il
            if(iqq(1).eq.bez(j)) iq(1)=j
  620     if(iqq(2).eq.bez(j)) iq(2)=j
          goto 110
        else
          write(*,10370)
          iqmod=0
          iqmod6=0
          goto 110
        endif
      endif
      call intepr(1,1,ch,ch1)
      if(l.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) iqmod6
          nf=nf-1
        endif
        if(iqmod6.eq.1) then
          iqmod6=0
        elseif(iqmod6.eq.2) then
          iqmod6=1
          iqmod=0
        elseif(iqmod6.eq.3) then
          iqmod6=1
        endif
      endif
      if(l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
      if(l.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(3)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(3)=fround(errno,fields,2)
        nf=nf-1
        endif
      endif
  630 continue
  640 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 640
      call intepr(4,1,ch,ch1)
      read(ch1,*) iqq(4),iqq(5)
      if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni                  &
     &.and.abs(qw0(3)).gt.pieni) then
        do 650 j=1,il
          if(iqq(1).eq.bez(j)) iq(1)=j
          if(iqq(2).eq.bez(j)) iq(2)=j
          if(iqq(3).eq.bez(j)) iq(3)=j
          if(iqq(4).eq.bez(j)) kpa(j)=1
          if(iqq(5).eq.bez(j)) kpa(j)=2
 650    continue
        goto 110
      else
        write(*,10370)
        iqmod=0
        iqmod6=0
        write(*,*) 'TUNE ADJUSTED'
        goto 110
      endif
!-----------------------------------------------------------------------
!  LINEAR OPTICS CALCULATION
!  - in the 4D case (ilin=1) the subroutine linopt is called
!  - in the 6d case (ilin=2) the optics parameters are calculated and
!    printed in the subroutine umlauda (calculated in the common block
!    umlalid)
!-----------------------------------------------------------------------
 660  continue
      ilin0=1
      read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 660
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nt
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ilin0
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(4),*) ntco
        nf=nf-1
      endif
      if (nf.gt.0) then
        eui=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        euii=fround(errno,fields,6)
        nf=nf-1
      endif
      iprint=0
      if(idat.ne.'BLOCK'.and.idat.ne.'ELEMENT') call prror(45)
      if(idat.eq.'BLOCK') iprint=1
      ilin=1
      if(ilin0.ge.1.and.ilin0.le.3) ilin=ilin0
  670 do 680 m=1,40
  680 ilm0(m)=idum
  690 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 690
      if(ch(:4).eq.next) goto 110
      call intepr(2,1,ch,ch1)
! ilm0 are character strings, should be OK
      read(ch1,*) (ilm0(m),m=1,40)
      do 700 m=1,40
      if(ilm0(m).eq.idum) goto 700
      nlin=nlin+1
      if(nlin.gt.nele) call prror(81)
      bezl(nlin)=ilm0(m)
  700 continue
      goto 670
!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!-----------------------------------------------------------------------
  710 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 710
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          harm=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          alc=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          u0=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          phag=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          tlen=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          pma=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ition
          nf=nf-1
        endif
        if (nf.gt.0) then
          dppoff=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          dpscor=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          sigcor=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
      if(iclr.ne.2) goto 710
      iclr=0
      if(abs(pma-pmap).le.c1m1) pmat=pmap
      if(abs(pma-pmae).le.c1m1) pmat=pmae
      if(pmat.ne.pmap.and.pmat.ne.pmae) then
        write(*,*)
        write(*,*) 'Warning: Particle is neither proton nor electron'
        write(*,*)
      endif
      if(pma.lt.pieni) call prror(27)
!hr05 crad=crade*pmae/pma
      crad=(crade*pmae)/pma                                              !hr05
      if(abs(tlen).le.pieni) call prror(25)
      if(ncy2.eq.0) then
        ncy=icy*mper
        idp=1
        if(ncy.ne.0) goto 720
        idp=0
        write(*,10130)
        write(*,10340)
  720   phas=phag*rad
        if(ncy.ne.0) then
          hsy(1)=u0/dble(ncy)
        else
          hsy(1)=u0
        endif
        if(nvar.eq.5) then
          idp=1
          ition=1
          hsy(1)=zero
        endif
        halc=harm*alc
        halc2=harm/tlen
!hr05   hsy(3)=two*pi*halc2
        hsy(3)=(two*pi)*halc2                                            !hr05
        cosy=cos_rn(phas)
!hr05   qigam=pma*pma/e0/e0
        qigam=(pma**2/e0)/e0                                             !hr05
        qbet=one-qigam
!hr05   halc3=-(qigam-alc)*ition*harm*u0/e0*cosy/(two*pi*qbet)
        halc3=((((((-1d0*(qigam-alc))*dble(ition))*harm)*u0)/e0)*cosy)/ &!hr05
     &((two*pi)*qbet)                                                    !hr05
        if(halc3.lt.zero) call prror(28)
        qs=sqrt(halc3)
      else
        idp=1
        ncy=0
        do 725 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(abs(kz(ix)).eq.12) ncy=ncy+1
          endif
  725   continue
        do 730 j=1,il
          if(abs(kz(j)).eq.12) then
!hr05       hsyc(j)=two*pi*ek(j)/tlen
            hsyc(j)=((two*pi)*ek(j))/tlen                                !hr05
            if(nvar.eq.5) then
              ition=1
              ed(j)=zero
            endif
          endif
  730   continue
      endif
      goto 110
!-----------------------------------------------------------------------
!  MULTIPOLE COEFFICIENTS  FOR KZ = 11
!-----------------------------------------------------------------------
  740 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 740
      ! Get first data line: name, R_0, \delta_0
      call intepr(1,1,ch,ch1)
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) imn
        nf=nf-1
      endif
      if (nf.gt.0) then
        r0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        benki=fround(errno,fields,3)
        nf=nf-1
      endif
      ! Renaming variables?
      i=1
      r0a=one
      im=im+1
      benkc(im)=benki
      r00(im)=r0
      ! Find single element which matches the name, set its
      ! irm from the MULT block counter im.
      do 750 j=1,il
      if(imn.eq.bez(j)) then
        irm(j)=im
        goto 760
      endif
  750 continue
  760 write(*,10130)
      write(*,10210) imn,r0,benki
      ! Read data lines: B_n rms-B_n A_n rms-A_n
  770 bk0d=zero
      bkad=zero
      ak0d=zero
      akad=zero
  780 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 780
      if(ch(:4).eq.next) goto 110
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        bk0d=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bkad=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ak0d=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        akad=fround(errno,fields,4)
        nf=nf-1
      endif
      ! Set nmu for the current single element (j)
      ! to the currently highest multipole seen (i)
      if(abs(bk0d).gt.pieni.or.abs(bkad).gt.pieni                       &
     &.or.abs(ak0d).gt.pieni.or.abs(akad).gt.pieni) nmu(j)=i
      write(*,10220) i,bk0d,bkad,ak0d,akad
!hr05 bk0(im,i)=benki*bk0d/r0a
      bk0(im,i)=(benki*bk0d)/r0a                                         !hr05
!hr05 ak0(im,i)=benki*ak0d/r0a
      ak0(im,i)=(benki*ak0d)/r0a                                         !hr05
!hr05 bka(im,i)=benki*bkad/r0a
      bka(im,i)=(benki*bkad)/r0a                                         !hr05
!hr05 aka(im,i)=benki*akad/r0a
      aka(im,i)=(benki*akad)/r0a                                         !hr05
      i=i+1
      r0a=r0a*r0
      if(i.gt.mmul+1) call prror(105)
      if(ch(:4).ne.next) goto 770 ! loop
      write(*,10380)
      write (*,*) 'BENKI done'
      goto 770
!-----------------------------------------------------------------------
!  FLUCTUATION RANDOM STARTING NUMBER
!-----------------------------------------------------------------------
  790 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 790
      ! Read izu0, mmac, mout, mcut
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) izu0, mmac, mout, mcut
      mcut=iabs(mcut)
      if(mmac.gt.nmac) call prror(55)
      !Generate normal distributed random numbers into zfz
      call recuin(izu0,irecuin)
      call ranecu(zfz,nzfz,mcut)
      rsum=zero
      do 800 i=1,nzfz
  800 rsum=rsum+zfz(i)
!hr05 rmean=rsum/nzfz
      rmean=rsum/dble(nzfz)                                              !hr05
      rsqsum=zero
      do 810 i=1,nzfz
  810 rsqsum=rsqsum+(zfz(i)-rmean)**2                                    !hr05
!hr05  810 rsqsum=rsqsum+(zfz(i)-rmean)*(zfz(i)-rmean)
!hr05 rdev=sqrt(rsqsum/nzfz)
      rdev=sqrt(rsqsum/dble(nzfz))                                       !hr05
      write(*,10410) izu0,nzfz,rmean,rdev
      if(mcut.eq.0) write(*,10430)
      if(mcut.gt.0) write(*,10440) mcut
      write(*,10130)
      ! Set flags mout1, mout2, mount3, mout4 depending on mout
      ! Enables/disables different functionality
      if(mout.ge.8) mout4=1
      if(mout.eq.7.or.mout.eq.15) then
        mout1=1
        mout2=1
        mout3=1
      else if(mout.eq.6.or.mout.eq.14) then
        mout2=1
        mout3=1
      else if(mout.eq.5.or.mout.eq.13) then
        mout1=1
        mout3=1
      else if(mout.eq.4.or.mout.eq.12) then
        mout3=1
      else if(mout.eq.3.or.mout.eq.11) then
        mout1=1
        mout2=1
      else if(mout.eq.2.or.mout.eq.10) then
        mout2=1
      else if(mout.eq.1.or.mout.eq.9) then
        mout1=1
      endif
 
      ! Reads from fort.16 IF mout1==1
      if(mout1.eq.1) then
        write(*,*)
        write(*,*) '          Multipole errors read in ' ,              &
     &'from external file'
        write(*,*)
        iexread=0 ! Reading regular multipoles(1) or skew components (2)
        ifiend16=0
        iexnum=0
        read(16,10020,end=861)
        rewind 16
 
        do 860 i=1,mper*mbloz ! Loop over all structure elements
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend16.eq.0) then
                read(16,10020,end=820,iostat=ierro) ch
                lineno16=lineno16+1
              else
                goto 820
              endif
              call intepr(3,1,ch,ch1) ! Read the name of element
! ilm0 are character strings, should be OK
              read(ch1,*) ilm0(1)
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 840
  820         ifiend16=1
              if(iexnum.eq.0) call prror(80)
              do 830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
  830         continue
  840         continue
            endif ! closing if(iexread.eq.0) then
            if(ilm0(1).eq.bez(ix)) then
              icext(i)=ix
              do 850 k=1,40
                exterr(i,k)=extaux(k)
  850         continue
              iexread=0
              goto 860
            endif
          endif
  860   continue
  861   continue
        write(*,*) '        From file fort.16 :',iexnum,                &
     &' values read in.'
        write(*,*)
      endif
      if(mout3.eq.1) then
        write(*,*)
        write(*,*) '          Alignment errors read in ' ,              &
     &'from external file'
        write(*,*)
        iexread=0
        ifiend8=0
        iexnum=0
        read(8,10020,end=1581)
        rewind 8
        do 1580 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(8,10020,end=1550,iostat=ierro) ch
                if(ierro.gt.0) call prror(86)
                lineno8=lineno8+1
              else
                goto 1550
              endif
              call intepr(1,1,ch,ch1)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
              call splitfld(errno,8,lineno8,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignx=fround(errno,fields,2)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignz=fround(errno,fields,3)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tilt=fround(errno,fields,4)
                nf=nf-1
              endif
!             alignx=DBLE(SNGL(alignx))
!             alignz=DBLE(SNGL(alignz))
!             tilt=DBLE(SNGL(tilt))
!             call roundnulp(alignx,1024)
!             call roundnulp(alignz,1024)
!             call roundnulp(tilt,1024)
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1570
 1550         ifiend8=1
              if(iexnum.eq.0) call prror(86)
              do 1560 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(86)
 1560         continue
 1570         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1580
            endif
          endif
 1580   continue
 1581   continue
        write(*,*) '        From file fort.8 :',iexnum,                 &
     &' values read in.'
        write(*,*)
      endif
      izu=0
      iexnum=0
      if(mout4.eq.1) then
        read(30,10020,end=1591)
        rewind 30
        do 1590 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 1590
            izu=izu+3
            read(30,10020,end=1591,iostat=ierro) ch
            if(ierro.gt.0) call prror(87)
            lineno30=lineno30+1
            call intepr(1,1,ch,ch1)
            read(ch1,*) ilm0(1),zfz(izu-2)
            iexnum=iexnum+1
            if(kz(ix).eq.11) izu=izu+2*mmul
          endif
 1590   continue
        if(iexnum.gt.0) then
          write(*,*)
          write(*,*) '          Single (random) kick errors read in ' , &
     &'from external file'
          write(*,*)
          write(*,*) '        From file fort.30 :',iexnum,              &
     &' values read in.'
          write(*,*)
        endif
        iexread=0
        ifiend8=0
        iexnum=0
        rewind 30
        do 1593 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
 1595         ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(30,10020,end=1594,iostat=ierro) ch
                if(ierro.gt.0) call prror(87)
                lineno30=lineno30+1
              else
                goto 1594
              endif
              call intepr(1,1,ch,ch1)
              read(ch1,*) ilm0(1),dummy,alignx,alignz,tilt
!hr05         if((abs(alignx)+abs(alignz)+abs(tilt)).le.pieni)          &
              if(((abs(alignx)+abs(alignz))+abs(tilt)).le.pieni)        &!hr05
     &goto 1595
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1596
 1594         ifiend8=1
              do 1597 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(87)
 1597         continue
 1596         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1593
            endif
          endif
 1593   continue
 1591   continue
      endif
      goto 110
  870 call prror(80)
!-----------------------------------------------------------------------
!  ORGANISATION OF RANDOM NUMBERS
!-----------------------------------------------------------------------
  880 write(*,10130)
      write(*,10350)
      do 890 i=1,3
      do 890 j=1,nele
  890 bezr(i,j)=idum !Initialize all bezr to idum=' '
 
  900 iorg=iorg+1
  910 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 910
      if(ch(:4).eq.next) goto 110
      call intepr(3,1,ch,ch1)
      ! bezr are character strings, should be OK
      read(ch1,*) idat,bezr(2,iorg),bezr(3,iorg)
      if(idat.ne.next) then !Isn't this already checked for above?
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).eq.idum)
     &        write(*,10360)    idat
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).ne.idum)
     &        write(*,10390)    idat,bezr(2,iorg)
         if(idat.ne.mult)
     &        bezr(1,iorg)=idat
         if(idat.eq.mult.and.
     &        bezr(2,iorg).ne.idum.and.bezr(3,iorg).ne.idum) then
            write(*,10400)    bezr(2,iorg),bezr(3,iorg)
            im=im+1
            j0=0
            j1=0
            do 920 i=1,il
               if(bez(i).eq.bezr(2,iorg)) j1=i
 920           if(bez(i).eq.bezr(3,iorg)) j0=i
            if(j0.eq.0.or.j1.eq.0.or.kz(j0).ne.11.or.kz(j1).ne.11)          &
     &              call prror(29)
 
            irm(j0)=im
            benkc(j0)=benkc(j1)
            r00(j0)=r00(j1)
            imo=irm(j1)
            nmu(j0)=nmu(j1)
            do 930 i1=1,nmu(j0)
               bk0(im,i1)=bk0(imo,i1)
               bka(im,i1)=bka(imo,i1)
               ak0(im,i1)=ak0(imo,i1)
 930           aka(im,i1)=aka(imo,i1)
 
         endif
         goto 900
      endif
      write(*,10130)
      goto 110
!-----------------------------------------------------------------------
!  ITERATION ERRORS FOR CLOSED ORBIT ,TUNE ADJUSTMENT AND CHROMATICITY
!-----------------------------------------------------------------------
  940 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 940
      endif
      if(ch(:4).eq.next) then
      iclr=0
      goto 110
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itco
        endif
        if (nf.gt.0) then
          dma=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dmap=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itqv
          nf=nf-1
        endif
        if (nf.gt.0) then
          dkq=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dqq=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itcro
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsm0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dech=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          de0=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          ded=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsi=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(2)=fround(errno,fields,5)
          nf=nf-1
        endif
      endif
      if(iclr.ne.4) goto 940
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  APERTURE LIMITATIONS
!-----------------------------------------------------------------------
  950 write(*,10320)
  960 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 960
      apxx=zero
      apzz=zero
      call intepr(8,1,ch,ch1)
 
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) irel
        nf=nf-1
      endif
      if (nf.gt.0) then
        apxx=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        apzz=fround(errno,fields,4)
          nf=nf-1
      endif
      do 970 j=1,il
      if(idat.ne.bez(j)) goto 970
      kp(j)=1
      if(irel.eq.rect) kp(j)=2
      apx(j)=apxx
      apz(j)=apzz
      if(irel.eq.rect) then
        kp(j)=3
!hr05   ape(1,j)=apzz*apzz
        ape(1,j)=apzz**2                                                 !hr05
!hr05   ape(2,j)=apxx*apxx
        ape(2,j)=apxx**2                                                 !hr05
!hr05   ape(3,j)=apxx*apxx*apzz*apzz
        ape(3,j)=apxx**2*apzz**2                                         !hr05
      endif
      write(*,10330) bez(j),irel,apxx,apzz
  970 continue
! Eric temporary fix for BUG??? Uncommnted for Riccardo 14/2/2015
      if(idat.ne.next) goto 960
      goto 110
!-----------------------------------------------------------------------
!  ORBIT CORRECTION
!-----------------------------------------------------------------------
  980 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 980
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        sigma0(1)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sigma0(2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) ncorru
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ncorrep
        nf=nf-1
      endif
      iclo=1
  990 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 990
      iele=idum
      call intepr(4,1,ch,ch1)
! integers so should be OK
      read(ch1,*) idat,iele
      if(idat.eq.next) goto 110
      if(idat.ne.'HMON='.and.idat.ne.'HCOR='.and. idat.ne.'VMON='.and.  &
     &idat.ne.'VCOR=') call prror(44)
      if(idat.eq.'HMON='.or.idat.eq.'VMON=') goto 1010
      do 1000 j=1,il
      if(iele.ne.bez(j)) goto 1000
      if(idat.eq.'HCOR=') then
        if(kp(j).eq.-4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.1.and.kz(j).ne.11) call prror(82)
        kp(j)=4
      endif
      if(idat.eq.'VCOR=') then
        if(kp(j).eq.4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.-1.and.kz(j).ne.11) call prror(82)
        kp(j)=-4
      endif
 1000 continue
      goto 990
 1010 do 1020 j=1,il
      if(iele.ne.bez(j)) goto 1020
      if(idat.eq.'HMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.-3) call prror(83)
        kp(j)=3
      endif
      if(idat.eq.'VMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.3) call prror(83)
        kp(j)=-3
      endif
 1020 continue
      goto 990
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
 1030 ii=0
      do 1040 jj=1,ncom
      do 1040 ll=1,20
 1040 icel(jj,ll)=idum
      write(*,10130)
      write(*,10300)
 1050 ii=ii+1
      if(ii.gt.ncom) goto 1100
 1060 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1060
      if(ch(:4).eq.next) goto 110
      icoe=ii
      call intepr(5,1,ch,ch1)
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      do l=1,20
        if (nf.gt.0) then
          ratio(ii,l)=fround(errno,fields,l*2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(l*2+1),*) icel(ii,l)
          nf=nf-1
        endif
      enddo
      do 1080 j=1,il
      if(idat.ne.bez(j)) goto 1070
      kp(j)=5
      icomb0(ii)=j
      ratioe(j)=one
 1070 do 1080 l=1,20
        if(bez(j).eq.icel(ii,l)) then
          icomb(ii,l)=j
          ratioe(j)=ratio(ii,l)
        endif
 1080 continue
      jj=icomb0(ii)
      if(jj.eq.0) goto 1050
      do 1090 m=1,20
        ico=icomb(ii,m)
        if(ico.eq.jj) call prror(92)
        if(ico.eq.0) goto 1090
        write(*,10310) bez(jj),bez(ico),ratio(ii,m)
        iratioe(ico)=jj
        if(el(jj).le.pieni) then
          if(el(ico).le.pieni) then
            ed(ico)=ed(jj)*ratio(ii,m)
          else
            ek(ico)=ed(jj)*ratio(ii,m)
          endif
        else
          if(el(ico).le.pieni) then
            ed(ico)=ek(jj)*ratio(ii,m)
          else
            ek(ico)=ek(jj)*ratio(ii,m)
          endif
        endif
 1090 continue
      goto 1050
 1100 write(*,10290) ncom
      goto 110
!-----------------------------------------------------------------------
!  SUBRESONANCE CALCULATION
!-----------------------------------------------------------------------
 1110 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1110
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nta
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nte
        qxt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(7),*) ipt
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,8)
        nf=nf-1
      endif
      if(nta.lt.2) call prror(37)
      if(nte.lt.nta.or.nte.gt.9) call prror(37)
      isub=1
      goto 110
!-----------------------------------------------------------------------
!  RESONANCE-COMPENSATION
!-----------------------------------------------------------------------
 1120 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1120
      ch1(:nchars+3)=ch(:nchars)//' / '
! all integers so should be OK
      read(ch1,*) nre
      if(nre.ne.0) read(ch1,*) nre,npp,nrr(1),nrr(2),nrr(3),            &
     &ipr(1),ipr(2),ipr(3)
      if(nre.ne.0.and.(npp.lt.2.or.npp.gt.nrco)) call prror(46)
      if(nre.lt.0.or.nre.gt.3) call prror(47)
      if(abs(nrr(1)).gt.npp.or.abs(nrr(2)).gt.npp                       &
     &.or.abs(nrr(3)).gt.npp) call prror(48)
 1130 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1130
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nur
      if(nur.ne.0) read(ch1,*) nur,nu(1),nu(2),nu(3)
      if(nur.lt.0.or.nur.gt.3) call prror(49)
      if(nu(1).gt.9.or.nu(2).gt.9.or.nu(3).gt.9                         &
     &.or.nu(1).lt.0.or.nu(2).lt.0.or.nu(3).lt.0) call prror(50)
 1140 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1140
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        totl=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qxt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,5)
        nf=nf-1
      endif
 1150 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1150
      call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
      read(ch1,*) (ilm0(i),i=1,6)
 1160 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1160
      call intepr(6,1,ch,ch1)
      read(ch1,*) nch
      if(nch.ne.0) read(ch1,*) nch,ilm0(7),ilm0(8)
 1170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1170
      call intepr(7,1,ch,ch1)
      read(ch1,*) nqc
      if(nqc.ne.0) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) nqc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) ilm0(9)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ilm0(10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,4)
          nf=nf-1
        endif
      endif
      do 1190 k=1,10
      do 1180 j=1,il
        if(ilm0(k).ne.bez(j)) goto 1180
        ire(k)=j
        if(nre.eq.1.and.k.lt.3.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.2.and.k.lt.5.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.3.and.k.lt.7.and.abs(kz(j)).ne.npp) call prror(39)
        if(nch.eq.1.and.(k.eq.7.or.k.eq.8).and.kz(j).ne.3) call prror   &
     &(11)
        if(nqc.eq.1.and.(k.eq.9.or.k.eq.10).and.kz(j).ne.2) call prror  &
     &(8)
        goto 1190
 1180 continue
      if((nre.eq.1.and.k.lt.3).or.(nre.eq.2.and.k.lt.5).or.             &
     &(nre.eq.3.and.k.lt.7).or.(nch.eq.1.and.(k.eq.7.or.k.eq.8)).or.    &
     &(nqc.eq.1.and.(k.eq.9.or.k.eq.10))) call prror(3)
 1190 continue
      irmod2=1
      goto 110
!-----------------------------------------------------------------------
!  SEARCH FOR OPTIMUM PLACES TO COMPENSATE RESONANCES
!-----------------------------------------------------------------------
 1200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1200
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        qxt=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
          tam2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,5)
        nf=nf-1
      endif
 1210 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1210
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) mesa,mp,m21,m22,m23,ise1,ise2,ise3
      if(mp.lt.2.or.mp.gt.9) call prror(37)
      if(abs(m21).gt.mp.or.abs(m22).gt.mp                               &
     &.or.abs(m23).gt.mp) call prror(48)
      ise=1
      k0=0
 1220 do 1230 m=1,40
 1230 ilm0(m)=idum
 1240 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1240
      call intepr(3,1,ch,ch1)
! character strings so should be OK
      read(ch1,*) idat,(ilm0(m),m=2,40)
      if(idat.eq.next) goto 110
      ilm0(1)=idat
      ka=k0+1
      ke=k0+40
      do 1260 k=ka,ke
      if(k.gt.nele) call prror(2)
      if(k.gt.mesa) goto 110
      ki=k-k0
      if(ilm0(ki).eq.idum) goto 1270
      do 1250 j=1,il
        if(ilm0(ki).ne.bez(j)) goto 1250
        isea(k)=j
        if(abs(kz(j)).ne.mp) call prror(39)
        goto 1260
 1250 continue
      call prror(3)
 1260 continue
 1270 k0=k-1
      goto 1220
!-----------------------------------------------------------------------
!  POSTPROCESSING
!-----------------------------------------------------------------------
 1280 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 1280
      endif
      ch1(:83)=ch(:80)//' / '
      if(iclr.eq.1) toptit(1)=ch
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iav
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) nstart
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) nstop
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) iwg
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphix=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphiz=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) iconv
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) imad
        nf=nf-1
        endif
        if (nf.gt.0) then
          cma1=fround(errno,fields,10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cma2=fround(errno,fields,11)
          nf=nf-1
        endif
      endif
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          qx0=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qz0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ivox
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) ivoz
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(5),*) ires
          nf=nf-1
        endif
        if (nf.gt.0) then
          dres=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ifh
          nf=nf-1
        endif
        if (nf.gt.0) then
          dfft=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
      if(iclr.eq.4) read(ch1,*) kwtype,itf,icr,idis,icow,istw,iffw,     &
     &nprint,ndafi
      kwtype=0
      icr=0
      if(iskip.le.0) iskip=1
      if(iclr.ne.4) goto 1280
      if(nprint.ne.1) nprint=0
      iclr=0
      if(nstart.lt.0) nstart=0
      if(nstop.lt.0) nstop=0
      if(nstop.lt.nstart) then
      nstart=0
      nstop=0
      endif
      if(iconv.ne.1) iconv=0
      if(abs(cma1).le.pieni) cma1=one
      cma1=cma1*c1e3
      if(abs(cma2).le.pieni) cma2=one
      ipos=1
      goto 110
!-----------------------------------------------------------------------
!  POWER SUPPLY RIPPLE
!-----------------------------------------------------------------------
 1290 continue
      write(*,*)
      write(*,*) "     old RIPP module is not supported anymore"
      write(*,*) "     ignoring all concerned lines"
      write(*,*)
 1300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
 
      write(*,*) 'ignoring line:'
      write(*,*) ch
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1300
      if(ch(:4).eq.next) goto 110
      goto 1300
!-----------------------------------------------------------------------
!  DECOUPLING ROUTINE
!-----------------------------------------------------------------------
 1320 iskew=1
 1330 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1330
      call intepr(3,1,ch,ch1)
! character strings again
      read(ch1,*) idat,(ilm0(m),m=2,4)
      if(idat.eq.next) then
      iskew=0
      goto 110
      endif
      ilm0(1)=idat
      do 1350 i=1,2
 1340 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1340
      if(ch(:4).eq.next) then
        iskew=2
        goto 1360
      endif
      call intepr(1,1,ch,ch1)
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) ilm0(4+i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qwsk(i)=fround(errno,fields,2)
        nf=nf-1
      endif
 1350 continue
 1360 continue
      do 1380 i=1,6
      do 1380 j=1,il
        if(iskew.eq.2.and.i.gt.4) goto 1380
        if(ilm0(i).eq.bez(j)) then
          if(i.le.4) then
            if(kz(j).ne.-2) call prror(62)
          else
            if(kz(j).ne.2) call prror(8)
          endif
          nskew(i)=j
          do 1370 i2=1,6
            if(nskew(i2).ne.0.and.(nskew(i2).eq.nskew(i)) .and.(i2.ne.i)&
     &) call prror(63)
 1370     continue
        endif
 1380 continue
      goto 110
!GRD-----------------------------------------------------------------------
!  COLLIMATION INPUT BLOCK
!GRD-----------------------------------------------------------------------
 1285 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      write(*,*)
      write(*,*)    "     collimation not forseen in this version"
      write(*,*)    "     please use proper version"
      write(*,*)
 1287 continue
      if(ch(:4).eq.next) goto 110
      read(3,10020,end=1530,iostat=ierro) ch
      lineno3=lineno3+1
      goto 1287
!-----------------------------------------------------------------------
!  COMMENT LINE
!-----------------------------------------------------------------------
 1390 read(3,10020,end=1530,iostat=ierro) commen
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(commen(1:1).eq.'/') goto 1390
      if(commen(:4).eq.next) then
      commen=' '
      endif
      goto 110
!-----------------------------------------------------------------------
!  NORMAL FORMS
!-----------------------------------------------------------------------
 1400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1400
      if(ch(:4).eq.next) then
      goto 110
      else
      if(idial.eq.0.and.numl.ne.0) then
        write(*,10130)
        write(*,*)
        call prror(78)
      endif
      inorm=1
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nordf,nvarf,nord1,idptr
      if(nord.ne.0.and.nordf.gt.nord+1) imod1=1
      if(nvar.ne.0.and.nvarf.gt.nvar) then
        nvarf=nvar
        imod2=1
      endif
      if(idptr.lt.0.or.idptr.gt.6) idptr=0
      endif
!-----------------------------------------------------------------------
!  TUNESHIFT CORRECTIONS
!-----------------------------------------------------------------------
 1410 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1410
      if(ch(:4).eq.next) goto 110
      icorr=1
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nctype,ncor
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
      read(3,10020,end=1530,iostat=ierro) ch
      lineno3=lineno3+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call intepr(3,1,ch,ch1)
! coel are character strings so should be OK
      read(ch1,*) (coel(i),i=1,ncor)
      do 1430 j1=1,ncor
        do 1420 j2=1,il
          if(coel(j1).eq.bez(j2)) then
            if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
            ipar(j1)=j2
            goto 1430
          endif
 1420   continue
        call prror(66)
 1430 continue
      else
      call prror(70)
      endif
      if(nctype.eq.0) then
      read(3,*) namp,nmom,dummy,dummy,dummy
      lineno3=lineno3+1
      if(namp+nmom.eq.0) call prror(71)
      if(namp*nmom.ne.0) call prror(72)
      if(namp.lt.0.or.namp.gt.2) call prror(73)
      if(nmom.lt.0.or.nmom.eq.1.or.nmom.gt.3) call prror(74)
      if(namp.eq.1.or.nmom.eq.2) then
        nord=6
      else
        nord=7
      endif
      else
      read(3,*) ch1
      lineno3=lineno3+1
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nmom1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nmom2
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        dpmax=fround(errno,fields,5)
        nf=nf-1
      endif
      if(nmom1.lt.2.or.nmom1.gt.3) call prror(75)
      if(nmom1.gt.nmom2) call prror(76)
      if(nmom2.lt.2.or.nmom2.gt.3) call prror(77)
      nord=2*(nmom2+1)
      endif
!-----------------------------------------------------------------------
      idial=1
      numlr=0
      napx=1
      imc=1
      preda=1.d-38
      nsix=1
      nvar=5
      nvar2=nvar
      nvar=nvar2+ncor
!-----------------------------------------------------------------------
      inorm=1
      nordf=nord+1
      nvarf=nvar
!-----------------------------------------------------------------------
      goto 1410
!-----------------------------------------------------------------------
!  Beam-Beam Element
!-----------------------------------------------------------------------
 1600 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1600
      if(ch(:4).eq.next) goto 110
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        partnum=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        emitnx=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        emitny=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sigz=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sige=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(6),*) ibeco
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(7),*) ibtyp
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(8),*) lhc
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(9),*) ibbc
        nf=nf-1
      endif
      if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
      if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
      if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
!GRD-2007
      if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
!GRD-2007
      if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
      nbeam=1
      if(ibtyp.eq.1) call wzset
 1610 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1610
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) i
        nf=nf-1
      endif
      if (nf.gt.0) then
        xang=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        xplane=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        xstr=fround(errno,fields,5)
        nf=nf-1
      endif
      if(i.lt.0) i=0
      do 1620 j=1,il
      if(idat.eq.bez(j).and.kz(j).eq.20) then
        ibb6d=1
!hr12   parbe(j,2)=i
        parbe(j,2)=dble(i)                                               !hr12
        parbe(j,1)=xang
        parbe(j,3)=xplane
        parbe(j,5)=xstr
        goto 1610
      endif
 1620 continue
      goto 1610
!-----------------------------------------------------------------------
!  TROMBONE ELEMENT KZ=22
!-----------------------------------------------------------------------
 1700 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1700
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      read(ch1,*) imn
      imtr0=imtr0+1
      if(imtr0.gt.ntr) call prror(100)
      do 1710 j=1,il
        if(imn.eq.bez(j)) then
          imtr(j)=imtr0
          goto 1720
        endif
 1710 continue
      call prror(98)
 1720 j1=0
      if(imtr0.eq.1) write(*,10130)
      if(imtr0.eq.1) write(*,10700)
      write(*,10710) imtr0,imn
 1730 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1730
      if(ch(:4).eq.next) call prror(99)
      ch1(:nchars+3)=ch(:nchars)//' / '
      j1=j1+3
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cotr(imtr0,j1-2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1-1)=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1)=fround(errno,fields,3)
        nf=nf-1
      endif
      if(j1.lt.6) goto 1730
      do j=1,6
        j1=0
 1740   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 1740
        if(ch(:4).eq.next) call prror(99)
        ch1(:nchars+3)=ch(:nchars)//' / '
        j1=j1+3
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-1)=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1)=fround(errno,fields,3)
        nf=nf-1
      endif
        if(j1.lt.6) goto 1740
      enddo
      goto 1700
!-----------------------------------------------------------------------
!  DUMP BEAM POPULATION
!  A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!  K.Sjobak, BE-ABP/HSS
!  last modified: 03-09-2015
!  always in main code
!-----------------------------------------------------------------------
 2000 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 ! Line number used for some crash output
 
      if(ch(1:1).eq.'/') goto 2000 !Skip comment line
 
      !Done with DUMP, write out!
      if(ch(:4).eq.next) then
        ! HEADER
        write(*,10460) dump
        write(*,*)    ''
        write(*,*)    '       The last column states the format'
        write(*,*)    '            of the output file (see Twiki page):'
        write(*,*)    '       ==0 -> regular output (default)'
        write(*,*)    '       ==1 -> special one, for post-processing'
        write(*,*)    '              with LHC Coll Team tools'
        write(*,*)    '       ==2 -> as 1, but add z as column 8'
 
        ! ldump(0)=.true. : DUMP all elements found
        if ( ldump(0) ) then
!           write(*,'(t10,a50)')
!     &          ' required dump at ALL SINGLE ELEMENTs'
           write(*,10470) 'ALL SING. ELEMS.', ndumpt(0),
     &          dumpunit(0), dump_fname(0), dumpfmt(0),
     &          dumpfirst(0), dumplast(0)
        endif
        do ii=1,il
          if(ldump(ii)) then
            write(*,10470)
     &     bez(ii), ndumpt(ii), dumpunit(ii),dump_fname(ii),dumpfmt(ii),
     &     dumpfirst(ii), dumplast(ii)
 
!           At which structure indices is this single element found? (Sanity che
            kk = 0
            do jj=1,mper*mbloz      ! Loop over all structure elements
              if ( ic(jj)-nblo .eq. ii ) then
                write (ch1,*) jj    ! internal write for left-adjusting
                write (*,10472)
     &               " -> Found as structure element no. "
     &               // trim(adjustl(ch1))
                kk = kk + 1
              end if
            end do
            if (kk .eq. 0) then
               write (*,10472)    " !! Warning: No structure elements "
     &              // "found for '" // bez(ii) // "'!"
               write (*,10472)
     &              " !! This element is probably only found"
     &              // " in a BLOC, or it is not used at all."
               write (*,10472)    " !! Please fix your DUMP block"
     &              // " in fort.3"
               call prror(-1)
            endif
          endif
        enddo
 
        if ( ldumphighprec ) then
          write(*,*)    ''
          write(*,*)    '        --> requested high precision dumping!'
        endif
        if ( ldumpfront ) then
          write(*,*)    ''
          write(*,*)    '        --> requested FRONT dumping!'
 
        endif
        goto 110
      endif
 
!     initialise reading variables, to avoid storing non sense values
      idat = ' '
      i1 = 0  ! frequency
      i2 = 0  ! unit
      i3 = 0  ! format
      i4 = 1  ! first turn
      i5 = -1 ! last turn
 
      if(ch(:4).eq.'HIGH') then
        ldumphighprec = .true.
        goto 2000
      else if(ch(:5).eq.'FRONT') then
         ldumpfront = .true.
         goto 2000
      endif
 
!     requested element
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) call prror(-1)
 
      if ( (getfields_nfields .lt. 4) .or.
     &     (getfields_nfields .gt. 7) .or.
     &     (getfields_nfields .eq. 6)      ) then
         write(*,*)    "ERROR in DUMP:"
         write(*,*)    "Expected 4 to 7 (but not 6)arguments, got",
     &        getfields_nfields
         write(*,*)
     &        ("'"//getfields_fields(kk)(1:getfields_lfields(kk))//"' ",
     &        kk=1,getfields_nfields)
         call prror(-1)
      endif
      if (getfields_lfields(1) > 16) then
         write(*,*)    "ERROR in DUMP:"
         write(*,*)    "element names are max. 16 characters"
         call prror(-1)
 
      endif
      idat = getfields_fields(1)(1:getfields_lfields(1))
      read(getfields_fields(2)(1:getfields_lfields(2)),*) i1
      read(getfields_fields(3)(1:getfields_lfields(3)),*) i2
      read(getfields_fields(4)(1:getfields_lfields(4)),*) i3
      if (getfields_nfields .eq. 4) then
         !Automatic fname
         write(ch1,"(a5,I0)") "fort.", i2
      else if ( (getfields_nfields .eq. 5) .or.
     &          (getfields_nfields .eq. 7)     ) then
         !Given fname
         ch1 = getfields_fields(5)(1:getfields_lfields(5))
      else
         !ERROR
         call prror(-1)
      endif
      if (getfields_nfields .eq. 7) then
         read(getfields_fields(6)(1:getfields_lfields(6)),*) i4
         read(getfields_fields(7)(1:getfields_lfields(7)),*) i5
      endif
 
!Check that first/last turn is sane
      if ( i5.ne.-1 ) then
         if ( i5 .lt. i4 ) then
            write(*,*)
     &           "Error in DUMP: Expect last turn >= first turn, ",
     &           "unless last turn = -1 (infinity), got", i4,i5
           call prror(-1)
         endif
      endif
      if ( i4 .lt. 1 ) then
         write(*,*)
     &        "Error in DUMP: Expect first turn >= 1, got", i4
         call prror(-1)
      endif
 
!     find it in the list of SINGLE ELEMENTs:
      do j=1,il
         if(bez(j).eq.idat) then
            if (ldump(j)) then !Only enable once/element!
               write(*,*)    "Error in parsing DUMP block:"
               write(*,*)    "Element '",idat, "' was specified",
     &              " more than once"
               call prror(-1)
            endif
            goto 2001
         endif
      enddo
      if ( idat(:3).eq.'ALL' ) then
         j=0
         goto 2001
      endif
!     search failed:
      write(*,*)    ''
      write(*,*)    " Un-identified SINGLE ELEMENT '", idat, "'"
      write(*,*)    '   in block ',dump, '(fort.3)'
      write(*,*)    '   parsed line:'
      write(*,*)    ch(:80)
      write(*,*)    ''
      call prror(-1)
 
!     element found:
 2001 ldump(j) = .true.
      ndumpt(j) = i1
      if (ndumpt(j).le.0) ndumpt(j)=1
      dumpunit(j) = i2
      dumpfmt(j)  = i3
      dump_fname(j) = ch1
      dumpfirst(j) = i4
      dumplast(j) = i5
!     go to next line
      goto 2000
 
!-----------------------------------------------------------------------
!  DYNAMIC KICKS
!  A.Mereghetti, for the FLUKA Team
!  K.Sjobak & A. Santamaria, BE-ABP/HSS
!  last modified: 21-01-2014
!  always in main code
!-----------------------------------------------------------------------
 2200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output
 
      if(ch(1:1).eq.'/') goto 2200 ! skip comment line
 
      ! Which type of block? Look at start of string (no leading blanks allowed)
 
      if (ch(:4).eq."DEBU") then
         ldynkdebug = .true.
         write (*,*)
     &        "DYNK> DYNK block debugging is ON"
         goto 2200 !loop DYNK
 
      else if (ch(:6).eq."NOFILE") then
         ldynkfiledisable = .true.
         write (*,*)
     &        "DYNK> Disabled writing dynksets.dat"
         goto 2200 !loop DYNK
 
      else if (ch(:3).eq."FUN") then
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write    (*,'(1x,A,I4,A)')
     &           "DYNKDEBUG> Got a FUN block, len=",
     &           len(ch), ": '"// trim(ch)// "'"
            do ii=1,getfields_nfields
               write (*,*)
     &              "DYNKDEBUG> Field(",ii,") ='",
     &              getfields_fields(ii)(1:getfields_lfields(ii)),"'"
            enddo
         endif
         call dynk_parseFUN(getfields_fields,
     &        getfields_lfields, getfields_nfields)
         goto 2200 !loop DYNK
 
      else if (ch(:3).eq."SET") then
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write    (*,'(1x,A,I4,A)')
     &           "DYNKDEBUG> Got a SET block, len=",
     &           len(ch), ": '"//trim(ch)//"'"
            do ii=1,getfields_nfields
               write (*,*)
     &              "DYNKDEBUG> Field(",ii,") ='",
     &              getfields_fields(ii)(1:getfields_lfields(ii)),"'"
            enddo
         endif
         call dynk_parseSET(getfields_fields,
     &        getfields_lfields, getfields_nfields)
         goto 2200 !loop DYNK
 
      else if (ch(:4).eq.next) then
         if (ldynkdebug) then
            write (*,*)
     &           "DYNKDEBUG> Finished parsing DYNK block"
            call dynk_dumpdata
         endif
         if (ldynk) then
            write (*,*)
            write (*,*) "******************************************"
            write (*,*) "** More than one DYNK block encountered **"
            write (*,*) "******************************************"
            call prror(51)
         else
            ldynk = .true.
         endif
         call dynk_inputsanitycheck
         goto 110 ! loop BLOCK
 
      else
         write (*,*)
         write (*,*) "*******************************************"
         write (*,*) "ERROR while parsing DYNK block in fort.3"
         write (*,*) "Expected keywords FUN, SET, DEBU, NOFILE or NEXT"
         write (*,*) "Got ch:"
         write (*,*) "'"//ch//"'"
         write (*,*) "*******************************************"
         call prror(51)
      endif
      ! Should never arrive here
      write (*,*) "*****************************"
      write (*,*) "*LOGIC ERROR IN PARSING DYNK*"
      write (*,*) "*****************************"
      call prror(51)
!-----------------------------------------------------------------------
!  FMA
!  M. Fitterer, R. De Maria, K. Sjobak, BE/ABP-HSS
!  last modified: 07-01-2016
!  always in main code
!-----------------------------------------------------------------------
 2300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output
 
      if(ch(1:1).eq.'/') goto 2300 ! skip comment lines
 
      if (ch(:4).eq.next) then
         goto 110 ! loop to next BLOCK in fort.3
      endif
 
      if(fma_numfiles.ge.fma_max) then
        write(*,*)
     &       'ERROR: you can only do ',fma_max,' number of FMAs'
        call prror(-1)
      endif
 
      fma_numfiles=fma_numfiles+1 !Initially initialized to 0 in COMNUL
!     read in input parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(*,*)
     &       'ERROR in FMA block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif
      if(getfields_nfields.eq.1 .or. getfields_nfields.ge.4) then
        write(*,*)
     &       'ERROR in FMA block: wrong number of input ',
     &       'parameters: ninput = ', getfields_nfields, ' != 2 (or 3)'
        call prror(-1)
      endif
 
      fma_fname(fma_numfiles)  =
     &     getfields_fields(1)(1:getfields_lfields(1))
      fma_method(fma_numfiles) =
     &     getfields_fields(2)(1:getfields_lfields(2))
      if(getfields_nfields.eq.2) then
        fma_norm_flag(fma_numfiles) = 1 !default: normalize phase space
      endif
      if(getfields_nfields.eq.3) then
         read (getfields_fields(3)(1:getfields_lfields(3)),'(I10)')
     &        fma_norm_flag(fma_numfiles)
      endif
 
      ! Input sanity checks
      if (.not. (
     &    trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNELASK"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFFTI"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFFT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEAPA"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFIT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNENEWT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEABT2"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEABT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNENEWT1")
     &   ) then
         write(*,*)
     &        "ERROR in DATEN::FMA: The FMA method '"//
     &        trim(stringzerotrim(fma_method(fma_numfiles)))
     &        //"' is unknown. FMA index = ", fma_numfiles
         write(*,*)
     &       "Please use one of TUNELASK, TUNEFFTI, TUNEFFT, "//
     &       "TUNEAPA, TUNEFIT, TUNENEWT, TUNEABT2, TUNEABT2. "//
     &       "Note that it is case-sensitive, so use uppercase only."
         call prror(-1)
      end if
 
      if (.not. (fma_norm_flag(fma_numfiles).eq.0 .or.
     &           fma_norm_flag(fma_numfiles).eq.1      )) then
         write(*,*)
     &        "ERROR in DATEN::FMA: Expected  fma_norm_flag = 1 or 0."//
     &        "Got:", fma_norm_flag(fma_numfiles),
     &        "FMA index =",fma_numfiles
      end if
 
      fma_flag = .true.
      goto 2300
!-----------------------------------------------------------------------
  771 if(napx.ge.1) then
        if(e0.lt.pieni.or.e0.le.pma) call prror(27)
!hr05   if(nbeam.ge.1) parbe14=-crad*partnum/four/pi/emitnx*c1e6
        if(nbeam.ge.1) parbe14=                                         &!hr05
     &(((((-1d0*crad)*partnum)/four)/pi)/emitnx)*c1e6                    !hr05
        gammar=pma/e0
!hr05   crad=two*crad*partnum*gammar*c1e6
        crad=(((two*crad)*partnum)*gammar)*c1e6                          !hr05
        emitx=emitnx*gammar
        emity=emitny*gammar
      endif
      if(idp.eq.0.or.ition.eq.0.or.nbeam.lt.1) then
        do j=1,il
!hr05     parbe(j,2)=0
          parbe(j,2)=0d0                                                 !hr05
        enddo
      else
        do j=1,il
!hr05     if(parbe(j,2).gt.mbea) then
          if(parbe(j,2).gt.dble(mbea)) then                              !hr05
!hr12       write(*,'(a48,i4,a29,i4)') '     WARNING: Number of ',      &
            write(*,'(a48,i4,a29,i4)') '     WARNING: Number of '//     &!hr12
!hr12&'slices set to maximum : ',mbea,' for 6D beam-beam element',      &
     &'slices set to maximum : ',mbea,' for 6D beam-beam element'//     &!hr12
     &' #: ',j
!hr05       parbe(j,2)=mbea
            parbe(j,2)=dble(mbea)                                        !hr05
          endif
        enddo
      endif
      do j=1,il
         if(kz(j).eq.15) then
            if(abs(xpl(j)).lt.pieni.and.abs(zpl(j)).lt.pieni) then
               kz(j)=0
!hr05          ed(j)=0
               ed(j)=0d0                                                 !hr05
!hr05          ek(j)=0
               ek(j)=0d0                                                 !hr05
!hr05          el(j)=0
               el(j)=0d0                                                 !hr05
            endif
         endif
      enddo
      if(iout.eq.0) return
      write(*,10050)
      write(*,10060)
      il1=il
      if(ncy2.eq.0) il1=il-1
      do 1435 k=1,il1
      if(abs(kz(k)).eq.12) then
        write(*,10070) k,bez(k),kz(k),ed(k),ek(k),phasc(k),xpl(k),      &
     &xrms(k),zpl(k),zrms(k)
        kz(k)=abs(kz(k))
        phasc(k)=phasc(k)*rad
      else
        write(*,10070) k,bez(k),kz(k),ed(k),ek(k),el(k),xpl(k),xrms(k), &
     &zpl(k),zrms(k)
      endif
 1435 continue
      write(*,10130)
      write(*,10080)
      write(*,10090) mper,(msym(k),k=1,mper)
      write(*,10250) mblo,mbloz
      write(*,10100)
      do 1450 l=1,mblo
      kk=mel(l)
      ll=kk/6
      if(ll.ne.0) then
        do 1440 l1=1,ll
          l2=(l1-1)*6+1
          l3=l2+5
          if(l2.eq.1) then
            write(*,10260) l,bezb(l),kk,(beze(l,k),k=1,6)
          else
            write(*,10270) (beze(l,k),k=l2,l3)
          endif
 1440   continue
        if(mod(kk,6).ne.0) then
          l4=ll*6+1
          write(*,10270) (beze(l,k),k=l4,kk)
        endif
      else
        write(*,10260) l,bezb(l),kk,(beze(l,k),k=1,kk)
      endif
 1450 continue
      write(*,10120)
      mblozz=mbloz/5+1
      do 1480 k=1,mblozz
      k10=(k-1)*5
      if((mbloz-k10).eq.0) goto 1480
      do 1470 l=1,5
        if((k10+l).gt.mbloz) ic0(l)=' '
        if((k10+l).gt.mbloz) goto 1470
        icc=ic(k10+l)
        if(icc.gt.nblo) goto 1460
        ic0(l)=bezb(icc)
        goto 1470
 1460   ic0(l)=bez0(icc-nblo)
 1470 continue
      k11=k10+1
      write(*,10280) k11,(ic0(l),l=1,5)
 1480 continue
      write(*,10130)
 1490 if(idp.eq.0) goto 1500
      if(nbeam.ge.1) then
        if(partnum.gt.zero) then
          write(*,10140) ncy,dp1,dppoff,tlen,pma,partnum,parbe14,       &
     &ibeco,                                                            &
     &ibtyp,ibb6d,sigz,sige,emitnx,emitny,e0
        else
          write(*,10141) ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,  &
     &ibeco,ibtyp,ibb6d,sigz,sige,emitnx,emitny,e0
        endif
      else
        write(*,10142) ncy,dp1,dppoff,tlen,pma,e0
      endif
      if(ncy2.eq.0) then
        write(*,10143) harm,u0,phag,qs,alc
      else
        write(*,*)
      endif
        if(ibb6d.eq.1) then
          write(*,10144)
          do j=1,il
!hr12       if(parbe(j,2).gt.0) write(*,10145) bez(j),                  &
            if(parbe(j,2).gt.0d0) write(*,10145) bez(j),                &!hr12
     &int(parbe(j,2)),parbe(j,1),parbe(j,3)
          enddo
        endif
      write(*,10130)
 1500 continue
      write(*,10150)
      nfb=nde(1)
      nac=nde(2)
      nft=numl-nde(2)
      if(numl.le.nde(2)) nft=0
      if(numl.le.nde(2)) nac=numl
      if(numl.le.nde(1)) nac=0
      if(numl.le.nde(1)) nfb=numl
      write(*,10160) numl,numlr,nwr(4),nfb,nwr(1),nac,nwr(2),nft,nwr(3),&
     &kanf,amp(1),rat,itco,dma,dmap,itqv,dkq,dqq
      write(*,10170) itcro,dsm0,dech,de0,ded,dsi
      write(*,10130)
      write(*,10040)
      write(*,10130)
      goto 1540
 1520 call prror(41)
 1530 call prror(42)
 1540 continue
!hr05 if(2*mmac*imc*napx.gt.npart) call prror(54)
      if(((2*mmac)*imc)*napx.gt.npart) call prror(54)                    !hr05
 
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(11(a4,1x))
10010 format(a4,8x,a60)
10020 format(a)
10030 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
     &'OO  SIXTRACK-INPUT  OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10040 format(t10,21('O')/t10,2('O'),17x,2('O')/t10,                     &
     &'OO  PREPROCESSING  OO', /t10,2('O'),17x,2('O')/t10,21('O'))
10050 format(//131('-')//t43,'*** RING PARAMETERS ***'/)
10060 format(t30,'SINGLE ELEMENTS:'/'  NO   NAME  TYP      ',           &
     &' 1/RHO          STRENGTH          LENGTH           X-POS     ',  &
     &'     X-RMS            Y-PO          Y-RMS     ' /131('-'))
10080 format(/t30,'RINGSTRUCTURE:'//)
10090 format(t10,'NO. OF SUPERPERIODS AND SYMMETRY ' ,t50,i3,'   ',15i4,&
     &'   ')
10100 format(//131('-')//t30,'BLOCKSTRUCTURE:'/ t30,                    &
     &'(BLOCKTYP--NO. OF SINGLE ELEMENTS--SINGLE ELEMENT TYPES)'//)
10110 format(t10,i3,' ---',i3,' --- ',30i3)
10120 format(//131('-')//t30,'BLOCKSTRUCTURE OF SUPERPERIOD:'//)
10130 format(/131('-')/)
10140 format(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//             &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10141 format(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//             &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10142 format(t30,'SYNCHROTRON OSCILLATIONS'//                           &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10143 format(                                                           &
     &t10,'HARMONIC NUMBER',t74,f6.0/                                   &
     &t10,'CIRCUMF. VOLTAGE   (MV)',t66,f14.9/                          &
     &t10,'EQUILIBRIUM PHASE     (DEG)',t66,f14.9/                      &
     &t10,'FREQUENCY (IN UNITS OF REVOLUTION-FREQ.) QS-LINEAR',         &
     &t66 ,f14.9/                                                       &
     &t10,'MOMENTUM COMPACTION',t66,f14.9/)
10144 format(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//        &
     &t10,'ELEMENT           #_OF_SLICES    CROSSING_ANGLE',            &
     &'    CROSSING_PLANE    COUPLING_ANGLE'/t10,85('-')/)
10145 format(t10,a16,5x,i4,7x,d16.10,2x,d16.10)
10150 format(//t43,'*** TRACKING PARAMETERS ***'/)
10160 format(t10,'NUMBER OF REVOLUTIONS  ',t48,i8/ t10,                 &
     &'NUMBER OF REVERSE-REVOLUTIONS',t48,i8/ t10,                      &
     &'TURNS PER COOR.-PRINTOUT',t48,i8/ t10,'FLAT BOTTOM UP TO TURN ', &
     &t48,i8/ t10,'TURNS PER PRINT ON DATASET',t48,i8/ t10,             &
     &'ACCELERATION UP TO TURN',t48,i8/ t10,'TURNS PER PRINT ON DATASET'&
     &,t48,i8/ t10,'FLAT TOP NUMBER OF TURNS',t48,i8/ t10,              &
     &'TURNS PER PRINT ON DATASET',t48,i8/ t10,                         &
     &'TRACKING START AT ELEMENT NO.',t48,i8/ t10,                      &
     &'INITIAL AMPLITUDE-H IN (MM)',t49,f7.3/ t10,                      &
     &'COUPLING  EPS-Y/EPS-X',t49,f7.3/ t10,                            &
     &'NUMBER OF C.-O. ITERATIONS ',t48,i8/ t10,                        &
     &'PRECISION OF C.-O. DEVIATION',t47,d9.3/ t10,                     &
     &'PRECISION OF C.-O. SLOPE   ',t47,d9.3/ t10,                      &
     &'NUMBER OF Q-ADJ. ITERATIONS',t48,i8/ t10,                        &
     &'CHANGE IN K-STRENGTH BY',t47,d9.3/ t10,                          &
     &'PRECISION OF Q-ADJUSTEMENT',t47,d9.3)
10170 format(t10,'NUMBER OF CHROMAT.-ADJ. ITER.',t48,i8/ t10,           &
     &'CHANGE IN SEX.-STRENGTH BY',t47,d9.3/ t10,                       &
     &'PRECISION OF CHROMAT.-ADJ.',t47,d9.3/ t10,                       &
     &'DP-INTERVAL F. CROMAT.-ADJ.',t47,d9.3/ t10,                      &
     &'DP-INTERVAL FOR DISPERSION',t47,d9.3/ t10,                       &
     &'PRECISION FOR C.-O. RMS',t47,d9.3/)
10180 format(t5/t10,a60)
10190 format(t10,'PROGRAM MODE : FREE FORMAT INPUT')
10200 format(t10,'PROGRAM MODE : FREE FORMAT INPUT --READ FROM ',       &
     &'EXTRA GEOMETRY STRENGTH FILE--')
10220 format(t10,i4,2(' ',d15.8),5x,2(' ',d15.8))
10250 format(t10,'NUMBER OF DIFFERENT BLOCKS',t50,i3/ t10,              &
     &'BLOCKS PER PERIOD',t49,i5//)
10290 format(t10,'MORE THAN ',i5,' COMBINATIONS SPECIFIED'/)
10300 format(//131('-')//t10,'DATA BLOCK COMBINATION OF ELEMENTS',      &
     &'  THE FOLLOWING ELEMENTS ARE RELATED IN STRENGTHS--->'/ t10,     &
     &'ELEMENT RELATED TO ELEMENT BY THE RATIO'/)
10320 format(//131('-')//t10,'DATA BLOCK APERTURE LIMITATIONS'/ /t10,   &
     &'TYP',t20,'FORM',t30,'APERT-H',t40,'APERT-V')
10340 format(t10,'NO CAVITIES SPECIFIED'/)
10350 format(//131('-')//t10,'DATA BLOCK ORGANISATION OF RANDOM NUMBERS'&
     &/5x,'|          |      OWN RANDOM NUMBERS      |      SAME RAN' , &
     &'DOM NUMBERS      |   SAME MULTIPOLECOEFFICIENTS  |'/131('-'))
10370 format(t10,'DESIRED TUNE TO ADJUST IS ZERO'/ t10,                 &
     &'DATA BLOCK TUNE ADJUSTMENT  IGNORED')
10380 format(t10,'HIGHER MULTIPOLES THAN 20-POLES ARE NOT ALLOWED' ,    &
     &' AND THEREFORE IGNORED')
10410 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
10420 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
     &'OO   NORMAL FORMS   OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10430 format(/5x,'No cut on random distribution'//)
10440 format(/5x,'Random distribution has been cut to: ',i4,' sigma.'//)
10460 format(//131('-')//t10,'DATA BLOCK ',a4,' INFOs'/ /t10,           &
     &'ELEMENT NAME',8x,'EVERY # TURNs',2x,
     &'LOGICAL UNIT',2x,'FILENAME',24x,'FORMAT',5x,
     &"FirstTurn",6x,"LastTurn") !DUMP/STAT/BMAT
10070 format(1x,i3,1x,a16,1x,i3,1x,d16.10,1x,d16.10,1x,d16.10,1x,d13.7, &
     &1x,d12.6,1x,d13.7,1x,d12.6)
10210 format(t10,'DATA BLOCK MULTIPOLE COEFFICIENTS'/ t10,              &
     &'MULTIPOLE                    ',a16/t10,'RADIUS IN MM            '&
     &,f15.7/ t10,'BENDING STRENGTH IN MRAD',f15.7// t10,19x,'NORMAL',25&
     &x,'      SKEW '// t10,'      MEAN            RMS-VALUE     ',     &
     &'       MEAN            RMS-VALUE'/)
10240 format(t10,a16,3(2x,d16.10),2x,i10)
10260 format(t4,i4,1x,a16,1x,i2,1x,6(1x,a16))
10270 format(t28,6(1x,a16))
10280 format(t3,i6,1x,5(a16,1x))
10310 format(t10,a16,10x,a16,6x,f20.15)
10330 format(t8,a16,t18,a2,t30,f8.2,t40,f8.2)
10360 format(5x,'| ELEMENT  |           ',a16,'           |           ',&
     &'    |               |               |               |')
10390 format(5x,'| ELEMENTS |                              |    ',a16,  &
     &'   |    ',a16,'   |               |               |')
10400 format(5x,'| ELEMENTS |                              |          ' &
     &,'     |               |    ',a16,'   |    ',a16,'   |')
10470 format(t10,a16,4x,i13,2x,i12,2x,a32,i6,2x,i12,2x,i12) !BMAT/STAT/DUMP
10472 format(t10,a)                           !BMAT/STAT/DUMP
10700 format(t10,'DATA BLOCK TROMBONE ELEMENT'/                         &
     &t10,'TROMBONE #      NAME'/)
10710 format(t22,i4,5x,a16)
      end
 
      subroutine write4
!-----------------------------------------------------------------------
!     WRITE MODIFIED GEOMETRY FILE ON UNIT 4
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ii,ikz
      double precision rdum1,rdum2,rel1
      character*160  ch
      character*320 ch1
      character*16 idat
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      save
!-----------------------------------------------------------------------
      ii=0
      rewind 2
 1    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
        goto 1
      elseif(ch(:4).eq.'SING') then
        write(4,*) ch
      else
        return
      endif
 2    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
      else
        ii=ii+1
        if(ch(:4).ne.'NEXT') then
          call intepr(1,1,ch,ch1)
          read(ch1,*) idat,ikz,rdum1,rdum2,rel1
          if(ikz.eq.11) then
            write(4,10000) idat,ikz,rdum1,rdum2,rel1
          else
            if(abs(rel1).le.pieni) then
              if(ncororb(ii).eq.0) then
                write(4,10000) idat,ikz,sm(ii),rdum2,rel1
              else
                write(4,10000) idat,ikz,sm(ii),ek(ii),rel1
              endif
            else
              write(4,10000) idat,ikz,rdum1,ek(ii),rel1
            endif
          endif
        else
          write(4,*) ch
          goto 3
        endif
      endif
      goto 2
 3    read(2,*,end=90) ch
      lineno2=lineno2+1
      write(4,*) ch
      goto 3
 90   continue
10000 format(a16,1x,i2,1x,d21.15,1x,d21.15,1x,d16.10)
      end
      subroutine intepr(i,j,ch,ch1)
!-----------------------------------------------------------------------
!     SUBROUTINE TO INTEPRET INPUT WITH CHARACTERS AND NUMBERS MIXED
!
!     I ... TYPE OF COMBINATION
!
!         1  LINE WITH 1 CHARACTERSTRING FOLLOWED BY NUMBERS
!         2  LINE WITH CHARACTERSTRINGS, IF THE FIRST 5 CHARACTERS
!            ARE BLANKS THIS IS INTERPRETED AS A BLANK CHARACTER
!         3  LINE WITH CHARACTERSTRINGS
!         4  LINE WITH 2 CHARACTERSTRINGS
!         5  LINE WITH 1 CHARACTERSTRING AND N*(NUMBER,CHA.STRING)
!         6  LINE WITH 1 NUMBER AND 2 CHARACTERSTRINGS
!         7  LINE WITH 1 NUMBER, 2 CHARACTERSTRINGS AND NUMBERS
!         8  LINE WITH 2 CHARACTERSTRINGS AND NUMBERS
!
!     J ... SKIP THE FIRST (J-1) CHARACTERS OF CHARACTERSTRING CH
!    CH ... INPUT CHARACTERSTRING
!   CH1 ... OUTPUT CHARACTERSTRING
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
!ERIC
      integer i,i0,i1,i2,i3,i4,iev,ii,j
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      save
!-----------------------------------------------------------------------
      i0=0
      i1=j
      i2=1
      i4=0
      do 10 ii=j,nchars
        if(i0.eq.0.and.ch(ii:ii).eq.' ') then
          if(i.eq.2.and.ii.eq.5.and.ch(:5).eq.'     ') then
            ch1(:4)=''' '' '
            i2=5
          endif
          i1=ii+1
          goto 10
        endif
        i0=1
        if(ch(ii:ii).eq.' ') then
          i4=i4+1
          iev=1
          if(mod(i4,2).eq.0) iev=0
          if(i.eq.1) goto 20
          if(i.eq.2.or.i.eq.3.or.i.eq.4.or. (i.eq.5.and.iev.eq.1.).or.  &
     &(i.eq.6.and.i4.ge.2).or. (i.eq.7.and.(i4.eq.2.or.i4.eq.3)).or.    &
     &(i.eq.8.and.i4.lt.3)) then
!hr05       i3=i2+ii-i1+2
            i3=((i2+ii)-i1)+2                                            !hr05
            ch1(i2:i3)=''''//ch(i1:ii-1)//''' '
            if(i.eq.4.and.i4.eq.2) goto 30
            i2=i3+1
          endif
          if((i.eq.5.and.iev.eq.0).or. (i4.eq.1.and.(i.eq.6.or.i.eq.7)))&
     &then
!hr05       i3=i2+ii-i1
            i3=(i2+ii)-i1                                                !hr05
            ch1(i2:i3)=ch(i1:ii)
            i2=i3+1
          endif
          if((i.eq.7.and.i4.gt.3).or.(i.eq.8.and.i4.eq.3)) goto 40
          i0=0
          i1=ii+1
        endif
   10 continue
      goto 30
   20 ch1(1:nchars+nchars)=''''//ch(i1:ii-1)//''''//ch(ii:nchars)//' / '
      return
   30 i3=i3+1
      ch1(i3:i3+2)=' / '
      return
   40 i3=i2+nchars+3-i1
      ch1(i2:i3)=ch(i1:nchars)//' / '
      return
      end
 
      subroutine initialize_element(ix,lfirst)
!
!-----------------------------------------------------------------------
!     K.Sjobak & A.Santamaria, BE-ABP/HSS
!     last modified: 16-12-2014
!     Initialize a lattice element with index elIdx,
!     such as done when reading fort.2 (GEOM) and in DYNK.
!
!     Never delete an element from the lattice, even if it is not making a kick.
!     If the element is not recognized, do nothing (for now).
!     If trying to initialize an element (not lfirst) which is disabled,
!     print an error and exit.
!-----------------------------------------------------------------------
!
      implicit none
 
      integer, intent(in) :: ix
      logical, intent(in) :: lfirst
 
      integer im, izu, k, m, nmz, r0, r0a !needed to use multini
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
 
      !Temp variables
      integer i
 
!--Nonlinear Elements
! TODO: Merge these cases into 1 + subcases?
      if(abs(kz(ix)).eq.1) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)             ! Also done in envar() which is calle
                 smiv(1,i)=sm(ix)+smizf(i) ! Also done in program maincr
                 smi(i)=smiv(1,i)          ! Also done in program maincr
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.2) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
      elseif(abs(kz(ix)).eq.3) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.4) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.5) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.6) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.7) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.8) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.9) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
      elseif(abs(kz(ix)).eq.10) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
               endif
            enddo
         endif
 
!--Multipoles
      elseif(kz(ix).eq.11) then
 
         !MULT support removed untill we have a proper use case.
c$$$         if (lfirst) then
c$$$            dynk_elemdata(ix,1) = el(ix) !Flag for type
c$$$            dynk_elemdata(ix,2) = ed(ix) !Bending strenght
c$$$            dynk_elemdata(ix,3) = ek(ix) !Radius
c$$$         else
c$$$            el(ix) = dynk_elemdata(ix,1)
c$$$            dynk_elemdata(ii,2) = ed(ii) !Updated in dynk_setvalue
c$$$            ek(ii) = dynk_elemdata(ix,3)
c$$$         end if
 
         ! Moved from daten():
         if (abs(el(ix)+one).le.pieni) then
            dki(ix,1) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         else if(abs(el(ix)+two).le.pieni) then
            dki(ix,2) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         endif
         !Otherwise, i.e. when el=0, dki(:,1) = dki(:,2) = dki(:,3) = 0.0
 
         !MULT support removed untill we have a proper use case.
c$$$         !All multipoles:
c$$$         if(.not.lfirst) then
c$$$            do i=1,iu
c$$$               if ( ic(i)-nblo.eq.ix ) then
c$$$                  if(ktrack(i).eq.31) goto 100 !ERROR
c$$$                  !--Initialize smiv as usual
c$$$                  sm(ix)=ed(ix)
c$$$                  smiv(m,i)=sm(ix)+smizf(i)
c$$$                  smi(i)=smiv(m,i)
c$$$
c$$$                  !--Using the right izu & setting aaiv, bbiv (see multini)
c$$$                  izu = dynk_izuIndex(ix)
c$$$+ca multini !Also in program maincr()
c$$$ 150              continue ! needs to be after a multini block
c$$$
c$$$                  ! From trauthin()&trauthck() (they are identical)
c$$$                  r0=ek(ix)
c$$$                  nmz=nmu(ix)
c$$$                  if(abs(r0).le.pieni.or.nmz.eq.0) then
c$$$                     if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                    abs(dki(ix,2)).le.pieni) then
c$$$C                       ktrack(i)=31
c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
c$$$     &                       abs(dki(ix,2)).le.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                          ktrack(i)=33
c$$$+ca stra11
c$$$                        else
c$$$C                          ktrack(i)=35
c$$$+ca stra12
c$$$                        endif
c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                       abs(dki(ix,2)).gt.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=37
c$$$+ca stra13
c$$$                        else
c$$$C                            ktrack(i)=39
c$$$+ca stra14
c$$$                        endif
c$$$                     endif
c$$$                  else
c$$$                     if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                    abs(dki(ix,2)).le.pieni) then
c$$$C                        ktrack(i)=32
c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
c$$$     &                       abs(dki(ix,2)).le.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=34
c$$$+ca stra11
c$$$                        else
c$$$C                           ktrack(i)=36
c$$$+ca stra12
c$$$                        endif
c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                       abs(dki(ix,2)).gt.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=38
c$$$+ca stra13
c$$$                        else
c$$$C                           ktrack(i)=40
c$$$+ca stra14
c$$$                        endif
c$$$                     endif
c$$$                  endif
c$$$               endif
c$$$            enddo
c$$$         endif
 
!--Cavities (ktrack = 2 for thin)
      elseif(abs(kz(ix)).eq.12) then
         !Moved from daten
         phasc(ix) = el(ix)
         el(ix) = zero
         dynk_elemdata(ix,3) = phasc(ix)
         if (.not.lfirst) then
 
            ! Doesn't work, as i is not initialized here.
            !if (.not.ktrack(i).eq.2) goto 100 !ERROR
 
            phasc(ix) = phasc(ix)*rad
 
            hsyc(ix) = ((two*pi)*ek(ix))/tlen         ! daten SYNC block
            hsyc(ix)=(c1m3*hsyc(ix))*dble(itionc(ix)) ! trauthin/trauthck
         endif
!--Crab Cavities
!   Note: If setting something else than el(),
!   DON'T call initialize_element on a crab, it will reset the phase to 0.
      elseif(abs(kz(ix)).eq.23) then
         !Moved from daten()
         crabph(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 2
      elseif(abs(kz(ix)).eq.26) then
         !Moved from daten()
         crabph2(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 3
      elseif(abs(kz(ix)).eq.27) then
         !Moved from daten()
         crabph3(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 4
      else if(abs(kz(ix)).eq.28) then
         !Moved from daten()
         crabph4(ix)=el(ix)
         el(ix)=0d0
      endif
 
      return
 
      !Error handlers
 100  continue
      write (*,*)    "ERROR in initialize_element, tried to set"
      write (*,*)    "the strength of an element which is disabled."
      write (*,*)    "bez = ", bez(ix)
      call prror(-1)
 
      end subroutine
 
      subroutine splitfld(errno,nunit,lineno,nfields,nf,chars,fields)
      implicit none
      integer errno,nunit,lineno,nfields,nf,i,j,k,l,lf
      character*(*) chars
      character*(*) fields(*)
      character*999 localstr
! This routine splits the chars input into space separated
! fields, up to nfields maximum. It returns the no of
! fields in nf. All spaces are ignored but treated as separators.
! A / is a line terminator as provided in ch1 typically.
! This corresponds to Fortran treatment with an * format spec.
      j=0
      nf=0
      do i=1,nfields
        fields(i)=' '
        lf=len(fields(i))
 8889   k=0
 8888   j=j+1
        if (j.gt.len(chars)) then
          errno=1
          go to 8887
        endif
        if (k.eq.0.and.chars(j:j).eq.' ') go to 8888
        if (chars(j:j).ne.' '.and.chars(j:j).ne.'/') then
          k=k+1
          if (k.ge.lf) then
! We reserve the last position for a null for C
! Field length exceeded
! Eric for debug
            do j=1,nf
              l=len(fields(j))
              localstr=fields(j)(1:l)
              write(*,*) 'splitfld:'//localstr(1:30)//':'
            enddo
            errno=2
            call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
          endif
          fields(i)(k:k)=chars(j:j)
          go to 8888
        else
          if (chars(j:j).eq.'/') then
! we are all through but may have a field
            if (k.ne.0) nf=nf+1
! Eric for debug
!     do j=1,nf
!       l=len(fields(j)
!       localstr=fields(j)(1:l)
!       write(*,*) 'splitfld:'//localstr)//':'
!     enddo
            return
          else
! Must have a space, field separator
            nf=nf+1
          endif
        endif
      enddo
 8890 continue
! If we get here we have a problem unless there
! is nothing left but ' '*/
 8886 j=j+1
      if (j.gt.len(chars)) go to 8887
      if (chars(j:j).eq.'/') return
      if (chars(j:j).eq.' ') go to 8886
      errno=3
 8887 continue
! Eric for debug
      do j=1,nf
        l=len(fields(j))
        localstr=fields(j)(1:l)
        write(*,*) 'splitfld:'//localstr//':'
      enddo
      call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      end
      double precision function fround(errno,fields,f)
      implicit none
      integer maxf
      parameter (maxf=30)
      integer errno,f
      character*(*) fields(*)
      double precision round_near,value
      fround=round_near(errno,maxf,fields(f))
      if (errno.ne.0) then
        value=fround
        call rounderr(errno,fields,f,value)
      endif
      return
      end
      subroutine rounderr(errno,fields,f,value)
      implicit none
      integer nchars,nofields
      integer errno,nfields,f,l
      character*(*) fields(*)
      character*999 localstr
      double precision value
      write (*,10000)
      write (*,*) 'Data Input Error (probably in subroutine daten)'
      write (*,*) 'Overfow/Underflow in strtod()'
      write (*,*) 'Errno: ',errno
      l=len(fields(f))
      localstr=fields(f)(1:l)
      write (*,*) 'f:fieldf:',f,':'//localstr
      write (*,*) 'Function fround (rounderr) returning:',value
      call abend('Treating this as FATAL!!!                         ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
      return
      end
      subroutine spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      implicit none
      integer errno,nunit,lineno,nfields,nf,lf,l
      character* (*) chars
      character*999 localstr
      write (*,10000)
      write (*,*) 'Data Input Error (probably in subroutine daten)'
      write (*,*) 'Reading unit no (fort.)',nunit,' Line',lineno
      l=len(chars)
      localstr=chars(1:l)
      write (*,*) 'Input line:'//localstr//':'
      if (errno.eq.1) then
        write (*,*)                                                     &
     &  'Input string too long, exceeds',len(chars),' characters'
      endif
      if (errno.eq.2) then
        write (*,*)                                                     &
     &  'Field too long, exceeds',lf-1,' characters'
      endif
      if (errno.eq.3) then
        write (*,*)                                                     &
     &  'Too many input fields, maximum of',nfields,' exceeded'
      endif
      call abend('Treating this error as FATAL!!!                   ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      end
      integer function dtostr(x,results)
! Uses the dtoa_c.c version of dtoa via the dtoaf.c interface in
! crlibm
      implicit none
      double precision x
      character*(24) results
      integer dtoaf
      integer ilen,mode,ndigits,decpoint,mysign
      integer i,l,d,e
      character*1 str(17)
      character*24 lstr
      character*3 e3
      mode=2
      ndigits=17
      ilen=dtoaf(x,mode,ndigits,decpoint,mysign,str(1),1)
      if (ilen.le.0.or.ilen.gt.17) then
! Always returns 17 or less characters as requested
      write (*,10000)
      write (*,*) 'Routine dtoa[f] returned string length ',ilen
      call abend('Error from dtostr, string length not 17           ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      endif
      lstr=' '
      do i=1,ilen
        lstr(i:i)=str(i)
      enddo
! Now try my formatting
      d=decpoint
      e=0
      l=1
      lstr=' '
      if (mysign.ne.0) then
        lstr(l:l)='-'
      endif
      if (decpoint.eq.9999) then
! Infinity or Nan
        do i=1,ilen
          lstr(l+i:l+i)=str(i)
        enddo
      else
! Pad with zeros
        do i=ilen+1,17
          str(i)='0'
        enddo
        if (decpoint.le.0) then
          e=decpoint-1
          d=1
        else
! I am using 17 as decision point to avoid dddd.e+eee
! but rather d.ddde+eee
          if (decpoint.ge.17) then
            e=decpoint-1
            d=1
          else
            d=decpoint
          endif
        endif
! and copy with the decimal point
        do i=1,17
          lstr(l+i:l+i)=str(i)
          if (i.eq.d) then
            l=l+1
            lstr(l+i:l+i)='.'
          endif
        enddo
! and add exponent e+/-nnn
        l=20
        lstr(l:l)='e'
        l=21
        lstr(l:l)='+'
        if (e.lt.0) then
          lstr(l:l)='-'
          e=-e
        endif
        l=22
        write (e3,'(I3.3)') e
        lstr(l:l+2)=e3(1:3)
      endif
      results=lstr(1:24)
      dtostr=24
      return
      end
      double precision function acos_rn(x)
      implicit none
      double precision atan_rn,x,pi,pi2
      logical myisnan
      data pi  /3.1415926535897932d0/
      data pi2 /1.5707963267948966d0/
      if (myisnan(x,x)) then
        acos_rn=x
      elseif (abs(x).eq.0.0d0) then
        acos_rn=pi2
      else
!       acos_rn=atan_rn(sqrt(1.0d0-x*x)/x)
! Try using (1-x)*(1+x) in case x is very small.........
! or close to 1.....write a test program!!!
         acos_rn=atan_rn(sqrt((1.0d0-x)*(1.0d0+x))/x)
        if (x.lt.0.0d0) then
          acos_rn=pi+acos_rn
        endif
      endif
      end
      double precision function asin_rn(x)
      implicit none
      double precision atan_rn,x,pi2
      logical myisnan
      data pi2 /1.5707963267948966d0/
      if (myisnan(x,x)) then
        asin_rn=x
        return
      endif
      if (abs(x).eq.1.0d0) then
        asin_rn=sign(pi2,x)
      else
!       asin_rn=atan_rn(x/sqrt(1.0d0-x*x))
! Try using (1-x)*(1+x) in case x is very small.........
! or close to 1.....write a test program!!!
        asin_rn=atan_rn(x/sqrt((1.0d0-x)*(1.0d0+x)))
      endif
      end
      double precision function atan2_rn(y,x)
      implicit none
      double precision atan_rn,x,y,pi,pi2
      logical myisnan
      data pi  /3.1415926535897932d0/
      data pi2 /1.5707963267948966d0/
      if (x.eq.0d0) then
         if (y.eq.0d0) then
C Should get me a NaN
           atan2_rn=atan_rn(y/x)
         else
           atan2_rn=sign(pi2,y)
         endif
      else
        if (y.eq.0d0) then
          if (x.gt.0d0) then
            atan2_rn=0d0
          else
            atan2_rn=pi
          endif
        else
          atan2_rn=atan_rn(y/x)
          if (x.lt.0d0) then
            atan2_rn=sign(pi,y)+atan2_rn
          endif
        endif
      endif
      end
      subroutine wzset
!  *********************************************************************
!
!  This subroutine must be called before subroutine WZSUB can be used to
!  compute values of the complex error function w(z).
!
!  Parameters xcut and ycut specify the opposite corners (xcut,0) and
!  (0,ycut) of the rectangle inside which interpolation is to be used
!  by subroutine WZSUB.
!
!  Parameter h is the side of the squares of the interpolation grid.
!
!  Parameters nx and ny must be set to the nearest integers to xcut/h
!  and ycut/h respectively (or to larger values).
!
!  Calls MYWWERF new version of (CERN library) WWERF (C335)
!
!  (G.A.Erskine, 29.09.1995)
!
!  *********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,j,k
      double precision wi,wr,x,y
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer idim,kstep,nx,ny
      double precision h,half,hrecip,one,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77d0, ycut = 7.46d0 )
      parameter ( h = 1.d0/63.d0 )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      parameter ( half = 0.5d0, one = 1.d0 )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      save
!-----------------------------------------------------------------------
      hrecip = 1.d0/h
      kstep = nx+2
      k = 0
      do 2 j=0,ny+1
         do 1 i=0,nx+1
            k = k+1
!hr05       x=i*h
            x=dble(i)*h                                                  !hr05
!hr05       y=j*h
            y=dble(j)*h                                                  !hr05
            call mywwerf(x,y,wr,wi)
            wtreal(k)=wr
            wtimag(k)=wi
 1       continue
 2    continue
      end
      subroutine mywwerf(x,y,wr,wi)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer n
      double precision c,c1,c2,c3,c4,hf,p,rr,ri,sr0,sr,si,tr,ti,vi,vr,  &
     &wi,wr,x,xa,xl,y,ya,zhi,zhr,z1,z10
      parameter (z1=1,hf=z1/2d0,z10=10d0)
      parameter (c1=74d0/z10,c2=83d0/z10,c3=z10/32d0,c4=16d0/z10)
!     parameter (c=1.12837916709551257d0,p=(2d0*c4)**33)
      parameter (c=1.12837916709551257d0,p=46768052394588893.3825d0)
      dimension rr(37),ri(37)
      save
!-----------------------------------------------------------------------
      xa=abs(x)
      ya=abs(y)
      if(ya.lt.c1.and.xa.lt.c2) then
!        zh=dcmplx(ya+c4,xa)
        zhr=ya+c4
        zhi=xa
        rr(37)=0d0
        ri(37)=0d0
        do n=36,1,-1
!          t=zh+n*dconjg(r(n+1))
!hr05     tr=zhr+n*rr(n+1)
          tr=zhr+dble(n)*rr(n+1)                                         !hr05
!hr05     ti=zhi-n*ri(n+1)
          ti=zhi-dble(n)*ri(n+1)                                         !hr05
!          r(n)=hf*t/(dreal(t)**2+dimag(t)**2)
!hr05     rr(n)=hf*tr/(tr**2+ti**2)
          rr(n)=(hf*tr)/(tr**2+ti**2)                                    !hr05
!hr05     ri(n)=hf*ti/(tr**2+ti**2)
          ri(n)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
        xl=p
        sr=0d0
        si=0d0
        do n=33,1,-1
          xl=c3*xl
!          s=r(n)*(s+xl)
          sr0=rr(n)*(sr+xl)-ri(n)*si
          si=rr(n)*si+ri(n)*(sr+xl)
          sr=sr0
        enddo
!        v=c*s
        vr=c*sr
        vi=c*si
      else
        zhr=ya
        zhi=xa
        rr(1)=0d0
        ri(1)=0d0
        do n=9,1,-1
!          t=zh+n*dconjg(r(1))
!hr05     tr=zhr+n*rr(1)
          tr=zhr+dble(n)*rr(1)                                           !hr05
!hr05     ti=zhi-n*ri(1)
          ti=zhi-dble(n)*ri(1)                                           !hr05
!          r(1)=hf*t/(dreal(t)**2+dimag(t)**2)
!hr05     rr(1)=hf*tr/(tr**2+ti**2)
          rr(1)=(hf*tr)/(tr**2+ti**2)                                    !hr05
!hr05     ri(1)=hf*ti/(tr**2+ti**2)
          ri(1)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
!        v=c*r(1)
        vr=c*rr(1)
        vi=c*ri(1)
      endif
!hr05 if(ya.eq.0) then
      if(ya.eq.0d0) then                                                 !hr05
!        v=dcmplx(exp(-xa**2),dimag(v))
!hr05   vr=exp_rn(-xa**2)
        vr=exp_rn(-1d0*xa**2)                                            !hr05
      endif
      if(y.lt.0d0) then
!        v=2*exp(-dcmplx(xa,ya)**2)-v
!hr05   vr=2d0*exp_rn(ya**2-xa**2)*cos_rn(2d0*xa*ya)-vr
        vr=(2d0*exp_rn(ya**2-xa**2))*cos_rn((2d0*xa)*ya)-vr              !hr05
        vi=(-2d0*exp_rn(ya**2-xa**2))*sin_rn((2d0*xa)*ya)-vi             !hr05
!hr05   if(x.gt.0) vi=-vi
        if(x.gt.0d0) vi=-1d0*vi                                          !hr05
      else
!hr05   if(x.lt.0) vi=-vi
        if(x.lt.0d0) vi=-1d0*vi                                          !hr05
      endif
      wr=vr
      wi=vi
      return
      end
      subroutine getfields_split( tmpline, getfields_fields,
     &         getfields_lfields, getfields_nfields, getfields_lerr)
!
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak and A.Santamaria, BE-ABP-HSS
!     last modified: 24-02-2015
!     parse a line and split it into its fields
!       fields are returned as 0-terminated and padded string
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
      character tmpline*(getfields_l_max_string-1) !nchars in daten is 160
 
      intent(in) tmpline
      intent(out) getfields_fields, getfields_lfields,
     &     getfields_nfields, getfields_lerr
 
*     runtime variables
      integer ii, jj
      logical lchar
      integer lenstr, istart
 
*     initialise output variables
      getfields_lerr = .false.
      getfields_nfields=0
      do ii=1,getfields_n_max_fields
         do jj=1,getfields_l_max_string
            getfields_fields(ii)(jj:jj) = char(0) ! ZERO terminate/pad
         enddo
         getfields_lfields(ii)=0
      enddo
 
*     parse the line
      lchar = .false.
      do ii=1, getfields_l_max_string-1 !For \0 termination
         if ( tmpline(ii:ii) .eq. ' ' ) then
*           blank char
            if ( lchar ) then
*              end of a string: record it
               getfields_lfields(getfields_nfields)          = lenstr
               getfields_fields (getfields_nfields)
     &              (1:getfields_lfields(getfields_nfields)) =
     &              tmpline(istart:
     &               istart+getfields_lfields(getfields_nfields))
               lchar = .false.
            endif
         else
*           non-blank char
            if ( .not. lchar ) then
*              a new what starts
               getfields_nfields = getfields_nfields +1
               if ( getfields_nfields.gt.getfields_n_max_fields ) then
                  write (*,*)   'error! too many fields in line:'
                  write (*,*)   tmpline
                  write (*,*)   'please increase getfields_n_max_fields'
                  getfields_lerr = .true.
                  exit !Break do
               endif
               istart = ii
               lchar = .true.
               lenstr = 0
            endif
            lenstr = lenstr+1
         endif
      enddo
 
      end subroutine
 
      function stringzerotrim(instring)
!----------------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 30-10-2014
!     Replace "\0" with ' ' in strings.
!     Usefull before output, else "write (*,*)" will actually write all the \0s
!
!     Warning: Do not add any write(*,*) inside this function:
!     if this function is called by a write(*,*) and then does a write,
!     the program may deadlock!
!----------------------------------------------------------------------------
      implicit none
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      character(stringzerotrim_maxlen) instring
      intent(in) instring
 
      integer ii
 
      do ii=1,stringzerotrim_maxlen
         if ( instring(ii:ii) .ne. char(0) ) then
            stringzerotrim(ii:ii) = instring(ii:ii)
         else
            stringzerotrim(ii:ii) = ' '
         end if
      end do
      stringzerotrim = trim(stringzerotrim)
 
      end function
 
 
      subroutine ranecu(rvec,len,mcut)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,is1,is2,iseed1,iseed2,iz,j,k,len,mcut
      double precision rvec0,rvec,pi,r
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension rvec(*),r(2)
      data iseed1,iseed2 / 12345, 67890 /
      save
!-----------------------------------------------------------------------
      pi = four*atan_rn(one)
!     DO 100 I = 1,LEN
      i=1
   10 do 20 j = 1,2
        k = iseed1/53668
        iseed1 = 40014*(iseed1-k*53668) - k*12211
        if (iseed1.lt.0) iseed1 = iseed1+2147483563
        k = iseed2/52774
        iseed2 = 40692*(iseed2-k*52774) - k*3791
        if (iseed2.lt.0) iseed2 = iseed2+2147483399
        iz = iseed1-iseed2
        if (iz.lt.1) iz = iz+2147483562
!hr05   r(j) = real(iz)*4.656613e-10
        r(j) = dble(iz)*4.656613d-10                                     !hr05
   20 continue
 
C     Convert r(1), r(2) from U(0,1) -> rvec0 as Gaussian with cutoff mcut (#sig
!hr05 rvec0 = ((-two*log_rn(r(1)))**half)*cos_rn(two*pi*r(2))
!     rvec0 = (((-1d0*two)*log_rn(r(1)))**half)*cos_rn((two*pi)*r(2))    !hr05
      rvec0 = sqrt(((-1d0*two)*log_rn(r(1))))*cos_rn((two*pi)*r(2))      !hr05
!hr05 if(abs(rvec0).le.mcut.or.mcut.eq.0) then
      if(abs(rvec0).le.dble(mcut).or.mcut.eq.0) then
        rvec(i) = rvec0
        i=i+1
      endif
      if(i.le.len) goto 10
!     RVEC(I) = ((-TWO*LOG(R(1)))**HALF)*COS(TWO*PI*R(2))
! 100 CONTINUE
      return
      entry recuin(is1,is2)
      iseed1 = is1
      iseed2 = is2
      return
      entry recuut(is1,is2)
      is1 = iseed1
      is2 = iseed2
      return
      end
      subroutine envars(j,dpp,rv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ih,j,kz1,l,ll
      double precision aek,afok,as3,as4,as6,co,dpd,dpp,dpsq,fi,fok,fok1,&
     &fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoc,rhoi,rv,si,siq,sm1,         &
     &sm12,sm2,sm23,sm3,sm5,sm6,wf,wfa,wfhi
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 190 i=1,il
        do ll=1,6
          do l=1,2
            al(ll,l,j,i)=zero
            as(ll,l,j,i)=zero
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 190
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          al(1,l,j,i)=one
          al(2,l,j,i)=el(i)
          al(3,l,j,i)=zero
          al(4,l,j,i)=one
!hr05   20   as(6,l,j,i)=-rv*al(2,l,j,i)/c2e3
   20   as(6,l,j,i)=((-1d0*rv)*al(2,l,j,i))/c2e3                         !hr05
!hr05   as(1,1,j,i)=el(i)*(one-rv)*c1e3
        as(1,1,j,i)=(el(i)*(one-rv))*c1e3                                !hr05
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
!hr05   40   fok=el(i)*ed(i)/dpsq
   40   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        fok1=(tan_rn(fok*half))/rho
        si=sin_rn(fok)
        co=cos_rn(fok)
        al(1,ih,j,i)=one
        al(2,ih,j,i)=rho*si
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
!hr05   al(5,ih,j,i)=-dpp*(rho*(one-co)/dpsq)*c1e3
        al(5,ih,j,i)=((-1d0*dpp)*((rho*(one-co))/dpsq))*c1e3             !hr05
!hr05   al(6,ih,j,i)=-dpp*(two*tan_rn(fok*half)/dpsq)*c1e3
        al(6,ih,j,i)=((-1d0*dpp)*((two*tan_rn(fok*half))/dpsq))*c1e3     !hr05
        sm1=cos_rn(fok)
        sm2=sin_rn(fok)*rho
!hr05   sm3=-sin_rn(fok)/rho
        sm3=(-1d0*sin_rn(fok))/rho                                       !hr05
!hr05   sm5=-rho*dpsq*(one-sm1)
        sm5=((-1d0*rho)*dpsq)*(one-sm1)                                  !hr05
!hr05   sm6=-sm2*dpsq/rho
        sm6=((-1d0*sm2)*dpsq)/rho                                        !hr05
        sm12=el(i)-sm1*sm2
        sm23=sm2*sm3
!hr05   as3=-rv*(dpp*rho/(two*dpsq)*sm23+sm5)
        as3=(-1d0*rv)*(((dpp*rho)/(two*dpsq))*sm23+sm5)                  !hr05
!hr05   as4=-rv*sm23/c2e3
        as4=((-1d0*rv)*sm23)/c2e3                                        !hr05
!hr05   as6=-rv*(el(i)+sm1*sm2)/c4e3
        as6=((-1d0*rv)*(el(i)+sm1*sm2))/c4e3                             !hr05
!hr05   as(1,ih,j,i)=(-rv*(dpp*dpp/(four*dpd)*sm12+dpp*(el(i)-sm2))+    &
!hr05&el(i)*(one-rv))*c1e3
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12+      &!hr05
     &dpp*(el(i)-sm2)))*c1e3                                             !hr05
!hr05   as(2,ih,j,i)=-rv*(dpp/(two*rho*dpsq)*sm12+sm6)+fok1*as3
        as(2,ih,j,i)=fok1*as3-rv*((dpp/((two*rho)*dpsq))*sm12+sm6)       !hr05
        as(3,ih,j,i)=as3
!hr05   as(4,ih,j,i)=as4+two*as6*fok1
        as(4,ih,j,i)=as4+(two*as6)*fok1                                  !hr05
!hr05   as(5,ih,j,i)=-rv*sm12/(c4e3*rho*rho)+as6*fok1*fok1+fok1*as4
        as(5,ih,j,i)=(as6*fok1*2+fok1*as4)-(rv*sm12)/(c4e3*rho**2)       !hr05
        as(6,ih,j,i)=as6
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        g=tan_rn(fok*half)/rho
        gl=el(i)*g
        al(1,ih,j,i)=one-gl
        al(2,ih,j,i)=el(i)
!hr05   al(3,ih,j,i)=-g*(two-gl)
        al(3,ih,j,i)=(-1d0*g)*(two-gl)                                   !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
!hr05   as6=-rv*al(2,ih,j,i)/c2e3
        as6=((-1d0*rv)*al(2,ih,j,i))/c2e3                                !hr05
!hr05   as(4,ih,j,i)=-two*as6*fok1
        as(4,ih,j,i)=((-1d0*two)*as6)*fok1                               !hr05
!hr05   as(5,ih,j,i)=as6*fok1*fok1
        as(5,ih,j,i)=as6*fok1**2                                         !hr05
        as(6,ih,j,i)=as6
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
!hr05   60   fok=el(i)*ed(i)/dpsq
   60   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_rn(fok)
        co=cos_rn(fok)
!hr05   rhoc=rho*(one-co)/dpsq
        rhoc=(rho*(one-co))/dpsq                                         !hr05
        siq=si/dpsq
        al(1,ih,j,i)=co
        al(2,ih,j,i)=rho*si
!hr05   al(3,ih,j,i)=-si/rho
        al(3,ih,j,i)=(-1d0*si)/rho                                       !hr05
        al(4,ih,j,i)=co
!hr05   al(5,ih,j,i)=-dpp*rhoc*c1e3
        al(5,ih,j,i)=((-1d0*dpp)*rhoc)*c1e3                              !hr05
!hr05   al(6,ih,j,i)=-dpp*siq*c1e3
        al(6,ih,j,i)=((-1d0*dpp)*siq)*c1e3                               !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
!hr05   as(1,ih,j,i)=(-rv*(dpp*dpp/(four*dpd)*sm12 +dpp*(el(i)-         &
!hr05&al(2,ih,j,i)))+el(i)*(one-rv))*c1e3
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12 +     &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))*c1e3                                    !hr05
!hr05   as(2,ih,j,i)=-rv*(dpp/(two*rho*dpsq)*sm12-dpd*siq)
        as(2,ih,j,i)=(-1d0*rv)*((dpp/((two*rho)*dpsq))*sm12-dpd*siq)     !hr05
!hr05   as(3,ih,j,i)=-rv*(dpp*rho/(two*dpsq)*sm23-dpd*rhoc)
        as(3,ih,j,i)=(-1d0*rv)*(((dpp*rho)/(two*dpsq))*sm23-dpd*rhoc)    !hr05
!hr05   as(4,ih,j,i)=-rv*sm23/c2e3
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
!hr05   as(5,ih,j,i)=-rv*sm12/(c4e3*rho*rho)
        as(5,ih,j,i)=((-1d0*rv)*sm12)/(c4e3*rho**2)                      !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        al(1,ih,j,i)=one
        al(2,ih,j,i)=el(i)
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
!hr05   as(6,ih,j,i)=-rv*al(2,ih,j,i)/c2e3
        as(6,ih,j,i)=((-1d0*rv)*al(2,ih,j,i))/c2e3                       !hr05
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        aek=abs(fok)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(aek)
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
        al(1,ih,j,i)=cos_rn(fi)
        hi1=sin_rn(fi)
        al(2,ih,j,i)=hi1/hi
!hr05   al(3,ih,j,i)=-hi1*hi
        al(3,ih,j,i)=(-1d0*hi1)*hi                                       !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
!hr05   as(1,ih,j,i)=el(i)*(one-rv)*c1e3
        as(1,ih,j,i)=(el(i)*(one-rv))*c1e3                               !hr05
!hr05   as(4,ih,j,i)=-rv*al(2,ih,j,i)*al(3,ih,j,i)/c2e3
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
!hr05   as(5,ih,j,i)=-rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i))*aek/c4e3
      as(5,ih,j,i)=(((-1d0*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  110   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
!hr05   as(4,ih,j,i)=-rv*al(2,ih,j,i)*al(3,ih,j,i)/c2e3
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
!hr05   as(5,ih,j,i)=+rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i))*aek/c4e3
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.1) goto 100
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
!hr05   fok=fokq/(dpd)-wf*wf
        fok=fokq/(dpd)-wf**2                                             !hr05
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
        si=sin_rn(fi)
        co=cos_rn(fi)
!hr05   wfa=wf/afok*(one-co)/dpsq
        wfa=((wf/afok)*(one-co))/dpsq                                    !hr05
!hr05   wfhi=wf/hi*si/dpsq
        wfhi=((wf/hi)*si)/dpsq                                           !hr05
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
!hr05   al(3,ih,j,i)=-si*hi
        al(3,ih,j,i)=(-1d0*si)*hi                                        !hr05
        al(4,ih,j,i)=co
!hr05   al(5,ih,j,i)=-wfa*dpp*c1e3
        al(5,ih,j,i)=((-1d0*wfa)*dpp)*c1e3                               !hr05
!hr05   al(6,ih,j,i)=-wfhi*dpp*c1e3
        al(6,ih,j,i)=((-1d0*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
!hr05   as(1,ih,j,i)=(-rv*(dpp*dpp/(four*dpd)*sm12+dpp*(el(i)-          &
!hr05&al(2,ih,j,i)))/afok*wf*wf+el(i)*(one-rv))*c1e3
        as(1,ih,j,i)=(el(i)*(one-rv)-((rv*((dpp**2/(four*dpd))*sm12+    &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))/afok)*wf**2)*c1e3                       !hr05
!hr05   as(2,ih,j,i)=-rv*(dpp*wf/(two*dpsq)*sm12-dpd*wfhi)
        as(2,ih,j,i)=(-1d0*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
!hr05   as(3,ih,j,i)=-rv*(dpp*half/afok/dpd*ed(i)*sm23-dpd*wfa)
        as(3,ih,j,i)=(-1d0*rv)*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-   &!hr05
     &dpd*wfa)                                                           !hr05
!hr05   as(4,ih,j,i)=-rv*sm23/c2e3
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
!hr05   as(5,ih,j,i)=-rv*sm12*afok/c4e3
        as(5,ih,j,i)=(((-1d0*rv)*sm12)*afok)/c4e3                        !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=el(i)
        if(abs(hi).le.pieni) goto 150
        al(2,ih,j,i)=hs/hi
  150   al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
!hr05   as(4,ih,j,i)=-rv*al(2,ih,j,i)*al(3,ih,j,i)/c2e3
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
!hr05   as(5,ih,j,i)=+rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i))*aek/c4e3
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
!hr05   wfa=wf/afok*(one-hc)/dpsq
        wfa=((wf/afok)*(one-hc))/dpsq                                    !hr05
!hr05   wfhi=wf/hi*hs/dpsq
        wfhi=((wf/hi)*hs)/dpsq                                           !hr05
!hr05   al(5,ih,j,i)= wfa*dpp*c1e3
        al(5,ih,j,i)= (wfa*dpp)*c1e3                                     !hr05
!hr05   al(6,ih,j,i)=-wfhi*dpp*c1e3
        al(6,ih,j,i)=((-1d0*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
!hr05   as(1,ih,j,i)=(rv*(dpp*dpp/(four*dpd)*sm12+dpp*(el(i)-           &
!hr05&al(2,ih,j,i)))/afok*wf*wf+el(i)*(one-rv))*c1e3
        as(1,ih,j,i)=(((rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-        &!hr05
     &al(2,ih,j,i))))/afok)*wf**2+el(i)*(one-rv))*c1e3                   !hr05
!hr05   as(2,ih,j,i)=-rv*(dpp*wf/(two*dpsq)*sm12-dpd*wfhi)
        as(2,ih,j,i)=(-1d0*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
!hr05   as(3,ih,j,i)=rv*(dpp*half/afok/dpd*ed(i)*sm23-dpd*wfa)
        as(3,ih,j,i)=rv*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-dpd*wfa)   !hr05
!hr05   as(4,ih,j,i)=-rv*sm23/c2e3
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
!hr05   as(5,ih,j,i)=+rv*sm12*afok/c4e3
        as(5,ih,j,i)=((rv*sm12)*afok)/c4e3                               !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
        si=sin_rn(fi)
        co=cos_rn(fi)
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
!hr05   al(3,ih,j,i)=-si*hi
        al(3,ih,j,i)=(-1d0*si)*hi                                        !hr05
        al(4,ih,j,i)=co
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
!hr05   as(5,ih,j,i)=-rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i))*aek/c4e3
      as(5,ih,j,i)=(((-1d0*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
!hr05   as(6,ih,j,i)=-rv*(el(i)+al(1,ih,j,i)*al(2,ih,j,i))/c4e3
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
!hr05   fokq=-ek(i)
        fokq=-1d0*ek(i)                                                  !hr05
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
!hr05   fok=rhoi*tan_rn(el(i)*rhoi*half)
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr05
        al(1,1,j,i)=one
        al(2,1,j,i)=zero
        al(3,1,j,i)=fok
        al(4,1,j,i)=one
        al(1,2,j,i)=one
        al(2,2,j,i)=zero
!hr05   al(3,2,j,i)=-fok
        al(3,2,j,i)=-1d0*fok                                             !hr05
        al(4,2,j,i)=one
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
      return
      end
      program maincr
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  F. SCHMIDT, M. VANTTINEN
!
!  COLLIMATION VERSION, NOVEMBER 2004
!
!  G. ROBERT-DEMOLAIZE
!
!  COLLIMATION UPGRADE, JUNE 2005
!
!  G. ROBERT-DEMOLAIZE, S. REDAELLI
!
!-----------------------------------------------------------------------
!  SIXTRACR CHECKPOINT/RESTART and CRLIBM (ENS Lyon)
!
!  E. MCINTOSH FEBRUARY 2005
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!  DATA FOR SUMMARY OF THE POSTPROCESSING   : UNIT 10
!  AUXILIARY FILE FOR THE INPUT             : UNIT 11
!  ASCII FILE WITH THE HORIZONTAL FFT DATA  : UNIT 14
!  ASCII FILE WITH THE VERTICAL FFT DATA    : UNIT 15
!  METAFILE FOR PLOTTING WITH GKS           : UNIT 20
!
!-----------------------------------------------------------------------
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      double precision tasm
      common/tasm/tasm(6,6)
      double precision aml6,edcor
      common/sixdim/aml6(6,6),edcor(2)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
! Eric needs nwri (clean up new variables and common blocks!)
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each ele
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
 
      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (norma
 
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be act
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
 
      character dump_fname (0:nele)*(getfields_l_max_string)
 
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
!     M. Fitterer, for CERN BE-ABP/HSS and Fermilab
!     Common block for the FMA analysis postprocessing
      integer, parameter :: fma_max       = 200              !max. number of FMA
      integer, parameter :: fma_nturn_max = 10000            !max. number of tur
      integer fma_numfiles                                   !number of FMAs
      logical fma_flag                                       !FMA input block ex
      character fma_fname  (fma_max)*(getfields_l_max_string)!name of input file
      character fma_method (fma_max)*(getfields_l_max_string)!method used to fin
      integer fma_nturn    (fma_max)                         !number of turns us
      integer fma_norm_flag(fma_max)                         !fma_norm_flag=0, d
      common /fma_var/ fma_fname,fma_method,fma_numfiles,fma_flag,
     &fma_norm_flag,fma_nturn
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,&
     &idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
     &jm,k,kpz,kzz,l,lkk,ll,m,mkk,ncorruo,ncrr,nd,nd2,ndafi2,           &
     &nerror,nlino,nlinoo,nmz,nthinerr
      double precision alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
     &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
     &dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
     &gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
     &rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
     &tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
     &taus,x11,x13
      integer idummy(6)
      character*10 cmonth
      character*4 cpto
      character*80 day,runtim
      character*8 cdate,ctime,progrm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
      logical lopen
      dimension cmonth(12)
      data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
     &'  April   ','   May    ','   June   ','   July   ',' August  ',  &
     &' September',' October  ',' November ',' December '/
      character*8 version
      character*10 moddate
      integer itot,ttot
      data version /'4.5.35'/
      data moddate /'13.06.2016'/
!-----------------------------------------------------------------------
! Removed the call to disable_xp for Laurent
! but re-instated it
      call disable_xp()
! Set napx,napxo,trtime for error handling
      napx=0
      napxo=0
      trtime=0.0
      napxto=0
      runtim=''
!-----------------------------------------------------------------------
!--OPENING DATA FILES
      open(2,file='fort.2',form='formatted',status='unknown')
      open(3,file='fort.3',form='formatted',status='unknown')
      open(4,file='fort.4',form='formatted',status='unknown')
      open(7,file='fort.7',form='formatted',status='unknown')
      open(8,file='fort.8',form='formatted',status='unknown')
      open(9,file='fort.9',form='formatted',status='unknown')
! We no longer open fort.10 except for BOINC AND BNLELENS
! When we are returning everything from BOINC we can
! use the proper files as normal
      open(11,file='fort.11',form='formatted',status='unknown')
      open(12,file='fort.12',form='formatted',status='unknown')
      open(13,file='fort.13',form='formatted',status='unknown')
      open(14,file='fort.14',form='formatted',status='unknown')
      open(15,file='fort.15',form='formatted',status='unknown')
      open(16,file='fort.16',form='formatted',status='unknown')
      open(17,file='fort.17',form='formatted',status='unknown')
      open(18,file='fort.18',form='formatted',status='unknown')
      open(19,file='fort.19',form='formatted',status='unknown')
      open(20,file='fort.20',form='formatted',status='unknown')
      open(21,file='fort.21',form='formatted',status='unknown')
      open(22,file='fort.22',form='formatted',status='unknown')
      open(23,file='fort.23',form='formatted',status='unknown')
      open(24,file='fort.24',form='formatted',status='unknown')
      open(25,file='fort.25',form='formatted',status='unknown')
      open(26,file='fort.26',form='formatted',status='unknown')
      open(27,file='fort.27',form='formatted',status='unknown')
      open(28,file='fort.28',form='formatted',status='unknown')
      open(29,file='fort.29',form='formatted',status='unknown')
      open(30,file='fort.30',form='formatted',status='unknown')
      open(31,file='fort.31',form='formatted',status='unknown')
      open(32,file='fort.32',form='unformatted',status='unknown')
      open(33,file='fort.33',form='formatted',status='unknown')
      open(34,file='fort.34',form='formatted',status='unknown')
      open(35,file='fort.35',form='formatted',status='unknown')
      open(59,file='fort.59',form='unformatted',status='unknown')
      open(60,file='fort.60',form='unformatted',status='unknown')
      open(61,file='fort.61',form='unformatted',status='unknown')
      open(62,file='fort.62',form='unformatted',status='unknown')
      open(63,file='fort.63',form='unformatted',status='unknown')
      open(64,file='fort.64',form='unformatted',status='unknown')
      open(65,file='fort.65',form='unformatted',status='unknown')
      open(66,file='fort.66',form='unformatted',status='unknown')
      open(67,file='fort.67',form='unformatted',status='unknown')
      open(68,file='fort.68',form='unformatted',status='unknown')
      open(69,file='fort.69',form='unformatted',status='unknown')
      open(70,file='fort.70',form='unformatted',status='unknown')
      open(71,file='fort.71',form='unformatted',status='unknown')
      open(72,file='fort.72',form='unformatted',status='unknown')
      open(73,file='fort.73',form='unformatted',status='unknown')
      open(74,file='fort.74',form='unformatted',status='unknown')
      open(75,file='fort.75',form='unformatted',status='unknown')
      open(76,file='fort.76',form='unformatted',status='unknown')
      open(77,file='fort.77',form='unformatted',status='unknown')
      open(78,file='fort.78',form='unformatted',status='unknown')
      open(79,file='fort.79',form='unformatted',status='unknown')
      open(80,file='fort.80',form='unformatted',status='unknown')
      open(81,file='fort.81',form='unformatted',status='unknown')
      open(82,file='fort.82',form='unformatted',status='unknown')
      open(83,file='fort.83',form='unformatted',status='unknown')
      open(84,file='fort.84',form='unformatted',status='unknown')
      open(85,file='fort.85',form='unformatted',status='unknown')
      open(86,file='fort.86',form='unformatted',status='unknown')
      open(87,file='fort.87',form='unformatted',status='unknown')
      open(88,file='fort.88',form='unformatted',status='unknown')
      open(89,file='fort.89',form='unformatted',status='unknown')
      open(90,file='fort.90',form='unformatted',status='unknown')
      open(98,file='fort.98',form='formatted',status='unknown')
!Eric for the DA coefficients in BINARY
      open(111,file='fort.111',form='unformatted')
! Write a BINARY fort.10 of sumda for checking
      open(110,file='fort.110',form='unformatted')
 
      write(*,10010) version,moddate
      tlim=1e7
      call timest(tlim)
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)// &
     &'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(*,'(a80)') runtim
!     A normal start, time0 is beginning
      pretime=0.0
      trtime=0.0
      posttime=0.0
      tottime=0.0
      time0=0.0
      time1=0.0
      time2=0.0
      time3=0.0
      tlim=1e7
      call timest(tlim)
      call timex(time0)
      do 10 i=1,nblz
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
   10 continue
      do 20 i=1,mmul
        cr(i)=zero
        ci(i)=zero
   20 continue
      do 30 i=1,2
        eps(i)=zero
        epsa(i)=zero
        ekk(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      do 60 i=1,npart
        nnumxv(i)=0
        xv(1,i)=zero
        xv(2,i)=zero
        yv(1,i)=zero
        yv(2,i)=zero
        dam(i)=zero
        ekkv(i)=zero
        sigmv(i)=zero
        dpsv(i)=zero
        dp0v(i)=zero
        ejv(i)=zero
        ejfv(i)=zero
        xlv(i)=zero
        zlv(i)=zero
        rvv(i)=one
        ejf0v(i)=zero
        dpd(i)=zero
        dpsq(i)=zero
        fok(i)=zero
        rho(i)=zero
        fok1(i)=zero
        si(i)=zero
        co(i)=zero
        g(i)=zero
        gl(i)=zero
        sm1(i)=zero
        sm2(i)=zero
        sm3(i)=zero
        sm12(i)=zero
        as3(i)=zero
        as4(i)=zero
        as6(i)=zero
        sm23(i)=zero
        rhoc(i)=zero
        siq(i)=zero
        aek(i)=zero
        afok(i)=zero
        hp(i)=zero
        hm(i)=zero
        hc(i)=zero
        hs(i)=zero
        wf(i)=zero
        wfa(i)=zero
        wfhi(i)=zero
        rhoi(i)=zero
        hi(i)=zero
        fi(i)=zero
        hi1(i)=zero
        xvl(1,i)=zero
        xvl(2,i)=zero
        yvl(1,i)=zero
        yvl(2,i)=zero
        ejvl(i)=zero
        dpsvl(i)=zero
        oidpsv(i)=one
        sigmvl(i)=zero
        iv(i)=0
        aperv(i,1)=zero
        aperv(i,2)=zero
        ixv(i)=0
        clov(1,i)=zero
        clov(2,i)=zero
        clo6v(1,i)=zero
        clo6v(2,i)=zero
        clo6v(3,i)=zero
        clopv(1,i)=zero
        clopv(2,i)=zero
        clop6v(1,i)=zero
        clop6v(2,i)=zero
        clop6v(3,i)=zero
        alf0v(i,1)=zero
        alf0v(i,2)=zero
        bet0v(i,1)=zero
        bet0v(i,2)=zero
        ampv(i)=zero
        do 40 i1=1,nblo
          do 40 i2=1,2
            do 40 i3=1,6
              hv(i3,i2,i,i1)=zero
              bl1v(i3,i2,i,i1)=zero
   40   continue
        do 50 i1=1,6
          do 50 i2=1,6
            tas(i,i1,i2)=zero
   50   continue
        qwcs(i,1)=zero
        qwcs(i,2)=zero
        qwcs(i,3)=zero
        di0xs(i)=zero
        di0zs(i)=zero
        dip0xs(i)=zero
        dip0zs(i)=zero
   60 continue
      qwc(3)=zero
      call comnul
      commen=' '
      progrm='SIXTRACK'
      pi=four*atan_rn(one)
      pi2=pi*half
      pisqrt=sqrt(pi)
!hr05 rad=pi/180
      rad=pi/180d0                                                       !hr05
      call daten
      if(ithick.eq.1) write(*,10030)
      if(ithick.eq.0) write(*,10040)
      if(ibidu.eq.2) then
        write(*,10025)
        goto 550
      endif
!--SETTING UP THE PLOTTING
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call hlimit(nplo)
        call hplint(kwtype)
        call igmeta(-20,-111)
        cpto='NPTO'
        if(icr.eq.1) cpto='PTO '
        call hplopt(cpto,1)
        call hplopt('DATE',1)
        call hplset('DATE',1.)
        call hplset('CSIZ',.15)
      endif
      if(ipos.eq.1.and.napx.eq.0) then
! and now we open fort.10 unless already opened for
! BOINC AND BNLELENS
 
 
 
      open(10,file='fort.10',form='formatted',status='unknown')
        do 70 i=1,ndafi
          call postpr(91-i)
   70   continue
        call sumpos
        goto 520
      endif
      do 90 i=1,20
        fake(1,i)=zero
   90 fake(2,i)=zero
      itra=2
      amp00=amp(1)
!hr05 if(napx.ne.1) damp=(amp00-amp0)/(napx-1)/2
      if(napx.ne.1) damp=((amp00-amp0)/dble(napx-1))/2d0                 !hr05
      napx=2*napx
      iation=abs(ition)
      ib0=0
      dp00=dp1
      if(napx.le.0.or.imc.le.0) goto 490
      do 260 m=1,mmac
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
        if(m.ge.2) then
          call recuin(m*izu0,irecuin)
          call ranecu(zfz,nzfz,mcut)
          rsum=zero
          do 100 i=1,nzfz
  100     rsum=rsum+zfz(i)
!hr05     rmean=rsum/nzfz
          rmean=rsum/dble(nzfz)                                          !hr05
          rsqsum=zero
          do 110 i=1,nzfz
  110     rsqsum=rsqsum+(zfz(i)-rmean)*(zfz(i)-rmean)
!hr05     rdev=sqrt(rsqsum/nzfz)
          rdev=sqrt(rsqsum/dble(nzfz))                                   !hr05
          write(*,10320) m*izu0,nzfz,rmean,rdev
          write(*,10070)
        endif
        if(m.eq.1) call ord
        call clorb(ded)
        do 120 l=1,2
          clo0(l)=clo(l)
  120   clop0(l)=clop(l)
        call clorb(zero)
        do 130 l=1,2
          ll=2*l
          di0(l)=(clo0(l)-clo(l))/ded
  130   dip0(l)=(clop0(l)-clop(l))/ded
        call corrorb
        if(irmod2.eq.1) call rmod(dp1)
        if(iqmod.ne.0) call qmod0
        if(ichrom.eq.1.or.ichrom.eq.3) call chroma
        if(iskew.ne.0) call decoup
        if(ilin.eq.1.or.ilin.eq.3) then
          call linopt(dp1)
        endif
!--beam-beam element
        nlino=nlin
        nlin=0
        if(nbeam.ge.1) then
          do 135 i=1,nele
            if(kz(i).eq.20) then
              nlin=nlin+1
              if(nlin.gt.nele) call prror(81)
              bezl(nlin)=bez(i)
            endif
  135     continue
        endif
        if(isub.eq.1) call subre(dp1)
        if(ise.eq.1) call search(dp1)
 
        !! Initialize kicks
        izu=0
        do 150 i=1,iu
          ix=ic(i)
          if(ix.le.nblo) goto 150
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 150
          if(iorg.lt.0) mzu(i)=izu
          izu=mzu(i)+1
          smizf(i)=zfz(izu)*ek(ix)
          smiv(m,i)=sm(ix)+smizf(i) ! Also in initalize_element!
          smi(i)=smiv(m,i)          ! Also in initalize_element!
          izu=izu+1
          xsiv(m,i)=xpl(ix)+zfz(izu)*xrms(ix)
          xsi(i)=xsiv(m,i)
          izu=izu+1
          zsiv(m,i)=zpl(ix)+zfz(izu)*zrms(ix)
          zsi(i)=zsiv(m,i)
          if(mout2.eq.1) then
            if(kzz.eq.11) zfz(izu-2)=zero
            if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
            if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
            if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
            write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),           &
     &zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
          endif
 
!-- MULTIPOLE BLOCK
          if(kzz.eq.11) then
             dynk_izuIndex(ix)=izu
!-- Initialize multipoles, combining settings from fort.2 with
!-- coefficients from MULT and random values from FLUC.
!-- Used in program maincr and from initialize_element.
      r0=ek(ix)
      if(abs(r0).le.pieni) goto 150 ! label 150 - just after this code
      nmz=nmu(ix)
      if(nmz.eq.0) then
         izu=izu+2*mmul
         goto 150
      endif
      im=irm(ix)
      r0a=one
      do k=1,nmz
         izu=izu+1
!     hr05         aaiv(k,m,i)=ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k))/r0a
         aaiv(k,m,i)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a !hr05
         aai(i,k)=aaiv(k,m,i)
         izu=izu+1
!     hr05         bbiv(k,m,i)=ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k))/r0a
         bbiv(k,m,i)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a !hr05
         bbi(i,k)=bbiv(k,m,i)
 
         r0a=r0a*r0
      enddo
 
      izu=izu+2*mmul-2*nmz
!-------------------------------------------------------------------------------
 
          endif
 150   continue
        dp1=zero
        if(ichrom.gt.1) then
          itiono=ition
          ition=0
          call chromda
          ition=itiono
          do ncrr=1,iu
            ix=ic(ncrr)
            if(ix.gt.nblo) ix=ix-nblo
            if(ix.eq.is(1).or.iratioe(ix).eq.is(1)) then
              smiv(m,ncrr)=smi(ncrr)
            else if(ix.eq.is(2).or.iratioe(ix).eq.is(2)) then
              smiv(m,ncrr)=smi(ncrr)
            endif
          enddo
        endif
        dp1=dp00
        dp0=dp00
        if(imc.gt.1) then
!hr05     ddp1=two*dp0/(imc-one)
          ddp1=(two*dp0)/(dble(imc)-one)                                 !hr05
        endif
        do 250 ib=1,imc
          if(imc.gt.1) then
!hr05       dp1=dp0-(ib-1)*ddp1
            dp1=dp0-(dble(ib)-1d0)*ddp1                                  !hr05
          endif
          dp10=dp1
!-----------------------------------------------------------------------
          if(idp.ne.1.or.iation.ne.1) iclo6=0
          if (iclo6.eq.1.or.iclo6.eq.2) then
            if(ib.eq.1) then
              if(iclo6r.eq.0) then
                clo6(1)=clo(1)
                clop6(1)=clop(1)
                clo6(2)=clo(2)
                clop6(2)=clop(2)
                clo6(3)=zero
                clop6(3)=zero
              else
                read(33,*) ch
                lineno=lineno+1
                ch1(:nchars+3)=ch(:nchars)//' / '
                call splitfld(errno,33,lineno,nofields,nf,ch1,fields)
                do l=1,3
                  if (nf.gt.0) then
                    clo6(l)=fround(errno,fields,l*2-1)
                    nf=nf-1
                  endif
                  if (nf.gt.0) then
                    clop6(l)=fround(errno,fields,l*2)
                    nf=nf-1
                  endif
                enddo
              endif
              call clorb(zero)
              call betalf(zero,qw)
              call phasad(zero,qwc)
              sigm(1)=clo6(3)
              dps(1)=clop6(3)
              call qmodda(3,qwc)
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
                nlin=nlinoo
              endif
              dp1=dp10+clop6(3)
            endif
            if(iqmod6.eq.1) then
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif
            do 190 ib1=1,napx
              ib3=ib1+(m+ib-2)*napx
!--beam-beam element
              clo6v(1,ib3)=clo6(1)
              clo6v(2,ib3)=clo6(2)
              clo6v(3,ib3)=clo6(3)
              clop6v(1,ib3)=clop6(1)
              clop6v(2,ib3)=clop6(2)
              clop6v(3,ib3)=clop6(3)
              di0xs(ib3)=di0(1)
              di0zs(ib3)=di0(2)
              dip0xs(ib3)=dip0(1)
              dip0zs(ib3)=dip0(2)
              qwcs(ib3,1)=qwc(1)
              qwcs(ib3,2)=qwc(2)
              qwcs(ib3,3)=qwc(3)
              do 180 i2=1,6
                do 180 j2=1,6
                  tas(ib3,i2,j2)=tasm(i2,j2)
  180         continue
  190       continue
          else
            if(idp.eq.1.and.iation.eq.1) then
              ncorruo=ncorru
              ncorru=1
              call clorb(zero)
              call betalf(zero,qw)
              call phasad(zero,qwc)
!--beam-beam element
              if(nbeam.ge.1) then
              nd=3
              nd2=6
              dps0=dps(1)
              dps(1)=zero
              iqmodc=4
              call mydaini(1,2,nd2,nd,nd2,1)
              ilinc=2
              call mydaini(2,2,nd2,nd,nd2,1)
              dps(1)=dps0
              endif
              ncorru=ncorruo
              iqmodc=3
              call mydaini(2,2,6,3,6,1)
              do i=1,2
!hr05           qwc(i)=int(qwc(i))+wxys(i)
                qwc(i)=dble(int(qwc(i)))+wxys(i)
              enddo
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
                nlin=nlinoo
              endif
            else
              dps(1)=dp1
              ncorruo=ncorru
              ncorru=1
              call clorb(dp1)
              call betalf(dp1,qw)
              call phasad(dp1,qwc)
              dp1=zero
!--beam-beam element
              dp1=dps(1)
              ncorru=ncorruo
              if(nvar2.le.5) then
                itiono=ition
                ition=0
              endif
              call qmodda(2,qwc)
              if(nvar2.le.5) ition=itiono
              if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                iqmodc=2
                call mydaini(1,2,5,2,5,1)
                ilinc=1
                call mydaini(2,2,5,2,5,1)
                nlin=nlinoo
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif
            do 170 i=1,napx
              iar=(m+ib-2)*napx+i
              clo6v(1,iar)=clo(1)
              clop6v(1,iar)=clop(1)
              clo6v(2,iar)=clo(2)
              clop6v(2,iar)=clop(2)
              di0xs(iar)=di0(1)
              di0zs(iar)=di0(2)
              dip0xs(iar)=dip0(1)
              dip0zs(iar)=dip0(2)
              qwcs(iar,1)=qwc(1)
              qwcs(iar,2)=qwc(2)
              qwcs(iar,3)=zero
              do 160 i2=1,4
                do 160 j2=1,4
  160         tas(iar,i2,j2)=tasm(i2,j2)
  170       continue
          endif
          iar=(m+ib-2)*napx+1
          tasiar16=tas(iar,1,6)*c1m3
          tasiar26=tas(iar,2,6)*c1m3
          tasiar36=tas(iar,3,6)*c1m3
          tasiar46=tas(iar,4,6)*c1m3
          tasiar56=tas(iar,5,6)*c1m3
          tasiar61=tas(iar,6,1)*c1e3
          tasiar62=tas(iar,6,2)*c1e3
          tasiar63=tas(iar,6,3)*c1e3
          tasiar64=tas(iar,6,4)*c1e3
          tasiar65=tas(iar,6,5)*c1e3
!hr05     bet0(1)=tas(iar,1,1)*tas(iar,1,1)+tas(iar,1,2)*tas(iar,1,2)
          bet0(1)=tas(iar,1,1)**2+tas(iar,1,2)**2                        !hr05
!hr05     bet0x2 =tas(iar,1,3)*tas(iar,1,3)+tas(iar,1,4)*tas(iar,1,4)
          bet0x2 =tas(iar,1,3)**2+tas(iar,1,4)**2                        !hr05
!hr05     bet0x3 =tas(iar,1,5)*tas(iar,1,5)+tasiar16*tasiar16
          bet0x3 =tas(iar,1,5)**2+tasiar16**2                            !hr05
!hr05     gam0x1 =tas(iar,2,1)*tas(iar,2,1)+tas(iar,2,2)*tas(iar,2,2)
          gam0x1 =tas(iar,2,1)**2+tas(iar,2,2)**2                        !hr05
!hr05     gam0x2 =tas(iar,2,3)*tas(iar,2,3)+tas(iar,2,4)*tas(iar,2,4)
          gam0x2 =tas(iar,2,3)**2+tas(iar,2,4)**2                        !hr05
!hr05     gam0x3 =tas(iar,2,5)*tas(iar,2,5)+tasiar26*tasiar26
          gam0x3 =tas(iar,2,5)**2+tasiar26**2                            !hr05
!hr05     alf0(1)=-(tas(iar,1,1)*tas(iar,2,1)+tas(iar,1,2)*tas(iar,2,2))
      alf0(1)=-1d0*(tas(iar,1,1)*tas(iar,2,1)+tas(iar,1,2)*tas(iar,2,2)) !hr05
!hr05     alf0x2 =-(tas(iar,1,3)*tas(iar,2,3)+tas(iar,1,4)*tas(iar,2,4))
      alf0x2 =-1d0*(tas(iar,1,3)*tas(iar,2,3)+tas(iar,1,4)*tas(iar,2,4)) !hr05
!hr05     alf0x3 =-(tas(iar,1,5)*tas(iar,2,5)+tasiar16*tasiar26)
      alf0x3 =-1d0*(tas(iar,1,5)*tas(iar,2,5)+tasiar16*tasiar26)         !hr05
!hr05     bet0(2)=tas(iar,3,3)*tas(iar,3,3)+tas(iar,3,4)*tas(iar,3,4)
          bet0(2)=tas(iar,3,3)**2+tas(iar,3,4)**2                        !hr05
!hr05     bet0z2 =tas(iar,3,1)*tas(iar,3,1)+tas(iar,3,2)*tas(iar,3,2)
          bet0z2 =tas(iar,3,1)**2+tas(iar,3,2)**2                        !hr05
!hr05     bet0z3 =tas(iar,3,5)*tas(iar,3,5)+tasiar36*tasiar36
          bet0z3 =tas(iar,3,5)**2+tasiar36**2                            !hr05
!hr05     gam0z1 =tas(iar,4,3)*tas(iar,4,3)+tas(iar,4,4)*tas(iar,4,4)
          gam0z1 =tas(iar,4,3)**2+tas(iar,4,4)**2                        !hr05
!hr05     gam0z2 =tas(iar,4,1)*tas(iar,4,1)+tas(iar,4,2)*tas(iar,4,2)
          gam0z2 =tas(iar,4,1)**2+tas(iar,4,2)**2                        !hr05
!hr05     gam0z3 =tas(iar,4,5)*tas(iar,4,5)+tasiar46*tasiar46
          gam0z3 =tas(iar,4,5)**2+tasiar46**2                            !hr05
!hr05     alf0(2)=-(tas(iar,3,3)*tas(iar,4,3)+tas(iar,3,4)*tas(iar,4,4))
      alf0(2)=-1d0*(tas(iar,3,3)*tas(iar,4,3)+tas(iar,3,4)*tas(iar,4,4)) !hr05
!hr05     alf0z2 =-(tas(iar,3,1)*tas(iar,4,1)+tas(iar,3,2)*tas(iar,4,2))
      alf0z2 =-1d0*(tas(iar,3,1)*tas(iar,4,1)+tas(iar,3,2)*tas(iar,4,2)) !hr05
!hr05     alf0z3 =-(tas(iar,3,5)*tas(iar,4,5)+tasiar36*tasiar46)
      alf0z3 =-1d0*(tas(iar,3,5)*tas(iar,4,5)+tasiar36*tasiar46)         !hr05
!hr05     bet0s1 =tas(iar,5,5)*tas(iar,5,5)+tasiar56*tasiar56
          bet0s1 =tas(iar,5,5)**2+tasiar56**2                            !hr05
!hr05     bet0s2 =tas(iar,5,1)*tas(iar,5,1)+tas(iar,5,2)*tas(iar,5,2)
          bet0s2 =tas(iar,5,1)**2+tas(iar,5,2)**2                        !hr05
!hr05     bet0s3 =tas(iar,5,3)*tas(iar,5,3)+tas(iar,5,4)*tas(iar,5,4)
          bet0s3 =tas(iar,5,3)**2+tas(iar,5,4)**2                        !hr05
!hr05     gam0s1 =tasiar65*tasiar65+tas(iar,6,6)*tas(iar,6,6)
          gam0s1 =tasiar65**2+tas(iar,6,6)**2                            !hr05
!hr05     gam0s2 =tasiar61*tasiar61+tasiar62*tasiar62
          gam0s2 =tasiar61**2+tasiar62**2                                !hr05
!hr05     gam0s3 =tasiar63*tasiar63+tasiar64*tasiar64
          gam0s3 =tasiar63**2+tasiar64**2                                !hr05
!hr05     alf0s1 =-(tas(iar,5,5)*tasiar65+tasiar56*tas(iar,6,6))
          alf0s1 =-1d0*(tas(iar,5,5)*tasiar65+tasiar56*tas(iar,6,6))     !hr05
!hr05     alf0s2 =-(tas(iar,5,1)*tasiar61+tas(iar,5,2)*tasiar62)
          alf0s2 =-1d0*(tas(iar,5,1)*tasiar61+tas(iar,5,2)*tasiar62)     !hr05
!hr05     alf0s3 =-(tas(iar,5,3)*tasiar63+tas(iar,5,4)*tasiar64)
          alf0s3 =-1d0*(tas(iar,5,3)*tasiar63+tas(iar,5,4)*tasiar64)     !hr05
          do 220 ib1=1,napx
            iar=ib1+(m+ib-2)*napx
            do 200 ib2=1,6
              do 200 ib3=1,6
  200       tau(ib2,ib3)=tas(iar,ib3,ib2)
            if(abs(tau(1,1)).le.pieni.and.abs(tau(2,2)).le.pieni) then
              tau(1,1)=one
              tau(2,2)=one
            endif
            if(abs(tau(3,3)).le.pieni.and.abs(tau(4,4)).le.pieni) then
              tau(3,3)=one
              tau(4,4)=one
            endif
            if(abs(tau(5,5)).le.pieni.and.abs(tau(6,6)).le.pieni) then
              tau(5,5)=one
              tau(6,6)=one
              call dinv(6,tau,6,idummy,nerror)
              its6d=0
              if(ntwin.ne.2) then
!hr05           taus=abs(tau(5,1))+abs(tau(5,2))+abs(tau(5,3))+abs      &
!hr05&(tau(5,4)) +abs(tau(5,5))+abs(tau(5,6))+abs(tau(6,1))             &
!hr05&+abs(tau(6,2)) +abs(tau(6,3))+abs(tau(6,4))+abs                   &
!hr05&(tau(6,5))+abs(tau(6,6)) +abs(tau(1,5))+abs(tau(2,5))             &
!hr05&+abs(tau(3,5))+abs(tau(4,5)) +abs(tau(1,6))+abs                   &
!hr05&(tau(2,6))+abs(tau(3,6))+abs(tau(4,6))-two
                taus=(((((((((((((((((((                                &!hr05
     &abs(tau(5,1))+abs(tau(5,2)))+abs(tau(5,3)))+abs                   &!hr05
     &(tau(5,4)))+abs(tau(5,5)))+abs(tau(5,6)))+abs(tau(6,1)))          &!hr05
     &+abs(tau(6,2)))+abs(tau(6,3)))+abs(tau(6,4)))+abs                 &!hr05
     &(tau(6,5)))+abs(tau(6,6)))+abs(tau(1,5)))+abs(tau(2,5)))          &!hr05
     &+abs(tau(3,5)))+abs(tau(4,5)))+abs(tau(1,6)))+abs                 &!hr05
     &(tau(2,6)))+abs(tau(3,6)))+abs(tau(4,6)))-two                      !hr05
                if(abs(taus).ge.pieni) its6d=1
              endif
              do 210 ib2=1,6
                do 210 ib3=1,6
                  tasau(iar,ib2,ib3)=tau(ib2,ib3)
  210         continue
            endif
  220     continue
          if(ierro.ne.0) then
            write(*,10230) dp1
            goto 520
          endif
          write(*,10070)
!hr05     phag=phas*180/pi
          phag=(phas*180d0)/pi                                           !hr05
          if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))         &
     &write(*,10170)                                                    &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
            if(iclo6.eq.0) then
              write(*,10150) phag,                                      &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(*,10160) phag,                                      &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)            &
     &write(*,10190) phag,                                              &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
            if(iclo6.eq.0) then
              write(*,10210)                                            &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(*,10220)                                            &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          write(*,10080) dp1
!hr05     e0f=sqrt(e0*e0-pma*pma)
          e0f=sqrt(e0**2-pma**2)                                         !hr05
          if(iclo6.eq.0) then
            write(*,10110) clo(1),clop(1),clo(2),clop(2),idz(1),        &
     &idz(2),                                                           &
     &iver, idfor,iclo6,ition
          else
            write(*,10120) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),   &
     &clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
          endif
          do 240 ib1=1,napx
            ib2=ib0+ib1
            clov(1,ib2)=clo(1)
            clov(2,ib2)=clo(2)
            clopv(1,ib2)=clop(1)
            clopv(2,ib2)=clop(2)
            bet0v(ib2,1)=bet0(1)
            bet0v(ib2,2)=bet0(2)
            alf0v(ib2,1)=alf0(1)
            alf0v(ib2,2)=alf0(2)
!hr05       ampv(ib2)=amp(1)-damp*(ib1-1)
            ampv(ib2)=amp(1)-damp*dble(ib1-1)                            !hr05
            dp0v(ib2)=dp10
            dpsv(ib2)=dp10
            oidpsv(ib2)=one/(one+dp1)
            nms(ib2)=m
            do 230 i=1,nele
              ekv(ib2,i)=ek(i)
  230       continue
  240     continue
          ib0=ib0+napx
  250   continue
  260 continue
 
!hr05 napx=napx*imc*mmac
      napx=(napx*imc)*mmac                                               !hr05
      napxo=napx
      if(ibidu.eq.1) then
      write(32)                                                         &
!
!  left out to do tracking
!  numl,niu,amp0,amp(2),damp,chi0,chid,rat,exz(2,6),time0,time1
!
!
     &ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
     &ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
     &idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
     &iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
     &hsyc,phasc,dppoff,sigmoff,tlen,                                   &
     &iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
     &sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
     &zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
     &mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
     &dech,dsm0,itco,itcro,itqv,iout,qw0,iq,iqmod,kpa,iqmod6,bez,elbe,  &
     &bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac,pac,  &
     &bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,apx,apz,sigma0,iclo,   &
     &ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
     &icoe,ise,mesa,mp,m21,m22,m23,                                     &
     &ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
     &rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
     &qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
     &iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
     &nprint,ndafi,qwsk,betx,betz,                                      &
     &alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
     &sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
     &sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
     &ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,                   &
     &as,al,sigm,dps,idz,dp1,itra,                                      &
     &x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
     &bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
     &nvar2,nsix,ncor,ipar,nordf,                                       &
     &nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
     &icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
     &ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
     &clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
     &dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
     &ejf0v,numxv,nms,nlostp,dpd,                                       &
     &dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
     &rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
     &ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
     &clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
     &di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr
      endif
  550 continue
      if(ibidu.eq.2) then
      read(32)                                                          &
!
!  left out to do tracking
!  numl,niu,amp0,amp(2),damp,chi0,chid,rat,exz(2,6),time0,time1
!
!
     &ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
     &ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
     &idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
     &iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
     &hsyc,phasc,dppoff,sigmoff,tlen,                                   &
     &iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
     &sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
     &zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
     &mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
     &dech,dsm0,itco,itcro,itqv,iout,qw0,iq,iqmod,kpa,iqmod6,bez,elbe,  &
     &bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac,pac,  &
     &bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,apx,apz,sigma0,iclo,   &
     &ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
     &icoe,ise,mesa,mp,m21,m22,m23,                                     &
     &ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
     &rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
     &qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
     &iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
     &nprint,ndafi,qwsk,betx,betz,                                      &
     &alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
     &sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
     &sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
     &ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,                   &
     &as,al,sigm,dps,idz,dp1,itra,                                      &
     &x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
     &bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
     &nvar2,nsix,ncor,ipar,nordf,                                       &
     &nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
     &icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
     &ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
     &clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
     &dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
     &ejf0v,numxv,nms,nlostp,dpd,                                       &
     &dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
     &rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
     &ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
     &clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
     &di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr
!hr05   damp=(amp(1)-amp0)/(napx/2-1)/2
        damp=((amp(1)-amp0)/dble(napx/2-1))/2d0                          !hr05
      endif
      do 80 i=1,npart
        pstop(i)=.false.
        nnumxv(i)=numl
   80 numxv(i)=numl
      rat0=rat
      do 340 ia=1,napx,2
        if(idfor.ne.2) then
!---------------------------------------  SUBROUTINE 'ANFB' IN-LINE
          write(*,10050)
          tasia56=tas(ia,5,6)*c1m3
!hr05     bet0x2=tas(ia,1,3)*tas(ia,1,3)+tas(ia,1,4)*tas(ia,1,4)
          bet0x2=tas(ia,1,3)**2+tas(ia,1,4)**2                           !hr05
!hr05     bet0z2=tas(ia,3,1)*tas(ia,3,1)+tas(ia,3,2)*tas(ia,3,2)
          bet0z2=tas(ia,3,1)**2+tas(ia,3,2)**2                           !hr05
!hr05     bet0s1=tas(ia,5,5)*tas(ia,5,5)+tasia56*tasia56
          bet0s1=tas(ia,5,5)**2+tasia56**2                               !hr05
          dsign=one
          rat=rat0
!hr05     if(tas(ia,3,3).lt.-pieni) rat=-rat
          if(tas(ia,3,3).lt.(-1d0*pieni)) rat=-1d0*rat                   !hr05
!hr05     if(rat.lt.-pieni) dsign=-one
          if(rat.lt.(-1d0*pieni)) dsign=-1d0*one                         !hr05
          x11=ampv(ia)/(sqrt(bet0v(ia,1))+sqrt(abs(rat)*bet0x2))
!hr05     x13=x11*dsign*sqrt(abs(rat))
          x13=(x11*dsign)*sqrt(abs(rat))                                 !hr05
!hr05     amp(2)=dsign*(1-iver)* (abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt   &
!hr05&(bet0v(ia,2)))
          amp(2)=(dsign*dble(1-iver))*(abs(x11)*sqrt(bet0z2)+abs(x13)*  &!hr05
     &sqrt(bet0v(ia,2)))                                                 !hr05
          x1(5)=zero
          x1(6)=dpsv(ia)*sqrt(bet0s1)
          chi=chi0*rad
          dchi=chid*rad
          do 320 i2=1,2
            i3=ia+i2-1
            sic=sin_rn(chi)
            coc=cos_rn(chi)
            x1(1)=x11*coc
            x1(2)=x11*sic
            x1(3)=x13*coc
            x1(4)=x13*sic
            do 300 ii=1,6
              x2(ii)=zero
              do 290 jj=1,6
                x2(ii)=x2(ii)+tas(ia,ii,jj)*x1(jj)
  290         continue
  300       continue
            if(iclo6.eq.1.or.iclo6.eq.2) then
!hr05         x2(2)=x2(2)/(one+x2(6)+clop6v(3,ia))
              x2(2)=x2(2)/((one+x2(6))+clop6v(3,ia))                     !hr05
!hr05         x2(4)=x2(4)/(one+x2(6)+clop6v(3,ia))
              x2(4)=x2(4)/((one+x2(6))+clop6v(3,ia))                     !hr05
            endif
            if(abs(bet0s1).le.pieni) x2(6)=dpsv(ia)
            if(iver.eq.1) then
              x2(3)=zero
              x2(4)=zero
            endif
            do 310 l=1,2
              ll=(l-1)*2
              xv(l,i3)=x2(1+ll)+exz(i2,1+ll)
              yv(l,i3)=x2(2+ll)+exz(i2,2+ll)
  310       continue
            sigmv(i3)=x2(5)+exz(i2,5)
            dpsv(i3)=x2(6)
            dpsic=dpsv(i3)+clop6v(3,ia)
            if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
              xv(1,i3)=xv(1,i3)+di0xs(ia)*dpsic
              xv(2,i3)=xv(2,i3)+di0zs(ia)*dpsic
              yv(1,i3)=yv(1,i3)+dip0xs(ia)*dpsic
              yv(2,i3)=yv(2,i3)+dip0zs(ia)*dpsic
            endif
            chi=chi+dchi
  320     continue
          write(*,10260) ia,nms(ia)*izu0,dpsv(ia)
          write(*,10060) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),           &
     &sigmv(ia),                                                        &
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1)
!---------------------------------------  END OF 'ANFB'
          if(iclo6.eq.2) then
            xv(1,ia)=xv(1,ia)+clo6v(1,ia)
            yv(1,ia)=yv(1,ia)+clop6v(1,ia)
            xv(2,ia)=xv(2,ia)+clo6v(2,ia)
            yv(2,ia)=yv(2,ia)+clop6v(2,ia)
            sigmv(ia)=sigmv(ia)+clo6v(3,ia)
            dpsv(ia)=dpsv(ia)+clop6v(3,ia)
            xv(1,ia+1)=xv(1,ia+1)+clo6v(1,ia)
            yv(1,ia+1)=yv(1,ia+1)+clop6v(1,ia)
            xv(2,ia+1)=xv(2,ia+1)+clo6v(2,ia)
            yv(2,ia+1)=yv(2,ia+1)+clop6v(2,ia)
            sigmv(ia+1)=sigmv(ia+1)+clo6v(3,ia)
            dpsv(ia+1)=dpsv(ia+1)+clop6v(3,ia)
            oidpsv(ia)=one/(one+dpsv(ia))
            oidpsv(ia+1)=one/(one+dpsv(ia+1))
          endif
          if(iclo6.ne.2) then
!hr05       xv(1,ia)=xv(1,ia)+clov(1,ia)*idz(1)*(1-idfor)
            xv(1,ia)=xv(1,ia)+(clov(1,ia)*dble(idz(1)))*dble(1-idfor)    !hr05
!hr05       yv(1,ia)=yv(1,ia)+clopv(1,ia)*idz(1)*(1-idfor)
            yv(1,ia)=yv(1,ia)+(clopv(1,ia)*dble(idz(1)))*dble(1-idfor)   !hr05
!hr05       xv(2,ia)=xv(2,ia)+clov(2,ia)*idz(2)*(1-idfor)
            xv(2,ia)=xv(2,ia)+(clov(2,ia)*dble(idz(2)))*dble(1-idfor)    !hr05
!hr05       yv(2,ia)=yv(2,ia)+clopv(2,ia)*idz(2)*(1-idfor)
            yv(2,ia)=yv(2,ia)+(clopv(2,ia)*dble(idz(2)))*dble(1-idfor)   !hr05
!hr05       xv(1,ia+1)=xv(1,ia+1)+clov(1,ia)*idz(1)*(1-idfor)
          xv(1,ia+1)=xv(1,ia+1)+(clov(1,ia)*dble(idz(1)))*dble(1-idfor)  !hr05
!hr05       yv(1,ia+1)=yv(1,ia+1)+clopv(1,ia)*idz(1)*(1-idfor)
          yv(1,ia+1)=yv(1,ia+1)+(clopv(1,ia)*dble(idz(1)))*dble(1-idfor) !hr05
!hr05       xv(2,ia+1)=xv(2,ia+1)+clov(2,ia)*idz(2)*(1-idfor)
          xv(2,ia+1)=xv(2,ia+1)+(clov(2,ia)*dble(idz(2)))*dble(1-idfor)  !hr05
!hr05       yv(2,ia+1)=yv(2,ia+1)+clopv(2,ia)*idz(2)*(1-idfor)
          yv(2,ia+1)=yv(2,ia+1)+(clopv(2,ia)*dble(idz(2)))*dble(1-idfor) !hr05
          endif
          ejfv(ia)=e0f*(one+dpsv(ia))
          ejfv(ia+1)=e0f*(one+dpsv(ia+1))
!hr05     ejv(ia)=sqrt(ejfv(ia)*ejfv(ia)+pma*pma)
          ejv(ia)=sqrt(ejfv(ia)**2+pma**2)                               !hr05
!hr05     ejv(ia+1)=sqrt(ejfv(ia+1)*ejfv(ia+1)+pma*pma)
          ejv(ia+1)=sqrt(ejfv(ia+1)**2+pma**2)                           !hr05
!hr05     epsa(1)=(ampv(ia)*ampv(ia)/bet0v(ia,1))
          epsa(1)=(ampv(ia)**2/bet0v(ia,1))                              !hr05
!hr05     epsa(2)=(amp(2)*amp(2)/bet0v(ia,2))
          epsa(2)=(amp(2)**2/bet0v(ia,2))                                !hr05
          write(*,10020) ampv(ia),amp(2),epsa
        else
          read(13,*,iostat=ierro) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),  &
     &sigmv(ia),dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv            &
     &(2,ia+1), sigmv(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
          if(ierro.ne.0) call prror(56)
!hr05     e0f=sqrt(e0*e0-pma*pma)
          e0f=sqrt(e0**2-pma**2)                                         !hr05
!hr05     ejfv(ia)=sqrt(ejv(ia)*ejv(ia)-pma*pma)
          ejfv(ia)=sqrt(ejv(ia)**2-pma**2)                               !hr05
!hr05     ejfv(ia+1)=sqrt(ejv(ia+1)*ejv(ia+1)-pma*pma)
          ejfv(ia+1)=sqrt(ejv(ia+1)**2-pma**2)                           !hr05
          oidpsv(ia)=one/(one+dpsv(ia))
          oidpsv(ia+1)=one/(one+dpsv(ia+1))
        endif
        write(*,10090) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),   &
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
        idam=3
        icode=0
        if(abs(xv(1,ia)).le.pieni.and.abs(yv(1,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+1
        endif
        if(abs(xv(2,ia)).le.pieni.and.abs(yv(2,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+2
        endif
        if(idp.eq.0.or.abs(ition).eq.0) then
          idam=idam-1
        else
          icode=icode+4
        endif
        if(idam.le.0) idam=1
        if(icode.le.0) icode=1
        ia2=(ia+1)/2
        if(ntwin.ne.2) then
          if(mod(ia+1,2).eq.0) then
            xau(1,1)= xv(1,ia)
            xau(1,2)= yv(1,ia)
            xau(1,3)= xv(2,ia)
            xau(1,4)= yv(2,ia)
            xau(1,5)=sigmv(ia)
            xau(1,6)= dpsv(ia)
            xau(2,1)= xv(1,ia+1)
            xau(2,2)= yv(1,ia+1)
            xau(2,3)= xv(2,ia+1)
            xau(2,4)= yv(2,ia+1)
            xau(2,5)=sigmv(ia+1)
            xau(2,6)= dpsv(ia+1)
            cloau(1)= clo6v(1,ia)
            cloau(2)=clop6v(1,ia)
            cloau(3)= clo6v(2,ia)
            cloau(4)=clop6v(2,ia)
            cloau(5)= clo6v(3,ia)
            cloau(6)=clop6v(3,ia)
            di0au(1)= di0xs(ia)
            di0au(2)=dip0xs(ia)
            di0au(3)= di0zs(ia)
            di0au(4)=dip0zs(ia)
            do 330 ib2=1,6
              do 330 ib3=1,6
                tau(ib2,ib3)=tasau(ia,ib2,ib3)
  330       continue
            call distance(xau,cloau,di0au,tau,dam1)
            dam(ia)=dam1
            dam(ia+1)=dam1
          endif
          write(91-ia2,iostat=ierro) sixtit,commen,cdate, ctime,progrm, &
     &ia,ia,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),clo6v     &
     &(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v(3,ia),        &
     &clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs(ia),zero,     &
     &one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas(ia,1,4),tas          &
     &(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas(ia,2,3),tas    &
     &(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas(ia,3,2),tas    &
     &(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas(ia,4,1),tas    &
     &(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas(ia,4,6), tas    &
     &(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas(ia,5,5), tas     &
     &(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas(ia,6,4),tas     &
     &(ia,6,5), tas(ia,6,6),                                            &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
        else
          write(91-ia2,iostat=ierro) sixtit,commen,cdate, ctime,progrm, &
     &ia,ia+1,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),        &
     &clo6v(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v          &
     &(3,ia),clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs        &
     &(ia),zero,one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas            &
     &(ia,1,4),tas(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas    &
     &(ia,2,3),tas(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas    &
     &(ia,3,2),tas(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas    &
     &(ia,4,1),tas(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas     &
     &(ia,4,6), tas(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas     &
     &(ia,5,5), tas(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas    &
     &(ia,6,4),tas(ia,6,5), tas(ia,6,6),                                &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
        endif
        if(ierro.ne.0) then
          write(*,*)
          write(*,*) '*** ERROR ***,PROBLEMS WRITING TO FILE # : ',91   &
     &-ia2
          write(*,*) 'ERROR CODE : ',ierro
          write(*,*)
          goto 520
        endif
  340 continue
      if(e0.gt.pieni) then
        do 350 j=1,napx
  350   rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      else
        call prror(79)
      endif
 
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
 
!!! Really only neccessary for thick 4d tracking !!!
!!! In FLUKA version, this is moved to new subroutine "blocksv" (in a new deck)
!-------------------------------------  START OF 'BLOCK'
      do 440 k=1,mblo
        jm=mel(k)
        ikk=mtyp(k,1)
        do 370 lkk=1,2
          do 370 mkk=1,6
            do 360 ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(mkk,lkk,ia,1)=al(mkk,lkk,ia,ikk)
  360       if(mkk.eq.5.or.mkk.eq.6) hv(mkk,lkk,ia,1)=hv(mkk,lkk,ia,1)  &
     &/dpoff
  370   continue
        if(jm.eq.1) goto 410
        do 400 j=2,jm
          ikk=mtyp(k,j)
          do 390 lkk=1,2
            do 380 ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(1,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(2,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(3,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(4,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
!hr05         hv(5,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(2,lkk,ia,ikk)+al(5,lkk,ia,ikk)/dpoff
              hv(5,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(2,lkk,ia,ikk))+al(5,lkk,ia,ikk)/dpoff               !hr05
!hr05         hv(6,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(4,lkk,ia,ikk)+al(6,lkk,ia,ikk)/dpoff
              hv(6,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(4,lkk,ia,ikk))+al(6,lkk,ia,ikk)/dpoff               !hr05
  380       continue
  390     continue
  400   continue
  410   do 430 lkk=1,2
          do 430 mkk=1,6
            do 420 ia=1,napx
  420       bl1v(mkk,lkk,ia,k)=hv(mkk,lkk,ia,jm)
  430   continue
  440 continue
!---------------------------------------  END OF 'BLOCK'
 
!     A.Mereghetti, P. G. Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-07-2014
!     call routine for calculating dcum, necessary for the online
!        aperture check and in case of dumping particle population
!        or statistics or beam matrix
!     always in main code
      call cadcum
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-09-2014
!     open units for dumping particle population or statistics or beam matrix
!     always in main code
      do i=0,il
        if (ldump(i)) then
!         the same file could be used by more than one SINGLE ELEMENT
          inquire( unit=dumpunit(i), opened=lopen )
          if ( .not.lopen ) then
             open(dumpunit(i),file=dump_fname(i),
     &            status='replace',form='formatted')
             if ( dumpfmt(i).eq.1 ) then
                write(dumpunit(i),*)
     &  '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] dE/E[1] ktrack'
             else if ( dumpfmt(i).eq.2 ) then
                if (i.eq.0) then
                   write(dumpunit(i),*)
     &  '# DUMP format #2, ALL ELEMENTS, number of particles=', napx
                   write(dumpunit(i),fmt=*)
     &  '# dump period=', ndumpt(i), ', first turn=', dumpfirst(i),
     &  ', last turn=', dumplast(i)
                else
                   write(dumpunit(i),*)
     &  '# DUMP format #2, bez=', bez(i), ', number of particles=', napx
                   write(dumpunit(i),fmt=*)
     &  '# dump period=', ndumpt(i), ', first turn=', dumpfirst(i),
     &  ', last turn=', dumplast(i)
                endif
                write(dumpunit(i),*)
     &  '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] z[mm] dE/E[1] ',
     &  'ktrack'
             end if
          else
             !Sanity check: If already open, it should be by another DUMP
             ! (can't guarantee for files after this one)
             ! Also should not be shared with element 0 (all)
             ! Also should be same format -- if so, add to the header.
 
             !reuse the lopen flag as a temp variable
             lopen = .false.
             do j=0,i-1
                if (dumpunit(j).eq.dumpunit(i)) then
                   if (dumpfmt(j).ne.dumpfmt(i)) then
                      write(*,*)
     & "ERROR in DUMP: ouput unit",dumpunit(i), " used by two DUMPS,",
     & " formats are not the same."
                      call prror(-1)
                   else if (j.eq.0) then
                      write(*,*)
     & "ERROR in DUMP: ouput unit",dumpunit(i), " used by two DUMPS,",
     & " one of which is ALL"
                      call prror(-1)
                   else if (dump_fname(j).ne.dump_fname(i)) then
                      write(*,*)
     & "ERROR in DUMP: Output unit",dumpunit(i),"is used by to DUMPS,"//
     & " but filenames differ:", dump_fname(i), " vs ", dump_fname(j)
                      call prror(-1)
                   else
                      ! Everything is fine
                      lopen = .true.
                      if (dumpfmt(i).eq.2) then !More header
                         write(dumpunit(i),*)
     &  '# DUMP format #2, bez=', bez(i), ', dump period=', ndumpt(i),
     &  ' HIGH=', ldumphighprec, ', FRONT=', ldumpfront
                      endif
                   endif
                endif
             end do
             !File was already open, but not by DUMP
             if ( .not.lopen ) then
                write (*,*)
     & "ERROR in DUMP: unit", dumpunit(i), " is already open, ",
     & " but not by DUMP. Please pick another unit! ",
     & " Note: This test is not watertight, as other parts of",
     & " the program may later open the same file/unit."
                call prror(-1)
             endif
          endif
        endif
      enddo
 
      write(*,10200)
      time1=0.
      call timex(time1)
! time1 is now pre-processing CPU
! note that this will be reset evry restart as we redo pre-processing
      pretime=time1-time0
!---------------------------------------  LOOP OVER TURNS TO BE TRACKED
      if(ithick.eq.0) call trauthin(nthinerr)
      if(ithick.eq.1) call trauthck(nthinerr)
      time2=0.
      call timex(time2)
! trtime is now the tracking time, BUT we must add other time for C/R
      trtime=time2-time1
      if(nthinerr.eq.3000) goto 520
      if(nthinerr.eq.3001) goto 460
!---------------------------------------  END OF LOOP OVER TURNS
  460 continue
      napxto=0
! and set numx=nnuml (for writebin) NOT for LOST particles
! because all lost set nnuml=numl
      numx=nnuml
      id=0
      call writebin(nthinerr)
      if(nthinerr.eq.3000) goto 520
! If CR we have to worry about turns printed in fort.6
! If lost should be OK, otherwise we need to use nnuml instead
! of the numl in numxv/nnumxv???? Eric.
! where we reset [n]numxv to nnuml UNLESS particle lost
! Now we shall try using that fix at start of tracking
      do 470 ia=1,napxo,2
        ie=ia+1
        ia2=(ie)/2
!hr05   napxto=napxto+numxv(ia)+numxv(ie)
        napxto=(napxto+numxv(ia))+numxv(ie)                              !hr05
        if(pstop(ia).and.pstop(ie)) then
!-- BOTH PARTICLES LOST
          write(*,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),            &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(*,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),            &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(*,10280)                                                &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          if(ierro.ne.0) write(*,*) 'Warning from maincr: fort.12 has ',&
     &'corrupted output probably due to lost particle: ',ia,            &
     &' or: ',ie
        endif
        if(.not.pstop(ia).and.pstop(ie)) then
!-- SECOND PARTICLE LOST
          id=id+1
          write(*,10240) ia,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(*,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),            &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(*,10280)                                                &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          if(ierro.ne.0) write(*,*) 'Warning from maincr: fort.12 has ',&
     &'corrupted output probably due to lost particle: ',ie
        endif
        if(pstop(ia).and..not.pstop(ie)) then
!-- FIRST PARTICLE LOST
          id=id+1
          write(*,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),            &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(*,10240) ie,nms(ia)*izu0,dp0v(ia),numxv(ie)
          write(*,10280)                                                &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          if(ierro.ne.0) write(*,*) 'Warning from maincr: fort.12 has ',&
     &'corrupted output probably due to lost particle: ',ia
        endif
        if(.not.pstop(ia).and..not.pstop(ie)) then
!-- BOTH PARTICLES STABLE
          id=id+1
          ig=id+1
          write(*,10270) ia,ie,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(*,10280)                                                &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          if(ierro.ne.0) write(*,*) 'Warning from maincr: fort.12 has ',&
     &'corrupted output although particles stable'
          id=ig
        endif
  470 continue
! and we need to open fort.10 unless already opened
! for BOINC AND BNLELENS
 
 
 
 
      open(10,file='fort.10',form='formatted',status='unknown')
        iposc=0
        if(ipos.eq.1) then
          do 480 ia=1,napxo,2
            ia2=(ia+1)/2
            iposc=iposc+1
          call postpr(91-ia2)
  480     continue
          if(iposc.ge.1) call sumpos
        endif
        goto 520
  490   if(ipos.eq.1) then
          ndafi2=ndafi
          do 500 ia=1,ndafi2
            if(ia.gt.ndafi) goto 510
          call postpr(91-ia)
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
  520 continue
!     start fma
      if(fma_flag) then
        write(*,*)   'Calling FMA_POSTPR'
        call fma_postpr
      endif
!--HPLOTTING END
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call igmeta(999,0)
        call hplend
      endif
      time3=0.
      call timex(time3)
! Note that crpoint no longer destroys time2
      posttime=time3-time2
! and now get grand total including post-processing
      tottime=(pretime+trtime)+posttime
      write(*,10290) pretime
      write(*,10300) napxto,trtime
      write(*,10310) tottime
      call closeUnits
      stop
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i3,      &
     &' RANDOM SEED ',i8,/ t10,' MOMENTUM DEVIATION ',g12.5,            &
     &' LOST IN REVOLUTION ',i8,/ t10,'HORIZ:  AMPLITUDE = ',f15.3,     &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',f15.3,         &
     &'   APERTURE = ',f15.3/)
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
10020 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y = ',f15.3, '  PI*MRAD*MM')
10025 format(/t10,'Run started from binary dump file # 32')
10030 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10040 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10050 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
10060 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10070 format(/131('-'))
10080 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t8,                &
     &'========================================')
10090 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10110 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10120 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10150 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9,f15.9/)
10160 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10170 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10180 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10190 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10200 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10210 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10220 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10230 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,                &
     &'RELATIVE MOMENTUM DEVIATION')
10240 format(1x/5x,'PARTICLE ',i3,' STABLE - RANDOM SEED ', i8,         &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10250 format(1x/5x,'PARTICLE ',i3,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10260 format(1x/5x,'PARTICLE ',i3,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5/)
10270 format(1x/5x,'PARTICLE ',i3,' AND ',i3,' STABLE - RANDOM SEED ',  &
     &i8,' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10280 format(10x,f47.33)
10290 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10300 format(/10x,'For ',i12,' Turn(s)',g12.3,' second(s) of ',         &
     &'Computing Time was needed'//131('-'))
10310 format(//10x,'Total Time used: ',g12.3,' second(s)'//131('-'))
10320 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
10330 format(/10x,'ERROR IN OPENING FILES')
      end
      subroutine envarsv(dpsv,oidpsv,rvv,ekv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!  CAUTION:
!          A SPECIAL VERSION FOR VECTORIZATION - AUGUST   1994
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ih1,ih2,j,kz1,l,l1,l2
      double precision aek,afok,as3,as4,as6,co,dpd,dpsq,dpsv,ekv,fi,    &
     &fok,fok1,fokm,fokqv,g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,rho,rhoc,rhoi, &
     &rvv,si,siq,sm1,sm12,sm2,sm23,sm3,wf,wfa,wfhi
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
!-----------------------------------------------------------------------
      save
!-----------------------------------------------------------------------
      dimension ekv(npart,nele),fokqv(npart),dpsv(npart)
      dimension rvv(npart),oidpsv(npart)
      dimension dpd(npart),dpsq(npart),fok(npart),rho(npart)
      dimension fok1(npart),si(npart),co(npart),g(npart),gl(npart)
      dimension sm1(npart),sm2(npart),sm3(npart),sm12(npart)
      dimension as3(npart),as4(npart),as6(npart),sm23(npart)
      dimension rhoc(npart),siq(npart),aek(npart),afok(npart)
      dimension hp(npart),hm(npart),hc(npart),hs(npart),wf(npart)
      dimension wfa(npart),wfhi(npart),rhoi(npart)
      dimension hi(npart),fi(npart),hi1(npart)
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
   10 continue
      do 160 l=1,il
        do l1=1,6
          do j=1,napx
            do l2=1,2
              al(l1,l2,j,l)=zero
              as(l1,l2,j,l)=zero
            enddo
          enddo
        enddo
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 80
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 40
        if (kz1.eq.6) goto 60
        if (kz1.eq.7) goto 100
        if (kz1.eq.8) goto 100
        if (kz1.eq.9) goto 140
        goto 160
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          al(1,1,j,l)=one
          al(1,2,j,l)=one
          al(2,1,j,l)=el(l)
          al(2,2,j,l)=el(l)
          al(3,1,j,l)=zero
          al(3,2,j,l)=zero
          al(4,1,j,l)=one
          al(4,2,j,l)=one
!hr06     as(6,1,j,l)=-rvv(j)*el(l)/c2e3
          as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                         !hr06
          as(6,2,j,l)=as(6,1,j,l)
!hr06     as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr06
   30   continue
        goto 160
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.2) then
          ih1=1
          ih2=2
        else
!  RECTANGULAR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 50 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          fok1(j)=(tan_rn(fok(j)*half))/rho(j)
          si(j)=sin_rn(fok(j))
          co(j)=cos_rn(fok(j))
          al(1,ih1,j,l)=one
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=zero
          al(4,ih1,j,l)=one
!hr06     al(5,ih1,j,l)=-dpsv(j)*(rho(j)*(one-co(j))/dpsq(j))*c1e3
      al(5,ih1,j,l)=((-1d0*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr06
!hr06     al(6,ih1,j,l)=-dpsv(j)*(two*tan_rn(fok(j)*half)/dpsq(j))*c1e3
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan_rn(fok(j)*half))/dpsq(j)))&!hr06
     &*c1e3                                                              !hr06
          sm1(j)=cos_rn(fok(j))
          sm2(j)=sin_rn(fok(j))*rho(j)
!hr06     sm3(j)=-sin_rn(fok(j))/rho(j)
          sm3(j)=(-1d0*sin_rn(fok(j)))/rho(j)                            !hr06
          sm12(j)=el(l)-sm1(j)*sm2(j)
          sm23(j)=sm2(j)*sm3(j)
!hr06     as3(j)=-rvv(j)*(dpsv(j)*rho(j)/(two*dpsq(j))*sm23(j)- rho(j)  &
!hr06&*dpsq(j)*(one-sm1(j)))
         as3(j)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr06
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr06
!hr06     as4(j)=-rvv(j)*sm23(j)/c2e3
          as4(j)=((-1d0*rvv(j))*sm23(j))/c2e3                            !hr06
!hr06     as6(j)=-rvv(j)*(el(l)+sm1(j)*sm2(j))/c4e3
          as6(j)=((-1d0*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3              !hr06
!hr06     as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*sm12(j)+&
!hr06&dpsv(j)*(el(l)-sm2(j)))+el(l)*(one-rvv(j)))*c1e3
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/            &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
!hr06     as(2,ih1,j,l)=-rvv(j)*(dpsv(j)/(two*rho(j)*dpsq(j))*sm12(j)-  &
!hr06&sm2(j)*dpsq(j)/rho(j))+fok1(j)*as3(j)
      as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*    &!hr06
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr06
          as(3,ih1,j,l)=as3(j)
!hr06     as(4,ih1,j,l)=as4(j)+two*as6(j)*fok1(j)
          as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                      !hr06
!hr06     as(5,ih1,j,l)=-rvv(j)*sm12(j)/(c4e3*rho(j)*rho(j))+ as6(j)    &
!hr06&*fok1(j)*fok1(j)+fok1(j)*as4(j)
          as(5,ih1,j,l)=(as6(j)*fok1(j)**2                              &!hr06
     &-(rvv(j)*sm12(j))/(c4e3*rho(j)**2))+fok1(j)*as4(j)                 !hr06
          as(6,ih1,j,l)=as6(j)
!--VERTIKAL
          g(j)=tan_rn(fok(j)*half)/rho(j)
          gl(j)=el(l)*g(j)
          al(1,ih2,j,l)=one-gl(j)
          al(2,ih2,j,l)=el(l)
!hr06     al(3,ih2,j,l)=-g(j)*(two-gl(j))
          al(3,ih2,j,l)=(-1d0*g(j))*(two-gl(j))                          !hr06
          al(4,ih2,j,l)=al(1,ih2,j,l)
!hr06     as6(j)=-rvv(j)*al(2,ih2,j,l)/c2e3
          as6(j)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3                      !hr06
!hr06     as(4,ih2,j,l)=-two*as6(j)*fok1(j)
          as(4,ih2,j,l)=((-1d0*two)*as6(j))*fok1(j)                      !hr06
!hr06     as(5,ih2,j,l)=as6(j)*fok1(j)*fok1(j)
          as(5,ih2,j,l)=as6(j)*fok1(j)**2                                !hr06
          as(6,ih2,j,l)=as6(j)
   50   continue
        goto 160
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.4) then
          ih1=1
          ih2=2
        else
!  SECTOR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 70 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          si(j)=sin_rn(fok(j))
          co(j)=cos_rn(fok(j))
!hr06     rhoc(j)=rho(j)*(one-co(j))/dpsq(j)
          rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                           !hr06
          siq(j)=si(j)/dpsq(j)
          al(1,ih1,j,l)=co(j)
          al(2,ih1,j,l)=rho(j)*si(j)
!hr06     al(3,ih1,j,l)=-si(j)/rho(j)
          al(3,ih1,j,l)=(-1d0*si(j))/rho(j)                              !hr06
          al(4,ih1,j,l)=co(j)
!hr06     al(5,ih1,j,l)=-dpsv(j)*rhoc(j)*c1e3
          al(5,ih1,j,l)=((-1d0*dpsv(j))*rhoc(j))*c1e3                    !hr06
!hr06     al(6,ih1,j,l)=-dpsv(j)*siq(j)*c1e3
          al(6,ih1,j,l)=((-1d0*dpsv(j))*siq(j))*c1e3                     !hr06
          sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
          sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr06     as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*sm12(j) &
!hr06&+dpsv(j)*(el(l)-al(2,ih1,j,l)))+el(l)*(one-rvv(j)))*c1e3
       as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/           &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
!hr06     as(2,ih1,j,l)=-rvv(j)*(dpsv(j)/(two*rho(j)*dpsq(j))*sm12(j)-  &
!hr06&dpd(j)*siq(j))
       as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*   &!hr06
     &sm12(j)-dpd(j)*siq(j))                                             !hr06
!hr06     as(3,ih1,j,l)=-rvv(j)*(dpsv(j)*rho(j)/(two*dpsq(j))*sm23(j)-  &
!hr06&dpd(j)*rhoc(j))
         as(3,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))* &!hr06
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr06
!hr06     as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
          as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                     !hr06
!hr06     as(5,ih1,j,l)=-rvv(j)*sm12(j)/(c4e3*rho(j)*rho(j))
          as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/(c4e3*rho(j)**2)         !hr06
!hr06     as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))/c4e3
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr06
     &c4e3                                                               !hr06
!--VERTIKAL
          al(1,ih2,j,l)=one
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=zero
          al(4,ih2,j,l)=one
!hr06     as(6,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)/c2e3
          as(6,ih2,j,l)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3               !hr06
   70   continue
        goto 160
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
          fok(j)=ekv(j,l)*oidpsv(j)
          aek(j)=abs(fok(j))
          hi(j)=sqrt(aek(j))
          fi(j)=el(l)*hi(j)
          if(fok(j).le.zero) then
            al(1,1,j,l)=cos_rn(fi(j))
            hi1(j)=sin_rn(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hi1(j)/hi(j)
            endif
!hr06       al(3,1,j,l)=-hi1(j)*hi(j)
            al(3,1,j,l)=(-1d0*hi1(j))*hi(j)                              !hr06
            al(4,1,j,l)=al(1,1,j,l)
!hr06       as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
!hr06       as(4,1,j,l)=-rvv(j)*al(2,1,j,l)*al(3,1,j,l)/c2e3
            as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
!hr06       as(5,1,j,l)=-rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l))* aek(j) &
!hr06&/c4e3
          as(5,1,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
!hr06       as(6,1,j,l)=-rvv(j)*(el(l)+al(1,1,j,l)*al(2,1,j,l))/c4e3
      as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_rn(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,2,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hs(j)/hi(j)
            endif
            al(3,2,j,l)=hs(j)*hi(j)
            al(4,2,j,l)=hc(j)
!hr06       as(4,2,j,l)=-rvv(j)*al(2,2,j,l)*al(3,2,j,l)/c2e3
            as(4,2,j,l)=((-1d0*rvv(j))*al(2,2,j,l)*al(3,2,j,l))/c2e3     !hr06
!hr06       as(5,2,j,l)=+rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l))* aek(j) &
!hr06&/c4e3
          as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
!hr06       as(6,2,j,l)=-rvv(j)*(el(l)+al(1,2,j,l)*al(2,2,j,l))/c4e3
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
          else
            al(1,2,j,l)=cos_rn(fi(j))
            hi1(j)=sin_rn(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hi1(j)/hi(j)
            endif
!hr06       al(3,2,j,l)=-hi1(j)*hi(j)
            al(3,2,j,l)=(-1d0*hi1(j))*hi(j)                              !hr06
            al(4,2,j,l)=al(1,2,j,l)
!hr06       as(1,2,j,l)=el(l)*(one-rvv(j))*c1e3
            as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
!hr06       as(4,2,j,l)=-rvv(j)*al(2,2,j,l)*al(3,2,j,l)/c2e3
            as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3   !hr06
!hr06       as(5,2,j,l)=-rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l))* aek(j) &
!hr06&/c4e3
          as(5,2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
!hr06       as(6,2,j,l)=-rvv(j)*(el(l)+al(1,2,j,l)*al(2,2,j,l))/c4e3
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_rn(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,1,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hs(j)/hi(j)
            endif
            al(3,1,j,l)=hs(j)*hi(j)
            al(4,1,j,l)=hc(j)
!hr06       as(4,1,j,l)=-rvv(j)*al(2,1,j,l)*al(3,1,j,l)/c2e3
            as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
!hr06       as(5,1,j,l)=+rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l))* aek(j) &
!hr06&/c4e3
          as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
!hr06       as(6,1,j,l)=-rvv(j)*(el(l)+al(1,1,j,l)*al(2,1,j,l))/c4e3
      as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
          endif
   90   continue
        goto 160
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100   if(kz1.eq.7) then
          do 110 j=1,napx
            fokqv(j)=ekv(j,l)
  110     continue
          ih1=1
          ih2=2
        else
!  COMBINED FUNCTION MAGNET VERTICAL
          do 120 j=1,napx
!hr06       fokqv(j)=-ekv(j,l)
            fokqv(j)=-1d0*ekv(j,l)                                       !hr06
  120     continue
          ih1=2
          ih2=1
        endif
        do 130 j=1,napx
          wf(j)=ed(l)/dpsq(j)
!hr06     fok(j)=fokqv(j)/dpd(j)-wf(j)*wf(j)
          fok(j)=fokqv(j)/dpd(j)-wf(j)**2                                !hr06
          afok(j)=abs(fok(j))
          hi(j)=sqrt(afok(j))
          fi(j)=hi(j)*el(l)
          if(afok(j).le.pieni) then
            al(1,1,j,l)=one
            al(1,2,j,l)=one
            al(2,1,j,l)=el(l)
            al(2,2,j,l)=el(l)
            al(3,1,j,l)=zero
            al(3,2,j,l)=zero
            al(4,1,j,l)=one
            al(4,2,j,l)=one
!hr06       as(6,1,j,l)=-rvv(j)*el(l)/c2e3
            as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                       !hr06
            as(6,2,j,l)=as(6,1,j,l)
!hr06       as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
          endif
!hr06     if(fok(j).lt.-pieni) then
          if(fok(j).lt.(-1d0*pieni)) then                                !hr06
            si(j)=sin_rn(fi(j))
            co(j)=cos_rn(fi(j))
!hr06       wfa(j)=wf(j)/afok(j)*(one-co(j))/dpsq(j)
            wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)                 !hr06
!hr06       wfhi(j)=wf(j)/hi(j)*si(j)/dpsq(j)
            wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                        !hr06
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=si(j)/hi(j)
!hr06       al(3,ih1,j,l)=-si(j)*hi(j)
            al(3,ih1,j,l)=(-1d0*si(j))*hi(j)                             !hr06
            al(4,ih1,j,l)=co(j)
!hr06       al(5,ih1,j,l)=-wfa(j)*dpsv(j)*c1e3
            al(5,ih1,j,l)=((-1d0*wfa(j))*dpsv(j))*c1e3                   !hr06
!hr06       al(6,ih1,j,l)=-wfhi(j)*dpsv(j)*c1e3
            al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr06       as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*      &
!hr06&sm12(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l)))/afok(j)*wf(j)*wf(j)+      &
!hr06&el(l)* (one-rvv(j)))*c1e3
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                          &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3   !hr06
!hr06       as(2,ih1,j,l)=-rvv(j)*(dpsv(j)*wf(j)/(two*dpsq(j))*sm12(j)- &
!hr06&dpd(j)*wfhi(j))
      as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*     &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
!hr06       as(3,ih1,j,l)=-rvv(j)*(dpsv(j)*half/afok(j)/dpd(j)*ed(l)*   &
!hr06&sm23(j)-dpd(j)*wfa(j))
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr06
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr06
!hr06       as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr06
!hr06       as(5,ih1,j,l)=-rvv(j)*sm12(j)*afok(j)/c4e3
            as(5,ih1,j,l)=(((-1d0*rvv(j))*sm12(j))*afok(j))/c4e3         !hr06
!hr06       as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))   &
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            hp(j)=exp_rn(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih2,j,l)=hc(j)
            al(2,ih2,j,l)=el(l)
            if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
            al(3,ih2,j,l)=hs(j)*hi(j)
            al(4,ih2,j,l)=hc(j)
!hr06       as(4,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)*al(3,ih2,j,l)/c2e3
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
!hr06       as(5,ih2,j,l)=+rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l))*  &
!hr06&aek(j)/c4e3
          as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*  &!hr06
     &aek(j))/c4e3                                                       !hr06
!hr06       as(6,ih2,j,l)=-rvv(j)*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))   &
!hr06&/c4e3
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
!--DEFOCUSSING
          if(fok(j).gt.pieni) then
            hp(j)=exp_rn(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih1,j,l)=hc(j)
            al(2,ih1,j,l)=hs(j)/hi(j)
            al(3,ih1,j,l)=hs(j)*hi(j)
            al(4,ih1,j,l)=hc(j)
!hr06       wfa(j)=wf(j)/afok(j)*(one-hc(j))/dpsq(j)
            wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)                 !hr06
!hr06       wfhi(j)=wf(j)/hi(j)*hs(j)/dpsq(j)
            wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                        !hr06
!hr06       al(5,ih1,j,l)= wfa(j)*dpsv(j)*c1e3
            al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                         !hr06
!hr06       al(6,ih1,j,l)=-wfhi(j)*dpsv(j)*c1e3
            al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr06       as(1,ih1,j,l)=(rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*sm12(j)&
!hr06&+dpsv(j)*(el(l)-al(2,ih1,j,l)))/afok(j)*wf(j)*wf(j)+el(l)*        &
!hr06&(one-rvv(j)))*c1e3
            as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*sm12(j) &
     &+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*         &
     &(one-rvv(j)))*c1e3
!hr06       as(2,ih1,j,l)=-rvv(j)*(dpsv(j)*wf(j)/(two*dpsq(j))*sm12(j)- &
!hr06&dpd(j)*wfhi(j))
          as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))* &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
!hr06       as(3,ih1,j,l)=rvv(j)*(dpsv(j)*half/afok(j)/dpd(j)* ed(l)    &
!hr06&*sm23(j)-dpd(j)*wfa(j))
        as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))*ed(l)) &!hr06
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr06
!hr06       as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr06
!hr06       as(5,ih1,j,l)=+rvv(j)*sm12(j)*afok(j)/c4e3
            as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3                !hr06
!hr06       as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))   &
!hr06&/c4e3
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            si(j)=sin_rn(fi(j))
            co(j)=cos_rn(fi(j))
            al(1,ih2,j,l)=co(j)
            al(2,ih2,j,l)=si(j)/hi(j)
!hr06       al(3,ih2,j,l)=-si(j)*hi(j)
            al(3,ih2,j,l)=(-1d0*si(j))*hi(j)                             !hr06
            al(4,ih2,j,l)=co(j)
!hr06       as(4,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)*al(3,ih2,j,l)/c2e3
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
!hr06       as(5,ih2,j,l)=-rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l))*  &
!hr06&aek(j)/c4e3
      as(5,ih2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr06
     &*aek(j))/c4e3                                                      !hr06
!hr06       as(6,ih2,j,l)=-rvv(j)*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))   &
!hr06&/c4e3
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
  130   continue
        goto 160
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140   do 150 j=1,napx
          rhoi(j)=ed(l)/dpsq(j)
!hr06     fok(j)=rhoi(j)*tan_rn(el(l)*rhoi(j)*half)
          fok(j)=rhoi(j)*tan_rn((el(l)*rhoi(j))*half)                    !hr06
          al(1,1,j,l)=one
          al(2,1,j,l)=zero
          al(3,1,j,l)=fok(j)
          al(4,1,j,l)=one
          al(1,2,j,l)=one
          al(2,2,j,l)=zero
          al(3,2,j,l)=-fok(j)
          al(4,2,j,l)=one
  150   continue
  160 continue
      return
      end
      subroutine comnul
!-----------------------------------------------------------------------
!  SUBROUTINE TO SET THE ALL COMMON VARIABLES TO ZERO
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,i1,i2,i3,i4,j
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      integer alda_da,asda_da,aldaq_da,asdaq_da,smida_da,xx_da,         &
     &yy_da,dpda_da,dpda1_da,sigmda_da,ej1_da,ejf1_da,rv_da
      common/daele/alda_da(2,6),asda_da(2,6),aldaq_da(2,6),             &
     &asdaq_da(2,6),smida_da(mcor),xx_da(2),yy_da(2),dpda_da,dpda1_da,  &
     &sigmda_da,ej1_da,ejf1_da,rv_da
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each ele
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
 
      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (norma
 
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be act
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
 
      character dump_fname (0:nele)*(getfields_l_max_string)
 
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     M. Fitterer, for CERN BE-ABP/HSS and Fermilab
!     Common block for the FMA analysis postprocessing
      integer, parameter :: fma_max       = 200              !max. number of FMA
      integer, parameter :: fma_nturn_max = 10000            !max. number of tur
      integer fma_numfiles                                   !number of FMAs
      logical fma_flag                                       !FMA input block ex
      character fma_fname  (fma_max)*(getfields_l_max_string)!name of input file
      character fma_method (fma_max)*(getfields_l_max_string)!method used to fin
      integer fma_nturn    (fma_max)                         !number of turns us
      integer fma_norm_flag(fma_max)                         !fma_norm_flag=0, d
      common /fma_var/ fma_fname,fma_method,fma_numfiles,fma_flag,
     &fma_norm_flag,fma_nturn
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      save
!-----------------------------------------------------------------------
!
      ncorru=0
      ncorrep=0
      iexact=0
      ithick=0
      ierro=0
      il=0
      iclo6=0
      iclo6r=0
      mper=0
      mblo=0
      mbloz=0
      kanf=0
      iu=0
      itra=0
      napx=0
      numl=0
      numlr=0
      ird=0
      imc=0
      niu(1)=0
      niu(2)=0
      idp=0
      irew=0
      iorg=0
      itco=0
      itcro=0
      itqv=0
      ichrom=0
      iqmod=0
      iqmod6=0
      ilin=0
      iqmodc=0
      ichromc=0
      ilinc=0
      ntco=0
      nt=0
      iprint=0
      iclo=0
      icoe=0
      ise=0
      mesa=0
      mp=0
      m21=0
      m22=0
      m23=0
      ise1=0
      ise2=0
      ise3=0
      isub=0
      nta=0
      nte=0
      ipt=0
      irmod2=0
      nre=0
      nur=0
      nch=0
      nqc=0
      npp=0
      ipos=0
      iconv=0
      imad=0
      nstart=0
      nstop=0
      iskip=1
      iav=0
      iwg=0
      ivox=0
      ivoz=0
      ires=0
      ifh=0
      idis=0
      icow=0
      istw=0
      iffw=0
      idial=0
      nord=0
      nvar=0
      nvar2=0
      ndimf=0
      nordf=0
      nvarf=0
      nord1=1
      nsix=0
      nvar2=0
      ncor=0
      idptr=0
      nbeam=0
      ibb6d=0
      ibeco=1
      ibtyp=0
      lhc=1
      ibbc=0
      iver=0
      ibidu=0
!-----------------------------------------------------------------------
      inorm=0
      imod1=0
      imod2=0
!-----------------------------------------------------------------------
      icorr=0
      nctype=0
      namp=0
      nmom=0
      nmom1=0
      nmom2=0
      weig1=zero
      weig2=zero
      dpmax=zero
!--DA-------------------------------------------------------------------
      dpda_da=0
      dpda1_da=0
      sigmda_da=0
      ej1_da=0
      ejf1_da=0
      rv_da=0
!-----------------------------------------------------------------------
      pi=zero
      pi2=zero
      pisqrt=zero
      rad=zero
      chi0=zero
      chid=zero
      dp1=zero
      idfor=0
      rat=zero
      qs=zero
      e0=zero
      crad=zero
      dppoff=zero
      tlen=zero
      pma=zero
      phas0=zero
      phas=zero
      ition=0
      dpscor=one
      sigcor=one
      benki=zero
      dma=zero
      dmap=zero
      dkq=zero
      dqq=zero
      de0=zero
      ded=zero
      dsi=zero
      dech=zero
      dsm0=zero
      amp0=zero
      qxt=zero
      qzt=zero
      eui=zero
      euii=zero
      tam1=zero
      tam2=zero
      totl=zero
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      dres=zero
      dfft=zero
      preda=zero
      partnum=zero
      emitx=zero
      emity=zero
      emitz=zero
      gammar=one
      sigz=zero
      sige=zero
      damp=zero
      ampt=zero
!-----------------------------------------------------------------------
      tlim=0.
      time0=0.
      time1=0.
!-----------------------------------------------------------------------
      do 10 i=1,2
        nde(i)=0
        is(i)=0
        idz(i)=0
        amp(i)=zero
        bet0(i)=zero
        alf0(i)=zero
        clo(i)=zero
        clop(i)=zero
        aper(i)=c1e3
        di0(i)=zero
        dip0(i)=zero
        cro(i)=zero
        sigma0(i)=zero
        qwsk(i)=zero
        betx(i)=zero
        betz(i)=zero
        alfx(i)=zero
        alfz(i)=zero
   10 continue
      do 20 i=1,3
        iq(i)=0
        hsy(i)=zero
        qw0(i)=zero
        clo6(i)=zero
        clop6(i)=zero
        clon(i)=zero
        wxys(i)=zero
        do i1=1,3
          corr(i,i1)=zero
        enddo
   20 continue
      corr(1,1)=zero
      corr(1,2)=zero
      chromc(1)=9.999999d23
      chromc(2)=9.999999d23
      do 30 i=1,4
        nwr(i)=0
   30 continue
      do 40 i=1,5
        ipr(i)=0
        nrr(i)=0
        nu(i)=0
        toptit(i)=' '
   40 continue
      do 50 i=1,6
        nskew(i)=0
   50 continue
      do 60 i=1,10
        dtr(i)=zero
        coel(i)=' '
   60 continue
      do 70 i=1,12
        ire(i)=0
   70 continue
      do 80 i=1,nper
        msym(i)=0
   80 continue
      do 90 i=1,6
        do 90 j=1,6
          ta(i,j)=zero
   90 continue
      do 100 i=1,2
        do 100 j=1,6
          exz(i,j)=zero
  100 continue
      do 110 i1=1,9
        do 110 i2=1,18
          do 110 i3=1,10
            do 110 i4=1,5
              rtc(i1,i2,i3,i4)=zero
              rts(i1,i2,i3,i4)=zero
  110 continue
!--NUMBER OF PARTICLES--------------------------------------------------
      do i=1,npart
        do i1=1,6
          do i2=1,6
            tasau(i,i1,i2)=zero
          enddo
        enddo
      enddo
!--NUMBER OF ELEMENTS---------------------------------------------------
      do 150 i=1,nele
        kz(i)=0
        kp(i)=0
        irm(i)=0
        imtr(i)=0
        nmu(i)=0
        kpa(i)=0
        isea(i)=0
        ncororb(i)=0
        iratioe(i)=0
        itionc(i)=0
        dki(i,1)=zero
        dki(i,2)=zero
        dki(i,3)=zero
        ed(i)=zero
        el(i)=zero
        ek(i)=zero
        sm(i)=zero
        xpl(i)=zero
        xrms(i)=zero
        zpl(i)=zero
        zrms(i)=zero
        benkc(i)=zero
        r00(i)=zero
 
        apx(i)=c1e3
        apz(i)=c1e3
        ape(1,i)=c1e6
        ape(2,i)=c1e6
        ape(3,i)=c1e12
 
        ratioe(i)=one
        hsyc(i)=zero
        phasc(i)=zero
        ptnfac(i)=zero
        wirel(i)=zero
        acdipph(i)=zero
        crabph(i)=zero
        crabph2(i)=zero
        crabph3(i)=zero
        crabph4(i)=zero
        bez(i)=' '
        bezl(i)=' '
        do 120 i3=1,2
          do 120 i4=1,6
            a(i,i3,i4)=zero
              do 120 i1=1,npart
                al(i4,i3,i1,i)=zero
                as(i4,i3,i1,i)=zero
  120   continue
        do 130 i1=1,mmul
          bk0(i,i1)=zero
          ak0(i,i1)=zero
          bka(i,i1)=zero
          aka(i,i1)=zero
  130   continue
        do 140 i1=1,3
          bezr(i1,i)=' '
  140   continue
        ! JBG increasing parbe to dimension 5
        do i1=1,5
          parbe(i,i1)=zero
        enddo
  150 continue
!--NUMBER OF BLOCKS-----------------------------------------------------
      do 180 i=1,nblo
        mel(i)=0
        mstr(i)=0
        elbe(i)=zero
        bezb(i)=' '
        do 160 i1=1,2
          do 160 i2=1,6
            bl1(i,i1,i2)=zero
            bl2(i,i1,i2)=zero
  160   continue
        do 170 j=1,nelb
          mtyp(i,j)=0
  170   continue
  180 continue
!--# OF STRUCTURE ELEMENTS----------------------------------------------
      do 190 i=1,nblz
        ic(i)=0
        mzu(i)=0
        icext(i)=0
        icextal(i)=0
        extalign(i,1)=zero
        extalign(i,2)=zero
        extalign(i,3)=zero
        sigmoff(i)=zero
        tiltc(i)=one
        tilts(i)=zero
!--Beam-Beam------------------------------------------------------------
        imbb(i)=0
        do 190 j=1,40
          exterr(i,j)=zero
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
        smizf(i)=zero
        do i1=1,mmul
          aai(i,i1)=zero
          bbi(i,i1)=zero
        enddo
        do i3=1,mmul
          do i2=1,nmac
            aaiv(i3,i2,i)=zero
            bbiv(i3,i2,i)=zero
          enddo
        enddo
  190 continue
!--RANDOM NUMBERS-------------------------------------------------------
      do 200 i=1,nzfz
        zfz(i)=zero
  200 continue
!--# OF TRAJECTORIES----------------------------------------------------
      do 220 i=1,mpa
        rvf(i)=one
        sigm(i)=zero
        dps(i)=zero
        ej(i)=zero
        ejf(i)=zero
        do 210 i1=1,2
          x(i,i1)=zero
          y(i,i1)=zero
  210   continue
  220 continue
!--COMBINATION OF ELEMENTS----------------------------------------------
      do 240 i1=1,20
        icomb0(i1)=0
        do 230 i=1,ncom
          icomb(i,i1)=0
          ratio(i,i1)=zero
  230   continue
  240 continue
!--PAW------------------------------------------------------------------
      do 250 i=1,nplo
        hmal(i)=0.0
  250 continue
!--TROMBONES------------------------------------------------------------
      do i=1,ntr
        do i1=1,6
          cotr(i,i1)=zero
          do i2=1,6
            rrtr(i,i1,i2)=zero
          enddo
        enddo
      enddo
!--Beam-Beam------------------------------------------------------------
      do i=1,nbb
        do j=1,2
          sigman(j,i)=zero
          sigman2(j,i)=zero
          sigmanq(j,i)=zero
        enddo
        do j=1,6
          clobeam(j,i)=zero
          beamoff(j,i)=zero
        enddo
        do j=1,12
          bbcu(i,j)=zero
        enddo
        bbcu(i,11)=one
      enddo
!--DA-------------------------------------------------------------------
      do i1=1,2
        xx_da(i1)=0
        yy_da(i1)=0
        do i2=1,6
          alda_da(i1,i2)=0
          asda_da(i1,i2)=0
          aldaq_da(i1,i2)=0
          asdaq_da(i1,i2)=0
        enddo
      enddo
      do i=1,mcor
        smida_da(i)=0
      enddo
 
!--CADCUM---------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise common
!     always in main code
      do i=0,nblz+1
         dcum(i)=zero
      enddo
 
!--DUMP BEAM POPULATION-------------------------------------------------
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K.Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     initialise common
!     always in main code
      ldumphighprec = .false.
      ldumpfront    = .false.
      do i1=1,nblz
        do i2=1,6
          dump_clo(i1,i2)=0
          do i3=1,6
            dump_tas(i1,i2,i3)=0
          enddo
        enddo
      enddo
      do i=0,nele
        ldump(i)    = .false.
        ndumpt(i)   = 0
        dumpfirst(i) = 0
        dumplast(i)  = 0
        dumpunit(i) = 0
        dumpfmt(i)  = 0
        do j=1,getfields_l_max_string
           dump_fname(i)(j:j) = char(0)
        enddo
      enddo
      fma_flag = .false.
      fma_numfiles = 0
      do i=1,fma_max
        fma_nturn(i) = 0
        fma_norm_flag(i) = 1 !initialize to 1 as default is with normalisation
        do j=1,getfields_l_max_string
          fma_fname(i)(j:j) = char(0)
          fma_method(i)(j:j) = char(0)
        enddo
      enddo
 
!--DYNAMIC KICKS--------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     initialise common
!     always in main code
!     - general-purpose variables
      ldynk = .false.
      ldynkdebug = .false.
      ldynkfiledisable = .false.
 
      nfuncs_dynk = 0
      niexpr_dynk = 0
      nfexpr_dynk = 0
      ncexpr_dynk = 0
 
      do i=1,maxfuncs_dynk
         funcs_dynk(i,1)= 0 !FUN name ( index in cexpr_dynk; 0 is invalid )
         funcs_dynk(i,2)=-1 !FUN type (-1 is invalid)
         funcs_dynk(i,3)= 0
         funcs_dynk(i,4)= 0
         funcs_dynk(i,5)= 0
      enddo
 
      do i=1,maxdata_dynk
         iexpr_dynk(i) = 0
         fexpr_dynk(i) = 0.0
         do j=1,maxstrlen_dynk
            cexpr_dynk(i)(j:j) = char(0)
         enddo
      enddo
 
      nsets_dynk = 0
 
      do i=1, maxsets_dynk
         sets_dynk(i,1) = 0 !FUN idx ( index in funcs_dynk; 0 is invalid )
         sets_dynk(i,2) = 0
         sets_dynk(i,3) = 0
         sets_dynk(i,4) = 0
 
         do j=1, maxstrlen_dynk
            csets_dynk(i,1)(j:j) = char(0)
            csets_dynk(i,2)(j:j) = char(0)
            csets_unique_dynk(i,1)(j:j) = char(0)
            csets_unique_dynk(i,2)(j:j) = char(0)
         enddo
         fsets_origvalue_dynk(i) = 0.0
      enddo
 
      do i=1,nele
         dynk_izuIndex(i) = 0
         dynk_elemdata(i,1) = 0
         dynk_elemdata(i,2) = 0
         dynk_elemdata(i,3) = 0
      end do
!
!-----------------------------------------------------------------------
      return
      end
      subroutine distance(x,clo,di0,t,dam)
!-----------------------------------------------------------------------
!  CALCULATION OF DISTANCE IN PHASE SPACE FOR POST-PROCESSING
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ii,iq,j,jq
      double precision clo,cx,dam,di0,phi,pi,sx,t,x,x1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer icode,idam,its6d
      double precision dpscor,sigcor
      common/corcom/dpscor,sigcor,icode,idam,its6d
      dimension x(2,6),x1(2,6),clo(6),di0(4),t(6,6),phi(3)
      save
!-----------------------------------------------------------------------
      pi=four*atan_rn(one)
      if(icode.ge.4.and.its6d.eq.0) then
        do 10 i=1,2
          do 10 j=1,4
            x(i,j)=x(i,j)-di0(j)*x(i,6)
   10   continue
      endif
      do 60 i=1,2
        do 20 j=1,6
          x(i,j)=x(i,j)-clo(j)
   20   continue
        if(its6d.eq.1) then
!hr06     x(i,2)=x(i,2)/(one+x(i,6)+clo(6))
          x(i,2)=x(i,2)/((one+x(i,6))+clo(6))                            !hr06
!hr06     x(i,4)=x(i,4)/(one+x(i,6)+clo(6))
          x(i,4)=x(i,4)/((one+x(i,6))+clo(6))                            !hr06
        endif
        do 40 iq=1,6
          x1(i,iq)=zero
          do 30 jq=1,6
            x1(i,iq)=x1(i,iq)+t(jq,iq)*x(i,jq)
   30     continue
   40   continue
        do 50 j=1,6
          x(i,j)=x1(i,j)
   50   continue
   60 continue
      do 70 i=1,2
        x(i,5)=x(i,5)*sigcor
        x(i,6)=x(i,6)*dpscor
   70 continue
      do 80 i=1,3
        ii=2*i
        sx=x(2,ii-1)*x(1,ii)-x(1,ii-1)*x(2,ii)
        cx=x(1,ii-1)*x(2,ii-1)+x(1,ii)*x(2,ii)
        if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
          phi(i)=atan2_rn(sx,cx)
        else
          phi(i)=zero
        endif
   80 continue
!hr06 dam=sqrt((phi(1)*phi(1)+phi(2)*phi(2)+phi(3)*phi(3))/idam)/pi
      dam=sqrt((phi(1)**2+phi(2)**2+phi(3)**2)/dble(idam))/pi            !hr06
!-----------------------------------------------------------------------
      return
      end
      subroutine betalf(dpp,qw)
!-----------------------------------------------------------------------
!  CALCULATION OF : OPT. PARAMETERS AT THE STARTING POSITION:
!                   BETA-, ALFA-FUNCTIONS, Q-VALUES
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,j
      double precision am,det,detb,detc,dpp,egwg1,egwg2,f0,f1,f2,fak1,  &
     &fak2,qw,rca1,rca2,rclam1,rclam2,rcw1(4),rcw2(4),rn1,rn2,spa,spd,  &
     &sqrn,yca1,yca2,yclam1,yclam2,ycw1(4),ycw2(4)
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension am(4,4)
      dimension qw(2)
      save
!-----------------------------------------------------------------------
      ierro=0
      call matrix(dpp,am)
!--CALCULATION OF EIGENVALUES
   10 spa=am(1,1)+am(2,2)
      spd=am(3,3)+am(4,4)
      det=(am(1,3)+am(4,2))*(am(2,4)+am(3,1))                           &
     &-(am(1,4)-am(3,2))*(am(2,3)-am(4,1))
      f0=spa-spd
      f1=spa+spd
!hr06 f2=f0*f0+four*det
      f2=f0**2+four*det                                                  !hr06
      if(f2 .lt. zero) goto 160
      f2=sqrt(f2)
!hr06 if(f0.lt.0) goto 30
      if(f0.lt.0d0) goto 30                                              !hr06
!hr06 if(f0.ge.0) goto 20
      if(f0.ge.0d0) goto 20                                              !hr06
   20 egwg1=(f1+f2)*half
      egwg2=(f1-f2)*half
      goto 40
   30 egwg1=(f1-f2)*half
      egwg2=(f1+f2)*half
   40 continue
!hr06 f1=egwg1*egwg1-four
      f1=egwg1**2-four                                                   !hr06
!hr06 f2=egwg2*egwg2-four
      f2=egwg2**2-four                                                   !hr06
      rca1=f1
      yca1=zero
      rca2=f2
      yca2=zero
      if (rca1.ge.0) then
        rca1=sqrt(rca1)
      else
!hr06   yca1=sqrt(-rca1)
        yca1=sqrt(-1d0*rca1)                                             !hr06
        rca1=zero
      endif
      if (rca2.ge.0) then
        rca2=sqrt(rca2)
      else
!hr06   yca2=sqrt(-rca2)
        yca2=sqrt(-1d0*rca2)                                             !hr06
        rca2=zero
      endif
      rclam1=(egwg1+rca1)*half
      yclam1=yca1*half
      rclam2=(egwg2+rca2)*half
      yclam2=yca2*half
!hr06 if(egwg1*egwg1 .ge. four) goto 160
      if(egwg1**2 .ge. four) goto 160                                    !hr06
!hr06 if(egwg2*egwg2 .ge. four) goto 160
      if(egwg2**2 .ge. four) goto 160                                    !hr06
   50 continue
      detb=am(1,3)*am(2,4)-am(1,4)*am(2,3)
      detc=am(3,1)*am(4,2)-am(3,2)*am(4,1)
      fak1=spd-egwg1
      if(abs(fak1).gt.pieni) then
!hr06   rcw1(1)=-(am(1,3)*am(3,2)+am(1,4)*am(4,2))/fak1+am(1,2)
        rcw1(1)=am(1,2)-(am(1,3)*am(3,2)+am(1,4)*am(4,2))/fak1           !hr06
        ycw1(1)=zero
!hr06   rcw1(2)=(am(1,3)*am(3,1)+am(1,4)*am(4,1)+detb)/fak1-(am(1,1)    &
!hr06&-rclam1)
        rcw1(2)=((am(1,3)*am(3,1)+am(1,4)*am(4,1))+detb)/fak1-(am(1,1)  &!hr06
     &-rclam1)                                                           !hr06
        ycw1(2)=yclam1
!hr06   rcw1(3)=-((am(3,1)+am(2,4))*rcw1(1)+(am(3,2)-am(1,4))*rcw1(2))  &
!hr06&/fak1
      rcw1(3)=-1d0*((am(3,1)+am(2,4))*rcw1(1)+(am(3,2)-am(1,4))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
!hr06   ycw1(3)=-((am(3,1)+am(2,4))*ycw1(1)+(am(3,2)-am(1,4))*ycw1(2))  &
!hr06&/fak1
      ycw1(3)=-1d0*((am(3,1)+am(2,4))*ycw1(1)+(am(3,2)-am(1,4))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
!hr06   rcw1(4)=-((am(4,1)-am(2,3))*rcw1(1)+(am(4,2)+am(1,3))*rcw1(2))  &
!hr06&/fak1
      rcw1(4)=-1d0*((am(4,1)-am(2,3))*rcw1(1)+(am(4,2)+am(1,3))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
!hr06   ycw1(4)=-((am(4,1)-am(2,3))*ycw1(1)+(am(4,2)+am(1,3))*ycw1(2))  &
!hr06&/fak1
      ycw1(4)=-1d0*((am(4,1)-am(2,3))*ycw1(1)+(am(4,2)+am(1,3))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      else
        rcw1(1)=am(1,2)
        ycw1(1)=zero
!hr06   rcw1(2)=-am(1,1)+rclam1
        rcw1(2)=rclam1-am(1,1)                                           !hr06
        ycw1(2)=yclam1
        rcw1(3)=zero
        ycw1(3)=zero
        rcw1(4)=zero
        ycw1(4)=zero
      endif
      fak2=spa-egwg2
      if(abs(fak2).gt.pieni) then
!hr06   rcw2(3)=-(am(3,1)*am(1,4)+am(3,2)*am(2,4))/fak2+am(3,4)
        rcw2(3)=am(3,4)-(am(3,1)*am(1,4)+am(3,2)*am(2,4))/fak2           !hr06
        ycw2(3)=zero
!hr06   rcw2(4)=(am(3,1)*am(1,3)+am(3,2)*am(2,3)+detc)/fak2-(am(3,3)    &
!hr06&-rclam2)
        rcw2(4)=((am(3,1)*am(1,3)+am(3,2)*am(2,3))+detc)/fak2-(am(3,3)  &!hr06
     &-rclam2)                                                           !hr06
        ycw2(4)=yclam2
!hr06 rcw2(1)=-((am(1,3)+am(4,2))*rcw2(3)+(am(1,4)-am(3,2))*rcw2(4))&
!hr06&/fak2
      rcw2(1)=-1d0*((am(1,3)+am(4,2))*rcw2(3)+(am(1,4)-am(3,2))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
!hr06   ycw2(1)=-((am(1,3)+am(4,2))*ycw2(3)+(am(1,4)-am(3,2))*ycw2(4))  &
!hr06&/fak2
      ycw2(1)=-1d0*((am(1,3)+am(4,2))*ycw2(3)+(am(1,4)-am(3,2))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
!hr06   rcw2(2)=-((am(2,3)-am(4,1))*rcw2(3)+(am(2,4)+am(3,1))*rcw2(4))  &
!hr06&/fak2
      rcw2(2)=-1d0*((am(2,3)-am(4,1))*rcw2(3)+(am(2,4)+am(3,1))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
!hr06   ycw2(2)=-((am(2,3)-am(4,1))*ycw2(3)+(am(2,4)+am(3,1))*ycw2(4))  &
!hr06&/fak2
      ycw2(2)=-1d0*((am(2,3)-am(4,1))*ycw2(3)+(am(2,4)+am(3,1))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      else
        rcw2(3)=am(3,4)
        ycw2(3)=zero
!hr06   rcw2(4)=-am(3,3)+rclam2
        rcw2(4)=rclam2-am(3,3)                                           !hr06
        ycw2(4)=yclam2
        rcw2(1)=zero
        ycw2(1)=zero
        rcw2(2)=zero
        ycw2(2)=zero
      endif
!--LEAVING COMPLEX NUMBERS
      do 60 i=1,4
        ta(i,1)=rcw1(i)
        ta(i,3)=rcw2(i)
        ta(i,2)=ycw1(i)
        ta(i,4)=ycw2(i)
   60 continue
!--NORMALISATION OF EIGENVALUES
!hr06 rn1=ta(1,1)*ta(2,2)-ta(2,1)*ta(1,2)                               &
!hr06&+ta(3,1)*ta(4,2)-ta(4,1)*ta(3,2)
      rn1=((ta(1,1)*ta(2,2)-ta(2,1)*ta(1,2))                            &!hr06
     &+ta(3,1)*ta(4,2))-ta(4,1)*ta(3,2)                                  !hr06
!hr06 if(rn1.lt.0) goto 70
      if(rn1.lt.0d0) goto 70                                             !hr06
!hr06 if(rn1.eq.0) goto 160
      if(rn1.eq.0d0) goto 160                                            !hr06
!hr06 if(rn1.gt.0) goto 90
      if(rn1.gt.0d0) goto 90                                             !hr06
!hr06   70 yclam1=-yclam1
   70 yclam1=-1d0*yclam1                                                 !hr06
      do 80 i=1,4
!hr06   80 ta(i,2)=-ta(i,2)
   80 ta(i,2)=-1d0*ta(i,2)                                               !hr06
   90 sqrn=sqrt(abs(rn1))
      do 100 i=1,4
        ta(i,1)=ta(i,1)/sqrn
  100 ta(i,2)=ta(i,2)/sqrn
!hr06 rn2=ta(1,3)*ta(2,4)-ta(2,3)*ta(1,4)                               &
!hr06&+ta(3,3)*ta(4,4)-ta(4,3)*ta(3,4)
      rn2=((ta(1,3)*ta(2,4)-ta(2,3)*ta(1,4))                            &!hr06
     &+ta(3,3)*ta(4,4))-ta(4,3)*ta(3,4)                                  !hr06
!hr06 if(rn2.lt.0) goto 110
      if(rn2.lt.0d0) goto 110                                            !hr06
!hr06 if(rn2.eq.0) goto 160
      if(rn2.eq.0d0) goto 160                                            !hr06
!hr06 if(rn2.gt.0) goto 130
      if(rn2.gt.0d0) goto 130                                            !hr06
!hr06  110 yclam2=-yclam2
  110 yclam2=-1d0*yclam2                                                 !hr06
      do 120 i=1,4
!hr06  120 ta(i,4)=-ta(i,4)
  120 ta(i,4)=-1d0*ta(i,4)                                               !hr06
  130 sqrn=sqrt(abs(rn2))
      do 140 i=1,4
        ta(i,3)=ta(i,3)/sqrn
  140 ta(i,4)=ta(i,4)/sqrn
      qw(1)= atan_rn(yclam1/(one+rclam1))/pi
      qw(2)= atan_rn(yclam2/(one+rclam2))/pi
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
!hr06 betx(1)=ta(1,1)*ta(1,1)+ta(1,2)*ta(1,2)
      betx(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
!hr06 alfx(1)=-(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))
      alfx(1)=-1d0*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
!hr06 betx(2)=ta(1,3)*ta(1,3)+ta(1,4)*ta(1,4)
      betx(2)=ta(1,3)**2+ta(1,4)**2                                      !hr06
!hr06 alfx(2)=-(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))
      alfx(2)=-1d0*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
!hr06 betz(1)=ta(3,1)*ta(3,1)+ta(3,2)*ta(3,2)
      betz(1)=ta(3,1)**2+ta(3,2)**2                                      !hr06
!hr06 alfz(1)=-(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))
      alfz(1)=-1d0*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
!hr06 betz(2)=ta(3,3)*ta(3,3)+ta(3,4)*ta(3,4)
      betz(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
!hr06 alfz(2)=-(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))
      alfz(2)=-1d0*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
      bet0(1)=betx(1)
      alf0(1)=alfx(1)
      bet0(2)=betz(2)
      alf0(2)=alfz(2)
      if(ta(1,1).lt.-pieni) then
        do 150 i=1,4
          do 150 j=1,4
!hr06       ta(i,j)=-ta(i,j)
            ta(i,j)=-1d0*ta(i,j)
  150   continue
      endif
      return
!-----------------------------------------------------------------------
  160 ierro=1
      return
      end
      subroutine block
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,j,jm,k,l,m,n
      double precision g,h
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension h(nblo,2,6),g(nblo,2,6)
      save
!-----------------------------------------------------------------------
      do 60 k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)
        do 10 l=1,2
          do 10 m=1,6
            h(1,l,m)=a(i,l,m)
   10   g(1,l,m)=a(n,l,m)
        if(jm.eq.1) goto 40
        do 30 j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do 20 l=1,2
            h(j,l,1)=h(j-1,l,1)*a(i,l,1)+h(j-1,l,3)*a(i,l,2)
            h(j,l,2)=h(j-1,l,2)*a(i,l,1)+h(j-1,l,4)*a(i,l,2)
            h(j,l,3)=h(j-1,l,1)*a(i,l,3)+h(j-1,l,3)*a(i,l,4)
            h(j,l,4)=h(j-1,l,2)*a(i,l,3)+h(j-1,l,4)*a(i,l,4)
            g(j,l,1)=g(j-1,l,1)*a(n,l,1)+g(j-1,l,3)*a(n,l,2)
            g(j,l,2)=g(j-1,l,2)*a(n,l,1)+g(j-1,l,4)*a(n,l,2)
            g(j,l,3)=g(j-1,l,1)*a(n,l,3)+g(j-1,l,3)*a(n,l,4)
            g(j,l,4)=g(j-1,l,2)*a(n,l,3)+g(j-1,l,4)*a(n,l,4)
!hr06       h(j,l,5)=h(j-1,l,5)*a(i,l,1)+h(j-1,l,6)*a(i,l,2)+a(i,l,5)
            h(j,l,5)=(h(j-1,l,5)*a(i,l,1)+h(j-1,l,6)*a(i,l,2))+a(i,l,5)  !hr06
!hr06       h(j,l,6)=h(j-1,l,5)*a(i,l,3)+h(j-1,l,6)*a(i,l,4)+a(i,l,6)
            h(j,l,6)=(h(j-1,l,5)*a(i,l,3)+h(j-1,l,6)*a(i,l,4))+a(i,l,6)  !hr06
!hr06       g(j,l,5)=g(j-1,l,5)*a(n,l,1)+g(j-1,l,6)*a(n,l,2)+a(n,l,5)
            g(j,l,5)=(g(j-1,l,5)*a(n,l,1)+g(j-1,l,6)*a(n,l,2))+a(n,l,5)  !hr06
!hr06       g(j,l,6)=g(j-1,l,5)*a(n,l,3)+g(j-1,l,6)*a(n,l,4)+a(n,l,6)
            g(j,l,6)=(g(j-1,l,5)*a(n,l,3)+g(j-1,l,6)*a(n,l,4))+a(n,l,6)  !hr06
   20     continue
   30   continue
   40   do 50 l=1,2
          do 50 m=1,6
            bl1(k,l,m)=h(jm,l,m)
   50   bl2(k,l,m)=g(jm,l,m)
   60 continue
      return
      end
      subroutine blockdis(aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX, USED FOR DISPERSION
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,j,jm,k,l,m,n
      double precision aeg,bl1eg,bl2eg,g,h
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension h(nblo,2,6),g(nblo,2,6)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      save
!-----------------------------------------------------------------------
      do 60 k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)
        do 10 l=1,2
          do 10 m=1,6
            h(1,l,m)=aeg(i,l,m)
   10   g(1,l,m)=aeg(n,l,m)
        if(jm.eq.1) goto 40
        do 30 j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do 20 l=1,2
            h(j,l,1)=h(j-1,l,1)*aeg(i,l,1)+h(j-1,l,3)*aeg(i,l,2)
            h(j,l,2)=h(j-1,l,2)*aeg(i,l,1)+h(j-1,l,4)*aeg(i,l,2)
            h(j,l,3)=h(j-1,l,1)*aeg(i,l,3)+h(j-1,l,3)*aeg(i,l,4)
            h(j,l,4)=h(j-1,l,2)*aeg(i,l,3)+h(j-1,l,4)*aeg(i,l,4)
            g(j,l,1)=g(j-1,l,1)*aeg(n,l,1)+g(j-1,l,3)*aeg(n,l,2)
            g(j,l,2)=g(j-1,l,2)*aeg(n,l,1)+g(j-1,l,4)*aeg(n,l,2)
            g(j,l,3)=g(j-1,l,1)*aeg(n,l,3)+g(j-1,l,3)*aeg(n,l,4)
            g(j,l,4)=g(j-1,l,2)*aeg(n,l,3)+g(j-1,l,4)*aeg(n,l,4)
!hr06       h(j,l,5)=h(j-1,l,5)*aeg(i,l,1)+h(j-1,l,6)*aeg(i,l,2)+aeg    &
!hr06&(i,l,5)
            h(j,l,5)=(h(j-1,l,5)*aeg(i,l,1)+h(j-1,l,6)*aeg(i,l,2))+aeg  &!hr06
     &(i,l,5)                                                            !hr06
!hr06       h(j,l,6)=h(j-1,l,5)*aeg(i,l,3)+h(j-1,l,6)*aeg(i,l,4)+aeg    &
!hr06&(i,l,6)
            h(j,l,6)=(h(j-1,l,5)*aeg(i,l,3)+h(j-1,l,6)*aeg(i,l,4))+aeg  &!hr06
     &(i,l,6)                                                            !hr06
!hr06       g(j,l,5)=g(j-1,l,5)*aeg(n,l,1)+g(j-1,l,6)*aeg(n,l,2)+aeg    &
!hr06&(n,l,5)
            g(j,l,5)=(g(j-1,l,5)*aeg(n,l,1)+g(j-1,l,6)*aeg(n,l,2))+aeg  &!hr06
     &(n,l,5)                                                            !hr06
!hr06       g(j,l,6)=g(j-1,l,5)*aeg(n,l,3)+g(j-1,l,6)*aeg(n,l,4)+aeg    &
!hr06&(n,l,6)
            g(j,l,6)=(g(j-1,l,5)*aeg(n,l,3)+g(j-1,l,6)*aeg(n,l,4))+aeg  &!hr06
     &(n,l,6)                                                            !hr06
   20     continue
   30   continue
   40   do 50 l=1,2
          do 50 m=1,6
            bl1eg(k,l,m)=h(jm,l,m)
   50   bl2eg(k,l,m)=g(jm,l,m)
   60 continue
      return
      end
      subroutine chroma
!-----------------------------------------------------------------------
!  CALCULATION OF CHROMATICITY FROM 5 ENERGIE-VALUES
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ii,isl,j,jj,l,n
      double precision cor,coro,cro0,de2,det,dm,dpp,dsm,ox,oz,qwc,sens, &
     &sm0,su2,suxy,suzy,xi,zi
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      dimension dsm(2,4),sens(2,4),xi(2),zi(2),dm(2),sm0(2)
      dimension qwc(3),cro0(2)
      save
!-----------------------------------------------------------------------
      cor=0d0
      coro=1d38
      do 10 i=1,2
        do 10 j=1,4
          dsm(i,j)=zero
          sens(i,j)=zero
   10 continue
      do 20 i=1,2
        xi(i)=zero
        zi(i)=zero
        dm(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        cro0(i)=zero
   20 continue
      qwc(3)=zero
      write(*,10010)
      dsm(1,2)=dsm0
      dsm(2,3)=dsm0
      de2=de0*half
      do 90 jj=1,itcro
        do 80 ii=1,4
          su2=zero
          suxy=zero
          suzy=zero
          do 30 l=1,2
            isl=is(l)
            if(kz(isl).ne.3) call prror(11)
            ed(isl)=ed(isl)+dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   30     continue
          do 40 n=1,5
!hr06       dpp=de2*(3-n)
            dpp=de2*dble(3-n)                                            !hr06
            call clorb(dpp)
            if(ierro.gt.0) call prror(12)
            call phasad(dpp,qwc)
            if(ierro.gt.0) call prror(13)
            ox=qwc(1)
            oz=qwc(2)
!hr06       su2=su2+dpp*dpp
            su2=su2+dpp**2                                               !hr06
            suxy=suxy+ox*dpp
            suzy=suzy+oz*dpp
   40     continue
          do 50 l=1,2
            isl=is(l)
            ed(isl)=ed(isl)-dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   50     continue
          sens(1,ii)=suxy/su2
          sens(2,ii)=suzy/su2
          if(ii.ne.3) goto 80
!--COMPENSATION OF CHROMATICITY
          do 60 l=1,2
            cro0(l)=sens(l,1)-cro(l)
            xi(l)=(sens(1,l+1)-sens(1,1))/dsm0
   60     zi(l)=(sens(2,l+1)-sens(2,1))/dsm0
!hr06     cor=sqrt(cro0(1)*cro0(1)+cro0(2)*cro0(2))
          cor=sqrt(cro0(1)**2+cro0(2)**2)                                !hr06
          if(jj.eq.1.or.cor.lt.coro) then
            coro=cor
            det=xi(1)*zi(2)-zi(1)*xi(2)
!hr06       dm(1)=(-cro0(1)*zi(2)+cro0(2)*xi(2))/det
            dm(1)=(cro0(2)*xi(2)-cro0(1)*zi(2))/det                      !hr06
!hr06       dm(2)=(-cro0(2)*xi(1)+cro0(1)*zi(1))/det
            dm(2)=(cro0(1)*zi(1)-cro0(2)*xi(1))/det                      !hr06
            do 70 l=1,2
              sm0(l)=ed(is(l))
              isl=is(l)
              ed(isl)=ed(isl)+dm(l)
              if(kp(isl).eq.5) call combel(isl)
 70         continue
          else
            write(*,10035)
            return
          endif
   80   continue
        write(*,10020) sens(1,1),sens(1,4),sens(2,1),sens(2,4)
        chromc(1)=sens(1,4)*c1m3
        chromc(2)=sens(2,4)*c1m3
        write(*,10030) sm0(1),ed(is(1)),bez(is(1)), sm0(2),ed(is(2)),   &
     &bez(is(2))
        write(*,10040) xi,zi
        write(*,10010)
        if(abs(sens(1,4)-cro(1)).lt.dech.and.abs(sens(2,4)-cro(2))      &
     &.lt.dech) return
   90 continue
      write(*,10000) itcro
!-----------------------------------------------------------------------
      return
10000 format(/131('-')//t10,'CHROMATICITY CORRECTION'/t10,              &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(/131('-')//t10,'DATA BLOCK CHROMATICITY CORRECTION'/t10,   &
     &'CHROMATICITIES         BEFORE           AFTER CORRECTION'/t10,   &
     &'HORIZONTAL       ',d16.10,7x,d16.10/ t10,'VERTICAL         ',d16.&
     &10,7x,d16.10/)
10040 format(t10,'SEXTUPOLE SENSITIVITIES    XI/M1 XI/M2 YI/M1 YI/M2  ',&
     &4d15.8)
10030 format(t10,'SEXTUP.STRENGTHS ',g16.10,7x,g16.10,'   INDEX   ',a16/&
     &t10,'                 ',g16.10,7x,g16.10,'           ',a16)
10035 format(/t5,'---- NO Improvement in last Step ----'/)
      end
      subroutine chromda
!-----------------------------------------------------------------------
!  CHROMATICITY CORRECTION VIA DA
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer icht,iq1,iq2,ix,ncorr,ncorruo,nd,nd2
      double precision cor,coro,dps0,dq1,dq2,edcor1,edcor2,qw,qwc
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      double precision aml6,edcor
      common/sixdim/aml6(6,6),edcor(2)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      dimension qw(2),qwc(3)
      save
!-----------------------------------------------------------------------
      write(*,10000)
      nd=2
      nd2=4
      dps(1)=dp1+dppoff
      ncorruo=ncorru
      ncorru=1
      call clorb(dp1)
      call betalf(dp1,qw)
      call phasad(dp1,qwc)
      if(nbeam.ge.1) then
              dps0=dps(1)
              dps(1)=zero
              iqmodc=4
              call mydaini(1,2,nd2,nd,nd2,1)
              ilinc=2
              call mydaini(2,2,nd2,nd,nd2,1)
              dps(1)=dps0
      endif
      ncorru=ncorruo
      iq1=is(1)
      iq2=is(2)
      edcor(1)=ed(iq1)
      edcor(2)=ed(iq2)
      edcor1=edcor(1)
      edcor2=edcor(2)
      coro=1d38
      cor=0
      ncorr=0
      do ncorr=1,itcro+1
        ichromc=2
        call mydaini(1,1,nd2,nd,nd2,1)
        ichromc=1
        call mydaini(2,4,7,2,5,1)
        dq1=corr(1,1)-cro(1)*c1m3
        dq2=corr(1,2)-cro(2)*c1m3
!hr06   if(ncorr.eq.1) cor=c1e3*sqrt(dq1*dq1+dq2*dq2)
        if(ncorr.eq.1) cor=c1e3*sqrt(dq1**2+dq2**2)                      !hr06
        if(cor.gt.dech) then
!hr06     cor=c1e3*sqrt(dq1*dq1+dq2*dq2)
          cor=c1e3*sqrt(dq1**2+dq2**2)                                   !hr06
          if(ncorr.eq.1.or.cor.lt.coro) then
            coro=cor
!hr06       ed(iq1)=ed(iq1)-corr(2,1)*dq1-corr(2,2)*dq2
            ed(iq1)=(ed(iq1)-corr(2,1)*dq1)-corr(2,2)*dq2                !hr06
!hr06       ed(iq2)=ed(iq2)-corr(3,1)*dq1-corr(3,2)*dq2
            ed(iq2)=(ed(iq2)-corr(3,1)*dq1)-corr(3,2)*dq2                !hr06
            do icht=1,iu
              ix=ic(icht)
              if(ix.gt.nblo) then
                ix=ix-nblo
                if(ix.eq.iq1.or.iratioe(ix).eq.iq1) then
                  smi(icht)=ed(iq1)*ratioe(ix)+smizf(icht)
                else if(ix.eq.iq2.or.iratioe(ix).eq.iq2) then
                  smi(icht)=ed(iq2)*ratioe(ix)+smizf(icht)
                endif
              endif
            enddo
            edcor(1)=ed(iq1)
            edcor(2)=ed(iq2)
            if(ncorr.eq.1) then
              write(*,10010) cro(1),corr(1,1)*c1e3,cro(2),              &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(*,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),    &
     &bez(iq2)
            else
              write(*,10020) cro(1),corr(1,1)*c1e3,cro(2),              &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(*,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),    &
     &bez(iq2)
            endif
          else
            write(*,10040) ncorr-1
            goto 1
          endif
        else
          write(*,10050) ncorr-1
          goto 1
        endif
      enddo
 1    continue
      chromc(1)=corr(1,1)
      chromc(2)=corr(1,2)
      if(ncorr.eq.itcro+1) write(*,10060) itcro
      if(ncorr.eq.1) then
        write(*,10010) cro(1),corr(1,1)*c1e3,cro(2),                    &
     &corr(1,2)*c1e3,ncorr-1,cor
      else
        write(*,10020) cro(1),corr(1,1)*c1e3,cro(2),corr(1,2)*c1e3,     &
     &ncorr-1,cor
      endif
      write(*,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),bez(iq2)
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING DA CHROMATICITY CORRECTION'/)
10010 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        BEFORE CORRECTION'/ t10,   &
     &'HORIZONTAL'     ,15x,G20.14,1x,G20.14/ t10,                      &
     &'VERTICAL'       ,17x,G20.14,1x,G20.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10020 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        AFTER CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G20.14,1x,G20.14/ t10,                      &
     &'VERTICAL'       ,17x,G20.14,1x,G20.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10030 format(t10,'SEXTUPOLE STRENGTH',5x,g16.10,2x,g16.10,'   TYP     ',&
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
10040 format(/t5,'---- NO IMPROVEMENT OF DA CHROMATICITY CORRECTION ',  &
     &'IN ITERATION: ',i4/)
10050 format(t5/t10,'DA CHROMATICITY CORRECTION SUCCESSFUL IN ',        &
     &'ITERATION: ',i4/)
10060 format(/t10,'DA CHROMATICITY CORRECTION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
      end
      subroutine clorb(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT   'CLO(2),CLOP(2)'
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ierr,ii,l,ll
      double precision am,cor,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,  &
     &dy,x0,x1,y0,y1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
      save ! Saving DPP?
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=1e6
        dy(l)=1e6
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) return
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &goto 50
        do 20 l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
   20   y0(l)=y(1,l)
        call matrix(dpp,am)
        if(ierro.ne.0) return
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
!hr06     det=two-am(ll-1,ll-1)-am(ll,ll)
          det=(two-am(ll-1,ll-1))-am(ll,ll)                              !hr06
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
      if(ncorru.ne.1) write(*,10000) itco
!hr06   50 cor=c1e3*sqrt(dcx*dcx+dcz*dcz)
   50 cor=c1e3*sqrt(dcx**2+dcz**2)                                       !hr06
      if(iout.eq.1.and.ncorru.ne.1) then
        write(*,10010) dpp,clo(1),clop(1),clo(2),clop(2),ii,cor
      endif
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(t5,'---- ENTRY CLORB ----/DPP=',f8.5,' /CLOX/', 2f10.5,    &
     &' /CLOY/',2f10.5,' /ITERAT.=',i3,'/ ACCURACY=',d13.6)
      end
      subroutine clorb2(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT - NO WRITEOUT
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ierr,ii,l,ll
      double precision am,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,dy,x0,&
     &x1,y0,y1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
      save
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
!hr06   dx(l)=1e6
        dx(l)=1d6                                                        !hr06
!hr06   dy(l)=1e6
        dy(l)=1d6                                                        !hr06
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) call prror(36)
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &return
        do 20 l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
   20   y0(l)=y(1,l)
        call matrix(dpp,am)
        if(ierro.ne.0) call prror(36)
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=two-am(ll-1,ll-1)-am(ll,ll)
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
!-----------------------------------------------------------------------
      return
      end
      subroutine combel(iql)
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ico,ico0,iql,j,m
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      save
!-----------------------------------------------------------------------
      do 20 j=1,icoe
        ico0=icomb0(j)
        if(iql.ne.ico0) goto 20
        do 10 m=1,20
          ico=icomb(j,m)
          if(ico.eq.0) goto 10
          if(kz(ico0).ne.kz(ico)) call prror(14)
          if(abs(el(ico0)).gt.pieni) then
            if(abs(el(ico)).gt.pieni) then
              ek(ico)=ek(ico0)*ratio(j,m)
            else
              ed(ico)=ek(ico0)*ratio(j,m)
            endif
          endif
          if(abs(el(ico0)).le.pieni) then
            if(abs(el(ico)).le.pieni) then
              ed(ico)=ed(ico0)*ratio(j,m)
            else
              ek(ico)=ed(ico0)*ratio(j,m)
            endif
          endif
   10   continue
   20 continue
!-----------------------------------------------------------------------
      return
      end
      subroutine envar(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ih,kz1,l,ll
      double precision afok,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1, &
     &hm,hp,hs,rho,rhoi,si,wf
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 200 i=1,il
        do ll=1,6
          do l=1,2
            a(i,l,ll)=zero
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 200
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          a(i,l,1)=one
          a(i,l,2)=el(i)
          a(i,l,3)=zero
   20   a(i,l,4)=one
        goto 200
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_rn(fok)
        co=cos_rn(fok)
        a(i,ih,1)=one
        a(i,ih,2)=rho*si
        a(i,ih,3)=zero
        a(i,ih,4)=one
!hr06   a(i,ih,5)=-rho*(one-co)/dpsq
        a(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                             !hr06
!hr06   a(i,ih,6)=-two*tan_rn(fok*half)/dpsq
        a(i,ih,6)=((-1d0*two)*tan_rn(fok*half))/dpsq                     !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        g=tan_rn(fok*half)/rho
        gl=el(i)*g
        a(i,ih,1)=one-gl
        a(i,ih,2)=el(i)
!hr06   a(i,ih,3)=-g*(two-gl)
        a(i,ih,3)=(-1d0*g)*(two-gl)                                      !hr06
        a(i,ih,4)=a(i,ih,1)
        goto 200
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_rn(fok)
        co=cos_rn(fok)
        a(i,ih,1)=co
        a(i,ih,2)=rho*si
!hr06   a(i,ih,3)=-si/rho
        a(i,ih,3)=(-1d0*si)/rho                                          !hr06
        a(i,ih,4)=co
!hr06   a(i,ih,5)=-rho*(one-co)/dpsq
        a(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                             !hr06
!hr06   a(i,ih,6)=-si/dpsq
        a(i,ih,6)=(-1d0*si)/dpsq                                         !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        a(i,ih,1)=one
        a(i,ih,2)=el(i)
        a(i,ih,3)=zero
        a(i,ih,4)=one
        goto 200
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(abs(fok))
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
        a(i,ih,1)=cos_rn(fi)
        hi1=sin_rn(fi)
        a(i,ih,2)=hi1/hi
!hr06   a(i,ih,3)=-hi1*hi
        a(i,ih,3)=(-1d0*hi1)*hi                                          !hr06
        a(i,ih,4)=a(i,ih,1)
        if(ih.eq.2) goto 200
!--DEFOCUSSING
  110   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=hs/hi
        a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
        if(ih.eq.1) goto 100
        goto 200
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
!hr06   fok=fokq/dpd-wf*wf
        fok=fokq/dpd-wf**2                                               !hr06
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
        si=sin_rn(fi)
        co=cos_rn(fi)
        a(i,ih,1)=co
        a(i,ih,2)=si/hi
!hr06   a(i,ih,3)=-si*hi
        a(i,ih,3)=(-1d0*si)*hi                                           !hr06
        a(i,ih,4)=co
!hr06   a(i,ih,5)=-wf/afok*(one-co)/dpsq
        a(i,ih,5)=(((-1d0*wf)/afok)*(one-co))/dpsq                       !hr06
!hr06   a(i,ih,6)=-wf/hi*si/dpsq
        a(i,ih,6)=(((-1d0*wf)/hi)*si)/dpsq                               !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=el(i)
        if(abs(hi).le.pieni) goto 150
        a(i,ih,2)=hs/hi
  150   a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
        goto 200
!--DEFOCUSSING
  160   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=hs/hi
        a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
!hr06   a(i,ih,5)= wf/afok*(one-hc)/dpsq
        a(i,ih,5)= ((wf/afok)*(one-hc))/dpsq                             !hr06
!hr06   a(i,ih,6)=-wf/hi*hs/dpsq
        a(i,ih,6)=(((-1d0*wf)/hi)*hs)/dpsq                               !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
        si=sin_rn(fi)
        co=cos_rn(fi)
        a(i,ih,1)=co
        a(i,ih,2)=si/hi
!hr06   a(i,ih,3)=-si*hi
        a(i,ih,3)=(-1d0*si)*hi                                           !hr06
        a(i,ih,4)=co
        goto 200
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
!hr06   fokq=-ek(i)
        fokq=-1d0*ek(i)                                                  !hr06
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
!hr06   fok=rhoi*tan_rn(el(i)*rhoi*half)
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr06
        a(i,1,1)=one
        a(i,1,2)=zero
        a(i,1,3)=fok
        a(i,1,4)=one
        a(i,2,1)=one
        a(i,2,2)=zero
!hr06   a(i,2,3)=-fok
        a(i,2,3)=-1d0*fok                                                !hr06
        a(i,2,4)=one
        goto 200
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190   sm(i)=ed(i)
  200 continue
      call block
      return
      end
      subroutine envardis(dpp,aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ih,kz1,l,ll
      double precision aeg,afok,bl1eg,bl2eg,co,dpd,dpp,dpsq,fi,fok,fokq,&
     &g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 190 i=1,il
        do ll=1,6
          do l=1,2
            aeg(i,l,ll)=zero
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 190
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          aeg(i,l,1)=one
          aeg(i,l,2)=el(i)
          aeg(i,l,3)=zero
   20   aeg(i,l,4)=one
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_rn(fok)
        co=cos_rn(fok)
        aeg(i,ih,1)=one
        aeg(i,ih,2)=rho*si
        aeg(i,ih,3)=zero
        aeg(i,ih,4)=one
!hr06   aeg(i,ih,5)=-rho*(one-co)/dpsq
        aeg(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                           !hr06
!hr06   aeg(i,ih,6)=-two*tan_rn(fok*half)/dpsq
        aeg(i,ih,6)=((-1d0*two)*tan_rn(fok*half))/dpsq                   !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        g=tan_rn(fok*half)/rho
        gl=el(i)*g
        aeg(i,ih,1)=one-gl
        aeg(i,ih,2)=el(i)
!hr06   aeg(i,ih,3)=-g*(two-gl)
        aeg(i,ih,3)=(-1d0*g)*(two-gl)                                    !hr06
        aeg(i,ih,4)=aeg(i,ih,1)
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_rn(fok)
        co=cos_rn(fok)
        aeg(i,ih,1)=co
        aeg(i,ih,2)=rho*si
!hr06   aeg(i,ih,3)=-si/rho
        aeg(i,ih,3)=(-1d0*si)/rho                                        !hr06
        aeg(i,ih,4)=co
!hr06   aeg(i,ih,5)=-rho*(one-co)/dpsq
        aeg(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                           !hr06
!hr06   aeg(i,ih,6)=-si/dpsq
        aeg(i,ih,6)=(-1d0*si)/dpsq                                       !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        aeg(i,ih,1)=one
        aeg(i,ih,2)=el(i)
        aeg(i,ih,3)=zero
        aeg(i,ih,4)=one
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(abs(fok))
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
        aeg(i,ih,1)=cos_rn(fi)
        hi1=sin_rn(fi)
        aeg(i,ih,2)=hi1/hi
!hr06   aeg(i,ih,3)=-hi1*hi
        aeg(i,ih,3)=(-1d0*hi1)*hi                                        !hr06
        aeg(i,ih,4)=aeg(i,ih,1)
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  110   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=hs/hi
        aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
        if(ih.eq.1) goto 100
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
!hr06   fok=fokq/dpd-wf*wf
        fok=fokq/dpd-wf**2                                               !hr06
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
        si=sin_rn(fi)
        co=cos_rn(fi)
        aeg(i,ih,1)=co
        aeg(i,ih,2)=si/hi
!hr06   aeg(i,ih,3)=-si*hi
        aeg(i,ih,3)=(-1d0*si)*hi                                         !hr06
        aeg(i,ih,4)=co
!hr06   aeg(i,ih,5)=-wf/afok*(one-co)/dpsq
        aeg(i,ih,5)=(((-1d0*wf)/afok)*(one-co))/dpsq                     !hr06
!hr06   aeg(i,ih,6)=-wf/hi*si/dpsq
        aeg(i,ih,6)=(((-1d0*wf)/hi)*si)/dpsq                             !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=el(i)
        if(abs(hi).le.pieni) goto 150
        aeg(i,ih,2)=hs/hi
  150   aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
        hp=exp_rn(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=hs/hi
        aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
!hr06   aeg(i,ih,5)= wf/afok*(one-hc)/dpsq
        aeg(i,ih,5)= ((wf/afok)*(one-hc))/dpsq                           !hr06
!hr06   aeg(i,ih,6)=-wf/hi*hs/dpsq
        aeg(i,ih,6)=(((-1d0*wf)/hi)*hs)/dpsq                             !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
        si=sin_rn(fi)
        co=cos_rn(fi)
        aeg(i,ih,1)=co
        aeg(i,ih,2)=si/hi
!hr06   aeg(i,ih,3)=-si*hi
        aeg(i,ih,3)=(-1d0*si)*hi                                         !hr06
        aeg(i,ih,4)=co
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
!hr06   fokq=-ek(i)
        fokq=-1d0*ek(i)                                                  !hr06
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
!hr06   fok=rhoi*tan_rn(el(i)*rhoi*half)
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr06
        aeg(i,1,1)=one
        aeg(i,1,2)=zero
        aeg(i,1,3)=fok
        aeg(i,1,4)=one
        aeg(i,2,1)=one
        aeg(i,2,2)=zero
!hr06   aeg(i,2,3)=-fok
        aeg(i,2,3)=-1d0*fok
        aeg(i,2,4)=one
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
      call blockdis(aeg,bl1eg,bl2eg)
      return
      end
      subroutine prror(ier)
!-----------------------------------------------------------------------
!  ERROR OUTPUT
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ier
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      save
!-----------------------------------------------------------------------
      write(*,10000)
      goto(10  ,20  ,30  ,40  ,50  ,60  ,70  ,80  ,90  ,100 , !10       &
     &     110 ,120 ,130 ,140 ,150 ,160 ,170 ,180 ,190 ,200 , !20       &
     &     210 ,220 ,230 ,240 ,250 ,260 ,270 ,280 ,290 ,300 , !30       &
     &     310 ,320 ,330 ,340 ,350 ,360 ,370 ,380 ,390 ,400 , !40       &
     &     410 ,420 ,430 ,440 ,450 ,460 ,470 ,480 ,490 ,500 , !50       &
     &     510 ,520 ,530 ,540 ,550 ,560 ,570 ,580 ,590 ,600 , !60       &
     &     610 ,620 ,630 ,640 ,650 ,660 ,670 ,680 ,690 ,700 , !70       &
     &     710 ,720 ,730 ,740 ,750 ,760 ,770 ,780 ,790 ,800 , !80       &
     &     810 ,820 ,830 ,840 ,850 ,860 ,870 ,880 ,890 ,900 , !90       &
     &     910 ,920 ,930 ,940 ,950 ,960 ,970 ,980 ,990 ,1000, !100      &
     &     1010,1020,1030,1040,1050),ier
      goto 1870
   10 write(*,10010)
      goto 1870
   20 write(*,10020) nele
      goto 1870
   30 write(*,10030)
      goto 1870
   40 write(*,10040)
      goto 1870
   50 write(*,10050)
      goto 1870
   60 write(*,10060)
      goto 1870
   70 write(*,10070)
      goto 1870
   80 write(*,10080)
      goto 1870
   90 write(*,10090)
      goto 1870
  100 write(*,10100)
      goto 1870
  110 write(*,10110)
      goto 1870
  120 write(*,10120)
      goto 1870
  130 write(*,10130)
      goto 1870
  140 write(*,10140)
      goto 1870
  150 write(*,10150)
      goto 1870
  160 write(*,10160) nele
      goto 1870
  170 write(*,10170) nper
      goto 1870
  180 write(*,10180) nblo
      goto 1870
  190 write(*,10190) erbez
      goto 1870
  200 write(*,10200) erbez
      goto 1870
  210 write(*,10210)
      goto 1870
  220 write(*,10220)
      goto 1870
  230 write(*,10230)
      goto 1870
  240 write(*,10240)
      goto 1870
  250 write(*,10250)
      goto 1870
  260 write(*,10260) nelb
      goto 1870
  270 write(*,10270)
      goto 1870
  280 write(*,10280)
      goto 1870
  290 write(*,10290)
      goto 1870
  300 write(*,10300) nran
      goto 1870
  310 write(*,10310)
      goto 1870
  320 write(*,10320)
      goto 1870
  330 write(*,10330)
      goto 1870
  340 write(*,10340) mran
      goto 1870
  350 write(*,10350)
      goto 1870
  360 write(*,10360)
      goto 1870
  370 write(*,10370)
      goto 1870
  380 write(*,10380)
      goto 1870
  390 write(*,10390)
      goto 1870
  400 write(*,10400)
      goto 1870
  410 write(*,10410)
      goto 1870
  420 write(*,10420)
      goto 1870
  430 write(*,10430) nzfz
      goto 1870
  440 write(*,10440)
      goto 1870
  450 write(*,10450)
      goto 1870
  460 write(*,10460) nrco
      goto 1870
  470 write(*,10470)
      goto 1870
  480 write(*,10480)
      goto 1870
  490 write(*,10490)
      goto 1870
  500 write(*,10500)
      goto 1870
  510 write(*,10510)
      goto 1870
  520 write(*,10520) nema
      goto 1870
  530 write(*,10530)
      goto 1870
  540 write(*,10540) npart
      goto 1870
  550 write(*,10550) nmac
      goto 1870
  560 write(*,10560) ierro
      goto 1870
  570 write(*,10570) ierro
      goto 1870
  580 write(*,10580) ierro
      goto 1870
  590 write(*,10590) ierro
      goto 1870
  600 write(*,10600) ierro
      goto 1870
  610 write(*,10610) ierro
      goto 1870
  620 write(*,10620)
      goto 1870
  630 write(*,10630)
      goto 1870
  640 write(*,10640)
      goto 1870
  650 write(*,10650) mcor
      goto 1870
  660 write(*,10660)
      goto 1870
  670 write(*,10670)
      goto 1870
  680 write(*,10680)
      goto 1870
  690 write(*,10690)
      goto 1870
  700 write(*,10700)
      goto 1870
  710 write(*,10710)
      goto 1870
  720 write(*,10720)
      goto 1870
  730 write(*,10730)
      goto 1870
  740 write(*,10740)
      goto 1870
  750 write(*,10750)
      goto 1870
  760 write(*,10760)
      goto 1870
  770 write(*,10770)
      goto 1870
  780 write(*,10780)
      goto 1870
  790 write(*,10790)
      goto 1870
  800 write(*,10800)
      goto 1870
  810 write(*,10810)
      goto 1870
  820 write(*,10820)
      goto 1870
  830 write(*,10830)
      goto 1870
  840 write(*,10840)
      goto 1870
  850 write(*,10850) mmul
      goto 1870
  860 write(*,10860)
      goto 1870
  870 write(*,10870)
      goto 1870
  880 write(*,10880)
      goto 1870
  890 write(*,10890)
      goto 1870
  900 write(*,10900)
      goto 1870
  910 write(*,10910)
      goto 1870
  920 write(*,10920)
      goto 1870
  930 write(*,10930)
      goto 1870
  940 write(*,10940)
      goto 1870
  950 write(*,10950)
      goto 1870
  960 write(*,10960)
      goto 1870
  970 write(*,10970)
      goto 1870
  980 write(*,10980)
      goto 1870
  990 write(*,10990)
      goto 1870
 1000 write(*,11000) ntr
      goto 1870
 1010 write(*,11010)
      goto 1870
 1020 write(*,11020) nbb
      goto 1870
 1030 write(*,11030)
      goto 1870
 1040 write(*,11040)
      goto 1870
 1050 write(*,11050) mmul
 1870 continue
!-----------------------------------------------------------------------
      call closeUnits
      stop
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10,  &
     &'RUN TERMINATED ABNORMALLY !!!'//)
10010 format(t10,'WRONG MODE DEFINITION')
10020 format(t10,'NOT MORE THAN: ',i4,' POSITIONS FOR RESONANCE-COMPEN',&
     &'SATION ALLOWED')
10030 format(t10,'ELEMENT FOR RESONANCE-COMPENSATION IS NOT IN THE ELE',&
     &'MENTLIST')
10040 format(t10,'UNSTABLE CLOSED ORBIT DURING INITIAL DISPERSION' ,    &
     &' CALCULATION'/ t10,                                              &
     &'INSTABILITY OCCURED FOR SMALL RELATIVE ENERGY DEVIATION')
10050 format(t10,'UNSTABLE CLOSED ORBIT FOR ZERO ENERGY DEVIATION')
10060 format(t10,'UNSTABLE CLOSED ORBIT DURING DISPERSION CALCULATION' ,&
     &' AFTER ORBIT SCALING'/ t10,                                      &
     &'INSTABILITY OCCURED FOR SMALL RELATIVE ENERGY DEVIATION')
10070 format(t10,'UNSTABLE CLOSED ORBIT AFTER ORBIT SCALING')
10080 format(t10,'ELEMENTS SPECIFIED FOR TUNE VARIATION ARE NOT' ,      &
     &' QUADRUPOLES')
10090 format(t10,'UNSTABLE CLOSED ORBIT DURING TUNE VARIATION')
10100 format(t10,'NO OPTICAL SOLUTION DURING TUNE VARIATION')
10110 format(t10,'ELEMENTS SPECIFIED FOR CHROMATICITY CORRECTION ARE' , &
     &' NOT SEXTUPOLES')
10120 format(t10,'UNSTABLE CLOSED ORBIT DURING CHROMATICITY CORRECTION')
10130 format(t10,'NO OPTICAL SOLUTION DURING CHROMATICITY CORRECTION')
10140 format(t10,'ELEMENTS OF DIFFERENT TYPES ARE COMBINED IN DATA' ,   &
     &' BLOCK COMBINATION OF ELEMENTS')
10150 format(t10,'UNKNOWN BLOCK SPECIFICATION')
10160 format(t10,'NO. OF SINGLE ELEMENTS EXCEEDS THE MAXIMUM ALLOWED' , &
     &' VALUE: ',i4)
10170 format(t10,'NO. OF SUPERPERIODS LARGER THAN : ',i4)
10180 format(t10,'NO. OF DIFFERENT BLOCKS EXCEEDS THE MAXIMUM ALLOWED' ,&
     &' VALUE: ',i5)
10190 format(t10,'UNKNOWN SINGLE ELEMENT : ',a16,                       &
     &' IN THE BLOCK DEFINITION')
10200 format(t10,'UNKNOWN BLOCK NAME OR INSERTION NAME : ',a16,' IN THE'&
     &,' STRUCTURE INPUT')
10210 format(t10,'MAXIMUM NUMBER OF STRUCTURE ELEMENTS SURPASSED')
10220 format(t10,'NO SOLUTION FOR ORBIT SCALING - POSSIBLE REASONS:'/   &
     &t10,'--> DIPOLE STRENGTHS OF NON-CORRECTOR ELEMENTS TO HIGH'/ t10,&
     &'--> NONLINEARITIES TOO STRONG, TRY TO INCREASE INITIAL'/ t10,    &
     &'    CORRECTOR STRENGTHS'/ t10,                                   &
     &'--> USE ALL DIPOLE ELEMENTS FOR SCALING'/)
10230 format(t10,'NO OPTICAL SOLUTION')
10240 format(t10,'NO SOLUTION FOR DISPERSION')
10250 format(t10,'--> PLEASE INCLUDE LENGTH OF MACHINE IN THE' ,        &
     &' <SYNCHROTRON>-BLOCK')
10260 format(t10,'ONE BLOCK CAN NOT HAVE MORE THAN ',i4,' ELEMENTS')
10270 format(t10,'KINETIC ENERGY OF THE PARTICLE IS LESS OR EQUAL ZERO')
10280 format(t10,'EITHER YOUR RF-FREQENCY IS SHIFTED BY 180 DEGREES'/ , &
     &t10,'THEN CHANGE THE SIGN OF <ITION> IN THE ',                    &
     &'<SYNCHROTRON>-INPUTBLOCK',/t10,'OR YOUR ALFA-P IS WRONGLY ',     &
     &'INTRODUCED IN THE SAME INPUTBLOCK')
10290 format(t10,'MULTIPOLECOEFFITIONS CANNOT BE SET EQUAL')
10300 format(t10,'THE RANDOM NUMBER: ',i6,' FOR THE INITIAL',           &
     &' STRUCTURE IS TOO SMALL')
10310 format(t10,'ELEMENTS THAT NEED RANDOM NUMBERS HAVE A KZ > 0')
10320 format(t10,'THERE ARE NOT ENOUGH RANDOM NUMBERS FOR THE INSERTED',&
     &' ELEMENTS')
10330 format(t10,'TO USE THE SAME RANDOMNUMBERS FOR 2 ELEMENTS, THE',   &
     &' INSERTED ELEMENT MUST NOT NEED MORE OF SUCH NUMBERS THAN THE',  &
     &' REFERENCE ELEMENT')
10340 format(t10,'NOT MORE THAN',i4,' OF EACH TYP OF INSERTED ELEMENTS',&
     &' CAN BE USED')
10350 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN QMOD')
10360 format(t10,'NO CONVERGENCE IN RMOD')
10370 format(t10,'CHOSEN ORDERS OF RESONANCES CAN NOT BE CALCULATED')
10380 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN RMOD')
10390 format(t10,'WITH THE SPECIFIED ELEMENTS THE RESONANCE CANNOT BE', &
     &' COMPENSATED - RESONANCEORDER AND ELEMENTTYP # MUST BE THE SAME')
10400 format(t10,'NOT MORE THAN 2 PARTICLES CAN BE TRACKED')
10410 format(t10,'GEOMETRY AND STRENGTH FILE (UNIT 2) IS EMPTY OR ' ,   &
     &' DISTROYED')
10420 format(t10,'TRACKING PARAMETER FILE (UNIT 3) IS EMPTY OR ' ,      &
     &' NONEXISTING')
10430 format(t10,'NOT MORE THAN ',i4,' RANDOM NUMBERS CAN BE USED')
10440 format(t10,'FOR THE INPUTBLOCK - ORBIT CORRECTION - ONLY CORRE',  &
     &'CTORS WITH THE KEYWORDS ( HCOR= ; VCOR= )'/t10,                  &
     &'AND MONITORS WITH THE', ' KEYWORDS ( HMON= ; VMON= ) ARE ALLOWED'&
     &)
10450 format(t10,'FOR THE INPUTBLOCK - LINEAR OPTICS - ONLY',           &
     &' THE KEYWORD ( ELEMENT ) AND ( BLOCK ) ARE ALLOWED')
10460 format(t10,'ORDER OF COMPENSATION CAN NOT BE LARGER THAN : ',i4)
10470 format(t10,'ONLY UP TO 3 RESONANCES CAN BE COMPENSATED')
10480 format(t10,'RESONANCE TYPE IS OUT OF THE RANGE OF THE RESONANCE', &
     &' ORDER')
10490 format(t10,'ONLY UP TO 3 SUBRESONANCES CAN BE COMPENSATED')
10500 format(t10,'THE MULTIPOLE ORDER FOR THE SUBRESONANCE COMPENSATION'&
     &,' SHOULD NOT EXCEED THE VALUE 9')
10510 format(t10,'PROBLEMS WITH FILE 3 WITH DYNAMIC KICKS')
10520 format(t10,'MAXIMUM ORDER OF THE ONE TURN MAP IS ',i4, /,         &
     &' NEMA HAS TO BE LARGER THAN NORD')
10530 format(t10,'# OF VARIABLES -NV- OF THE ONE TURN MAP IS NOT',      &
     &' IN THE ALLOWED RANGE [2 <= NV <= 5]')
10540 format(t10,'MAXIMUM NUMBER OF PARTICLES FOR VECTORIZATION', ' IS '&
     &,i4)
10550 format(t10,'MAXIMUM NUMBER OF DIFFERENT SEEDS FOR VECTORIZATION', &
     &' IS ',i4)
10560 format(t10,'PROBLEMS WITH FILE 13 WITH INITIAL COORDINATES ',     &
     &' - ERROR CODE : ',i10)
10570 format(t10,'PROBLEMS WITH FILE 2 WITH ACCELERATOR STRUCTURE ',    &
     &' - ERROR CODE : ',i10)
10580 format(t10,'PROBLEMS WITH FILE 3 WITH TRACKING PARAMETERS ',      &
     &' - ERROR CODE : ',i10)
10590 format(t10,'PROBLEMS WITH FILE 11 FOR CRAY INPUT ',               &
     &' - ERROR CODE : ',i10)
10600 format(t10,'PROBLEMS WITH FILE 99 FOR BINARY OUTPUT ',            &
     &' - ERROR CODE : ',i10)
10610 format(t10,'PROBLEMS WITH FILE 12 FOR END COORDINATES',           &
     &' - ERROR CODE : ',i10)
10620 format(t10,'ELEMENTS SPECIFIED FOR DECOUPLING ARE NOT' ,          &
     &' SKEW QUADRUPOLES')
10630 format(t10,'THERE ARE THE APPROPRIATE ELEMENTS FOR' ,             &
     &' THE DECOUPLING OR SIMULTANEOUS TUNE ADJUSTMENT')
10640 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN DECOUP')
10650 format(t10,'MAXIMUM NUMBER OF EXTRA PARAMETERS IS : ',i4)
10660 format(t10,'EXTRA PARAMETERS FOR THE MAP DOES NOT EXIST')
10670 format(t10,'ONLY SINGLE KICK ELEMENTS ALLOWED FOR MAP CALCULATION'&
     &)
10680 format(t10,'THE ORDER OF THE NORMAL FORM IS TOO HIGH. CHECK THE' ,&
     &' DIFFERENTIAL ALGEBRA PARAMETERS')
10690 format(t10,'TOO MANY VARIABLES SPECIFIED. CHECK THE DIFFERENTIAL' &
     &,' ALGEBRA PARAMETERS')
10700 format(t10,'NO CORRECTORS SPECIFIED')
10710 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE ZERO!')
10720 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE DIFFERENT FROM',&
     &' ZERO!')
10730 format(t10,'AMPLITUDE ORDER OUTSIDE RANGE [0,2]')
10740 format(t10,'MOMENTUM ORDER OUTSIDE RANGE [0,3] (ONE EXCLUDED!)')
10750 format(t10,'MINIMUM ORDER OUTSIDE RANGE [2,3]')
10760 format(t10,'MINIMUM ORDER GREATER THAN MAXIMUM!')
10770 format(t10,'MAXIMUM ORDER OUTSIDE RANGE [2,3]')
10780 format(t10,'NORMAL FORMS ANALYSIS IMPOSSIBLE',/ ,t10,             &
     &'THE TRANSFER MAP DOES NOT EXIST!')
10790 format(t10,'ZERO OR NEGATIVE ENERGY DOES NOT MAKE MUCH SENSE')
10800 format(t10,'PROBLEM READING EXTERNAL MULTIPOLE ERRORS')
10810 format(t10,'TOO MANY ELEMENTS FOR LINEAR OPTICS WRITE-OUT')
10820 format(t10,'FOR CLOSED ORBIT CORRECTORS ONLY DIPOLES OF LEGTH',   &
     &' ZERO OR MULTIPOLE LENSES ALLOWED')
10830 format(t10,'AN ELEMENT FOR CLOSED ORBIT CORRECTION CAN BE ONLY',  &
     &' EITHER A HORIZONTAL MONITOR',/,t10, 'OR A VERTICAL MONITOR OR', &
     &' A HORIZONTAL CORRECTOR OR A VERTICAL CORRECTOR')
10840 format(t10,'NUMBER OF ORBIT CORRECTORS IS ZERO')
10850 format(t10,'THE ORDER OF MULTIPOLES MMUL: ',i4,' HAS TO BE LARGER'&
     &,' THAN 10 BUT SMALLER THAN 20')
10860 format(t10,'PROBLEM READING EXTERNAL MISALIGNMENTS')
10870 format(t10,'PROBLEM READING FROM FILE 30 (SINGLE KICKS AND ',     &
     &'MISALIGNMENTS')
10880 format(t10,'BEAM_BEAM: EITHER NORMALIZED EMITTANCES OR THE ',     &
     &'RESULTING SIGMA VALUES EQUAL TO ZERO')
10890 format(t10,'BEAM_BEAM: AT EACH INTERACTION POINT THE BEAM ',      &
     &'MUST BE EITHER ROUND OR ELLIPTICAL FOR ALL PARTICLES')
10900 format(t10,'QUADRUPOLES ARE NOT SUITED TO ADJUST THE TUNES')
10910 format(t10,'ORDER AND NUMBER OF VARIABLES HAVE TO BE LARGER ',    &
     &'THAN ZERO TO CALCULATE A DIFFERENTIAL ALGEBRA MAP')
10920 format(t10,'YOU CANNOT COMBINE AN ELEMENT WITH ITSELF')
10930 format(t10,'INVERTED LINEAR BLOCKS NOT ALLOWED')
10940 format(t10,'  NUMBER OF NORMAL FORM VARIABLES HAVE TO BE: ',      &
     &'2, 4, 5, 6 + PARAMETERS')
10950 format(t10,'  DA CORRECTIONS IMPLEMENTED FOR 4-D AND 6-D ONLY ')
10960 format(t10,'SEXTUPOLES ARE NOT SUITED TO ADJUST THE CHROMATICITY')
10970 format(t10,'UNSTABLE CLOSED ORBIT IN DA CALCULATION')
10980 format(t10,'TROMBONE ELEMENT NOT IN LIST OF SINGLE ELEMENTS')
10990 format(t10,'INCOMPLETE PARAMETERS FOR TROMBONE ELEMENT')
11000 format(t10,'MAXIMUM NUMBER OF TROMBONES EXCEEDED : NTR = ',i4)
11010 format(t10,'AMPLITUDES EXCEED THE MAXIMUM VALUES IN UMLAUF')
11020 format(t10,'MAXIMUM ELEMENT NUMBER FOR BEAM_BEAM WITH COUPLING ', &
     &'EXCEEDED:  NBB = ',i4)
11030 format(t10,'6D BEAM-BEAM WITH TILT NOT POSSIBLE')
11040 format(t10,'SINGLE ELEMENT NAME LONGER THAN 16 CHARACTERS')
11050 format(t10,'THE INPUT ORDER OF MULTIPOLES IS LARGER THAN THE ',   &
     &'MAXIMUM ALLOWED ORDER MMUL: ',i4)
      end
 
      subroutine dynk_parseFUN( getfields_fields,
     &                          getfields_lfields,getfields_nfields )
!
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 30-10-2014
!     parse FUN lines in the fort.3 input file,
!     store it in COMMON block dynkComExpr.
!-----------------------------------------------------------------------
!
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
      intent(in) getfields_fields, getfields_lfields, getfields_nfields
 
      ! Temp variables
      integer ii, stat, t
      double precision x,y,z,u,           ! FILE, FILELIN, FIR/IIR
     &                 x1,x2,y1,y2,deriv, ! LINSEG, QUADSEG,
     &                 tinj,Iinj,Inom,A,D,R,te,                 !PELP (input)
     &                 derivI_te,I_te,bexp,aexp, t1,I1, td,tnom !PELP (calc)
 
      logical isFIR ! FIR/IIR
 
      ! define function return type
      integer dynk_findFUNindex
 
      logical lopen
 
      integer nchars
      parameter (nchars=160) !Same as in daten
      character*(nchars) ch
 
      character filefields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
      integer filefields_nfields
      integer filefields_lfields( getfields_n_max_fields )
      logical filefields_lerr
 
      double precision round_near
      integer errno
 
 
      if (nfuncs_dynk+1 .gt. maxfuncs_dynk) then
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "Maximum number of FUN exceeded, please" //
     &        "parameter maxfuncs_dynk."
         write (*,*)    "Current value of maxfuncs_dynk:",maxfuncs_dynk
         call prror(51)
      endif
 
      if (getfields_lfields(2).gt.maxstrlen_dynk-1) then
         write(*,*)    "ERROR in DYNK block parsing (fort.3):"
         write(*,*)    "Max length of a FUN name is", maxstrlen_dynk-1
         write(*,*)    "Offending FUN: '"//
     &        getfields_fields(2)(1:getfields_lfields(2))//"'"
         write(*,*) "length:", getfields_lfields(2)
         call prror(51)
      endif
 
      ! ! ! ! ! ! ! ! ! ! ! ! ! !
      ! Which type of function? !
      ! ! ! ! ! ! ! ! ! ! ! ! ! !
 
      !!! System functions: #0-19 !!!
      select case ( getfields_fields(3)(1:getfields_lfields(3)) )
      case ("GET")
         ! GET: Store the value of an element/value
 
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname GET elementName attribute" )
         call dynk_checkspace(0,1,3)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 0           !TYPE (GET)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
 
         !Sanity checks
         if (getfields_lfields(4) .gt. 16 .or.   ! length of BEZ elements
     &       getfields_lfields(4) .gt. maxstrlen_dynk-1 ) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN GET got an element name with     "
            write (*,*)    "length =", getfields_lfields(4), "> 16."
            write (*,*)    "or > ",maxstrlen_dynk-1
            write (*,*)    "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (*,*)    "*************************************"
            call prror(51)
         end if
         if (getfields_lfields(5) .gt. maxstrlen_dynk-1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN GET got an attribute name with   "
            write (*,*)    "length =", getfields_lfields(5)
            write (*,*)    "> ",maxstrlen_dynk-1
            write (*,*)    "The name was: '",getfields_fields(5)
     &                                    (1:getfields_lfields(5)),"'"
            write (*,*)    "*************************************"
            call prror(51)
         endif
 
         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !ELEMENT_NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         cexpr_dynk(ncexpr_dynk+2)(1:getfields_lfields(5)) = !ATTRIBUTE_NAME
     &        getfields_fields(5)(1:getfields_lfields(5))
         ncexpr_dynk = ncexpr_dynk+2
 
         fexpr_dynk(nfexpr_dynk) = -1.0 !Initialize a place in the array to stor
 
      case ("FILE")
         ! FILE: Load the contents from a file
         ! File format: two ASCII columns of numbers,
         ! first  column = turn number (all turns should be there, starting from
         ! second column = value (as a double)
 
         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname FILE filename" )
         call dynk_checkspace(0,0,2)
 
         ! Set pointers to start of funs data blocks (nfexpr_dynk handled when r
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 1             !TYPE (FILE)
         funcs_dynk(nfuncs_dynk,3) = ncexpr_dynk+1 !Filename (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk+1 !Data     (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1            !Below: Length of file
 
         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN FILE got a filenname with   "
            write (*,*)    "length =", getfields_lfields(4)
            write (*,*)    "> ",maxstrlen_dynk-1
            write (*,*)    "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (*,*)    "*************************************"
            call prror(51)
         endif
 
         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !FILE NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         ncexpr_dynk = ncexpr_dynk+1
 
         !Open the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(*,*)   "DYNK> **** ERROR in dynk_parseFUN():FILE ****"
            write(*,*)   "DYNK> unit 664 for file '"//
     &           cexpr_dynk(ncexpr_dynk), "' was already taken"
            call prror(-1)
         end if
 
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(*,*)    "DYNK> dynk_parseFUN():FILE"
            write(*,*)    "DYNK> Error opening file '",
     &           cexpr_dynk(ncexpr_dynk), "'"
            call prror(51)
         endif
 
         ii = 0 !Number of data lines read
         do
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) exit !EOF
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILE"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Error in getfields_split"
               call prror(-1)
            end if
 
            if ( filefields_nfields  .ne. 2 ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILE"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
               call prror(-1)
            end if
 
            read(filefields_fields(1)(1:filefields_lfields(1)),*) t
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)
!            write(*,*) "DBGDBG: t,y = ",t,y
 
            ii = ii+1
            if (t .ne. ii) then
               write(*,*)    "DYNK> dynk_parseFUN():FILE"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Missing turn number", ii,
     &              ", got turn", t
               call prror(51)
            endif
            if (nfexpr_dynk+1 .gt. maxdata_dynk) then
               write(*,*)    "DYNK> dynk_parseFUN():FILE"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Ran out of memory in fexpr_dynk ",
     &              "in turn", t
               write(*,*)    "DYNK> Please increase maxdata_dynk."
               call prror(51)
            endif
 
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = y
         enddo
         funcs_dynk(nfuncs_dynk,5) = ii
 
         close(664)
 
      case ("FILELIN")
         ! FILELIN: Load the contents from a file, linearly interpolate
         ! File format: two ASCII columns of numbers,
         ! first  column = turn number (as a double)
         ! second column = value (as a double)
 
         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname FILELIN filename" )
         call dynk_checkspace(0,0,2)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 2             !TYPE (FILELIN)
         funcs_dynk(nfuncs_dynk,3) = ncexpr_dynk+1 !Filename (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk+1 !Data     (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1            !Below: Length of file (numbe
         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN FILELIN got a filenname with   "
            write (*,*)    "length =", getfields_lfields(4)
            write (*,*)    "> ",maxstrlen_dynk-1
            write (*,*)    "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (*,*)    "*************************************"
            call prror(51)
         endif
         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !FILE NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         ncexpr_dynk = ncexpr_dynk+1
 
         !Open the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(*,*)
     &           "DYNK> **** ERROR in dynk_parseFUN():FILELIN ****"
            write(*,*)   "DYNK> unit 664 for file '"//
     &           cexpr_dynk(ncexpr_dynk), "' was already taken"
            call prror(-1)
         end if
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat,status='OLD')
         if (stat .ne. 0) then
            write(*,*)    "DYNK> dynk_parseFUN():FILELIN"
            write(*,*)    "DYNK> Error opening file '",
     &           cexpr_dynk(ncexpr_dynk), "'"
            call prror(51)
         endif
         ! Find the size of the file
         ii = 0 !Number of data lines read
         do
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) exit !EOF
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILELIN"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Error in getfields_split"
               call prror(-1)
            end if
 
            if ( filefields_nfields  .ne. 2 ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILELIN"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
               call prror(-1)
            end if
 
            x = round_near(errno, filefields_lfields(1)+1,
     &           filefields_fields(1) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,1,x)
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
 
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)(1:filefields_lfields(1))
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)(1:filefields_lfields(2))
!            write(*,*) "DBGDBG: x,y = ",x,y
 
            if (ii.gt.0 .and. x.le. x2) then !Insane: Decreasing x
               write (*,*)    "DYNK> dynk_parseFUN():FILELIN"
               write (*,*)    "DYNK> Error while reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write (*,*)    "DYNK> x values must "//
     &              "be in increasing order"
               call prror(-1)
            endif
            x2 = x
 
            ii = ii+1
         enddo
         t = ii
         rewind(664)
 
         if (nfexpr_dynk+2*t .gt. maxdata_dynk) then
            write (*,*)    "DYNK> dynk_parseFUN():FILELIN"
            write (*,*)    "DYNK> Error reading file '",
     &           cexpr_dynk(ncexpr_dynk),"'"
            write (*,*)    "DYNK> Not enough space in fexpr_dynk,"//
     &           " need", 2*t
            write (*,*)    "DYNK> Please increase maxdata_dynk"
            call prror(51)
         endif
 
         !Read the file
         ii = 0
         do
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) then !EOF
               if (ii .ne. t) then
                  write (*,*)    "DYNK> dynk_parseFUN():FILELIN"
                  write (*,*)    "DYNK> Unexpected when reading file '",
     &                 cexpr_dynk(ncexpr_dynk),"'"
                  write (*,*)    "DYNK> ii=",ii,"t=",t
                  call prror(51)
               endif
               exit
            endif
 
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILELIN"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Error in getfields_split"
               call prror(-1)
            end if
 
            if ( filefields_nfields  .ne. 2 ) then
               write(*,*)    "DYNK> dynk_parseFUN():FILELIN"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
              call prror(-1)
            end if
 
            x = round_near(errno, filefields_lfields(1)+1,
     &           filefields_fields(1) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,1,x)
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)
!            write(*,*) "DBGDBG: x,y = ",x,y
 
            !Current line number
            ii = ii+1
 
            fexpr_dynk(nfexpr_dynk + ii    ) = x
            fexpr_dynk(nfexpr_dynk + ii + t) = y
         enddo
 
         nfexpr_dynk = nfexpr_dynk + 2*t
         funcs_dynk(nfuncs_dynk,5) = t
         close(664)
 
      case ("PIPE")
         ! PIPE: Use a pair of UNIX FIFOs.
         ! Another program is expected to hook onto the other end of the pipe,
         ! and will recieve a message when SixTrack's dynk_computeFUN() is calle
         ! That program should then send a value back (in ASCII), which will be
 
         call dynk_checkargs(getfields_nfields,7,
     &        "FUN funname PIPE inPipeName outPipeName ID fileUnit" )
         call dynk_checkspace(1,0,4)
 
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 3             !TYPE (PIPE)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk   !UnitNR (set below)
         funcs_dynk(nfuncs_dynk,4) = -1            !Not used
         funcs_dynk(nfuncs_dynk,5) = -1            !Not used
 
         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1 .or.
     &       getfields_lfields(5) .gt. maxstrlen_dynk-1 .or.
     &       getfields_lfields(6) .gt. maxstrlen_dynk-1      ) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN PIPE got one or more strings which "
            write (*,*)    "was too long (>",maxstrlen_dynk-1,")"
            write (*,*)    "Strings: '",
     &           getfields_fields(4)(1:getfields_lfields(4)),"' and '",
     &           getfields_fields(5)(1:getfields_lfields(5)),"' and '",
     &           getfields_fields(6)(1:getfields_lfields(6)),"'."
            write (*,*)    "lengths =",
     &           getfields_lfields(4),", ",
     &           getfields_lfields(5)," and ",
     &           getfields_lfields(6)
            write (*,*)    "*************************************"
            call prror(51)
         endif
 
         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !inPipe
     &        getfields_fields(4)(1:getfields_lfields(4))
         cexpr_dynk(ncexpr_dynk+2)(1:getfields_lfields(5)) = !outPipe
     &        getfields_fields(5)(1:getfields_lfields(5))
         cexpr_dynk(ncexpr_dynk+3)(1:getfields_lfields(6)) = !ID
     &        getfields_fields(6)(1:getfields_lfields(6))
         ncexpr_dynk = ncexpr_dynk+3
 
         read(getfields_fields(7)(1:getfields_lfields(7)),*) !fileUnit
     &        iexpr_dynk(niexpr_dynk)
 
         ! Look if the fileUnit or filenames are used in a different FUN PIPE
         t=0 !Used to hold the index of the other pipe; t=0 if no older pipe ->
         do ii=1,nfuncs_dynk-1
            if (funcs_dynk(ii,2) .eq. 3) then !It's a PIPE
               !Does any of the settings match?
               if ( iexpr_dynk(funcs_dynk(ii,3)).eq.      !Unit number
     &              iexpr_dynk(niexpr_dynk)           .or.
     &              cexpr_dynk(funcs_dynk(ii,1)+1).eq.    !InPipe filename
     &              cexpr_dynk(ncexpr_dynk-2)         .or.
     &              cexpr_dynk(funcs_dynk(ii,1)+2).eq.    !OutPipe filename
     &              cexpr_dynk(ncexpr_dynk-1)         ) then
                  !Does *all* of the settings match?
                  if ( iexpr_dynk(funcs_dynk(ii,3)).eq.   !Unit number
     &                 iexpr_dynk(niexpr_dynk)           .and.
     &                 cexpr_dynk(funcs_dynk(ii,1)+1).eq. !InPipe filename
     &                 cexpr_dynk(ncexpr_dynk-2)         .and.
     &                 cexpr_dynk(funcs_dynk(ii,1)+2).eq. !OutPipe filename
     &                 cexpr_dynk(ncexpr_dynk-1)         ) then
                     t=ii
                     write(*,*)    "DYNK> "//
     & "PIPE FUN '"//cexpr_dynk(funcs_dynk(nfuncs_dynk,1))//
     & "' using same settings as previously defined FUN '"   //
     & cexpr_dynk(funcs_dynk(ii,1))//"' -> reusing files!"
                     if (cexpr_dynk(funcs_dynk(ii,1)+3).eq. !ID
     &                   cexpr_dynk(ncexpr_dynk)           ) then
                        write(*,*)    "DYNK> "//
     &               "ERROR: IDs must be different when sharing PIPEs."
                        call prror(-1)
                     endif
                     exit !break loop
                  else !Partial match
      write(*,*)    "DYNK> *** Error in dynk_parseFUN():PIPE ***"
      write(*,*)    "DYNK> Partial match of inPipe/outPipe/unit number"
      write(*,*)    "DYNK> between PIPE FUN '"               //
     &     cexpr_dynk(funcs_dynk(nfuncs_dynk,1))// "' and '" //
     &     cexpr_dynk(funcs_dynk(ii,1))                      //"'"
                     call prror(-1)
                  endif
               endif
            endif
         end do
 
         if (t.eq.0) then !Must open a new set of files
         ! Open the inPipe
         inquire( unit=iexpr_dynk(niexpr_dynk), opened=lopen )
         if (lopen) then
            write(*,*)   "DYNK> **** ERROR in dynk_parseFUN():PIPE ****"
            write(*,*)   "DYNK> unit",iexpr_dynk(niexpr_dynk),
     &           "for file '"//cexpr_dynk(ncexpr_dynk-2)
     &           //"' was already taken"
            call prror(-1)
         end if
 
         write(*,*)    "DYNK> Opening input pipe '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-2)))//"' for FUN '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-3)))//"', ID='"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk)))//"'"
         open(unit=iexpr_dynk(niexpr_dynk),
     &        file=cexpr_dynk(ncexpr_dynk-2),action='read',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(*,*)    "DYNK> dynk_parseFUN():PIPE"
            write(*,*)    "DYNK> Error opening file '",
     &           cexpr_dynk(ncexpr_dynk-2), "' stat=",stat
            call prror(51)
         endif
 
         ! Open the outPipe
         write(*,*)    "DYNK> Opening output pipe '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-1)))//"' for FUN '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-3)))//"', ID='"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk)))//"'"
         inquire( unit=iexpr_dynk(niexpr_dynk)+1, opened=lopen )
         if (lopen) then
            write(*,*)   "DYNK> **** ERROR in dynk_parseFUN():PIPE ****"
            write(*,*)   "DYNK> unit",iexpr_dynk(niexpr_dynk)+1,
     &           "for file '"//cexpr_dynk(ncexpr_dynk-1)
     &           //"' was already taken"
            call prror(-1)
         end if
 
         open(unit=iexpr_dynk(niexpr_dynk)+1,
     &        file=cexpr_dynk(ncexpr_dynk-1),action='write',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(*,*)    "DYNK> dynk_parseFUN():PIPE"
            write(*,*)    "DYNK> Error opening file '",
     &           cexpr_dynk(ncexpr_dynk-1), "' stat=",stat
            call prror(51)
         endif
         write(iexpr_dynk(niexpr_dynk)+1,'(a)')
     &        "DYNKPIPE !******************!" !Once per file
         endif !End "if (t.eq.0)"/must open new files
         write(iexpr_dynk(niexpr_dynk)+1,'(a)') !Once per ID
     &        "INIT ID="//
     &        trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))
     &        //" for FUN="//
     &        trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-3)))
 
 
      case ("RANDG")
         ! RANDG: Gausian random number with mu, sigma, and optional cutoff
 
         call dynk_checkargs(getfields_nfields,8,
     &        "FUN funname RANDG seed1 seed2 mu sigma cut" )
         call dynk_checkspace(5,2,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 6           !TYPE (RANDG)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk !seed1, seed2, mcut (in iexpr_d
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk !mu, sigma (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk) ! seed1 (initial)
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        iexpr_dynk(niexpr_dynk+1) ! seed2 (initial)
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! mu
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk)  )
 
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! sigma
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7,
     &                       fexpr_dynk(nfexpr_dynk+1) )
         read(getfields_fields(8)(1:getfields_lfields(8)),*)
     &        iexpr_dynk(niexpr_dynk+2) ! mcut
 
         iexpr_dynk(niexpr_dynk+3) = 0 ! seed1 (current)
         iexpr_dynk(niexpr_dynk+4) = 0 ! seed2 (current)
 
         niexpr_dynk = niexpr_dynk+4
         nfexpr_dynk = nfexpr_dynk+1
 
         if (iexpr_dynk(niexpr_dynk) .lt. 0) then
            !mcut < 0
            write (*,*)    "DYNK> dynk_parseFUN():RANDG"
            write (*,*)    "DYNK> ERROR in DYNK block parsing (fort.3)"
            write (*,*)    "DYNK> mcut must be >= 0"
            call prror(51)
         endif
 
      case("FIR","IIR")
         ! FIR: Finite Impulse Response filter
         ! y[n] = \sum_{i=0}^N b_i*x[n-i]
         ! where N is the order of the filter, x[] is the results from
         ! previous calls to the input function, and b_i is a set of coefficient
         ! The coefficients are loaded from an ASCII file, formatted with three
         ! the first one being the index 0...N, the second being the coefficient
         ! and the third one being the initial values of x[n]..x[n-N].
         ! When running, the values x[n]...x[n-N] are the N last results from ca
         ! Note that this means that at the first call, x[n-0] is pushed into x[
         ! and x[n-N] is deleted; i.e. the initial x[n-N] is never used.
         !
         ! Format in fexpr_dynk:
         ! b_0 <- funcs_dynk(<this>,3)
         ! x[n]
         ! x_init[n] (holds the x[n]s from the input file, used to reset the FIR
         ! b_1
         ! x[n-1]
         ! x_init[n-1]
         ! (etc., repeat funcs_dynk(<this>,4)+1 times)
         !
         ! IIR: Infinite Impulse Response filter
         ! y[n] = \sum_{i=0}^N b_i*x[n-i] \sum_{i=1}^M a_i*y[i-n]
         ! where N=M. This is the same as FIR, except that it also uses
         ! previous values of it's own output.
         ! The input file is also identical, except adding two extra columns:
         ! One for the coefficients a_0...a_N, and one for the
         ! initial values of y[n]...y[n-N]. For both these columns,
         ! the first row (a_0 and y[n]) are ignored.
         ! For the first of these columns, the first value (a_0) is ignored and
         ! while y[n-0] is pushed into y[n-1] at the first evaluation,
         ! such that the initial x[n-N] is never used (just like for x[n-N]).
         !
         ! Format in fexpr_dynk:
         ! b_0 <- funcs_dynk(<this>,3)
         ! x[n]
         ! x_init[n]
         ! a_0  (a_0 is never used)
         ! y[n] (zeroed for computation, used to hold previously returned value)
         ! y_init[n] (holds the y[n]s from the input file, used to reset the FIR
         ! b_1
         ! x[n-1]
         ! x_init[n-1]
         ! a_1
         ! y[n-1]
         ! y_init[n-1]
         ! (etc., repeat funcs_dynk(<this>,4) times)
 
 
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname {FIR|IIR} N filename baseFUN")
         select case( getfields_fields(3)(1:getfields_lfields(3)) )
         case("FIR")
            isFIR = .true.
         case("IIR")
            isFIR = .false.
         case default
            write (*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
            write (*,*)    "DYNK> non-recognized type in inner switch?"
            write (*,*)    "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(-1)
         end select
 
         read(getfields_fields(4)(1:getfields_lfields(4)),*) t ! N
         if (isFIR) then
            call dynk_checkspace(0,3*(t+1),2)
         else
            call dynk_checkspace(0,6*(t+1),2)
         endif
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         if (isFIR) then
            funcs_dynk(nfuncs_dynk,2) = 10 !TYPE (FIR)
         else
            funcs_dynk(nfuncs_dynk,2) = 11 !TYPE (IIR)
         endif
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk+1 !ARG1 (start of float storage
         funcs_dynk(nfuncs_dynk,4) = t             !ARG2 (filter order N)
         funcs_dynk(nfuncs_dynk,5) =               !ARG3 (filtered function)
     &        dynk_findFUNindex( getfields_fields(6)
     &                           (1:getfields_lfields(6)), 1)
         !Store metadata
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk) ! N
 
         ! Sanity check
         if (funcs_dynk(nfuncs_dynk,5).eq.-1) then
            call dynk_dumpdata
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FIR/IIR function wanting function '",
     &            getfields_fields(6)(1:getfields_lfields(6)), "'"
            write (*,*)    "This FUN is unknown!"
            write (*,*) "*************************************"
            call prror(51)
         endif
        if (getfields_lfields(5) .gt. maxstrlen_dynk-1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN FIR/IIR got a filenname with "
            write (*,*)    "length =", getfields_lfields(5)
            write (*,*)    "> ",maxstrlen_dynk-1
            write (*,*)    "The name was: '",getfields_fields(5)
     &                                    (1:getfields_lfields(5)),"'"
            write (*,*)    "*************************************"
            call prror(51)
         endif
         if ( iexpr_dynk(niexpr_dynk) .le. 0 ) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "FUN FIR/IIR got N <= 0, this is not valid"
            write (*,*)    "*************************************"
            call prror(51)
         endif
 
         !More metadata
         ncexpr_dynk = ncexpr_dynk+1
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(5)) = !FILE NAME
     &        getfields_fields(5)(1:getfields_lfields(5))
 
         !Read the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(*,*)
     &           "DYNK> **** ERROR in dynk_parseFUN():FIR/IIR ****"
            write(*,*)   "DYNK> unit 664 for file '"//
     &           cexpr_dynk(ncexpr_dynk), "' was already taken"
            call prror(-1)
         end if
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat, status="OLD")
         if (stat .ne. 0) then
            write(*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
            write(*,*)    "DYNK> Error opening file '",
     &           cexpr_dynk(ncexpr_dynk), "'"
            call prror(51)
         endif
 
         do ii=0, funcs_dynk(nfuncs_dynk,4)
            !Reading the FIR/IIR file without CRLIBM
 
            !Reading the FIR/IIR file with CRLIBM
            read(664,'(a)', iostat=stat) ch
            if (stat.ne.0) then
               write(*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> File ended unexpectedly at ii =",ii
               call prror(-1)
            endif
 
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
 
            !Sanity checks
            if ( filefields_lerr ) then
               write(*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Error in getfields_split()"
               call prror(-1)
            end if
            if ( (      isFIR .and.filefields_nfields .ne. 3) .or.
     &           ((.not.isFIR).and.filefields_nfields .ne. 5)     ) then
               write(*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"', line =", ii
               write(*,*)    "DYNK> Expected 3[5] fields ",
     &              "(idx, fac, init, selfFac, selfInit), ",
     &              "got ",filefields_nfields
               call prror(-1)
            endif
 
            !Read the data into t,x,y(,z,u):
            read(filefields_fields(1)(1:filefields_lfields(1)),*) t
 
            x = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,x)
 
            y = round_near(errno, filefields_lfields(3)+1,
     &           filefields_fields(3) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,3,y)
 
            if (.not.isFIR) then
               z = round_near(errno, filefields_lfields(4)+1,
     &              filefields_fields(4) )
               if (errno.ne.0)
     &              call rounderr(errno,filefields_fields,4,z)
 
               u = round_near(errno, filefields_lfields(5)+1,
     &              filefields_fields(5) )
               if (errno.ne.0)
     &              call rounderr(errno,filefields_fields,5,u)
            endif
 
 
            ! More sanity checks
            if (t .ne. ii) then
               write(*,*)    "DYNK> dynk_parseFUN():FIR/IIR"
               write(*,*)    "DYNK> Error reading file '",
     &              cexpr_dynk(ncexpr_dynk),"'"
               write(*,*)    "DYNK> Got line t =",t, ", expected ", ii
               call prror(-1)
            endif
            !Save data to arrays
            !Store coefficients (x) and initial/earlier values (y) in interlaced
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = x      ! b_i
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = 0.0    ! x[n-1], will be initialized in dy
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = y      ! x_init[n-i]
            if (.not.isFIR) then
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = z   ! a_i
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = 0.0 ! y[n-i], will be initialized in dy
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = u   ! y_init[n-i]
            endif
         enddo
         close(664)
 
      !!! Operators: #20-39 !!!
      case("ADD","SUB","MUL","DIV","POW")
         ! Two-argument operators  y = OP(f1, f2)
 
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname {ADD|SUB|MUL|DIV|POW} funname1 funname2")
         call dynk_checkspace(0,0,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case (getfields_fields(3)(1:getfields_lfields(3)))
         case ("ADD")
            funcs_dynk(nfuncs_dynk,2) = 20 !TYPE (ADD)
         case ("SUB")
            funcs_dynk(nfuncs_dynk,2) = 21 !TYPE (SUB)
         case ("MUL")
            funcs_dynk(nfuncs_dynk,2) = 22 !TYPE (MUL)
         case ("DIV")
            funcs_dynk(nfuncs_dynk,2) = 23 !TYPE (DIV)
         case ("POW")
            funcs_dynk(nfuncs_dynk,2) = 24 !TYPE (POW)
         case default
            write (*,*)    "DYNK> dynk_parseFUN() : 2-arg function"
            write (*,*)    "DYNK> non-recognized type in inner switch"
            write (*,*)    "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) =
     &        dynk_findFUNindex( getfields_fields(4)
     &                           (1:getfields_lfields(4)), 1) !Index to f1
         funcs_dynk(nfuncs_dynk,4) =
     &        dynk_findFUNindex( getfields_fields(5)
     &                           (1:getfields_lfields(5)), 1) !Index to f2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         ! Sanity check (string lengths are done inside dynk_findFUNindex)
         if (funcs_dynk(nfuncs_dynk,3) .eq. -1 .or.
     &       funcs_dynk(nfuncs_dynk,4) .eq. -1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "TWO ARG OPERATOR wanting functions '",
     &           getfields_fields(4)(1:getfields_lfields(4)), "' and '",
     &           getfields_fields(5)(1:getfields_lfields(5)), "'"
            write (*,*)    "Calculated indices:",
     &           funcs_dynk(nfuncs_dynk,3), funcs_dynk(nfuncs_dynk,4)
            write (*,*)    "One or both of these are not known (-1)."
            write (*,*)    "*************************************"
            call dynk_dumpdata
            call prror(51)
         end if
 
      case ("MINUS","SQRT","SIN","COS","LOG","LOG10","EXP")
         ! One-argument operators  y = OP(f1)
 
         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname {MINUS|SQRT|SIN|COS|LOG|LOG10|EXP} funname")
         call dynk_checkspace(0,0,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case ( getfields_fields(3)(1:getfields_lfields(3)) )
         case ("MINUS")
            funcs_dynk(nfuncs_dynk,2) = 30 !TYPE (MINUS)
         case ("SQRT")
            funcs_dynk(nfuncs_dynk,2) = 31 !TYPE (SQRT)
         case ("SIN")
            funcs_dynk(nfuncs_dynk,2) = 32 !TYPE (SIN)
         case ("COS")
            funcs_dynk(nfuncs_dynk,2) = 33 !TYPE (COS)
         case ("LOG")
            funcs_dynk(nfuncs_dynk,2) = 34 !TYPE (LOG)
         case ("LOG10")
            funcs_dynk(nfuncs_dynk,2) = 35 !TYPE (LOG10)
         case ("EXP")
            funcs_dynk(nfuncs_dynk,2) = 36 !TYPE (EXP)
         case default
            write (*,*)    "DYNK> dynk_parseFUN() : 1-arg function"
            write (*,*)    "DYNK> non-recognized type in inner switch?"
            write (*,*)    "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) =
     &        dynk_findFUNindex(getfields_fields(4)
     &        (1:getfields_lfields(4)), 1)       !Index to f1
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         ! Sanity check (string lengths are done inside dynk_findFUNindex)
         if (funcs_dynk(nfuncs_dynk,3) .eq. -1) then
            write (*,*)    "*************************************"
            write (*,*)    "ERROR in DYNK block parsing (fort.3):"
            write (*,*)    "SINGLE OPERATOR FUNC wanting function '",
     &           getfields_fields(4)(1:getfields_lfields(4)), "'"
            write (*,*)    "Calculated index:",
     &           funcs_dynk(nfuncs_dynk,3)
            write (*,*)    "One or both of these are not known (-1)."
            write (*,*)    "*************************************"
            call dynk_dumpdata
            call prror(51)
         end if
 
      !!! Polynomial & Elliptical functions: # 40-59 !!!
      case("CONST")
         ! CONST: Just a constant value
 
         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname CONST value" )
         call dynk_checkspace(0,1,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 40          !TYPE (CONST)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! value
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)  )
 
      case ("TURN")
         ! TURN: Just the current turn number
 
         call dynk_checkargs(getfields_nfields,3,
     &        "FUN funname TURN" )
         call dynk_checkspace(0,0,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 41          !TYPE (TURN)
         funcs_dynk(nfuncs_dynk,3) = -1          !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
      case ("LIN")
         ! LIN: Linear ramp y = dy/dt*T+b
 
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname LIN dy/dt b" )
         call dynk_checkspace(0,2,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 42          !TYPE (LIN)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! dy/dt
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! b
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1) )
         nfexpr_dynk = nfexpr_dynk + 1
 
      case ("LINSEG")
         ! LINSEG: Linear ramp between points (x1,y1) and (x2,y2)
 
         call dynk_checkargs(getfields_nfields,7,
     &        "FUN funname LINSEG x1 x2 y1 y2" )
         call dynk_checkspace(0,4,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 43          !TYPE (LINSEG)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! x1
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! x2
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! y1
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
         fexpr_dynk(nfexpr_dynk+3) = round_near(errno, ! y2
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7,
     &                       fexpr_dynk(nfexpr_dynk+3)   )
         nfexpr_dynk = nfexpr_dynk + 3
 
         if (fexpr_dynk(nfexpr_dynk-3).eq.fexpr_dynk(nfexpr_dynk-2))then
            write (*,*)    "ERROR in DYNK block parsing (fort.3)"
            write (*,*)    "LINSEG: x1 and x2 must be different."
            call prror(51)
         endif
 
      case ("QUAD")
         ! QUAD: Quadratic ramp y = a*T^2 + b*T + c
 
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname QUAD a b c" )
         call dynk_checkspace(0,3,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 44          !TYPE (QUAD)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! a
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! b
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! c
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
         nfexpr_dynk = nfexpr_dynk + 2
 
      case ("QUADSEG")
         ! QUADSEG: Quadratic ramp y = a*T^2 + b*T + c,
         ! input as start point (x1,y1), end point (x2,y2), derivative at at x1
 
         call dynk_checkargs(getfields_nfields,8,
     &        "FUN funname QUADSEG x1 x2 y1 y2 deriv" )
         call dynk_checkspace(0,8,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 45          !TYPE (QUADSEG)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         x1 = round_near(errno, ! x1
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4, x1 )
         x2 = round_near(errno, ! x2
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5, x2 )
         y1 = round_near(errno, ! y1
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6, y1 )
         y2 = round_near(errno, ! y2
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7, y2 )
         deriv = round_near(errno, ! deriv
     &        getfields_lfields(8)+1, getfields_fields(8) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,8, deriv )
         if (x1 .eq. x2) then
            write (*,*)    "ERROR in DYNK block parsing (fort.3)"
            write (*,*)    "QUADSEG: x1 and x2 must be different."
            call prror(51)
         endif
 
         ! Compute a:
         fexpr_dynk(nfexpr_dynk) = deriv/(x1-x2)
     &        + (y2-y1)/((x1-x2)**2)
         ! Compute b:
         fexpr_dynk(nfexpr_dynk+1) = (y2-y1)/(x2-x1)
     &        - (x1+x2)*fexpr_dynk(nfexpr_dynk)
         ! Compute c:
         fexpr_dynk(nfexpr_dynk+2) = y1 + (
     &        - x1**2 * fexpr_dynk(nfexpr_dynk)
     &        - x1    * fexpr_dynk(nfexpr_dynk+1) )
 
         ! Store input data:
         fexpr_dynk(nfexpr_dynk+3) = x1
         fexpr_dynk(nfexpr_dynk+4) = x2
         fexpr_dynk(nfexpr_dynk+5) = y1
         fexpr_dynk(nfexpr_dynk+6) = y2
         fexpr_dynk(nfexpr_dynk+7) = deriv
 
         nfexpr_dynk = nfexpr_dynk + 7
 
      !!! Trancedental functions: #60-79 !!!
      case ("SINF","COSF","COSF_RIPP")
         ! SINF     : Sin functions y = A*sin(omega*T+phi)
         ! COSF     : Cos functions y = A*cos(omega*T+phi)
         ! COSF_RIPP: Cos functions y = A*cos(2*pi*(T-1)/period+phi)
 
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname {SINF|COSF|COSF_RIPP} "//
     &        "amplitude {omega|period} phase" )
         call dynk_checkspace(0,3,1)
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case (getfields_fields(3)(1:getfields_lfields(3)))
         case("SINF")
            funcs_dynk(nfuncs_dynk,2) = 60       !TYPE (SINF)
         case("COSF")
            funcs_dynk(nfuncs_dynk,2) = 61       !TYPE (COSF)
         case ("COSF_RIPP")
            funcs_dynk(nfuncs_dynk,2) = 62       !TYPE (COSF_RIPP)
         case default
            write (*,*)    "DYNK> dynk_parseFUN() : SINF/COSF"
            write (*,*)    "DYNK> non-recognized type in inner switch"
            write (*,*)    "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! A
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! omega
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! phi
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
         nfexpr_dynk = nfexpr_dynk + 2
 
      case ("PELP")
         ! PELP: Parabolic/exponential/linear/parabolic
         ! From "Field Computation for Accelerator Magnets:
         ! Analytical and Numerical Methods for Electromagnetic Design and Optim
         ! By Dr.-Ing. Stephan Russenschuck
         ! Appendix C: "Ramping the LHC Dipoles"
 
         call dynk_checkargs(getfields_nfields,10,
     &        "FUN funname PELP tinj Iinj Inom A D R te" )
         call dynk_checkspace(0,13,1) !!...
 
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 80          !TYPE (PELP)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
 
         !Read and calculate parameters
         tinj = round_near(errno,    ! tinj
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4, tinj )
         Iinj = round_near(errno,    ! Iinj
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5, Iinj )
         Inom = round_near(errno,    ! Inom
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6, Inom )
         A = round_near(errno,       ! A
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7, A )
         D = round_near(errno,       ! D
     &        getfields_lfields(8)+1, getfields_fields(8) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,8, D )
         R = round_near(errno,       ! R
     &        getfields_lfields(9)+1, getfields_fields(9) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,9, R )
         te = round_near(errno,      ! te
     &        getfields_lfields(10)+1, getfields_fields(10) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,10, te )
         derivI_te = A*(te-tinj)                 ! nostore
         I_te      = (A/2.0)*(te-tinj)**2 + Iinj ! nostore
         bexp      = derivI_te/I_te
         aexp      = exp(-bexp*te)*I_te
         t1        = log(R/(aexp*bexp))/bexp
         I1        = aexp*exp(bexp*t1)
         td        = (Inom-I1)/R + (t1 - R/(2*D))
         tnom      = td + R/D
 
         if (ldynkdebug) then
         write (*,*)    "DYNKDEBUG> *** PELP SETTINGS: ***"
         write (*,*)    "DYNKDEBUG> tinj =", tinj
         write (*,*)    "DYNKDEBUG> Iinj =", Iinj
         write (*,*)    "DYNKDEBUG> Inom =", Inom
         write (*,*)    "DYNKDEBUG> A    =", A
         write (*,*)    "DYNKDEBUG> D    =", D
         write (*,*)    "DYNKDEBUG> R    =", R
         write (*,*)    "DYNKDEBUG> te   =", te
         write (*,*)    "DYNKDEBUG> "
         write (*,*)    "DYNKDEBUG> derivI_te =", derivI_te
         write (*,*)    "DYNKDEBUG> I_te      =", I_te
         write (*,*)    "DYNKDEBUG> bexp      =", bexp
         write (*,*)    "DYNKDEBUG> aexp      =", aexp
         write (*,*)    "DYNKDEBUG> t1        =", t1
         write (*,*)    "DYNKDEBUG> I1        =", I1
         write (*,*)    "DYNKDEBUG> td        =", td
         write (*,*)    "DYNKDEBUG> tnom      =", tnom
         write (*,*)    "DYNKDEBUG> **********************"
         endif
 
         if (.not. (tinj .lt. te .and.
     &                te .lt. t1 .and.
     &                t1 .lt. td .and.
     &                td .lt. tnom ) ) then
            WRITE(*,*)    "DYNK> ********************************"
            WRITE(*,*)    "DYNK> ERROR***************************"
            write(*,*)    "DYNK> PELP: Order of times not correct"
            WRITE(*,*)    "DYNK> ********************************"
            call prror(51)
         endif
 
         !Store: Times
         fexpr_dynk(nfexpr_dynk)    = tinj
         fexpr_dynk(nfexpr_dynk+ 1) = te
         fexpr_dynk(nfexpr_dynk+ 2) = t1
         fexpr_dynk(nfexpr_dynk+ 3) = td
         fexpr_dynk(nfexpr_dynk+ 4) = tnom
         !Store: Parameters / section1 (parabola)
         fexpr_dynk(nfexpr_dynk+ 5) = Iinj
         fexpr_dynk(nfexpr_dynk+ 6) = A
         !Store: Parameters / section2 (exponential)
         fexpr_dynk(nfexpr_dynk+ 7) = aexp
         fexpr_dynk(nfexpr_dynk+ 8) = bexp
         !Store: Parameters / section3 (linear)
         fexpr_dynk(nfexpr_dynk+ 9) = I1
         fexpr_dynk(nfexpr_dynk+10) = R
         !Store: Parameters / section4 (parabola)
         fexpr_dynk(nfexpr_dynk+11) = D
         fexpr_dynk(nfexpr_dynk+12) = Inom
 
         nfexpr_dynk = nfexpr_dynk + 12
 
      case default
         ! UNKNOWN function
         write (*,*)    "*************************************"
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "Unkown function to dynk_parseFUN()   "
         write (*,*)    "Got fields:"
         do ii=1,getfields_nfields
            write (*,*)    "Field(",ii,") ='",
     &           getfields_fields(ii)(1:getfields_lfields(ii)),"'"
         enddo
         write (*,*)    "*************************************"
 
         call dynk_dumpdata
         call prror(51)
      end select
 
      end subroutine
 
      subroutine dynk_checkargs(nfields,nfields_expected,funsyntax)
      implicit none
      integer nfields, nfields_expected
      character(*) funsyntax
      intent(in) nfields, nfields_expected, funsyntax
 
      if (nfields .ne. nfields_expected) then
         write (*,*) "ERROR in DYNK block parsing (fort.3)"
         write (*,*) "The function expected",nfields_expected,
     &               "arguments, got",nfields
         write (*,*) "Expected syntax:"
         write (*,*) funsyntax(:)
         call prror(51)
      endif
      end subroutine
 
      subroutine dynk_checkspace(iblocks,fblocks,cblocks)
      implicit none
      integer iblocks,fblocks,cblocks
      intent(in) iblocks,fblocks,cblocks
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
 
 
      if ( (niexpr_dynk+iblocks .gt. maxdata_dynk) .or.
     &     (nfexpr_dynk+fblocks .gt. maxdata_dynk) .or.
     &     (ncexpr_dynk+cblocks .gt. maxdata_dynk) ) then
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "Max number of maxdata_dynk to be exceeded"
         write (*,*)    "niexpr_dynk:", niexpr_dynk
         write (*,*)    "nfexpr_dynk:", nfexpr_dynk
         write (*,*)    "ncexpr_dynk:", ncexpr_dynk
         call prror(51)
      endif
      end subroutine
 
      subroutine dynk_parseSET(getfields_fields,
     &     getfields_lfields,getfields_nfields)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 15-10-2014
!     parse SET lines in the fort.3 input file,
!     store it in COMMON block dynkComExpr.
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
 
      integer ii
 
      integer dynk_findFUNindex
 
      if (nsets_dynk+1 .gt. maxsets_dynk) then
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "Maximum number of SET exceeded, ",
     &                  "please increase parameter maxsets_dynk."
         write (*,*)    "Current value of maxsets_dynk:", maxsets_dynk
         call prror(51)
      endif
 
      if (getfields_nfields .ne. 7) then
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "Expected 6 fields on line while parsing SET."
         write (*,*)    "Correct syntax:"
         write (*,*)    "SET element_name attribute_name function_name",
     &                  " startTurn endTurn turnShift"
         write (*,*)    "got field:"
         do ii=1,getfields_nfields
            write (*,*)    "Field(",ii,") ='",
     &           getfields_fields(ii)(1:getfields_lfields(ii)),"'"
         enddo
         call prror(51)
      endif
 
      nsets_dynk = nsets_dynk + 1
 
      sets_dynk(nsets_dynk,1) =
     &     dynk_findFUNindex( getfields_fields(4)
     &     (1:getfields_lfields(4)), 1 ) ! function_name -> function index
      read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &     sets_dynk(nsets_dynk,2) ! startTurn
      read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &     sets_dynk(nsets_dynk,3) ! endTurn
      read(getfields_fields(7)(1:getfields_lfields(7)),*)
     &     sets_dynk(nsets_dynk,4) ! turnShift
 
      !Sanity check on string lengths
      if (getfields_lfields(2).gt.16 .or.
     &    getfields_lfields(2).gt.maxstrlen_dynk-1) then
         write (*,*)    "*************************************"
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "SET got an element name with length =",
     &        getfields_lfields(2), "> 16 or > maxstrlen_dynk-1."
         write (*,*)    "The name was: '",
     &        getfields_fields(2)(1:getfields_lfields(2)),"'"
         write (*,*)    "*************************************"
         call prror(51)
      endif
 
      if (getfields_lfields(3).gt.maxstrlen_dynk-1) then
         write(*,*)    "ERROR in DYNK block parsing (fort.3) (SET):"
         write(*,*)    "The attribute name '"//
     &        getfields_fields(2)(1:getfields_lfields(2))//"'"
         write(*,*)    "is too long! Max length is",
     &        maxstrlen_dynk-1
         call prror(51)
      endif
 
      !OK -- save them!
      csets_dynk(nsets_dynk,1)(1:getfields_lfields(2)) =
     &     getfields_fields(2)(1:getfields_lfields(2)) ! element_name
      csets_dynk(nsets_dynk,2)(1:getfields_lfields(3)) =
     &     getfields_fields(3)(1:getfields_lfields(3)) ! attribute_name
 
      ! Sanity check
      if (sets_dynk(nsets_dynk,1).eq.-1) then
         write (*,*)    "*************************************"
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "SET wanting function '",
     &        getfields_fields(4)(1:getfields_lfields(4)), "'"
         write (*,*)    "Calculated index:", sets_dynk(nsets_dynk,1)
         write (*,*)    "This function is not known."
         write (*,*)    "*************************************"
         call prror(51)
      endif
 
      if (  (sets_dynk(nsets_dynk,3) .ne. -1) .and. !Not the special case
     &      (sets_dynk(nsets_dynk,2) .gt. sets_dynk(nsets_dynk,3)) )then
         write (*,*)    "*************************************"
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "SET got first turn num > last turn num"
         write (*,*)    "first=",sets_dynk(nsets_dynk,2)
         write (*,*)    "last =",sets_dynk(nsets_dynk,3)
         write (*,*)    "SET #", nsets_dynk
         write (*,*)    "*************************************"
         call prror(51)
      end if
 
      if ( (sets_dynk(nsets_dynk,2) .le. 0 ) .or.
     &     (sets_dynk(nsets_dynk,3) .lt. -1) .or.
     &     (sets_dynk(nsets_dynk,3) .eq. 0 )     ) then
         write (*,*)    "*************************************"
         write (*,*)    "ERROR in DYNK block parsing (fort.3):"
         write (*,*)    "SET got turn number <= 0 "
         write (*,*)    "(not last = -1 meaning infinity)"
         write (*,*)    "first=",sets_dynk(nsets_dynk,2)
         write (*,*)    "last =",sets_dynk(nsets_dynk,3)
         write (*,*)    "SET #", nsets_dynk
         write (*,*)    "*************************************"
         call prror(51)
      end if
 
      end subroutine
 
      integer function dynk_findFUNindex(funName_input, startfrom)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-07-2015
!     Find and return the index in the ifuncs array to the
!      function with name funName, which should be zero-padded.
!     Return -1 if nothing was found.
!
!     Note: It is expected that the length of funName_input is
!      equal or less than maxstrlen_dynk, and if it equal,
!      that it is a zero-terminated string.
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      character(*) funName_input
      character(maxstrlen_dynk) funName
      integer startfrom
      intent(in) funName_input, startfrom
 
 
      integer ii
 
C      write(*,*)"DBGDBG input: '"//funName_input//"'",len(funName_input)
 
      if (len(funName_input).gt.maxstrlen_dynk) then
         write (*,*)    "ERROR in dynk_findFUNindex"
         write (*,*)    "len(funName_input) = ",len(funName_input),
     &        ".gt. maxstrlen_dynk-1 = ", maxstrlen_dynk-1
         call prror(-1)
      endif
      ! If the length is exactly maxstrlen_dynk, it should be zero-terminated.
      if (( len(funName_input).eq.maxstrlen_dynk ) .and.
     &    ( funName_input(len(funName_input):len(funName_input))
     &     .ne.char(0)) ) then
         write (*,*) "ERROR in dynk_findFUNindex"
         write (*,*) "Expected funName_input[-1]=NULL"
         call prror(-1)
      endif
 
      do ii=1,len(funName_input)
C         write(*,*) "DBGDBG a:", ii
         funName(ii:ii) = funName_input(ii:ii)
      enddo
      funName(1:len(funName_input)) = funName_input
      do ii=len(funName_input)+1,maxstrlen_dynk
C         write(*,*) "DBGDBG b:", ii
         funName(ii:ii) = char(0)
      enddo
C      write(*,*) "DBGDBG c:", funName, len(funName)
 
      dynk_findFUNindex = -1
 
      do ii=startfrom, nfuncs_dynk
         if (cexpr_dynk(funcs_dynk(ii,1)).eq.funName) then
            dynk_findFUNindex = ii
            exit ! break loop
         endif
      end do
 
      end function
 
      integer function dynk_findSETindex
     &     (element_name, att_name, startfrom)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 23-10-2014
!     Find and return the index in the sets array to the set which
!     matches element_name and att_name, which should be zero-padded.
!     Return -1 if nothing was found.
!
!     Note: It is expected that the length of element_name and att_name
!      is exactly maxstrlen_dynk .
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      character(maxstrlen_dynk) element_name, att_name
      integer startfrom
      intent(in) element_name, att_name, startfrom
 
      integer ii
 
      dynk_findSETindex = -1
 
      do ii=startfrom, nsets_dynk
         if ( csets_dynk(ii,1) .eq. element_name .and.
     &        csets_dynk(ii,2) .eq. att_name ) then
            dynk_findSETindex = ii
            exit                ! break loop
         endif
      enddo
 
      end function
 
      subroutine dynk_inputsanitycheck
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-10-2014
!     Check that DYNK block input in fort.3 was sane
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      ! functions
      integer dynk_findFUNindex , dynk_findSETindex
 
      integer ii, jj
      integer biggestTurn ! Used as a replacement for ending turn -1 (infinity)
      logical sane
      sane = .true.
 
      ! Check that there are no doubly-defined function names
      do ii=1, nfuncs_dynk-1
         jj = dynk_findFUNindex(cexpr_dynk(funcs_dynk(ii,1)),ii+1)
         if ( jj.ne. -1) then
            sane = .false.
            write (*,*)
     &           "DYNK> Insane: function ",
     &           ii, "has the same name as", jj
         end if
      end do
 
      ! Check that no SETS work on same elem/att at same time
      biggestTurn = 1
      do ii=1, nsets_dynk
         if (sets_dynk(ii,3) .gt. biggestTurn) then
            biggestTurn = sets_dynk(ii,3)
         endif
      end do
      biggestTurn = biggestTurn+1 !Make sure it is unique
      if (biggestTurn .le. 0) then
         !In case of integer overflow
         write(*,*)
     &        "FATAL ERROR: Integer overflow in dynk_inputsanitycheck!"
         call prror(-1)
      endif
      !Do the search!
      do ii=1, nsets_dynk-1
         if (sets_dynk(ii,3).eq.-1) sets_dynk(ii,3) = biggestTurn
!         write(*,*) "DBG: ii=",ii,
!     &           csets_dynk(ii,1)," ", csets_dynk(ii,2)
!         write(*,*)"DBG:", sets_dynk(ii,2),sets_dynk(ii,3)
 
         jj = ii
         do while (.true.)
            !Only check SETs affecting the same elem/att
            jj = dynk_findSETindex(csets_dynk(ii,1),
     &                             csets_dynk(ii,2),jj+1)
 
!            write(*,*)" DBG: jj=",jj,
!     &           csets_dynk(jj,1)," ", csets_dynk(jj,2)
 
            if (jj .eq. -1) exit ! next outer loop
 
            if (sets_dynk(jj,3).eq.-1) sets_dynk(jj,3) = biggestTurn
 
!            write(*,*)" DBG:", sets_dynk(jj,2),sets_dynk(jj,3)
 
            if ( sets_dynk(jj,2) .le. sets_dynk(ii,2) .and.
     &           sets_dynk(jj,3) .ge. sets_dynk(ii,2) ) then
               sane = .false.
               write (*,   "(A,I4,A,I8,A,I4,A,I8,A,I4,A,I8,A,I4)")
     &              " DYNK> Insane: Lower edge of SET #", jj,
     &        " =", sets_dynk(jj,2)," <= lower edge of SET #",ii,
     &        " =", sets_dynk(ii,2),"; and also higer edge of SET #",jj,
     &        " =", sets_dynk(jj,3)," >= lower edge of SET #", ii
 
            else if (sets_dynk(jj,3) .ge. sets_dynk(ii,3) .and.
     &               sets_dynk(jj,2) .le. sets_dynk(ii,3) ) then
               sane = .false.
               write (*,   "(A,I4,A,I8,A,I4,A,I8,A,I4,A,I8,A,I4)")
     &              " DYNK> Insane: Upper edge of SET #", jj,
     &        " =", sets_dynk(jj,3)," >= upper edge of SET #",ii,
     &        " =", sets_dynk(ii,3),"; and also lower edge of SET #",jj,
     &        " =", sets_dynk(jj,2)," <= upper edge of SET #", ii
 
            else if (sets_dynk(jj,2) .ge. sets_dynk(ii,2) .and.
     &               sets_dynk(jj,3) .le. sets_dynk(ii,3) ) then
               ! (other way round gets caugth by the first "if")
               sane = .false.
               write (*,   "(A,I4,A,I8,A,I8,A,A,I4,A,I8,A,I8,A)")
     &              " DYNK> Insane: SET #", jj,
     &        " = (", sets_dynk(jj,2),", ", sets_dynk(jj,3), ")",
     &        " is inside SET #", ii, " = (",
     &                sets_dynk(ii,2),", ", sets_dynk(ii,3), ")"
            endif
            if (sets_dynk(jj,3).eq.biggestTurn) sets_dynk(jj,3) = -1
         enddo
         if (sets_dynk(ii,3).eq.biggestTurn) sets_dynk(ii,3) = -1
      enddo
 
      if (.not. sane) then
         write (*,*)    "****************************************"
         write (*,*)    "*******DYNK input was insane************"
         write (*,*)    "****************************************"
         call dynk_dumpdata
         call prror(-11)
      else if (sane .and. ldynkdebug) then
         write (*,*)
     &        "DYNK> DYNK input was sane"
      end if
      end subroutine
 
      subroutine dynk_dumpdata
!----------------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-10-2014
!     Dump arrays with DYNK FUN and SET data to the std. output for debugging
!----------------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
 
      integer ii
      write(*,*)
     &     "**************** DYNK parser knows: ****************"
 
      write (*,*)    "OPTIONS:"
      write (*,*)    " ldynk            =", ldynk
      write (*,*)    " ldynkdebug       =", ldynkdebug
      write (*,*)    " ldynkfiledisable =", ldynkfiledisable
 
      write (*,*)    "FUN:"
      write (*,*)    "ifuncs: (",nfuncs_dynk,")"
      do ii=1,nfuncs_dynk
         write (*,*)
     &        ii, ":", funcs_dynk(ii,:)
 
      end do
      write (*,*)    "iexpr_dynk: (",niexpr_dynk,")"
      do ii=1,niexpr_dynk
         write (*,*)
     &     ii, ":", iexpr_dynk(ii)
      end do
      write (*,*)    "fexpr_dynk: (",nfexpr_dynk,")"
      do ii=1,nfexpr_dynk
         write (*,    '(1x,I8,1x,A,1x,E16.9)')
     &   ii, ":", fexpr_dynk(ii)
      end do
      write (*,*)    "cexpr_dynk: (",ncexpr_dynk,")"
      do ii=1,ncexpr_dynk
         write(*,*)
     &   ii, ":", "'"//trim(stringzerotrim(cexpr_dynk(ii)))//"'"
      end do
 
      write (*,*)    "SET:"
      write (*,*)    "sets(,:) csets(,1) csets(,2): (",
     &     nsets_dynk,")"
      do ii=1,nsets_dynk
         write (*,*)
     &        ii, ":", sets_dynk(ii,:),
     &        "'"//trim(stringzerotrim(csets_dynk(ii,1)))//
     &  "' ", "'"//trim(stringzerotrim(csets_dynk(ii,2)))//"'"
      end do
 
      write (*,*)    "csets_unique_dynk: (",nsets_unique_dynk,")"
      do ii=1,nsets_unique_dynk
         write (*,   '(1x,I8,1x,A,1x,E16.9)')
     &       ii, ": '"//
     &       trim(stringzerotrim(csets_unique_dynk(ii,1)))//"' '"//
     &       trim(stringzerotrim(csets_unique_dynk(ii,2)))//"' = ",
     &        fsets_origvalue_dynk(ii)
      end do
 
      write (*,*)    "*************************************************"
 
      end subroutine
 
      subroutine dynk_pretrack
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 21-10-2014
!
!     Save original values for GET functions and sanity check
!     that elements/attributes for SET actually exist.
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxl
 
 
*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc is
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?
 
C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)
 
      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are:
                                           ! (1) = function name in fort.3 (poin
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\
 
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used
 
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within f
                                         ! (2) = first turn num. where it is act
                                         ! (3) =  last turn num. where it is act
                                         ! (4) = Turn shift - number added to tu
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same or
                                                            ! (1) element name
                                                            ! (2) attribute name
 
      integer nsets_dynk ! Number of used positions in arrays
 
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to c
                                                                   ! but only on
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value
      integer nsets_unique_dynk ! Number of used positions in arrays
 
      ! Some elements (multipoles) overwrites the general settings info when ini
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable
 
      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk
 
      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
 
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata
 
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
 
      !Functions
      double precision dynk_getvalue
      integer dynk_findSETindex
 
      !Temp variables
      integer ii,jj
      character(maxstrlen_dynk) element_name_s, att_name_s
      logical found, badelem
      integer ix
      if (ldynkdebug) then
         write(*,*)
     &    "DYNKDEBUG> In dynk_pretrack()"
      end if
 
      ! Find which elem/attr combos are affected by SET
      nsets_unique_dynk = 0 !Assuming this is only run once
      do ii=1,nsets_dynk
         if ( dynk_findSETindex(
     &        csets_dynk(ii,1),csets_dynk(ii,2), ii+1 ) .eq. -1 ) then
            ! Last SET which has this attribute, store it
            nsets_unique_dynk = nsets_unique_dynk+1
 
            csets_unique_dynk(nsets_unique_dynk,1) = csets_dynk(ii,1)
            csets_unique_dynk(nsets_unique_dynk,2) = csets_dynk(ii,2)
 
            ! Sanity check: Does the element actually exist?
            element_name_s =
     &           trim(stringzerotrim(
     &           csets_unique_dynk(nsets_unique_dynk,1) ))
            att_name_s     =
     &           trim(stringzerotrim(
     &           csets_unique_dynk(nsets_unique_dynk,2) ))
            found = .false.
 
            do jj=1,il
               if ( bez(jj).eq. element_name_s) then
 
                  found = .true.
 
                  ! Check that the element type and attribute is supported
                  ! Check that the element can be used now
                  badelem = .false.
                  if (abs(kz(jj)).ge.1 .and. abs(kz(jj)).le.10) then !thin kicks
                     if (att_name_s .ne. "average_ms") then
                        badelem = .true.
                     endif
                  elseif (abs(kz(jj)).eq.12) then !cavity
                     if (.not. (att_name_s.eq."voltage"  .or.
     &                    att_name_s.eq."harmonic"       .or.
     &                    att_name_s.eq."lag_angle"          )) then
                        badelem = .true.
                     endif
                     if (kp(jj).ne.6) then
                        write(*,*)    "DYNK> Insane - want to modify ",
 
     &                      "DISABLED RF cavity named '",element_name_s,
     &                      ". Please make sure that the voltage and ",
     &                      "harmonic number in the SINGLE ELEMENTS ",
     &                      "block is not 0!"
                        call prror(-1)
                     endif
                     if (nvar .eq. 5) then
                        write(*,*)    "DYNK> Insane - want to modify ",
     &                       "RF cavity named '", element_name_s, "', ",
     &                       "but nvars=5 (from DIFF block)."
                     endif
 
                  elseif (abs(kz(jj)).eq.23 .or.   ! crab
     &                    abs(kz(jj)).eq.26 .or.   ! cc multipole,  order 2
     &                    abs(kz(jj)).eq.27 .or.   ! cc multipole,  order 3
     &                    abs(kz(jj)).eq.28 ) then ! cc muiltipole, order 4
                     if (.not. (att_name_s.eq."voltage"   .or.
     &                          att_name_s.eq."frequency" .or.
     &                          att_name_s.eq."phase"         )) then
                        badelem = .true.
                     endif
                  endif
 
                  if (badelem) then
                     write(*,*)    "DYNK> Insane - attribute '",
     &                    att_name_s, "' is not valid for element '",
     &                    element_name_s, "' which is of type",kz(jj)
                     call prror(-1)
                  endif
 
               endif
            enddo
            if (.not. found) then
               write (*,*)    "DYNK> Insane: Element '", element_name_s,
     &                        "' was not found"
               call prror(-1)
            endif
 
            ! Store original value of data point
            fsets_origvalue_dynk(nsets_unique_dynk) =
     &           dynk_getvalue(csets_dynk(ii,1),csets_dynk(ii,2))
         endif
      enddo
 
      ! Save original values for GET functions
      do ii=1,nfuncs_dynk
         if (funcs_dynk(ii,2) .eq. 0) then !GET
            fexpr_dynk(funcs_dynk(ii,3)) =
     &           dynk_getvalue( cexpr_dynk(funcs_dynk(ii,1)+1),
     &                          cexpr_dynk(funcs_dynk(ii,1)+2) )
         endif
      enddo
 
      if (ldynkdebug) call dynk_dumpdata
 
      end subroutine
 
 
      subroutine cadcum
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 13-06-2014
!     calculate dcum, as done in linopt and when parsing BLOCs (daten):
!         lengths of thick lens elements are taken on the curvilinear
!         reference system; thus, no difference between the length
!         of SBENDs and the one of RBENDs, as they are both the ARC one;
!     for future needs:
!                ds=two/ed(ix)*asin(el(ix)*ed(ix)/two)
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
 
!     temporary variables
      double precision tmpdcum, ds
      integer ientry, jentry, kentry, ix
 
      write(*,*)   ''
      write(*,10010)
      write(*,*)   ''
      write(*,*)   ' CALL TO CADCUM'
      write(*,*)   ''
 
!     initialise cumulative length
      tmpdcum=zero
 
!     loop all over the entries in the accelerator structure
      do ientry=1,iu
        ix=ic(ientry)
        if(ix.gt.nblo) then
!         SINGLE ELEMENT
          ix=ix-nblo
          if ( el(ix).gt.zero ) tmpdcum=tmpdcum+el(ix)
        else
!         BLOC: iterate over elements
          do jentry=1,mel(ix)
            kentry=mtyp(ix,jentry)
            if( el(kentry).gt.zero ) tmpdcum=tmpdcum+el(kentry)
          enddo
        endif
!       assign value of dcum
        dcum(ientry)=tmpdcum
!     go to next entry in the acclerator structure
      enddo
 
!     assign the last value to the closing MARKER:
      dcum(iu+1)=tmpdcum
 
      if ( print_dcum ) then
!       a useful printout
        write(*,10030)   'ientry','ix','name            ','dcum [m]'
        write(*,10020)    0,-1,'START           ',dcum(0)
        do ientry=1,iu
          ix=ic(ientry)
          if(ix.gt.nblo) then
!            SINGLE ELEMENT
             ix=ix-nblo
             write(*,10020)    ientry,ix,bez(ix),dcum(ientry)
          else
!            BLOC
             write(*,10020)    ientry,ix,bezb(ix),dcum(ientry)
          endif
        enddo
        write(*,10020)    iu+1,-1,'END            ',dcum(iu+1)
        write(*,*)        ''
      endif
 
!     au revoir:
      return
 
10010 format(132('-'))
10020 format(2(1x,i6),1x,a16,1x,f12.5)
10030 format(2(1x,a6),1x,a16,1x,a12)
      end subroutine
!
      subroutine linopt(dpp)
!-----------------------------------------------------------------------
!  LINEAR PARAMETERS AT THE POSITION OF EVERY ELEMENT OR BLOCK
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,iiii,im,ium,ix,izu,j,jj,jk,jm,k,kpz,kzz,l,l1,ll,
     &nmz,nr,dj
      double precision aa,aeg,alfa,bb,benkr,beta,bexi,bezii,bl1eg,bl2eg,&
     &ci,cikve,clo0,clop0,cr,crkve,crkveuk,di00,dip00,dphi,dpp,dpp1,    &
     &dppi,dpr,dyy1,dyy2,ekk,etl,phi,phibf,pie,puf,qu,qv,qw,qwc,r0,r0a, &
     &t,xl,xs,zl,zs,quz,qvz
      double precision dyy11,qu1,tiltck,tiltsk
      character*16 idum
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
!
!
      dimension t(6,4)
      dimension beta(2),alfa(2),phibf(2),phi(2)
      dimension clo0(2),clop0(2),di00(2),dip00(2),qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(6)
      dimension cr(mmul),ci(mmul)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      data dpr/6*0d0/
      save
!-----------------------------------------------------------------------
      nhmoni=0
      nvmoni=0
      nhcorr=0
      nvcorr=0
      ium=6
      pie=two*pi
      if(ncorru.eq.0) then
        write(*,10010)
        write(*,10000)
      endif
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phibf(i)=zero
        phi(i)=zero
        clo0(i)=zero
        clop0(i)=zero
        di00(i)=zero
        dip00(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      qwc(3)=zero
      do 40 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   40 continue
      etl=zero
      dpr(1)=dpp*c1e3
      dpr(6)=one
      dpp1=dpp+ded
      call clorb(dpp1)
      do 50 l=1,2
        clo0(l)=clo(l)
   50 clop0(l)=clop(l)
      call clorb(dpp)
      do 60 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
        t(6,ll-1)=di0(l)
   60 t(6,ll)=dip0(l)
      if(ncorru.eq.0) then
        write(*,10010)
        write(*,10050) (di0(l),dip0(l),l=1,2)
      endif
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      if(ierro.ne.0) call prror(22+ierro)
      if(ncorru.eq.0) write(*,10040) dpp,qwc(1),qwc(2)
      call envar(dpp)
      if(ithick.eq.1) call envardis(dpp1,aeg,bl1eg,bl2eg)
!--STARTVALUES OF THE TRAJECTORIES
      do 70 l=1,2
        ll=2*l
        t(1,ll-1)=clo(l)
   70 t(1,ll)=clop(l)
      do 80 i=1,4
        do 80 j=1,4
          t(i+1,j)=ta(j,i)
   80 t(i+1,j)=ta(j,i)
      if(ncorru.eq.0) then
        write(*,10010)
        if(iprint.eq.1) write(*,10030)
        write(*,10020)
        write(*,10010)
      endif
 
!--START OF THE MACHINE
      idum='START'
      nr=0
      call writelin(nr,idum,etl,phi,t,1,.false.)
      if(ntco.ne.0) then
        if(mod(nr,ntco).eq.0) call cpltwis(idum,t,etl,phi)
      endif
 
 
!--STRUCTURE ELEMENT LOOP
      if(nt.le.0.or.nt.gt.iu) nt=iu
      izu=0
      do 500 k=1,nt
        ix=ic(k)
        if(ix.gt.nblo) goto 220 !Not a BLOCK
        if(ithick.eq.1.and.iprint.eq.1) goto 160
 
        jj=0 !initial idx
        dj=1 !step
 
        if (ix.le.0) then
           ix=-1*ix             !hr13
           jj=mel(ix)+1         !initial idx
           dj=-1                !step
        endif
        jm=mel(ix)
!-- Loop over elements inside the block
        do 150 j=1,jm
          jj=jj+dj       ! Subelement index of current sub=element
          jk=mtyp(ix,jj) ! Single-element index of the current sub-element
          if(ithick.eq.1.and.kz(jk).ne.0) goto 120
 
          if(ithick.eq.0.and.kz(jk).ne.0) then
            etl=etl+el(jk)
 
c$$$            nr=nr+1
c$$$+if .not.collimat.and..not.bnlelens
c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
c$$$+ei
c$$$+if collimat.or.bnlelens
c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
c$$$+ei
c$$$            if(ntco.ne.0) then
c$$$              if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl,phi)
c$$$            endif
 
            write(*,*)    "ERROR in LINOPT:"
            write(*,*)    "In block ", bezb(ix),
     &           "found a thick non-drift element",
     &           bez(jk), "while ithick=1. This should not be possible!"
            call prror(-1)
            goto 500
          endif
 
!--IN BLOCK: PURE DRIFTLENGTH (above: If ITHICK=1 and kz!=0, goto 120->MAGNETELE
          etl=etl+el(jk)
          do 100 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do 100 i=1,ium
  100     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 110 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
!hr06       if(-dphi.gt.pieni) dphi=dphi+pi
            if((-1d0*dphi).gt.pieni) dphi=dphi+pi                        !hr06
  110     phi(l)=phi(l)+dphi/pie
 
          nr=nr+1
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
 
          goto 150
 
!--IN BLOCK: MAGNETELEMENT
  120     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            puf=t(6,ll-1)
!hr06       t(6,ll-1)=(aeg(jk,l,1)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,2)*(t  &
!hr06&(1,ll)+t(6,ll)*ded)+aeg(jk,l,5)*dpp1*c1e3- a(jk,l,1)*t            &
!hr06&(1,ll-1)-a(jk,l,2)*t(1,ll)- a(jk,l,5)*dpr(1))/ded
         t(6,ll-1)=(((((aeg(jk,l,1)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,2)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,5)*dpp1*c1e3)- a(jk,l,1)*t          &!hr06
     &(1,ll-1))-a(jk,l,2)*t(1,ll))- a(jk,l,5)*dpr(1))/ded                !hr06
!hr06       t(6,ll)=(aeg(jk,l,3)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,4)*(t    &
!hr06&(1,ll)+t(6,ll)*ded)+aeg(jk,l,6)*dpp1*c1e3- a(jk,l,3)*t            &
!hr06&(1,ll-1)-a(jk,l,4)*t(1,ll)- a(jk,l,6)*dpr(1))/ded
           t(6,ll)=(((((aeg(jk,l,3)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,4)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,6)*dpp1*c1e3)- a(jk,l,3)*t          &!hr06
     &(1,ll-1))-a(jk,l,4)*t(1,ll))- a(jk,l,6)*dpr(1))/ded                !hr06
            do i=1,ium-1
              puf=t(i,ll-1)
!hr06         t(i,ll-1)=puf*a(jk,l,1)+t(i,ll)*a(jk,l,2)+dpr(i)*a(jk,l,5)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
!hr06         t(i,ll)=puf*a(jk,l,3)+t(i,ll)*a(jk,l,4)+dpr(i)*a(jk,l,6)
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr06         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr06
            endif
!hr06       if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
 
          nr=nr+1
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
 
  150   continue !End of loop over elements inside block
 
        nr=nr+1
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
 
        goto 500
 
!--BETACALCULATION FOR SERIES OF BLOCKS (ix.ge.nblo.and.ithick.eq.1.and.iprint.e
  160   continue !if ithick=1 and iprint=1:
        if(ix.le.0) goto 190
!--REGULAR RUN THROUGH BLOCKS
        etl=etl+elbe(ix)
        do 170 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif
          puf=t(6,ll-1)
!hr06     t(6,ll-1)=(bl1eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,2)*(t&
!hr06&(1,ll)+t(6,ll)*ded)+ bl1eg(ix,l,5)*dpp1*c1e3- bl1(ix,l,1)*t       &
!hr06&(1,ll-1)-bl1(ix,l,2)*t(1,ll)- bl1(ix,l,5)*dpr(1))/ded
      t(6,ll-1)=(((((bl1eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,5)*dpp1*c1e3)- bl1(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,2)*t(1,ll))- bl1(ix,l,5)*dpr(1))/ded            !hr06
!hr06     t(6,ll)=(bl1eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,4)*(t  &
!hr06&(1,ll)+t(6,ll)*ded)+ bl1eg(ix,l,6)*dpp1*c1e3- bl1(ix,l,3)*t       &
!hr06&(1,ll-1)-bl1(ix,l,4)*t(1,ll)- bl1(ix,l,6)*dpr(1))/ded
      t(6,ll)=(((((bl1eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,6)*dpp1*c1e3)- bl1(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,4)*t(1,ll))- bl1(ix,l,6)*dpr(1))/ded            !hr06
          do 170 i=1,ium-1
            puf=t(i,ll-1)
!hr06       t(i,ll-1)=bl1(ix,l,1)*puf+bl1(ix,l,2)*t(i,ll)+dpr(i)*bl1    &
!hr06&(ix,l,5)
            t(i,ll-1)=(bl1(ix,l,1)*puf+bl1(ix,l,2)*t(i,ll))+dpr(i)*bl1  &!hr06
     &(ix,l,5)                                                           !hr06
!hr06  170   t(i,ll)=bl1(ix,l,3)*puf+bl1(ix,l,4)*t(i,ll)+dpr(i)*bl1(ix,l,6)
  170   t(i,ll)=(bl1(ix,l,3)*puf+bl1(ix,l,4)*t(i,ll))+dpr(i)*bl1(ix,l,6) !hr06
 
        do 180 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
!hr06       dphi=-phibf(l)
            dphi=-1d0*phibf(l)                                           !hr06
          endif
!hr06     if(-dphi.gt.pieni) dphi=dphi+pi
          if(-1d0*dphi.gt.pieni) dphi=dphi+pi                            !hr06
  180   phi(l)=phi(l)+dphi/pie
 
        nr=nr+1
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
 
        goto 500
 
!--REVERSE RUN THROUGH BLOCKS (ix.le.0)
  190   ix=-ix
        etl=etl+elbe(ix)
        do 200 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif
          puf=t(6,ll-1)
!hr06     t(6,ll-1)=(bl2eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,2)*(t&
!hr06&(1,ll)+t(6,ll)*ded)+ bl2eg(ix,l,5)*dpp1*c1e3- bl2(ix,l,1)*t       &
!hr06&(1,ll-1)-bl2(ix,l,2)*t(1,ll)- bl2(ix,l,5)*dpr(1))/ded
      t(6,ll-1)=(((((bl2eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,5)*dpp1*c1e3)- bl2(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,2)*t(1,ll))- bl2(ix,l,5)*dpr(1))/ded            !hr06
!hr06     t(6,ll)=(bl2eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,4)*(t  &
!hr06&(1,ll)+t(6,ll)*ded)+ bl2eg(ix,l,6)*dpp1*c1e3- bl2(ix,l,3)*t       &
!hr06&(1,ll-1)-bl2(ix,l,4)*t(1,ll)- bl2(ix,l,6)*dpr(1))/ded
      t(6,ll)=(((((bl2eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,6)*dpp1*c1e3)- bl2(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,4)*t(1,ll))- bl2(ix,l,6)*dpr(1))/ded            !hr06
          do 200 i=1,ium-1
            puf=t(i,ll-1)
!hr06       t(i,ll-1)=bl2(ix,l,1)*puf+bl2(ix,l,2)*t(i,ll)+dpr(i)*bl2    &
!hr06&(ix,l,5)
            t(i,ll-1)=(bl2(ix,l,1)*puf+bl2(ix,l,2)*t(i,ll))+dpr(i)*bl2  &!hr06
     &(ix,l,5)                                                           !hr06
!hr06  200   t(i,ll)=bl2(ix,l,3)*puf+bl2(ix,l,4)*t(i,ll)+dpr(i)*bl2(ix,l,6)
  200   t(i,ll)=(bl2(ix,l,3)*puf+bl2(ix,l,4)*t(i,ll))+dpr(i)*bl2(ix,l,6) !hr06
 
        do 210 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
            dphi=-phibf(l)
          endif
!hr06     if(-dphi.gt.pieni) dphi=dphi+pi
          if(-1d0*dphi.gt.pieni) dphi=dphi+pi                            !hr06
  210   phi(l)=phi(l)+dphi/pie
 
        nr=nr+1
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
 
        goto 500
 
!--NOT A BLOCK / Nonlinear insertion
  220   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        kzz=kz(ix)
 
 ! Cavity
        if(kpz.eq.6) then
          nr=nr+1
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
 
          goto 500
        endif
 
        !Beam Beam element .and. fort.3 has BB block
        if(kzz.eq.20.and.nbeam.ge.1) then
          nbeam=k
          nr=nr+1
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          goto 500
 
        endif
 
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr03         t(i,ll-1)=puf*rrtr(imtr(ix),ll-1,ll-1)+                   &
!hr03&t(i,ll)*rrtr(imtr(ix),ll-1,ll)+                                   &
!hr03&dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
!hr03         t(i,ll)=puf*rrtr(imtr(ix),ll,ll-1)+                       &
!hr03&t(i,ll)*rrtr(imtr(ix),ll,ll)+                                     &
!hr03&dpr(i)*rrtr(imtr(ix),ll,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr08         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr08
            endif
!hr03       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
            phi(l)=phi(l)+dphi/pie
          enddo
 
          nr=nr+1
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          goto 500
        endif
 
        ! Marker, beam-beam or phase-trombone -> next element
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 500
        ! RF CC Multipoles -> next element
        if (abs(kzz).eq.23.or.abs(kzz).eq.26.or.
     &      abs(kzz).eq.27.or.abs(kzz).eq.28) goto 500
 
        ! Update the matrix etc. for supported blocks
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
!hr02   zl=-(t(1,1)-xs)*tilts(k)+(t(1,3)-zs)*tiltc(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
        if(kzz.lt.0) goto 370 !Skew
        goto(230, 240, 250, 260, 270, 280, 290, 300, 310, 320, !10
     &       330, 500, 500, 500, 500, 500, 500, 500, 500, 500, !20
     &       500, 500, 500, 325, 326, 500, 500, 500),kzz       !28
 
        ! Un-recognized element (incl. cav with kp.ne.6 for non-collimat/bnlelen
        nr=nr+1
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        goto 500
 
!--HORIZONTAL DIPOLE
  230   ekk=ekk*c1e3
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
        goto 480
!--NORMAL QUADRUPOLE
  240   continue
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr08   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr08
        goto 480
!--NORMAL SEXTUPOLE
  250   ekk=ekk*c1m3
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*crkve+tiltsk*cikve)
        qu=(ekk*two)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qv=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL OCTUPOLE
  260   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(three*ekk)*(tiltck*crkve+tiltsk*cikve)                       !hr02
!hr02   qv=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL DECAPOLE
  270   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(four*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
!hr02   qv=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL DODECAPOLE
  280   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL 14-POLE
  290   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL 16-POLE
  300   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=7*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL 18-POLE
  310   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=8*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--NORMAL 20-POLE
  320   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=9*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 480
!--DIPEDGE ELEMENT
 325    continue
!hr02   dyy1=(ed(IX)*tiltc(k)*crkve-ek(IX)*tilts(k)*cikve)/(one+dpp)
        dyy1=((ed(IX)*tiltc(k))*crkve-(ek(IX)*tilts(k))*cikve)/(one+dpp) !hr02
!hr02   dyy2=(ek(IX)*tiltc(k)*cikve+ed(IX)*tilts(k)*crkve)/(one+dpp)
        dyy2=((ek(IX)*tiltc(k))*cikve+(ed(IX)*tilts(k))*crkve)/(one+dpp) !hr02
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
        goto 480
!--solenoid
 326    continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_rn(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_rn(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
        qu=ed(IX)
        qv=ek(IX)
        goto 480
!--Multipole block
  330   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)+(qu*xl-dppi*dpp)*tilts(k)                     &
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(6,2)=t(6,2)-(qu*xl+dppi)/(one+dpp)*tiltc(k)               &
!hr03&-dppi/(one+dpp)*(one-tiltc(k))
            t(6,2)=(t(6,2)-((qu*xl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
!hr03       t(6,4)=t(6,4)-(qu*xl+dppi)/(one+dpp)*tilts(k)               &
!hr03&-dppi/(one+dpp)*tilts(k)
            t(6,4)=(t(6,4)-((qu*xl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
            do 340 i=2,ium
!hr08         t(i,2)=t(i,2)+qu*t(i,1)*tiltc(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
!hr08         t(i,4)=t(i,4)+qu*t(i,3)*tilts(k)
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
  340       continue
          else
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tiltc(k)                             &
!hr03&+dppi*(one-tiltc(k))
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)-dppi*dpp*tilts(k)                             &
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(6,2)=t(6,2)-dppi/(one+dpp)*tiltc(k)                       &
!hr03&-dppi/(one+dpp)*(one-tiltc(k))
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
!hr03       t(6,4)=t(6,4)-dppi/(one+dpp)*tilts(k)                       &
!hr03&-dppi/(one+dpp)*tilts(k)
            t(6,4)=(t(6,4)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)+(qu*zl-dppi*dpp)*tilts(k)                     &
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+(-qu*zl+dppi*dpp)*tiltc(k)                    &
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
!hr03       t(6,2)=t(6,2)+(-qu*zl-dppi)/(one+dpp)*tilts(k)              &
!hr03&-dppi/(one+dpp)*tilts(k)
            t(6,2)=(t(6,2)-((qu*zl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
!hr03       t(6,4)=t(6,4)+(qu*zl+dppi)/(one+dpp)*tiltc(k)               &
!hr03&+dppi/(one+dpp)*(one-tiltc(k))
            t(6,4)=(t(6,4)+((qu*zl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
            do 350 i=2,ium
!hr03         t(i,2)=t(i,2)+qu*t(i,1)*tilts(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
!hr03         t(i,4)=t(i,4)-qu*t(i,3)*tiltc(k)
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
  350       continue
          else
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tilts(k)                             &
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+dppi*dpp*tiltc(k)                             &
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
!hr03       t(6,2)=t(6,2)-dppi/(one+dpp)*tilts(k)                       &
!hr03&-dppi/(one+dpp)*tilts(k)
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
!hr03       t(6,4)=t(6,4)+dppi/(one+dpp)*tiltc(k)                       &
!hr03&+dppi/(one+dpp)*(one-tiltc(k))
            t(6,4)=(t(6,4)+(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
          endif
        endif
        if(abs(r0).le.pieni) goto 500
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
 
          nr=nr+1
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
 
          goto 500
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 360 l=1,nmz
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
  360   continue
        if(nmz.ge.2) then
          qu=bb(2)
!hr03     qv=-aa(2)
          qv=-1d0*aa(2)
          dyy1=bb(1)+bb(2)*crkve+aa(2)*cikve
          dyy2=aa(1)-bb(2)*cikve+aa(2)*crkve
          do 365 l=3,nmz
            l1=l-1
!hr03       qu=qu+l1*(bb(l)*crkve+aa(l)*cikve)
            qu=qu+dble(l1)*(bb(l)*crkve+aa(l)*cikve)                     !hr03
!hr03       qv=qv+l1*(bb(l)*cikve-aa(l)*crkve)
            qv=qv+dble(l1)*(bb(l)*cikve-aa(l)*crkve)                     !hr03
            crkveuk=crkve*xl-cikve*zl
            cikve=crkve*zl+cikve*xl
            crkve=crkveuk
!hr03       dyy1=dyy1+bb(l)*crkve+aa(l)*cikve
            dyy1=(dyy1+bb(l)*crkve)+aa(l)*cikve                          !hr03
!hr03       dyy2=dyy2-bb(l)*cikve+aa(l)*crkve
            dyy2=(dyy2-bb(l)*cikve)+aa(l)*crkve                          !hr03
  365     continue
        else
          qu=zero
          qv=zero
          dyy1=bb(1)
          dyy2=aa(1)
        endif
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
        izu=izu+2*mmul-2*nmz
        goto 480
 
 
!--SKEW ELEMENTS
  370   kzz=-kzz
        goto(380,390,400,410,420,430,440,450,460,470),kzz
 
        ! Unrecognized element in the above GOTO (incl. kzz=-12,kp.ne.6 for non-
        nr=nr+1
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        goto 500
 
!--VERTICAL DIPOLE
  380   ekk=ekk*c1e3
!hr08   dyy1=-ekk*tilts(k)
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr08
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
        goto 480
!--SKEW QUADRUPOLE
  390   continue
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        goto 480
!--SKEW SEXTUPOLE
  400   ekk=ekk*c1m3
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qu=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-ekk*two*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*ekk)*two)*(tiltck*crkve+tiltsk*cikve)                  !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW OCTUPOLE
  410   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
!hr02   qv=-three*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*three)*ekk)*(tiltck*crkve+tiltsk*cikve)                !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW DECAPOLE
  420   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
!hr02   qv=-four*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*four)*ekk)*(tiltck*crkve+tiltsk*cikve)                 !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW DODECAPOLE
  430   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-5*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW 14-POLE
  440   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-6*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW 16-POLE
  450   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-7d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW 18-POLE
  460   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-8d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 480
!--SKEW 20-POLE
  470   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-9d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
 
!After processing an element: go here!
  480   continue
        t(6,2)=t(6,2)-dyy1/(one+dpp)
        t(6,4)=t(6,4)-dyy2/(one+dpp)
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*quz-qvz*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
!hr02       crkve=t(i,2)-t(i,1)*qu*qv
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
!hr02       cikve=t(i,4)-t(i,3)*qu*qv
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
!hr02       t(i,2)=crkve*cos(qv)+cikve*sin(qv)
!hr02       t(i,4)=-crkve*sin(qv)+cikve*cos(qv)
!hr02       crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
!hr02       cikve=-t(i,1)*sin(qv)+t(i,3)*cos(qv)
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
          else
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*qu-qv*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
!hr06   bexi=t(2,1)*t(2,1)+t(3,1)*t(3,1)
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
!hr06   bezii=t(4,3)*t(4,3)+t(5,3)*t(5,3)
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        if(ncorru.eq.0) then
          if(kz(ix).eq.11) then
            if(abs(aa(2)).gt.pieni.and.nmz.gt.1) write(34,10070) etl,   &
     &bez(ix),-2,aa(2),bexi,bezii,phi
            do iiii=3,nmz
              if(abs(bb(iiii)).gt.pieni) write(34,10070) etl,bez(ix),   &
     &iiii,bb(iiii),bexi,bezii,phi
              if(abs(aa(iiii)).gt.pieni) write(34,10070) etl,bez(ix),   &
     &-iiii,aa(iiii),bexi,bezii,phi
            enddo
          elseif(abs(ekk).gt.pieni.and.abs(kz(ix)).ge.3) then
            write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
          elseif(abs(ekk).gt.pieni.and.kz(ix).eq.-2) then
            write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
          endif
        endif
 
        nr=nr+1
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
 
  500 continue ! END LOOP OVER ELEMENTS
 
      call clorb(ded)
      do 510 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  510 continue
      call clorb(zero)
      do 520 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  520 continue
      iiii=100
      idum='END'
!hr06 bexi=t(2,1)*t(2,1)+t(3,1)*t(3,1)
      bexi=t(2,1)**2+t(3,1)**2                                           !hr06
!hr06 bezii=t(4,3)*t(4,3)+t(5,3)*t(5,3)
      bezii=t(4,3)**2+t(5,3)**2                                          !hr06
      if(ncorru.eq.0) write(34,10070) etl,idum,iiii,zero,bexi,bezii,phi
      if(ncorru.eq.0)                                                   &
     &write(*,10060)
!-----------------------------------------------------------------------
      return
10000 format(t5 ,'---- ENTRY LINOPT ----')
10010 format(132('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
10040 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7/)
10050 format(t8,'  PLANE          DISP(MM)                 DISP(MRAD)'/ &
     &t6,'      X  ',2(f20.12,6x)/t10,'  Y  ',2(f20.12,6x)/)
10060 format(//131('-')//)
10070 format(1x,1pg21.14,1x,a,1x,i4,5(1x,1pg21.14))
      end
      subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC)
!-----------------------------------------------------------------------
!  WRITE OUT LINEAR OPTICS PARAMETERS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,iwrite,ixwl,l,ll,nr
      double precision al1,al2,b1,b2,c,cp,d,dp,g1,g2,p1,t,tl
      character*16 typ
      ! isBLOC.eq.TRUE if ixwl currently refers to a BLOC index, FALSE if it is
      logical isBLOC
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension p1(2),t(6,4),b1(2),b2(2),al1(2),al2(2),g1(2),g2(2)
      dimension d(2),dp(2),c(2),cp(2)
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        do 20 l=1,2
          ll=2*l
!hr06     b1(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
          b1(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                            !hr06
!hr06     b2(l)=t(6-ll,ll-1)*t(6-ll,ll-1)+t(7-ll,ll-1)*t(7-ll,ll-1)
          b2(l)=t(6-ll,ll-1)**2+t(7-ll,ll-1)**2                          !hr06
!hr06     al1(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
          al1(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))      !hr06
!hr06     al2(l)=-(t(6-ll,ll-1)*t(6-ll,ll)+t(7-ll,ll-1)*t(7-ll,ll))
          al2(l)=-1d0*(t(6-ll,ll-1)*t(6-ll,ll)+t(7-ll,ll-1)*t(7-ll,ll))  !hr06
!hr06     g1(l)=t(ll,ll)*t(ll,ll)+t(ll+1,ll)*t(ll+1,ll)
          g1(l)=t(ll,ll)**2+t(ll+1,ll)**2                                !hr06
!hr06     g2(l)=t(6-ll,ll)*t(6-ll,ll)+t(7-ll,ll)*t(7-ll,ll)
          g2(l)=t(6-ll,ll)**2+t(7-ll,ll)**2                              !hr06
          d(l)=t(6,ll-1)*c1m3
          dp(l)=t(6,ll)*c1m3
          c(l)=t(1,ll-1)
          cp(l)=t(1,ll)
   20   continue
 
 
      if(ncorru.eq.0) then
          write(*,10000) nr,typ(:8),tl,p1(1),b1(1),al1(1),g1(1),d(1),   &
     &dp(1),c(1),cp(1)
          write(*,10010) b2(1),al2(1),g2(1)
          write(*,10030) typ(9:16)
          write(*,10020) p1(2),b1(2),al1(2),g1(2),d(2),dp(2),           &
     &c(2),cp(2)
          write(*,10010) b2(2),al2(2),g2(2)
          write(*,10040)
        else
           if(.not.isBLOC) then
              if(kp(ixwl).eq.3) then
                 nhmoni=nhmoni+1
                 betam(nhmoni,1)=b1(1)
                 pam(nhmoni,1)=(p1(1)*2d0)*pi
                 bclorb(nhmoni,1)=c(1)
              else if(kp(ixwl).eq.4) then
                 nhcorr=nhcorr+1
                 betac(nhcorr,1)=b1(1)
                 pac(nhcorr,1)=(p1(1)*2d0)*pi
              else if(kp(ixwl).eq.-3) then
                 nvmoni=nvmoni+1
                 betam(nvmoni,2)=b1(2)
                 pam(nvmoni,2)=(p1(2)*2d0)*pi
                 bclorb(nvmoni,2)=c(2)
              else if(kp(ixwl).eq.-4) then
                 nvcorr=nvcorr+1
                 betac(nvcorr,2)=b1(2)
                 pac(nvcorr,2)=(p1(2)*2d0)*pi
              endif
           endif
        endif
      endif
!-----------------------------------------------------------------------
      return
10010 format('|',6x,'|',8x,'|',12x,'|',1x,'|',12x,'|',f12.6,'|', f13.7, &
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10020 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f12.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format(132('-'))
10000 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f12.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10030 format('|',6x,'|',a8,'|',12x,'|',102('-'))
      end
      subroutine cpltwis(typ,t,etl,phi)
!-----------------------------------------------------------------------
!  CALCULATES COUPLED TWISS PARAMETERS AROUND THE RING AND ALSO THE
!  ANGLE OF THE MAJOR AXIS OF A ELLIPSE IN THE X-Y PROJECTION WITH
!  THE X-AXIS. THE 4-D ELLIPSOID IS GIVEN BY THE BOUNDARY OF A
!  DISTRIBUTION OF PARTICLES WITH MAXIMUM EMITANCE OF MODE I AND II,
!  EUI AND EUII RESPECTIVELY.
!  BINARY PRINT ON FILE 11 OF 22 VALUES :
!  POSITION [M],
!  BET(1-4), ALF(1-4), GAM(1-4), COOR-PHI(1-4), COOR-PRIME-PHI(1-4),
!  COUUANGL
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,iwrite
      double precision alxi,alxii,alzi,alzii,bexi,bexii,bezi,bezii,     &
     &couuang,etl,gaxi,gaxii,gazi,gazii,phi,phxi,phxii,phxpi,phxpii,    &
     &phzi,phzii,phzpi,phzpii,t
      character*16 typ
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension t(6,4),phi(2)
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
!hr06   bexi=t(2,1)*t(2,1)+t(3,1)*t(3,1)
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
!hr06   bexii=t(4,1)*t(4,1)+t(5,1)*t(5,1)
        bexii=t(4,1)**2+t(5,1)**2                                        !hr06
!hr06   bezi=t(2,3)*t(2,3)+t(3,3)*t(3,3)
        bezi=t(2,3)**2+t(3,3)**2                                         !hr06
!hr06   bezii=t(4,3)*t(4,3)+t(5,3)*t(5,3)
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
!hr06   alxi=-(t(2,1)*t(2,2)+t(3,1)*t(3,2))
        alxi=-1d0*(t(2,1)*t(2,2)+t(3,1)*t(3,2))                          !hr06
!hr06   alxii=-(t(4,1)*t(4,2)+t(5,1)*t(5,2))
        alxii=-1d0*(t(4,1)*t(4,2)+t(5,1)*t(5,2))                         !hr06
!hr06   alzi=-(t(2,3)*t(2,4)+t(3,3)*t(3,4))
        alzi=-1d0*(t(2,3)*t(2,4)+t(3,3)*t(3,4))                          !hr06
!hr06   alzii=-(t(4,3)*t(4,4)+t(5,3)*t(5,4))
        alzii=-1d0*(t(4,3)*t(4,4)+t(5,3)*t(5,4))                         !hr06
!hr06   gaxi=t(2,2)*t(2,2)+t(3,2)*t(3,2)
        gaxi=t(2,2)**2+t(3,2)**2                                         !hr06
!hr06   gaxii=t(4,2)*t(4,2)+t(5,2)*t(5,2)
        gaxii=t(4,2)**2+t(5,2)**2                                        !hr06
!hr06   gazi=t(2,4)*t(2,4)+t(3,4)*t(3,4)
        gazi=t(2,4)**2+t(3,4)**2                                         !hr06
!hr06   gazii=t(4,4)*t(4,4)+t(5,4)*t(5,4)
        gazii=t(4,4)**2+t(5,4)**2                                        !hr06
        if(abs(t(2,1)).gt.pieni) phxi=atan2_rn(t(3,1),t(2,1))
        if(abs(t(4,1)).gt.pieni) phxii=atan2_rn(t(5,1),t(4,1))
        if(abs(t(2,3)).gt.pieni) phzi=atan2_rn(t(3,3),t(2,3))
        if(abs(t(4,3)).gt.pieni) phzii=atan2_rn(t(5,3),t(4,3))
        if(abs(t(2,2)).gt.pieni) phxpi=atan2_rn(t(3,2),t(2,2))
        if(abs(t(4,2)).gt.pieni) phxpii=atan2_rn(t(5,2),t(4,2))
        if(abs(t(2,4)).gt.pieni) phzpi=atan2_rn(t(3,4),t(2,4))
        if(abs(t(4,4)).gt.pieni) phzpii=atan2_rn(t(5,4),t(4,4))
        if(abs(t(2,1)).le.pieni) phxi=pi*half
        if(abs(t(4,1)).le.pieni) then
          if(bexii.gt.pieni) phxii=pi*half
          if(bexii.le.pieni) phxii=zero
        endif
        if(abs(t(2,3)).le.pieni) then
          if(bezi.gt.pieni) phzi=pi*half
          if(bezi.le.pieni) phzi=zero
        endif
        if(abs(t(4,3)).le.pieni) phzii=pi*half
        if(abs(t(2,2)).le.pieni) phxpi=pi*half
        if(abs(t(4,2)).le.pieni) then
          if(gaxii.gt.pieni) phxpii=pi*half
          if(gaxii.le.pieni) phxpii=zero
        endif
        if(abs(t(2,4)).le.pieni) then
          if(gazi.gt.pieni) phzpi=pi*half
          if(gazi.le.pieni) phzpi=zero
        endif
        if(abs(t(4,4)).le.pieni) phzpii=pi*half
        if(abs(eui*(bexi-bezi)+euii*(bexii-bezii)).gt.pieni) then
!hr06     couuang=half*atan_rn(two*(eui*sqrt(bexi*bezi)*                &
!hr06&cos_rn(phxi-phzi)+                                                &
!hr06&euii*sqrt(bexii*bezii)*cos_rn(phxii-phzii))/ (eui*(bexi-bezi)     &
!hr06&+euii*(bexii-bezii)))
          couuang=half*atan_rn((two*((eui*sqrt(bexi*bezi))*             &!hr06
     &cos_rn(phxi-phzi)+                                                &!hr06
     &(euii*sqrt(bexii*bezii))*cos_rn(phxii-phzii)))/ (eui*(bexi-bezi)  &!hr06
     &+euii*(bexii-bezii)))                                              !hr06
!if crlibm
!hr06&euii*sqrt(bexii*bezii)*cos_rn(phxii-phzii))/ (eui*(bexi-bezi)     &
!ei
!if .not.crlibm
!hr06&euii*sqrt(bexii*bezii)*cos(phxii-phzii))/ (eui*(bexi-bezi)        &
!ei
!hr06&+euii*(bexii-bezii)))
        else
          couuang=zero
        endif
        write(11,*) typ,etl,phi,bexi,bexii,bezi,bezii, alxi,alxii,alzi, &
     &alzii, gaxi,gaxii,gazi,gazii,phxi,phxii,phzi,phzii, phxpi,        &
     &phxpii,phzpi,phzpii,couuang,t(6,1),t(6,2),t(6,3),t(6,4),t(1,1),   &
     &t(1,2),t(1,3),t(1,4)
 
      endif
      return
      end
      subroutine loesd (rmat, vec,dimakt,dimtot,kod)
!-----------------------------------------------------------------------
!  SOLUTION OF A SYSTEM OF LINEAR EQUATIONS
!  VEC1 = VEC2 * RMAT , WITH VEC2 AS RESULT
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ik,indi,j,jk,jy,k,kk,kod,l,n,n1,dimtot,dimakt
      double precision emax,eps,r,rmat,vec
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension rmat(dimtot,dimakt),vec(dimakt)
      data eps /1d-20/
      save
!-----------------------------------------------------------------------
      kod=1
      do 50 j=1,dimakt
        emax=zero
        do 10 ik=j,dimakt
          if(abs(emax).gt.abs(rmat(j,ik)) .or.emax.ne.emax) goto 10
          emax=rmat(j,ik)
          indi=ik
   10   continue
        if(abs(emax).lt.eps) then
          write(*,*) '  ****   ERROR IN LOESD   **** '
          return
        endif
   20   do 30 l=j,dimakt
          r=rmat(l,j)
          rmat(l,j)=rmat(l,indi)
          rmat(l,indi)=r
          rmat(l,j)=rmat(l,j)/emax
   30   continue
        r=vec(indi)
        vec(indi)=vec(j)
        vec(j)=r/emax
        if(j.eq.dimakt) goto 60
        jy=j+1
        do 50 jk=jy,dimakt
          r=rmat(j,jk)
          do 40 kk=jy,dimakt
            rmat(kk,jk)= rmat(kk,jk)-r*rmat(kk,j)
   40     continue
          vec(jk)=vec(jk)-vec(j)*r
   50 continue
   60 n=dimakt
      n1=dimakt-1
      do 70 j=1,n1
        do 70 k=1,j
          vec(n-j)=vec(n-j)-rmat(n-k+1,n-j)*vec(n-k+1)
   70 continue
      kod = 0
      return
      end
      subroutine matrix(dpp,am)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ierr,l
      double precision am,dpp
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension am(4,4)
      save
!-----------------------------------------------------------------------
      do 10 i=2,5
        do 10 l=1,2
          x(i,l)=zero
   10 y(i,l)=zero
      x(2,1)=one
      y(3,1)=one
      x(4,2)=one
      y(5,2)=one
      do 20 l=1,2
        x(1,l)=clo(l)
   20 y(1,l)=clop(l)
      call umlauf(dpp,5,ierr)
      ierro=ierr
      do 30 i=1,4
        am(1,i)=x(i+1,1)
        am(2,i)=y(i+1,1)
        am(3,i)=x(i+1,2)
   30 am(4,i)=y(i+1,2)
!-----------------------------------------------------------------------
      return
      end
      subroutine corrorb
!-----------------------------------------------------------------------
!  CORRECTION OF CLOSED ORBIT FIRST (MOST EFFECTIV CORRECTOR STRATEGY
!  USING MICADO), THEN
!  SCALING OF DIPOLE-ERRORS FOR RMS-VALUES OF THE CLOSED ORBIT
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,icflag,ihflag,ii,ij,im,iprinto,ivflag,j,k,kpz,kzz,l,    &
     &nlino,ntcoo,nto,nx
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      real ar(nmon1,ncor1)
      real b(nmon1),orbr(nmon1),xinc(ncor1)
      real rmsx,ptpx,rmsz,ptpz,rzero,rzero1
      double precision clo0,clop0,hfac,qwc1,vfac
      character*16 bezlo(nele)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension clo0(2),clop0(2)
      dimension qwc1(3),nx(ncor1)
      save
!-----------------------------------------------------------------------
      rzero=0.0
      rzero1=0.0
      do 10 l=1,2
        clo0(l)=zero
        clop0(l)=zero
        di0(l)=zero
   10 dip0(l)=zero
      call clorb(ded)
      if(ierro.gt.0) call prror(4)
      do 20 l=1,2
        clo0(l)=clo(l)
   20 clop0(l)=clop(l)
      call clorb(zero)
      if(ierro.gt.0) call prror(5)
      do 30 l=1,2
        di0(l)=(clo0(l)-clo(l))/ded
   30 dip0(l)=(clop0(l)-clop(l))/ded
      do 40 l=1,ncor1
        xinc(l)=0.0
   40 nx(l)=0
      if(iclo.eq.0) return
!-- ORBIT CORRECTION
      ihflag=0
      ivflag=0
      icflag=0
 
      write(*,*)
      write(*,10000)
      if(ncorru.eq.0) then
        call prror(84)
      else
        if(ncorrep.le.0) then
          write(*,10010) ncorru,sigma0(1),sigma0(2)
        else
          write(*,10020) ncorru,ncorrep
        endif
      endif
      write(*,*)
 
!-- SAVE OLD 'LINOPT' SETTINGS
      iprinto=iprint
      nto=nt
      ntcoo=ntco
      do 50 i=1,nlin
        bezlo(i)=bezl(i)
   50 continue
      nlino=nlin
!-- PUT MONITORS AND CORRECTORS INTO LINOPT SETTINGS
!-- GET TWISS PARAMETERS AND DISTORTED ORBIT BACK
      iprint=0
      ntco=0
      nlin=0
      do 60 i=1,il
        if(kp(i).eq.3.or.kp(i).eq.4.or. kp(i).eq.-3.or.kp(i).eq.-4) bezl&
     &(i)=bez(i)
        nlin=nlin+1
   60 continue
      call linopt(zero)
      call phasad(zero,qwc1)
 
!-- CHECK SOME CONDITIONS
      write(*,10100) nhmoni,nhcorr,nvmoni,nvcorr
      if(nhmoni.gt.nmon1) then
        write(*,10070) nhmoni,nmon1
        return
      endif
      if(nvmoni.gt.nmon1) then
        write(*,10070) nvmoni,nmon1
        return
      endif
      if(nhcorr.gt.ncor1) then
        write(*,10080) nhcorr,ncor1
        return
      endif
      if(nvcorr.gt.ncor1) then
        write(*,10080) nvcorr,ncor1
        return
      endif
      if(nhmoni.lt.nhcorr.or.nvmoni.lt.nvcorr) write(*,10090)
 
      write(*,*)
      call orbinit
!-- CORRECT BOTH PLANES
      if(ncorrep.eq.0) then
        icflag=1
        ncorrep=itco
      endif
      do 110 ii=1,ncorrep
!-- HORIZONTAL PLANE FIRST
        do 70 i=1,nhmoni
!hr06     b(i)=bclorb(i,1)
          b(i)=real(bclorb(i,1))
          do 70 j=1,nhcorr
!hr06       ar(i,j)=sqrt(betam(i,1)*betac(j,1))*cos_rn(abs(pam(i,1)- pac
!hr06&(j,1))-qwc1(1)*pi)*c1e3/(2*sin_rn(qwc1(1)*pi))
      ar(i,j)=real(((sqrt(betam(i,1)*betac(j,1))*cos_rn(abs(pam(i,1)-pac&!hr06
     &(j,1))-qwc1(1)*pi))*c1e3)/(2d0*sin_rn(qwc1(1)*pi)))                !hr06
!hr06+if crlibm
!hr06&(j,1))-qwc1(1)*pi)*c1e3/(2*sin_rn(qwc1(1)*pi))
!hr06+ei
!hr06+if .not.crlibm
!hr06&(j,1))-qwc1(1)*pi)*c1e3/(2*sin(qwc1(1)*pi))
!hr06+ei
   70   continue
        call calrms(b,nhmoni,rmsx,ptpx)
!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nhmoni,nhcorr,xinc,nx,orbr,ncorru,rzero,rzero1)
 
!-- VERTICAL PLANE HERE
        do 80 i=1,nvmoni
!hr06     b(i)=bclorb(i,2)
          b(i)=real(bclorb(i,2))                                         !hr06
          do 80 j=1,nvcorr
!hr06       ar(i,j)=sqrt(betam(i,2)*betac(j,2))*cos_rn(abs(pam(i,2)- pac
!hr06&(j,2))-qwc1(2)*pi)*c1e3/(2*sin_rn(qwc1(2)*pi))
      ar(i,j)=real(((sqrt(betam(i,2)*betac(j,2))*cos_rn(abs(pam(i,2)-pac&!hr06
     &(j,2))-qwc1(2)*pi))*c1e3)/(2d0*sin_rn(qwc1(2)*pi)))                !hr06
!hr06+if crlibm
!hr06&(j,2))-qwc1(2)*pi)*c1e3/(2*sin_rn(qwc1(2)*pi))
!hr06+ei
!hr06+if .not.crlibm
!hr06&(j,2))-qwc1(2)*pi)*c1e3/(2*sin(qwc1(2)*pi))
!hr06+ei
   80   continue
        call calrms(b,nvmoni,rmsz,ptpz)
        write(*,10030) ii-1,rmsx,rmsz
        write(*,10040) ii-1,ptpx,ptpz
        if(icflag.eq.1.and.sigma0(1).gt.rmsx.and.ihflag.eq.0) then
          write(*,10110)
          ihflag=1
        endif
        if(icflag.eq.1.and.sigma0(2).gt.rmsz.and.ivflag.eq.0) then
          write(*,10120)
          ivflag=1
        endif
 
        if(ihflag.eq.0) then
          write(*,*)
          do 90 ij=1,ncorru/10
            write(*,10050) (nx(10*(ij-1)+k), k=1,10)
   90     continue
          if(mod(ncorru,10).gt.0) then
            write(*,10050) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,1)
        endif
!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nvmoni,nvcorr,xinc,nx,orbr,ncorru,rzero,rzero1)
 
        if(ivflag.eq.0) then
          write(*,*)
          do 100 ij=1,ncorru/10
            write(*,10060) (nx(10*(ij-1)+k), k=1,10)
  100     continue
          if(mod(ncorru,10).gt.0) then
            write(*,10060) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,2)
        endif
 
        if(ihflag.eq.1.and.ivflag.eq.1) goto 140
        call linopt(zero)
        call phasad(zero,qwc1)
  110 continue
 
!-- GET LAST VALUES AFTER CORRECTION
      do 120 i=1,nhmoni
!hr06   b(i)=bclorb(i,1)
        b(i)=real(bclorb(i,1))                                           !hr06
  120 continue
      call calrms(b,nhmoni,rmsx,ptpx)
      do 130 i=1,nvmoni
!hr06   b(i)=bclorb(i,2)
        b(i)=real(bclorb(i,2))                                           !hr06
  130 continue
      call calrms(b,nvmoni,rmsz,ptpz)
      write(*,10030) ncorrep,rmsx,rmsz
      write(*,10040) ncorrep,ptpx,ptpz
      write(*,*)
 
  140 continue
      if((ii-1).eq.itco) write(*,10130) itco
 
!-- SCALE TO DESIRED RMS VALUE IF IT IS GREATER THAN ZERO
      if(sigma0(1).gt.pieni.or.sigma0(2).gt.pieni) then
        do 180 ii=1,itco
          write(*,10140)
!hr06     hfac=sigma0(1)/rmsx
          hfac=sigma0(1)/dble(rmsx)                                      !hr06
!hr06     vfac=sigma0(2)/rmsz
          vfac=sigma0(2)/dble(rmsz)                                      !hr06
          do 150 i=1,il
            kzz=kz(i)
            kpz=kp(i)
            if(kzz.eq.1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*hfac
              ek(i)=ek(i)*hfac
            endif
            if(kzz.eq.-1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*vfac
              ek(i)=ek(i)*vfac
            endif
            if(kzz.eq.11) then
              im=irm(i)
              ak0(im,1)=ak0(im,1)*vfac
              aka(im,1)=aka(im,1)*vfac
              bk0(im,1)=bk0(im,1)*hfac
              bka(im,1)=bka(im,1)*hfac
            endif
  150     continue
          call linopt(zero)
          do 160 i=1,nhmoni
!hr06       b(i)=bclorb(i,1)
            b(i)=real(bclorb(i,1))                                       !hr06
  160     continue
          call calrms(b,nhmoni,rmsx,ptpx)
          do 170 i=1,nvmoni
!hr06       b(i)=bclorb(i,2)
            b(i)=real(bclorb(i,2))                                       !hr06
  170     continue
          call calrms(b,nvmoni,rmsz,ptpz)
          write(*,10150) ii,rmsx,rmsz
          write(*,10160) ii,ptpx,ptpz
          write(*,*)
!hr06     if(abs(rmsx-sigma0(1)).lt.dsi.and. abs(rmsz-sigma0(2)).lt.dsi)&
          if(abs(dble(rmsx)-sigma0(1)).lt.dsi.and.                      &!hr06
     &       abs(dble(rmsz)-sigma0(2)).lt.dsi)                          &!hr06
     &goto 190
  180   continue
      endif
      if((ii-1).eq.itco) write(*,10130) itco
  190 continue
 
!-- WRITE OUT ADJUSTED CLOSED ORBIT
      do 200 i=1,nhmoni
        write(28,*) i,bclorb(i,1)
  200 continue
      do 210 i=1,nhmoni
        write(29,*) i,bclorb(i,2)
  210 continue
 
!-- CHANGE BACK TO OLD 'LINOPT' SETTINGS
      iprint=iprinto
      nt=nto
      ntco=ntcoo
      nlin=nlino
      do 220 i=1,nlin
        bezl(i)=bezlo(i)
  220 continue
      ncorru=0
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ORBIT CORRECTION WITH MOST EFFCTIVE CORRECTOR ',  &
     &'STRATEGY ----')
10010 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS UNTIL',/, &
     &t5,'       HOR. RMS SMALLER THAN ',f6.3,' MM',/, t5,              &
     &'       VER. RMS SMALLER THAN ',f6.3,' MM')
10020 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS AND ',i4, &
     &' ITERATIONS.')
10030 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-RMS: ',f6.3, &
     &' VER.-RMS: ',f6.3)
10040 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-PTP: ',f6.3, &
     &' VER.-PTP: ',f6.3)
10050 format(t5,'     HORIZONTAL CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10060 format(t5,'     VERTICAL   CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10070 format(/,t5,'ERROR: NUMBER OF MONITORS TOO BIG.',/                &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10080 format(/,t5,'ERROR: NUMBER OF CORRECTORS TOO BIG.',/              &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10090 format(/,t5,'WARNING: NUMBER OF MONITORS IS SMALLER THAN NUMBER', &
     &' OF CORRECTORS.',/ '    NUMERICAL PROBLEMS MIGHT BE ENCOUNTERED.'&
     &)
10100 format(/,t5,'NUMBER OF HOR. MONITORS: ',i4,                       &
     &'  NUMBER OF HOR. CORRECTORS: ',i4,/, t5,                         &
     &'NUMBER OF VER. MONITORS: ',i4, '  NUMBER OF VER. CORRECTORS: ',  &
     &i4)
10110 format(t10,'HORIZONTAL RMS GOAL REACHED')
10120 format(t10,'VERTICAL RMS GOAL REACHED')
10130 format(t10,'MAXIMUM NUMBER OF ITERATIONS ACHIVED: ',i4,/ ,t10,    &
     &'INCREASE ITCO TO INCREASE THE NUMBER OF ' ,                      &
     &'CLOSED ORBIT ITERATIONS',/)
10140 format(t5,'---- ORBIT SCALING USING ALL POSSIBLE ELEMENTS ')
10150 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-RMS: ',f6.3,    &
     &' VER.-RMS: ',f6.3)
10160 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-PTP: ',f6.3,    &
     &' VER.-PTP: ',f6.3)
      end
      subroutine putorb(xinc,nx,npflag)
!-----------------------------------------------------------------------
!  PUT ORBIT CHANGES FROM MICADO TO THE GIVEN ORBIT CORRECTORS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,im,ix,izu,j,k,kcorr,kcorru,kpz,kzz,nmz,npflag,nx
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      real xinc(ncor1)
      double precision ckicknew,ckickold,r0,r0a
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension nx(ncor1)
      save
!-----------------------------------------------------------------------
      kcorru=0
      kcorr=0
      izu=0
 
      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if(kpz.eq.4.and.kzz.eq.1.and.npflag.eq.1.or.                    &
     &kpz.eq.-4.and.kzz.eq.-1.and.npflag.eq.2) then
          kcorr=kcorr+1
          do 10 j=1,ncorru
            if(nx(j).eq.kcorr) then
              kcorru=kcorru+1
              ckickold=sm(ix)+zfz(izu)*ek(ix)
!hr06         zfz(izu)=zfz(izu)+xinc(j)/ek(ix)
              zfz(izu)=zfz(izu)+dble(xinc(j))/ek(ix)                     !hr06
              ckicknew=sm(ix)+zfz(izu)*ek(ix)
              write(*,10000) kcorru,kcorr,bez(ix), ckickold*c1e3,       &
     &ckicknew*c1e3
            endif
   10     continue
        endif
        izu=izu+2
 
        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one
          do 50 k=1,nmz
            izu=izu+1
            if(kpz.eq.-4.and.npflag.eq.2.and.k.eq.1) then
              kcorr=kcorr+1
              do 30, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k))/r0a
!hr06             zfz(izu)=zfz(izu)+c1e3* (xinc(j)/(r0a*ed(ix))-ak0     &
!hr06&(im,k))/aka(im,k)
           zfz(izu)=zfz(izu)+(c1e3* (dble(xinc(j))/(r0a*ed(ix))-ak0     &!hr06
     &(im,k)))/aka(im,k)                                                 !hr06
!hr06             ckicknew=ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k))/r0a
                  ckicknew=(ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k)))/r0a  !hr06
                  write(*,10000) kcorru,kcorr,bez(ix), ckickold,ckicknew
                endif
   30         continue
            endif
            izu=izu+1
            if(kpz.eq.4.and.npflag.eq.1.and.k.eq.1) then
              kcorr=kcorr+1
              do 40, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
!hr06             ckickold=ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k))/r0a
                  ckickold=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
!hr06             zfz(izu)=zfz(izu)+c1e3* (xinc(j)/(r0a*ed(ix))-bk0     &
!hr06&(im,k))/bka(im,k)
           zfz(izu)=zfz(izu)+(c1e3* (dble(xinc(j))/(r0a*ed(ix))-bk0     &!hr06
     &(im,k)))/bka(im,k)                                                 !hr06
!hr06             ckicknew=ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k))/r0a
                  ckicknew=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
                  write(*,10000) kcorru,kcorr,bez(ix), ckickold,ckicknew
                endif
   40         continue
            endif
   50     continue
          izu=izu+2*mmul-2*nmz
        endif
   60 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,i4,i4,' ',a16,'  OLD: ',d13.7,' MRAD   NEW: ' ,d13.7,   &
     &' MRAD')
      end
      subroutine orbinit
!-----------------------------------------------------------------------
!  INITIALIZES THE RANDOM NUMBER OF NOT SET CORRCTORS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,im,ix,izu,kpz,kzz,nmz
      double precision r0
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      save
!-----------------------------------------------------------------------
      izu=0
      do 10 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 10
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 10
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if((kpz.eq.4.and.kzz.eq.1).or.(kpz.eq.-4.and.kzz.eq.-1)) then
          zfz(izu)=zero
          ek(ix)=one
          ncororb(ix)=1
        endif
        izu=izu+2
 
        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 10
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 10
          endif
          im=irm(ix)
 
          izu=izu+1
          if(kpz.eq.-4) then
            zfz(izu)=zero
            aka(im,1)=one
          endif
          izu=izu+1
          if(kpz.eq.4) then
            zfz(izu)=zero
            bka(im,1)=one
          endif
          izu=izu+2*mmul-2
        endif
   10 continue
      return
      end
      subroutine htls(a,b,m,n,x,ipiv,r,iter,rms,ptp)
!*********************************************************************
!     Subroutine HTLS to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     DIMENSION OF ARRAY RHO SHOULD BE 3*NCOR1                       *
!     M    - NUMBER OF AVAILABLE MONITORS                            *
!     N    - NUMBERR OF AVAILABLE INDEPENDENT CORRECTORS             *
!     ITER - NUMBER OF CORRECTORS TO BE USED                         *
!     RMS  - RMS VALUE TO CORRECT FOR                                *
!     PTP  - PEAK TO PEAK VALUE TO CORRECT FOR                       *
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,iii,ij1,ip,ipiv,iter,j,j1,k,k2,k3,ki,kk,kpiv,m,n,ncor1, &
     &nmon1
      real a,b,piv,pivt,ptop,r,rho,rmss,x,xiter,xptp,xrms
      real rms,ptp
      real g,h,sig,beta
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),x(ncor1),ipiv(ncor1),r(nmon1)
      dimension rho(3*ncor1),xiter(ncor1),xrms(ncor1),xptp(ncor1)
      dimension rmss(ncor1),ptop(ncor1)
      save
!-----------------------------------------------------------------------
 
! --- calcul du premier pivot
 
!============================
      beta=0.0
 
      do 10 ij1=1,500
   10 rho(ij1)=0.0
 
      k2=n + 1
      piv=0.0d0
 
      do 40 k=1,n
        ipiv(k)=k
!hr06   h=0.0d0
        h=0.0                                                            !hr06
!hr06   g=0.0d0
        g=0.0                                                            !hr06
        do 20 i=1,m
          h=h+a(i,k)*a(i,k)
          g=g+a(i,k)*b(i)
   20   continue
        rho(k)=h
        rho(k2) = g
!hr06   pivt = g*g/h
        pivt = g**2/h                                                    !hr06
        if(pivt-piv.le.0) goto 40
        if(pivt-piv.gt.0) goto 30
   30   piv = pivt
        kpiv=k
   40 k2 = k2 + 1
 
! --- boucle pour chaque iteration
 
      do 150 k=1,iter
        if(kpiv.eq.k)goto 60
 
! --- on echange les K et KPIV si KPIV plus grand que K
        h=rho(k)
        rho(k)=rho(kpiv)
        rho(kpiv)=h
        k2=n+k
        k3=n+kpiv
        g = rho(k2)
        rho(k2) = rho(k3)
        rho(k3) = g
        do 50 i=1,m
          h=a(i,k)
          a(i,k)=a(i,kpiv)
          a(i,kpiv)=h
   50   continue
 
! --- calcul de beta,sigma et uk dans htul
   60   continue
        call htul(a,m,n,k,sig,beta)
 
! --- on garde SIGMA dans RHO(N+K)
        j=n+k
!hr06   rho(j)=-sig
        rho(j)=-1.0*sig                                                  !hr06
        ip=ipiv(kpiv)
        ipiv(kpiv)=ipiv(k)
        ipiv(k)=ip
        if(k.eq.n) goto 70
 
! --- transformation de A dans HTAL
        call htal(a,m,n,k,beta)
 
! --- transformation de B dans HTBL
   70   continue
        call htbl(a,b,m,n,k,beta)
 
! --- recherche du pivot (K+1)
!=============================
 
        rho(k)=sqrt(piv)
        if(k.eq.n) goto 90
!hr06   piv=0.0d0
        piv=0.0                                                          !hr06
        kpiv = k + 1
        j1 = kpiv
        k2=n + j1
        do 80 j=j1,n
          h=rho(j)-(a(k,j))*(a(k,j))
 
          if(h.lt.0.0000001) then
            write(*,*)
            write(*,*) 'CORRECTION PROCESS ABORTED.'
            write(*,*) 'DIVISION BY ZERO EXPECTED.'
            write(*,*) 'PROBABLY TWO CORRECTORS TOO CLOSE.'
            write(*,10000) ' SUSPECTED CORRECTOR: ',j
            call closeUnits
            stop 777
          endif
 
          rho(j)=h
          g=rho(k2)-(a(k,j))*(b(k))
          rho(k2) = g
!hr06     pivt = g*g/h
          pivt = g**2/h                                                  !hr06
          if(pivt.lt.piv)goto 80
          kpiv=j
          piv=pivt
   80   k2 = k2 + 1
 
! --- calcul des X
   90   x(k)=b(k)/rho(n+k)
        if(k.eq.1)goto 120
        do 110 i=2,k
          kk=k-i+1
          x(kk)=b(kk)
          ki=kk+1
          do 100 j=ki,k
  100     x(kk)=x(kk)-a(kk,j)*x(j)
          x(kk)=x(kk)/rho(n+kk)
  110   continue
  120   continue
 
! --- save residual orbit and inverse sign of corrections (convention!)
        do 130 iii= 1,m
  130   r(iii) = b(iii)
        do 140 iii= 1,k
!hr06  140   x(iii) =-x(iii)
  140   x(iii) =-1.0*x(iii)                                              !hr06
 
! --- calcul du vecteur residuel dans HTRL
!=========================================
 
!     transform orbit R back to "normal space"
        call htrl(a,r,m,n,k,rho)
        call calrms(r,m,rmss(k),ptop(k))
        xiter(k+1) = k
        xrms(k+1) = rmss(k)
        xptp(k+1) = ptop(k)
 
        if(ptop(k).le.ptp)goto 160
        if(rmss(k).le.rms)goto 160
  150 continue
      return
 
! --- correction is already good enough:
!=======================================
 
  160 ptp=ptop(k)
      rms=rmss(k)
10000 format(a,i4)
      end
      subroutine htal(a,m,n,k,beta)
!*********************************************************************
!     Subroutine HTAL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of matrix A
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer j,k,k1,m,n,nc,ncor1,nmon1
      real a,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------
 
      nc=n-k
 
      do 20 j=1,nc
!hr06   h=0.0d0
        h=0.0                                                            !hr06
 
        do 10 k1=k,m
   10   h=h+a(k1,k)*a(k1,k+j)
 
        h=beta*h
        do 20 k1=k,m
   20 a(k1,k+j)=a(k1,k+j)-a(k1,k)*h
 
      end
      subroutine htbl(a,b,m,n,k,beta)
!*********************************************************************
!     Subroutine HTBL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of vector B
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer k,k1,m,n,ncor1,nmon1
      real a,b,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1)
      save
!-----------------------------------------------------------------------
 
!hr06 h=0.0d0
      h=0.0                                                              !hr06
 
      do 10 k1=k,m
   10 h=h+a(k1,k)*b(k1)
 
      h=beta*h
 
      do 20 k1=k,m
   20 b(k1)=b(k1)-a(k1,k)*h
 
      end
      subroutine htrl(a,b,m,n,k,rho)
!*********************************************************************
!     Subroutine HTRL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate residual orbit vector
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,k,kk,kl,kn,lv,m,n,ncor1,nmon1
      real a,b,beta,rho
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),rho(3*ncor1)
      save
!-----------------------------------------------------------------------
 
      do 10 i= 1,k,1
!hr06   b(i)= 0.0d0
        b(i)= 0.0                                                        !hr06
   10 continue
 
      do 20 kk=1,k
        lv=m-k+kk
        kn=n+k-kk+1
        kl=k-kk+1
 
!hr06   beta=-1d0/(rho(kn)*a(kl,kl))
        beta=-1.0/(rho(kn)*a(kl,kl))                                     !hr06
        call htbl(a,b,m,n,kl,beta)
   20 continue
 
      end
      subroutine htul(a,m,n,k,sig,beta)
!*********************************************************************
!     Subroutine HTUL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate vector U
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,k,m,n,ncor1,nmon1
      real a,beta,h,sig
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------
!hr06 sig=0.0d0
      sig=0.0                                                            !hr06
 
      do 10 i=k,m
        sig=sig+a(i,k)* a(i,k)
   10 continue
 
      sig=sqrt(sig)
!     on choisit le signe correct pour SIG:
      h=a(k,k)
!hr06 if(h.lt.0.0d0)sig=-sig
      if(h.lt.0.0)sig=-1.0*sig                                           !hr06
      beta=h + sig
      a(k,k)=beta
!hr06 beta=1d0/(sig*beta)
      beta=1.0/(sig*beta)                                                !hr06
      end
      subroutine calrms(r,m,rms,ptp)
!*********************************************************************
!     Subroutine CALRMS to calculate rms                             *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculates rms and p.to.p value of R(1) .... R(M)
!*********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,imax,imin,m,maxmin
      real ave,ptp,r,rms,xave,xrms
      dimension r(m)
      save
!-----------------------------------------------------------------------
      xave = 0.0
      xrms = 0.0
 
      do 10 i=1,m
        xave = xave + r(i)
!hr06   xrms = xrms + (r(i)*r(i))
        xrms = xrms + r(i)**2                                            !hr06
   10 continue
 
      ave = xave / real(m)
      rms = xrms / real(m)
 
      imax=maxmin(r(1),m,1)
      imin=maxmin(r(1),m,0)
      ptp=r(imax)-r(imin)
      rms=sqrt(rms)
      return
      end
      function maxmin (a,n,m)
!-----------------------------------------------------------------------
!     if M=0, MAXMIN=lowest index of minimum element in A
!     if M=1, MAXMIN=lowest index of maximun element in A
!     if N<1, MAXMIN=1
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,m,maxmin,n
      real a,curent
      dimension a(n)
      save
!-----------------------------------------------------------------------
      maxmin=1
      if (n.lt.1) return
      curent=a(1)
      do 10 i=2,n
        if ((m.eq.0).and.(a(i).ge.curent)) goto 10
        if ((m.eq.1).and.(a(i).le.curent)) goto 10
        curent=a(i)
        maxmin=i
   10 continue
      return
      end
      subroutine ord
!-----------------------------------------------------------------------
!  ORGANISATION OF BLOCKS, NONLINEAR ELEMENTS AND RANDOM NUMBERS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,icext1,icextal1,ihi,ii,ilf,ilfr,inz,iran,ix,izu,j,jra,  &
     &jra3,kanf1,kpz,kzz,kzz1,kzz2,nra1
      double precision extalig1,exterr1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension ilf(nblz),ilfr(nblz),jra(nele,5),iran(nele),inz(nele)
      dimension exterr1(nblz,40),extalig1(nblz,3),icext1(nblz),         &
     &icextal1(nblz)
      save
!-----------------------------------------------------------------------
      do 10 i=1,nblz
        ilf(i)=0
        ilfr(i)=0
   10 continue
      do 20 i=1,nele
        iran(i)=0
        inz(i)=0
        do 20 j=1,5
          jra(i,j)=0
   20 continue
      if(mper.eq.1) goto 40
      do 30 i=2,mper
        do 30 j=1,mbloz
          ii=(i-1)*mbloz+j
          ihi=j
          if(msym(i).lt.0) ihi=mbloz-j+1
          ic(ii)=msym(i)*ic(ihi)
   30 if(ic(ii).lt.-nblo) ic(ii)=-ic(ii)
!--ORGANISATION OF RANDOM NUMBERS
   40 iu=mper*mbloz
      if(niu(1).lt.0) niu(1)=iabs(niu(1))
      if(niu(2).lt.0) niu(2)=iabs(niu(2))
      if(niu(1).eq.0) niu(1)=1
      if(niu(2).eq.0) niu(2)=iu
      if(niu(1).gt.iu) niu(1)=1
      if(niu(2).gt.iu) niu(2)=iu
      izu=0
      nra1=nran
      iorg=iorg-1
      if(iorg.ge.0) then
        if(iorg.eq.0) then !iorg == 0
          do 50 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 50
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 50
            mzu(i)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
            if(izu.gt.nzfz) then
              write(*,*)    "ERROR in ORD: nzfz was too small"
              call prror(-1)
            endif
   50     continue
        else ! iorg.gt.0
          do 70 i=1,iorg
            do 60 j=1,il
              if(bez(j).eq.bezr(1,i)) then
                jra(i,1)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)
     &               call prror(31)
                jra(i,2)=kz(j)
              endif
              if(bez(j).eq.bezr(2,i)) then
                jra(i,3)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)
     &               call prror(31)
                jra(i,4)=kz(j)
              endif
   60       continue
            kzz1=jra(i,2)
            kzz2=jra(i,4)
            if(kzz1.ne.0.and.kzz2.eq.0) then
              jra(i,5)=nra1
              nra1=nra1+mran*3
              if(kzz1.eq.11.and.abs(ek(jra(i,1))).gt.pieni)
     &             nra1=nra1+mran*2*mmul
              if(nra1.gt.nzfz) call prror(32)
            endif
            if(kzz1.eq.11.and.(kzz2.ne.11.and.kzz2.ne.0)) call prror(33)
   70     continue
          do 110 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 110
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 110
            do 80 j=1,iorg
              if(bez(ix).eq.bezr(1,j)) goto 90
   80       continue
            goto 100
   90       jra3=jra(j,3)
            if(jra3.ne.0) then
              mzu(i)=iran(jra3)
              iran(ix)=mzu(i)
            else
              inz(j)=inz(j)+1
              if(inz(j).gt.mran) call prror(34)
              mzu(i)=jra(j,5)
              iran(ix)=mzu(i)
              jra(j,5)=jra(j,5)+3
              if(jra(j,2).eq.11) jra(j,5)=jra(j,5)+2*mmul
            endif
            goto 110
  100       mzu(i)=izu
            iran(ix)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
  110     continue
        endif
      else !iorg < 0 (in case of no ORGA block in fort.3)
        do 115 i=1,iu
          ix=ic(i)
          if(ix.le.nblo) goto 115
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 115
          izu=izu+3
          if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
          if(izu.gt.nran) call prror(30)
          if(izu.gt.nzfz) then
            write(*,*)    "ERROR in ORD: nzfz was too small"
            call prror(-1)
          endif
  115   continue
      endif
 
      ! "GO" was not the first structure element -> Reshuffle the structure
      if(kanf.ne.1) then
        !--Re-saving of the starting point (UMSPEICHERUNG AUF DEN STARTPUNKT)
        kanf1=kanf-1
        do 130 i=1,kanf1
          if(iorg.ge.0) ilfr(i)=mzu(i)
          ilf(i)=ic(i)
          icext1(i)=icext(i)
          icextal1(i)=icextal(i)
          extalig1(i,1)=extalign(i,1)
          extalig1(i,2)=extalign(i,2)
          extalig1(i,3)=extalign(i,3)
          do 120 ii=1,40
            exterr1(i,ii)=exterr(i,ii)
  120     continue
  130   continue
        do 150 i=kanf,iu
          if(iorg.ge.0) mzu(i-kanf1)=mzu(i)
          ic(i-kanf1)=ic(i)
          icext(i-kanf1)=icext(i)
          icextal(i-kanf1)=icextal(i)
          extalign(i-kanf1,1)=extalign(i,1)
          extalign(i-kanf1,2)=extalign(i,2)
          extalign(i-kanf1,3)=extalign(i,3)
          do 140 ii=1,40
            exterr(i-kanf1,ii)=exterr(i,ii)
  140     continue
  150   continue
        do 170 i=1,kanf1
          if(iorg.ge.0) mzu(iu-kanf1+i)=ilfr(i)
          ic(iu-kanf1+i)=ilf(i)
          icext(iu-kanf1+i)=icext1(i)
          icextal(iu-kanf1+i)=icextal1(i)
          extalign(iu-kanf1+i,1)=extalig1(i,1)
          extalign(iu-kanf1+i,2)=extalig1(i,2)
          extalign(iu-kanf1+i,3)=extalig1(i,3)
          do 160 ii=1,40
            exterr(iu-kanf1+i,ii)=exterr1(i,ii)
  160     continue
  170   continue
      endif
 
      izu=0
      do 190 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 190
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 190
        if(icextal(i).ne.0) then
          izu=izu+2
          xrms(ix)=one
          zrms(ix)=one
          zfz(izu)=extalign(i,1)
          izu=izu+1
          zfz(izu)=extalign(i,2)
          tiltc(i)=cos_rn(extalign(i,3)*c1m3)
          tilts(i)=sin_rn(extalign(i,3)*c1m3)
        else
          izu=izu+3
        endif
        if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.icext(i).ne.0) then
          do 180 j=1,mmul
            izu=izu+1
            zfz(izu)=exterr(i,20+j)
            izu=izu+1
            zfz(izu)=exterr(i,j)
  180     continue
        else if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.                 &
     &icext(i).eq.0) then
          izu=izu+2*mmul
        endif
  190 continue
      return
      end
      subroutine phasad(dpp,qwc)
!-----------------------------------------------------------------------
!  ADDITIONAL ADJUSTMENT OF THE X-PHASEADVANCE BETWEEN 2 POSITIONS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ikpv,im,ium,ix,izu,j,jj,jk,jm,k,kpv,kpz,kzz,l,l1,ll,nmz,&
     &dj
      double precision aa,alfa,bb,benkr,beta,ci,cikve,cr,crkve,crkveuk, &
     &dphi,dpp,dppi,dpr,dyy1,dyy2,ekk,phi,phibf,pie,puf,qu,qv,qw,qwc,   &
     &qxsa,qxse,r0,r0a,t,xl,xs,zl,zs,quz,qvz
      double precision dyy11,qu1,tiltck,tiltsk
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
!GRD
      qxsa = zero
      qxse = zero
!GRD
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      qwc(3)=zero
      do 40 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   40 continue
      pie=two*pi
      ikpv=0
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
      do 50 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
   50 t(1,ll)=clop(l)
      do 60 i=1,4
        do 60 j=1,4
          t(i+1,j)=ta(j,i)
   60 t(i+1,j)=ta(j,i)
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 450 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 140
        jj=0
        dj=1
        if(ix.gt.0) goto 70
        ix=-ix
        jj=mel(ix)+1
        dj=-1
   70   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 130 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 100
          if(ithick.eq.0.and.kz(jk).ne.0) goto 450
!--PURE DRIFTLENGTH
          do 80 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do 80 i=1,ium
   80     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 90 l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
!hr06       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr06
   90     phi(l)=phi(l)+dphi/pie
          goto 130
!--MAGNETELEMENT
  100     continue
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr06         t(i,ll-1)=puf*a(jk,l,1)+t(i,ll)*a(jk,l,2)+dpr(i)*a(jk,l,5)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
!hr06         t(i,ll)=puf*a(jk,l,3)+t(i,ll)*a(jk,l,4)+dpr(i)*a(jk,l,6)
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr06         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr06
            endif
!hr06       if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
  130   continue
        goto 450
!--NL-INSERTION
  140   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 450
        kzz=kz(ix)
        kpv=kpa(ix)
        if(kpv.ne.1) goto 150
        qxsa=phi(1)
  150   if(kpv.ne.2.or.ikpv.eq.1) goto 160
        qxse=phi(1)
        ikpv=1
  160   continue
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr03         t(i,ll-1)=puf*rrtr(imtr(ix),ll-1,ll-1)+                   &
!hr03&t(i,ll)*rrtr(imtr(ix),ll-1,ll)+                                   &
!hr03&dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
!hr03         t(i,ll)=puf*rrtr(imtr(ix),ll,ll-1)+                       &
!hr03&t(i,ll)*rrtr(imtr(ix),ll,ll)+                                     &
!hr03&dpr(i)*rrtr(imtr(ix),ll,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
!hr03       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
!hr03       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr08         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr08
            endif
!hr03       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
            phi(l)=phi(l)+dphi/pie
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 450
! JBG RF CC Multipoles to 450
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 450
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
!hr02   zl=-(t(1,1)-xs)*tilts(k)+(t(1,3)-zs)*tiltc(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
        if(kzz.lt.0) goto 310
        goto(170,180,190,200,210,220,230,240,250,260,270,450,450,450,   &
     &      450,450,450,450,450,450,450,450,450,265,266,450,450,450),kzz
        goto 450
!--HORIZONTAL DIPOLE
  170   ekk=ekk*c1e3
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
        goto 420
!--NORMAL QUADRUPOLE
  180   continue
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr08   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr08
        goto 420
!--NORMAL SEXTUPOLE
  190   ekk=ekk*c1m3
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*crkve+tiltsk*cikve)
        qu=(ekk*two)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qv=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL OCTUPOLE
  200   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(three*ekk)*(tiltck*crkve+tiltsk*cikve)                       !hr02
!hr02   qv=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL DECAPOLE
  210   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(four*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
!hr02   qv=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL DODECAPOLE
  220   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL 14-POLE
  230   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL 16-POLE
  240   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=7*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL 18-POLE
  250   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=8*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--NORMAL 20-POLE
  260   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=9*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr02   dyy2=ekk*(-tiltc(k)*cikve+tilts(k)*crkve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
        goto 420
!--DIPEDGE ELEMENT
  265   continue
!hr02   dyy1=(ed(IX)*tiltc(k)*crkve-ek(IX)*tilts(k)*cikve)/(one+dpp)
        dyy1=((ed(IX)*tiltc(k))*crkve-(ek(IX)*tilts(k))*cikve)/(one+dpp) !hr02
!hr02   dyy2=(ek(IX)*tiltc(k)*cikve+ed(IX)*tilts(k)*crkve)/(one+dpp)
        dyy2=((ek(IX)*tiltc(k))*cikve+(ed(IX)*tilts(k))*crkve)/(one+dpp) !hr02
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
        goto 420
!--solenoid
  266   continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_rn(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_rn(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
        qu=ed(IX)
        qv=ek(IX)
        goto 420
  270   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)+(qu*xl-dppi*dpp)*tilts(k)                     &
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            do 280 i=2,ium
!hr08         t(i,2)=t(i,2)+qu*t(i,1)*tiltc(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
!hr08         t(i,4)=t(i,4)+qu*t(i,3)*tilts(k)
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
  280       continue
          else
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tiltc(k)                             &
!hr03&+dppi*(one-tiltc(k))
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)-dppi*dpp*tilts(k)                             &
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)+(qu*zl-dppi*dpp)*tilts(k)                     &
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+(-qu*zl+dppi*dpp)*tiltc(k)                    &
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
            do 290 i=2,ium
!hr03         t(i,2)=t(i,2)+qu*t(i,1)*tilts(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
!hr03         t(i,4)=t(i,4)-qu*t(i,3)*tiltc(k)
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
  290       continue
          else
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tilts(k)                             &
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+dppi*dpp*tiltc(k)                             &
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
          endif
        endif
        if(abs(r0).le.pieni) goto 450
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 450
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 300 l=1,nmz
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
  300   continue
        if(nmz.ge.2) then
          qu=bb(2)
!hr03     qv=-aa(2)
          qv=-1d0*aa(2)
          dyy1=bb(1)+bb(2)*crkve+aa(2)*cikve
          dyy2=aa(1)-bb(2)*cikve+aa(2)*crkve
          do 305 l=3,nmz
            l1=l-1
!hr03       qu=qu+l1*(bb(l)*crkve+aa(l)*cikve)
            qu=qu+dble(l1)*(bb(l)*crkve+aa(l)*cikve)                     !hr03
!hr03       qv=qv+l1*(bb(l)*cikve-aa(l)*crkve)
            qv=qv+dble(l1)*(bb(l)*cikve-aa(l)*crkve)                     !hr03
            crkveuk=crkve*xl-cikve*zl
            cikve=crkve*zl+cikve*xl
            crkve=crkveuk
!hr03       dyy1=dyy1+bb(l)*crkve+aa(l)*cikve
            dyy1=(dyy1+bb(l)*crkve)+aa(l)*cikve                          !hr03
!hr03       dyy2=dyy2-bb(l)*cikve+aa(l)*crkve
            dyy2=(dyy2-bb(l)*cikve)+aa(l)*crkve                          !hr03
  305     continue
        else
          qu=zero
          qv=zero
          dyy1=bb(1)
          dyy2=aa(1)
        endif
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
        izu=izu+2*mmul-2*nmz
        goto 420
!--SKEW ELEMENTS
  310   kzz=-kzz
        goto(320,330,340,350,360,370,380,390,400,410),kzz
        goto 450
!--VERTICAL DIPOLE
  320   ekk=ekk*c1e3
!hr08   dyy1=-ekk*tilts(k)
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr08
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
        goto 420
!--SKEW QUADRUPOLE
  330   continue
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        goto 420
!--SKEW SEXTUPOLE
  340   ekk=ekk*c1m3
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qu=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-ekk*two*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*ekk)*two)*(tiltck*crkve+tiltsk*cikve)                  !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW OCTUPOLE
  350   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
!hr02   qv=-three*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*three)*ekk)*(tiltck*crkve+tiltsk*cikve)                !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW DECAPOLE
  360   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
!hr02   qv=-four*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*four)*ekk)*(tiltck*crkve+tiltsk*cikve)                 !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW DODECAPOLE
  370   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-5*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW 14-POLE
  380   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-6*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW 16-POLE
  390   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-7d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW 18-POLE
  400   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-8d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        goto 420
!--SKEW 20-POLE
  410   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-9d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
  420   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 430 i=2,ium
          if(kzz.eq.24) then
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*quz-qvz*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
!hr02       crkve=t(i,2)-t(i,1)*qu*qv
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
!hr02       cikve=t(i,4)-t(i,3)*qu*qv
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
!hr02       t(i,2)=crkve*cos(qv)+cikve*sin(qv)
!hr02       t(i,4)=-crkve*sin(qv)+cikve*cos(qv)
!hr02       crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
!hr02       cikve=-t(i,1)*sin(qv)+t(i,3)*cos(qv)
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
          else
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*qu-qv*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  430   continue
        do 440 l=1,2
          ll=2*l
!hr06  440   alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
  440   alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))       !hr06
  450 continue
      qwc(1)=phi(1)
      qwc(2)=phi(2)
      if(qxse.ge.qxsa) then
        qwc(3)=qxse-qxsa
      else
!hr06   qwc(3)=phi(1)+qxse-qxsa
        qwc(3)=(phi(1)+qxse)-qxsa                                        !hr06
      endif
!-----------------------------------------------------------------------
      return
      end
      subroutine qmod0
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES PLUS AN ADDITIONAL ADJUSTMENT OF A
!  X-PHASEADVANCE BETWEEN 2 POSITIONS IN THE MACHINE
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ierr,ii,iq1,iq2,iq3,iql,j,l,n,nite
      double precision a11,a12,a13,a21,a22,a23,a31,a32,a33,aa,aa1,bb,   &
     &dpp,dq1,dq2,dq3,qwc,qx,qz,sens,sm0,sqx,sqxh,sqz
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension sens(3,5),aa(3,3),bb(3),qx(3),qz(3),sm0(3),qwc(3)
      dimension aa1(2,2)
      save
!-----------------------------------------------------------------------
      do 10 i=1,3
        bb(i)=zero
        qx(i)=zero
        qz(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        do 10 j=1,3
          aa(i,j)=zero
   10 continue
      do 20 i=1,3
        do 20 j=1,5
          sens(i,j)=zero
   20 continue
      do 30 i=1,2
        do 30 j=1,2
          aa1(i,j)=zero
   30 continue
      write(*,10010)
      sqx=zero
      sqz=zero
      sqxh=zero
      dpp=zero
      iq1=iq(1)
      iq2=iq(2)
      if(kz(iq1).ne.2.or.kz(iq2).ne.2) call prror(8)
      if (abs(el(iq1)).le.pieni.or.abs(el(iq2)).le.pieni) then
        sm0(1)=ed(iq1)
        sm0(2)=ed(iq2)
      else
        sm0(1)=ek(iq1)
        sm0(2)=ek(iq2)
      endif
      if(kp(iq1).eq.5) call combel(iq1)
      if(kp(iq2).eq.5) call combel(iq2)
      sens(1,1)=qw0(1)
      sens(2,1)=qw0(2)
      if(abs(qw0(3)).gt.pieni) then
        iq3=iq(3)
        if(kz(iq3).ne.2) call prror(8)
        if (abs(el(iq3)).le.pieni) then
          sm0(3)=ed(iq3)
        else
          sm0(3)=ek(iq3)
        endif
        if(kp(iq3).eq.5) call combel(iq3)
        nite=3
      else
        nite=2
      endif
      call clorb(dpp)
      if(ierro.gt.0) call prror(9)
      call phasad(dpp,qwc)
      sens(1,5)=qwc(1)
      sens(2,5)=qwc(2)
      if(nite.eq.3) then
        sens(3,1)=qw0(3)
        sens(3,5)=qwc(3)
        write(*,10100)
        write(*,10120) qwc,qw0
      else
        write(*,10110)
        write(*,10130) qwc(1),qwc(2),qw0(1),qw0(2)
      endif
      do 60 ii=1,itqv
        do 40 n=1,nite
          iql=iq(n)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)+dkq
          else
            ek(iql)=ek(iql)+dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
          call clorb(dpp)
          if(ierro.gt.0) call prror(9)
          call phasad(dpp,qwc)
          sens(1,n+1)=qwc(1)
          sens(2,n+1)=qwc(2)
          if(nite.eq.3) then
            sens(3,n+1)=qwc(3)
            write(*,10140) ii,n,qwc
          else
            write(*,10150) ii,n,qwc(1),qwc(2)
          endif
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-dkq
          else
            ek(iql)=ek(iql)-dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
   40   continue
!--Q-VALUE ADJUSTMENT
        aa1(1,1)=(sens(1,2)-sens(1,5))/dkq
        aa1(1,2)=(sens(2,2)-sens(2,5))/dkq
        aa1(2,1)=(sens(1,3)-sens(1,5))/dkq
        aa1(2,2)=(sens(2,3)-sens(2,5))/dkq
        a11=aa1(1,1)
        a12=aa1(1,2)
        a21=aa1(2,1)
        a22=aa1(2,2)
        bb(1)=sens(1,5)-sens(1,1)
        bb(2)=sens(2,5)-sens(2,1)
        sqx=sqx+abs(bb(1))
        sqz=sqz+abs(bb(2))
        if(nite.eq.3) then
          aa(1,1)=a11
          aa(1,2)=a12
          aa(1,3)=(sens(3,2)-sens(3,5))/dkq
          aa(2,1)=a21
          aa(2,2)=a22
          aa(2,3)=(sens(3,3)-sens(3,5))/dkq
          aa(3,1)=(sens(1,4)-sens(1,5))/dkq
          aa(3,2)=(sens(2,4)-sens(2,5))/dkq
          aa(3,3)=(sens(3,4)-sens(3,5))/dkq
          a13=aa(1,3)
          a23=aa(2,3)
          a31=aa(3,1)
          a32=aa(3,2)
          a33=aa(3,3)
          bb(3)=sens(3,5)-sens(3,1)
          sqxh=sqxh+abs(bb(3))
          call loesd(aa,bb,nite,nite,ierr)
        else
          call loesd(aa1,bb,nite,nite,ierr)
        endif
        if(ierr.eq.1) call prror(35)
        do 50 l=1,nite
          iql=iq(l)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-bb(l)
          else
            ek(iql)=ek(iql)-bb(l)
          endif
          if(kp(iql).eq.5) call combel(iql)
   50   continue
        call clorb(dpp)
        if(ierro.gt.0) call prror(9)
        call phasad(dpp,qwc)
        sens(1,5)=qwc(1)
        sens(2,5)=qwc(2)
        if(nite.eq.3) then
          sens(3,5)=qwc(3)
          write(*,10020) qw0(1),qwc(1),qw0(2),qwc(2),qw0(3),qwc(3)
          if (abs(el(iq1)).le.pieni) then
            write(*,10040) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez   &
     &(iq2),sm0(3),ed(iq3),bez(iq3)
          else
            write(*,10040) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez   &
     &(iq2),sm0(3),ek(iq3),bez(iq3)
          endif
          write(*,10080) sqx,sqz,sqxh
          write(*,10060) a11,a12,a13,a21,a22,a23,a31,a32,a33
        else
          write(*,10030) qw0(1),qwc(1),qw0(2),qwc(2)
          if (abs(el(iq1)).le.pieni) then
            write(*,10050) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez   &
     &(iq2)
          else
            write(*,10050) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez   &
     &(iq2)
          endif
          write(*,10090) sqx,sqz
          write(*,10070) a11,a12,a21,a22
        endif
        if (abs(el(iq(1))).le.pieni) then
          sm0(1)=ed(iq(1))
          sm0(2)=ed(iq(2))
        else
          sm0(1)=ek(iq(1))
          sm0(2)=ek(iq(2))
        endif
        dq1=abs(qwc(1)-qw0(1))
        dq2=abs(qwc(2)-qw0(2))
        if(nite.eq.3) then
          if (abs(el(iq(3))).le.pieni) then
            sm0(3)=ed(iq(3))
          else
            sm0(3)=ek(iq(3))
          endif
          dq3=abs(qwc(3)-qw0(3))
          if(dq1.lt.dqq.and.dq2.lt.dqq.and.dq3.lt.dqq) return
        else
          if(dq1.lt.dqq.and.dq2.lt.dqq) return
        endif
   60 continue
      write(*,10000) itqv
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'TUNE ADJUSTMENT'/ t10,                             &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.     AFTER CORRECTION'/ t10,       &
     &'HORIZONTAL'     ,17x,g16.10,2x,g16.10/ t10,                      &
     &'VERTICAL'       ,19x,g16.10,2x,g16.10/ t10,                      &
     &'PART-HORIZONTAL',12x,g16.10,2x,g16.10/)
10030 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.      AFTER CORRECTION'/ t10,      &
     &'HORIZONTAL'     ,17x,g16.10,2x,g16.10/ t10,                      &
     &'VERTICAL'       ,19x,g16.10,2x,g16.10/)
10060 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY',14x,   &
     &'D-QXH'/29x,'QF   ',d15.8,3x,d15.8,3x,d15.8/29x,                  &
     &'QD   ',d15.8,3x,d15.8,3x,d15.8/29x,                              &
     &'QF2  ',d15.8,3x,d15.8,3x,d15.8//131('-')//)
10070 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY', /29x, &
     &'QF   ',d15.8,3x,d15.8/29x,'QD   ',d15.8,3x,d15.8 //131('-')//)
10080 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7,  &
     &'   QXH =',f10.7)
10090 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7)
10100 format(t5,'---- QMOD FOR SPLIT-Q-VALUES ENTRY ---- ',             &
     &'(ZERO MOMENTUM-DEVIATION)')
10110 format(t5,'---- QMOD ENTRY ---- (ZERO MOMENTUM-DEVIATION)')
10120 format(t10,'START-QX-QY-QXH',3f12.7,' END-QX-QY-QXH',3f12.7)
10130 format(t10,'START-QX-QY',2f12.7,' END-QX-QY',2f12.7)
10140 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY-QXH',3f12.7)
10150 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY',2f12.7)
10040 format(t10,'QUADRU.STRENGTHS',7x,g16.10,2x,g16.10,'   TYP     ',  &
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
10050 format(t10,'QUADRU.STRENGTHS',7x,g16.10,2x,g16.10,'   TYP     ',  &
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
      end
      subroutine qmodda(mm,qwc)
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES VIA DA
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,intwq,ix,mm,ncorr,ncorruo,ncrr,nd,nd2,ndh
      double precision cor,coro,dq1,dq2,dps0,edcor1,edcor2,qwc
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      double precision aml6,edcor
      common/sixdim/aml6(6,6),edcor(2)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      dimension intwq(3),qwc(3)
      save
!-----------------------------------------------------------------------
      ncorruo=ncorru
      ncorru=1
      nd2=2*mm
      ndh=nd2+2
      intwq(1)=int(qwc(1))
      intwq(2)=int(qwc(2))
      intwq(3)=0
      dq1=zero
      dq2=zero
      if(iqmod6.eq.1) then
        if(el(iq(1)).le.pieni) then
          edcor(1)=ed(iq(1))
        else
          edcor(1)=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          edcor(2)=ed(iq(2))
        else
          edcor(2)=ek(iq(2))
        endif
        edcor1=edcor(1)
        edcor2=edcor(2)
        cor=0d0
        coro=1d38
      endif
      do ncorr=1,itqv+1
        if(nbeam.ge.1) then
          nd=mm
              dps0=dps(1)
              dps(1)=zero
              iqmodc=4
              call mydaini(1,2,nd2,nd,nd2,1)
              ilinc=2
              call mydaini(2,2,nd2,nd,nd2,1)
              dps(1)=dps0
        endif
        if(iqmod6.eq.1) write(*,10080) nd2
        if(iqmod6.ne.1) write(*,10090) nd2
        if(mm.eq.2) then
          write(*,10010) clo(1),clop(1)
          write(*,10010) clo(2),clop(2)
        elseif(mm.eq.3) then
          write(*,10010) clo6(1),clop6(1)
          write(*,10010) clo6(2),clop6(2)
          write(*,10010) clo6(3),clop6(3)
        endif
        iqmodc=2
        call mydaini(1,1,nd2,mm,nd2,1)
        if(iqmod6.eq.1) then
          write(*,10000) nd2
          iqmodc=1
          call mydaini(2,3,ndh,mm,nd2,1)
          do i=1,mm
!hr06       qwc(i)=intwq(i)+corr(1,i)
            qwc(i)=dble(intwq(i))+corr(1,i)                              !hr06
          enddo
          dq1=qwc(1)-qw0(1)
          dq2=qwc(2)-qw0(2)
!hr06     if(ncorr.eq.1) cor=sqrt(dq1*dq1+dq2*dq2)
          if(ncorr.eq.1) cor=sqrt(dq1**2+dq2**2)                         !hr06
          if(abs(dq1).gt.dqq.or.abs(dq2).gt.dqq) then
!hr06       cor=sqrt(dq1*dq1+dq2*dq2)
            cor=sqrt(dq1**2+dq2**2)                                      !hr06
            if(ncorr.eq.1.or.cor.lt.coro) then
              coro=cor
              if(el(iq(1)).le.pieni) then
!hr06           ed(iq(1))=ed(iq(1))-corr(2,1)*dq1-corr(2,2)*dq2
                ed(iq(1))=(ed(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              else
!hr06           ek(iq(1))=ek(iq(1))-corr(2,1)*dq1-corr(2,2)*dq2
                ek(iq(1))=(ek(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              endif
              if(el(iq(2)).le.pieni) then
!hr06           ed(iq(2))=ed(iq(2))-corr(3,1)*dq1-corr(3,2)*dq2
                ed(iq(2))=(ed(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              else
!hr06           ek(iq(2))=ek(iq(2))-corr(3,1)*dq1-corr(3,2)*dq2
                ek(iq(2))=(ek(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) then
                  ix=ix-nblo
                  if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                    smi(ncrr)=ed(iq(1))*ratioe(ix)+smizf(ncrr)
                  else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                    smi(ncrr)=ed(iq(2))*ratioe(ix)+smizf(ncrr)
                  endif
                endif
              enddo
              if(el(iq(1)).le.pieni) then
                edcor(1)=ed(iq(1))
              else
                edcor(1)=ek(iq(1))
              endif
              if(el(iq(2)).le.pieni) then
                edcor(2)=ed(iq(2))
              else
                edcor(2)=ek(iq(2))
              endif
              if(ncorr.eq.1) then
                write(*,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1, &
     &cor
              else
                write(*,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1, &
     &cor
              endif
              if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
                write(*,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,      &
     &ed(iq(2)),bez(iq(2))
              elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
                write(*,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,      &
     &ek(iq(2)),bez(iq(2))
              elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
                write(*,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,      &
     &ed(iq(2)),bez(iq(2))
              else
                write(*,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,      &
     &ek(iq(2)),bez(iq(2))
              endif
            else
              write(*,10050) nd2,ncorr-1
              goto 1
            endif
          else
            write(*,10060) nd2,ncorr-1
            goto 1
          endif
        else
          iqmodc=3
          call mydaini(2,2,nd2,mm,nd2,1)
          do i=1,mm
!hr06       qwc(i)=intwq(i)+wxys(i)
            qwc(i)=dble(intwq(i))+wxys(i)                                !hr06
          enddo
          goto 1
        endif
      enddo
 1    continue
      if(iqmod6.eq.1) then
        do ncrr=1,iu
          ix=ic(ncrr)
          if(ix.le.nblo) then
            if(iratioe(ix).eq.iq(1)) ek(ix)=ek(iq(1))*ratioe(ix)
            if(iratioe(ix).eq.iq(2)) ek(ix)=ek(iq(2))*ratioe(ix)
          endif
        enddo
        iqmodc=3
        call mydaini(2,2,nd2,mm,nd2,1)
        do i=1,mm
!hr06     qwc(i)=intwq(i)+wxys(i)
          qwc(i)=dble(intwq(i))+wxys(i)                                  !hr06
        enddo
        if(ncorr.eq.itqv+1) write(*,10070) nd2,itqv
        if(ncorr.eq.1) then
          write(*,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        else
          write(*,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        endif
        if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
          write(*,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),  &
     &bez(iq(2))
        elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
          write(*,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),  &
     &bez(iq(2))
        elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
          write(*,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),  &
     &bez(iq(2))
        else
          write(*,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),  &
     &bez(iq(2))
        endif
      endif
      ncorru=ncorruo
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING ',i1,'D DA TUNE-VARIATION')
10010 format(1x,f47.33/1x,f47.33)
10020 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       BEFORE CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G20.14,G20.14/ t10,                         &
     &'VERTICAL'       ,17x,G20.14,G20.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10030 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       AFTER CORRECTION'/ t10,     &
     &'HORIZONTAL'     ,15x,G20.14,G20.14/ t10,                         &
     &'VERTICAL'       ,17x,G20.14,G20.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10040 format(t10,'QUADRUPOLE STRENGTH',6x,g16.10,4x,g16.10,'   TYP     '&
     &,a16/t10,                  25x,g16.10,4x,g16.10,'           ',    &
     &a16)
10050 format(/t5,'---- NO IMPROVEMENT OF ',i1,'D DA TUNE-VARIATION ',   &
     &'IN ITERATION: ',i4/)
10060 format(/t10,i1,'D DA TUNE-VARIATION SUCCESSFUL IN ITERATION: ',   &
     &i4/)
10070 format(/t10,i1,'D DA TUNE-VARIATION'/ t10,                        &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10080 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA')
10090 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA (NO ',    &
     &'TUNE ADJUSTEMENT)')
      end
      subroutine umlauf(dpp,ium,ierr)
!-----------------------------------------------------------------------
!     ONE TURN-TRANSFORMATION (INCLUDING QUADRUPOLE CONTRIBUTIONS)
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ierr,im,ium,ix,izu,j,k,kpz,kx,kzz,l,ll,l1,nmz
      double precision aa,bb,benkr,ci,cikve,cr,crkve,crkveuk,dpp,dpr,   &
     &dyy1,dyy2,ekk,puf,qu,qv,quz,qvz,r0,r0a,xl,xs,zl,zs
      double precision dyy11,qu1,tiltck,tiltsk
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      do 10 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   10 continue
      do 20 i=1,5
        dpr(i)=zero
   20 continue
      ierr=0
      dpr(1)=dpp*c1e3
      izu=0
      do 350 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 60
        if(ix.le.0) goto 40
        do 30 j=1,ium
          do 30 kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
!hr06         x(j,kx)=bl1(ix,kx,1)*puf+bl1(ix,kx,2)*y(j,kx)+dpr(j)*bl1  &
!hr06&(ix,kx,5)
             x(j,kx)=(bl1(ix,kx,1)*puf+bl1(ix,kx,2)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,5)                                                          !hr06
!hr06         y(j,kx)=bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx)+dpr(j)*bl1  &
!hr06         y(j,kx)=bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx)+dpr(j)*bl1  &
!hr06&(ix,kx,6)
             y(j,kx)=(bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl1(ix,kx,2)*y(j,kx)
            endif
   30   continue
        goto 350
   40   ix=-ix
        do 50 j=1,ium
          do 50 kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
!hr06         x(j,kx)=bl2(ix,kx,1)*puf+bl2(ix,kx,2)*y(j,kx)+dpr(j)*bl2  &
!hr06&(ix,kx,5)
             x(j,kx)=(bl2(ix,kx,1)*puf+bl2(ix,kx,2)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,5)                                                          !hr06
!hr06         y(j,kx)=bl2(ix,kx,3)*puf+bl2(ix,kx,4)*y(j,kx)+dpr(j)*bl2  &
!hr06&(ix,kx,6)
             y(j,kx)=(bl2(ix,kx,3)*puf+bl2(ix,kx,4)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl2(ix,kx,2)*y(j,kx)
            endif
   50   continue
        goto 350
   60   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 350
        kzz=kz(ix)
        if(abs(x(1,1)).lt.aper(1).and.abs(x(1,2)).lt.aper(2)) goto 70
        ierr=1
        call prror(101)
        return
 70     continue
        if(kzz.eq.22) then
          do j=1,ium
            do kx=1,2
              ll=kx*2
              puf=x(j,kx)
!hr03         x(j,kx)=cotr(imtr(ix),ll-1)+rrtr(imtr(ix),ll-1,ll-1)*puf+ &
!hr03&rrtr(imtr(ix),ll-1,ll)*y(j,kx)+dpr(j)*                            &
!hr03&rrtr(imtr(ix),ll-1,6)
           x(j,kx)=((cotr(imtr(ix),ll-1)+rrtr(imtr(ix),ll-1,ll-1)*puf)+ &!hr03
     &rrtr(imtr(ix),ll-1,ll)*y(j,kx))+dpr(j)*                           &!hr03
     &rrtr(imtr(ix),ll-1,6)                                              !hr03
!hr03         y(j,kx)=cotr(imtr(ix),ll)+rrtr(imtr(ix),ll,ll-1)*puf+     &
!hr03&rrtr(imtr(ix),ll,ll)*y(j,kx)+dpr(j)*                              &
!hr03&rrtr(imtr(ix),ll,6)
           y(j,kx)=((cotr(imtr(ix),ll)+rrtr(imtr(ix),ll,ll-1)*puf)+     &!hr03
     &rrtr(imtr(ix),ll,ll)*y(j,kx))+dpr(j)*                             &!hr03
     &rrtr(imtr(ix),ll,6)                                                !hr03
            enddo
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 350
! JBG RF CC Multipoles to 350
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 350
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(x(1,1)-xs)*tiltc(k)+(x(1,2)-zs)*tilts(k)
!hr02   zl=-(x(1,1)-xs)*tilts(k)+(x(1,2)-zs)*tiltc(k)
        zl=(x(1,2)-zs)*tiltc(k)-(x(1,1)-xs)*tilts(k)                     !hr02
        crkve=xl
        cikve=zl
        if(kzz.lt.0) goto 220
        goto(80,90,100,110,120,130,140,150,160,170,180,350,350,350,     &
     &       350,350,350,350,350,350,350,350,350,175,176,350,350,350),  &
     &kzz
        goto 350
!--HORIZONTAL DIPOLE
   80   ekk=ekk*c1e3
        y(1,1)=y(1,1)+ekk*tiltc(k)
        y(1,2)=y(1,2)+ekk*tilts(k)
        goto 350
!--NORMAL QUADRUPOLE
   90   continue
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr08   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr08
        goto 330
!--NORMAL SEXTUPOLE
  100   ekk=ekk*c1m3
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*crkve+tiltsk*cikve)
        qu=(ekk*two)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qv=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL OCTUPOLE
  110   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(three*ekk)*(tiltck*crkve+tiltsk*cikve)                       !hr02
!hr02   qv=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DECAPOLE
  120   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(four*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
!hr02   qv=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DODECAPOLE
  130   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 14-POLE
  140   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 16-POLE
  150   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=7*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 18-POLE
  160   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=8*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 20-POLE
  170   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*crkve+tiltsk*cikve)
        qu=(9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
!hr02   qv=9*ekk*(tiltck*cikve-tiltsk*crkve)
        qv=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*crkve
!hr08   dyy2=-ekk*cikve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--DIPEDGE ELEMENT
  175   continue
!hr02   dyy1=ed(IX)*crkve/(one+dpp)
        dyy1=(ed(IX)*crkve)/(one+dpp)                                    !hr02
!hr02   dyy2=ek(IX)*cikve/(one+dpp)
        dyy2=(ek(IX)*cikve)/(one+dpp)                                    !hr02
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
         goto 330
!--solenoid
  176   continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_rn(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_rn(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
        if(ium.eq.1) goto 350
        qu=ed(IX)
        qv=ek(IX)
         goto 330
  180   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       y(1,1)=y(1,1)+(qu*xl-dpp*c1e3*dki(ix,1)                     &
!hr03&/(one+dpp))*tiltc(k)                                              &
!hr03&+c1e3*dki(ix,1)/(one+dpp)*(one-tiltc(k))
            y(1,1)=(y(1,1)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tiltc(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
!hr03       y(1,2)=y(1,2)+(qu*xl-dpp*c1e3*dki(ix,1)                     &
!hr03&/(one+dpp))*tilts(k)                                              &
!hr03&+c1e3*dki(ix,1)/(one+dpp)*tilts(k)
            y(1,2)=(y(1,2)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
            do 190 j=2,ium
!hr03         y(j,1)=y(j,1)+qu*x(j,1)*tiltc(k)
              y(j,1)=y(j,1)+(qu*x(j,1))*tiltc(k)                         !hr03
!hr03         y(j,2)=y(j,2)+qu*x(j,2)*tilts(k)
              y(j,2)=y(j,2)+(qu*x(j,2))*tilts(k)                         !hr03
  190       continue
          else
!hr03       y(1,1)=y(1,1)-dki(ix,1)*dpp/(one+dpp)*c1e3*tiltc(k)         &
!hr03&+c1e3*dki(ix,1)/(one+dpp)*(one-tiltc(k))
            y(1,1)=(y(1,1)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
!hr03       y(1,2)=y(1,2)-dki(ix,1)*dpp/(one+dpp)*c1e3*tilts(k)         &
!hr03&+c1e3*dki(ix,1)/(one+dpp)*tilts(k)
            y(1,2)=(y(1,2)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       y(1,1)=y(1,1)+(qu*zl-dpp*c1e3*dki(ix,2)                     &
!hr03&/(one+dpp))*tilts(k)                                              &
!hr03&+c1e3*dki(ix,2)/(one+dpp)*tilts(k)
            y(1,1)=(y(1,1)+(qu*zl-((dpp*c1e3)*dki(ix,2))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,2))/(one+dpp))*tilts(k)                             !hr03
!hr03       y(1,2)=y(1,2)+(-qu*zl+dpp*c1e3*dki(ix,2)                    &
!hr03&/(one+dpp))*tiltc(k)                                              &
!hr03&-c1e3*dki(ix,2)/(one+dpp)*(one-tiltc(k))
            y(1,2)=(y(1,2)+(((dpp*c1e3)*dki(ix,2))                      &!hr03
     &/(one+dpp)-qu*zl)*tiltc(k))                                       &!hr03
     &-((c1e3*dki(ix,2))/(one+dpp))*(one-tiltc(k))                       !hr03
            do 200 j=2,ium
!hr03         y(j,1)=y(j,1)+qu*x(j,1)*tilts(k)
              y(j,1)=y(j,1)+(qu*x(j,1))*tilts(k)                         !hr03
!hr03         y(j,2)=y(j,2)-qu*x(j,2)*tiltc(k)
              y(j,2)=y(j,2)-(qu*x(j,2))*tiltc(k)                         !hr03
  200       continue
          else
!hr03       y(1,1)=y(1,1)-dki(ix,2)*dpp/(one+dpp)*c1e3*tilts(k)         &
!hr03&+dki(ix,2)/(one+dpp)*c1e3*tilts(k)
            y(1,1)=(y(1,1)-(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((dki(ix,2)/(one+dpp))*c1e3)*tilts(k)                             !hr03
!hr03       y(1,2)=y(1,2)+dki(ix,2)*dpp/(one+dpp)*c1e3*tiltc(k)         &
!hr03&-dki(ix,2)/(one+dpp)*c1e3*(one-tiltc(k))
            y(1,2)=(y(1,2)+(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &-((dki(ix,2)/(one+dpp))*c1e3)*(one-tiltc(k))                       !hr03
          endif
        endif
        if(abs(r0).le.pieni) goto 350
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 350
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 210 l=1,nmz
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
  210   continue
        if(nmz.ge.2) then
          qu=bb(2)
!hr03     qv=-aa(2)
          qv=-1d0*aa(2)
          dyy1=bb(1)+bb(2)*crkve+aa(2)*cikve
          dyy2=aa(1)-bb(2)*cikve+aa(2)*crkve
          do 215 l=3,nmz
            l1=l-1
!hr03       qu=qu+l1*(bb(l)*crkve+aa(l)*cikve)
            qu=qu+dble(l1)*(bb(l)*crkve+aa(l)*cikve)                     !hr03
!hr03       qv=qv+l1*(bb(l)*cikve-aa(l)*crkve)
            qv=qv+dble(l1)*(bb(l)*cikve-aa(l)*crkve)                     !hr03
            crkveuk=crkve*xl-cikve*zl
            cikve=crkve*zl+cikve*xl
            crkve=crkveuk
!hr03       dyy1=dyy1+bb(l)*crkve+aa(l)*cikve
            dyy1=(dyy1+bb(l)*crkve)+aa(l)*cikve                          !hr03
!hr03       dyy2=dyy2-bb(l)*cikve+aa(l)*crkve
            dyy2=(dyy2-bb(l)*cikve)+aa(l)*crkve                          !hr03
  215     continue
        else
          qu=zero
          qv=zero
          dyy1=bb(1)
          dyy2=aa(1)
        endif
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
        izu=izu+2*mmul-2*nmz
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
        if(ium.eq.1) goto 350
        goto 330
!--SKEW ELEMENTS
  220   kzz=-kzz
        goto(230,240,250,260,270,280,290,300,310,320),kzz
        goto 350
!--VERTICAL DIPOLE
  230   ekk=ekk*c1e3
        y(1,1)=y(1,1)-ekk*tilts(k)
        y(1,2)=y(1,2)+ekk*tiltc(k)
        goto 350
!--SKEW QUADRUPOLE
  240   continue
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        goto 330
!--SKEW SEXTUPOLE
  250   ekk=ekk*c1m3
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*cikve-tiltsk*crkve)
        qu=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-ekk*two*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*ekk)*two)*(tiltck*crkve+tiltsk*cikve)                  !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW OCTUPOLE
  260   ekk=ekk*c1m6
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
!hr02   qv=-three*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*three)*ekk)*(tiltck*crkve+tiltsk*cikve)                !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DECAPOLE
  270   ekk=ekk*c1m9
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=four*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
!hr02   qv=-four*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=((-1d0*four)*ekk)*(tiltck*crkve+tiltsk*cikve)                 !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DODECAPOLE
  280   ekk=ekk*c1m12
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=5*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-5*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 14-POLE
  290   ekk=ekk*c1m15
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=6*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-6*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 16-POLE
  300   ekk=ekk*c1m18
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=7d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-7d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 18-POLE
  310   ekk=ekk*c1m21
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=8d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-8d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 20-POLE
  320   ekk=ekk*c1m24
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        if(ium.ne.1) then
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9d0*ekk*(tiltck*cikve-tiltsk*crkve)
        qu=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
!hr02   qv=-9d0*ekk*(tiltck*crkve+tiltsk*cikve)
        qv=(-9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        endif
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
        dyy1=ekk*cikve
        dyy2=ekk*crkve
!hr02   y(1,1)=y(1,1)+tiltc(k)*dyy1-tilts(k)*dyy2
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
!hr02   y(1,2)=y(1,2)+tiltc(k)*dyy2+tilts(k)*dyy1
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
        if(ium.eq.1) goto 350
  330   continue
        do 340 j=2,ium
          if(kzz.eq.24) then
!hr06       y(j,1)=y(j,1)+x(j,1)*qu-qv*x(j,2)
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
!hr06       y(j,2)=y(j,2)-x(j,2)*quz-qvz*x(j,1)
            y(j,2)=(y(j,2)-x(j,2)*quz)-qvz*x(j,1)                        !hr06
          elseif(kzz.eq.25) then
!hr06       crkve=y(j,1)-x(j,1)*qu*qv
            crkve=y(j,1)-(x(j,1)*qu)*qv                                  !hr06
!hr06       cikve=y(j,2)-x(j,2)*qu*qv
            cikve=y(j,2)-(x(j,2)*qu)*qv                                  !hr06
            y(j,1)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr09
            y(j,2)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr09
            crkve=x(j,1)*cos_rn(qv)+x(j,2)*sin_rn(qv)                    !hr09
            cikve=x(j,2)*cos_rn(qv)-x(j,1)*sin_rn(qv)                    !hr09
            x(j,1)=crkve
            x(j,2)=cikve
          else
!hr06       y(j,1)=y(j,1)+x(j,1)*qu-qv*x(j,2)
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
!hr06       y(j,2)=y(j,2)-x(j,2)*qu-qv*x(j,1)
            y(j,2)=(y(j,2)-x(j,2)*qu)-qv*x(j,1)                          !hr06
          endif
  340   continue
  350 continue
!-----------------------------------------------------------------------
      return
      end
      subroutine resex(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR RMOD
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,i1,i2,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jl,jm,k,k1,kpz,    &
     &kzz,l,l1,l2,ll,lmin,m2,m4,m6,min,mm,mpe,mx,n,n2,n2e,nf1,nf3,nf4,  &
     &nkk,nmz,nn1,nn2,nnf,np,np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,   &
     &chy,ci,cikve,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dphi,dpp,  &
     &dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,phy,pie, &
     &puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,    &
     &vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension qw(2)
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18),min(5)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue
      do 40 i=1,10
        nnf(i)=0
        do 40 j=1,18
          ip(i,j)=0
          re(i,j)=zero
   40 continue
      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue
      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
              min(l)=0
   70       continue
   80     continue
   90   continue
  100 continue
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
      do 110 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
  110 t(1,ll)=clop(l)
      do 120 i=1,4
        do 120 j=1,4
          t(i+1,j)=ta(j,i)
  120 t(i+1,j)=ta(j,i)
!--EP=EMITTANCE IN PI*MM*MRAD
!hr06 ep(1)=tam1*tam1/beta(1)
      ep(1)=tam1**2/beta(1)                                              !hr06
!hr06 ep(2)=tam2*tam2/beta(2)
      ep(2)=tam2**2/beta(2)                                              !hr06
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 770 k=1,iu
        do 130 k1=1,10
          ab1(k1)=zero
  130   ab2(k1)=zero
        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 770
!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do 150 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do 150 i=1,ium
  150     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 160 l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
!hr06       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi
  160     phi(l)=phi(l)+dphi
          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr06         t(i,ll-1)=puf*a(jk,l,1)+t(i,ll)*a(jk,l,2)+dpr(i)*a(jk,l,5)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
!hr06         t(i,ll)=puf*a(jk,l,3)+t(i,ll)*a(jk,l,4)+dpr(i)*a(jk,l,6)
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr06         dphi=-phibf(l)
              dphi=-1d0*phibf(l)
            endif
            if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 770
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 770
        kzz=kz(ix)
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr03         t(i,ll-1)=puf*rrtr(imtr(ix),ll-1,ll-1)+                   &
!hr03&t(i,ll)*rrtr(imtr(ix),ll-1,ll)+                                   &
!hr03&dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
!hr03         t(i,ll)=puf*rrtr(imtr(ix),ll,ll-1)+                       &
!hr03&t(i,ll)*rrtr(imtr(ix),ll,ll)+                                     &
!hr03&dpr(i)*rrtr(imtr(ix),ll,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
!hr03       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
!hr03       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr08         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr08
            endif
!hr03       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
            phi(l)=phi(l)+dphi
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 770
! JBG RF CC Multipoles to 770
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 770
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 770
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
!hr02   zl=-(t(1,1)-xs)*tilts(k)+(t(1,3)-zs)*tiltc(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
        if(kzz.lt.0) goto 370
        goto(220,230,240,250,260,270,280,290,300,310,320,480,480,480,   &
     &      480,480,480,480,480,480,480,480,480,315,316,480,480,480),kzz
        goto 770
!--HORIZONTAL DIPOLE
  220   ekk=ekk*c1e3
        mpe=20
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
        goto 480
!--NORMAL QUADRUPOLE
  230   continue
        dyy1=ekk*(tiltc(k)*xl+tilts(k)*zl)
!hr08   dyy2=ekk*(-tiltc(k)*zl+tilts(k)*xl)
        dyy2=ekk*(tilts(k)*xl-tiltc(k)*zl)                               !hr08
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr02   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        goto 480
!--NORMAL SEXTUPOLE
  240   ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*xl+tiltsk*zl)
        qu=(ekk*two)*(tiltck*xl+tiltsk*zl)                               !hr02
!hr02   qv=ekk*two*(tiltck*zl-tiltsk*xl)
        qv=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltck
        ab2(3)=ekk*tiltsk
        goto 480
!--NORMAL OCTUPOLE
  250   ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(three*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                       !hr02
!hr02   qv=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab1(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
!hr02   ab2(3)=three*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(3)=(three*ekk)*(tiltsk*xl-tiltck*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltck
        ab2(4)=ekk*tiltsk
        goto 480
!--NORMAL DECAPOLE
  260   ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
!hr02   ab2(3)=6*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(6d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(four*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
!hr02   qv=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab1(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
!hr02   ab2(4)=four*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(4)=(four*ekk)*(tiltsk*xl-tiltck*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltck
        ab2(5)=ekk*tiltsk
        goto 480
!--NORMAL DODECAPOLE
  270   ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=10*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(10d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=10*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(10d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab1(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(5)=5*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(5)=(5d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltck
        ab2(6)=ekk*tiltsk
        goto 480
!--NORMAL 14-POLE
  280   ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=20*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(20d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab1(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(6)=6*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(6)=(6d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltck
        ab2(7)=ekk*tiltsk
        goto 480
!--NORMAL 16-POLE
  290   ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=21*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(21d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=35*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(35d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=35*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(35d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=21*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(21d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab1(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(7)=7*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(7)=(7d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltck
        ab2(8)=ekk*tiltsk
        goto 480
!--NORMAL 18-POLE
  300   ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
!hr02   ab2(7)=28*ekk*(-tiltck5*cxzyi+tiltsk5*cxzyr)
        ab2(7)=(28d0*ekk)*(tiltsk5*cxzyr-tiltck5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=56*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(56d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=70*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(70d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=56*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(56d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=28*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(28d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab1(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(8)=8*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(8)=(8d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltck
        ab2(9)=ekk*tiltsk
        goto 480
!--NORMAL 20-POLE
  310   ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        goto 480
!--DIPEDGE ELEMENT
  315   continue
!hr02   dyy1=(ed(IX)*tiltc(k)*xl-ek(IX)*tilts(k)*zl)/(one+dpp)
        dyy1=((ed(IX)*tiltc(k))*xl-(ek(IX)*tilts(k))*zl)/(one+dpp)       !hr02
!hr02   dyy2=(ek(IX)*tiltc(k)*zl+ed(IX)*tilts(k)*xl)/(one+dpp)
        dyy2=((ek(IX)*tiltc(k))*zl+(ed(IX)*tilts(k))*xl)/(one+dpp)       !hr02
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
        goto 480
!--solenoid
  316   continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX))/(one+dpp))+                      &!hr02
     &(cikve*sin_rn(ek(IX))/(one+dpp))-y(1,1)                            !hr02
            dyy2=cikve*cos_rn(ek(IX)/(one+dpp))-                        &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp))-y(1,2)                              !hr02
        mpe=20
        qu=ed(IX)
        qv=ek(IX)
        goto 480
  320   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)+(qu*xl-dppi*dpp)*tilts(k)                     &
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            do 330 i=2,ium
!hr08         t(i,2)=t(i,2)+qu*t(i,1)*tiltc(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
!hr08         t(i,4)=t(i,4)+qu*t(i,3)*tilts(k)
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
  330       continue
          else
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tiltc(k)                             &
!hr03&+dppi*(one-tiltc(k))
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)-dppi*dpp*tilts(k)                             &
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)+(qu*zl-dppi*dpp)*tilts(k)                     &
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+(-qu*zl+dppi*dpp)*tiltc(k)                    &
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
            do 340 i=2,ium
!hr03         t(i,2)=t(i,2)+qu*t(i,1)*tilts(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
!hr03         t(i,4)=t(i,4)-qu*t(i,3)*tiltc(k)
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
  340       continue
          else
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tilts(k)                             &
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+dppi*dpp*tiltc(k)                             &
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
          endif
        endif
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 770
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 770
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2
        do 350 l=lmin,mmul
          cr(l)=zero
  350   ci(l)=zero
        do 360 l=1,nmz
          l1=l-1
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
          if(l.gt.2) then
            cxzyrr=cxzyr*cxzr-cxzyi*cxzi
            cxzyi=cxzyr*cxzi+cxzyi*cxzr
            cxzyr=cxzyrr
            cr(l)=cxzyr
            ci(l)=cxzyi
          endif
!hr03     dyy1=dyy1+bb(l)*cr(l)+aa(l)*ci(l)
          dyy1=(dyy1+bb(l)*cr(l))+aa(l)*ci(l)                            !hr03
!hr03     dyy2=dyy2-bb(l)*ci(l)+aa(l)*cr(l)
          dyy2=(dyy2-bb(l)*ci(l))+aa(l)*cr(l)                            !hr03
          if(l.gt.1.and.ium.ne.1) then
!hr03       qu=qu+l1*(bb(l)*cr(l1)+aa(l)*ci(l1))
            qu=qu+dble(l1)*(bb(l)*cr(l1)+aa(l)*ci(l1))                   !hr03
!hr03       qv=qv+l1*(bb(l)*ci(l1)-aa(l)*cr(l1))
            qv=qv+dble(l1)*(bb(l)*ci(l1)-aa(l)*cr(l1))                   !hr03
          endif
  360   continue
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
        izu=izu+2*mmul-2*nmz
        goto 480
!--SKEW ELEMENTS
  370   kzz=-kzz
        goto(380,390,400,410,420,430,440,450,460,470),kzz
        goto 770
!--VERTICAL DIPOLE
  380   ekk=ekk*c1e3
        mpe=20
!hr02   dyy1=-ekk*tilts(k)
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr02
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
        goto 480
!--SKEW QUADRUPOLE
  390   continue
        dyy1=ekk*(tiltc(k)*zl-tilts(k)*xl)
        dyy2=ekk*(tiltc(k)*xl+tilts(k)*zl)
        mpe=2
        mx=-1
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        goto 480
!--SKEW SEXTUPOLE
  400   ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*zl-tiltsk*xl)
        qu=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
!hr02   qv=-ekk*two*(tiltck*xl+tiltsk*zl)
        qv=((-1d0*ekk)*two)*(tiltck*xl+tiltsk*zl)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltsk
        ab2(3)=ekk*tiltck
        goto 480
!--SKEW OCTUPOLE
  410   ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
!hr02   qv=-three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*three)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*zl-tiltsk*xl)
        ab1(3)=(three*ekk)*(tiltck*zl-tiltsk*xl)                         !hr02
!hr02   ab2(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab2(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltsk
        ab2(4)=ekk*tiltck
        goto 480
!--SKEW DECAPOLE
  420   ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                   !hr02
!hr02   ab2(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*four)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*zl-tiltsk*xl)
        ab1(4)=(four*ekk)*(tiltck*zl-tiltsk*xl)                          !hr02
!hr02   ab2(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab2(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltsk
        ab2(5)=ekk*tiltck
        goto 480
!--SKEW DODECAPOLE
  430   ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*zl-tiltsk*xl)
        ab1(5)=(5d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab2(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltsk
        ab2(6)=ekk*tiltck
        goto 480
!--SKEW 14-POLE
  440   ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=15*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(15d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*zl-tiltsk*xl)
        ab1(6)=(6d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab2(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltsk
        ab2(7)=ekk*tiltck
        goto 480
!--SKEW 16-POLE
  450   ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*zl-tiltsk*xl)
        ab1(7)=(7d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab2(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltsk
        ab2(8)=ekk*tiltck
        goto 480
!--SKEW 18-POLE
  460   ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyi-tiltsk5*cxzyr)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyi-tiltsk5*cxzyr)                  !hr02
!hr02   ab2(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab2(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*zl-tiltsk*xl)
        ab1(8)=(8d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab2(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltsk
        ab2(9)=ekk*tiltck
        goto 480
!--SKEW 20-POLE
  470   ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
  480   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*quz-qvz*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
!hr02       crkve=t(i,2)-t(i,1)*qu*qv
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
!hr02       cikve=t(i,4)-t(i,3)*qu*qv
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
!hr02       t(i,2)=crkve*cos(qv)+cikve*sin(qv)
!hr02       t(i,4)=-crkve*sin(qv)+cikve*cos(qv)
!hr02       crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
!hr02       cikve=-t(i,1)*sin(qv)+t(i,3)*cos(qv)
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
          else
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*qu-qv*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
        do 500 l=1,2
          ll=2*l
!hr06     alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
          alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
  500   continue
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 770
        if(mpe.lt.nta) goto 770
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 520
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx  &
     &.eq.5.or.mx.eq.6.or.mx.eq.7) goto 520
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do 510 l=2,nmz
          l1=l-1
!hr06  510   ab2(2)=ab2(2)+l1*(aa(l)*cr(l1)-bb(l)*ci(l1))
  510   ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
  520   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 540
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 670
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 540
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 530 l=3,nmz
          l1=l-2
!hr06     ab1(3)=ab1(3)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(3)=ab2(3)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  530   l2=l2*l/l1
  540   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 560
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 670
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 560
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 550 l=4,nmz
          l1=l-3
!hr06     ab1(4)=ab1(4)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(4)=ab2(4)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550   l2=l2*l/l1
!hr06  560   b(5,1)=b1*b1
  560   b(5,1)=b1**2                                                     !hr06
!hr06   b(1,5)=b2*b2
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 580
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 670
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 580
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 570 l=5,nmz
          l1=l-4
!hr06     ab1(5)=ab1(5)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(5)=ab2(5)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  570   l2=l2*l/l1
  580   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 600
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 670
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 590 l=6,nmz
          l1=l-5
!hr06     ab1(6)=ab1(6)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(6)=ab2(6)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  590   l2=l2*l/l1
  600   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 620
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 670
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 620
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 610 l=7,nmz
          l1=l-6
!hr06     ab1(7)=ab1(7)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(7)=ab2(7)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  610   l2=l2*l/l1
  620   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 640
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 670
        if(mx.eq.6.or.mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 630 l=8,nmz
          l1=l-7
!hr06     ab1(8)=ab1(8)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(8)=ab2(8)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  630   l2=l2*l/l1
  640   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 670
        if(mx.eq.7) goto 660
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do 650 l=9,nmz
          l1=l-8
!hr06     ab1(9)=ab1(9)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(9)=ab2(9)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  650   l2=l2*l/l1
  660   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  670   do 700 np=1,mpe
          n2e=2*np
          do 690 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
!hr06       re1=nn1*qxt+n2*qzt
            re1=dble(nn1)*qxt+dble(n2)*qzt                               !hr06
            ipt=0
            do 680 ii=1,nre
  680       if(n2.eq.nrr(ii)) ipt=ipr(ii)
            ip(np,nv)=int(re1+half)+ipt
!hr06       if(-re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
            if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
!--RE=DISTANCE FROM THE RESONANCE
!hr06       re(np,nv)=re1-ip(np,nv)
            re(np,nv)=re1-dble(ip(np,nv))                                !hr06
            res=re(np,nv)/radi
!hr06       chy(np,nv)=cos_rn(nn1*phi(1)+n2*phi(2)-res*etl)
           chy(np,nv)=cos_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
!hr06       shy(np,nv)=sin_rn(nn1*phi(1)+n2*phi(2)-res*etl)
           shy(np,nv)=sin_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
  690     continue
  700   continue
        do 760 np=nta,mpe
          np2=np
          nkk=0
  710     nkk=nkk+1
          n2e=2*np2
          do 750 i=1,nkk
            do 740 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
!hr06         rn2=nn2*half
              rn2=dble(nn2)*half                                         !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 720
!hr06         btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
!hr06         bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 730
!hr06  720         btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
  720         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
!hr06         bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  730         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  740       continue
  750     continue
          np2=np2-2
          if(np2.ge.1) goto 710
  760   continue
  770 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
!hr06 e(2,2)=one/seb/sea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
!hr06 e(7,3)=ea*ea
      e(7,3)=ea**2                                                       !hr06
!hr06 e(3,7)=eb*eb
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 810 np=nta,nte
!hr06   vdt1=nnf(np)/(nz2(np)*pi)
        vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                            !hr06
        np2=np
        nkk=0
  780   nkk=nkk+1
        n2e=2*np2
        do 800 i=1,nkk
          do 790 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
!hr06       vdt2=vdt1*e(nv1,nv2)/(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4))
!hr06       vdt2=(vdt1*e(nv1,nv2))/
!hr06&(((dble(nnf(nf1))*dble(nnf(i)))*dble(nnf(nf3)))*dble(nnf(nf4)))
      vdt2=(vdt1*e(nv1,nv2))/dble(((nnf(nf1)*nnf(i))*nnf(nf3))*nnf(nf4)) !hr06
!hr06       vdt3=nn2*ea+nn1*eb
            vdt3=dble(nn2)*ea+dble(nn1)*eb                               !hr06
!hr06       if(n2.ge.0) vdt3=n2*nv21*ea+nn1*nv11*eb
            if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb          !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  790     continue
  800   continue
        np2=np2-2
        if(np2.ge.1) goto 780
  810 continue
      if(nur.eq.0) goto 840
      do 830 j=1,nur
        jk=j*2
        do 820 i=1,nur
          jl=nu(i)-npp-jk
          if(jl.eq.0) min(j)=1
  820   if(jl.eq.0) goto 830
  830 continue
  840 m2=npp+2
      m4=npp+4
      m6=npp+6
      do 850 i=1,nre
        i2=2*i
        i1=i2-1
        n=nrr(i)+npp
!hr06   dtr(i1)=rtc(npp,n,npp,1)+min(1)*(-rtc(npp,n,m2,1)+rtc           &
!hr06&(npp,n,m2,2))+min(2)*(rtc(npp,n,m4,1)-rtc(npp,n,m4,2)+rtc         &
!hr06&(npp,n,m4,3))+ min(3)*(-rtc(npp,n,m6,1)+rtc(npp,n,m6,2)-rtc       &
!hr06&(npp,n,m6,3)+ rtc(npp,n,m6,4))
        dtr(i1)=rtc(npp,n,npp,1)+(min(1)*(rtc(npp,n,m2,2)-              &!hr06
     &rtc(npp,n,m2,1))+min(2)*((rtc(npp,n,m4,1)-rtc(npp,n,m4,2))+rtc    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rtc(npp,n,m6,2)-rtc(npp,n,m6,1))-rtc     &!hr06
     &(npp,n,m6,3))+ rtc(npp,n,m6,4))                                    !hr06
!hr06   dtr(i2)=rts(npp,n,npp,1)+min(1)*(-rts(npp,n,m2,1)+rts           &
!hr06&(npp,n,m2,2))+min(2)*(rts(npp,n,m4,1)-rts(npp,n,m4,2)+rts         &
!hr06&(npp,n,m4,3))+ min(3)*(-rts(npp,n,m6,1)+rts(npp,n,m6,2)-rts       &
!hr06&(npp,n,m6,3)+ rts(npp,n,m6,4))
        dtr(i2)=rts(npp,n,npp,1)+(min(1)*(rts(npp,n,m2,2)-              &!hr06
     &rts(npp,n,m2,1))+min(2)*((rts(npp,n,m4,1)-rts(npp,n,m4,2))+rts    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rts(npp,n,m6,2)-rts(npp,n,m6,1))-rts     &!hr06
     &(npp,n,m6,3))+rts(npp,n,m6,4))                                     !hr06
  850 continue
      return
      end
      subroutine rmod(dppr)
!-----------------------------------------------------------------------
!  CALCULATION OF THE STRENGTH OF CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,i1,i2,ierr,irr,j,j1,j2,j3,j4,jj1,jj2,jjr,k,n,no,ntao,   &
     &nteo
      double precision aa,bb,d1,de2,dpp,dppr,dsm,ox,oz,qwc,se11,se12,   &
     &se2,sen,sen15,sen16,sen17,sen18,sn,ss
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension aa(10,10),bb(10),dsm(10),sn(10),sen(10),ss(10)
      dimension qwc(3),d1(10),irr(12)
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=npp
      nte=npp
      dpp=dppr
      do 10 i=1,10
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero
        do 10 j=1,10
          aa(i,j)=zero
   10 continue
      do 20 i=1,12
        irr(i)=0
   20 continue
      do 30 i=1,3
        qwc(i)=zero
   30 continue
      k=1
      jj1=0
      jj2=0
      jjr=2*nre
      de2=de0*half
      if(nre.eq.0) goto 50
      write(*,10000)
      write(*,10010) npp,totl,qxt,qzt,tam1
      call resex(dpp)
      do 40 i=1,nre
        i2=2*i
        i1=i2-1
        irr(i1)=ire(i1)
        irr(i2)=ire(i2)
        sn(i1)=ed(irr(i1))
        sn(i2)=ed(irr(i2))
        dsm(i1)=dsm0
        dsm(i2)=dsm0
        write(*,10020) i,nrr(i),ipr(i)
        sen(i1)=dtr(i1)
        bb(i1)=sen(i1)
        sen(i2)=dtr(i2)
        bb(i2)=sen(i2)
        ss(i1)=sen(i1)
        ss(i2)=sen(i2)
   40 continue
      j2=jjr
   50 if(nur.eq.0) goto 70
      write(*,10030) nur
      do 60 i=1,nur
        write(*,10040) nu(i),i
   60 continue
   70 if(nch.eq.0) goto 90
      write(*,10050)
      j1=j2+1
      j2=j2+2
      irr(j1)=ire(7)
      irr(j2)=ire(8)
      sn(j1)=ed(irr(j1))
      sn(j2)=ed(irr(j2))
      dsm(j1)=dsm0
      dsm(j2)=dsm0
      se2=zero
      se11=zero
      se12=zero
      do 80 n=1,5
!hr06   dpp=de2*(3-n)
        dpp=de2*dble(3-n)                                                !hr06
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ox=qwc(1)
        oz=qwc(2)
        se2=se2+dpp*dpp
        se11=se11+ox*dpp
        se12=se12+oz*dpp
   80 continue
      sen(j1)=se11/se2
      sen(j2)=se12/se2
      bb(j1)=sen(j1)
      bb(j2)=sen(j2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
   90 if(nqc.eq.0) goto 100
      write(*,10060)
      j1=j2+1
      j2=j2+2
      jj1=j1
      jj2=j2
      irr(j1)=ire(9)
      irr(j2)=ire(10)
      if (abs(el(irr(j1))).le.pieni.or.abs(el(irr(j2))).le.pieni) then
        sn(j1)=ed(irr(j1))
        sn(j2)=ed(irr(j2))
      else
        sn(j1)=ek(irr(j1))
        sn(j2)=ek(irr(j2))
      endif
      dsm(j1)=dkq
      dsm(j2)=dkq
      dpp=zero
      call clorb2(dpp)
      call phasad(dpp,qwc)
      sen(j1)=qwc(1)
      sen(j2)=qwc(2)
      bb(j1)=sen(j1)-qw0(1)
      bb(j2)=sen(j2)-qw0(2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
  100 do 330 no=1,itcro
        do 160 i=1,j2
          if(i.ne.jj1.and.i.ne.jj2) ed(irr(i))=ed(irr(i))+dsm(i)
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))+dsm(i)
            else
              ek(irr(i))=ek(irr(i))+dsm(i)
            endif
          endif
          if(kp(irr(i)).eq.5) call combel(irr(i))
          if(nre.eq.0) goto 120
          call resex(dpp)
          do 110 j=1,jjr
            aa(i,j)=(dtr(j)-ss(j))/dsm(i)
  110     continue
  120     if(nch.eq.0) goto 140
          j3=jjr+1
          j4=jjr+2
          se2=zero
          se11=zero
          se12=zero
          do 130 n=1,5
!hr06       dpp=de2*(3-n)
            dpp=de2*dble(3-n)                                            !hr06
            call clorb2(dpp)
            call phasad(dpp,qwc)
            ox=qwc(1)
            oz=qwc(2)
            se2=se2+dpp*dpp
            se11=se11+ox*dpp
            se12=se12+oz*dpp
  130     continue
          sen15=se11/se2
          sen16=se12/se2
          aa(i,j3)=(sen15-ss(j3))/dsm(i)
          aa(i,j4)=(sen16-ss(j4))/dsm(i)
  140     if(nqc.eq.0) goto 150
          dpp=zero
          call clorb2(dpp)
          call phasad(dpp,qwc)
          sen17=qwc(1)
          sen18=qwc(2)
          aa(i,j1)=(sen17-ss(j1))/dsm(i)
          aa(i,j2)=(sen18-ss(j2))/dsm(i)
  150     continue
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-dsm(i)
            else
              ek(irr(i))=ek(irr(i))-dsm(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-dsm(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  160   continue
        call loesd(aa,bb,j2,10,ierr)
        if(ierr.eq.1) call prror(38)
        do 170 i=1,j2
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-bb(i)
            else
              ek(irr(i))=ek(irr(i))-bb(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-bb(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  170   continue
        if(nre.eq.0) goto 190
        call resex(dpp)
        do 180 i=1,jjr
          ss(i)=dtr(i)
  180   d1(i)=abs(ss(i))
  190   if(nch.eq.0) goto 210
        se2=zero
        se11=zero
        se12=zero
        do 200 n=1,5
!hr06     dpp=de2*(3-n)
          dpp=de2*dble(3-n)                                              !hr06
          call clorb2(dpp)
          call phasad(dpp,qwc)
          ox=qwc(1)
          oz=qwc(2)
          se2=se2+dpp*dpp
          se11=se11+ox*dpp
          se12=se12+oz*dpp
  200   continue
        ss(j3)=se11/se2
        ss(j4)=se12/se2
        d1(j3)=abs(ss(j3))
        d1(j4)=abs(ss(j4))
  210   if(nqc.eq.0) goto 220
        dpp=zero
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ss(j1)=qwc(1)
        ss(j2)=qwc(2)
        d1(j1)=abs(qwc(1)-qw0(1))
        d1(j2)=abs(qwc(2)-qw0(2))
  220   write(*,10070)
        if(nre.eq.0) goto 270
        write(*,10080) no,nrr(1),sen(1),ss(1),sen(2),ss(2)
        if(nre.eq.1) goto 240
        do 230 i=2,nre
          i2=2*i
          i1=i2-1
  230   write(*,10090) nrr(i),sen(i1),ss(i1),sen(i2),ss(i2)
  240   write(*,10100)
        write(*,10110) bez(irr(1)),sn(1),ed(irr(1)),bez(irr(2)),sn(2),  &
     &ed(irr(2))
        if(nre.eq.1) goto 260
        do 250 i=2,nre
          i2=2*i
          i1=i2-1
  250   write(*,10110) bez(irr(i1)),sn(i1),ed(irr(i1)),bez(irr(i2)),sn  &
     &(i2), ed(irr(i2))
  260   write(*,10070)
  270   if(nch.eq.0) goto 280
        write(*,10120) sen(j3),ss(j3),sen(j4),ss(j4)
        write(*,10110) bez(irr(j3)),sn(j3),ed(irr(j3)),bez(irr(j4)),sn  &
     &(j4), ed(irr(j4))
        write(*,10070)
  280   if(nqc.eq.0) goto 290
        write(*,10130) qw0(1),qwc(1),qw0(2),qwc(2)
        if (abs(el(irr(j1))).le.pieni) then
          write(*,10140) sn(j1),ed(irr(j1)),irr(j1),sn(j2),ed(irr(j2)), &
     &irr(j2)
        else
          write(*,10140) sn(j1),ek(irr(j1)),irr(j1),sn(j2),ek(irr(j2)), &
     &irr(j2)
        endif
  290   do 300 i=1,j2
  300   if(d1(i).gt.dsi) goto 310
        nta=ntao
        nte=nteo
        return
  310   do 320 i=1,j2
  320   bb(i)=ss(i)
        if(nqc.eq.1) bb(j1)=bb(j1)-qw0(1)
        if(nqc.eq.1) bb(j2)=bb(j2)-qw0(2)
  330 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY RMOD ----')
10010 format(/10x,'N=',i1,' IS THE ORDER OF RESONACE, THAT WILL BE',    &
     &' COMPENSATED'// 10x,'L=',f15.6,'; QX=',f10.5,'; QY=',f10.5,      &
     &'; AMAX=',f10.5)
10020 format(/10x,i1,' RESONANCE; NY=',i2,';CHANGE OF P=',i2)
10030 format(/10x,'NUMBER OF SUBRESONANCES THAT ARE CONSIDERED IS ',i2)
10040 format(/10x,'NU=',i2,' IS THE ',i1,' SUBRESONANCE-MULTIPOLE-ORDER'&
     &,i2)
10050 format(/10x,'CHROMATICITY IS COMPENSATED')
10060 format(/10x,'Q-VALUES ARE ADJUSTED')
10070 format(131('-'))
10080 format(/10x,'RESONANCE-CORRECTION     ITERATION #',i2// 15x,      &
     &'DRIVING-TERM',13x,'BEFORE         AFTER     COMPENSATION'// 10x, &
     &'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,'SIN-COMPONENT  ',2g15.5/&
     &)
10090 format(10x,'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,              &
     &'SIN-COMPONENT  ',2g15.5/)
10100 format(10x,'  ELEMENT NAME'/)
10130 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10140 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10120 format(10x,'CHROMATICITY-CORRECTION'/ 15x,'CHROMATICITY',13x,     &
     &'BEFORE         AFTER     COMPENSATION'// 19x,'HORIZONTAL   ',2g15&
     &.5/ 19x,'VERTICAL     ',2g15.5/ 10x,'   SEXTUPOLE'/)
10110 format(14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,g16.10)
      end
      subroutine search(dpp)
!-----------------------------------------------------------------------
!  FINDING THE BEST POSITIONS FOR CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,id,n21,n22,n23,ntao,nteo
      double precision b,c,c1,c2,c3,d,dpp,e,f,g,s1,s2,s3
      character*16 ref
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=mp
      nte=mp
      ref='REFERENCE       '
      id=0
      write(*,10010)
      write(*,10000)
      write(*,10010)
      write(*,10020) mp
      write(*,10010)
      write(*,10030) m21,ise1,m22,ise2,m23,ise3
      write(*,10010)
      write(*,10040)
      write(*,10010)
      n21=m21+mp
      n22=m22+mp
      n23=m23+mp
      ipt=ise1
      call subsea(dpp)
      c1=rtc(mp,n21,mp,1)
      s1=rts(mp,n21,mp,1)
      ipt=ise2
      call subsea(dpp)
      c2=rtc(mp,n22,mp,1)
      s2=rts(mp,n22,mp,1)
      ipt=ise3
      call subsea(dpp)
      c3=rtc(mp,n23,mp,1)
      s3=rts(mp,n23,mp,1)
      write(*,10050) ref,id,c1,s1,c2,s2,c3,s3
      do 10 i=1,mesa
        ed(isea(i))=ed(isea(i))+dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
        ipt=ise1
        call subsea(dpp)
        b=rtc(mp,n21,mp,1)-c1
        c=rts(mp,n21,mp,1)-s1
        ipt=ise2
        call subsea(dpp)
        d=rtc(mp,n22,mp,1)-c2
        e=rts(mp,n22,mp,1)-s2
        ipt=ise3
        call subsea(dpp)
        f=rtc(mp,n23,mp,1)-c3
        g=rts(mp,n23,mp,1)-s3
        write(*,10050) bez(isea(i)),i,b,c,d,e,f,g
        ed(isea(i))=ed(isea(i))-dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
   10 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY SEARCH ----')
10010 format(1x ,131('-'))
10020 format(10x,///'RESONANCES OF ORDER',i4,'  ARE CONSIDERED'//)
10030 format(24x ,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|',6x,'NY =',i4,    &
     &';D-P= ',i4,7x,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|')
10040 format(1x,'ELEMENT          | POS |',6x,'COS',13x,'SIN',6x,'|',   &
     &6x,'COS',13x,'SIN',6x,'|', 6x,'COS',13x,'SIN',6x,'|')
10050 format(1x,a16,1x,'|',i3,'  |',g15.5,'|',g15.5,'|',g15.5,'|',      &
     &g15.5,'|',g15.5,'|',g15.5,'|')
      end
      subroutine subre(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF RESONANCE- AND SUBRESONANCE-DRIVINGTERMS
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ii,ik,im,ip,ipc,ipcc,ipl,ium,iv,ix,izu,j,jj,jk,jm,k,    &
     &k1,kpz,kzz,l,l1,l2,ll,lmin,min1,min2,mis,mm,mpe,mx,n2,n22,n2e,nf1,&
     &nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,nph,nr,ns,ntx,nv,nv1,nv11,nv2, &
     &nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,cc,&
     &chy,ci,cikve,clo0,clop0,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,&
     &dfac,dphi,dpp,dpp1,dppi,dpr,dt,dtu,dtup,dyy1,dyy2,e,ea,eb,ekk,    &
     &ekko,ep,etl,gerad,gtu1,gtu2,phi,phibf,phy,pie,puf,qu,qv,qw,qwc,r0,&
     &r0a,radi,rc,re,re1,res,rn2,rs,sb1,sb2,sdel,sdel2,sea,seb,shy,ss,t,&
     &vdt1,vdt2,vdt3,vdt4,xl,xs,zl,zs,quz,qvz
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltck6,tiltck8,tiltck10,tiltckuk,tiltsk,tiltsk1,tiltsk2, &
     &tiltsk3,tiltsk4,tiltsk5,tiltsk6,tiltsk8,tiltsk10
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension t(6,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension clo0(2),clop0(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),qwc(3),dpr(6)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension dfac(10),dtu(2,5),dtup(2,5,0:4,0:4)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
      ipl=1
      gtu1=zero
      gtu2=zero
      dfac(1)=one
      dfac(2)=one
      dfac(3)=two
!hr13 dfac(4)=6
      dfac(4)=6d0                                                        !hr13
!hr13 dfac(5)=24
      dfac(5)=24d0                                                       !hr13
!hr13 dfac(6)=120
      dfac(6)=120d0                                                      !hr13
!hr13 dfac(7)=720
      dfac(7)=720d0                                                      !hr13
!hr13 dfac(8)=5040
      dfac(8)=5040d0                                                     !hr13
!hr13 dfac(9)=40320
      dfac(9)=40320d0                                                    !hr13
!hr13 dfac(10)=362880
      dfac(10)=362880d0                                                  !hr13
      if(ipt.eq.1) ipl=3
      do 940 ipcc=1,ipl
        ipc=ipcc-ipl+1
        if(ipt.eq.0) ipc=0
        btc=zero
        bts=zero
        phy=zero
        dt=zero
        del=zero
        ns=0
        ik=0
        do 10 i=1,ium
          dpr(i)=zero
   10   continue
        do 20 i=1,ium
          do 20 j=1,4
            t(i,j)=zero
   20   continue
        do 30 i=1,2
          beta(i)=zero
          alfa(i)=zero
          phi(i)=zero
          phibf(i)=zero
          qw(i)=zero
          qwc(i)=zero
          clo0(i)=zero
          clop0(i)=zero
          ep(i)=zero
   30   continue
        qwc(3)=zero
        do 40 i=1,10
          nnf(i)=0
          do 40 j=1,18
            re(i,j)=zero
            ip(i,j)=0
   40   continue
        do 50 i=1,mmul
          aa(i)=zero
          bb(i)=zero
          cr(i)=zero
          ci(i)=zero
   50   continue
        do 60 i=1,2
          do 60 j=1,5
            dtu(i,j)=zero
   60   continue
        do 70 i=1,5
          do 70 j=0,4
            do 70 k=0,4
              dtup(1,i,j,k)=zero
              dtup(2,i,j,k)=zero
   70   continue
        do 120 i=1,9
          nz2(i)=0
          do 110 j=1,18
            chy(i,j)=zero
            shy(i,j)=zero
            do 100 k=1,10
              do 80 ii=1,10
                e(k,ii)=zero
                b(k,ii)=zero
   80         continue
              do 90 l=1,5
                rtc(i,j,k,l)=zero
                rts(i,j,k,l)=zero
   90         continue
  100       continue
  110     continue
  120   continue
        write(*,10030)
        write(*,10020)
        pie=two*pi
        etl=zero
        radi=totl/pie
        nr=0
        dpr(1)=dpp*c1e3
        dpr(6)=c1e3
        dpp1=dpp+ded
        call clorb(dpp1)
        do 130 l=1,2
          clo0(l)=clo(l)
  130   clop0(l)=clop(l)
        call clorb(dpp)
        do 140 l=1,2
          di0(l)=(clo0(l)-clo(l))/ded
  140   dip0(l)=(clop0(l)-clop(l))/ded
        write(*,10030)
        write(*,10120) (di0(l),dip0(l),l=1,2)
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        if(ierro.ne.0) call prror(22+ierro)
        write(*,10070) dpp,qwc(1),qwc(2)
        call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
        do 150 l=1,2
          ll=2*l
          alfa(l)=alf0(l)
          beta(l)=bet0(l)
          t(1,ll-1)=clo(l)
          t(1,ll)=clop(l)
          clo0(l)=clo(l)
  150   clop0(l)=clop(l)
        do 160 i=1,4
          do 160 j=1,4
            t(i+1,j)=ta(j,i)
  160   t(i+1,j)=ta(j,i)
        write(*,10030)
        write(*,10040)
        write(*,10030)
        write(*,10010) nr,'START   ',zero,zero,(beta(l),alfa(l),phi(l), &
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
!--EP=EMITTANCE IN PI*MM*MRAD
!hr06   ep(1)=tam1*tam1/beta(1)
        ep(1)=tam1**2/beta(1)                                            !hr06
!hr06   ep(2)=tam2*tam2/beta(2)
        ep(2)=tam2**2/beta(2)                                            !hr06
        write(*,10050) tam1,ep(1),tam2,ep(2)
        write(*,10030)
!--SINGLE TURN BLOCKLOOP
        izu=0
        do 790 k=1,iu
          do 170 k1=1,10
            ab1(k1)=zero
  170     ab2(k1)=zero
          ix=ic(k)
          if(ix.gt.nblo) goto 250
          jj=0
          dj=1
          if(ix.gt.0) goto 180
!hr13     ix=-ix
          ix=-1*ix
          jj=mel(ix)+1
          dj=-1
  180     jm=mel(ix)
!--SINGLE TURN BLOCKLOOP
          do 240 j=1,jm
            jj=jj+dj
            jk=mtyp(ix,jj)
            if(ithick.eq.1.and.kz(jk).ne.0) goto 210
            if(ithick.eq.0.and.kz(jk).ne.0) goto 790
!--PURE DRIFTLENGTH
            etl=etl+el(jk)
            do 190 l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
              do 190 i=1,ium
  190       t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            do 200 l=1,2
              ll=2*l
!hr06         beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
!hr06         alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
              alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
!hr06         if(-dphi.gt.pieni) dphi=dphi+pi
              if(-1d0*dphi.gt.pieni) dphi=dphi+pi                        !hr06
  200       phi(l)=phi(l)+dphi/pie
            nr=nr+1
            goto 240
!--MAGNETELEMENT
  210       continue
            if(kz(jk).ne.8) etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=zero
              endif
              do i=1,ium
                puf=t(i,ll-1)
!hr06           t(i,ll-1)=puf*a(jk,l,1)+t(i,ll)*a(jk,l,2)+dpr(i)*a      &
                t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a    &!hr06
     &(jk,l,5)
!hr06           t(i,ll)=puf*a(jk,l,3)+t(i,ll)*a(jk,l,4)+dpr(i)*a(jk,l,6)
              t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6) !hr06
              enddo
            enddo
            do l=1,2
              ll=2*l
!hr06         beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
!hr06         alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
              alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=-phibf(l)
              endif
              if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
              phi(l)=phi(l)+dphi/pie
            enddo
            nr=nr+1
  240     continue
          goto 790
!--NL-INSERTION
  250     ix=ix-nblo
          qu=zero
          qv=zero
          kpz=kp(ix)
          if(kpz.eq.6) goto 790
          kzz=kz(ix)
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr03         t(i,ll-1)=puf*rrtr(imtr(ix),ll-1,ll-1)+                   &
!hr03&t(i,ll)*rrtr(imtr(ix),ll-1,ll)+                                   &
!hr03&dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
!hr03         t(i,ll)=puf*rrtr(imtr(ix),ll,ll-1)+                       &
!hr03&t(i,ll)*rrtr(imtr(ix),ll,ll)+                                     &
!hr03&dpr(i)*rrtr(imtr(ix),ll,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
!hr03       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
!hr03       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr08         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr08
            endif
!hr03       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
            phi(l)=phi(l)+dphi
          enddo
        endif
          clo0(1)=t(1,1)
          clop0(1)=t(1,2)
          clo0(2)=t(2,3)
          clop0(2)=t(2,4)
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 790
! JBG RF CC Multipoles to 790
          if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 790
          if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 790
          dyy1=zero
          dyy2=zero
          if(iorg.lt.0) mzu(k)=izu
          izu=mzu(k)+1
          ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
          izu=izu+1
          xs=xpl(ix)+zfz(izu)*xrms(ix)
          izu=izu+1
          zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
!hr02   zl=-(t(1,1)-xs)*tilts(k)+(t(1,3)-zs)*tiltc(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
          if(kzz.lt.0) goto 400
          goto(260,270,280,290,300,310,320,330,340,350,360,790,790,790, &
     &      790,790,790,790,790,790,790,790,790,355,356,790,790,790),kzz
          goto 790
!--HORIZONTAL DIPOLE
  260     ekk=ekk*c1e3
        mpe=20
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
          goto 510
!--NORMAL QUADRUPOLE
  270     continue
        dyy1=ekk*(tiltc(k)*xl+tilts(k)*zl)
!hr08   dyy2=ekk*(-tiltc(k)*zl+tilts(k)*xl)
        dyy2=ekk*(tilts(k)*xl-tiltc(k)*zl)                               !hr08
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr02   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
          goto 510
!--NORMAL SEXTUPOLE
  280     ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*xl+tiltsk*zl)
        qu=(ekk*two)*(tiltck*xl+tiltsk*zl)                               !hr02
!hr02   qv=ekk*two*(tiltck*zl-tiltsk*xl)
        qv=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltck
        ab2(3)=ekk*tiltsk
          goto 510
!--NORMAL OCTUPOLE
  290     ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(three*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                       !hr02
!hr02   qv=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab1(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
!hr02   ab2(3)=three*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(3)=(three*ekk)*(tiltsk*xl-tiltck*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltck
        ab2(4)=ekk*tiltsk
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DECAPOLE
  300     ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
!hr02   ab2(3)=6*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(6d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(four*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
!hr02   qv=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab1(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
!hr02   ab2(4)=four*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(4)=(four*ekk)*(tiltsk*xl-tiltck*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltck
        ab2(5)=ekk*tiltsk
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DODECAPOLE
  310     ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=10*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(10d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=10*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(10d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab1(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(5)=5*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(5)=(5d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltck
        ab2(6)=ekk*tiltsk
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 14-POLE
  320     ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=20*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(20d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab1(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(6)=6*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(6)=(6d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltck
        ab2(7)=ekk*tiltsk
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 16-POLE
  330     ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=21*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(21d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=35*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(35d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=35*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(35d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=21*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(21d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab1(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(7)=7*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(7)=(7d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltck
        ab2(8)=ekk*tiltsk
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 18-POLE
  340     ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
!hr02   ab2(7)=28*ekk*(-tiltck5*cxzyi+tiltsk5*cxzyr)
        ab2(7)=(28d0*ekk)*(tiltsk5*cxzyr-tiltck5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=56*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(56d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=70*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(70d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=56*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(56d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=28*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(28d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab1(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(8)=8*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(8)=(8d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltck
        ab2(9)=ekk*tiltsk
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 20-POLE
  350     ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
!hr08     tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
          ekk=ekko*tiltck10
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
!hr03     ekk=36*ekko*(tiltck8*cxzyr+tiltsk8*cxzyi)
          ekk=(36d0*ekko)*(tiltck8*cxzyr+tiltsk8*cxzyi)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
!hr03     ekk=126*ekko*(tiltck6*cxzyr+tiltsk6*cxzyi)
          ekk=(126d0*ekko)*(tiltck6*cxzyr+tiltsk6*cxzyi)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
!hr03     ekk=84*ekko*(tiltck4*cxzyr+tiltsk4*cxzyi)
          ekk=(84d0*ekko)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--DIPEDGE ELEMENT
  355     continue
!hr02   dyy1=(ed(IX)*tiltc(k)*xl-ek(IX)*tilts(k)*zl)/(one+dpp)
        dyy1=((ed(IX)*tiltc(k))*xl-(ek(IX)*tilts(k))*zl)/(one+dpp)       !hr02
!hr02   dyy2=(ek(IX)*tiltc(k)*zl+ed(IX)*tilts(k)*xl)/(one+dpp)
        dyy2=((ek(IX)*tiltc(k))*zl+(ed(IX)*tilts(k))*xl)/(one+dpp)       !hr02
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
          goto 510
!--solenoid
  356     continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX))/(one+dpp))+                      &!hr02
     &(cikve*sin_rn(ek(IX))/(one+dpp))-y(1,1)                            !hr02
            dyy2=cikve*cos_rn(ek(IX)/(one+dpp))-                        &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp))-y(1,2)                              !hr02
        mpe=20
        qu=ed(IX)
        qv=ek(IX)
          goto 510
  360     r0=ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)+(qu*xl-dppi*dpp)*tilts(k)                     &
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            do 363 i=2,ium
!hr08         t(i,2)=t(i,2)+qu*t(i,1)*tiltc(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
!hr08         t(i,4)=t(i,4)+qu*t(i,3)*tilts(k)
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
  363       continue
            else
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tiltc(k)                             &
!hr03&+dppi*(one-tiltc(k))
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)-dppi*dpp*tilts(k)                             &
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)+(qu*zl-dppi*dpp)*tilts(k)                     &
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+(-qu*zl+dppi*dpp)*tiltc(k)                    &
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
            do 366 i=2,ium
!hr03         t(i,2)=t(i,2)+qu*t(i,1)*tilts(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
!hr03         t(i,4)=t(i,4)-qu*t(i,3)*tiltc(k)
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
  366       continue
            else
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tilts(k)                             &
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+dppi*dpp*tiltc(k)                             &
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
            endif
          endif
          mpe=9
          mx=0
          if(abs(r0).le.pieni) goto 790
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 790
          endif
          im=irm(ix)
          r0a=one
          benkr=ed(ix)/(one+dpp)
          cr(1)=one
          cr(2)=xl
          ci(2)=zl
          cxzyr=xl
          cxzyi=zl
          cxzr=cxzyr
          cxzi=cxzyi
          dyy1=zero
          dyy2=zero
          qu=zero
          qv=zero
          lmin=3
          if(nmz.eq.1) lmin=2
          do 370 l=lmin,mmul
            aa(l)=zero
            bb(l)=zero
            cr(l)=zero
  370     ci(l)=zero
          do 380 l=1,nmz
          l1=l-1
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
          if(l.gt.2) then
            cxzyrr=cxzyr*cxzr-cxzyi*cxzi
            cxzyi=cxzyr*cxzi+cxzyi*cxzr
            cxzyr=cxzyrr
            cr(l)=cxzyr
            ci(l)=cxzyi
          endif
!hr03     dyy1=dyy1+bb(l)*cr(l)+aa(l)*ci(l)
          dyy1=(dyy1+bb(l)*cr(l))+aa(l)*ci(l)                            !hr03
!hr03     dyy2=dyy2-bb(l)*ci(l)+aa(l)*cr(l)
          dyy2=(dyy2-bb(l)*ci(l))+aa(l)*cr(l)                            !hr03
          if(l.gt.1.and.ium.ne.1) then
!hr03       qu=qu+l1*(bb(l)*cr(l1)+aa(l)*ci(l1))
            qu=qu+dble(l1)*(bb(l)*cr(l1)+aa(l)*ci(l1))                   !hr03
!hr03       qv=qv+l1*(bb(l)*ci(l1)-aa(l)*cr(l1))
            qv=qv+dble(l1)*(bb(l)*ci(l1)-aa(l)*cr(l1))                   !hr03
          endif
  380     continue
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
          izu=izu+2*mmul-2*nmz
          do 390 iv=2,5
!hr03       tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
            tiltck=tiltc(k)**2-tilts(k)**2                               !hr03
!hr03       tiltsk=two*tiltc(k)*tilts(k)
            tiltsk=(two*tiltc(k))*tilts(k)                               !hr03
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck4=tiltckuk
            tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
            tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck6=tiltckuk
            tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
            tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck8=tiltckuk
            tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
            tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck10=tiltckuk
            if(iv.eq.2) then
!hr03         ekk= tiltck4* bb(4)                     +                 &
!hr03&tiltsk4*(             -aa(4)       )+                             &
!hr03&4  *tiltck4*(bb(5) *cr(2)+aa(5) *ci(2))+                          &
!hr03&4  *tiltsk4*(bb(5) *ci(2)-aa(5) *cr(2))+                          &
!hr03&10 *tiltck4*(bb(6) *cr(3)+aa(6) *ci(3))+                          &
!hr03&10 *tiltsk4*(bb(6) *ci(3)-aa(6) *cr(3))+                          &
!hr03&20 *tiltck4*(bb(7) *cr(4)+aa(7) *ci(4))+                          &
!hr03&20 *tiltsk4*(bb(7) *ci(4)-aa(7) *cr(4))+                          &
!hr03&35 *tiltck4*(bb(8) *cr(5)+aa(8) *ci(5))+                          &
!hr03&35 *tiltsk4*(bb(8) *ci(5)-aa(8) *cr(5))+                          &
!hr03&56 *tiltck4*(bb(9) *cr(6)+aa(9) *ci(6))+                          &
!hr03&56 *tiltsk4*(bb(9) *ci(6)-aa(9) *cr(6))+                          &
!hr03&84 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7))+                          &
!hr03&84 *tiltsk4*(bb(10)*ci(7)-aa(10)*cr(7))
              ekk= ((((((((((((tiltck4* bb(4)                     -     &!hr03
     &tiltsk4*(             aa(4)       ))+                             &!hr03
     &4d0  *tiltck4*(bb(5) *cr(2)+aa(5) *ci(2)))+                       &!hr03
     &4d0  *tiltsk4*(bb(5) *ci(2)-aa(5) *cr(2)))+                       &!hr03
     &10d0 *tiltck4*(bb(6) *cr(3)+aa(6) *ci(3)))+                       &!hr03
     &10d0 *tiltsk4*(bb(6) *ci(3)-aa(6) *cr(3)))+                       &!hr03
     &20d0 *tiltck4*(bb(7) *cr(4)+aa(7) *ci(4)))+                       &!hr03
     &20d0 *tiltsk4*(bb(7) *ci(4)-aa(7) *cr(4)))+                       &!hr03
     &35d0 *tiltck4*(bb(8) *cr(5)+aa(8) *ci(5)))+                       &!hr03
     &35d0 *tiltsk4*(bb(8) *ci(5)-aa(8) *cr(5)))+                       &!hr03
     &56d0 *tiltck4*(bb(9) *cr(6)+aa(9) *ci(6)))+                       &!hr03
!hr03&56d0 *tiltsk4*(bb(9) *ci(6)-aa(9) *cr(6)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltsk4*(bb(10)*ci(7)-aa(10)*cr(7))
            endif
            if(iv.eq.3) then
!hr03         ekk= tiltck6* bb(6)                     +                 &
!hr03&tiltsk6*(            -aa(6)       )+                              &
!hr03&6  *tiltck6*(bb(7) *cr(2)+aa(7) *ci(2))+                          &
!hr03&6  *tiltsk6*(bb(7) *ci(2)-aa(7) *cr(2))+                          &
!hr03&21 *tiltck6*(bb(8) *cr(3)+aa(8) *ci(3))+                          &
!hr03&21 *tiltsk6*(bb(8) *ci(3)-aa(8) *cr(3))+                          &
!hr03&56 *tiltck6*(bb(9) *cr(4)+aa(9) *ci(4))+                          &
!hr03&56 *tiltsk6*(bb(9) *ci(4)-aa(9) *cr(4))+                          &
!hr03&126*tiltck6*(bb(10)*cr(5)+aa(10)*ci(5))+                          &
!hr03&126*tiltsk6*(bb(10)*ci(5)-aa(10)*cr(5))
              ekk= ((((((((tiltck6* bb(6)                     -         &!hr03
     &tiltsk6*(             aa(6)       ))+                             &!hr03
     &6d0  *tiltck6*(bb(7) *cr(2)+aa(7) *ci(2)))+                       &!hr03
     &6d0  *tiltsk6*(bb(7) *ci(2)-aa(7) *cr(2)))+                       &!hr03
     &21d0 *tiltck6*(bb(8) *cr(3)+aa(8) *ci(3)))+                       &!hr03
     &21d0 *tiltsk6*(bb(8) *ci(3)-aa(8) *cr(3)))+                       &!hr03
     &56d0 *tiltck6*(bb(9) *cr(4)+aa(9) *ci(4)))+                       &!hr03
     &56d0 *tiltsk6*(bb(9) *ci(4)-aa(9) *cr(4)))+                       &!hr03
     &126d0*tiltck6*(bb(10)*cr(5)+aa(10)*ci(5)))+                       &!hr03
     &126d0*tiltsk6*(bb(10)*ci(5)-aa(10)*cr(5))
            endif
            if(iv.eq.4) then
!hr03         ekk= tiltck8* bb(8)                     +                 &
!hr03&tiltsk8*(            -aa(8)       )+                              &
!hr03&8  *tiltck8*(bb(9) *cr(2)+aa(9) *ci(2))+                          &
!hr03&8  *tiltsk8*(bb(9) *ci(2)-aa(9) *cr(2))+                          &
!hr03&36 *tiltck8*(bb(10)*cr(3)+aa(10)*ci(3))+                          &
!hr03&36 *tiltsk8*(bb(10)*ci(3)-aa(10)*cr(3))
              ekk= ((((tiltck8* bb(8)                     -             &!hr03
     &tiltsk8*(             aa(8)       ))+                             &!hr03
     &8d0  *tiltck8*(bb(9) *cr(2)+aa(9) *ci(2)))+                       &!hr03
     &8d0  *tiltsk8*(bb(9) *ci(2)-aa(9) *cr(2)))+                       &!hr03
     &36d0 *tiltck8*(bb(10)*cr(3)+aa(10)*ci(3)))+                       &!hr03
     &36d0 *tiltsk8*(bb(10)*ci(3)-aa(10)*cr(3))
            endif
            if(iv.eq.5) then
              ekk= tiltck10*bb(10)-tiltsk10*aa(10)
            endif
            call detune(iv,ekk,ep,beta,dtu,dtup,dfac)
  390     continue
          goto 510
!--SKEW ELEMENTS
  400     kzz=-kzz
          goto(410,420,430,440,450,460,470,480,490,500),kzz
          goto 790
!--VERTICAL DIPOLE
  410     ekk=ekk*c1e3
        mpe=20
!hr02   dyy1=-ekk*tilts(k)
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr02
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
          goto 510
!--SKEW QUADRUPOLE
  420     continue
        dyy1=ekk*(tiltc(k)*zl-tilts(k)*xl)
        dyy2=ekk*(tiltc(k)*xl+tilts(k)*zl)
        mpe=2
        mx=-1
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
          goto 510
!--SKEW SEXTUPOLE
  430     ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*zl-tiltsk*xl)
        qu=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
!hr02   qv=-ekk*two*(tiltck*xl+tiltsk*zl)
        qv=((-1d0*ekk)*two)*(tiltck*xl+tiltsk*zl)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltsk
        ab2(3)=ekk*tiltck
          goto 510
!--SKEW OCTUPOLE
  440     ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
!hr02   qv=-three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*three)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*zl-tiltsk*xl)
        ab1(3)=(three*ekk)*(tiltck*zl-tiltsk*xl)                         !hr02
!hr02   ab2(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab2(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltsk
        ab2(4)=ekk*tiltck
          goto 510
!--SKEW DECAPOLE
  450     ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                   !hr02
!hr02   ab2(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*four)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*zl-tiltsk*xl)
        ab1(4)=(four*ekk)*(tiltck*zl-tiltsk*xl)                          !hr02
!hr02   ab2(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab2(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltsk
        ab2(5)=ekk*tiltck
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW DODECAPOLE
  460     ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*zl-tiltsk*xl)
        ab1(5)=(5d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab2(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltsk
        ab2(6)=ekk*tiltck
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 14-POLE
  470     ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=15*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(15d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*zl-tiltsk*xl)
        ab1(6)=(6d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab2(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltsk
        ab2(7)=ekk*tiltck
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 16-POLE
  480     ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*zl-tiltsk*xl)
        ab1(7)=(7d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab2(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltsk
        ab2(8)=ekk*tiltck
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 18-POLE
  490     ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyi-tiltsk5*cxzyr)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyi-tiltsk5*cxzyr)                  !hr02
!hr02   ab2(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab2(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*zl-tiltsk*xl)
        ab1(8)=(8d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab2(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltsk
        ab2(9)=ekk*tiltck
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 20-POLE
  500     ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr08     tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
!hr03     ekk=-ekko*tiltsk10
          ekk=(-1d0*ekko)*tiltsk10                                       !hr03
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
!hr03     ekk=36*ekko*(tiltck8*cxzyi-tiltsk8*cxzyr)
          ekk=(36d0*ekko)*(tiltck8*cxzyi-tiltsk8*cxzyr)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
!hr03     ekk=126*ekko*(tiltck6*cxzyi-tiltsk6*cxzyr)
          ekk=(126d0*ekko)*(tiltck6*cxzyi-tiltsk6*cxzyr)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
!hr03     ekk=84*ekko*(tiltck4*cxzyi-tiltsk4*cxzyr)
          ekk=(84d0*ekko)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
  510     continue
          t(1,2)=t(1,2)+dyy1
          t(1,4)=t(1,4)+dyy2
          do 520 i=2,ium
          if(kzz.eq.24) then
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*quz-qvz*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
!hr02       crkve=t(i,2)-t(i,1)*qu*qv
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
!hr02       cikve=t(i,4)-t(i,3)*qu*qv
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
!hr02       t(i,2)=crkve*cos(qv)+cikve*sin(qv)
!hr02       t(i,4)=-crkve*sin(qv)+cikve*cos(qv)
!hr02       crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
!hr02       cikve=-t(i,1)*sin(qv)+t(i,3)*cos(qv)
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
          else
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*qu-qv*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  520     continue
          do 530 l=1,2
            ll=2*l
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
  530     clop0(l)=t(1,ll)
          if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 790
          if(mpe.lt.nta) goto 790
          if(mpe.gt.nte) mpe=nte
          if(nta.gt.2) goto 550
          if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.  &
     &mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 550
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          do 540 l=2,nmz
            l1=l-1
!hr06  540     ab2(2)=ab2(2)+l1*(aa(l)*cr(l1)-bb(l)*ci(l1))
  540     ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550     b1=beta(1)
          b2=beta(2)
          sb1=sqrt(b1)
          sb2=sqrt(b2)
          b(3,1)=b1
          b(1,3)=b2
          b(2,2)=sb1*sb2
          if(nta.gt.3) goto 570
          if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 700
          if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx &
     &.eq.6.or.mx.eq.7) goto 570
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 560 l=3,nmz
            l1=l-2
!hr06       ab1(3)=ab1(3)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(3)=ab2(3)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  560     l2=l2*l/l1
  570     b(4,1)=b1*sb1
          b(1,4)=b2*sb2
          b(3,2)=b1*sb2
          b(2,3)=b2*sb1
          if(nta.gt.4) goto 590
          if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 700
          if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx &
     &.eq.7) goto 590
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 580 l=4,nmz
            l1=l-3
!hr06       ab1(4)=ab1(4)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(4)=ab2(4)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  580     l2=l2*l/l1
!hr06  590     b(5,1)=b1*b1
  590     b(5,1)=b1**2                                                   !hr06
!hr06     b(1,5)=b2*b2
          b(1,5)=b2**2                                                   !hr06
          b(4,2)=b(3,2)*sb1
          b(2,4)=b(2,3)*sb2
          b(3,3)=b1*b2
          if(nta.gt.5) goto 610
          if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 700
          if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)      &
     &goto 610
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 600 l=5,nmz
            l1=l-4
!hr06       ab1(5)=ab1(5)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(5)=ab2(5)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  600     l2=l2*l/l1
  610     b(6,1)=b(5,1)*sb1
          b(1,6)=b(1,5)*sb2
          b(5,2)=b(4,2)*sb1
          b(2,5)=b(2,4)*sb2
          b(4,3)=b(4,2)*sb2
          b(3,4)=b(2,4)*sb1
          if(nta.gt.6) goto 630
          if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 700
          if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 630
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 620 l=6,nmz
            l1=l-5
!hr06       ab1(6)=ab1(6)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(6)=ab2(6)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  620     l2=l2*l/l1
  630     b(7,1)=b(6,1)*sb1
          b(1,7)=b(1,6)*sb2
          b(6,2)=b(5,2)*sb1
          b(2,6)=b(2,5)*sb2
          b(5,3)=b(5,2)*sb2
          b(3,5)=b(2,5)*sb1
          b(4,4)=b(3,4)*sb1
          if(nta.gt.7) goto 650
          if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 700
          if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 650
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 640 l=7,nmz
            l1=l-6
!hr06       ab1(7)=ab1(7)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(7)=ab2(7)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  640     l2=l2*l/l1
  650     b(8,1)=b(7,1)*sb1
          b(1,8)=b(1,7)*sb2
          b(7,2)=b(7,1)*sb2
          b(2,7)=b(1,7)*sb1
          b(6,3)=b(5,3)*sb1
          b(3,6)=b(3,5)*sb2
          b(5,4)=b(4,4)*sb1
          b(4,5)=b(4,4)*sb2
          if(nta.gt.8) goto 670
          if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 700
          if(mx.eq.6.or.mx.eq.7) goto 670
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 660 l=8,nmz
            l1=l-7
!hr06       ab1(8)=ab1(8)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(8)=ab2(8)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  660     l2=l2*l/l1
  670     b(9,1)=b(8,1)*sb1
          b(1,9)=b(1,8)*sb2
          b(8,2)=b(8,1)*sb2
          b(2,8)=b(1,8)*sb1
          b(7,3)=b(7,2)*sb2
          b(3,7)=b(2,7)*sb1
          b(6,4)=b(6,3)*sb2
          b(4,6)=b(3,6)*sb1
          b(5,5)=b(4,5)*sb1
          if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 700
          if(mx.eq.7) goto 690
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
          l2=1
          do 680 l=9,nmz
            l1=l-8
!hr06       ab1(9)=ab1(9)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
            ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
!hr06       ab2(9)=ab2(9)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
            ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  680     l2=l2*l/l1
  690     b(10,1)=b(9,1)*sb1
          b(1,10)=b(1,9)*sb2
          b(9,2)=b(9,1)*sb2
          b(2,9)=b(1,9)*sb1
          b(8,3)=b(8,2)*sb2
          b(3,8)=b(2,8)*sb1
          b(4,7)=b(3,7)*sb1
          b(7,4)=b(7,3)*sb2
          b(5,6)=b(4,6)*sb1
          b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  700     do 720 np=1,mpe
            n2e=2*np
            do 710 nv=1,n2e
              n2=nv-np
              nn2=abs(n2)
              nn1=np-nn2
!hr06         re1=nn1*qxt+n2*qzt
              re1=dble(nn1)*qxt+dble(n2)*qzt                             !hr06
              ip(np,nv)=int(re1+half)+ipc
!hr06         if(-re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipc
              if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipc
!--RE=DISTANCE FROM THE RESONANCE
              re(np,nv)=re1-dble(ip(np,nv))
              res=re(np,nv)/radi
!hr06         chy(np,nv)=cos_rn(nn1*pie*phi(1)+n2*pie*phi(2)-res*etl)
          chy(np,nv)=cos_rn((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))- &!hr06
     &res*etl)                                                           !hr06
!hr06         shy(np,nv)=sin_rn(nn1*pie*phi(1)+n2*pie*phi(2)-res*etl)
          shy(np,nv)=sin_rn((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))- &!hr06
     &res*etl)                                                           !hr06
  710       continue
  720     continue
          do 780 np=nta,mpe
            np2=np
            nkk=0
  730       nkk=nkk+1
            n2e=2*np2
            do 770 i=1,nkk
              do 760 nv=1,n2e
                nn2=abs(nv-np2)
                nv1=np2-nn2+(i-1)*2+1
                nv2=np-nv1+2
!hr06           rn2=nn2*half
                rn2=dble(nn2)*half                                       !hr06
!--EVENESS OF N2
                mm=0
                gerad=rn2-aint(rn2)
                if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
                if (mm.eq.0) goto 740
                btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
                goto 750
  740           btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
  750           rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
                rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  760         continue
  770       continue
            np2=np2-2
            if(np2.ge.1) goto 730
  780     continue
          nr=nr+1
  790   continue
        nnf(1)=1
        nnf(2)=1
        nnf(3)=2
        nz2(2)=2
        sea=sqrt(ep(1))
        seb=sqrt(ep(2))
        ea=ep(1)
        eb=ep(2)
        e(3,1)=one/eb
        e(1,3)=one/ea
!hr06   e(2,2)=one/seb/sea
        e(2,2)=(one/seb)/sea                                             !hr06
        nnf(4)=6
        nz2(3)=4
        e(4,1)=sea/eb
        e(1,4)=seb/ea
        e(3,2)=one/seb
        e(2,3)=one/sea
        nnf(5)=24
        nz2(4)=8
        e(5,1)=ea/eb
        e(1,5)=eb/ea
        e(4,2)=sea/seb
        e(2,4)=seb/sea
        e(3,3)=one
        nnf(6)=120
        nz2(5)=16
        e(6,1)=e(5,1)*sea
        e(1,6)=e(1,5)*seb
        e(5,2)=ea/seb
        e(2,5)=eb/sea
        e(4,3)=sea
        e(3,4)=seb
        nnf(7)=720
        nz2(6)=32
        e(7,1)=e(6,1)*sea
        e(1,7)=e(1,6)*seb
        e(6,2)=e(5,2)*sea
        e(2,6)=e(2,5)*seb
        e(5,3)=ea
        e(3,5)=eb
        e(4,4)=sea*seb
        nnf(8)=5040
        nz2(7)=64
        e(8,1)=e(7,1)*sea
        e(1,8)=e(1,7)*seb
        e(7,2)=e(6,2)*sea
        e(2,7)=e(2,6)*seb
        e(6,3)=ea*sea
        e(3,6)=eb*seb
        e(5,4)=ea*seb
        e(4,5)=sea*eb
        nnf(9)=40320
        nz2(8)=128
        e(9,1)=e(8,1)*sea
        e(1,9)=e(1,8)*seb
        e(8,2)=e(7,2)*sea
        e(2,8)=e(2,7)*seb
!hr06   e(7,3)=ea*ea
        e(7,3)=ea**2                                                     !hr06
!hr06   e(3,7)=eb*eb
        e(3,7)=eb**2                                                     !hr06
        e(6,4)=e(5,4)*sea
        e(4,6)=e(4,5)*seb
        e(5,5)=ea*eb
        nnf(10)=362880
        nz2(9)=256
        e(10,1)=e(9,1)*sea
        e(1,10)=e(1,9)*seb
        e(9,2)=e(8,2)*sea
        e(2,9)=e(2,8)*seb
        e(8,3)=e(7,3)*sea
        e(3,8)=e(3,7)*seb
        e(7,4)=e(6,4)*sea
        e(4,7)=e(4,6)*seb
        e(6,5)=e(5,5)*sea
        e(5,6)=e(5,5)*seb
        write(*,10000)
        write(*,10030)
        write(*,10010) nr,'END     ',etl,zero,(beta(l),alfa(l),phi(l),  &
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
        write(*,10030)
        write(*,10110) etl,qwc(1),qwc(2)
        write(*,10030)
        do 800 iv=2,5
          gtu1=gtu1+dtu(1,iv)
          gtu2=gtu2+dtu(2,iv)
  800   continue
        write(*,10150) dtu(1,2),dtu(1,3),dtu(1,4),dtu(1,5),gtu1, dtu    &
     &(2,2),dtu(2,3),dtu(2,4),dtu(2,5),gtu2
        do 810 i=1,2
          do 810 j=1,5
            do 810 l=0,4
              do 810 k=0,4
                if(i.eq.2.and.j.eq.1.and.k.eq.1.and.l.eq.1) write       &
     &(*,10160)
                if(abs(dtup(i,j,k,l)).gt.pieni) write(*,                &
     &'(10X,G16.10,3X,I2,2X,I2)') dtup(i,j,k,l),k,l
  810   continue
        write(*,10060)
        write(*,10030)
        do 880 np=nta,nte
          write(*,10080) np
          write(*,10030)
!hr06     vdt1=nnf(np)/(nz2(np)*pi)
          vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                          !hr06
          np2=np
          nkk=0
          write(*,10090) np
          goto 830
  820     write(*,10100) np,np2
  830     nkk=nkk+1
          n2e=2*np2
          do 850 i=1,nkk
            do 840 nv=1,n2e
              n2=nv-np2
              nn2=abs(n2)
              nn1=np2-nn2
!hr06         nv1=nn1+(i-1)*2+1
              nv1=(nn1+(i-1)*2)+1                                        !hr06
!hr06         nv2=np-nv1+2
              nv2=(np-nv1)+2                                             !hr06
              nv11=nv1-1
              nv21=nv2-1
              nf1=nn1+i
              nf3=nkk-i+1
              nf4=nf3+nn2
!hr06         vdt2=vdt1*e(nv1,nv2)/(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4))
          vdt2=vdt1*e(nv1,nv2)/dble(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4))   !hr06
!hr06         vdt3=nn2*ea+nn1*eb
              vdt3=dble(nn2)*ea+dble(nn1)*eb                             !hr06
              vdt4=vdt3
!hr06         if(n2.ge.0) vdt3=n2*nv21*ea+nn1*nv11*eb
              if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb        !hr06
              rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
              rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  840       continue
  850     continue
          do 870 nv=1,n2e
            mis=1
            rc=zero
            rs=zero
            do 860 i=1,nkk
!hr06         rc=rc+mis*rtc(np2,nv,np,i)
              rc=rc+dble(mis)*rtc(np2,nv,np,i)                           !hr06
!hr06         rs=rs+mis*rts(np2,nv,np,i)
              rs=rs+dble(mis)*rts(np2,nv,np,i)                           !hr06
              mis=-mis
  860       continue
!hr06       sdel2=sqrt(rc*rc+rs*rs)
            sdel2=sqrt(rc**2+rs**2)                                      !hr06
            n22=nv-np2
            write(*,10140) n22,ip(np2,nv),ipc,rc,rs,re(np2,nv),sdel2
  870     continue
          np2=np2-2
          if(np2.ge.1) goto 820
  880   continue
        ntx=nte-2
        write(*,10130)
        do 930 np=1,nte
          write(*,10090) np
          n2e=2*np
          do 920 nv=1,n2e
            n2=nv-np
            nkk=2
            nph=np+2
            min1=-1
  890       min2=min1
            do 900 i=1,nkk
!hr06         rtc(np,nv,np,1)=rtc(np,nv,np,1)+min2*rtc(np,nv,nph,i)
             rtc(np,nv,np,1)=rtc(np,nv,np,1)+dble(min2)*rtc(np,nv,nph,i) !hr06
!hr06         rts(np,nv,np,1)=rts(np,nv,np,1)+min2*rts(np,nv,nph,i)
             rts(np,nv,np,1)=rts(np,nv,np,1)+dble(min2)*rts(np,nv,nph,i) !hr06
              min2=-min2
  900       continue
            nph=nph+2
            if(nph.gt.nte) goto 910
            nkk=nkk+1
            min1=-min1
            goto 890
  910       cc=rtc(np,nv,np,1)
            ss=rts(np,nv,np,1)
!hr06       sdel=sqrt(cc*cc+ss*ss)
            sdel=sqrt(cc**2+ss**2)                                       !hr06
            write(*,10140) n2,ip(np,nv),ipc,cc,ss,re(np,nv),sdel
  920     continue
  930   continue
  940 continue
      call clorb(ded)
      do 950 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  950 continue
      call clorb(zero)
      do 960 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  960 continue
!-----------------------------------------------------------------------
      return
10000 format(1x,i4,27x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x, &
     &f6.3,1x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x,f6.3)
10020 format(t5,'---- ENTRY SUBRES ----')
10030 format(131('-'))
10040 format('  NR  TYP      L-TOTAL  LENGTH   BETAH  ALFAH  ',         &
     &' PHIH   DISH  DISPH   CLOH  CLOPH',                              &
     &'   BETAV  ALFAV   PHIV   DISV  DISPV   CLOV  CLOPV'/ 1x,         &
     &'                 (M)      (M)     (M)           ',               &
     &'(QE)   (M)   (RAD)   (MM) (MRAD)',                               &
     &'    (M)           (QE)   (M)   (RAD)   (MM) (MRAD)')
10050 format(//7x,'INIT. X-AMPLITUDE=',g15.8,'X-EMITTANCE=',g15.8,/40x, &
     &/7x,'INIT. Y-AMPLITUDE=',g15.8,'Y-EMITTANCE=',g15.8,              &
     &'UNITS ARE (PI X MM X MRAD)'//)
10060 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x)
10070 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7)
10080 format(/10x,'RESONANCE EXCITING MULTIPOLE-ORDER = ',i2)
10090 format(//20x,'RESONANCE-ORDER =',i2/20x,100('-')/ 20x,'| NY |',   &
     &'   P  | D-P |',2x,'DRIVING-COS ',3x,'|', 2x,'DRIVING-SIN ',3x,'|'&
     &, 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10100 format(//20x,'RESONANCE-ORDER =',i2,5x,'SUBRESONANCE-ORDER = ',i2,&
     &/20x,100('-')/ 20x,'| NY |','   P  | D-P |',2x,'DRIVING-COS ',3x, &
     &'|', 2x,'DRIVING-SIN ',3x,'|', 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10110 format(/10x,'PRECISE LENGTH OF THE MACHINE : ',f43.33/ /10x,      &
     &'   PRECISE HORIZONTAL Q-VALUE : ',f43.33/ /10x,                  &
     &'     PRECISE VERTICAL Q-VALUE : ',f43.33/)
10120 format(t8,'  PLANE     DISP(MM)     DISP(MRAD)   '/ t6,'      X  '&
     &,2(f12.3,3x)/t10,'  Y  ',2(f12.3,3x)/)
10130 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x,    &
     &'!!!! ALL SUBRESONANCES ARE INCLUDED !!!! ')
10140 format(20x,'| ',i2,' | ',i4,' | ',i3,' |', g16.8,' |',g16.8,' |', &
     &g16.8,' |',g16.8,' |')
10150 format(/10x,'NONLINEAR DETUNING  '// 10x,'CHANGE IN QX'/ 10x,     &
     &' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ 10x,' 8. ORDER ',f15&
     &.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  ',f15.12/ 10x,       &
     &'CHANGE IN QY'/ 10x,' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ &
     &10x,' 8. ORDER ',f15.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  '&
     &,f15.12// 10x,'DETUNING ORDER BY ORDER'// 10x,                    &
     &'Qx - COEFFICIENT   Ex  EY'/ 10x,'-------------------------')
10160 format(/ 10x,'Qy - COEFFICIENT   Ex  Ey'/ 10x,                    &
     &'-------------------------')
10010 format(1x,i4,1x,a8,1x,f8.2,1x,f7.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.&
     &2,1x,f6.3,1x,f6.2,1x,f6.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6. &
     &3,1x,f6.2,1x,f6.3)
      end
      subroutine detune(iv,ekk,ep,beta,dtu,dtup,dfac)
!-----------------------------------------------------------------------
!  USED FOR SUBRE - CALCULATES DETUNING
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer iv,iv2,iv3,iv4,iv5,iv6
      double precision beta,dfac,dtu,dtu1,dtu2,dtup,ekk,ep,pi,vor,vtu1, &
     &vtu2
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension dfac(10),dtu(2,5),ep(2),beta(2),dtup(2,5,0:4,0:4)
      save
!-----------------------------------------------------------------------
      if(iv.lt.2) then
        write(*,*)
        write(*,*) '       ***** ERROR IN DETUNE *****'
        write(*,*)
        write(*,*) '       IV LESS THAN 2, NO DETUNING POSSIBLE'
        write(*,*)
        return
      endif
      pi=four*atan_rn(one)
      iv2=2*iv
      iv3=iv+1
!hr06 vtu1=-ekk*(half**iv2)*dfac(iv2)/pi
!      vtu1=(((-1d0*ekk)*(half**iv2))*dfac(iv2))/pi                       !hr06
!hr13 vtu1=(((-1d0*ekk)*exp_rn(iv2*log_rn(half)))*dfac(iv2))/pi           !yil11
      vtu1=(((-1d0*ekk)*exp_rn(dble(iv2)*log_rn(half)))*dfac(iv2))/pi    !hr13
      dtu1=zero
      dtu2=zero
      do 10 iv4=1,iv3
        iv5=iv4-1
        iv6=iv-iv5
        vor=one
!hr06   if(mod(iv6,2).ne.0) vor=-one
        if(mod(iv6,2).ne.0) vor=-1d0*one                                 !hr06
!        vtu2=vor/(dfac(iv5+1)**2)/(dfac(iv6+1)**2)*(beta(1)**iv5)* (beta&
!     &(2)**iv6)
!hr13   vtu2=vor/(dfac(iv5+1)**2)/(dfac(iv6+1)**2)*                     & !yil11
!hr13&exp_rn(iv5*log_rn(beta(1)))*exp_rn(iv6*log_rn(beta(2)))
        vtu2=(((vor/(dfac(iv5+1)**2))/(dfac(iv6+1)**2))*                &!hr13
     &exp_rn(dble(iv5)*log_rn(beta(1))))*                               &!hr13
     &exp_rn(dble(iv6)*log_rn(beta(2)))                                  !hr13
        if(iv5.ne.0) then
!hr06     dtu1=dtu1+vtu2*iv5*(ep(1)**(iv5-1))*(ep(2)**iv6)
!          dtu1=dtu1+((vtu2*dble(iv5))*(ep(1)**(iv5-1)))*(ep(2)**iv6)     !hr06
!hr13     dtu1=dtu1+((vtu2*dble(iv5))*exp_rn((iv5-1)*log_rn(ep(1))))*   & !yil11
!hr13&         exp_rn(iv6*log_rn(ep(2)))
         dtu1=dtu1+((vtu2*dble(iv5))*exp_rn(dble(iv5-1)*log_rn(ep(1))))*&!hr13
     &         exp_rn(dble(iv6)*log_rn(ep(2)))                           !hr13
!hr06     dtup(1,iv,iv5-1,iv6)=dtup(1,iv,iv5-1,iv6)+vtu2*iv5*vtu1
         dtup(1,iv,iv5-1,iv6)=dtup(1,iv,iv5-1,iv6)+(vtu2*dble(iv5))*vtu1 !hr06
        endif
        if(iv6.ne.0) then
!hr06     dtu2=dtu2+vtu2*iv6*(ep(1)**iv5)*(ep(2)**(iv6-1))
!          dtu2=dtu2+((vtu2*dble(iv6))*(ep(1)**iv5))*(ep(2)**(iv6-1))     !hr06
!hr13     dtu2=dtu2+((vtu2*dble(iv6))*exp_rn(iv5*log_rn(ep(1))))*       & !yil11
!hr13&                exp_rn((iv6-1)*log_rn(ep(2)))
          dtu2=dtu2+((vtu2*dble(iv6))*exp_rn(dble(iv5)*log_rn(ep(1))))* &!hr13
     &                exp_rn(dble(iv6-1)*log_rn(ep(2)))                  !hr13
!hr06     dtup(2,iv,iv5,iv6-1)=dtup(2,iv,iv5,iv6-1)+vtu2*iv6*vtu1
         dtup(2,iv,iv5,iv6-1)=dtup(2,iv,iv5,iv6-1)+(vtu2*dble(iv6))*vtu1 !hr06
        endif
   10 continue
      dtu(1,iv)=dtu(1,iv)+vtu1*dtu1
      dtu(2,iv)=dtu(2,iv)+vtu1*dtu2
      return
      end
      subroutine subsea(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR SEARCH
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jm,k,k1,kpz,kzz,l,l1,    &
     &l2,ll,lmin,mm,mpe,mx,n2,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,   &
     &np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,   &
     &chy,ci,cikve,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dphi,dpp,  &
     &dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,phy,pie, &
     &puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,    &
     &vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue
      do 40 i=1,10
        nnf(i)=0
        do 40 j=1,18
          ip(i,j)=0
          re(i,j)=zero
   40 continue
      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue
      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
   70       continue
   80     continue
   90   continue
  100 continue
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb2(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
      do 110 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
  110 t(1,ll)=clop(l)
      do 120 i=1,4
        do 120 j=1,4
          t(i+1,j)=ta(j,i)
  120 t(i+1,j)=ta(j,i)
!--EP=EMITTANCE IN PI*MM*MRAD
!hr06 ep(1)=tam1*tam1/beta(1)
      ep(1)=tam1**2/beta(1)                                              !hr06
!hr06 ep(2)=tam2*tam2/beta(2)
      ep(2)=tam2**2/beta(2)                                              !hr06
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 740 k=1,iu
        do 130 k1=1,10
          ab1(k1)=zero
  130   ab2(k1)=zero
        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 740
!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do 150 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do 150 i=1,ium
  150     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 160 l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
!hr06       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr06
  160     phi(l)=phi(l)+dphi
          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr06         t(i,ll-1)=puf*a(jk,l,1)+t(i,ll)*a(jk,l,2)+dpr(i)*a(jk,l,5)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
!hr06         t(i,ll)=puf*a(jk,l,3)+t(i,ll)*a(jk,l,4)+dpr(i)*a(jk,l,6)
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
!hr06       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
!hr06       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-phibf(l)
            endif
!hr06       if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 740
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 740
        kzz=kz(ix)
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
!hr03         t(i,ll-1)=puf*rrtr(imtr(ix),ll-1,ll-1)+                   &
!hr03&t(i,ll)*rrtr(imtr(ix),ll-1,ll)+                                   &
!hr03&dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
!hr03         t(i,ll)=puf*rrtr(imtr(ix),ll,ll-1)+                       &
!hr03&t(i,ll)*rrtr(imtr(ix),ll,ll)+                                     &
!hr03&dpr(i)*rrtr(imtr(ix),ll,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
!hr03       beta(l)=t(ll,ll-1)*t(ll,ll-1)+t(ll+1,ll-1)*t(ll+1,ll-1)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
!hr03       alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
!hr08         dphi=-phibf(l)
              dphi=-1d0*phibf(l)                                         !hr08
            endif
!hr03       if(-dphi.gt.pieni) dphi=dphi+pi
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
            phi(l)=phi(l)+dphi
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 740
! JBG RF CC Multipoles to 740
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 740
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 740
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
!hr02   zl=-(t(1,1)-xs)*tilts(k)+(t(1,3)-zs)*tiltc(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
        if(kzz.lt.0) goto 350
        goto(220,230,240,250,260,270,280,290,300,310,320,740,740,740,   &
     &      740,740,740,740,740,740,740,740,740,315,316,740,740,740),kzz
        goto 740
!--HORIZONTAL DIPOLE
  220   ekk=ekk*c1e3
        mpe=20
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
        goto 460
!--NORMAL QUADRUPOLE
  230   continue
        dyy1=ekk*(tiltc(k)*xl+tilts(k)*zl)
!hr08   dyy2=ekk*(-tiltc(k)*zl+tilts(k)*xl)
        dyy2=ekk*(tilts(k)*xl-tiltc(k)*zl)                               !hr08
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
!hr02   qv=-ekk*tiltsk
        qv=(-1d0*ekk)*tiltsk                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        goto 460
!--NORMAL SEXTUPOLE
  240   ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*xl+tiltsk*zl)
        qu=(ekk*two)*(tiltck*xl+tiltsk*zl)                               !hr02
!hr02   qv=ekk*two*(tiltck*zl-tiltsk*xl)
        qv=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltck
        ab2(3)=ekk*tiltsk
        goto 460
!--NORMAL OCTUPOLE
  250   ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(three*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                       !hr02
!hr02   qv=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab1(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
!hr02   ab2(3)=three*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(3)=(three*ekk)*(tiltsk*xl-tiltck*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltck
        ab2(4)=ekk*tiltsk
        goto 460
!--NORMAL DECAPOLE
  260   ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
!hr02   ab2(3)=6*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(6d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(four*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
!hr02   qv=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab1(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
!hr02   ab2(4)=four*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(4)=(four*ekk)*(tiltsk*xl-tiltck*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltck
        ab2(5)=ekk*tiltsk
        goto 460
!--NORMAL DODECAPOLE
  270   ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=10*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(10d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=10*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(10d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab1(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(5)=5*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(5)=(5d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltck
        ab2(6)=ekk*tiltsk
        goto 460
!--NORMAL 14-POLE
  280   ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=20*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(20d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(5)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(5)=15*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(5)=(15d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab1(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(6)=6*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(6)=(6d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltck
        ab2(7)=ekk*tiltsk
        goto 460
!--NORMAL 16-POLE
  290   ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=21*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(21d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=35*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(35d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=35*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(35d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=21*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(21d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab1(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(7)=7*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(7)=(7d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltck
        ab2(8)=ekk*tiltsk
        goto 460
!--NORMAL 18-POLE
  300   ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
!hr02   ab2(7)=28*ekk*(-tiltck5*cxzyi+tiltsk5*cxzyr)
        ab2(7)=(28d0*ekk)*(tiltsk5*cxzyr-tiltck5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
!hr02   ab2(6)=56*ekk*(-tiltck4*cxzyi+tiltsk4*cxzyr)
        ab2(6)=(56d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
!hr02   ab2(5)=70*ekk*(-tiltck3*cxzyi+tiltsk3*cxzyr)
        ab2(5)=(70d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
!hr02   ab2(4)=56*ekk*(-tiltck2*cxzyi+tiltsk2*cxzyr)
        ab2(4)=(56d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
!hr02   ab2(3)=28*ekk*(-tiltck1*cxzyi+tiltsk1*cxzyr)
        ab2(3)=(28d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab1(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
!hr02   ab2(8)=8*ekk*(-tiltck*zl+tiltsk*xl)
        ab2(8)=(8d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltck
        ab2(9)=ekk*tiltsk
        goto 460
!--NORMAL 20-POLE
  310   ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qu=(9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
!hr02   qv=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr02   dyy2=ekk*(-tiltc(k)*cxzyi+tilts(k)*cxzyr)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        goto 460
!--DIPEDGE ELEMENT
  315   continue
!hr02   dyy1=(ed(IX)*tiltc(k)*xl-ek(IX)*tilts(k)*zl)/(one+dpp)
        dyy1=((ed(IX)*tiltc(k))*xl-(ek(IX)*tilts(k))*zl)/(one+dpp)       !hr02
!hr02   dyy2=(ek(IX)*tiltc(k)*zl+ed(IX)*tilts(k)*xl)/(one+dpp)
        dyy2=((ek(IX)*tiltc(k))*zl+(ed(IX)*tilts(k))*xl)/(one+dpp)       !hr02
        mpe=20
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ed(IX)*tiltck/(one+dpp)
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
!hr02   qv=-ed(IX)*tiltsk/(one+dpp)
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
!hr02   quz=-ek(IX)*tiltck/(one+dpp)
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
!hr02   qvz=ek(IX)*tiltsk/(one+dpp)
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
        goto 460
!--solenoid
  316   continue
!hr02       crkve=y(1,1)-x(1,1)*ed(IX)*ek(IX)/(one+dpp)
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       cikve=y(1,2)-x(1,2)*ed(IX)*ek(IX)/(one+dpp)
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
!hr02       dyy1=crkve*cos(ek(IX)/(one+dpp))+                           &
!hr02&cikve*sin(ek(IX)/(one+dpp))-y(1,1)
!hr02       dyy2=-crkve*sin(ek(IX)/(one+dpp))+                          &
!hr02&cikve*cos(ek(IX)/(one+dpp))-y(1,2)
            dyy1=(crkve*cos_rn(ek(IX))/(one+dpp))+                      &!hr02
     &(cikve*sin_rn(ek(IX))/(one+dpp))-y(1,1)                            !hr02
            dyy2=cikve*cos_rn(ek(IX)/(one+dpp))-                        &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp))-y(1,2)                              !hr02
        mpe=20
        qu=ed(IX)
        qv=ek(IX)
        goto 460
  320   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=-dki(ix,1)/dki(ix,3)*dki(ix,1)/(one+dpp)
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)+(qu*xl-dppi*dpp)*tilts(k)                     &
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            do 323 i=2,ium
!hr08         t(i,2)=t(i,2)+qu*t(i,1)*tiltc(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
!hr08         t(i,4)=t(i,4)+qu*t(i,3)*tilts(k)
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
  323       continue
          else
!hr03       dppi=c1e3*dki(ix,1)/(one+dpp)
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tiltc(k)                             &
!hr03&+dppi*(one-tiltc(k))
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
!hr03       t(1,4)=t(1,4)-dppi*dpp*tilts(k)                             &
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
!hr03       qu=dki(ix,2)/dki(ix,3)*dki(ix,2)/(one+dpp)
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)+(qu*zl-dppi*dpp)*tilts(k)                     &
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+(-qu*zl+dppi*dpp)*tiltc(k)                    &
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
            do 326 i=2,ium
!hr03         t(i,2)=t(i,2)+qu*t(i,1)*tilts(k)
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
!hr03         t(i,4)=t(i,4)-qu*t(i,3)*tiltc(k)
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
  326       continue
          else
!hr03       dppi=c1e3*dki(ix,2)/(one+dpp)
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
!hr03       t(1,2)=t(1,2)-dppi*dpp*tilts(k)                             &
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
!hr03       t(1,4)=t(1,4)+dppi*dpp*tiltc(k)                             &
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
          endif
        endif
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 740
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 740
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2
        do 330 l=lmin,mmul
          cr(l)=zero
  330   ci(l)=zero
        do 340 l=1,nmz
          l1=l-1
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
!hr03     aa(l)=benkr*aa(l)/r0a
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
!hr03     bb(l)=benkr*bb(l)/r0a
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
          if(l.gt.2) then
            cxzyrr=cxzyr*cxzr-cxzyi*cxzi
            cxzyi=cxzyr*cxzi+cxzyi*cxzr
            cxzyr=cxzyrr
            cr(l)=cxzyr
            ci(l)=cxzyi
          endif
!hr03     dyy1=dyy1+bb(l)*cr(l)+aa(l)*ci(l)
          dyy1=(dyy1+bb(l)*cr(l))+aa(l)*ci(l)                            !hr03
!hr03     dyy2=dyy2-bb(l)*ci(l)+aa(l)*cr(l)
          dyy2=(dyy2-bb(l)*ci(l))+aa(l)*cr(l)                            !hr03
          if(l.gt.1.and.ium.ne.1) then
!hr03       qu=qu+l1*(bb(l)*cr(l1)+aa(l)*ci(l1))
            qu=qu+dble(l1)*(bb(l)*cr(l1)+aa(l)*ci(l1))                   !hr03
!hr03       qv=qv+l1*(bb(l)*ci(l1)-aa(l)*cr(l1))
            qv=qv+dble(l1)*(bb(l)*ci(l1)-aa(l)*cr(l1))                   !hr03
          endif
  340   continue
!hr03   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
!hr03   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
!hr06   izu=izu+2*mmul-2*nmz
        izu=(izu+2*mmul)-2*nmz                                           !hr06
        goto 460
!--SKEW ELEMENTS
  350   kzz=-kzz
        goto(360,370,380,390,400,410,420,430,440,450),kzz
        goto 740
!--VERTICAL DIPOLE
  360   ekk=ekk*c1e3
        mpe=20
!hr02   dyy1=-ekk*tilts(k)
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr02
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
        goto 460
!--SKEW QUADRUPOLE
  370   continue
        dyy1=ekk*(tiltc(k)*zl-tilts(k)*xl)
        dyy2=ekk*(tiltc(k)*xl+tilts(k)*zl)
        mpe=2
        mx=-1
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=-ekk*tiltsk
        qu=(-1d0*ekk)*tiltsk                                             !hr02
!hr02   qv=-ekk*tiltck
        qv=(-1d0*ekk)*tiltck                                             !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        goto 460
!--SKEW SEXTUPOLE
  380   ekk=ekk*c1m3
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=ekk*two*(tiltck*zl-tiltsk*xl)
        qu=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
!hr02   qv=-ekk*two*(tiltck*xl+tiltsk*zl)
        qv=((-1d0*ekk)*two)*(tiltck*xl+tiltsk*zl)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltsk
        ab2(3)=ekk*tiltck
        goto 460
!--SKEW OCTUPOLE
  390   ekk=ekk*c1m6
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=three*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
!hr02   qv=-three*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*three)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(3)=three*ekk*(tiltck*zl-tiltsk*xl)
        ab1(3)=(three*ekk)*(tiltck*zl-tiltsk*xl)                         !hr02
!hr02   ab2(3)=three*ekk*(tiltck*xl+tiltsk*zl)
        ab2(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltsk
        ab2(4)=ekk*tiltck
        goto 460
!--SKEW DECAPOLE
  400   ekk=ekk*c1m9
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
!hr02   ab1(3)=6*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                   !hr02
!hr02   ab2(3)=6*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=four*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-four*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=((-1d0*four)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(4)=four*ekk*(tiltck*zl-tiltsk*xl)
        ab1(4)=(four*ekk)*(tiltck*zl-tiltsk*xl)                          !hr02
!hr02   ab2(4)=four*ekk*(tiltck*xl+tiltsk*zl)
        ab2(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltsk
        ab2(5)=ekk*tiltck
        goto 460
!--SKEW DODECAPOLE
  410   ekk=ekk*c1m12
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
!hr02   ab1(4)=10*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=10*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=10*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=10*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=5*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-5*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(5)=5*ekk*(tiltck*zl-tiltsk*xl)
        ab1(5)=(5d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(5)=5*ekk*(tiltck*xl+tiltsk*zl)
        ab2(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltsk
        ab2(6)=ekk*tiltck
        goto 460
!--SKEW 14-POLE
  420   ekk=ekk*c1m15
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
!hr02   ab1(5)=15*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=15*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=20*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=20*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=15*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(15d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=15*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=6*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
!hr02   qv=-6*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(6)=6*ekk*(tiltck*zl-tiltsk*xl)
        ab1(6)=(6d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(6)=6*ekk*(tiltck*xl+tiltsk*zl)
        ab2(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltsk
        ab2(7)=ekk*tiltck
        goto 460
!--SKEW 16-POLE
  430   ekk=ekk*c1m18
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
!hr02   ab1(6)=21*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=21*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=35*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=35*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=35*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=35*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=21*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=21*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=7*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-7*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(7)=7*ekk*(tiltck*zl-tiltsk*xl)
        ab1(7)=(7d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(7)=7*ekk*(tiltck*xl+tiltsk*zl)
        ab2(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltsk
        ab2(8)=ekk*tiltck
        goto 460
!--SKEW 18-POLE
  440   ekk=ekk*c1m21
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
!hr02   ab1(7)=28*ekk*(tiltck5*cxzyi-tiltsk5*cxzyr)
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyi-tiltsk5*cxzyr)                  !hr02
!hr02   ab2(7)=28*ekk*(tiltck5*cxzyr+tiltsk5*cxzyi)
        ab2(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(6)=56*ekk*(tiltck4*cxzyi-tiltsk4*cxzyr)
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
!hr02   ab2(6)=56*ekk*(tiltck4*cxzyr+tiltsk4*cxzyi)
        ab2(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(5)=70*ekk*(tiltck3*cxzyi-tiltsk3*cxzyr)
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
!hr02   ab2(5)=70*ekk*(tiltck3*cxzyr+tiltsk3*cxzyi)
        ab2(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(4)=56*ekk*(tiltck2*cxzyi-tiltsk2*cxzyr)
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
!hr02   ab2(4)=56*ekk*(tiltck2*cxzyr+tiltsk2*cxzyi)
        ab2(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   ab1(3)=28*ekk*(tiltck1*cxzyi-tiltsk1*cxzyr)
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
!hr02   ab2(3)=28*ekk*(tiltck1*cxzyr+tiltsk1*cxzyi)
        ab2(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr02   qu=8*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-8*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
!hr02   ab2(2)=-qv
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
!hr02   ab1(8)=8*ekk*(tiltck*zl-tiltsk*xl)
        ab1(8)=(8d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
!hr02   ab2(8)=8*ekk*(tiltck*xl+tiltsk*zl)
        ab2(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltsk
        ab2(9)=ekk*tiltck
        goto 460
!--SKEW 20-POLE
  450   ekk=ekk*c1m24
        mpe=20
        cxzr=xl
        cxzi=zl
!hr08   cxzyr=cxzr*cxzr-cxzi*cxzi
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
!hr08   tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
!hr02   tiltsk=two*tiltc(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
!hr02   qu=9*ekk*(tiltck*cxzyi-tiltsk*cxzyr)
        qu=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
!hr02   qv=-9*ekk*(tiltck*cxzyr+tiltsk*cxzyi)
        qv=(-9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
  460   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 470 i=2,ium
          if(kzz.eq.24) then
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*quz-qvz*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
!hr02       crkve=t(i,2)-t(i,1)*qu*qv
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
!hr02       cikve=t(i,4)-t(i,3)*qu*qv
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
!hr02       t(i,2)=crkve*cos(qv)+cikve*sin(qv)
!hr02       t(i,4)=-crkve*sin(qv)+cikve*cos(qv)
!hr02       crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
!hr02       cikve=-t(i,1)*sin(qv)+t(i,3)*cos(qv)
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
          else
!hr06       t(i,2)=t(i,2)+t(i,1)*qu-qv*t(i,3)
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
!hr06       t(i,4)=t(i,4)-t(i,3)*qu-qv*t(i,1)
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  470   continue
        do 480 l=1,2
          ll=2*l
!hr06     alfa(l)=-(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
          alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
  480   continue
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 740
        if(mpe.lt.nta) goto 740
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 500
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx  &
     &.eq.5.or.mx.eq.6.or.mx.eq.7) goto 500
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do 490 l=2,nmz
          l1=l-1
!hr06  490   ab2(2)=ab2(2)+l1*(aa(l)*cr(l1)-bb(l)*ci(l1))
  490   ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
  500   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 520
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 650
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 520
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 510 l=3,nmz
          l1=l-2
!hr06     ab1(3)=ab1(3)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(3)=ab2(3)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  510   l2=l2*l/l1
  520   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 540
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 650
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 540
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 530 l=4,nmz
          l1=l-3
!hr06     ab1(4)=ab1(4)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(4)=ab2(4)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  530   l2=l2*l/l1
!hr06  540   b(5,1)=b1*b1
  540   b(5,1)=b1**2                                                     !hr06
!hr06   b(1,5)=b2*b2
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 560
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 650
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 560
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 550 l=5,nmz
          l1=l-4
!hr06     ab1(5)=ab1(5)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(5)=ab2(5)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550   l2=l2*l/l1
  560   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 580
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 650
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 570 l=6,nmz
          l1=l-5
!hr06     ab1(6)=ab1(6)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(6)=ab2(6)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  570   l2=l2*l/l1
  580   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 600
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 650
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 590 l=7,nmz
          l1=l-6
!hr06     ab1(7)=ab1(7)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(7)=ab2(7)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  590   l2=l2*l/l1
  600   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 620
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 650
        if(mx.eq.6.or.mx.eq.7) goto 620
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 610 l=8,nmz
          l1=l-7
!hr06     ab1(8)=ab1(8)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(8)=ab2(8)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  610   l2=l2*l/l1
  620   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 650
        if(mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do 630 l=9,nmz
          l1=l-8
!hr06     ab1(9)=ab1(9)+l2*(aa(l)*ci(l1)+bb(l)*cr(l1))
          ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
!hr06     ab2(9)=ab2(9)+l2*(aa(l)*cr(l1)-bb(l)*ci(l1))
          ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  630   l2=l2*l/l1
  640   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  650   do 670 np=1,mpe
          n2e=2*np
          do 660 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
!hr06       re1=nn1*qxt+n2*qzt
            re1=dble(nn1)*qxt+dble(n2)*qzt                               !hr06
            ip(np,nv)=int(re1+half)+ipt
!hr06       if(-re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
            if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt      !hr06
!--RE=DISTANCE FROM THE RESONANCE
!hr06       re(np,nv)=re1-ip(np,nv)
            re(np,nv)=re1-dble(ip(np,nv))                                !hr06
            res=re(np,nv)/radi
!hr06       chy(np,nv)=cos_rn(nn1*phi(1)+n2*phi(2)-res*etl)
           chy(np,nv)=cos_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
!hr06       shy(np,nv)=sin_rn(nn1*phi(1)+n2*phi(2)-res*etl)
           shy(np,nv)=sin_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
  660     continue
  670   continue
        do 730 np=nta,mpe
          np2=np
          nkk=0
  680     nkk=nkk+1
          n2e=2*np2
          do 720 i=1,nkk
            do 710 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
!hr06         rn2=nn2*half
              rn2=dble(nn2)*half                                         !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 690
!hr06         btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
!hr06         bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 700
!hr06  690         btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
  690         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
!hr06         bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  700         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  710       continue
  720     continue
          np2=np2-2
          if(np2.ge.1) goto 680
  730   continue
  740 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
!hr06 e(2,2)=one/seb/sea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
!hr06 e(7,3)=ea*ea
      e(7,3)=ea**2                                                       !hr06
!hr06 e(3,7)=eb*eb
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 780 np=nta,nte
!hr06   vdt1=nnf(np)/(nz2(np)*pi)
        vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                            !hr06
        np2=np
        nkk=0
  750   nkk=nkk+1
        n2e=2*np2
        do 770 i=1,nkk
          do 760 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
!hr06       vdt2=vdt1*e(nv1,nv2)/(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4))
            vdt2=vdt1*e(nv1,nv2)/dble(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4)) !hr06
!hr06       vdt3=nn2*ea+nn1*eb
            vdt3=dble(nn2)*ea+dble(nn1)*eb                               !hr06
!hr06       if(n2.ge.0) vdt3=n2*nv21*ea+nn1*nv11*eb
            if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb          !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  760     continue
  770   continue
        np2=np2-2
        if(np2.ge.1) goto 750
  780 continue
      return
      end
      subroutine decoup
!-----------------------------------------------------------------------
!  DECOUPLING USING MATRIX ELEMENTS
!
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ierr,j,no
      double precision aa,bb,d1,dpp,dsm,qw,qwc,sen,sn,ss
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      dimension aa(6,6),bb(6),dsm(6),sn(6),sen(6),ss(6)
      dimension qwc(3),qw(2),d1(6)
      save
!-----------------------------------------------------------------------
      do 10 i=1,6
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero
        do 10 j=1,6
          aa(i,j)=zero
   10 continue
      do 20 i=1,3
        qwc(i)=zero
   20 continue
      dpp=zero
      write(*,10000)
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      sen(1)=ta(3,1)
      sen(2)=ta(3,2)
      sen(3)=ta(4,1)
      sen(4)=ta(4,2)
      if(iskew.eq.1) then
        sen(5)=qwc(1)
        sen(6)=qwc(2)
      endif
      do 30 i=1,6
        if(iskew.eq.2.and.i.gt.4) goto 30
        if(i.le.4) then
          sn(i)=ed(nskew(i))
          dsm(i)=dsm0
          bb(i)=sen(i)
        else
          if (abs(el(nskew(i))).le.pieni) then
            sn(i)=ed(nskew(i))
          else
            sn(i)=ek(nskew(i))
          endif
          dsm(i)=dkq
          bb(i)=sen(i)-qwsk(i-4)
        endif
        ss(i)=sen(i)
   30 continue
      do 100 no=1,itcro
        do 40 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 40
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))+dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))+dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))+dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
          call betalf(dpp,qw)
          call phasad(dpp,qwc)
          aa(i,1)=(ta(3,1)-ss(1))/dsm(i)
          aa(i,2)=(ta(3,2)-ss(2))/dsm(i)
          aa(i,3)=(ta(4,1)-ss(3))/dsm(i)
          aa(i,4)=(ta(4,2)-ss(4))/dsm(i)
          if(iskew.eq.1) then
            aa(i,5)=(qwc(1)-ss(5))/dsm(i)
            aa(i,6)=(qwc(2)-ss(6))/dsm(i)
          endif
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))-dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   40   continue
        if(iskew.eq.1) then
          call loesd(aa,bb,6,6,ierr)
        else if(iskew.eq.2) then
          call loesd(aa,bb,4,4,ierr)
        endif
        if(ierr.eq.1) call prror(64)
        do 50 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 50
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-bb(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-bb(i)
            else
              ek(nskew(i))=ek(nskew(i))-bb(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   50   continue
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        ss(1)=ta(3,1)
        ss(2)=ta(3,2)
        ss(3)=ta(4,1)
        ss(4)=ta(4,2)
        if(iskew.eq.1) then
          ss(5)=qwc(1)
          ss(6)=qwc(2)
        endif
        write(*,10010)
        write(*,10020) no,sen(1),ss(1),sen(2),ss(2),sen(3),ss(3), sen   &
     &(4),ss(4)
        write(*,10030) bez(nskew(1)),sn(1),ed(nskew(1)),bez(nskew(2)),sn&
     &(2),ed(nskew(2)),bez(nskew(3)),sn(3),ed(nskew(3)), bez            &
     &(nskew(4)),sn(4),ed(nskew(4))
        if(iskew.eq.1) then
          write(*,10010)
          write(*,10040) qwsk(1),qwc(1),qwsk(2),qwc(2)
          if (abs(el(nskew(5))).le.pieni) then
            write(*,10060) sn(5),ed(nskew(5)),nskew(5),sn(6),ed         &
     &(nskew(6)), nskew(6)
          else
            write(*,10060) sn(5),ek(nskew(5)),nskew(5),sn(6),ek         &
     &(nskew(6)), nskew(6)
          endif
        else if(iskew.eq.2) then
          write(*,10010)
          write(*,10050) qwc(1),qwc(2)
        endif
        do 60 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 60
          if(i.le.4) then
            d1(i)=abs(ss(i))
          else
            d1(i)=abs(ss(i)-qwsk(i-4))
          endif
   60   continue
        do 70 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 70
          if(d1(i).gt.dsi) goto 80
   70   continue
        return
   80   do 90 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 90
          if(i.le.4) then
            bb(i)=ss(i)
          else
            bb(i)=ss(i)-qwsk(i-4)
          endif
   90   continue
  100 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY DECOUP ----')
10010 format(131('-'))
10020 format(/10x,'DECOUPLING ROUTINE  ITERATION #',i2// 30x,           &
     &'BEFORE         AFTER     DECOUPLING'// 17x,'   M(3,1)      ',2g15&
     &.5/ 17x,'   M(3,2)      ',2g15.5/ 17x,'   M(4,1)      ',2g15.5/ 17&
     &x,'   M(4,2)      ',2g15.5// 5x,'SKEW QUDRUPOLE STRENGTHS')
10040 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10050 format(10x,'CURRENT TUNE' / 10x,'Q-VALUE'/ 10x,'HORIZONTAL     ', &
     &g15.7/ 10x,'VERTICAL       ',g15.7/)
10060 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10030 format(14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,          &
     &g16.10/14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,g16.10)
      end
      subroutine postpr(nfile)
!-----------------------------------------------------------------------
!  POST PROCESSING
!
!  NFILE   :  FILE UNIT
!
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,iconv,icow,icr,idis,iffw,ifh,imad,ipos,ires,iskip,    &
     &istw,itf,ivox,ivoz,iwg,kwtype,ndafi,nprint,nstart,nstop
      double precision cma1,cma2,dfft,dphix,dphiz,dres,qx0,qz0
      real hmal
      character*80 toptit,sixtit,commen
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/pawc/hmal(nplo)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer icode,idam,its6d
      double precision dpscor,sigcor
      common/corcom/dpscor,sigcor,icode,idam,its6d
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      common/phasecom/ phase(3,npos+1)
      common/invari/ dani(ninv+1)
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!-----                                                                   -----
!-----    NEW BLOCKS PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----        G. ROBERT-DEMOLAIZE, October 27th, 2004                    -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      integer i,i1,i11,i2,i3,ia,ia0,iaa,iab,iap6,iapx,iapz,ich,idnt,    &
     &ierro,idummy,if1,if2,ife,ife2,ifipa,ifp,ii,ilapa,ilyap,im1,im1s,  &
     &invx,invz,iq,iskc,itopa,iturn,ivo6,iwar6,iwarx,iwarz,j,jm1,jm1s,  &
     &jq,k,k1,nerror,nfft,nfile,nivh,nlost,ntwin,nuex,nuez,nuix,nuiz,   &
     &numl
      real tim1,tim2,fxs,fzs
      double precision const,dle,slope,tle,varlea,wgh
      double precision alf0,alf04,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,   &
     &alf0z3,ampx0,ampz0,angi,angii,angiii,ared,ares,armin,armin0,b,b0, &
     &bet0,bet04,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,biav,bold,c, &
     &c0,c1,c6,clo,cloau,clop,cx,cz,d,d0,d1,dani,dared,dares,di0,di0au, &
     &di11,dife,dip0,dizu0,dle1,dle1c,dmmac,dnms,dnumlr,dp1,dph6,dphx,  &
     &dphz,dpx,dpxp,dpz,dpzp,dummy,e,e0,e1,emag,emat,emax,emaz,emi,emig,&
     &emii,emiii,emit,emix,emiz,emt,emta,emts,emx,emx0,emxa,emxs,emz,   &
     &emz0,emza,emzs,evt,evt1,evtm,evtma,evtmi,evx,evx1,evx2,evxm,evxma,&
     &evxmi,evz,evz1,evz2,evzm,evzma,evzmi,f,f0,f1,ffx,ffz,finv,g,g0,g1,&
     &gam0s1,gam0s2,gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,h, &
     &h0,h1,p,p1,pcha,phase,pieni2,pinx,pinz,pixr,pizr,pmax,pmin,prec,  &
     &qs0,qwc,ratemx,ratemz,rbeta,s6,sdp6,sdpx,sdpz,sevt,sevx,sevz,     &
     &slopem,sumda,sx,sz,t,ta,ta16,ta26,ta36,ta46,ta56,ta61,ta62,ta63,  &
     &ta64,ta65,tasum,tidnt,tle1,tlo,tph6,tphx,tphz,tpi,txyz,txyz2,x,   &
     &xing,xinv,xp,xp0,xxaux,xxmax,xxmin,xxi,xxr,xyzv,xyzv2,zing,zinv,  &
     &zp,zp0,zzaux,zzmax,zzmin,zzi,zzr
      character*80 title(20),chxtit(20),chytit(20)
      character*8 cdate,ctime,progrm
      character*11 hvs
      character*8192 ch
      character*25 ch1
      integer errno,l1,l2
      integer dtostr
      dimension tle(nlya),dle(nlya)
      dimension wgh(nlya),biav(nlya),slope(nlya),varlea(nlya)
      dimension xinv(ninv),invx(ninv),zinv(ninv),invz(ninv)
      dimension xxr(npos),xxi(npos),zzr(npos),zzi(npos),fxs(npos),      &
     &fzs(npos)
      dimension bet0(3),alf0(3),t(6,6)
      dimension bet04(2),alf04(2)
      dimension pmin(30),pmax(30)
      dimension idummy(6)
      dimension sumda(60)
      dimension x(2,6),cloau(6),di0au(4)
      dimension qwc(3),clo(3),clop(3),di0(2),dip0(2)
      dimension ta(6,6),txyz(6),txyz2(6),xyzv(6),xyzv2(6),rbeta(6)
      character*8 version
      character*10 moddate
      integer itot,ttot
      data version /'4.5.35'/
      data moddate /'13.06.2016'/
      save
!----------------------------------------------------------------------
!--TIME START
      pieni2=1d-8
      tlim=1e7
      call timest(tlim)
      tim1=0.
      call timex(tim1)
      do 10 i=1,npos
        do 10 j=1,3
          phase(j,i)=zero
   10 continue
      do 20 i=1,2
        bet04(i)=zero
        alf04(i)=zero
        di0(i)=zero
        dip0(i)=zero
        di0au(i)=zero
        di0au(i+2)=zero
   20 continue
      do 30 i=1,3
        bet0(i)=zero
        alf0(i)=zero
        qwc(i)=zero
        clo(i)=zero
        clop(i)=zero
   30 continue
      do 40 i=1,ninv
        invx(i)=0
        invz(i)=0
        xinv(i)=zero
        zinv(i)=zero
        dani(i)=zero
   40 continue
      dani(ninv+1)=zero
      do 50 i=1,npos
        xxr(i)=zero
        xxi(i)=zero
        zzr(i)=zero
        zzi(i)=zero
        fxs(i)=0.0
        fzs(i)=0.0
   50 continue
      do 60 i=1,6
        txyz(i)=zero
        txyz2(i)=zero
        xyzv(i)=zero
        xyzv2(i)=zero
        rbeta(i)=zero
        cloau(i)=zero
        x(1,i)=zero
        x(2,i)=zero
   60 continue
      do 70 i=1,6
        do 70 j=1,6
          t(i,j)=zero
          ta(i,j)=zero
   70 continue
      do 80 i=1,30
        pmax(i)=zero
        pmin(i)=zero
   80 continue
      do 90 i=1,20
        title(i)=' '
        chxtit(i)=' '
        chytit(i)=' '
   90 continue
      do 100 i=1,nlya
        tle(i)=zero
        dle(i)=zero
        slope(i)=zero
        varlea(i)=zero
        wgh(i)=zero
        biav(i)=zero
  100 continue
      do 110 i=1,60
        sumda(i)=zero
  110 continue
      itot=0
      ttot=0
      do i=1,8
        if (version(i:i).ne.' ') then
          if (version(i:i).ne.'.') then
            itot=itot*10+ichar(version(i:i))-ichar('0')
          else
            ttot=ttot*10**2+itot
            itot=0
          endif
        endif
      enddo
      ttot=ttot*10**2+itot
!hr06 sumda(52)=float(ttot)
      sumda(52)=dble(ttot)                                               !hr06
! and put CPU time for Massimo
! so even if we go to 550 we now get the stats
      sumda(60)=dble(trtime)
      b0=zero
      nlost=0
      ntwin=1
      nfft=1
      do 120 j=1,npos
        if(nfft.gt.npos/2) goto 130
        nfft=nfft*2
  120 continue
  130 continue
!----------------------------------------------------------------------
!--READING HEADER
!----------------------------------------------------------------------
      rewind nfile
      ia=0
      read(nfile,end=510,iostat=ierro) sixtit,commen,cdate,ctime,       &
     &progrm,ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1), &
     &clop(1),clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0 &
     &(2),dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), &
     &ta(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2), &
     &ta(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4), &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta(5,6), &
     &ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6), dmmac,dnms,dizu0,&
     &dnumlr,sigcor,dpscor
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      sumda(1)=numl
      idam=1
      if(icode.eq.1.or.icode.eq.2.or.icode.eq.4) idam=1
      if(icode.eq.3.or.icode.eq.5.or.icode.eq.6) idam=2
      if(icode.eq.7) idam=3
      if(ilapa.ne.ifipa) ntwin=2
      if(imad.eq.1.and.progrm.eq.'MAD') then
        imad=0
        rewind nfile
        call join
        read(nfile,end=520,iostat=ierro) sixtit,commen,cdate,ctime,     &
     &progrm,ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo     &
     &(1),clop(1),clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0     &
     &(2),dip0(2),dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta       &
     &(1,5),ta(1,6), ta(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6),   &
     &ta(3,1),ta(3,2),ta(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta       &
     &(4,2),ta(4,3),ta(4,4),ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),   &
     &ta(5,4),ta(5,5),ta(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta       &
     &(6,5),ta(6,6), dmmac,dnms,dizu0,dnumlr,sigcor,dpscor
        ta(1,6)=ta(1,6)*c1e3
        ta(2,6)=ta(2,6)*c1e3
        ta(3,6)=ta(3,6)*c1e3
        ta(4,6)=ta(4,6)*c1e3
        ta(5,6)=ta(5,6)*c1e3
        ta(6,1)=ta(6,1)*c1m3
        ta(6,2)=ta(6,2)*c1m3
        ta(6,3)=ta(6,3)*c1m3
        ta(6,4)=ta(6,4)*c1m3
        ta(6,5)=ta(6,5)*c1m3
        if(ierro.gt.0) then
          write(*,10320) nfile
          goto 550
        endif
      endif
!--PREVENT FAULTY POST-PROCESSING
      read(nfile,end=530,iostat=ierro) iaa
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      read(nfile,end=535,iostat=ierro) iab
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
!hr06 600  if((numl+1)/iskip/(iab-iaa)/iav.gt.nlya) nstop=iav*nlya
 600  if((((numl+1)/iskip)/(iab-iaa))/iav.gt.nlya) nstop=iav*nlya        !hr06
      rewind nfile
      read(nfile)
!hr06 sumda(5)=ta(1,1)*ta(1,1)+ta(1,2)*ta(1,2)
      sumda(5)=ta(1,1)**2+ta(1,2)**2                                     !hr06
!hr06 sumda(6)=ta(3,3)*ta(3,3)+ta(3,4)*ta(3,4)
      sumda(6)=ta(3,3)**2+ta(3,4)**2                                     !hr06
      if(iconv.eq.1) then
        cma1=one
        cma2=one
        clo(1)=zero
        clo(2)=zero
        clo(3)=zero
        clop(1)=zero
        clop(2)=zero
        clop(3)=zero
        di0(1)=zero
        di0(2)=zero
        dip0(1)=zero
        dip0(2)=zero
        do 140 i=1,6
          do 140 j=1,6
            if(i.ne.j) then
              ta(i,j)=zero
            else
              ta(i,j)=one
            endif
  140   continue
      endif
      cloau(1)= clo(1)
      cloau(2)=clop(1)
      cloau(3)= clo(2)
      cloau(4)=clop(2)
      cloau(5)= clo(3)
      cloau(6)=clop(3)
      di0au(1)= di0(1)
      di0au(2)=dip0(1)
      di0au(3)= di0(2)
      di0au(4)=dip0(2)
      sigcor=cma2
      dpscor=cma1
      sumda(53)= clo(1)
      sumda(54)=clop(1)
      sumda(55)= clo(2)
      sumda(56)=clop(2)
      sumda(57)= clo(3)
      sumda(58)=clop(3)
      if(ifipa.eq.ilapa.and.ndafi.gt.itopa) ndafi=itopa
      if(ilapa-ifipa.eq.1.and.ndafi.gt.itopa/2) ndafi=itopa/2
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      ta16=ta(1,6)*c1m3
      ta26=ta(2,6)*c1m3
      ta36=ta(3,6)*c1m3
      ta46=ta(4,6)*c1m3
      ta56=ta(5,6)*c1m3
      ta61=ta(6,1)*c1e3
      ta62=ta(6,2)*c1e3
      ta63=ta(6,3)*c1e3
      ta64=ta(6,4)*c1e3
      ta65=ta(6,5)*c1e3
!hr06 bet0(1)=ta(1,1)*ta(1,1)+ta(1,2)*ta(1,2)
      bet0(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
!hr06 bet0x2 =ta(1,3)*ta(1,3)+ta(1,4)*ta(1,4)
      bet0x2 =ta(1,3)**2+ta(1,4)**2                                      !hr06
!hr06 bet0x3 =ta(1,5)*ta(1,5)+ta16*ta16
      bet0x3 =ta(1,5)**2+ta16**2                                         !hr06
!hr06 gam0x1 =ta(2,1)*ta(2,1)+ta(2,2)*ta(2,2)
      gam0x1 =ta(2,1)**2+ta(2,2)**2                                      !hr06
!hr06 gam0x2 =ta(2,3)*ta(2,3)+ta(2,4)*ta(2,4)
      gam0x2 =ta(2,3)**2+ta(2,4)**2                                      !hr06
!hr06 gam0x3 =ta(2,5)*ta(2,5)+ta26*ta26
      gam0x3 =ta(2,5)**2+ta26**2                                         !hr06
!hr06 alf0(1)=-(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))
      alf0(1)=-1d0*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
!hr06 alf0x2 =-(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))
      alf0x2 =-1d0*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
!hr06 alf0x3 =-(ta(1,5)*ta(2,5)+ta16*ta26)
      alf0x3 =-1d0*(ta(1,5)*ta(2,5)+ta16*ta26)                           !hr06
!hr06 bet0(2)=ta(3,3)*ta(3,3)+ta(3,4)*ta(3,4)
      bet0(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
!hr06 bet0z2 =ta(3,1)*ta(3,1)+ta(3,2)*ta(3,2)
      bet0z2 =ta(3,1)**2+ta(3,2)**2                                      !hr06
!hr06 bet0z3 =ta(3,5)*ta(3,5)+ta36*ta36
      bet0z3 =ta(3,5)**2+ta36**2                                         !hr06
!hr06 gam0z1 =ta(4,3)*ta(4,3)+ta(4,4)*ta(4,4)
      gam0z1 =ta(4,3)**2+ta(4,4)**2                                      !hr06
!hr06 gam0z2 =ta(4,1)*ta(4,1)+ta(4,2)*ta(4,2)
      gam0z2 =ta(4,1)**2+ta(4,2)**2                                      !hr06
!hr06 gam0z3 =ta(4,5)*ta(4,5)+ta46*ta46
      gam0z3 =ta(4,5)**2+ta46**2                                         !hr06
!hr06 alf0(2)=-(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))
      alf0(2)=-1d0*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
!hr06 alf0z2 =-(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))
      alf0z2 =-1d0*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
!hr06 alf0z3 =-(ta(3,5)*ta(4,5)+ta36*ta46)
      alf0z3 =-1d0*(ta(3,5)*ta(4,5)+ta36*ta46)                           !hr06
!hr06 bet0(3)=ta(5,5)*ta(5,5)+ta56*ta56
      bet0(3)=ta(5,5)**2+ta56**2                                         !hr06
!hr06 bet0s2 =ta(5,1)*ta(5,1)+ta(5,2)*ta(5,2)
      bet0s2 =ta(5,1)**2+ta(5,2)**2                                      !hr06
!hr06 bet0s3 =ta(5,3)*ta(5,3)+ta(5,4)*ta(5,4)
      bet0s3 =ta(5,3)**2+ta(5,4)**2                                      !hr06
!hr06 gam0s1 =ta65*ta65+ta(6,6)*ta(6,6)
      gam0s1 =ta65**2+ta(6,6)**2                                         !hr06
!hr06 gam0s2 =ta61*ta61+ta62*ta62
      gam0s2 =ta61**2+ta62**2                                            !hr06
!hr06 gam0s3 =ta63*ta63+ta64*ta64
      gam0s3 =ta63**2+ta64**2                                            !hr06
!hr06 alf0(3)=-(ta(5,5)*ta65+ta56*ta(6,6))
      alf0(3)=-1d0*(ta(5,5)*ta65+ta56*ta(6,6))                           !hr06
!hr06 alf0s2 =-(ta(5,1)*ta61+ta(5,2)*ta62)
      alf0s2 =-1d0*(ta(5,1)*ta61+ta(5,2)*ta62)                           !hr06
!hr06 alf0s3 =-(ta(5,3)*ta63+ta(5,4)*ta64)
      alf0s3 =-1d0*(ta(5,3)*ta63+ta(5,4)*ta64)                           !hr06
      bet04(1)=bet0(1)
      bet04(2)=bet0(2)
      alf04(1)=alf0(1)
      alf04(2)=alf0(2)
      if(bet0(1).le.pieni.or.bet0(2).le.pieni) then
        write(*,*) 'WARNING: BETA VALUES ARE ZERO'
        bet0(1)=zero
        bet0(2)=zero
      endif
      do 135 i=1,3
        ii=2*i
        rbeta(ii-1)=sqrt(bet0(i))
        rbeta(ii)=rbeta(ii-1)
        if(abs(rbeta(ii-1)).lt.pieni) rbeta(ii-1)=one
        if(abs(rbeta(ii)).lt.pieni) rbeta(ii)=one
  135 continue
!----------------------------------------------------------------------
!--SETTING UP OF THE PARAMETERS
!----------------------------------------------------------------------
!--HPLOT TITLES
      if(icode.eq.1) hvs(1:11)='Hor        '
      if(icode.eq.2) hvs(1:11)='    Ver    '
      if(icode.eq.3) hvs(1:11)='Hor Ver    '
      if(icode.eq.4) hvs(1:11)='        Syn'
      if(icode.eq.5) hvs(1:11)='Hor     Syn'
      if(icode.eq.6) hvs(1:11)='    Ver Syn'
      if(icode.eq.7) hvs(1:11)='Hor Ver Syn'
      toptit(2)(1:13)='Particle no. '
      write(toptit(2)(14:16),'(I3)') ifipa
      toptit(2)(17:30)=', Phase Space '
      write(toptit(2)(31:41),'(A11)') hvs
      toptit(2)(42:50)=', Dp/p = '
      toptit(2)(61:80)=' '
      toptit(3)(1:5)='Ax = '
      toptit(3)(16:22)=', Ay = '
      toptit(3)(33:80)=' '
      toptit(4)(1:5)='Qx = '
      write(toptit(4)(6:15),10010) qwc(1)
      toptit(4)(16:22)=', Qy = '
      write(toptit(4)(23:32),10010) qwc(2)
      toptit(4)(33:39)=', Qs = '
      write(toptit(4)(39:48),10010) qwc(3)
      toptit(4)(49:80)=' '
      title(1)='Normalized Distance of Phase Space D as a Function '    &
     &//'of Turn Number N'
      title(2)='Normalized Horizontal Phase Space Projection'
      title(3)='Normalized Vertical Phase Space Projection'
      title(4)='Physical Phase Space Projection'
      title(5)='Synchrotron Phase Space Projection'
      title(6)='Synchrotron versus Horizontal Phase Space '             &
     &//'Projection'
      title(7)='Synchrotron versus Vertical Phase Space '               &
     &//'Projection'
      title(8)='Energy E as a Function of Turn Number N'
      title(9)='Stroboscoped Normalized Horizontal Phase Space '        &
     &//'Projection'
      title(10)='Stroboscoped Normalized Vertical Phase Space '         &
     &//'Projection'
      title(11)='FFT Analysis of the X Coordinate'
      title(12)='FFT Analysis of the Y Coordinate'
      chxtit(1)='N'
      chytit(1)='D (PI rad)'
      chxtit(2)='X (mm)'
      chytit(2)='Normalized Slope of X (mm)'
      chxtit(3)='Y (mm)'
      chytit(3)='Normalized Slope of Y (MM)'
      chxtit(4)='X (mm)'
      chytit(4)='Y (mm)'
      chxtit(5)='Sigma (mm)'
      chytit(5)='Relative Momentum Deviation'
      chxtit(6)='X (mm)'
      chytit(6)='Relative Momentum Deviation'
      chxtit(7)='Y (mm)'
      chytit(7)='Relative Momentum Deviation'
      chxtit(8)='N'
      chytit(8)='E (MeV)'
      chxtit(9)='X (mm)'
      chytit(9)='Normalized Slope of X (mm)'
      chxtit(10)='Y (mm)'
      chytit(10)='Normalized Slope of Y (mm)'
      chxtit(11)='Horizontal Tune Qx'
      chytit(11)='Normalized FFT Signal'
      chxtit(12)='Vertical Tune Qy'
      chytit(12)='Normalized FFT Signal'
      if(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0) then
        call hplsiz(15.,15.,' ')
        call hplset('VSIZ',.24)
        call hplset('ASIZ',.19)
        call hplset('XLAB',1.5)
        call hplset('YLAB',1.0)
        call hplset('GSIZ',.19)
      endif
      if(iav.lt.1) iav=1
      if(nprint.eq.1) then
        write(*,10040) sixtit,commen
        write(*,10050) progrm,ifipa,itopa,hvs,numl,                     &
     &bet0(1),bet0x2,bet0x3,                                            &
     &bet0(2),bet0z2,bet0z3,bet0(3),bet0s2,bet0s3,                      &
     &alf0(1),alf0x2,alf0x3
        write(*,10060) alf0(2),alf0z2,alf0z3,alf0(3),alf0s2,alf0s3,     &
     &gam0x1,gam0x2,gam0x3,                                             &
     &gam0z1,gam0z2,gam0z3,gam0s1,gam0s2,gam0s3,                        &
     &clo(1),clo(2),clo(3),clop(1),clop(2),clop(3),                     &
     &di0(1),di0(2),dip0(1),dip0(2),qwc(1),qwc(2),qwc(3)
        write(*,10070) iav,nstart,nstop,dphix,dphiz,iwg, qx0,qz0
        write(*,10080) ivox,ivoz,ires,dres,ifh,dfft
        write(*,10090) idis,icow,istw,iffw
        write(*,10100) iskip,iconv,imad,cma1,cma2,nprint,ndafi
      endif
!--INITIALISATION
!hr06 tpi=8*atan_rn(one)
      tpi=8d0*atan_rn(one)                                               !hr06
      prec=c1m1
      i1=0
      i11=1
      tlo=zero
      i2=0
      ifp=0
      iwarx=0
      iwarz=0
      iwar6=0
      iapx=0
      iapz=0
      iap6=0
      ivo6=1
      qs0=zero
!hr06 armin0=1e9
      armin0=1d9                                                         !hr06
      armin=armin0
      nivh=ninv/2
!hr06 finv=tpi/ninv
      finv=tpi/dble(ninv)                                                !hr06
      dani(1)=zero
      dani(ninv+1)=tpi
      do 150 i=1,ninv-1
!hr06  150 dani(i+1)=i*finv
  150 dani(i+1)=dble(i)*finv                                             !hr06
      dle1=zero
      bold=zero
      dle1c=zero
      const=zero
      dphx=zero
      dphz=zero
      dph6=zero
      tphx=zero
      tphz=zero
      tph6=zero
      sdpx=zero
      sdpz=zero
      sdp6=zero
      evx=zero
      evz=zero
      evx2=zero
      evz2=zero
      evt=zero
      sevx=zero
      sevz=zero
      sevt=zero
      emax=zero
      emix=zero
      emaz=zero
      emiz=zero
      emag=zero
      emig=zero
      emxa=zero
      emza=zero
      emta=zero
      emxs=zero
      emzs=zero
      emts=zero
      nuex=0
      nuez=0
      nuix=0
      nuiz=0
      xing=zero
      zing=zero
      pinx=zero
      pinz=zero
      pixr=zero
      pizr=zero
!--INVERTING THE MATRIX OF THE GENERATING VECTORS
!     ta = matrix of eigenvectors already normalized, rotated and ordered, units
!     t  = inverse(ta), units mm,mrad,mm,mrad,mm,1
      do 160 i=1,6
        do 160 j=1,6
  160 t(i,j)=ta(j,i)
      if(abs(t(1,1)).le.pieni.and.abs(t(2,2)).le.pieni) then
        t(1,1)=one
        t(2,2)=one
      endif
      if(abs(t(3,3)).le.pieni.and.abs(t(4,4)).le.pieni) then
        t(3,3)=one
        t(4,4)=one
      endif
      if(abs(t(5,5)).le.pieni.and.abs(t(6,6)).le.pieni) then
        t(5,5)=one
        t(6,6)=one
      endif
      tasum=zero
      its6d=0
      do 170 i=1,6
!hr06   tasum=tasum+abs(t(i,5))+abs(t(i,6))
        tasum=(tasum+abs(t(i,5)))+abs(t(i,6))                            !hr06
  170 continue
      do 180 i=1,4
!hr06   tasum=tasum+abs(t(5,i))+abs(t(6,i))
        tasum=(tasum+abs(t(5,i)))+abs(t(6,i))                            !hr06
  180 continue
      tasum=tasum-two
      if(abs(tasum).ge.pieni) its6d=1
      call dinv(6,t,6,idummy,nerror)
      if(nerror.eq.-1) then
        write(*,10290) nfile
        goto 550
      endif
!----------------------------------------------------------------------
!--FIND MINIMUM VALUE OF THE DISTANCE IN PHASESPACE
!----------------------------------------------------------------------
  190 ifipa=0
      if(ntwin.eq.1) read(nfile,end=200,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p
      if(ntwin.eq.2) read(nfile,end=200,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      if(ifipa.lt.1) goto 190
!hr06 if((ia-nstart).lt.zero) goto 190
      if((ia-nstart).lt.0) goto 190                                      !hr06
      if(progrm.eq.'MAD') then
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        h=h*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          h1=h1*c1e3
          p1=p1*c1e3
        endif
      endif
      if(ntwin.eq.2) then
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
!hr06 if(nstop.gt.nstart.and.(ia-nstop).gt.zero) goto 200
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 200                   !hr06
      if(b.lt.b0.or.abs(b0).le.pieni) b0=b
      goto 190
  200 if(ia.le.0) goto 530
      rewind nfile
!----------------------------------------------------------------------
!--GET FIRST DATA POINT AS A REFERENCE
!----------------------------------------------------------------------
      read(nfile,iostat=ierro)
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
  210 ifipa=0
      if(ntwin.eq.1) read(nfile,end=530,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p
      if(ntwin.eq.2) read(nfile,end=530,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      if(ifipa.lt.1) goto 210
      if((ia-nstart).lt.0) goto 210
      if(progrm.eq.'MAD') then
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        g=g*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          g1=g1*c1e3
          p1=p1*c1e3
        endif
      endif
      dp1=h
      write(toptit(2)(51:60),10000) dp1-clop(3)
      if(nprint.eq.1.and.ia.eq.0) then
        write(*,*) 'INITIAL COORDINATES'
        write(*,*) '       X = ',c
        write(*,*) '      XP = ',d
        write(*,*) '       Z = ',e
        write(*,*) '      ZP = ',f
        write(*,*) '   SIGMA = ',g
        write(*,*) '    DP/P = ',h
        write(*,*) '  ENERGY = ',p
      endif
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 540
      ia=ia-nstart
!--LYAPUNOV
      if(ntwin.eq.2) then
!     first particle
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
!     twin particle
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
!--KEEP THE FIRST TURN NUMBER : IA0
      ia0=ia
      xxr(1)=c
      xxi(1)=zero
      zzr(1)=e
      zzi(1)=zero
      c=c-clo(1)
      d=d-clop(1)
      e=e-clo(2)
      f=f-clop(2)
      g=g-clo(3)
      h=h-clop(3)
      c1=c1-clo(1)
      d1=d1-clop(1)
      e1=e1-clo(2)
      f1=f1-clop(2)
      g1=g1-clo(3)
      h1=h1-clop(3)
      if(icode.ge.4) then
        c=c-di0(1)*h
        d=d-dip0(1)*h
        e=e-di0(2)*h
        f=f-dip0(2)*h
        c1=c1-di0(1)*h
        d1=d1-dip0(1)*h
        e1=e1-di0(2)*h
        f1=f1-dip0(2)*h
      endif
!     calculation first particle
!--EMITTANCES
      xp0=bet0(1)*d+alf0(1)*c
      zp0=bet0(2)*f+alf0(2)*e
!hr06 emx=(c*c+xp0*xp0)/bet0(1)
      emx=(c**2+xp0**2)/bet0(1)                                          !hr06
!hr06 emz=(e*e+zp0*zp0)/bet0(2)
      emz=(e**2+zp0**2)/bet0(2)                                          !hr06
      if(icode.ge.4.and.its6d.ne.0) then
        c=c+di0(1)*h
        d=d+dip0(1)*h
        e=e+di0(2)*h
        f=f+dip0(2)*h
        c1=c1+di0(1)*h
        d1=d1+dip0(1)*h
        e1=e1+di0(2)*h
        f1=f1+dip0(2)*h
      endif
      emt=emx+emz
      emax=emx
      emix=emx
      emxa=emx
      emaz=emz
      emiz=emz
      emza=emz
      emat=emt
      emit=emt
      emta=emt
      emx0=emx
      emz0=emz
!--COURANT SYNDER
      xyzv(1)=c
      xyzv(2)=d
      xyzv(3)=e
      xyzv(4)=f
      xyzv(5)=g
      xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
!hr06   xyzv(2)=xyzv(2)*(one+xyzv(6)+clop(3))
        xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                          !hr06
!hr06   xyzv(4)=xyzv(4)*(one+xyzv(6)+clop(3))
        xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                          !hr06
      endif
      do 220 iq=1,6
        txyz(iq)=zero
        do 220 jq=1,6
          txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  220 continue
!--INITIAL COORDINATES
      if(nprint.eq.1.and.ia.eq.0) then
        write(*,*) 'DISTANCE = ',b
      endif
!--EMITTANCES WITH LINEAR COUPLING
!hr06 evx=txyz(1)*txyz(1)+txyz(2)*txyz(2)
      evx=txyz(1)**2+txyz(2)**2                                          !hr06
!hr06 evz=txyz(3)*txyz(3)+txyz(4)*txyz(4)
      evz=txyz(3)**2+txyz(4)**2                                          !hr06
!     calculation second particle
      xyzv2(1)=c1
      xyzv2(2)=d1
      xyzv2(3)=e1
      xyzv2(4)=f1
      xyzv2(5)=g1
      xyzv2(6)=h1
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
!hr06   xyzv2(2)=xyzv2(2)*(one+xyzv2(6)+clop(3))
        xyzv2(2)=xyzv2(2)*((one+xyzv2(6))+clop(3))                       !hr06
!hr06   xyzv2(4)=xyzv2(4)*(one+xyzv2(6)+clop(3))
        xyzv2(4)=xyzv2(4)*((one+xyzv2(6))+clop(3))                       !hr06
      endif
      do 225 iq=1,6
        txyz2(iq)=zero
        do 225 jq=1,6
          txyz2(iq)=txyz2(iq)+t(jq,iq)*xyzv2(jq)
  225 continue
!hr06 evx2=txyz2(1)*txyz2(1)+txyz2(2)*txyz2(2)
      evx2=txyz2(1)**2+txyz2(2)**2                                       !hr06
!hr06 evz2=txyz2(3)*txyz2(3)+txyz2(4)*txyz2(4)
      evz2=txyz2(3)**2+txyz2(4)**2                                       !hr06
      write(toptit(3)(6:15),10010) sqrt(evx*bet0(1))+sqrt(evz*bet0x2)
      write(toptit(3)(23:32),10010) sqrt(evz*bet0(2))+sqrt(evx*bet0z2)
      if(its6d.eq.1) then
!hr06   emiii=txyz(5)*txyz(5)*cma2*cma2+txyz(6)*txyz(6)*cma1*cma1
        emiii=txyz(5)**2*cma2**2+txyz(6)**2*cma1**2
      else
        emiii=zero
      endif
!--COURANT SYNDER CONT.
      do 230 iq=1,6
        txyz(iq)=txyz(iq)*rbeta(iq)
  230 continue
      c0=txyz(1)
      d0=txyz(2)
      e0=txyz(3)
      f0=txyz(4)
      g0=txyz(5)*cma2
      h0=txyz(6)*cma1
!--MIN MAX VALUES
      pmin(2)=b
      pmax(2)=b
      pmin(3)=c0
      pmax(3)=c0
      pmin(4)=d0
      pmax(4)=d0
      pmin(5)=e0
      pmax(5)=e0
      pmin(6)=f0
      pmax(6)=f0
      pmin(9)=g0
      pmax(9)=g0
      pmin(10)=h0
      pmax(10)=h0
      pmin(16)=p
      pmax(16)=p
!--EMITTANCES WITH LINEAR COUPLING CONT.
      emi=evx
      emii=evz
      angi=zero
      angii=zero
      angiii=zero
      if(abs(txyz(1)).gt.pieni.or.abs(txyz(2)).gt.pieni)                &
     &angi=atan2_rn(txyz(2),txyz(1))
      if(abs(txyz(3)).gt.pieni.or.abs(txyz(4)).gt.pieni)                &
     &angii=atan2_rn(txyz(4),txyz(3))
      if(abs(txyz(5)).gt.pieni.or.abs(txyz(6)).gt.pieni)                &
     &angiii=atan2_rn(txyz(6)*cma1,txyz(5)*cma2)
      evt=evx+evz
      evxma=evx
      evzma=evz
      evtma=evt
      evxmi=evx
      evzmi=evz
      evtmi=evt
!--COORDINATE-ANGLE CONVERSION
      call caconv(dpx,d0,c0)
      call caconv(dpz,f0,e0)
      dpxp=tpi+dpx
      dpzp=tpi+dpz
!--INVARIANTS
      call cinvar(dpx,dphix,dpz,dpzp,nuex,emz,zinv,invz)
      call cinvar(dpz,dphiz,dpx,dpxp,nuez,emx,xinv,invx)
!----------------------------------------------------------------------
!--GET DATA POINTS
!----------------------------------------------------------------------
      iskc=0
  240 ifipa=0
      if(ntwin.eq.1) read(nfile,end=270,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p
      if(ntwin.eq.2) read(nfile,end=270,iostat=ierro) ia,ifipa,b,c,d,e, &
     &f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      if(ifipa.lt.1) goto 240
      if(progrm.eq.'MAD') then
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        g=g*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          g1=g1*c1e3
          p1=p1*c1e3
        endif
      endif
!--LYAPUNOV
      if(ntwin.eq.2) then
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
      iskc=iskc+1
      if(mod(iskc,iskip).ne.0) goto 240
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 270
      i1=i1+1
      i11=i1+1
      if(i2.ge.nlya.and.i11.gt.nfft.and.iapx.gt.npos.and.iapz.gt.npos)  &
     &goto 270
      if(i11.le.nfft) then
        xxr(i11)=c
        xxi(i11)=zero
      endif
      if(i11.le.nfft) then
        zzr(i11)=e
        zzi(i11)=zero
      endif
      c=c-clo(1)
      d=d-clop(1)
      e=e-clo(2)
      f=f-clop(2)
      g=g-clo(3)
      h=h-clop(3)
      if(icode.ge.4) then
        c=c-di0(1)*h
        d=d-dip0(1)*h
        e=e-di0(2)*h
        f=f-dip0(2)*h
      endif
!--EMITTANCES
      xp=bet0(1)*d+alf0(1)*c
      zp=bet0(2)*f+alf0(2)*e
!hr06 emx=(c*c+xp*xp)/bet0(1)
      emx=(c**2+xp**2)/bet0(1)                                           !hr06
!hr06 emz=(e*e+zp*zp)/bet0(2)
      emz=(e**2+zp**2)/bet0(2)                                           !hr06
      if(icode.ge.4.and.its6d.ne.0) then
        c=c+di0(1)*h
        d=d+dip0(1)*h
        e=e+di0(2)*h
        f=f+dip0(2)*h
      endif
      emt=emx+emz
      emxa=emxa+emx
      emza=emza+emz
      emta=emta+emt
      emax=max(emx,emax)
      emix=min(emx,emix)
      emaz=max(emz,emaz)
      emiz=min(emz,emiz)
      emat=max(emt,emat)
      emit=min(emt,emit)
!--COURANT SYNDER
      xyzv(1)=c
      xyzv(2)=d
      xyzv(3)=e
      xyzv(4)=f
      xyzv(5)=g
      xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
!hr06   xyzv(2)=xyzv(2)*(one+xyzv(6)+clop(3))
        xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                          !hr06
!hr06   xyzv(4)=xyzv(4)*(one+xyzv(6)+clop(3))
        xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                          !hr06
      endif
      do 250 iq=1,6
        txyz(iq)=zero
        do 250 jq=1,6
          txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  250 continue
!--EMITTANCES WITH LINEAR COUPLING
!hr06 evx1=txyz(1)*txyz(1)+txyz(2)*txyz(2)
      evx1=txyz(1)**2+txyz(2)**2                                         !hr06
!hr06 evz1=txyz(3)*txyz(3)+txyz(4)*txyz(4)
      evz1=txyz(3)**2+txyz(4)**2                                         !hr06
!--COURANT SYNDER CONT.
      do 260 iq=1,6
        txyz(iq)=txyz(iq)*rbeta(iq)
  260 continue
      c=txyz(1)
      d=txyz(2)
      e=txyz(3)
      f=txyz(4)
      g=txyz(5)*cma2
      h=txyz(6)*cma1
!--MIN MAX VALUES
      pmin(2)= min(pmin(2) ,b)
      pmax(2)= max(pmax(2) ,b)
      pmin(3)= min(pmin(3) ,c)
      pmax(3)= max(pmax(3) ,c)
      pmin(4)= min(pmin(4) ,d)
      pmax(4)= max(pmax(4) ,d)
      pmin(5)= min(pmin(5) ,e)
      pmax(5)= max(pmax(5) ,e)
      pmin(6)= min(pmin(6) ,f)
      pmax(6)= max(pmax(6) ,f)
      pmin(9)= min(pmin(9) ,g)
      pmax(9)= max(pmax(9) ,g)
      pmin(10)=min(pmin(10),h)
      pmax(10)=max(pmax(10),h)
      pmin(16)=min(pmin(16),p)
      pmax(16)=max(pmax(16),p)
!--ADDING (LOG OF) THE DISTANCES OF PHASE SPACE
      ia=ia-nstart
!--GET DIFFERENCE IN THE NUMBER OF TURNS PER DATA ENTRY : IDNT
      if(i1.eq.1) idnt=ia-ia0
      bold=bold+b
      b=b-b0
      dle1c=zero
      if(b.gt.zero) dle1c=log_rn(b)
!hr06 if(b.lt.zero) dle1c=-log_rn(-b)
      if(b.lt.zero) dle1c=-1d0*log_rn(-1d0*b)                            !hr06
      dle1=dle1+dle1c
!--EMITTANCES WITH LINEAR COUPLING CONT.
      evt1=evx1+evz1
      evxma=max(evx1,evxma)
      evzma=max(evz1,evzma)
      evtma=max(evt1,evtma)
      evxmi=min(evx1,evxmi)
      evzmi=min(evz1,evzmi)
      evtmi=min(evt1,evtmi)
      evx=evx+evx1
      evz=evz+evz1
      evt=evt+evt1
!--ADDING OF THE PHASE ADVANCES
      sx=c*d0-c0*d
      cx=c0*c+d*d0
      if(iapx.le.npos)                                                  &
     &call cphase(1,dphx,sx,cx,qx0,ivox,iwarx,iapx)
      sz=e*f0-e0*f
      cz=e0*e+f*f0
      if(iapz.le.npos)                                                  &
     &call cphase(2,dphz,sz,cz,qz0,ivoz,iwarz,iapz)
      s6=g*h0-g0*h
      c6=h0*h+g*g0
      if(iap6.le.npos)                                                  &
     &call cphase(3,dph6,s6,c6,qs0,ivo6,iwar6,iap6)
!--AVERAGING AFTER IAV TURNS
      if(mod(i1,iav).eq.0) then
        if(i2.ge.nlya) goto 240
        i2=i2+1
!hr06   dle(i2)=dle1/iav
        dle(i2)=dle1/dble(iav)                                           !hr06
        if(ia.gt.0) then
!ERIC bug fixed...........
!hr06     tle1=real(log_rn(dble(ia)))
!eric     tle1=real(log_rn(dble(ia)))
!bugfix   tle1=log_rn(dble(ia))                                          !hr06
          tle1=log_rn(dble(ia))                                          !hr06
          if(i2.gt.1) then
!hr06       biav(i2-1)=bold/iav
            biav(i2-1)=bold/dble(iav)                                    !hr06
            if(i2.eq.2) biav(1)=biav(1)*half
            bold=zero
            tle(i2)=(tle1+tlo)*half
            if(abs(tle1-tlo).gt.pieni) then
              wgh(i2)=one/(tle1-tlo)
            else
              write(*,10310) nfile
              wgh(i2)=zero
            endif
          else
            tle(i2)=tle1*half
            wgh(i2)=one/(tle1)
          endif
        else
          tle(i2)=zero
          wgh(i2)=zero
        endif
        tlo=tle1
        dle1=zero
      endif
!--COORDINATE-ANGLE CONVERSION
      call caconv(dpx,d,c)
      call caconv(dpz,f,e)
      dpxp=tpi+dpx
      dpzp=tpi+dpz
!--INVARIANTS
      call cinvar(dpx,dphix,dpz,dpzp,nuex,emz,zinv,invz)
      call cinvar(dpz,dphiz,dpx,dpxp,nuez,emx,xinv,invx)
!--RESET OF COORDINATES
      c0=c
      d0=d
      e0=e
      f0=f
      g0=g
      h0=h
      goto 240
  270 if(i2.lt.1) i2=1
!----------------------------------------------------------------------
!--ANALYSING DATA
!----------------------------------------------------------------------
!--FIT OF DISTANCE IN PHASESPACE + MEAN PHASEADVANCE
      do 280 i=2,i2
        if(iwg.eq.1) call lfitwd(tle,dle,wgh,i,1,slope(i-1),const,varlea&
     &(i-1))
        if(iwg.eq.0) call lfitd(tle,dle,i,1,slope(i-1),const,varlea     &
     &(i-1))
  280 continue
      if(iapx.eq.0) then
        write(*,*) 'WARNING: IAPX IS ZERO'
        iapx=1
      endif
      if(iapz.eq.0) then
        write(*,*) 'WARNING: IAPZ IS ZERO'
        iapz=1
      endif
!hr06 tphx=dphx/iapx
      tphx=dphx/dble(iapx)                                               !hr06
!hr06 tphz=dphz/iapz
      tphz=dphz/dble(iapz)                                               !hr06
!hr06 if(iap6.gt.0) tph6=dph6/iap6
      if(iap6.gt.0) tph6=dph6/dble(iap6)                                 !hr06
!--STANDARD DEVIATION OF PHASEADVANCES
      do 290 i=1,iapx
!hr06  290 sdpx=sdpx+(phase(1,i)-tphx)*(phase(1,i)-tphx)
  290 sdpx=sdpx+(phase(1,i)-tphx)**2                                     !hr06
      do 300 i=1,iapz
!hr06  300 sdpz=sdpz+(phase(2,i)-tphz)*(phase(2,i)-tphz)
  300 sdpz=sdpz+(phase(2,i)-tphz)**2                                     !hr06
      do 310 i=1,iap6
!hr06  310 sdp6=sdp6+(phase(3,i)-tph6)*(phase(3,i)-tph6)
  310 sdp6=sdp6+(phase(3,i)-tph6)**2                                     !hr06
!hr06 sdpx=sqrt(sdpx)/iapx
      sdpx=sqrt(sdpx)/dble(iapx)                                         !hr06
!hr06 sdpz=sqrt(sdpz)/iapz
      sdpz=sqrt(sdpz)/dble(iapz)                                         !hr06
!hr06 if(iap6.gt.0) sdp6=sqrt(sdp6)/iap6
      if(iap6.gt.0) sdp6=sqrt(sdp6)/dble(iap6)                           !hr06
!--AVERAGED EMITTANCES
      di11=i11
      if(i11.eq.0) then
        write(*,*) '** ERROR ** - I11 IS ZERO'
        goto 550
      endif
      emxa=emxa/di11
      emza=emza/di11
      emta=emta/di11
      evxm=evx/di11
      evzm=evz/di11
      evtm=evt/di11
!--SMEAR CALCULATION AND 4D-SMEAR
      rewind nfile
      read(nfile,iostat=ierro)
      if(ierro.gt.0) then
        write(*,10320) nfile
        goto 550
      endif
      iskc=-1
      do 340 i=1,i11*iskip+nstart
        ifipa=0
        read(nfile,end=350,iostat=ierro) ia,ifipa,b,c,d,e,f,g,h,p
        if(ierro.gt.0) then
          write(*,10320) nfile
          goto 550
        endif
        if(ifipa.lt.1) goto 340
        if(progrm.eq.'MAD') then
          c=c*c1e3
          d=d*c1e3
          e=e*c1e3
          f=f*c1e3
          g=g*c1e3
          p=p*c1e3
        endif
        iskc=iskc+1
        if(mod(iskc,iskip).ne.0) goto 340
        if((ia-nstart).lt.0) goto 340
        c=c-clo(1)
        d=d-clop(1)
        e=e-clo(2)
        f=f-clop(2)
        g=g-clo(3)
        h=h-clop(3)
        if(icode.ge.4) then
          c=c-di0(1)*h
          d=d-dip0(1)*h
          e=e-di0(2)*h
          f=f-dip0(2)*h
        endif
!--MEAN EMITTANCES
        xp=bet0(1)*d+alf0(1)*c
        zp=bet0(2)*f+alf0(2)*e
!hr06   emx=(c*c+xp*xp)/bet0(1)
        emx=(c**2+xp**2)/bet0(1)                                         !hr06
!hr06   emz=(e*e+zp*zp)/bet0(2)
        emz=(e**2+zp**2)/bet0(2)                                         !hr06
        if(icode.ge.4.and.its6d.ne.0) then
          c=c+di0(1)*h
          d=d+dip0(1)*h
          e=e+di0(2)*h
          f=f+dip0(2)*h
        endif
        emt=emx+emz
!hr06   emxs=emxs+(emx-emxa)*(emx-emxa)
        emxs=emxs+(emx-emxa)**2                                          !hr06
!hr06   emzs=emzs+(emz-emza)*(emz-emza)
        emzs=emzs+(emz-emza)**2                                          !hr06
!hr06   emts=emts+(emt-emta)*(emt-emta)
        emts=emts+(emt-emta)**2                                          !hr06
!--COURANT SYNDER
        xyzv(1)=c
        xyzv(2)=d
        xyzv(3)=e
        xyzv(4)=f
        xyzv(5)=g
        xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
        if(its6d.eq.1) then
!hr06     xyzv(2)=xyzv(2)*(one+xyzv(6)+clop(3))
          xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                        !hr06
!hr06     xyzv(4)=xyzv(4)*(one+xyzv(6)+clop(3))
          xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                        !hr06
        endif
! normalisation with t-matrix = inverse matrix of eigenvectors
        do 320 iq=1,6
          txyz(iq)=zero
          do 320 jq=1,6
            txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  320   continue
!--MEAN EMITTANCES WITH LINEAR COUPLING
!hr06   evx=txyz(1)*txyz(1)+txyz(2)*txyz(2)
        evx=txyz(1)**2+txyz(2)**2                                        !hr06
!hr06   evz=txyz(3)*txyz(3)+txyz(4)*txyz(4)
        evz=txyz(3)**2+txyz(4)**2                                        !hr06
!--COURANT SYNDER CONT.
        do 330 iq=1,6
          txyz(iq)=txyz(iq)*rbeta(iq)
  330   continue
        c=txyz(1)
        d=txyz(2)
        e=txyz(3)
        f=txyz(4)
        g=txyz(5)
        h=txyz(6)
!--MEAN EMITTANCES WITH LINEAR COUPLING CONT.
        evt=evx+evz
!hr06   sevx=sevx+(evx-evxm)*(evx-evxm)
        sevx=sevx+(evx-evxm)**2                                          !hr06
!hr06   sevz=sevz+(evz-evzm)*(evz-evzm)
        sevz=sevz+(evz-evzm)**2                                          !hr06
!hr06   sevt=sevt+(evt-evtm)*(evt-evtm)
        sevt=sevt+(evt-evtm)**2                                          !hr06
  340 continue
  350 continue
!--SMEAR IN %
      call sinpro(emxa,di11,emxs,emax,emix)
      call sinpro(emza,di11,emzs,emaz,emiz)
      call sinpro(emta,di11,emts,emat,emit)
      call sinpro(evxm,di11,sevx,evxma,evxmi)
      call sinpro(evzm,di11,sevz,evzma,evzmi)
      call sinpro(evtm,di11,sevt,evtma,evtmi)
!----------------------------------------------------------------------
!--PRINTING
!----------------------------------------------------------------------
      if(nstop.lt.ia.and.(ia.lt.numl.or.ia.lt.nint(dnumlr))) nlost=1
      if(nnumxv(ifipa).eq.0.and.nnumxv(ilapa).eq.0) then
!hr06   sumda(22)=ia
        sumda(22)=dble(ia)                                               !hr06
!hr06   sumda(23)=ia
        sumda(23)=dble(ia)                                               !hr06
      else
!hr06   sumda(22)=nnumxv(ifipa)
        sumda(22)=dble(nnumxv(ifipa))                                    !hr06
!hr06   sumda(23)=nnumxv(ilapa)
        sumda(23)=dble(nnumxv(ilapa))                                    !hr06
      endif
!hr06 sumda(2)=nlost
      sumda(2)=dble(nlost)
      sumda(9)=dp1-clop(3)
!--GET DIFFERENCE IN THE NUMBER OF TURNS PER DATA ENTRY : TIDNT
!--NOW CONSIDERING ONLY TURNS LARGER THAN NSTART
!hr06 tidnt=(ia-nstart+idnt)/i11
      tidnt=dble(((ia-nstart)+idnt)/i11)                                 !hr06
      if(i2.ge.2) then
        if(nprint.eq.1) write(*,10110)
        ilyap=0
        slopem=zero
        do 360 i=1,i2-1
!hr06     iturn=nint((i+1)*iav*tidnt)
          iturn=nint(dble((i+1)*iav)*tidnt)                              !hr06
          if(nprint.eq.1) write(*,10120) iturn,biav(i),slope(i),        &
     &varlea(i)
          if(biav(i).gt.0.1d0) ilyap=1
          slopem=max(slopem,slope(i))
  360   continue
        if(nprint.eq.1) write(*,10130)
        sumda(10)=biav(i2-1)
        if(ilyap.eq.0) then
!hr06    sumda(11)=slope(i2-1)
         sumda(11)=slope(i2-1)                                           !hr06
        else
         sumda(11)=slopem
        endif
      endif
!--CALCULATION OF AVERAGED PHASEADVANCES
      tph6=abs(tph6)
      if(nprint.eq.1) write(*,10140)tphx,sdpx,tphz,sdpz,tph6,sdp6,qwc   &
     &(1),tphx-qwc(1) ,qwc(2),tphz-qwc(2),qwc(3),tph6-qwc(3),dres,ires
      sumda(3)=qwc(1)
      sumda(4)=qwc(2)
      if(abs(tphx).gt.pieni) then
        sumda(12)=tphx-qwc(1)
      else
        sumda(12)=zero
      endif
      sumda(13)=sdpx
      if(abs(tphz).gt.pieni) then
        sumda(14)=tphz-qwc(2)
      else
        sumda(14)=zero
      endif
      sumda(15)=sdpz
      sumda(25)=tph6
!--DISTANCE OF Q-VALUES (AVERAGED PHASEADVANCE) TO RESONANCES
      do 370 i=1,21
        do 370 j=1,21
          im1=i-1
          jm1=j-1
          if(im1.eq.0.and.jm1.eq.0) goto 370
          if(im1+jm1.gt.ires) goto 370
!hr06     ares=im1*tphx+jm1*tphz
          ares=dble(im1)*tphx+dble(jm1)*tphz                             !hr06
          dares=anint(ares)
          ares=ares-dares
          if(abs(ares).lt.armin) then
            armin=abs(ares)
            im1s=im1
            jm1s=jm1
          endif
!hr06     ared=im1*tphx-jm1*tphz
          ared=dble(im1)*tphx-dble(jm1)*tphz                             !hr06
          dared=anint(ared)
          ared=ared-dared
          if(abs(ared).lt.armin) then
            armin=abs(ared)
            im1s=im1
            jm1s=-jm1
          endif
          if(abs(ares).lt.dres.and.nprint.eq.1) write(*,10170) im1,jm1, &
     &dares,ares
          if(abs(ared).lt.dres.and.jm1.ne.0.and.im1.ne.0.and.nprint.eq. &
     &1) write(*,10170) im1,-jm1,dared,ared
  370 continue
      if(armin.lt.armin0) then
!hr06   sumda(16)=im1s
        sumda(16)=dble(im1s)                                             !hr06
!hr06   sumda(17)=jm1s
        sumda(17)=dble(jm1s)                                             !hr06
        sumda(18)=sumda(16)+abs(sumda(17))
      endif
      if(iwarx.eq.1.and.nprint.eq.1) write(*,10150)
      if(iwarz.eq.1.and.nprint.eq.1) write(*,10160)
!--Q-VALUES BY AN FFT-ROUTINE
  380 ifp=ifp+1
      ife=2**ifp
      if(ife.le.i11.and.ife.le.nfft) then
        goto 380
      else
        ifp=ifp-1
        ife=ife/2
      endif
      if(ife.eq.0) then
        write(*,*) '** ERROR ** - IFE IS ZERO'
        goto 550
      endif
      dife=ife
      if(ifp.gt.1) then
        if(nprint.eq.1) write(*,10180) ife,dfft*100
        call fft(xxr,xxi,ifp,ife)
        call fft(zzr,zzi,ifp,ife)
        xxmax=zero
        zzmax=zero
        xxmin=one
        zzmin=one
        if(ifh.eq.0) then
          if1=1
          if2=ife
          ife2=ife
          pmin(21)=qx0
          pmax(21)=qx0+one
          pmin(23)=qz0
          pmax(23)=qz0+one
        else if(ifh.eq.1) then
          if1=1
          if2=ife/2
          ife2=ife/2
          pmin(21)=qx0
          pmax(21)=qx0+half
          pmin(23)=qz0
          pmax(23)=qz0+half
        else
          if1=ife/2+1
          if2=ife
          ife2=ife/2
          pmin(21)=qx0+half
          pmax(21)=qx0+one
          pmin(23)=qz0+half
          pmax(23)=qz0+one
        endif
        do 390 i=if1,if2
          xxmax=max(xxmax,sqrt(xxr(i)**2+xxi(i)**2))
          zzmax=max(zzmax,sqrt(zzr(i)**2+zzi(i)**2))
          xxmin=min(xxmin,sqrt(xxr(i)**2+xxi(i)**2))
          zzmin=min(zzmin,sqrt(zzr(i)**2+zzi(i)**2))
  390   continue
        if(abs(xxmax).gt.pieni) xxmin=xxmin/xxmax
        if(abs(zzmax).gt.pieni) zzmin=zzmin/zzmax
        if(xxmax.le.pieni) then
          write(*,*) 'WARNING: XXMAX IS SET TO : ',pieni
          xxmax=pieni
        endif
        if(zzmax.le.pieni) then
          write(*,*) 'WARNING: ZZMAX IS SET TO : ',pieni
          zzmax=pieni
        endif
        do 400 i=if1,if2
          xxaux=sqrt(xxr(i)**2+xxi(i)**2)
          zzaux=sqrt(zzr(i)**2+zzi(i)**2)
!hr06     if(abs(xxaux-xxmax).le.pieni) ffx=(i-1)/dife+qx0
          if(abs(xxaux-xxmax).le.pieni) ffx=(dble(i-1)/dife)+qx0         !hr06
!hr06     if(abs(zzaux-zzmax).le.pieni) ffz=(i-1)/dife+qz0
          if(abs(zzaux-zzmax).le.pieni) ffz=(dble(i-1)/dife)+qz0         !hr06
          xxaux=xxaux/xxmax
          zzaux=zzaux/zzmax
!hr06     if(xxaux.gt.dfft.and.nprint.eq.1) write(*,10190) (i-1)/dife
          if(xxaux.gt.dfft.and.nprint.eq.1) write(*,10190)              &!hr06
     &dble(i-1)/dife+qx0,xxaux*100d0                                     !hr06
!hr06&+qx0,xxaux*100
!hr06     if(zzaux.gt.dfft.and.nprint.eq.1) write(*,10200) (i-1)/dife   &
      if(zzaux.gt.dfft.and.nprint.eq.1) write(*,10200) dble(i-1)/dife   &!hr06
     &+qz0,zzaux*100d0                                                   !hr06
!hr06&+qz0,zzaux*100
  400   continue
        if(nprint.eq.1) write(*,10210) ffx,ffz,qwc(1),ffx-qwc(1),qwc(2),&
     &ffz-qwc(2),dres,ires
!--DISTANCE OF Q-VALUES (FFT) TO RESONANCES
        do 410 i=1,21
          do 410 j=1,21
            im1=i-1
            jm1=j-1
            if(im1.eq.0.and.jm1.eq.0) goto 410
            if(im1+jm1.gt.ires) goto 410
!hr06       ares=im1*ffx+jm1*ffz
            ares=dble(im1)*ffx+dble(jm1)*ffz                             !hr06
            dares=anint(ares)
            ares=ares-dares
!hr06       ared=im1*ffx-jm1*ffz
            ared=dble(im1)*ffx-dble(jm1)*ffz                             !hr06
            dared=anint(ared)
            ared=ared-dared
            if(abs(ares).lt.dres.and.nprint.eq.1) write(*,10170) im1,   &
     &jm1,dares,ares
            if(abs(ared).lt.dres.and.jm1.ne.0.and.im1.ne.0.and.nprint.eq&
     &.1) write(*,10170) im1,-jm1,dared,ared
  410   continue
      endif
!--PRINT 4-D INVARIANTS WITH LINEAR COUPLING
      if(nprint.eq.1) write(*,10270) emi,emii,emiii,angi,angii,angiii,  &
     &evxm,sevx,evxma,evxmi,evzm,sevz,evzma,evzmi,evtm,sevt,evtma,evtmi
!--PRINT EMITTANCES AND SMEAR
      ampx0=sqrt(bet0(1)*emx0)
      ampz0=sqrt(bet0(2)*emz0)
      if(nprint.eq.1) write(*,10220) emx0,ampx0,emz0,ampz0,emxa,emxs,   &
     &emax,emix,emza, emzs,emaz,emiz,emta,emts,emat,emit
      sumda(46)=emi
      sumda(47)=emii
      sumda(48)=bet0x2
      sumda(49)=bet0z2
      sumda(7)=sqrt(bet0(1)*emi)+sqrt(bet0x2*emii)
      sumda(8)=sqrt(bet0(2)*emii)+sqrt(bet0z2*emi)
      sumda(26)=sqrt(bet0(1)*evx2)+sqrt(bet0x2*evz2)
      sumda(27)=sqrt(bet0(2)*evz2)+sqrt(bet0z2*evx2)
      sumda(19)=sevx
      sumda(20)=sevz
      sumda(21)=sevt
!     sumda(59)=dmmac
!     sumda(60)=dnms
      sumda(59)=dnms
! This place 60 now used for CPU time seconds
! But it is set earlier in case particles are lost very early
      sumda(24)=dizu0
!hr06 emax=emax/100*emxa+emxa
      emax=(emax/100d0)*emxa+emxa                                        !hr06
!hr06 emix=emix/100*emxa+emxa
      emix=(emix/100d0)*emxa+emxa                                        !hr06
!hr06 emaz=emaz/100*emza+emza
      emaz=(emaz/100d0)*emza+emza                                        !hr06
!hr06 emiz=emiz/100*emza+emza
      emiz=(emiz/100d0)*emza+emza                                        !hr06
      sumda(28)=sqrt(bet0(1)*abs(emix))
      sumda(29)=sqrt(bet0(1)*emxa)
      sumda(30)=sqrt(bet0(1)*emax)
      sumda(31)=sqrt(bet0(2)*abs(emiz))
      sumda(32)=sqrt(bet0(2)*emza)
      sumda(33)=sqrt(bet0(2)*emaz)
!hr06 evxma=evxma/100*evxm+evxm
      evxma=(evxma/100d0)*evxm+evxm                                      !hr06
!hr06 evxmi=evxmi/100*evxm+evxm
      evxmi=(evxmi/100d0)*evxm+evxm                                      !hr06
!hr06 evzma=evzma/100*evzm+evzm
      evzma=(evzma/100d0)*evzm+evzm                                      !hr06
!hr06 evzmi=evzmi/100*evzm+evzm
      evzmi=(evzmi/100d0)*evzm+evzm                                      !hr06
      sumda(34)=sqrt(bet0(1)*abs(evxmi))
      sumda(35)=sqrt(bet0(1)*evxm)
      sumda(36)=sqrt(bet0(1)*evxma)
      sumda(37)=sqrt(bet0(2)*abs(evzmi))
      sumda(38)=sqrt(bet0(2)*evzm)
      sumda(39)=sqrt(bet0(2)*evzma)
!hr06 evtma=evtma/100*evtm+evtm
      evtma=(evtma/100d0)*evtm+evtm                                      !hr06
!hr06 evtmi=evtmi/100*evtm+evtm
      evtmi=(evtmi/100d0)*evtm+evtm                                      !hr06
      if(abs(evxm+evzm).gt.pieni) then
        ratemx=evxm/(evxm+evzm)
        ratemz=evzm/(evxm+evzm)
      else
        ratemx=zero
        ratemz=zero
      endif
!hr06 sumda(40)=sqrt(bet0(1)*abs(evtmi)*ratemx)
      sumda(40)=sqrt((bet0(1)*abs(evtmi))*ratemx)                        !hr06
!hr06 sumda(41)=sqrt(bet0(1)*evtm*ratemx)
      sumda(41)=sqrt((bet0(1)*evtm)*ratemx)                              !hr06
!hr06 sumda(42)=sqrt(bet0(1)*evtma*ratemx)
      sumda(42)=sqrt((bet0(1)*evtma)*ratemx)                             !hr06
!hr06 sumda(43)=sqrt(bet0(2)*abs(evtmi)*ratemz)
      sumda(43)=sqrt((bet0(2)*abs(evtmi))*ratemz)                        !hr06
!hr06 sumda(44)=sqrt(bet0(2)*evtm*ratemz)
      sumda(44)=sqrt((bet0(2)*evtm)*ratemz)                              !hr06
!hr06 sumda(45)=sqrt(bet0(2)*evtma*ratemz)
      sumda(45)=sqrt((bet0(2)*evtma)*ratemz)                             !hr06
!--PUT IN THE CHROMATICITY
      sumda(50)=chromc(1)*c1e3
      sumda(51)=chromc(2)*c1e3
!--WRITE DATA FOR THE SUMMARY OF THE POSTPROCESSING ON FILE # 10
! We should really write fort.10 in BINARY!
      write(110,iostat=ierro) (sumda(i),i=1,60)
! Now use my new dtostr for portability
      l1=1
      do i=1,60
! We return the length of the string (always 24)
        errno=dtostr(sumda(i),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
      enddo
      write(10,'(a)',iostat=ierro) ch(1:l1-1)
      if(ierro.ne.0) then
        write(*,*)
        write(*,*)'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110'
        write(*,*) 'ERROR CODE : ',ierro
        write(*,*)
      endif
!--CALCULATION THE INVARIANCES OF THE 4D TRANSVERSAL MOTION
      do 420 i=1,ninv
        if(invx(i).gt.0) then
          nuix=nuix+1
!hr06     xing=xing+xinv(i)/invx(i)
          xing=xing+xinv(i)/dble(invx(i))                                !hr06
        endif
        if(invz(i).gt.0) then
          nuiz=nuiz+1
!hr06     zing=zing+zinv(i)/invz(i)
          zing=zing+zinv(i)/dble(invz(i))                                !hr06
        endif
  420 continue
!hr06 pinx=nuix
      pinx=dble(nuix)                                                    !hr06
!hr06 pinz=nuiz
      pinz=dble(nuiz)                                                    !hr06
      if(nuix.ne.0) then
        pixr=dble(nuez)/dble(nuix)
!hr06   xing=xing/nuix
        xing=xing/dble(nuix)                                             !hr06
      endif
      if(nuiz.ne.0) then
        pizr=dble(nuex)/dble(nuiz)
!hr06   zing=zing/nuiz
        zing=zing/dble(nuiz)                                             !hr06
      endif
!hr06 pinx=pinx/ninv*100
      pinx=(pinx/dble(ninv))*100d0                                       !hr06
!hr06 pinz=pinz/ninv*100
      pinz=(pinz/dble(ninv))*100d0                                       !hr06
      if(nprint.eq.1) write(*,10230)
      if(nuez.lt.ninv.and.nprint.eq.1) write(*,10240) nuez,ninv
      if(nuex.lt.ninv.and.nprint.eq.1) write(*,10250) nuex,ninv
      if(nprint.eq.1) write(*,10260) nuez,nuix,nuex,nuiz, ninv,pinx,    &
     &pixr,pinz,pizr,xing,zing
!----------------------------------------------------------------------
!--PLOTTING
!----------------------------------------------------------------------
      pmin(1)=zero
!hr06 pmax(1)=ia
      pmax(1)=dble(ia)                                                   !hr06
      pmin(7)=pmin(3)
      pmax(7)=pmax(3)
      pmin(8)=pmin(5)
      pmax(8)=pmax(5)
      pmin(11)=pmin(3)
      pmax(11)=pmax(3)
      pmin(12)=pmin(10)
      pmax(12)=pmax(10)
      pmin(13)=pmin(5)
      pmax(13)=pmax(5)
      pmin(14)=pmin(10)
      pmax(14)=pmax(10)
!hr06 pmax(15)=ia
      pmax(15)=dble(ia)                                                  !hr06
      pmin(17)=pmin(3)
      pmax(17)=pmax(3)
      pmin(18)=pmin(4)
      pmax(18)=pmax(4)
      pmin(19)=pmin(5)
      pmax(19)=pmax(5)
      pmin(20)=pmin(6)
      pmax(20)=pmax(6)
      pmin(22)=zero
      pmin(24)=zero
      pmax(22)=one
      pmax(24)=one
      do 500 i=1,12
        i2=2*i
        i1=i2-1
        if(pmin(i1).gt.pmax(i1)) pmin(i1)=pmax(i1)
        if(pmin(i2).gt.pmax(i2)) pmin(i2)=pmax(i2)
        if((abs(pmin(i1)-pmax(i1)).le.pieni2) .or.(abs(pmin(i2)-pmax(i2)&
     &).le.pieni2)) then
          goto 500
        endif
        do 430 i3=i1,i2
          pcha=(pmax(i3)-pmin(i3))*prec
          pmin(i3)=pmin(i3)-pcha
          pmax(i3)=pmax(i3)+pcha
  430   continue
        if(iffw.eq.2) then
          pmin(22)=xxmin/(1d0+abs(prec))
          pmin(24)=zzmin/(1d0+abs(prec))
        endif
        if((i.eq.1.and.idis.eq.1).or. (i.gt.1.and.i.le.8.and.icow.eq.1) &
     &.or. ((i.eq.9.or.i.eq.10).and.istw.eq.1).and. (pmin(i1).ne.pmax   &
     &(i1).and.pmin(i2).ne.pmax(i2))) then
!--HBOOK FRAME
          call htitle(title(i))
          call hbook2(i,' ',2,real(pmin(i1)),real(pmax(i1)), 2,real     &
     &(pmin(i2)),real(pmax(i2)),0.)
          call hplot(i,' ',' ',0)
          call hplax(chxtit(i),chytit(i))
          call hplsof(4.,14.75,toptit(1),.15,0.,99.,-1)
          call hplsof(4.,14.50,toptit(2),.15,0.,99.,-1)
          call hplsof(4.,14.25,toptit(3),.15,0.,99.,-1)
          call hplsof(4.,14.00,toptit(4),.15,0.,99.,-1)
          call iselnt(10)
          rewind nfile
          read(nfile,iostat=ierro)
          if(ierro.gt.0) then
            write(*,10320) nfile
            goto 550
          endif
          iskc=-1
          do 460 j=1,i11*iskip+nstart
            ifipa=0
            if(ntwin.eq.1) read(nfile,end=470,iostat=ierro) ia,ifipa,b, &
     &c,d,e,f,g,h,p
            if(ntwin.eq.2) read(nfile,end=470,iostat=ierro) ia,ifipa,b, &
     &c,d,e,f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
            if(ierro.gt.0) then
              write(*,10320) nfile
              goto 550
            endif
            if(ifipa.lt.1) goto 460
            iskc=iskc+1
            if(mod(iskc,iskip).ne.0) goto 460
            if((ia-nstart).lt.0) goto 460
            if(progrm.eq.'MAD') then
              c=c*c1e3
              d=d*c1e3
              e=e*c1e3
              f=f*c1e3
              g=g*c1e3
              p=p*c1e3
              if(ntwin.eq.2) then
                c1=c1*c1e3
                d1=d1*c1e3
                e1=e1*c1e3
                f1=f1*c1e3
                g1=g1*c1e3
                p1=p1*c1e3
              endif
            endif
!--LYAPUNOV
            if(ntwin.eq.2) then
              x(1,1)=c
              x(1,2)=d
              x(1,3)=e
              x(1,4)=f
              x(1,5)=g
              x(1,6)=h
              x(2,1)=c1
              x(2,2)=d1
              x(2,3)=e1
              x(2,4)=f1
              x(2,5)=g1
              x(2,6)=h1
              call distance(x,cloau,di0au,t,b)
            endif
            if(icode.ge.4.and.its6d.eq.0) then
              c=c-di0(1)*h
              d=d-dip0(1)*h
              e=e-di0(2)*h
              f=f-dip0(2)*h
            endif
            c=c-clo(1)
            d=d-clop(1)
            e=e-clo(2)
            f=f-clop(2)
            g=g-clo(3)
            h=h-clop(3)
            xyzv(1)=c
            xyzv(2)=d
            xyzv(3)=e
            xyzv(4)=f
            xyzv(5)=g
            xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
            if(its6d.eq.1) then
!hr06         xyzv(2)=xyzv(2)*(one+xyzv(6)+clop(3))
              xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                    !hr06
!hr06         xyzv(4)=xyzv(4)*(one+xyzv(6)+clop(3))
              xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                    !hr06
            endif
            do 440 iq=1,6
              txyz(iq)=zero
              do 440 jq=1,6
                txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  440       continue
            do 450 iq=1,6
              txyz(iq)=txyz(iq)*rbeta(iq)
  450       continue
            c=txyz(1)
            d=txyz(2)
            e=txyz(3)
            f=txyz(4)
            g=txyz(5)*cma2
            h=txyz(6)*cma1
            if(idis.eq.1.and.i.eq.1) call ipm(1,real(ia),real(b))
            if(icow.eq.1.and.i.le.8) then
              if(i.eq.2) call ipm(1,real(c),real(d))
              if(i.eq.3) call ipm(1,real(e),real(f))
              if(i.eq.4) call ipm(1,real(c),real(e))
              if(i.eq.5) call ipm(1,real(g),real(h))
              if(i.eq.6) call ipm(1,real(c),real(h))
              if(i.eq.7) call ipm(1,real(e),real(h))
              if(i.eq.8) call ipm(1,real(ia),real(p))
            endif
            if(istw.eq.1.and.(i.eq.9.or.i.eq.10)) then
              if(i.eq.9) then
                call caconv(dpz,f,e)
                if(abs(dpz).lt.dphiz) call ipm(1,real(c),real(d))
              endif
              if(i.eq.10) then
                call caconv(dpx,d,c)
                if(abs(dpx).lt.dphix) call ipm(1,real(e),real(f))
              endif
            endif
  460     continue
  470     continue
        else if((iffw.eq.1.or.iffw.eq.2).and.(i.eq.11.or.i.eq.12)) then
!--HBOOK FRAME
          call htitle(title(i))
          call hbook2(i,' ',2,real(pmin(i1)),real(pmax(i1)), 2,real     &
     &(pmin(i2)),real(pmax(i2)),0.)
          if(iffw.eq.2) call hplopt('LOGY',1)
          call hplot(i,' ',' ',0)
          call hplax(chxtit(i),chytit(i))
          call hplsof(4.,14.75,toptit(1),.15,0.,99.,-1)
          call hplsof(4.,14.50,toptit(2),.15,0.,99.,-1)
          call hplsof(4.,14.25,toptit(3),.15,0.,99.,-1)
          call hplsof(4.,14.00,toptit(4),.15,0.,99.,-1)
          call iselnt(10)
          if(i.eq.11) then
            do 480 k=if1,if2
              k1=k-if1+1
              xxaux=sqrt(xxr(k)**2+xxi(k)**2)
              xxaux=xxaux/xxmax
!hr06         fxs(k1)=real((k-1)/dife+qx0)
              fxs(k1)=real(dble(k-1)/dife+qx0)                           !hr06
              if(iffw.eq.2) then
                if(abs(xxaux).lt.pieni) then
                  write(*,*) '* * * ERROR * * *'
                  write(*,*)                                            &
     &'Apparently horizontal FFT data are corrupted'
                  xxaux=one
                endif
                fzs(k1)=real(log10_rn(xxaux))
              else
                fzs(k1)=real(xxaux)
              endif
              if(nprint.eq.1) then
                write(14,10030,iostat=ierro) fxs(k1),fzs(k1)
                if(ierro.ne.0) then
                  write(*,*)
                  write(*,*)                                            &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : ',14
                  write(*,*) 'ERROR CODE : ',ierro
                  write(*,*)
                endif
              endif
  480       continue
            call ipl(ife2,fxs,fzs)
          else if(i.eq.12) then
            do 490 k=if1,if2
              k1=k-if1+1
              zzaux=sqrt(zzr(k)**2+zzi(k)**2)
              zzaux=zzaux/zzmax
!hr06         fxs(k1)=real((k-1)/dife+qz0)
              fxs(k1)=real(dble(k-1)/dife+qz0)                           !hr06
              if(iffw.eq.2) then
                if(abs(zzaux).lt.pieni) then
                  write(*,*) '* * * ERROR * * *'
                  write(*,*)                                            &
     &'Apparently vertical FFT data are corrupted'
                  zzaux=one
                endif
                fzs(k1)=real(log10_rn(zzaux))
              else
                fzs(k1)=real(zzaux)
              endif
              if(nprint.eq.1) then
                write(15,10030,iostat=ierro) fxs(k1),fzs(k1)
                if(ierro.ne.0) then
                  write(*,*)
                  write(*,*)                                            &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : ',14
                  write(*,*) 'ERROR CODE : ',ierro
                  write(*,*)
                endif
              endif
  490       continue
            call ipl(ife2,fxs,fzs)
          endif
        endif
        if(iffw.eq.2) call hplopt('LINY',1)
  500 continue
      if(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)              &
     &call hdelet(0)
      goto 560
  510 continue
      write(*,10300) nfile,'HEADER CORRUPTED'
      goto 550
  520 continue
      write(*,10300) nfile,'HEADER OF MADFILE CORRUPTED'
      goto 550
  530 continue
      write(*,10300) nfile,'NO DATA'
      goto 550
  535 continue
      write(*,10300) nfile,'ONLY START VALUES'
      goto 550
  540 continue
      write(*,10300) nfile,'WRONG RANGE OF DATA FOR PROCESSING'
      goto 550
  550 continue
!--WRITE DATA FOR THE SUMMARY OF THE POSTPROCESSING ON FILE # 10
!-- Will almost all be zeros but we now have napxto and ttime
! We should really write fort.10 in BINARY!
      write(110,iostat=ierro) (sumda(i),i=1,60)
! Now use my new dtostr for portability
      l1=1
      do i=1,60
! We return the length of the string (always 24)
        errno=dtostr(sumda(i),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
      enddo
      write(10,'(a)',iostat=ierro) ch(1:l1-1)
      if(ierro.ne.0) then
        write(*,*)
        write(*,*)'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110'
        write(*,*) 'ERROR CODE : ',ierro
        write(*,*)
      endif
!--REWIND USED FILES
  560 rewind nfile
      rewind 14
      rewind 15
!--TIME COUNT
      tim2=0.
      call timex(tim2)
      if(nprint.eq.1) write(*,10280) tim2-tim1
!----------------------------------------------------------------------
      return
10000 format(d10.4)
10010 format(f10.6)
10020 format(a80)
10030 format(2f10.6)
10040 format( //131('-')//10x,'OOOOOOOOOOOOOOOOOOOOOO' /10x,            &
     &'OO                  OO' /10x,'OO  POSTPROCESSING  OO' /10x,      &
     &'OO                  OO' /10x,'OOOOOOOOOOOOOOOOOOOOOO'// /10x,    &
     &'TITLE AND COMMENT :'//a80//a80// )
10050 format(10x,'THE FOLLOWING PARAMETERS ARE USED:'//                 &
     &10x,'PROGRAM NAME',t102,a8/                                       &
     &10x,'PARTICLE NUMBER',t102,i3/                                    &
     &10x,'TOTAL NUMBER OF PARTICLES',t102,i3/                          &
     &10x,'PHASE SPACE',t102,a11/                                       &
     &10x,'MAXIMUM NUMBER OF TURNS',t102,i8/                            &
     &10x,'HORIZONTAL BETA',t102,f16.10/                                &
     &10x,'HORIZONTAL BETA-II',t102,f16.10/                             &
     &10x,'HORIZONTAL BETA-III',t102,f16.10/                            &
     &10x,'VERTICAL BETA',t102,f16.10/                                  &
     &10x,'VERTICAL BETA-II',t102,f16.10/                               &
     &10x,'VERTICAL BETA-III',t102,f16.10/                              &
     &10x,'LONGITUDINAL BETA',t98,f20.10/                               &
     &10x,'LONGITUDINAL BETA-II',t102,f16.10/                           &
     &10x,'LONGITUDINAL BETA-III',t102,f16.10/                          &
     &10x,'HORIZONTAL ALFA',t102,f16.10/                                &
     &10x,'HORIZONTAL ALFA-II',t102,f16.10/                             &
     &10x,'HORIZONTAL ALFA-III',t102,f16.10)
10060 format(                                                           &
     &10x,'VERTICAL ALFA',t102,f16.10/                                  &
     &10x,'VERTICAL ALFA-II',t102,f16.10/                               &
     &10x,'VERTICAL ALFA-III',t102,f16.10/                              &
     &10x,'LONGITUDINAL ALFA',t102,f16.10/                              &
     &10x,'LONGITUDINAL ALFA-II',t102,f16.10/                           &
     &10x,'LONGITUDINAL ALFA-III',t102,f16.10/                          &
     &10x,'HORIZONTAL GAMMA',t102,f16.10/                               &
     &10x,'HORIZONTAL GAMMA-II',t102,f16.10/                            &
     &10x,'HORIZONTAL GAMMA-III',t102,f16.10/                           &
     &10x,'VERTICAL GAMMA',t102,f16.10/                                 &
     &10x,'VERTICAL GAMMA-II',t102,f16.10/                              &
     &10x,'VERTICAL GAMMA-III',t102,f16.10/                             &
     &10x,'LONGITUDINAL GAMMA',t102,f16.10/                             &
     &10x,'LONGITUDINAL GAMMA-II',t102,f16.10/                          &
     &10x,'LONGITUDINAL GAMMA-III',t102,f16.10/                         &
     &10x,'HORIZONTAL CLOSED ORBIT',t102,d16.10/                        &
     &10x,'VERTICAL CLOSED ORBIT',t102,d16.10/                          &
     &10x,'LONGITUDINAL CLOSED ORBIT',t102,d16.10/                      &
     &10x,'SLOPE OF HORIZONTAL CLOSED ORBIT',t102,d16.10/               &
     &10x,'SLOPE OF VERTICAL CLOSED ORBIT',t102,d16.10/                 &
     &10x,'SLOPE OF LONGITUDINAL CLOSED ORBIT',t102,d16.10/             &
     &10x,'HORIZONTAL DISPERSION',t102,f16.10/                          &
     &10x,'VERTICAL DISPERSION',t102,f16.10/                            &
     &10x,'SLOPE OF HORIZONTAL DISPERSION',t102,f16.10/                 &
     &10x,'SLOPE OF VERTICAL DISPERSION',t102,f16.10/                   &
     &10x,'LINEAR HORIZONTAL TUNE',t102,f16.10/                         &
     &10x,'LINEAR VERTICAL TUNE',t102,f16.10/                           &
     &10x,'LINEAR LONGITUDINAL TUNE',t102,f16.10)
10070 format( 10x,'DATA IS AVERAGED IN SAMPLES OF IAV TURNS',t96,       &
     &'IAV =    ',i7 /10x,'START TURN NUMBER FOR THE ANALYSIS ',t93,    &
     &'NSTART =  ',i9 /10x,'THE ANALYSIS STOPS AFTER TURN NUMBER ',t94, &
     &'NSTOP =  ',i9, /10x,                                             &
     &'HORIZONTAL ANGLE-INTERVAL FOR STROBOSCOPING THE VERTICAL',       &
     &' PHASESPACE PROJECTION',t94,'DPHIX = ',d16.10 /10x,              &
     &'VERTICAL ANGLE-INTERVAL FOR STROBOSCOPING THE HORIZONTAL',       &
     &' PHASESPACE PROJECTION',t94,'DPHIY = ',d16.10 /10x,              &
     &'SWITCH FOR THE WEIGHTING OF THE LINEAR FIT FOR THE ' ,           &
     &'DISTANCE IN PHASESPACE ',t96,'IWG = ',i4 /10x,                   &
     &'INTEGER PART FOR THE HORIZONTAL TUNE ',t96,'QX0 = ' ,f16.10 /10x,&
     &'INTEGER PART FOR THE VERTICAL TUNE ',t96,'QY0 = ' ,f16.10 )
10080 format( 10x,'SWITCH FOR THE QX-VALUE CLOSE TO AN HALF-INTEGER' ,  &
     &' ( INT => 1 ; HALF-INT => 0 )',t95,'IVOX = ',i4 /10x,            &
     &'SWITCH FOR THE QY-VALUE CLOSE TO AN HALF-INTEGER' ,              &
     &' ( INT => 1 ; HALF-INT => 0 )',t95,'IVOY = ',i4 /10x,            &
     &'Q-VALUES ARE CHECKED FOR RESONANCES UP TO ORDER',t95, 'IRES = ', &
     &i4 /10x,'A RESONANCE IS CONSIDERED TO BE STRONG WHEN THE Q-VALUES'&
     &, ' ARE CLOSER TO IT THAN',t95,'DRES = ',d16.10 /10x,             &
     &'SWITCH FOR FFT-RANGE ( IFH=0 => 0-1 ; IFH=1 => 0-.5 ' ,          &
     &'; IFH=2 => .5-1 )',t96,'IFH = ',i4 /10x,                         &
     &'Q-PEAKS OF THE FFT ARE CONSIDERED IF THEY ARE LARGER THAN' ,t95, &
     &'DFFT = ',d16.10 )
10090 format( 10x,                                                      &
     &'SWITCH FOR PRINTING THE DISTANCE IN PHASE SPACE' ,t95,'IDIS = ', &
     &i4 /10x,'SWITCH FOR PRINTING THE COORDINATES',t95,'ICOW = ',i4 /10&
     &x,'SWITCH FOR PRINTING THE STROBOSCOPED PHASESPACES',t95,         &
     &'ISTW = ',i4 /10x,'SWITCH FOR PRINTING THE FFT-SIGNALS',t95,      &
     &'IFFW = ',i4 ,i4 )
10100 format( 10x,'EVERY ISKIP VALUE IS USED FOR THE ANALYSIS' ,t94,    &
     &'ISKIP = ',i4 /10x,                                               &
     &'SWITCH OF COURANT SYNDER TRANSFORMATION (ICONV = 1 => OFF)' ,t93,&
     &' ICONV = ',i4 /10x,                                              &
     &'SWITCH FOR READING MAD DATA ( IMAD = 1 => MAD-DATA ' ,           &
     &'WITH LYAPUNOV ANALYSIS )',t95,'IMAD = ',i4 /10x,                 &
     &'SCALING OF MOMENTUM', ' WITH LYAPUNOV ANALYSIS',t95,'CMA1 = ',f16&
     &.10 /10x,'SCALING OF PATH-LENGTH', ' WITH LYAPUNOV ANALYSIS',t95, &
     &'CMA2 = ',f16.10 /10x,                                            &
     &'SWITCH FOR PRINTING OF THE POSTPROCESSING OUTPUT' ,              &
     &' NPRINT = ( 0 => OFF ; 1 => ON) ',t93,'NPRINT = ',i4 /10x,       &
     &'NUMBER OF BINARY FILES TO BE PROCESSED', ' ( 90 - [90-NDAFI+1] )'&
     &,t94,'NDAFI = ',i4 //)
10110 format(/10x,'ANALYSING THE INCREASE OF THE DISTANCE IN PHASE-' ,  &
     &'SPACE'/10x,53('-')/ //12x,'TURNS',10x,'DISTANCE',13x,            &
     &'SLOPE          RESIDUAL' /10x,63('-'))
10120 format(10x,i7,6x,d16.10,2(2x,f15.10))
10130 format(10x,63('-')//)
10140 format(//10x,'AVERAGED PHASE-ADVANCE' /10x,22('-')/ /10x,         &
     &'X-PHASE :  ',f14.10,'   +/_ ',f14.10 /10x,'Y-PHASE :  ',f14.10,  &
     &'   +/_ ',f14.10/ /10x,'S-PHASE :  ',f14.10,'   +/_ ',f14.10/ /10 &
     &x,'START-QX : ',f14.10,'   CHANGE IN X : ',d16.10 /10x,           &
     &'START-QY : ',f14.10,'   CHANGE IN Y : ',d16.10 /10x,'START-QS : '&
     &,f14.10,'   CHANGE IN S : ',d16.10// /10x,                        &
     &'THE AVERAGED PHASE-ADVANCES ARE CLOSER THEN ',d10.4,' TO ' ,     &
     &'THE FOLLOWING RESONANCES UP TO ',i3,' ORDER'/10x,98('-')/ /10x,  &
     &'NX * QX   +   NY * QY   -      P      =      DELTA'/10x, 52('-'))
10150 format(/10x,'WARNING ! X-PHASE MIGHT NOT BE PRECISE'/)
10160 format(/10x,'WARNING ! Y-PHASE MIGHT NOT BE PRECISE'//)
10170 format(12x,i2,11x,i3,7x,f8.1,9x,d10.4)
10180 format(//10x,'Q-VALUES FROM FFT-ROUTINE' /10x,25('-')/ /10x,      &
     &'THE ANALYSIS WAS DONE WITH ',i7,' ENTRIES.'/ /10x,               &
     &'THE FOLLOWING Q-PEAKS ARE LARGER THEN ',f8.4,' PERCENT.'/ /10x,  &
     &'PLANE          Q-VALUE            SIZE [%]'/10x,43('-'))
10190 format(12x,'X',7x,f14.10,5x,f14.10)
10200 format(12x,'Y',7x,f14.10,5x,f14.10)
10210 format(//10x,'MAXIMUM PEAK'/ /10x,'HORIZONTAL PLANE :  ',f14.10   &
     &/10x,'VERTICAL PLANE   :  ',f14.10/ /10x,'START-QX : ',f14.10,    &
     &'   CHANGE IN X : ',d16.10 /10x,'START-QY : ',f14.10,             &
     &'   CHANGE IN Y : ',d16.10// /10x,                                &
     &'THE MAXIMUM Q-PEAKS ARE CLOSER THEN ',d10.4,' TO ' ,             &
     &'THE FOLLOWING RESONANCES UP TO ',i3,' ORDER'/10x,96('-')/ /10x,  &
     &'NX * QX   +   NY * QY   -      P      =      DELTA'/10x, 52('-'))
10220 format(////10x,'CALCULATION OF THE AVERAGED EMITTANCES' /10x,38(  &
     &'-')// 24x,'START-EMITTANCE           START-AMPLITUDE'// 10x,     &
     &'HORIZONTAL   ',f16.10,9x,f16.10/ 10x,'VERTICAL     ',f16.10,9x,  &
     &f16.10// 14x,'PLANE',10x,'EMITTANCE',16x,'SMEAR',12x,'MAXIMUM',11 &
     &x, 'MINIMUM'/28x,'[PI*MM*MRAD]',15x,'[%]',15x,'[%]',15x, '[%]'/10 &
     &x,86('-')/ 10x,'HORIZONTAL',6x,f16.10,3(6x,f12.6)/ 10x,'VERTICAL',&
     &8x,f16.10,3(6x,f12.6)/ 10x,'SUM',13x,f16.10,3(6x,f12.6)/10x,86('-'&
     &)//)
10230 format(//10x,'INVARIANTS OF THE 4-DIMENSIONAL PHASE-SPACE' /10x,43&
     &('-')//)
10240 format(/10x,'WARNING ! CALCULATION OF THE HORIZONTAL INVARIANT' , &
     &' MIGHT NOT BE PRECISE'/10x,'ONLY ',i5,' ENTRIES COMPARED TO ' ,  &
     &i5,' ANGLE-INTERVALS !'/10x,'INCREASE THE VERTICAL ANGLE-INT' ,   &
     &'ERVAL <DPHIY>'/)
10250 format(/10x,'WARNING ! CALCULATION OF THE VERTICAL INVARIANT' ,   &
     &' MIGHT NOT BE PRECISE'/10x,'ONLY ',i5,' ENTRIES COMPARED TO ' ,  &
     &i5,' ANGLE-INTERVALS !'/10x,'INCREASE THE HORIZONTAL ANGLE-INT' , &
     &'ERVAL <DPHIX>'/)
10260 format(/10x,'THERE ARE ',i5,' ENTRIES FOR THE CALCULATION OF' ,   &
     &' THE HORIZONTAL INVARIANT GROUPED IN ',i5,' ANGLE-INTERVALS' /10 &
     &x,'--------- ',i5,' ENTRIES ----------------------' ,             &
     &'---- VERTICAL   -------------------- ',i5,' ANGLE-INTERVALS' //10&
     &x,'IF THE MOTION IS CLOSE TO FIXPOINTS THE NUMBER OF THOSE' ,     &
     &' ANGLE-INTERVALS WILL BE ONLY A SMALL FRACTION'/10x,             &
     &'OF THE TOTAL NUMBER OF ',i5,' INTERVALS.'/ /25x,                 &
     &'PERCENTAGE OF OCCUPIED INTERVALS     NUMBER OF ENTRIES ' ,       &
     &'PER OCCUPIED INTERVAL' /10x,'HORIZONTAL',16x,f10.6,30x,f12.6 /10 &
     &x,'VERTICAL  ',16x,f10.6,30x,f12.6/ //10x,                        &
     &'THE CALCULATED INVARIANTS ARE IN UNITS OF [PI*MM*MRAD]'/ /10x,   &
     &'HORIZONTAL',10x,f16.10 /10x,'VERTICAL  ',10x,f16.10//)
10270 format(////10x,'LINEARLY DECOUPLED INVARIANTS' /10x,35('-')/ 10x, &
     &'INITIAL EMITTANCE MODE I   :',f16.10/ 10x,                       &
     &'INITIAL EMITTANCE MODE II  :',f16.10/ 10x,                       &
     &'INITIAL EMITTANCE MODE III :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE I   :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE II  :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE III :',f16.10/ /10x,35('-')// 14x,'PLANE',&
     &10x,'EMITTANCE',14x,'4D-SMEAR',11x,'MAXIMUM',11x, 'MINIMUM'/28x,  &
     &'[PI*MM*MRAD]',15x,'[%]',15x,'[%]',15x, '[%]'/10x,86('-')/ 10x,   &
     &'HORIZONTAL',6x,f16.10,3(6x,f12.6)/ 10x,'VERTICAL',8x,f16.10,3    &
     &(6x,f12.6)/ 10x,'SUM',13x,f16.10,3(6x,f12.6)/10x,86('-')//)
10280 format(/10x,'Postprocessing took ',f12.3,' second(s)',            &
     &' of Execution Time'//131('-')//)
10290 format(//10x,'** ERROR ** ----- TRANSFORMATION MATRIX SINGULAR ' ,&
     &'(FILE : ',i2,') -----'//)
10300 format(//10x,'** ERROR ** ----- FILE :',i2,' WITH TRACKING ' ,    &
     &'DATA EMPTY OR CORRUPTED-----'/10x,'PROBLEM : ',a80//)
10310 format(//10x,'** ERROR ** ----- WEIGHTING OF DISTANCE IN PHASE' , &
     &' SPACE (FILE : ',i2,') NOT POSSIBLE-----'//)
10320 format(//10x,'** ERROR ** ----- INPUT DATA CORRUPTED' ,' (FILE : '&
     &,i2,') -----'//)
      end
 
      subroutine fma_error(ierro,str,subroutine_name)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: error messages for fma analysis                             *
!-----------------------------------------------------------------------*
      implicit none
      integer,       intent(in)  :: ierro
      character (*), intent (in) :: subroutine_name
      character (*), intent (in) :: str             !error message
      if(ierro.ne.0) then
        write(*,*) 'ERROR in ',subroutine_name,': ',
     & str,', iostat=',ierro
        call prror(-1)
      endif
      end subroutine
 
      subroutine fma_norm_phase_space_matrix(fma_tas_inv,fma_tas)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: invert the matrix of eigenvecors tas                        *
!           (code copied from postpr only that ta is here fma_tas)      *
!           x(normalized)=fma_tas^-1 x=fma_tas_inv x                    *
!           note: inversion method copied from subroutine postpr        *
!-----------------------------------------------------------------------*
      implicit none
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      double precision tasm
      common/tasm/tasm(6,6)
      integer :: i,j            !iterators
      double precision, dimension(6,6), intent(inout) :: fma_tas !tas = normalis
      double precision, dimension(6,6), intent(out) :: fma_tas_inv !inverse of t
      integer ierro                   !error messages
!     dummy variables
      double precision, dimension(6,6) :: tdummy !dummy variable for transposing
      integer, dimension(6) :: idummy !for matrix inversion
!     units: [mm,mrad,mm,mrad,mm,1]
!     invert matrix
!     - set values close to 1 equal to 1
      do 160 i=1,6
        do 160 j=1,6
  160 fma_tas_inv(i,j)=fma_tas(j,i)
      if(abs(fma_tas_inv(1,1)).le.pieni.and.abs(fma_tas_inv(2,2)).le.   &
     &pieni) then
        fma_tas_inv(1,1)=one
        fma_tas_inv(2,2)=one
      endif
      if(abs(fma_tas_inv(3,3)).le.pieni.and.abs(fma_tas_inv(4,4)).le.   &
     &pieni) then
        fma_tas_inv(3,3)=one
        fma_tas_inv(4,4)=one
      endif
      if(abs(fma_tas_inv(5,5)).le.pieni.and.abs(fma_tas_inv(6,6)).le.   &
     &pieni) then
        fma_tas_inv(5,5)=one
        fma_tas_inv(6,6)=one
      endif
!     - invert: dinv returns the transposed matrix
      call dinv(6,fma_tas_inv,6,idummy,ierro)
      call fma_error(ierro,'matrix inversion failed!',                  &
     &'fma_norm_phase_space_matrix')
!     - transpose fma_tas_inv
      tdummy=fma_tas_inv
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j)=tdummy(j,i)
        enddo
      enddo
      end subroutine fma_norm_phase_space_matrix
 
      subroutine fma_postpr
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: return files used for fma analysis                          *
!           -> calculate particle amplitudes and tunes using the        *
!              normalized coordinates for input files                   *
!              fma_fname(fma_numfiles)                                  *
!  output format: q1,q2,q3,eps1_min,eps2_min,eps3_min,eps1_max,         *
!                 eps2_max,eps3_max,eps1_avg, eps2_avg,eps3_avg,        *
!                 eps1_0,eps2_0,eps3_0,phi1_0,phi2_0,phi3_0             *
!-----------------------------------------------------------------------*
      implicit none
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, an
 
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code
 
*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and it
                                                 ! (nchars in daten +1 to always
 
*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each ele
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
 
      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (norma
 
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be act
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
 
      character dump_fname (0:nele)*(getfields_l_max_string)
 
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      !For resetting file positions
      integer dumpfilepos, dumpfilepos_cr
      common /dumpdbCR/ dumpfilepos(0:nele), dumpfilepos_cr(0:nele)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     M. Fitterer, for CERN BE-ABP/HSS and Fermilab
!     Common block for the FMA analysis postprocessing
      integer, parameter :: fma_max       = 200              !max. number of FMA
      integer, parameter :: fma_nturn_max = 10000            !max. number of tur
      integer fma_numfiles                                   !number of FMAs
      logical fma_flag                                       !FMA input block ex
      character fma_fname  (fma_max)*(getfields_l_max_string)!name of input file
      character fma_method (fma_max)*(getfields_l_max_string)!method used to fin
      integer fma_nturn    (fma_max)                         !number of turns us
      integer fma_norm_flag(fma_max)                         !fma_norm_flag=0, d
      common /fma_var/ fma_fname,fma_method,fma_numfiles,fma_flag,
     &fma_norm_flag,fma_nturn
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision tasm
      common/tasm/tasm(6,6)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer :: i,j,k,l,m,n !for do loops
      integer :: fma_npart,fma_tfirst,fma_tlast !local variables to check input
      logical :: lopen              !flag to check if file is already open
      logical :: lexist             !flag to check if file fma_fname exists
      logical :: lread              !flag for file reading
      character(len=getfields_l_max_string) :: ch,ch1
      character filefields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
      integer filefields_nfields
      integer filefields_lfields( getfields_n_max_fields )
      logical filefields_lerr
      double precision round_near
 
      integer, dimension(npart,fma_nturn_max) :: turn ! npart = max. number of p
      double precision, dimension(6,6) :: fma_tas ! dump_tas in units [mm,mrad,m
      double precision, dimension(6,6) :: fma_tas_inv ! normalisation matrix = i
      double precision, dimension(npart,fma_nturn_max,6) ::
     &xyzv,nxyzv ! phase space (x,x',y,y',z,dE/E) [mm,mrad,mm,mrad,mm,1.e-3], no
      double precision, dimension(npart,fma_nturn_max,3) ::
     &epsnxyzv ! normalized emittances
      double precision :: tunelask,tuneffti,tunefft,tuneapa,tunefit,    &
     &tunenewt,tuneabt2,tuneabt,tunenewt1
!     dummy variables for readin + normalisation + loops
      integer :: id,kt,counter
      double precision :: pos
      double precision, dimension(6) :: xyzvdummy,nxyzvdummy !phase space variab
      double precision, dimension(3) :: q123 !tune q1,q2,q3
      double precision, dimension(3) :: eps123_0,eps123_min,eps123_max, &
     &eps123_avg !initial,minimum,maximum,average emittance
      double precision, dimension(3) :: phi123_0  !initial phase
 
 
!     initialize variables
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j) = 0
        enddo
      enddo
 
!     fma_six = data file for storing the results of the FMA analysis
      inquire(unit=2001001,opened=lopen)
      if(lopen) then
         write(*,*)    "ERROR in FMA: Tried to open unit 2001001",
     &        "for file 'fma_sixtrack', but it was already taken?"
         call prror(-1)
      endif
      open(2001001,file='fma_sixtrack',status='replace',iostat=ierro,   &
     &action='write',form='formatted')
      call fma_error(ierro,'cannot open file fma_sixtrack for writing!',&
     &'fma_postpr')
 
!     write the header
      write(2001001,'(a)') '# eps1*,eps2*,eps3* all in 1.e-6*m, '//
     &'phi* [rad]'
      write(2001001,'(a)') '# inputfile method id q1 q2 q3 eps1_min '//
     &'eps2_min eps3_min eps1_max eps2_max eps3_max eps1_avg eps2_avg'//
     &' eps3_avg eps1_0 eps2_0 eps3_0 phi1_0 phi2_0 phi3_0'
 
!      start FMA analysis: loop over all files, calculate tunes, write output fi
      do i=1,fma_numfiles
        lexist=.false.
        do j=1,nele !START: loop over dump files
          if(trim(stringzerotrim(fma_fname(i))).eq.
     &trim(stringzerotrim(dump_fname(j)))) then
            lexist=.true.     !set lexist = true if the file fma_fname(j) exists
            write(*,*) 'start FMA analysis using file ',                &
     &trim(stringzerotrim(fma_fname(i))),': number of particles=',napx, &
     &', first turn=',dumpfirst(j),', last turn=',dumplast(j)
 
!    check the format, if dumpfmt != 2 abort
            if(dumpfmt(j).ne.2) then
              call fma_error(-1,'input file has wrong format! Choose for&
     &mat=2 in DUMP block.','fma_postpr')
            endif
!    open dump file for reading, resume to original position before exiting the
            inquire(unit=dumpunit(j),opened=lopen)
            if(lopen) then
              close(dumpunit(j))
            else ! file has to be open if nothing went wrong
              call fma_error(-1,'file '//trim(stringzero                &
     &trim(dump_fname(j)))//' has to be open','fma_postpr')
            endif
            open(dumpunit(j),file=dump_fname(j),status='old',
     &iostat=ierro,action='read')
            call fma_error(ierro,'cannot open file '//trim(stringzero   &
     &trim(dump_fname(j))),'fma_postpr')
 
!    now we can start reading in the file
!    - skip header
            counter=1
            do
              read(dumpunit(j),'(A)',iostat=ierro) ch
              call fma_error(ierro,'while reading file ' //             &
     &dump_fname(j),'fma_postpr')
              ch1=adjustl(trim(ch))
              if(ch1(1:1).ne.'#')  exit
              if(counter>500) then
                call fma_error(ierro,'Something is wrong with your '//  &
     &'inputfile '//trim(stringzerotrim(dump_fname(j)))//'! We found '//&
     &'more than 500 header lines','fma_postpr')
              endif
              counter=counter+1
            enddo
            backspace(dumpunit(j),iostat=ierro)
!   read in particle amplitudes
            fma_nturn(i) = dumplast(j)-dumpfirst(j)+1 !number of turns used for
            if(fma_nturn(i).gt.fma_nturn_max) then
              write(*,*) 'ERROR in fma_postpr: only ',                  &
     &fma_nturn_max,' turns allowed for fma and ',fma_nturn(i),' used!'
              write(*,*) '->reset fma_nturn_max > ', fma_nturn_max
              call prror(-1)
            endif
 
!    - now we have done all checks, we only need the normalisation matrix
!         units: dump_tas [mm,mrad,mm,mrad,1.e-3]
!                fma_tas  [mm,mrad,mm,mrad,1]
!      note: closed orbit dump_clo already converted in linopt part
            do m=1,6
              do n=1,6
                fma_tas(m,n)=dump_tas(j,m,n)
              enddo
            enddo
            do m=1,5
              fma_tas(m,6)=fma_tas(m,6)*1.e3
              fma_tas(6,m)=fma_tas(6,m)*1.e-3
            enddo
            call fma_norm_phase_space_matrix(fma_tas_inv,
     &                                       fma_tas(1:6,1:6) )
 
!     dump normalized particle amplitudes for debugging (200101+i*10)
            inquire(unit=200101+i*10,opened=lopen)
            if(lopen) then
               write(*,*)    "ERROR in FMA: Tried to open unit",
     &            200101+i*10, "for file 'NORM_"//dump_fname(j)//
     &            "', but it was already taken?!?"
               call prror(-1)
            endif
 
            open(200101+i*10,file='NORM_'//dump_fname(j),
     &           status='replace',iostat=ierro,action='write') ! nx,nx',ny,ny'
!    - write closed orbit in header of file with normalized phase space coordina
!      units: x,xp,y,yp,sig,dp/p = [mm,mrad,mm,mrad,1] (note: units are already
            write(200101+i*10,'(a,1x,6(1X,1PE16.9))') '# closorb',
     &           dump_clo(j,1),dump_clo(j,2),dump_clo(j,3),
     &           dump_clo(j,4),dump_clo(j,5),dump_clo(j,6)
!    - write tas-matrix and its inverse in header of file with normalized phase
!      units: x,px,y,py,sig,dp/p [mm,mrad,mm,mrad,1]
            write(200101+i*10,'(a)') '# tamatrix'
            do m=1,6
              do n=1,6
                write(200101+i*10,'(a,1x,1PE16.9)') '# ',
     &                fma_tas(m,n)
            enddo
            enddo
            write(200101+i*10,'(a)') '# inv(tamatrix)'
            do m=1,6
              do n=1,6
                write(200101+i*10,'(a,1x,1PE16.9)') '# ',
     &                fma_tas_inv(m,n)
              enddo
            enddo
            write(200101+i*10,'(a)') '# id turn pos[m] nx[1.e-3'//
     &' sqrt(m)] npx[1.e-3 sqrt(m)] ny[1.e-3 sqrt(m)] npy[1.e-3'//
     &' sqrt(m)] nsig[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] kt'
!    - read in particle amplitudes a(part,turn), x,xp,y,yp,sigma,dE/E [mm,mrad,m
            do k=1,fma_nturn(i) !loop over turns
              do l=1,napx !loop over particles
                read(dumpunit(j),'(a)', iostat=ierro) ch
                if(ierro.gt.0) call fma_error(ierro,'while reading '    &
     &//' particles from file' // dump_fname(j) // '. Check that tracked
     & turns is larger than number of turns used for FFT!','fma_postpr')!read er
                call getfields_split(ch,filefields_fields,
     &filefields_lfields,filefields_nfields, filefields_lerr)
                if( filefields_lerr ) call fma_error(-1,'while reading '&
     &//' particles from file ' // dump_fname(j) // 'in function getfiel&
     &ds_split','fma_postpr') !error in getfields_split while reading
!    check if number of fields is correct
                if( filefields_nfields  .ne. 10 ) then
                  write(*,*) 'ERROR in fma_postpr while reading particle&
     &s from file ',trim(stringzerotrim(dump_fname(j))),'. 10 fields exp&
     &ected from getfields_split, got ',filefields_nfields, ' and ch =',&
     &ch
                  call prror(-1)
                endif
                read(filefields_fields(1)(1:filefields_lfields(1)),*) id
                read(filefields_fields(2)(1:filefields_lfields(2)),*)
     &turn(l,k)
                pos = round_near(ierro, filefields_lfields(3)+1,
     &filefields_fields(3) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,3,pos)
                xyzvdummy(1) = round_near(ierro, filefields_lfields(4)+1
     &,filefields_fields(4) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,4,xyzvdummy(1))
                xyzvdummy(2) = round_near(ierro, filefields_lfields(5)+1
     &,filefields_fields(5) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,5,xyzvdummy(2))
                xyzvdummy(3) = round_near(ierro, filefields_lfields(6)+1
     &,filefields_fields(6) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,6,xyzvdummy(3))
                xyzvdummy(4) = round_near(ierro, filefields_lfields(7)+1
     &,filefields_fields(7) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,7,xyzvdummy(4))
                xyzvdummy(5) = round_near(ierro, filefields_lfields(8)+1
     &,filefields_fields(8) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,8,xyzvdummy(5))
                xyzvdummy(6) = round_near(ierro, filefields_lfields(9)+1
     &,filefields_fields(9) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,9,xyzvdummy(6))
                read(filefields_fields(10)(1:filefields_lfields(10)),*)
     &kt
!    - remove closed orbit -> check units used in dump_clo (is x' or px used?)
                do m=1,6
                  xyzvdummy(m)=xyzvdummy(m)-dump_clo(j,m)
                enddo
!    - for FMA in physical coordinates, convert units to [mm,mrad,mm,mrad,mm,1.e
                do m=1,6
                  if(m.eq.6) then
                    xyzv(l,k,m)=xyzvdummy(m)*c1e3
                  else
                    xyzv(l,k,m)=xyzvdummy(m)
                  endif
                enddo
!    - convert to canonical variables
                xyzvdummy(2)=xyzvdummy(2)*((one+xyzvdummy(6))+
     &dump_clo(j,6))
                xyzvdummy(4)=xyzvdummy(4)*((one+xyzvdummy(6))+
     &dump_clo(j,6))
!    - normalize nxyz=fma_tas_inv*xyz
                do m=1,6
                  nxyzvdummy(m)=zero
                  do n=1,6
                    nxyzvdummy(m)=nxyzvdummy(m)+fma_tas_inv(m,n)*       &
     &xyzvdummy(n)
                  enddo
!      a) convert nxyzv(6) to 1.e-3 sqrt(m)
!         unit: nx,npx,ny,npy,nsig,ndelta all in [1.e-3 sqrt(m)]
                  if(m.eq.6) then
                    nxyzv(l,k,m)=nxyzvdummy(m)*c1e3
                  else
                    nxyzv(l,k,m)=nxyzvdummy(m)
                  endif
!      b) calculate emittance of mode 1,2,3
                  if(mod(m,2).eq.0) then
                    epsnxyzv(l,k,m/2)=nxyzvdummy((m-1))**2+             &
     &nxyzvdummy(m)**2
                  endif
                enddo
                write(200101+i*10,1986) id,turn(l,k),pos,               &
     &nxyzv(l,k,1),nxyzv(l,k,2),nxyzv(l,k,3),nxyzv(l,k,4),nxyzv(l,k,5), &
     &nxyzv(l,k,6),kt! write normalized particle amplitudes
              enddo
            enddo
!     calculate tunes of particles using the methods in plato_seq.f
!     for fma_norm_flag = 0 use physical coordinates x,x',y,y',sig,dp/p
!         fma_norm_flag > 0 use normalized coordinates
            do l=1,napx ! loop over particles
              do m=1,3 ! loop over modes (hor.,vert.,long.)
                 select case( trim(stringzerotrim(fma_method(i))) )
                 case('TUNELASK')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunelask(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunelask(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEFFTI')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneffti(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneffti(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEFFT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunefft(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunefft(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEAPA')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneapa(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneapa(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEFIT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunefit(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunefit(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNENEWT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunenewt(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunenewt(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEABT2')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneabt2(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneabt2(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNEABT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneabt(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneabt(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case('TUNENEWT1')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunenewt1(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunenewt1(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
 
                 case default
                    call fma_error(-1,'FMA method '//
     &                   trim(stringzerotrim(fma_method(i)))//
     &                   ' not known! Note method name must be in'//
     &                   ' capital letters!','fma_postpr')
                 end select
 
                if(m.eq.3) q123(m)=one-q123(m)                       ! mode 3 ro
                eps123_0(m)=epsnxyzv(l,1,m)                          ! initial a
                phi123_0(m)=atan_rn(nxyzv(l,1,2*m)/nxyzv(l,1,2*(m-1)+1))! inital
                eps123_min(m)=minval(epsnxyzv(l,1:fma_nturn(i),m),      &
     &fma_nturn(i))      ! minimum emittance
                eps123_max(m)=maxval(epsnxyzv(l,1:fma_nturn(i),m),      &
     &fma_nturn(i))      ! maximum emittance
                eps123_avg(m)=sum(epsnxyzv(l,1:fma_nturn(i),m))/        &
     &fma_nturn(i) ! average emittance
              enddo
              write(2001001,1988) trim(stringzerotrim(fma_fname(i))),   &
     &trim(stringzerotrim(fma_method(i))),l,q123(1),q123(2),q123(3),    &
     &eps123_min(1),eps123_min(2),eps123_min(3),eps123_max(1),          &
     &eps123_max(2),eps123_max(3),eps123_avg(1),eps123_avg(2),          &
     &eps123_avg(3),eps123_0(1),eps123_0(2),eps123_0(3),                &
     &phi123_0(1),phi123_0(2),phi123_0(3)
            enddo
            close(200101+i*10)! filename NORM_* (normalized particle amplitudes)
            close(dumpunit(j))
!    resume initial position of dumpfile = end of file
            open(dumpunit(j),file=dump_fname(j), status='old',          &
     &form='formatted',action='readwrite',position='append',            &
     &iostat=ierro)
            call fma_error(ierro,'while resuming file '//dump_fname(j), &
     &'fma_postpr')
          endif !END: if fma_fname(i) matches dump_fname(j)
!    if file has been already found, jump to next file fma_fname(i)
          if( lexist ) then
            exit
          endif
        enddo !END: loop over dump files
        if(.not. lexist) then !if no dumpfile has been found, raise error and ab
          call fma_error(-1,'dump file '//trim(stringzero               &
     &trim(fma_fname(i)))//' does not exist! Please check that filenames&
     & in FMA block agree with the ones in the DUMP block!'             &
     &,'fma_postpr')
        endif
      enddo !END: loop over fma files
      close(2001001) !filename: fma_sixtrack
 
 1986 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9),1X,I8)   !fmt 2 / not hiprec as in
 1988 format (2(1x,A20),1x,I8,18(1X,1PE16.9))          !fmt for fma output file
      end subroutine fma_postpr
 
      subroutine fft(ar,ai,m,n)
!---------------------------------------------------------------------
!      A(N) IS A COMPLEX ARRAY. THE INPUT IS A(N)=(X(N),0.0), WHERE
!      X(N) IS THE SEQUENCE TO FOURIER ANALYSE.
!      N=2**M.
!      THIS ROUTINE ONLY WORKS FOR N EQUAL TO A POWER OF TWO.
!      AFTER RETURN A(N)=(..,..) CONTAINS THE COEFFICIENTS OF THE FFT.
!      TO COMPUTE POWER SPECTRA DO   ...=ABS(A(N))
!
!      WRITTEN BY : RUI DILAO
!
!---------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ip,j,k,l,le,le1,m,n,nm1,nv2
      double precision ar,ai,pi,tr,ti,ui,ur,uur,wr,wi
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension ar(n),ai(n)
      save
!-----------------------------------------------------------------------
      n=2**m
      nv2=n/2
      nm1=n-1
      j=1
      do 30 i=1,nm1
        if(i.gt.j)goto 10
        tr=ar(j)
        ti=ai(j)
        ar(j)=ar(i)
        ai(j)=ai(i)
        ar(i)=tr
        ai(i)=ti
   10   k=nv2
   20   if(k.ge.j)goto 30
        j=j-k
        k=k/2
        goto 20
   30 j=j+k
      pi=four*atan_rn(one)
      do 50 l=1,m
        le=2**l
        le1=le/2
        ur=one
        ui=zero
!hr06   wr=cos_rn(pi/le1)
        wr=cos_rn(pi/dble(le1))                                          !hr06
!hr06   wi=-sin_rn(pi/le1)
        wi=-1d0*sin_rn(pi/dble(le1))                                     !hr06
        do 50 j=1,le1
          do 40 i=j,n,le
            ip=i+le1
            tr=ar(ip)*ur-ai(ip)*ui
            ti=ar(ip)*ui+ai(ip)*ur
            ar(ip)=ar(i)-tr
            ai(ip)=ai(i)-ti
            ar(i)=ar(i)+tr
            ai(i)=ai(i)+ti
   40     continue
        uur=ur*wr-ui*wi
        ui=ur*wi+ui*wr
        ur=uur
   50 continue
      do 60 i=1,n
!hr06   ar(i)=ar(i)/n*2
        ar(i)=(ar(i)/dble(n))*2                                          !hr06
!hr06   ai(i)=ai(i)/n*2
        ai(i)=(ai(i)/dble(n))*2                                          !hr06
   60 continue
      return
      end
      subroutine caconv(a,b,c)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      double precision a,b,c
      save
!---------------------------------------------------------------------
      if(abs(b).gt.pieni.or.abs(c).gt.pieni) then
        a=atan2_rn(b,c)
      else
        a=zero
      endif
      return
      end
      subroutine cphase(k,a,b,c,d,i,j,ie)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ie,j,k
      double precision a,b,c,d,f,phase,tpi,dani
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      common/phasecom/ phase(3,npos+1)
      common/invari/ dani(ninv+1)
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!-----                                                                   -----
!-----    NEW BLOCKS PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----        G. ROBERT-DEMOLAIZE, October 27th, 2004                    -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
      save
!---------------------------------------------------------------------
!hr06 tpi=8*atan_rn(one)
      tpi=8d0*atan_rn(one)                                               !hr06
      if(abs(b).gt.pieni.or.abs(c).gt.pieni) then
        f=atan2_rn(b,c)
        ie=ie+1
        phase(k,ie)=f/tpi+d
        if(i.ne.1.and.-f.gt.pieni) phase(k,ie)=phase(k,ie)+one
        a=a+phase(k,ie)
      else
        j=1
      endif
      return
      end
      subroutine cinvar(a,b,c,d,j,e,xinv,invx)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,invx,j
      double precision a,b,c,d,phase,dani,e,xinv
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      common/phasecom/ phase(3,npos+1)
      common/invari/ dani(ninv+1)
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!-----                                                                   -----
!-----    NEW BLOCKS PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----        G. ROBERT-DEMOLAIZE, October 27th, 2004                    -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
      dimension xinv(ninv),invx(ninv)
      save
!---------------------------------------------------------------------
      if(abs(a).le.b) then
        do 10 i=1,ninv
          if((c.ge.zero.and.c.ge.dani(i).and.c.lt.dani(i+1)).or. (c.lt. &
     &zero.and.d.ge.dani(i).and.d.lt.dani(i+1))) then
            j=j+1
            if(abs(xinv(i)).le.pieni) then
              xinv(i)=e
              invx(i)=1
            else
              xinv(i)=xinv(i)+e
              invx(i)=invx(i)+1
            endif
          endif
   10   continue
      endif
      return
      end
      subroutine sinpro(a,b,c,d,e)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      double precision a,b,c,d,e
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      save
!---------------------------------------------------------------------
      if(abs(a).gt.pieni) then
        if(c.gt.pieni.and.b.gt.pieni) then
!hr06     c=sqrt(c/b)/a*100
          c=(sqrt(c/b)/a)*100d0                                          !hr06
        else
          c=zero
        endif
!hr06   d=(d-a)/a*100
        d=((d-a)/a)*100d0                                                !hr06
!hr06   e=(e-a)/a*100
        e=((e-a)/a)*100d0                                                !hr06
      else
        c=zero
        d=zero
        e=zero
      endif
      return
      end
      subroutine join
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ia,idummy,ierro,ifipa,ihalf,ilapa,ipa,ipa1,itopa,numl
      double precision alf0,bet0,clo,clop,dam,di0,dip0,dps,dummy,e0,pi, &
     &qwc,sigm,ta,x,y
      character*80 sixtit,commen
      character*8 cdate,ctime,progrm
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer icode,idam,its6d
      double precision dpscor,sigcor
      common/corcom/dpscor,sigcor,icode,idam,its6d
      dimension bet0(2),alf0(2),ta(6,6)
      dimension qwc(3),clo(3),clop(3)
      dimension x(mpa,2),y(mpa,2),sigm(mpa),dps(mpa)
      dimension di0(2),dip0(2)
      save
!-----------------------------------------------------------------------
      pi=four*atan_rn(one)
      sigcor=one
      dpscor=one
      read(90,end=60,iostat=ierro) sixtit,commen,cdate,ctime, progrm,   &
     &ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),&
     &clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),     &
     &dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta  &
     &(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),ta &
     &(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta(5,6), ta&
     &(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6)
      if(ierro.gt.0) then
        write(*,10010) 90,ierro
        goto 70
      endif
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      bet0(1)=ta(1,1)*ta(1,1)+ta(1,2)*ta(1,2)
      alf0(1)=-(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))
      bet0(2)=ta(3,3)*ta(3,3)+ta(3,4)*ta(3,4)
      alf0(2)=-(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))
      rewind 90
      ihalf=itopa/2
      if(icode.eq.1.or.icode.eq.2.or.icode.eq.4) idam=1
      if(icode.eq.3.or.icode.eq.5.or.icode.eq.6) idam=2
      if(icode.eq.7) idam=3
      do 50 i=1,ihalf
        read(91-i,end=50,iostat=ierro)
        if(ierro.gt.0) then
          write(*,10010) 91-i,ierro
          goto 50
        endif
        read(91-i-ihalf,end=50,iostat=ierro)
        if(ierro.gt.0) then
          write(*,10010) 91-i-ihalf,ierro
          goto 50
        endif
   10   read(91-i,end=20,iostat=ierro) ia,ipa,dummy, x(1,1),y(1,1),x    &
     &(1,2),y(1,2),sigm(1),dps(1),e0
        if(ierro.gt.0) then
          write(*,10010) 91-i,ierro
          goto 20
        endif
        x(1,1)=x(1,1)*c1e3
        y(1,1)=y(1,1)*c1e3
        x(1,2)=x(1,2)*c1e3
        y(1,2)=y(1,2)*c1e3
        sigm(1)=sigm(1)*c1e3
        e0=e0*c1e3
        read(91-i-ihalf,end=20,iostat=ierro) idummy,idummy,dummy, x     &
     &(2,1),y(2,1),x(2,2),y(2,2),sigm(2),dps(2)
        if(ierro.gt.0) then
          write(*,10010) 91-i-ihalf,ierro
          goto 20
        endif
        x(2,1)=x(2,1)*c1e3
        y(2,1)=y(2,1)*c1e3
        x(2,2)=x(2,2)*c1e3
        y(2,2)=y(2,2)*c1e3
        sigm(2)=sigm(2)*c1e3
        write(90,iostat=ierro) ia,ipa,dummy, x(1,1),y(1,1),x(1,2),y     &
     &(1,2),sigm(1),dps(1),e0, ipa+1,dam,x(2,1),y(2,1),x(2,2),y(2,2),   &
     &sigm(2),dps(2),e0
        if(ierro.ne.0) then
          write(*,10010) 90,ierro
          goto 20
        endif
        goto 10
   20   rewind 91-i
        rewind 91-i-ihalf
        write(91-i-ihalf,iostat=ierro)
        if(ierro.ne.0) then
          write(*,10010) 91-i-ihalf,ierro
        endif
        rewind 90
        read(91-i,iostat=ierro) sixtit,commen,cdate,ctime, progrm,ifipa,&
     &ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),clo   &
     &(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),dummy,  &
     &dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta(2,1),  &
     &ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta       &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),   &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta       &
     &(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6)
        if(ierro.gt.0) then
          write(*,10010) 91-i,ierro
          goto 40
        endif
        rewind 91-i
        progrm='MADTOSIX'
        write(91-i,iostat=ierro) sixtit,commen,cdate,ctime, progrm,2*i  &
     &-1,2*i,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),clo  &
     &(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),dummy,  &
     &dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta(2,1),  &
     &ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta       &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),   &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta       &
     &(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6), zero,     &
     &zero,zero,zero,sigcor,dpscor, zero,zero,zero,zero, zero,zero,     &
     &zero,zero,zero,zero,zero,zero,zero,zero, zero,zero,zero,zero,     &
     &zero,zero,zero,zero,zero,zero, zero,zero,zero,zero,zero,zero,     &
     &zero,zero,zero,zero, zero,zero,zero,zero,zero,zero,zero,zero,     &
     &zero,zero
        if(ierro.ne.0) then
          write(*,10010) 91-i,ierro
          goto 40
        endif
   30   read(90,end=40,iostat=ierro) ia,ipa,dam, x(1,1),y(1,1),x(1,2),y &
     &(1,2),sigm(1),dps(1),e0, ipa1,dam,x(2,1),y(2,1),x(2,2),y(2,2),    &
     &sigm(2),dps(2),e0
        if(ierro.gt.0) then
          write(*,10010) 90,ierro
          goto 40
        endif
        write(91-i,iostat=ierro) ia,ipa,dam, x(1,1),y(1,1),x(1,2),y     &
     &(1,2),sigm(1),dps(1),e0, ipa1,dam,x(2,1),y(2,1),x(2,2),y(2,2),    &
     &sigm(2),dps(2),e0
        if(ierro.ne.0) then
          write(*,10010) 91-i,ierro
          goto 40
        endif
        goto 30
   40   rewind 90
        rewind 91-i
   50 continue
      goto 70
   60 continue
      write(*,10000) 90
   70 continue
!-----------------------------------------------------------------------
      return
10000 format(//10x,'** ERROR IN JOIN** ----- INPUT DATA EMPTY' ,        &
     &' (FILE : ',i2,') -----'//)
10010 format(//10x,'** ERROR IN JOIN** ----- PROBLEMS WITH DATA ' ,     &
     &'FILE : ',i2,' ----- ERROR CODE : ',i10//)
      end
      subroutine sumpos
!-----------------------------------------------------------------------
!  SUBROUTINE TO SUMMARIZE THE RESULTS OF THE POSTPROCESSING
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ierro,j
      double precision d,dlost
      character*4 ch
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      dimension d(60)
!     integer nchars
!     parameter (nchars=160)
      character*(1601) ch1
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=60)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
      save
!-----------------------------------------------------------------------
      rewind 10
      do 10 i=1,1000
        ch=' '
        read(10,'(A1600)',end=20,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
!       write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
!       write (*,*) ':'//fields(1)//':'
!       write (*,*) ':'//fields(2)//':'
!       write (*,*) ':'//fields(3)//':'
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
        if(ierro.gt.0) then
          write(*,*) '**ERROR**'
          write(*,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',         &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
        if(i.eq.1) write(*,10000)
        if(abs(d(2)).gt.pieni) ch='LOST'
        if(d(22).ge.d(23)) then
          dlost=d(23)
        else
          dlost=d(22)
        endif
        write(*,10010) nint(dlost),d(3),d(5),d(7),d(9),d(10),d(11),     &
     &d(12),nint(d(16)),nint(d(18)),d(19),d(21),ch,d(4),d(6),d(8),      &
     &d(13),nint(d(17)),d(20),d(25),d(14),d(15)
   10 continue
   20 rewind 10
      lineno=0
      write(*,10020)
      do 30 i=1,1000
        read(10,'(A1600)',end=40,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
        if(ierro.gt.0) then
          write(*,*) '**ERROR**'
          write(*,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',         &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
! Now we are using 60 for CPU in seconds
! But note that dnms is now found in word 59.
! and we always print the maximum DMMAC as NMAC
! or zero which should really be OK I think.
! N.B. If particle is lost nms is 0, so we set mmac to zero too
      d(60)=dble(nmac)
      if (nint(d(59)).eq.0) d(60)=zero
      write(*,10030) i,nint(d(59)),nint(d(60)),                         &
     &nint(d(59))*nint(d(24))
   30 continue
   40 continue
      write(*,10040)
!-----------------------------------------------------------------------
      return
10000 format(/131('-')/t10,'SUMMARY OF THE POSTPROCESSING' //t1,125(    &
     &'-'), /t1,'|',8x,'|',11x,'|',11x,'|',12x,'|',10x,                 &
     &'|NORMALIZED| SLOPE  |',13x,'|',10x,'|',21x,'|', /t1,             &
     &'|  TURN  |   LINEAR  |   BETA-   | AMPLITUDES | MOMENTUM |',     &
     &'PHASESPACE| OF THE |  NONLINEAR  |  NEAREST |',7x,'SMEAR OF',6x, &
     &'|', /t1,                                                         &
     &'| NUMBER |   TUNES   | FUNCTIONS |            | DEVIATION|',     &
     &' DISTANCE |DISTANCE|  DETUNING   | RESONANCE|    THE EMITTANCES' &
     &,3x,'|',/t1,125('-'), /t1,                                        &
     &'|        |           |     [M]   |     [MM]   |          |',     &
     &'          |        |             |     |ORD.|',                  &
     &'    [%]  |      [%]  |'/t1,125('-'))
10010 format(t1,'|',i8,'|X ',f9.5,'|X ',f9.4,'|X ',f10.6,'|',d10.4, '|',&
     &d10.4,'|',f8.4,'|X ',d11.5,'|X ',i3,'| ',i2,' |X ', f7.3,'|X+Y ', &
     &f7.3,'|' /t1,'|  ',a4,'  |Y ',f9.5,'|Y ',f9.4,'|Y ',f10.6,'|',10x,&
     &'|',10x,'|',8x,'|+/- ',d9.3,'|Y ',i3,'|    |Y ', f7.3,'|    ',7x, &
     &'|' /t1,'|',8x,'|QS ',f8.6,'|  ',9x,'|  ',10x,'|',10x, '|',10x,'|'&
     &,8x,'|Y ',d11.5,'|  ',3x,'|    |  ', 7x,'|    ',7x,'|' /t1,'|',8x,&
     &'|  ',9x,'|  ',9x,'|  ',10x,'|',10x, '|',10x,'|',8x,'|+/- ',d9.3, &
     &'|  ',3x,'|    |  ', 7x,'|    ',7x,'|'/t1,125('-'))
10020 format(/131('-')/t10,'RANDOM SETS USED' //                        &
     &'  CASE  |  # OF RANDOM SET  |  MAX. POSSIBLE SETS   |    ',      &
     &' SEED'/65('-'))
10030 format(3x,i2,13x,i2,19x,i2,13x,i8)
10040 format(65('-')//131('-'))
      end
 
      subroutine beamint(np,track,param,sigzs,bcu,ibb,ne,ibtyp,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ibb,ibbc,ibtyp,ne,np,nsli
      double precision alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,tphi,track,star,phi2,cphi2,sphi2,tphi2
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension track(6,npart)
      !JBG increased the dimension of param to 5 to include xstr
      dimension param(nele,5),bcu(nbb,12)
      dimension star(3,mbea)
      save
!-----------------------------------------------------------------------
      phi=param(ne,1)
      nsli=param(ne,2)
      alpha=param(ne,3)
      phi2=param(ne,5)
!hr06 f=param(ne,4)/nsli
      f=param(ne,4)/dble(nsli)                                           !hr06
      sphi=sin_rn(phi)
      sphi2=sin_rn(phi2)
      cphi=cos_rn(phi)
      cphi2=cos_rn(phi2)
      tphi=tan_rn(phi)
      tphi2=tan_rn(phi2)
      salpha=sin_rn(alpha)
      calpha=cos_rn(alpha)
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boost(np,sphi,cphi,tphi,salpha,calpha,track)
      call sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
      call boosti(np,sphi,cphi,tphi,salpha,calpha,track)
      return
      end
      subroutine boost(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOST Boost Operation ********************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,np
      double precision calpha,cphi,h,h1x,h1y,h1z,hd1,salpha,sphi,tphi,  &
     &track,x1,y1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
!hr06   h=track(6,i)+one-sqrt((one+track(6,i))**2-                      &
!hr06&track(2,i)**2-track(4,i)**2)
        h=(track(6,i)+one)-sqrt(((one+track(6,i))**2-                   &!hr06
     &track(2,i)**2)-track(4,i)**2)                                      !hr06
!hr06   track(6,i)=track(6,i)-calpha*tphi*track(2,i)                    &
!hr06&-track(4,i)*salpha*tphi+h*tphi*tphi
        track(6,i)=((track(6,i)-(calpha*tphi)*track(2,i))               &!hr06
     &-(track(4,i)*salpha)*tphi)+h*tphi**2                               !hr06
!hr06   track(2,i)=(track(2,i)-tphi*h*calpha)/cphi
        track(2,i)=(track(2,i)-(tphi*h)*calpha)/cphi                     !hr06
!hr06   track(4,i)=(track(4,i)-tphi*h*salpha)/cphi
        track(4,i)=(track(4,i)-(tphi*h)*salpha)/cphi                     !hr06
!hr06   hd1=sqrt((one+track(6,i))**2-track(2,i)**2-track(4,i)**2)
        hd1=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/hd1
        h1y=track(4,i)/hd1
        h1z=one-(one+track(6,i))/hd1
!hr06   x1=calpha*tphi*track(5,i)+(one+calpha*sphi*h1x)*track(1,i)      &
!hr06&+track(3,i)*salpha*sphi*h1x
        x1=((calpha*tphi)*track(5,i)+(one+(calpha*sphi)*h1x)*track(1,i))&!hr06
     &+((track(3,i)*salpha)*sphi)*h1x                                    !hr06
!hr06   y1=salpha*tphi*track(5,i)+(one+salpha*sphi*h1y)*track(3,i)      &
!hr06&+track(1,i)*calpha*sphi*h1y
        y1=((salpha*tphi)*track(5,i)+(one+(salpha*sphi)*h1y)*track(3,i))&!hr06
     &+((track(1,i)*calpha)*sphi)*h1y                                    !hr06
!hr06   track(5,i)=track(5,i)/cphi+h1z*(sphi*calpha*track(1,i)          &
!hr06&+sphi*salpha*track(3,i))
        track(5,i)=track(5,i)/cphi+h1z*((sphi*calpha)*track(1,i)        &!hr06
     &+(sphi*salpha)*track(3,i))                                         !hr06
        track(1,i)=x1
        track(3,i)=y1
 1000 continue
      return
      end
      subroutine sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!**SBC ***Synchro-Beam for headon collision**********************
!  call BBF  (table) disabled
!****************************************************************
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,ibb,ibbc,ibbc1,ibtyp,jsli,np,nsli
      double precision bbf0,bbfx,bbfy,bbgx,bbgy,bcu,costh,costhp,cphi,  &
     &dum,f,s,sepx,sepx0,sepy,sepy0,sfac,sinth,sinthp,sp,star,sx,       &
     &sy,track,cphi2
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension track(6,npart),bcu(nbb,12)
      dimension star(3,mbea),dum(13)
      save
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
        do 1000 i=1,np
          s=(track(5,i)-star(3,jsli))*half
          !write(*,*)'JBG - cphi2',cphi2
          sp=s/cphi2
!hr06     dum(1)=bcu(ibb,1)+two*bcu(ibb,4)*sp+bcu(ibb,6)*sp*sp
          dum(1)=(bcu(ibb,1)+(two*bcu(ibb,4))*sp)+bcu(ibb,6)*sp**2       !hr06
!hr06     dum(2)=bcu(ibb,2)+two*bcu(ibb,9)*sp+bcu(ibb,10)*sp*sp
          dum(2)=(bcu(ibb,2)+(two*bcu(ibb,9))*sp)+bcu(ibb,10)*sp**2      !hr06
!hr06     dum(3)=bcu(ibb,3)+(bcu(ibb,5)+bcu(ibb,7))*sp+                 &
!hr06&bcu(ibb,8)*sp*sp
          dum(3)=(bcu(ibb,3)+(bcu(ibb,5)+bcu(ibb,7))*sp)+               &!hr06
     &bcu(ibb,8)*sp**2                                                   !hr06
          dum(4)=dum(1)-dum(2)
!hr06     dum(5)=dum(4)*dum(4)+four*dum(3)*dum(3)
          dum(5)=dum(4)**2+four*dum(3)**2                                !hr06
          if(ibbc.eq.1.and.(abs(dum(4)).gt.pieni.and.                   &
     &abs(dum(5)).gt.pieni)) then
            ibbc1=1
            dum(5)=sqrt(dum(5))
         else
            ibbc1=0
          endif
        !JBG New set of canonical set of variables at the Col point (CP)
!hr06     sepx0=track(1,i)+track(2,i)*s-star(1,jsli)
          sepx0=(track(1,i)+track(2,i)*s)-star(1,jsli)                   !hr06
!hr06     sepy0=track(3,i)+track(4,i)*s-star(2,jsli)
          sepy0=(track(3,i)+track(4,i)*s)-star(2,jsli)                   !hr06
          if(ibbc1.eq.1) then
            sfac=one
!hr06       if(dum(4).lt.zero) sfac=-one
            if(dum(4).lt.zero) sfac=-1d0*one                             !hr06
!hr06       dum(6)=sfac*dum(4)/dum(5)
            dum(6)=(sfac*dum(4))/dum(5)                                  !hr06
            dum(7)=dum(1)+dum(2)
            costh=half*(one+dum(6))
            if(abs(costh).gt.pieni) then
              costh=sqrt(costh)
            else
              costh=zero
            endif
            sinth=half*(one-dum(6))
            if(abs(sinth).gt.pieni) then
!hr06         sinth=-sfac*sqrt(sinth)
              sinth=(-1d0*sfac)*sqrt(sinth)                              !hr06
            else
              sinth=zero
            endif
!hr06       if(dum(3).lt.zero) sinth=-sinth
            if(dum(3).lt.zero) sinth=-1d0*sinth                          !hr06
            sy=sfac*dum(5)
            sx=(dum(7)+sy)*half
            sy=(dum(7)-sy)*half
            sepx=sepx0*costh+sepy0*sinth
!hr06       sepy=-sepx0*sinth+sepy0*costh
            sepy=sepy0*costh-sepx0*sinth                                 !hr06
          else
            sx=dum(1)
            sy=dum(2)
            sepx=sepx0
            sepy=sepy0
          endif
          if(sx.gt.sy) then
            call bbf(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy,ibtyp)
          else
            call bbf(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx,ibtyp)
          endif
          bbfx=f*bbfx
          bbfy=f*bbfy
          bbgx=f*bbgx
          bbgy=f*bbgy
          if(ibbc1.eq.1) then
!hr06       dum(8)=two*(bcu(ibb,4)-bcu(ibb,9)+                          &
!hr06&(bcu(ibb,6)-bcu(ibb,10))*sp)
            dum(8)=two*((bcu(ibb,4)-bcu(ibb,9))+                        &!hr06
     &(bcu(ibb,6)-bcu(ibb,10))*sp)                                       !hr06
!hr06       dum(9)=bcu(ibb,5)+bcu(ibb,7)+two*bcu(ibb,8)*sp
            dum(9)=(bcu(ibb,5)+bcu(ibb,7))+(two*bcu(ibb,8))*sp           !hr06
!hr06       dum(10)=(dum(4)*dum(8)+four*dum(3)*dum(9))/                 &
!hr06&dum(5)/dum(5)/dum(5)
            dum(10)=(((dum(4)*dum(8)+(four*dum(3))*dum(9))/             &!hr06
     &dum(5))/dum(5))/dum(5)                                             !hr06
            dum(11)=sfac*(dum(8)/dum(5)-dum(4)*dum(10))
!hr06       dum(12)=bcu(ibb,4)+bcu(ibb,9)+(bcu(ibb,6)+bcu(ibb,10))*sp
            dum(12)=(bcu(ibb,4)+bcu(ibb,9))+(bcu(ibb,6)+bcu(ibb,10))*sp  !hr06
!hr06       dum(13)=sfac*(dum(4)*dum(8)*half+two*dum(3)*dum(9))/dum(5)
      dum(13)=(sfac*((dum(4)*dum(8))*half+(two*dum(3))*dum(9)))/dum(5)   !hr06
            if(abs(costh).gt.pieni) then
!hr06         costhp=dum(11)/four/costh
              costhp=(dum(11)/four)/costh                                !hr06
            else
              costhp=zero
            endif
            if(abs(sinth).gt.pieni) then
              sinthp=((-1d0*dum(11))/four)/sinth                         !hr06
            else
              sinthp=zero
            endif
!hr06       track(6,i)=track(6,i)-                                      &
!hr06&(bbfx*(costhp*sepx0+sinthp*sepy0)+                                &
!hr06&bbfy*(-sinthp*sepx0+costhp*sepy0)+                                &
!hr06&bbgx*(dum(12)+dum(13))+bbgy*(dum(12)-dum(13)))/                   &
!hr06&cphi*half
            track(6,i)=track(6,i)-                                      &!hr06
     &((((bbfx*(costhp*sepx0+sinthp*sepy0)+                             &!hr06
     &bbfy*(costhp*sepy0-sinthp*sepx0))+                                &!hr06
     &bbgx*(dum(12)+dum(13)))+bbgy*(dum(12)-dum(13)))/                  &!hr06
     &cphi)*half                                                         !hr06
            bbf0=bbfx
            bbfx=bbf0*costh-bbfy*sinth
            bbfy=bbf0*sinth+bbfy*costh
          else
            track(6,i)=track(6,i)-                                      &
     &(bbgx*(bcu(ibb,4)+bcu(ibb,6)*sp)+                                 &
     &bbgy*(bcu(ibb,9)+bcu(ibb,10)*sp))/cphi
          endif
          track(6,i)=track(6,i)-(bbfx*(track(2,i)-bbfx*half)+           &
     &bbfy*(track(4,i)-bbfy*half))*half
          track(1,i)=track(1,i)+s*bbfx
          track(2,i)=track(2,i)-bbfx
          track(3,i)=track(3,i)+s*bbfy
          track(4,i)=track(4,i)-bbfy
 1000   continue
 2000 continue
      return
      end
      subroutine boosti(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOSTI **************inverse boost *****************
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,np
      double precision calpha,cphi,det,h1,h1d,h1x,h1y,h1z,salpha,sphi,  &
     &tphi,track,x1,y1,z1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
!hr06   h1d=sqrt((one+track(6,i))**2-track(2,i)**2-track(4,i)**2)
        h1d=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/h1d
        h1y=track(4,i)/h1d
        h1z=one-(one+track(6,i))/h1d
!hr06   h1=(track(6,i)+one-sqrt((one+track(6,i))**2-                    &
!hr06&track(2,i)**2-track(4,i)**2))*cphi*cphi
        h1=((track(6,i)+one)-sqrt(((one+track(6,i))**2-                 &!hr06
     &track(2,i)**2)-track(4,i)**2))*cphi**2                             !hr06
!hr06   det=one/cphi+tphi*(h1x*calpha+h1y*salpha-h1z*sphi)
        det=one/cphi+tphi*((h1x*calpha+h1y*salpha)-h1z*sphi)             !hr06
!hr06   x1= track(1,i)*(one/cphi+salpha*(h1y-h1z*salpha*sphi)*tphi)     &
!hr06&+track(3,i)*salpha*tphi*(-h1x+h1z*calpha*sphi)                    &
!hr06&-track(5,i)*(calpha+h1y*calpha*salpha*sphi                        &
!hr06&-h1x*salpha*salpha*sphi)*tphi
        x1= (track(1,i)*(one/cphi+(salpha*(h1y-(h1z*salpha)*sphi))*tphi)&!hr06
     &+((track(3,i)*salpha)*tphi)*((h1z*calpha)*sphi-h1x))              &!hr06
     &-(track(5,i)*((calpha+((h1y*calpha)*salpha)*sphi)                 &!hr06
     &-(h1x*salpha**2)*sphi))*tphi                                       !hr06
!hr06   y1= track(1,i)*calpha*tphi*(-h1y+h1z*salpha*sphi)               &
!hr06&+track(3,i)*(one/cphi+calpha*(h1x-h1z*calpha*sphi)*tphi)          &
!hr06&-track(5,i)*(salpha-h1y*calpha*calpha*sphi                        &
!hr06&+h1x*calpha*salpha*sphi)*tphi
        y1= (((track(1,i)*calpha)*tphi)*((h1z*salpha)*sphi-h1y)         &!hr06
     &+track(3,i)*(one/cphi+(calpha*(h1x-(h1z*calpha)*sphi))*tphi))     &!hr06
     &-(track(5,i)*(salpha-(h1y*calpha**2)*sphi                         &!hr06
     &+((h1x*calpha)*salpha)*sphi))*tphi                                 !hr06
!hr06   z1=-track(1,i)*h1z*calpha*sphi-track(3,i)*h1z*salpha*sphi       &
!hr06&+track(5,i)*(one+h1x*calpha*sphi+h1y*salpha*sphi)
        z1= (track(5,i)*((one+(h1x*calpha)*sphi)+(h1y*salpha)*sphi)     &!hr06
     &-((track(1,i)*h1z)*calpha)*sphi)-((track(3,i)*h1z)*salpha)*sphi    !hr06
        track(1,i)=x1/det
        track(3,i)=y1/det
        track(5,i)=z1/det
!hr06   track(6,i)=track(6,i)+calpha*sphi*track(2,i)                    &
!hr06&+salpha*sphi*track(4,i)
        track(6,i)=(track(6,i)+(calpha*sphi)*track(2,i))                &!hr06
     &+(salpha*sphi)*track(4,i)                                          !hr06
!hr06   track(2,i)=(track(2,i)+calpha*sphi*h1)*cphi
        track(2,i)=(track(2,i)+(calpha*sphi)*h1)*cphi                    !hr06
!hr06   track(4,i)=(track(4,i)+salpha*sphi*h1)*cphi
        track(4,i)=(track(4,i)+(salpha*sphi)*h1)*cphi                    !hr06
 1000 continue
      return
      end
      subroutine bbf(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy,ibtyp)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**BBF   without using table ******************************************
! gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer ibtyp
      double precision arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,     &
     &comfac,comfac2,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,sigyy, &
     &sqrpi2,wx1,wx2,wy1,wy2,x,xxyy
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      data sqrpi2/3.544907701811032d0/
      save
!-----------------------------------------------------------------------
      if(sigxx.eq.sigyy) then
        x=sepx**2+sepy**2
        xxyy=sigxx+sigyy
        const=0.0d0
        if(abs(xxyy).gt.pieni) const=x/xxyy
!hr06   expfac=exp_rn(-const)
        expfac=exp_rn(-1d0*const)                                        !hr06
        bbfx=0.0d0
        bbfy=0.0d0
        bbgx=0.0d0
        bbgy=0.0d0
        if(abs(x).gt.pieni) then
!hr06     bbfx=2.0d0*sepx*(1d0-expfac)/x
          bbfx=((2.0d0*sepx)*(1d0-expfac))/x                             !hr06
!hr06     bbfy=2.0d0*sepy*(1d0-expfac)/x
          bbfy=((2.0d0*sepy)*(1d0-expfac))/x                             !hr06
!hr06     comfac=-sepx*bbfx+sepy*bbfy
          comfac=sepy*bbfy-sepx*bbfx                                     !hr06
          comfac2=(abs(sigxx)+abs(sigyy))**2
!hr06     bbgx=(comfac+4d0*sepx**2*const/x*expfac)/(2d0*x)
          bbgx=(comfac+(((4d0*sepx**2)*const)/x)*expfac)/(2d0*x)         !hr06
!hr06     bbgy=(-comfac+4d0*sepy**2*const/x*expfac)/(2d0*x)
          bbgy=((((4d0*sepy**2)*const)/x)*expfac-comfac)/(2d0*x)         !hr06
        endif
      else
        x=sepx**2/sigxx+sepy**2/sigyy
        fac2=2.d0*abs(sigxx-sigyy)
        fac=sqrt(fac2)
        const=sqrpi2/fac
        sigxy=sqrt(sigxx/sigyy)
        arg1x=abs(sepx/fac)
        arg1y=abs(sepy/fac)
        if(ibtyp.eq.0) call errf(arg1x,arg1y,wy1,wx1)
        if(ibtyp.eq.1) call wzsub(arg1x,arg1y,wy1,wx1)
        if(x.lt.100.d0) then
!hr06     expfac=exp_rn(-x*0.5d0)
          expfac=exp_rn(-0.5d0*x)                                        !hr06
          arg2x=arg1x/sigxy
          arg2y=arg1y*sigxy
          if(ibtyp.eq.0) call errf(arg2x,arg2y,wy2,wx2)
          if(ibtyp.eq.1) call wzsub(arg2x,arg2y,wy2,wx2)
          bbfx=const*(wx1-expfac*wx2)
          bbfy=const*(wy1-expfac*wy2)
!hr06     if(sepx.lt.0) bbfx=-bbfx
          if(sepx.lt.0) bbfx=-1d0*bbfx                                   !hr06
!hr06     if(sepy.lt.0) bbfy=-bbfy
          if(sepy.lt.0) bbfy=-1d0*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
!hr06     bbgx=-(comfac+2d0*(expfac/sigxy -1))/fac2
          bbgx=(-1d0*(comfac+2d0*(expfac/sigxy -1d0)))/fac2              !hr06
!hr06     bbgy= (comfac+2d0*(expfac*sigxy -1))/fac2
          bbgy= (comfac+2d0*(expfac*sigxy -1d0))/fac2                    !hr06
        else
          bbfx=const*wx1
          bbfy=const*wy1
!hr06     if(sepx.lt.0) bbfx=-bbfx
          if(sepx.lt.0) bbfx=-1d0*bbfx                                   !hr06
!hr06     if(sepy.lt.0) bbfy=-bbfy
          if(sepy.lt.0) bbfy=-1d0*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
!hr06     bbgx=-(comfac-2d0)/fac2
          bbgx=(-1d0*(comfac-2d0))/fac2                                  !hr06
!hr06     bbgy= -bbgx
          bbgy= -1d0*bbgx                                                !hr06
        endif
      endif
      return
      end
      subroutine stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!*******STSLD*********************************************************
!   makes longitudinal position of the strong slice for all slices
!*********************************************************************
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,nsli
      double precision bord,bord1,border,calpha,cphi,cphi2,gauinv,pi,   &
     &salpha,sigz,sigzs,sphi,sphi2,star,yy
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      dimension star(3,mbea)
!-----------------------------------------------------------------------
      data border /8d0/
      save
!-----------------------------------------------------------------------
      pi=4d0*atan_rn(1d0)
      sigz=sigzs/cphi2
! DEFINE `STARRED' COORDINATES
!  BORD is longitudinal border star(3,mbea) is the barycenter of region
!  divided two borders.
      bord=+border
      do 101 i=nsli,1,-1
!hr06   yy=1d0/dble(nsli)*(i-1)
        yy=(1d0/dble(nsli))*dble(i-1)                                    !hr06
!hr06   if(i.ne.1) bord1=dble(gauinv(yy))
        if(i.ne.1) bord1=gauinv(yy)                                      !hr06
!hr06   if(i.eq.1) bord1=-border
        if(i.eq.1) bord1=-1d0*border                                     !hr06
!hr06   star(3,i)=(exp_rn(-bord**2*half)-exp_rn(-bord1**2*half))/
!hr06&sqrt(2d0*pi)*dble(nsli)*sigz
        star(3,i)=(((exp_rn((-1d0*bord**2)*half)-                       &!hr06
     &exp_rn((-1d0*bord1**2)*half))/sqrt(2d0*pi))*dble(nsli))*sigz       !hr06
!hr06&sqrt(2d0*pi)*dble(nsli)*sigz
        bord=bord1
        !JBG When doing slicing phi=0 for crab crossing
        ! star(1,i)=0.
        ! star(2,i)=0.
        !JBG When doing slicing phi2 different tiltings of the strong beam
        star(1,i)=(star(3,i)*sphi2)*calpha
        star(2,i)=(star(3,i)*sphi2)*salpha
!hr06   star(1,i)=star(3,i)*sphi*calpha
        !star(1,i)=(star(3,i)*sphi)*calpha                                !hr06
!hr06   star(2,i)=star(3,i)*sphi*salpha
        !star(2,i)=(star(3,i)*sphi)*salpha                                !hr06
 101  continue
      return
      end
      function gauinv(p0)
!GAUINV***********************************************
!  INVERSE OF (INTEGRATED) NORMAL DISTRIBUTION FUNCTION
!              1         X= Y
!     P(Y)=-----------* INTEGRAL EXP(-X**2/2) DX
!          SQRT(2*PI)    X= -INF
!     IF P(Y)=P0, THEN GAUINV(P0)=Y.
!        0 < P0 < 1 ,   -INF < Y < +INF
!  IF THIS ROUTINE IS USED TO CONVERT UNIFORM RANDOM NUMBERS TO
!  GAUSSIAN, MAXIMUM RELATIVE ERROR IN THE DISTRIBUTION FUNCTION
!  DP/DX=EXP(-X**2/2)/SQRT(2*PI) IS LESS THAN 0.640E-3 EVERYWHERE
!  IN THE RANGE  2**(-31) < P0 < 1-2**31.  (MINIMAX APPROXIMATION)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      double precision a0,a1,a2,a3,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d0,d1, &
     &d2,d3,d4,e0,e1,e2,e3,e4,f0,f1,f2,gauinv,p,p0,p1,p2,pp1,q,qq2,qq3, &
     &qq4,qq5,t
!-----------------------------------------------------------------------
      data pp1/0.334624883253d0/, qq2/0.090230446775d0/,                &
     &qq3/0.049905685242d0/, qq4/0.027852994157d0/,                     &
     &qq5/0.015645650215d0/
      data a3/ 4.5585614d+01/, a2/ 2.1635544d+00/, a1/ 2.7724523d+00/,  &
     &a0/ 2.5050240d+00/,                                               &
     &b4/ 4.0314354d+02/, b3/-2.7713713d+02/, b2/ 7.9731883d+01/,       &
     &b1/-1.4946512d+01/, b0/ 2.2157257d+00/,                           &
     &c4/ 4.1394487d+03/, c3/-1.5585873d+03/, c2/ 2.4648581d+02/,       &
     &c1/-2.4719139d+01/, c0/ 2.4335936d+00/,                           &
     &d4/ 4.0895693d+04/, d3/-8.5400893d+03/, d2/ 7.4942805d+02/,       &
     &d1/-4.1028898d+01/, d0/ 2.6346872d+00/,                           &
     &e4/ 3.9399134d+05/, e3/-4.6004775d+04/, e2/ 2.2566998d+03/,       &
     &e1/-6.8317697d+01/, e0/ 2.8224654d+00/
      data f0/-8.1807613d-02/, f1/-2.8358733d+00/, f2/ 1.4902469d+00/
      save
!-----------------------------------------------------------------------
      p=p0-0.5d0
      p1=abs(p)
      if(p1.ge.pp1) goto 120
      p2=p**2
      gauinv=(((a3*p2+a2)*p2+a1)*p2+a0)*p
      return
 120  q=0.5d0-p1
      if(q.le.qq2) goto 140
      gauinv=(((b4*q+b3)*q+b2)*q+b1)*q+b0
      goto 200
 140  if(q.le.qq3) goto 150
      gauinv=(((c4*q+c3)*q+c2)*q+c1)*q+c0
      goto 200
 150  if(q.le.qq4) goto 160
      gauinv=(((d4*q+d3)*q+d2)*q+d1)*q+d0
      goto 200
 160  if(q.le.qq5) goto 170
      gauinv=(((e4*q+e3)*q+e2)*q+e1)*q+e0
      goto 200
 170  if(q.le.0d0) goto 900
      t=sqrt(-2d0*log_rn(q))
!hr06 gauinv=t+f0+f1/(f2+t)
      gauinv=(t+f0)+f1/(f2+t)                                            !hr06
!hr06 200  if(p.lt.0d0) gauinv=-gauinv
 200  if(p.lt.0d0) gauinv=-1d0*gauinv                                    !hr06
      return
 900  write(*,910) p0
 910  format(' (FUNC.GAUINV) INVALID INPUT ARGUMENT ',1pd20.13)
      call closeUnits
      stop
      end
      subroutine kerset(ercode,lgfile,limitm,limitr)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,kounte,l,lgfile,limitm,limitr,log,logf
      parameter(kounte = 27)
      character*6         ercode,   code(kounte)
      logical             mflag,    rflag
      integer             kntm(kounte),       kntr(kounte)
!-----------------------------------------------------------------------
      data      logf      /  0  /
      data      code(1), kntm(1), kntr(1)  / 'C204.1', 255, 255 /
      data      code(2), kntm(2), kntr(2)  / 'C204.2', 255, 255 /
      data      code(3), kntm(3), kntr(3)  / 'C204.3', 255, 255 /
      data      code(4), kntm(4), kntr(4)  / 'C205.1', 255, 255 /
      data      code(5), kntm(5), kntr(5)  / 'C205.2', 255, 255 /
      data      code(6), kntm(6), kntr(6)  / 'C305.1', 255, 255 /
      data      code(7), kntm(7), kntr(7)  / 'C308.1', 255, 255 /
      data      code(8), kntm(8), kntr(8)  / 'C312.1', 255, 255 /
      data      code(9), kntm(9), kntr(9)  / 'C313.1', 255, 255 /
      data      code(10),kntm(10),kntr(10) / 'C336.1', 255, 255 /
      data      code(11),kntm(11),kntr(11) / 'C337.1', 255, 255 /
      data      code(12),kntm(12),kntr(12) / 'C341.1', 255, 255 /
      data      code(13),kntm(13),kntr(13) / 'D103.1', 255, 255 /
      data      code(14),kntm(14),kntr(14) / 'D106.1', 255, 255 /
      data      code(15),kntm(15),kntr(15) / 'D209.1', 255, 255 /
      data      code(16),kntm(16),kntr(16) / 'D509.1', 255, 255 /
      data      code(17),kntm(17),kntr(17) / 'E100.1', 255, 255 /
      data      code(18),kntm(18),kntr(18) / 'E104.1', 255, 255 /
      data      code(19),kntm(19),kntr(19) / 'E105.1', 255, 255 /
      data      code(20),kntm(20),kntr(20) / 'E208.1', 255, 255 /
      data      code(21),kntm(21),kntr(21) / 'E208.2', 255, 255 /
      data      code(22),kntm(22),kntr(22) / 'F010.1', 255,   0 /
      data      code(23),kntm(23),kntr(23) / 'F011.1', 255,   0 /
      data      code(24),kntm(24),kntr(24) / 'F012.1', 255,   0 /
      data      code(25),kntm(25),kntr(25) / 'F406.1', 255,   0 /
      data      code(26),kntm(26),kntr(26) / 'G100.1', 255, 255 /
      data      code(27),kntm(27),kntr(27) / 'G100.2', 255, 255 /
      save
!-----------------------------------------------------------------------
      logf  =  lgfile
         l  =  0
      if(ercode .ne. ' ')  then
         do 10  l = 1, 6
            if(ercode(1:l) .eq. ercode)  goto 12
  10        continue
  12     continue
      endif
      do 14     i  =  1, kounte
         if(l .eq. 0)  goto 13
         if(code(i)(1:l) .ne. ercode(1:l))  goto 14
  13     if(limitm.ge.0) kntm(i)  =  limitm
         if(limitr.ge.0) kntr(i)  =  limitr
  14     continue
      return
      entry kermtr(ercode,log,mflag,rflag)
      log  =  logf
      do 20     i  =  1, kounte
         if(ercode .eq. code(i))  goto 21
  20     continue
      write(*,1000)  ercode
      call abend('KERNLIB Library Error                             ')
      return
  21  rflag  =  kntr(i) .ge. 1
      if(rflag  .and.  (kntr(i) .lt. 255))  kntr(i)  =  kntr(i) - 1
      mflag  =  kntm(i) .ge. 1
      if(mflag  .and.  (kntm(i) .lt. 255))  kntm(i)  =  kntm(i) - 1
      if(.not. rflag)  then
         if(logf .lt. 1)  then
            write(*,1001)  code(i)
         else
            write(logf,1001)  code(i)
         endif
      endif
      if(mflag .and. rflag)  then
         if(logf .lt. 1)  then
            write(*,1002)  code(i)
         else
            write(logf,1002)  code(i)
         endif
      endif
      return
1000  format(' KERNLIB LIBRARY ERROR. ' /                               &
     &' ERROR CODE ',a6,' NOT RECOGNIZED BY KERMTR',                    &
     &' ERROR MONITOR. RUN ABORTED.')
1001  format(/' ***** RUN TERMINATED BY CERN LIBRARY ERROR ',           &
     &'CONDITION ',a6)
1002  format(/' ***** CERN LIBRARY ERROR CONDITION ',a6)
      end
      subroutine rinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR REQINV.)
!
!     CALLS ... RFACT, RFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer idim,ifail,ir,jfail,k,kprnt,n
      real t1,t2,t3,a,det,temp,s,c11,c12,c13,c21,c22,c23,c31,c32,c33
      character*6 name
      dimension ir(n),a(idim,n)
      data name/'RINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      t1=abs(a(1,1))
      t2=abs(a(2,1))
      t3=abs(a(3,1))
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.0.) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.0.) goto 8
!hr07 s=1d0/det
      s=1e0/det                                                          !hr07
      c11   =s*a(2,2)
!hr07 a(1,2)=-s*a(1,2)
      a(1,2)=(-1e0*s)*a(1,2)                                             !hr07
!hr07 a(2,1)=-s*a(2,1)
      a(2,1)=(-1e0*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.0.) goto 8
!hr07 a(1,1)=1d0/a(1,1)
      a(1,1)=1e0/a(1,1)                                                  !hr07
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call rfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call rfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end
      subroutine dinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR DEQINV.)
!
!     CALLS ... DFACT, DFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer idim,ifail,jfail,k,kprnt,n
      integer ir
      real t1,t2,t3
      double precision a,det,temp,s,c11,c12,c13,c21,c22,c23,c31,c32,c33
      character*6 name
      dimension ir(n),a(idim,n)
      data name/'DINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
!hr07 t1=abs(sngl(a(1,1)))
      t1=abs(real(a(1,1)))                                               !hr07
!hr07 t2=abs(sngl(a(2,1)))
      t2=abs(real(a(2,1)))                                               !hr07
!hr07 t3=abs(sngl(a(3,1)))
      t3=abs(real(a(3,1)))                                               !hr07
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.0d0) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.0d0) goto 8
      s=1d0/det
      c11   =s*a(2,2)
!hr07 a(1,2)=-s*a(1,2)
      a(1,2)=(-1d0*s)*a(1,2)                                             !hr07
!hr07 a(2,1)=-s*a(2,1)
      a(2,1)=(-1d0*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.0d0) goto 8
      a(1,1)=1d0/a(1,1)
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call dfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call dfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end
      subroutine f010pr(name,n,idim,k,kprnt)
!     ******************************************************************
!
!     PRINT ROUTINE FOR PARAMETER ERRORS IN MATRIX SUBROUTINES $EQINV,
!     $EQN, $INV (WHERE $ IS A LETTER SPECIFYING THE ARITHMETIC TYPE).
!
!     NAME         (CHARACTER*6) NAME OF THE CALLING ROUTINE.
!
!     N,IDIM,K     PARAMETERS OF THE CALLING ROUTINE (WITH K=0 IF K IS
!                  NOT TO BE PRINTED).
!
!     KPRNT        PRINT FLAG FOR K (K IS NOT PRINTED IF KPRNT=0).
!
!     ******************************************************************
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer idim,k,kprnt,lgfile,n
      character*6 name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      call kermtr('F010.1',lgfile,mflag,rflag)
      if(mflag) then
         if(lgfile.eq.0)  then
            if(kprnt.eq.0) write(*,2000) name,n,idim
            if(kprnt.ne.0) write(*,2001) name,n,idim,k
         else
            if(kprnt.eq.0) write(lgfile,2000) name,n,idim
            if(kprnt.ne.0) write(lgfile,2001) name,n,idim,k
         endif
      endif
      if(.not. rflag)                                                   &
     &call abend('KERNLIB F010PR: '//name//                             &
     &'                            ')
      return
!
 2000 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim).',                                  &
     &6x,'n =', i4, 6x,'idim =', i4,'.')
 2001 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim or k.lt.1).',                        &
     &6x,'n =', i4, 6x,'idim =', i4, 6x,'k =', i4,'.')
      end
      subroutine rfact(n,a,idim,ir,ifail,det,jfail)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ifail,imposs,ipairf,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch
      real a,det,g1,g2,one,p,pivotf,q,sizef,t,tf,x,y,zero
      double precision s11,s12,dotf
      character*6 hname
      dimension ir(*),a(idim,*)
!      data      g1, g2              /  1.e-37,  1.e37  /
!hr07 data      g1, g2              /  1.0d-37,  1.0d37  /
      data      g1, g2              /  1.0e-37,  1.0e37  /               !hr07
      data      hname               /  ' RFACT'  /
      data      zero, one           /  0., 1.  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s11)  =  dble(x)*dble(y) + s11
      ipairf(j,k)  =  j*2**12 + k
      pivotf(x)    =  abs(x)
      sizef(x)     =  abs(x)
      if(idim .ge. n  .and.  n .gt. 0)  goto 110
         call tmprnt(hname,n,idim,0)
         return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q  =  pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. 0.)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
!hr07       s11  =  -a(j,k)
            s11  =  -1d0*dble(a(j,k))                                    !hr07
!hr07       s12  =  -a(k,j+1)
            s12  =  -1d0*dble(a(k,j+1))                                  !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
!hr07 142        a(j,k)    =  -s11 * a(j,j)
 142        a(j,k)    =  real((-1d0*s11) * dble(a(j,j)))                 !hr07
!hr07       a(k,j+1)  =  -dotf(a(j,j+1),a(k,j),s12)
            a(k,j+1)  =  real(-1d0*dotf(a(j,j+1),a(k,j),s12))            !hr07
 143        continue
 144     continue
!hr07 if(mod(nxch,2) .ne. 0)  det  =  -det
 150  if(mod(nxch,2) .ne. 0)  det  =  -1e0*det
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return
      end
      subroutine dfact(n,a,idim,ir,ifail,det,jfail)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ifail,imposs,ipairf,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch
      real g1,g2,p,pivotf,q,sizef,t
      double precision a,det,dotf,zero,one,s11,s12,x,y,tf
      character*6         hname
      dimension ir(*),a(idim,*)
!      data      g1, g2              /  1.e-37,  1.e37  /
!hr07 data      g1, g2              /  1.0d-37,  1.0d37  /
      data      g1, g2              /  1.0e-37,  1.0e37  /               !hr07
      data      hname               /  ' DFACT'  /
      data      zero, one           /  0.d0, 1.d0  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------
      ipairf(j,k)  =  j*2**12 + k
!hr07 pivotf(x)    =  abs(sngl(x))
      pivotf(x)    =  abs(real(x))                                       !hr07
!hr07 sizef(x)     =  abs(sngl(x))
      sizef(x)     =  abs(real(x))                                       !hr07
      dotf(x,y,s11)  =  x * y + s11
      if(idim .ge. n  .and.  n .gt. 0)  goto 110
      call tmprnt(hname,n,idim,0)
      return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q  =  pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. 0.)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
!hr07       s11  =  -a(j,k)
            s11  =  -1d0*a(j,k)                                          !hr07
!hr07       s12  =  -a(k,j+1)
            s12  =  -1d0*a(k,j+1)                                        !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
!hr07 142        a(j,k)    =  -s11 * a(j,j)
 142        a(j,k)    =  (-1d0*s11) * a(j,j)                             !hr07
!hr07       a(k,j+1)  =  -dotf(a(j,j+1),a(k,j),s12)
            a(k,j+1)  =  -1d0*dotf(a(j,j+1),a(k,j),s12)                  !hr07
 143        continue
 144     continue
!hr07 150 if(mod(nxch,2) .ne. 0)  det  =  -det
 150  if(mod(nxch,2) .ne. 0)  det  =  -1d0*det                           !hr07
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return
      end
      subroutine rfeqn(n,a,idim,ir,k,b)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      real a,b,te,x,y
      double precision dotf,s21,s22
      character*6 hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' RFEQN'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s21)  =  dble(x)*dble(y) + s21
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
!hr07       s21  =  - b(i,l)
            s21  =  -1d0* dble(b(i,l))                                   !hr07
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
!hr07       b(i,l)  =  - a(i,i)*s21
            b(i,l)  =  real((-1d0*dble(a(i,i)))*s21)                     !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
!hr07       s22  =  - b(nmi,l)
            s22  =  -1d0*dble(b(nmi,l))                                  !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
            b(nmi,l)  =  real(-1d0*s22)
 242        continue
 243     continue
 299  continue
      return
      end
      subroutine dfeqn(n,a,idim,ir,k,b)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      double precision a,b,x,y,te
      double precision dotf,s21,s22
      character*6 hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' DFEQN'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s21)  =  x*y + s21
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
            s21  =  - b(i,l)
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
!hr07       b(i,l)  =  - a(i,i)*s21
            b(i,l)  =  (-1d0*a(i,i))*s21                                 !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
!hr07       s22  =  - b(nmi,l)
            s22  =  -1d0*b(nmi,l)                                        !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
!hr07       b(nmi,l)  =  - s22
            b(nmi,l)  =  -1d0*s22                                        !hr07
 242        continue
 243     continue
 299  continue
      return
      end
      subroutine rfinv(n,a,idim,ir)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      real a,ti,x,y
      double precision dotf,s31,s32,s33,s34,zero
      character*6 hname
      dimension ir(*),a(idim,*)
      data      zero      /  0.d0  /
      data      hname               /  ' RFINV'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s31)  =  dble(x)*dble(y) + s31
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
!hr07 a(2,1)  =  -a(2,2) * dotf(a(1,1),a(2,1),zero)
      a(2,1)  =  real((-1d0*dble(a(2,2))) * dotf(a(1,1),a(2,1),zero))     !hr07
!hr07 a(1,2)  =  -a(1,2)
      a(1,2)  =  -1e0*a(1,2)                                             !hr07
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
!hr07       s32  =  a(j,i)
            s32  =  dble(a(j,i))                                         !hr07
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
!hr07       a(i,j)  =  -a(i,i) * dotf(a(i-1,j),a(i,i-1),s31)
      a(i,j)  =  real((-1d0*dble(a(i,i))) * dotf(a(i-1,j),a(i,i-1),s31)) !hr07
!hr07       a(j,i)  =  -s32
            a(j,i)  =  real(-1d0*s32)                                    !hr07
 312        continue
!hr07    a(i,i-1)  =  -a(i,i) * dotf(a(i-1,i-1),a(i,i-1),zero)
      a(i,i-1)=real((-1d0*dble(a(i,i)))*dotf(a(i-1,i-1),a(i,i-1),zero))  !hr07
!hr07    a(i-1,i)  =  -a(i-1,i)
         a(i-1,i)  =  -1e0*a(i-1,i)                                      !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
!hr07       s33  =  a(i,j)
            s33  =  dble(a(i,j))                                         !hr07
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
!hr07       a(i,i+j)  =  s34
            a(i,i+j)  =  real(s34)                                       !hr07
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341  k  =  1, n
            ti      =  a(k,i)
            a(k,i)  =  a(k,j)
            a(k,j)  =  ti
 341        continue
 342     continue
      return
      end
      subroutine dfinv(n,a,idim,ir)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      double precision a,dotf,s31,s32,s33,s34,ti,x,y,zero
      character*6 hname
      dimension ir(*),a(idim,*)
      data      hname               /  ' DFINV'  /
      data      zero      /  0.d0  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s31)  =  x*y + s31
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
!hr07 a(2,1)  =  -a(2,2) * dotf(a(1,1),a(2,1),zero)
      a(2,1)  =  (-1d0*a(2,2)) * dotf(a(1,1),a(2,1),zero)                !hr07
!hr07 a(1,2)  =  -a(1,2)
      a(1,2)  =  -1d0*a(1,2)
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
            s32  =  a(j,i)
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
!hr07       a(i,j)  =  -a(i,i) * dotf(a(i-1,j),a(i,i-1),s31)
            a(i,j)  =  (-1d0*a(i,i)) * dotf(a(i-1,j),a(i,i-1),s31)       !hr07
!hr07       a(j,i)  =  -s32
            a(j,i)  =  -1d0*s32                                          !hr07
 312        continue
!hr07    a(i,i-1)  =  -a(i,i) * dotf(a(i-1,i-1),a(i,i-1),zero)
         a(i,i-1)  =  (-1d0*a(i,i)) * dotf(a(i-1,i-1),a(i,i-1),zero)     !hr07
!hr07    a(i-1,i)  =  -a(i-1,i)
         a(i-1,i)  =  -1d0*a(i-1,i)                                      !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
            s33  =  a(i,j)
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
            a(i,i+j)  =  s34
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341  k  =  1, n
            ti      =  a(k,i)
            a(k,i)  =  a(k,j)
            a(k,j)  =  ti
 341        continue
 342     continue
      return
      end
      subroutine tmprnt(name,n,idim,k)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer idim,k,lgfile,n
      character*6 name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      if(name(2:2) .eq. 'S') then
         call kermtr('F012.1',lgfile,mflag,rflag)
      else
         call kermtr('F011.1',lgfile,mflag,rflag)
      endif
      if(mflag) then
         if(lgfile .eq. 0) then
            if(name(3:6) .eq. 'FEQN') then
               write(*,1002) name, n, idim, k
            else
               write(*,1001) name, n, idim
            endif
         else
            if(name(3:6) .eq. 'FEQN') then
               write(lgfile,1002) name, n, idim, k
            else
               write(lgfile,1001) name, n, idim
            endif
         endif
      endif
      if(.not. rflag)                                                   &
     &call abend('KERNLIB TMPRNT: '//name//                             &
     &'                            ')
!hr09 return
      return
1001  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n).',                                    &
     &5x,'n =', i4, 5x,'idim =', i4,'.')
1002  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n or k.lt.1).',                          &
     &5x,'n =', i4, 5x,'idim =', i4, 5x,'k =', i4,'.')
      end
      subroutine lfitd(x,y,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO FIT A STRAIGHT LINE    Y=A*X+B    TO L POINTS WITH ERROR E
!     SEE MENZEL , FORMULAS OF PHYSICS P.116
!     POINTS WITH Y=0 ARE IGNOERD IF KEY=0
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer j,key,l
      double precision a,b,count,e,scartx,scarty
      double precision sumx,sumxx,sumxy,sumy,sumyy,x,xmed,y,ymed
!hr07 dimension x(*),y(*)
      dimension x(l),y(l)                                                !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l-2.lt.0) goto 25
      if(l-2.ge.0) goto 1
    1 count=0.0
      sumx=0.0
      sumy=0.0
      sumxy=0.0
      sumxx=0.0
      sumyy=0.0
      do 10 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 10
      sumx=sumx+x(j)
      sumy=sumy+y(j)
      count=count+1.0
   10 continue
      if(count.le.1.) goto 25
      ymed=sumy/count
      xmed=sumx/count
      do 20 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 20
      scartx=x(j)-xmed
      scarty=y(j)-ymed
      sumxy=sumxy+scartx   *scarty
      sumxx=sumxx+scartx   *scartx
      sumyy=sumyy+scarty   *scarty
   20 continue
!
!     FIT PARAMETERS
      if(sumxx.eq.0.) goto 25
      a=sumxy/sumxx
      b=ymed-a*xmed
      if(count.lt.3.) goto 101
      e=(sumyy-sumxy*a          )/(count-2.0)
      goto 100
!
!     ISUFFICIENT POINTS
   25 a=0.0
      b=0.0
  101 e=0.0
  100 return
      end
      subroutine lfitwd(x,y,w,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO PERFORM A WEIGHTED STRAIGHT LINE FIT
!
!     FOR FORMULAE USED SEE MENZEL, FORMULAS OF PHYSICS P.116
!
!     FIT IS OF Y=AX+B , WITH S**2 ESTIMATOR E. WEIGHTS ARE IN W.
!     IF KEY=0, POINTS WITH Y=0 ARE IGNORED
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      integer icnt,j,key,l
      double precision a,b,e,x,y,w
      double precision w2,w2x,w2x2,w2xy,w2y,w2y2,ww,wwf,wwfi
!hr07 dimension x(*),y(*),w(*)
      dimension x(l),y(l),w(l)                                           !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l.le.1) goto 1
      w2=0.
      w2x=0.
      w2y=0.
      w2xy=0.
      w2x2=0.
      w2y2=0.
      icnt=0
      do 2 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 2
!hr07 ww=w(j)*w(j)
      ww=w(j)**2                                                         !hr07
      w2=ww+w2
      wwf=ww*x(j)
      w2x=wwf+w2x
      w2x2=wwf*x(j)+w2x2
      w2xy=wwf*y(j)+w2xy
      wwfi=ww*y(j)
      w2y=wwfi+w2y
      w2y2=wwfi*y(j)+w2y2
      icnt=icnt+1
    2 continue
!
!     FIT PARAMETERS
!hr07 a=(w2xy-w2x*w2y/w2)/(w2x2-w2x**2/w2)
      a=(w2xy-(w2x*w2y)/w2)/(w2x2-w2x**2/w2)
      b=(w2y-a*w2x)/w2
      if(icnt.le.2) goto 3
!Eric
      e=((w2y2-w2y**2/w2)-(w2xy-(w2x*w2y)/w2)**2/(w2x2-w2x**2/w2))/     &!hr07
     &dble(icnt-2)
      goto 4
!
!     ISUFFICIENT POINTS
    1 a=0.
      b=0.
    3 e=0.
    4 return
      end
!      logical function isnan(arg1,arg2)
      logical function myisnan(arg1,arg2)
      implicit none
      double precision sin_rn,cos_rn,tan_rn,sinh_rn,cosh_rn,asin_rn,    &
     &acos_rn,atan_rn,atan2_rn,exp_rn,log_rn,log10_rn
      double precision arg1,arg2
!      isnan=.false.
!      if(arg1.ne.arg2) isnan=.true.
      myisnan=.false.
      if(arg1.ne.arg2) myisnan=.true.
      end
      subroutine datime(nd,nt)
      implicit none
! Fill common slate for usage by hmachi call as per z007 writeup.        !hr08
      common /slate/ isl(40)                                             !hr08
 
      integer isl                                                        !hr08
!
!-    call datime (nd,nt)   returns integer date   nd = yymmdd
!-                                  integer time   nt =   hhmm
!     integer nd,nt,mm(3),nn(3)
!     call idate (mm(1),mm(2),mm(3))
!     call itime (nn)
      character*8 date
      character*10 time
      character*5 zone
      integer values(8),mm(3),nd,nt
      save
      call date_and_time(date,time,zone,values)
      mm(3)=mod(values(1),100)
!     mm(3) = mod (mm(3),100)
      mm(2)=values(3)
      mm(1)=values(2)
      isl(1)= mm(3)                                                      !hr08
      isl(2)= mm(2)                                                      !hr08
      isl(3)= mm(1)                                                      !hr08
      isl(4)= values(5)                                                  !hr08
      isl(5)= values(6)                                                  !hr08
      isl(6)= 0                                                          !hr08
      nd = (mm(3)*100+mm(1))*100 + mm(2)
!     nt =            nn(1) *100 + nn(2)
      nt=values(5)*100+values(6)
      return
      end
      subroutine timest(r1)
      implicit none
      real r1,timestart,timenow
      common /mytimes/timestart
      logical start
      data start /.false./
      save
      if (.not.start) then
        start=.true.
        call cpu_time(timestart)
      endif
      return
      end
      subroutine timex(r1)
      implicit none
      real r1,timestart,timenow
      common /mytimes/timestart
      save
      call timest(0.0)
      call cpu_time(timenow)
      r1=timenow-timestart
      return
      end
      subroutine abend(cstring)
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag
! 6000/20000 -> 30% multipoles
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
 
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer lout
      common /crflags/lout
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
      integer sixrecs,binrec,binrecs,bnlrec,bllrec,numlcr
      logical rerun,start,restart,checkp,fort95,fort96,read95,read96
      character*255 arecord
      character*20 stxt
      character*80 runtim
! Note order of placement in COMMON crdata is important
! for the alignment of the data
      common /crdata/                                                   &
     &sixrecs,binrec,binrecs((npart+1)/2),bnlrec,bllrec,                &
     &numlcr,rerun,start,restart,checkp,                                &
     &fort95,fort96,read95,read96,arecord,stxt,runtim
      integer crnumlcr,crnuml,crnapxo,crnapx,crnumxv,crnnumxv,crnlostp, &
     &crsixrecs,crbinrec,crbinrecs,crbnlrec,crbllrec,cril
      logical crpstop,crsythck
      real crtime3
      double precision cre0,crxv,cryv,crsigmv,crdpsv,crdpsv1,crejv,     &
     &crejfv,craperv,crxvl,cryvl,crdpsvl,crejvl,crsigmvl
      common/crio/                                                      &
     &cre0,
     &crxv(2,npart),cryv(2,npart),                                      &
     &crsigmv(npart),crdpsv(npart),crdpsv1(npart),crejv(npart),         &
     &crejfv(npart),craperv(npart,2),crxvl(2,npart),cryvl(2,npart),     &
     &crdpsvl(npart),crejvl(npart),crsigmvl(npart),                     &
     &            crsixrecs,crbinrec,crbinrecs((npart+1)/2),crbnlrec,   &
     &crbllrec,cril,                                                    &
     &crnumlcr,crnuml,crsythck,                                         &
     &                crtime3,                                          &
     &crnapxo,crnapx,                                                   &
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart)
 
      character*8 version
      character*10 moddate
      integer itot,ttot
      data version /'4.5.35'/
      data moddate /'13.06.2016'/
      integer i,lstring,j
      character*(*) cstring
      character*256 filename
      double precision sumda(60)
      logical fopen
      character*8192 ch
      character*25 ch1
      integer errno,l1,l2
      integer dtostr
      integer ich
      save
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND called and closing files'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
! Calling close to be very safe.......96 calls to abend
! Easier than adding the call on every abend
      call closeUnits
! If fort.10 is inexistent (physics error or some other problem)
! we try and write a 0d0 file with a turn number and CPU time
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND checking fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
 
      open(10,file='fort.10',form='formatted',status='unknown',err=11)
 
! Now we try and read fort.10 i.e. is it empty?
      read(10,'(a255)',end=11,err=11,iostat=ierro) arecord
! Seems to be OK
      goto 12
 11   continue
! Now we try and write a fort.10
! We put some CPU for Igor, a version, and turn number 0
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND writing a fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
!     the version
      itot=0
      ttot=0
      do i=1,8
        if (version(i:i).ne.' ') then
          if (version(i:i).ne.'.') then
            itot=itot*10+ichar(version(i:i))-ichar('0')
          else
            ttot=ttot*10**2+itot
            itot=0
          endif
        endif
      enddo
      ttot=ttot*10**2+itot
      do i=1,60
        sumda(i)=0d0
      enddo
      sumda(52)=dble(ttot)
!     the CPU
      call timex(time1)
      trtime=time1-time0
      sumda(60)=dble(trtime)
! Note it COULD happen that napxo is 0 for a very very early error
! and even napx!!!
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      write(93,*)                                                       &
     &'SIXTRACR STOP/ABEND writing fort.10, lines',napxo,'/',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      if (napxo.eq.0) napxo=napx
      do j=1,napxo
! Now use my new dtostr for portability
        l1=1
        do i=1,60
! We return the length of the string (always 24)
          errno=dtostr(sumda(i),ch1)
          ch(l1:l1+errno)=' '//ch1(1:errno)
          l1=l1+errno+1
        enddo
        write(10,'(a)',iostat=ierro) ch(1:l1-1)
        if(ierro.ne.0) then
          write(*,*)
          write(*,*)'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110'
          write(*,*) 'ERROR CODE : ',ierro
          write(*,*)
        endif
      enddo
 12   continue
      close (10,iostat=ierro)
      write(*,*)                                                        &
     &'SIXTRACK STOP/ABEND '//cstring
      stop
      end
