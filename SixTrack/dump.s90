+dk dump

! A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
! K. Sjobak, BE-ABP/HSS, BE-ABP/LAT
!
! In case the DUMP input block is issued, the beam population is dumped
!   at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator structure
! Important remarks:
!   - The chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot be chosen
!   - The special name 'ALL' will trigger dump at all SINGLE ELEMENTs (settings of dump 
!     are stored in index 0 of all the usual arrays);
!   - The beam population is ALWAYS dumped at the end of the entry, i.e. AFTER the proper
!     transformation map is applied, and after the aperture check, i.e. AFTER the lost
!     particles are filtered out
!   - A negative or null value of the dump frequency is interpreted as dump at every turn
!   - No check is performed on the logical units, i.e. if the ones selected by the user
!     are used in other places of the code...
!   - The dump format can be changed to the one required by the LHC aperture check
!     post-processing tools, activating the dumpfmt flag (0=off, by default);

module dump
  
  use floatPrecision
  use end_sixtrack
  use parpro ! For nele
  use mod_alloc
  use string_tools, only : str_maxLen

  implicit none

  ! High precision printout required at all flagged SINGLE ELEMENTs
  logical, save :: ldumphighprec
  ! Dump at the beginning of each element, not at the end.
  logical, save :: ldumpfront
  ! flag the SINGLE ELEMENT for dumping
  logical, allocatable, save :: ldump(:)  !(-1:nele)

  ! Dump every n turns at a flagged SINGLE ELEMENT (dump frequency)
  integer, allocatable, save :: ndumpt(:) !(-1:nele)
  ! First turn for DUMP to be active
  integer, allocatable, save :: dumpfirst(:) !(-1:nele)
  ! Last turn for this DUMP to be active (-1=all)
  integer, allocatable, save :: dumplast(:) !(-1:nele)
  ! Fortran unit for dump at a flagged SINGLE ELEMENT
  integer, allocatable, save :: dumpunit(:) !(-1:nele)
  ! Flag the format of the dump
  integer, allocatable, save :: dumpfmt(:) !(-1:nele)
  ! Filename to write the dump to
  character(len=:), allocatable, save :: dump_fname(:) !(str_maxLen)(-1:nele)

  ! tas matrix used for nomalisation of phase space in DUMP and FMA.
  ! First index = -1 -> StartDUMP, filled differently than idx > 0; First index = 0  -> Unused.
  real(kind=fPrec), save :: dumptas (-1:nblz,6,6)
  ! inverse matrix of dumptas
  real(kind=fPrec), save :: dumptasinv (-1:nblz,6,6)
  ! closed orbit used for normalisation of phase space
  ! TODO: check units used in dumpclo; is x' or px used?
  real(kind=fPrec), save :: dumpclo (-1:nblz,6)

+if cr
  ! For resetting file positions
  integer, allocatable,save :: dumpfilepos(:), dumpfilepos_cr(:) !(-1:nele)
+ei

! ================================================================================================================================ !
!  THE SUBROUTINES
! ================================================================================================================================ !
contains

! ================================================================================================================================ !
subroutine dump_allocate_arrays
  use crcoall
  implicit none
  integer :: stat

  character(len=str_maxLen) :: defaultstring
  defaultstring = repeat(char(0),str_maxLen)

!  allocate(ldump(-1:nele), ndumpt(-1:nele), dumpfirst(-1:nele), dumplast(-1:nele), &
!       dumpunit(-1:nele), dumpfmt(-1:nele), dump_fname(-1:nele), STAT=stat)
!  if (stat.ne.0) then
!     write(lout,'(A,I8)') "ERROR in SUBROUTINE DUMP_ALLOCATE_ARRAYS; stat=", stat
!     call prror(-1)
!  endif
  call alloc(ldump,nele,.FALSE.,'ldump',-1)
  call alloc(ndumpt,nele,0,'ndumpt',-1)
  call alloc(dumpfirst,nele,0,'dumpfirst',-1)
  call alloc(dumplast,nele,0,'dumplast',-1)
  call alloc(dumpunit,nele,0,'dumpunit',-1)
  call alloc(dumpfmt,nele,0,'dumpfmt',-1)
  call alloc(dump_fname,str_maxLen,nele,defaultstring,'dump_fname',-1)

+if cr
  call alloc(dumpfilepos,nele,0,'dumpfilepos',-1)
  call alloc(dumpfilepos_cr,nele,0,'dumpfilepos_cr',-1)
!  allocate(dumpfilepos(-1:nele),dumpfilepos_cr(-1:nele), STAT=stat)
!  if (stat.ne.0) then
!     write(lout,'(A,I8)') "ERROR in SUBROUTINE DUMP_ALLOCATE_ARRAYS; stat=", stat
!     call prror(-1)
!  endif
+ei
end subroutine dump_allocate_arrays

subroutine dump_expand_arrays(nele_new)
  use crcoall
  implicit none
  integer, intent(in) :: nele_new

  character(len=str_maxLen) :: defaultstring
  defaultstring = repeat(char(0),str_maxLen)

  call resize(ldump,nele_new,.FALSE.,'ldump',-1)
  call resize(ndumpt,nele_new,0,'ndumpt',-1)
  call resize(dumpfirst,nele_new,0,'dumpfirst',-1)
  call resize(dumplast,nele_new,0,'dumplast',-1)
  call resize(dumpunit,nele_new,0,'dumpunit',-1)
  call resize(dumpfmt,nele_new,0,'dumpfmt',-1)
  call resize(dump_fname,str_maxLen,nele_new,defaultstring,'dump_fname',-1)

+if cr
  call resize(dumpfilepos,nele_new,0,'dumpfilepos',-1)
  call resize(dumpfilepos_cr,nele_new,0,'dumpfilepos_cr',-1)
+ei
end subroutine dump_expand_arrays

subroutine dump_lines (n,i,ix)

  implicit none
  integer, intent(in) :: n,i,ix

+ca commontr
  if ( ldump(0) ) then
    ! Dump at all SINGLE ELEMENTs
    if (ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1) then
      if ((n.ge.dumpfirst(0)) .and. ((n.le.dumplast(0)) .or. (dumplast(0).eq.-1))) then
        call dump_beam_population(n, i, ix, dumpunit(0), dumpfmt(0), ldumphighprec, dumpclo(ix,1:6),dumptasinv(ix,1:6,1:6))
      end if
    end if
  end if
  if (ktrack(i) .ne. 1) then
    ! The next "if" is only safe for SINGLE ELEMENTS, not BLOC where ix<0.
    if (ldump(ix)) then
      ! Dump at this precise SINGLE ELEMENT
      if (ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1) then
        if ((n.ge.dumpfirst(ix)) .and. ((n.le.dumplast(ix)) .or. (dumplast(ix).eq.-1))) then
          call dump_beam_population(n, i, ix, dumpunit(ix), dumpfmt(ix), ldumphighprec, dumpclo(ix,1:6),dumptasinv(ix,1:6,1:6))
        end if
      end if
    end if
  end if

end subroutine dump_lines

! ================================================================================================================================ !
subroutine dump_linesFirst(n)

  implicit none
  integer, intent(in) :: n
  
  ! StartDUMP - dump on the first element
  if (ldump(-1)) then
    if (ndumpt(-1).eq.1 .or. mod(n,ndumpt(-1)).eq.1) then
      if ((n.ge.dumpfirst(-1)) .and. ((n.le.dumplast(-1)) .or. (dumplast(-1).eq.-1))) then
        call dump_beam_population(n, 0, 0, dumpunit(-1), dumpfmt(-1), ldumphighprec, dumpclo(-1,1:6),dumptasinv(-1,1:6,1:6))
      end if
    end if
  end if
  
end subroutine dump_linesFirst

! ================================================================================================================================ !
!  A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!  Last modified: 01-09-2014
!  Close units for dumping particle population
! ================================================================================================================================ !
subroutine dump_closeUnits
  
  use mod_common
  implicit none
  logical lopen
  integer i
  
  do i=0,il
    if (ldump(i)) then
      ! The same file could be used by more than one SINGLE ELEMENT
      inquire( unit=dumpunit(i), opened=lopen )
      if (lopen) close(dumpunit(i))
    end if
  end do
  
end subroutine dump_closeUnits

! ================================================================================================================================ !
subroutine dump_parseInputLine(ch)
  
  use crcoall
  use mod_common
  use file_units
  use string_tools
  
  implicit none
  
  character(len=*), intent(in) :: ch
  character getfields_fields(getfields_n_max_fields)*(str_maxLen) ! Array of fields
  integer   getfields_nfields                                                 ! Number of identified fields
  integer   getfields_lfields(getfields_n_max_fields)                         ! Length of each what:
  logical   getfields_lerr                                                    ! An error flag
  
  ! Temp variables
  character(len=max_name_len) idat ! Synchronized with daten
  integer i1,i2,i3,i4,i5,kk,j
  
  character(len=str_maxLen) ch1
  
  ! initialise reading variables, to avoid storing nonsense values
  idat = ' ' ! Name
  i1 = 0     ! frequency
  i2 = -1    ! unit
  i3 = 0     ! format
  i4 = 1     ! first turn
  i5 = -1    ! last turn
  
  if(ch(:4).eq.'HIGH') then
    ldumphighprec = .true.
    return
  else if(ch(:5).eq.'FRONT') then
    ldumpfront = .true.
    return
  end if
  
  ! Requested element
  call getfields_split(ch, getfields_fields, getfields_lfields, getfields_nfields, getfields_lerr)
  if (getfields_lerr) call prror(-1)
  
  if ((getfields_nfields .lt. 4) .or. (getfields_nfields .gt. 7) .or. (getfields_nfields .eq. 6)) then
    write(lout,*) "ERROR in DUMP:"
    write(lout,*) "Expected 4 to 7 (but not 6) arguments, got", getfields_nfields
    write(lout,*) ("'"//getfields_fields(kk)(1:getfields_lfields(kk))//"' ",kk=1,getfields_nfields)
    call prror(-1)
  end if
  
  if (getfields_lfields(1) > max_name_len) then
    write(lout,*) "ERROR in DUMP:"
    write(lout,*) "element names are max. ', max_name_len, ' characters"
    call prror(-1)
  end if
  
  idat = getfields_fields(1)(1:getfields_lfields(1))
  read(getfields_fields(2)(1:getfields_lfields(2)),*) i1
  read(getfields_fields(3)(1:getfields_lfields(3)),*) i2
  read(getfields_fields(4)(1:getfields_lfields(4)),*) i3
  if (getfields_nfields .eq. 4) then
    ! Automatic fname
    write(ch1,"(a5,I0)") "fort.", i2
  else if ( (getfields_nfields .eq. 5) .or. (getfields_nfields .eq. 7)) then
    ! Given fname
    ch1 = getfields_fields(5)(1:getfields_lfields(5))
  else
    call prror(-1)
  end if
  if (getfields_nfields .eq. 7) then
    read(getfields_fields(6)(1:getfields_lfields(6)),*) i4
    read(getfields_fields(7)(1:getfields_lfields(7)),*) i5
  end if
  
  ! Check that first/last turn is sane
  if (i5.ne.-1) then
    if (i5 .lt. i4) then
      write(lout,*) "Error in DUMP: Expect last turn >= first turn, unless last turn = -1 (infinity), got", i4,i5
      call prror(-1)
    end if
  end if
  if (i4 .lt. 1) then
    write(lout,*) "Error in DUMP: Expect first turn >= 1, got", i4
    call prror(-1)
  end if
  
  ! Find it in the list of SINGLE ELEMENTs:
  do j=1,il
    if(bez(j).eq.idat) then
      if (ldump(j)) then ! Only enable once/element!
        write(lout,*) "Error in parsing DUMP block:"
        write(lout,*) "Element '",idat, "' was specified more than once"
        call prror(-1)
      end if
      
      ! Element was found in SINGLE ELEMENTS list, now do some sanity checks
      if(trim(bez(j)).eq."ALL") then
        write(lout,*) "Error in parsing DUMP block:"
        write(lout,*) "The element name 'ALL' cannot be used in the SINGLE ELEMENTS list when an 'ALL' special DUMP is active."
        call prror(-1)
      else if(trim(bez(j)).eq."StartDUMP") then
        write(lout,*) "Error in parsing DUMP block:"
        write(lout,*) "The element name 'StartDUMP' cannot be used in the SINGLE ELEMENTS "// &
                      "list when an 'StartDUMP' special DUMP is active."
        call prror(-1)
      end if
      goto 10 ! Element found, store the data
    end if
  end do
  
  if (idat(:3).eq.'ALL') then
    j=0
    if (ldump(j)) then
      write(lout,*) "ERROR in parsing DUMP block:"
      write(lout,*) "'Element' ALL was specified (at least) twice"
      call prror(-1)
    end if
    goto 10 ! Element found, store the data
  end if
  if (idat(:9).eq.'StartDUMP') then
    j=-1
    if (ldump(j)) then
      write(lout,*) "ERROR in parsing DUMP block:"
      write(lout,*) "'Element' StartDUMP was specified (at least) twice"
      call prror(-1)
    end if
    goto 10 ! Element found, store the data
  end if
  
  ! Search failed, fall-through to here:
  write(lout,*) ''
  write(lout,*) " Un-identified SINGLE ELEMENT '", idat, "'"
  write(lout,*) '   in block DUMP (fort.3)'
  write(lout,*) '   parsed line:'
  write(lout,*) trim(ch)
  write(lout,*) ''
  call prror(-1)
  
  ! Element found, store the data:
10 continue
  ldump(j)     = .true.
  ndumpt(j)    = i1
  dumpunit(j)  = i2
  dumpfmt(j)   = i3
  dump_fname(j) = repeat(char(0),str_maxLen) ! Zero the file name first, as there is a bug in mod_alloc
  dump_fname(j)(1:getfields_lfields(5)) = ch1(1:getfields_lfields(5))
  dumpfirst(j) = i4
  dumplast(j)  = i5

  if(ndumpt(j)   <=  0) ndumpt(j)=1
  if(dumpunit(j) == -1) then
    call funit_requestUnit(dump_fname(j),dumpunit(j))
  end if
  
  return
  
end subroutine dump_parseInputLine

! ================================================================================================================================ !
subroutine dump_parseInputDone
  
  use crcoall
  use mod_common
  use string_tools
  
  implicit none

  ! Temp variables
  integer ii,jj,kk
  character(len=str_maxLen) ch1
  
  ! HEADER
  write(lout,10460) "DUMP"
  write(lout,*) ''
  write(lout,*) '       The last column states the format'
  write(lout,*) '            of the output file (see manual):'
  
  ! ldump(0)=.true. : DUMP all elements found
  if (ldump(0)) then
    write(lout,10470) 'ALL SING. ELEMS.', &
                      ndumpt(0),dumpunit(0),trim(stringzerotrim(dump_fname(0))),dumpfmt(0),dumpfirst(0),dumplast(0)
  end if
  if (ldump(-1)) then
    write(lout,10470) 'StartDUMP speci.', &
                      ndumpt(0),dumpunit(0),trim(stringzerotrim(dump_fname(0))),dumpfmt(0),dumpfirst(0),dumplast(0)
  end if
  
  do ii=1,il
    if (ldump(ii)) then
      write(lout,10470) bez(ii),ndumpt(ii),dumpunit(ii),trim(stringzerotrim(dump_fname(ii))),dumpfmt(ii),dumpfirst(ii),dumplast(ii)
      ! At which structure indices is this single element found? (Sanity check)
      kk = 0
        do jj=1,mper*mbloz      ! Loop over all structure elements
          if (ic(jj)-nblo .eq. ii) then
            write (ch1,*) jj    ! internal write for left-adjusting
            write (lout,10472) " -> Found as structure element no. " // trim(adjustl(ch1))
            kk = kk + 1
          end if
        end do
        if (kk .eq. 0) then
          write (lout,10472) " !! Warning: No structure elements found for '" // bez(ii) // "'!"
          write (lout,10472) " !! This element is probably only found in a BLOC, or it is not used at all."
          write (lout,10472) " !! Please fix your DUMP block in fort.3"
          call prror(-1)
        end if
      end if
    end do
    
    if (ldumphighprec) then
      write(lout,*) ''
      write(lout,*) '        --> requested high precision dumping!'
    end if
    if (ldumpfront) then
      write(lout,*) ''
      write(lout,*) '        --> requested FRONT dumping!'
    end if
    return
      
10460 format(//131('-')//t10,'DATA BLOCK ',a4,' INFOs'/ /t10, 'ELEMENT NAME',8x,'EVERY # TURNs',2x, &
                      'LOGICAL UNIT',2x,'FILENAME',24x,'FORMAT',5x, "FirstTurn",6x,"LastTurn")
10470 format(t10,a16,4x,i13,2x,i12,2x,a32,i6,2x,i12,2x,i12)
10472 format(t10,a)

end subroutine dump_parseInputDone

! ================================================================================================================================ !
subroutine dump_initialize
  
  use numerical_constants, only : zero
  use crcoall
  use string_tools
  
  use mod_common
  
  implicit none
  
  integer i,j
  logical lopen
  character(len=256) filename
  
  do i=-1,il
+if cr
    if (dumpfilepos(i).ge.0) then
      ! Expect the file to be opened already, in crcheck
      inquire( unit=dumpunit(i), opened=lopen )
      if (.not.lopen) then
        write(lout,*) "ERROR in DUMP: The unit",dumpunit(i),"has dumpfilepos=", dumpfilepos(i), ".ge.0, ", &
                      "but the file is NOT open. This is probably a bug."
        call prror(-1)
      end if
      cycle ! Everything OK, don't try to open the files again.
    end if
+ei
    if (ldump(i)) then
      ! The same file could be used by more than one SINGLE ELEMENT
      inquire( unit=dumpunit(i), opened=lopen )
      if (.not.lopen) then
        ! Check that the filename is not already taken
        do j=-1,i-1
          if (ldump(j) .and. (dump_fname(j).eq.dump_fname(i))) then
            write(lout,*) "ERROR in DUMP: Output filename '",trim(stringzerotrim(dump_fname(i))), &
                          "' is used by two DUMPS, but output units differ:",dumpunit(i), " vs ", dumpunit(j)
            call prror(-1)
          end if
        end do
        if (dumpfmt(i).eq.3 .or. dumpfmt(i).eq.8) then ! Binary dump
+if boinc
          call boincrf(dump_fname(i),filename)
          open(dumpunit(i),file=filename,status='replace',form='unformatted')
+ei
+if .not.boinc
          open(dumpunit(i),file=trim(stringzerotrim(dump_fname(i))),status='replace',form='unformatted')
+ei
        else ! ASCII dump
+if boinc
          call boincrf(dump_fname(i),filename)
          open(dumpunit(i),file=filename,status='replace',form='formatted')
+ei
+if .not.boinc
          open(dumpunit(i),file=trim(stringzerotrim(dump_fname(i))),status='replace',form='formatted')
+ei
        end if
+if cr
        dumpfilepos(i) = 0
+ei
      else ! lopen was .TRUE.

        ! Sanity check: If file number i is already open, it should be by another DUMP
        ! (but we can't guarantee that files opened later are handled correctly)
        ! Also, a file should not be shared with element 0 (all) or -1 (StartDUMP)
        ! All dumps writing to the same file (unit) must have the same format and filename.
        ! If everything is OK, add to the header.
        
        ! Reuse the lopen flag as a temp variable
        lopen = .false.
        do j=-1,i-1 ! Search all possible DUMPs up to but not including the one we're looking at (number i)
          if (ldump(j)) then
            if (dumpunit(j).eq.dumpunit(i)) then
              if (dumpfmt(j).ne.dumpfmt(i)) then
                write(lout,*) "ERROR in DUMP: output unit",dumpunit(i), " used by two DUMPS, formats are not the same."
                call prror(-1)
              else if (j.eq.0) then
                write(lout,*) "ERROR in DUMP: output unit",dumpunit(i), " used by two DUMPS, one of which is ALL"
                call prror(-1)
              else if (j.eq.-1) then
                write(lout,*) "ERROR in DUMP: output unit",dumpunit(i), " used by two DUMPS, one of which is StartDUMP"
                call prror(-1)
              else if (dump_fname(j).ne.dump_fname(i)) then
                write(lout,*) "ERROR in DUMP: output unit",dumpunit(i)," used by two DUMPS, but filenames differ: ", &
                              "'",trim(stringzerotrim(dump_fname(i))), "' vs '", trim(stringzerotrim(dump_fname(j))), "'"
                call prror(-1)
              else
                ! Everything is fine
                lopen = .true.
+if cr
                ! Dumpfilepos is separate for every element, even if they share files.
                dumpfilepos(i) = 0
+ei
              end if
            end if ! IF file unit matches
          end if ! IF ldump(j)
        end do ! DO loop over j
        
        ! LOPEN not set to true by sanity check in loop above
        ! => File was already open, but not by DUMP.
        if (.not.lopen) then
          write (lout,*) "ERROR in DUMP: unit", dumpunit(i), " is already open, but not by DUMP. Please pick another unit! ", &
                         " Note: This test is not watertight, as other parts of the program may later open the same file/unit."
          call prror(-1)
        end if
      end if
      
      ! Write format-specific headers
      if (dumpfmt(i).eq.1) then
        write(dumpunit(i),'(a)') '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] dE/E[1] ktrack'
        ! Flush file
        endfile   (dumpunit(i))
        backspace (dumpunit(i))
+if cr
        dumpfilepos(i) = dumpfilepos(i) + 1
+ei
      else if (dumpfmt(i).eq.2 .or. dumpfmt(i).eq.4 .or. dumpfmt(i).eq.5 .or. &
               dumpfmt(i).eq.6 .or. dumpfmt(i).eq.7 .or. dumpfmt(i).eq.9 ) then
        ! Write the general header
        if (i.eq.-1) then  ! STARTdump
          write(dumpunit(i),'(a,i0,a,a16,4(a,i12),2(a,L1))') &
            '# DUMP format #',dumpfmt(i),', START=',bez(1), ', number of particles=',napx, ', dump period=',ndumpt(i), &
            ', first turn=', dumpfirst(i), ', last turn=',dumplast(i), ', HIGH=',ldumphighprec, ', FRONT=',ldumpfront
        else if (i.eq.0) then ! ALL
          write(dumpunit(i),'(a,i0,a,4(a,i12),2(a,L1))') &
            '# DUMP format #',dumpfmt(i),', ALL ELEMENTS,', ' number of particles=',napx, ', dump period=',ndumpt(i), &
            ', first turn=', dumpfirst(i), ', last turn=',dumplast(i), ', HIGH=',ldumphighprec, ', FRONT=',ldumpfront
        else ! Normal element
          write(dumpunit(i),'(a,i0,a,a16,4(a,i12),2(a,L1))') &
            '# DUMP format #',dumpfmt(i), ', bez=', bez(i), ', number of particles=',napx,', dump period=',ndumpt(i), &
            ', first turn=',dumpfirst(i), ', last turn=',dumplast(i), ', HIGH=',ldumphighprec, ', FRONT=',ldumpfront
        end if
         
        ! Write the format-specific headers:
        if (dumpfmt(i).eq.2) then ! FORMAT 2
          write(dumpunit(i),'(a,a)') '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] z[mm] dE/E[1] ktrack'
        else if (dumpfmt(i).eq.4) then ! FORMAT 4
          write(dumpunit(i),'(a)') '# napx turn s[m] <x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <z>[mm] <dE/E>[1]'
        else if (dumpfmt(i).eq.5) then ! FORMAT 5
          write(dumpunit(i),'(a)') '# napx turn s[m] ' //                  &
            '<x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <z>[mm] <dE/E>[1] '//   &
            '<x^2> <x*xp> <x*y> <x*yp> <x*z> <x*(dE/E)> '//                &
            '<xp^2> <xp*y> <xp*yp> <xp*z> <xp*(dE/E)> '//                  &
            '<y^2> <y*yp> <y*z> <y*(dE/E)> '//                             &
            '<yp^2> <yp*z> <yp*(dE/E)> '//                                 &
            '<z^2> <z*(dE/E)> '//                                          &
            '<(dE/E)^2>'
        else if (dumpfmt(i).eq.6) then ! FORMAT 6
          write(dumpunit(i),'(a)') '# napx turn s[m] ' //                  &
            '<x>[m] <px>[1] <y>[m] <py>[1] <sigma>[m] <psigma>[1] '//      &
            '<x^2> <x*px> <x*y> <x*py> <x*sigma> <x*psigma> '//            &
            '<px^2> <px*y> <px*py> <px*sigma> <px*psigma> '//              &
            '<y^2> <y*py> <y*sigma> <y*psigma> '//                         &
            '<py^2> <py*sigma> <py*psigma> '//                             &
            '<sigma^2> <sigma*psigma> '//                                  &
            '<psigma^2>'
        else if (dumpfmt(i).eq.7 .or. dumpfmt(i).eq.9) then
          ! Normalized ASCII dump -> extra headers with matrices and closed orbit
          if (dumpfmt(i).eq.7) then ! FORMAT 7
            write(dumpunit(i),'(a)') '# ID turn s[m] nx[1.e-3 sqrt(m)] npx[1.e-3 sqrt(m)] '// &
              'ny[1.e-3 sqrt(m)] npy[1.e-3 sqrt(m)] nsig[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] ktrack'
          end if
          if (dumpfmt(i).eq.9) then ! FORMAT 9
            write(dumpunit(i),'(a)') '# napx turn s[m] ' //                   &
              '<nx>[1.e-3 sqrt(m)] <npx>[1.e-3 sqrt(m)] '//                   &
              '<ny>[1.e-3 sqrt(m)] <npy>[1.e-3 sqrt(m)] '//                   &
              '<nsig>[1.e-3 sqrt(m)] <ndp/p>[1.e-3 sqrt(m)]'//                & ! There should be a space at the end of the string
              '<nx^2> <nx*npx> <nx*ny> <nx*npy> <nx*nsigma> <nx*npsigma> '//  &
              '<npx^2> <npx*ny> <npx*npy> <npx*nsigma> <npx*npsigma> '//      &
              '<ny^2> <ny*npy> <ny*nsigma> <ny*npsigma> '//                   &
              '<npy^2> <npy*nsigma> <npy*npsigma> '//                         &
              '<nsigma^2> <nsigma*npsigma> '//                                &
              '<npsigma^2>'
          end if
          ! closed orbit
          ! units: x,xp,y,yp,sig,dp/p = [mm,mrad,mm,mrad,1] 
          ! (note: units are already changed in linopt part)
          write(dumpunit(i),'(a,1x,6(1X,1PE16.9))') '# closed orbit [mm,mrad,mm,mrad,1]', &
            dumpclo(i,1),dumpclo(i,2),dumpclo(i,3),dumpclo(i,4),dumpclo(i,5),dumpclo(i,6)
          write(dumpunit(i),'(a,1x,36(1X,1PE16.9))') '# tamatrix [mm,mrad,mm,mrad,1]', &
            dumptas(i,1,1),dumptas(i,1,2),dumptas(i,1,3),dumptas(i,1,4),dumptas(i,1,5),dumptas(i,1,6), &
            dumptas(i,2,1),dumptas(i,2,2),dumptas(i,2,3),dumptas(i,2,4),dumptas(i,2,5),dumptas(i,2,6), &
            dumptas(i,3,1),dumptas(i,3,2),dumptas(i,3,3),dumptas(i,3,4),dumptas(i,3,5),dumptas(i,3,6), &
            dumptas(i,4,1),dumptas(i,4,2),dumptas(i,4,3),dumptas(i,4,4),dumptas(i,4,5),dumptas(i,4,6), &
            dumptas(i,5,1),dumptas(i,5,2),dumptas(i,5,3),dumptas(i,5,4),dumptas(i,5,5),dumptas(i,5,6), &
            dumptas(i,6,1),dumptas(i,6,2),dumptas(i,6,3),dumptas(i,6,4),dumptas(i,6,5),dumptas(i,6,6)
          write(dumpunit(i),'(a,1x,36(1X,1PE16.9))') '# inv(tamatrix)', &
            dumptasinv(i,1,1),dumptasinv(i,1,2),dumptasinv(i,1,3),dumptasinv(i,1,4),dumptasinv(i,1,5),dumptasinv(i,1,6), &
            dumptasinv(i,2,1),dumptasinv(i,2,2),dumptasinv(i,2,3),dumptasinv(i,2,4),dumptasinv(i,2,5),dumptasinv(i,2,6), &
            dumptasinv(i,3,1),dumptasinv(i,3,2),dumptasinv(i,3,3),dumptasinv(i,3,4),dumptasinv(i,3,5),dumptasinv(i,3,6), &
            dumptasinv(i,4,1),dumptasinv(i,4,2),dumptasinv(i,4,3),dumptasinv(i,4,4),dumptasinv(i,4,5),dumptasinv(i,4,6), &
            dumptasinv(i,5,1),dumptasinv(i,5,2),dumptasinv(i,5,3),dumptasinv(i,5,4),dumptasinv(i,5,5),dumptasinv(i,5,6), &
            dumptasinv(i,6,1),dumptasinv(i,6,2),dumptasinv(i,6,3),dumptasinv(i,6,4),dumptasinv(i,6,5),dumptasinv(i,6,6)
        end if ! Format-specific headers
        
        ! Flush file
        endfile   (dumpunit(i))
        backspace (dumpunit(i))
+if cr
        dumpfilepos(i) = dumpfilepos(i) + 2
        ! format 7 also writes clo, tas and tasinv
        if (dumpfmt(i).eq.7 .or. dumpfmt(i).eq.9) then 
          dumpfilepos(i) = dumpfilepos(i) + 3
        end if
+ei
      end if ! END if format 2/4/5/6/7/9 -> General header
      
      ! Normalized DUMP
      if (dumpfmt(i).eq.7 .or. dumpfmt(i).eq.8 .or. dumpfmt(i).eq.9) then
        ! Have a matrix that's not zero (i.e. did we put a 6d LINE block?)
        if (dumptas(i,1,1).eq.zero .and. dumptas(i,1,2).eq.zero .and. &
            dumptas(i,1,3).eq.zero .and. dumptas(i,1,4).eq.zero) then
          write(lout,*) "ERROR in normalized DUMP:"
          write(lout,*) "The normalization matrix appears to not be set?"
          write(lout,*) "Did you forget to put a 6D LINE block?"
          call prror(-1)
        end if
        if(idp.eq.0 .or. ition.eq.0) then ! We're in the 4D case
          if(imc.ne.1) then ! Energy scan
            write(lout,*) "ERROR in normalized DUMP:"
            write(lout,*) "Energy scan (imc != 1) not supported!"
            call prror(-1)
          end if
          if(i.ne.-1) then ! Not at StartDUMP
            write(lout,*) "ERROR in normalized DUMP:"
            write(lout,*) "4D only supported for StartDUMP!"
            call prror(-1)
          end if
        end if
      end if ! END if normalized dump
    end if ! If ldump(i) -> Dump on this element
  end do ! Loop over elements with index i
  
end subroutine dump_initialize

! ================================================================================================================================ !
!  By A.Mereghetti, D.Sinuela-Pastor & P.Garcia Ortega, for the FLUKA Team
!  K.Sjobak and A.Santamaria, BE-ABP-HSS
!  Last modified: 21-09-2015
!  dump beam particles
!  always in main code
!
!  nturn     : Current turn number
!  i         : Current structure element (0 for StartDUMP)
!  ix        : Corresponding single element (<0 for BLOC, only for ALL; 0 for StartDUMP)
!  unit      : Unit to dump from
!  fmt       : Dump output format (0/1/2/...)
!  lhighprec : High precission output y/n
! ================================================================================================================================ !
subroutine dump_beam_population( nturn, i, ix, unit, fmt, lhighprec, loc_clo, tasinv )
  
  use floatPrecision
  use physical_constants
  use numerical_constants
  use crcoall
  
  use parpro
  use mod_common
  use mod_commonmn
  implicit none
  
  ! interface variables:
  integer, intent(in) :: nturn, i, ix, unit, fmt
  logical, intent(in) ::  lhighprec
  real(kind=fPrec), intent(in) :: tasinv(6,6) ! normalization matrix in [mm,mrad,mm,mrad,mm,1]
  real(kind=fPrec), intent(in) :: loc_clo(6) ! closed orbit in [mm,mrad,mm,mrad,mm,1]
+ca commonm1
+ca commontr
+ca dbdcum

+if collimat
+ca collpara
+ca dbcommon
+ei
+if .not.collimat
  integer, parameter :: samplenumber = 1
+ei
  
  ! Temporary variables
  integer j,k,l,m,n
  character(len=max_name_len) localBez
  
  real(kind=fPrec) localDcum
  integer localKtrack
  
  real(kind=fPrec) xyz_particle(6),nxyz_particle(6)
  real(kind=fPrec) xyz(6)
  real(kind=fPrec) xyz2(6,6)
  
+if cr      
  ! For accessing dumpfilepos
  integer dumpIdx
  if (unit .eq. dumpunit(0)) then
    ! ALL output must be on separate unit
    dumpIdx = 0
  elseif (unit .eq. dumpunit(-1)) then
    ! ALL output must be on separate unit
    dumpIdx = -1
  else
    dumpIdx = ix
  end if
+ei
  ! General format
  if (fmt .eq. 0) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = 0.0
      localBez = "StartDUMP"
    else
      localDcum = dcum(i)
      if (ktrack(i) .ne. 1) then
        localBez = bez(ix)
      else                ! BLOCs
        localBez = bezb(ic(i))
      end if
    end if
    if (lhighprec) then
      do j=1,napx
        write(unit,1981) nturn, i, ix, localBez, localDcum, xv(1,j)*c1m3, yv(1,j)*c1m3, xv(2,j)*c1m3, &
          yv(2,j)*c1m3, ejfv(j)*c1m3, (ejv(j)-e0)*c1e6, -c1m3*(sigmv(j)/clight)*(e0/e0f)
      end do
    else
      do j=1,napx
        write(unit,1982) nturn, i, ix, localBez, localDcum, xv(1,j)*c1m3, yv(1,j)*c1m3, xv(2,j)*c1m3, &
          yv(2,j)*c1m3, ejfv(j)*c1m3, (ejv(j)-e0)*c1e6, -c1m3*(sigmv(j)/clight)*(e0/e0f)
      end do
    end if
    write(unit,*) ''
    write(unit,*) ''
    
    ! Flush
    endfile (unit,iostat=ierro)
    backspace (unit,iostat=ierro)
+if cr
    dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx+2
+ei
    
  ! Format for aperture check
  else if (fmt .eq. 1) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = 0.0
      localKtrack = 0
    else
      localDcum = dcum(i)
      localKtrack = ktrack(i)
    end if
    if (lhighprec) then
      do j=1,napx
        write(unit,1983) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum,xv(1,j),yv(1,j),xv(2,j),yv(2,j),(ejv(j)-e0)/e0,localKtrack
      end do
    else
      do j=1,napx
        write(unit,1984) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum,xv(1,j),yv(1,j),xv(2,j),yv(2,j),(ejv(j)-e0)/e0,localKtrack
      end do
    end if
    
    ! Flush
    endfile (unit,iostat=ierro)
    backspace (unit,iostat=ierro)
+if cr
    dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
  
  ! Same as fmt 1, but also include z (for crab cavities etc.)
  else if (fmt .eq. 2) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = zero
      localKtrack = 0
    else
      localDcum = dcum(i)
      localKtrack = ktrack(i)
    end if
      if (lhighprec) then
        do j=1,napx
          write(unit,1985) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum,xv(1,j),yv(1,j),xv(2,j),yv(2,j), &
            sigmv(j),(ejv(j)-e0)/e0,localKtrack
        end do
      else
        do j=1,napx
          write(unit,1986) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum,xv(1,j),yv(1,j),xv(2,j),yv(2,j), &
            sigmv(j),(ejv(j)-e0)/e0,localKtrack
        end do
      end if
      
      ! Flush
      endfile (unit,iostat=ierro)
      backspace (unit,iostat=ierro)
+if cr
      dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
  ! Same as fmt 2, but in Fortran binary
  else if (fmt .eq. 3) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = zero
      localKtrack = 0
    else
      localDcum = dcum(i)
      localKtrack = ktrack(i)
    end if
    do j=1,napx
      write(unit) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum,xv(1,j),yv(1,j),xv(2,j),yv(2,j), &
        sigmv(j),(ejv(j)-e0)/e0,localKtrack
    end do
    
    ! Flush
    endfile (unit,iostat=ierro)
    backspace (unit,iostat=ierro)
+if cr
    dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
  ! Average bunch position
  else if (fmt .eq. 4) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = zero
    else
      localDcum = dcum(i)
    end if
    do l=1,6
      xyz(l) = zero
    end do
    do j=1,napx
      xyz(1) = xyz(1) + xv(1,j)
      xyz(2) = xyz(2) + yv(1,j)
      xyz(3) = xyz(3) + xv(2,j)
      xyz(4) = xyz(4) + yv(2,j)
      xyz(5) = xyz(5) + sigmv(j)
      xyz(6) = xyz(6) + (ejv(j)-e0)/e0
    end do
    
    xyz = xyz/napx
    if (lhighprec) then
      write(unit,1989) napx, nturn, localDcum, xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6)
    else
      write(unit,1990) napx, nturn, localDcum, xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6)
    end if
    
    ! Flush
    endfile (unit,iostat=ierro)
    backspace (unit,iostat=ierro)
+if cr
    dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+1
+ei
  ! Average beam positon + beam matrix
  else if (fmt.eq.5 .or. fmt.eq.6) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = zero
    else
      localDcum = dcum(i)
    end if
    
    do l=1,6
      xyz(l) = zero
      do k=1,6
        xyz2(l,k) = zero
      end do
    end do
    
    if(fmt.eq.5) then ! Raw
      do j=1,napx
        xyz_particle(6)=(ejv(j)-e0)/e0
        
        ! Average beam position
        xyz(1) = xyz(1) + xv(1,j)
        xyz(2) = xyz(2) + yv(1,j)
        xyz(3) = xyz(3) + xv(2,j)
        xyz(4) = xyz(4) + yv(2,j)
        xyz(5) = xyz(5) + sigmv(j)
        xyz(6) = xyz(6) + xyz_particle(6)
        
        ! Beam matrix (don't calulate identical elements twice (symmetry))
        xyz2(1,1) = xyz2(1,1) + xv(1,j)*xv(1,j)
        xyz2(2,1) = xyz2(2,1) + xv(1,j)*yv(1,j)
        xyz2(3,1) = xyz2(3,1) + xv(1,j)*xv(2,j)
        xyz2(4,1) = xyz2(4,1) + xv(1,j)*yv(2,j)
        xyz2(5,1) = xyz2(5,1) + xv(1,j)*sigmv(j)
        xyz2(6,1) = xyz2(6,1) + xv(1,j)*xyz_particle(6)
        
        xyz2(2,2) = xyz2(2,2) + yv(1,j)*yv(1,j)
        xyz2(3,2) = xyz2(3,2) + yv(1,j)*xv(2,j)
        xyz2(4,2) = xyz2(4,2) + yv(1,j)*yv(2,j)
        xyz2(5,2) = xyz2(5,2) + yv(1,j)*sigmv(j)
        xyz2(6,2) = xyz2(6,2) + yv(1,j)*xyz_particle(6)
        
        xyz2(3,3) = xyz2(3,3) + xv(2,j)*xv(2,j)
        xyz2(4,3) = xyz2(4,3) + xv(2,j)*yv(2,j)
        xyz2(5,3) = xyz2(5,3) + xv(2,j)*sigmv(j)
        xyz2(6,3) = xyz2(6,3) + xv(2,j)*xyz_particle(6)
        
        xyz2(4,4) = xyz2(4,4) + yv(2,j)*yv(2,j)
        xyz2(5,4) = xyz2(5,4) + yv(2,j)*sigmv(j)
        xyz2(6,4) = xyz2(6,4) + yv(2,j)*xyz_particle(6)
        
        xyz2(5,5) = xyz2(5,5) + sigmv(j)*sigmv(j)
        xyz2(6,5) = xyz2(6,5) + sigmv(j)*xyz_particle(6)
        
        xyz2(6,6) = xyz2(6,6) + xyz_particle(6)*xyz_particle(6)
      end do
    else if (fmt.eq.6) then ! Canonical
      do j=1,napx
        xyz_particle(1) = xv(1,j)*c1m3                 !x:      [mm]   -> [m]
        xyz_particle(2) = (yv(1,j)*c1m3)*(one+dpsv(j)) !px:     [mrad] -> [1]
        xyz_particle(3) = xv(2,j)*c1m3                 !y:      [mm]   -> [m]
        xyz_particle(4) = (yv(2,j)*c1m3)*(one+dpsv(j)) !py:     [mrad] -> [1]
        xyz_particle(5) = sigmv(j)*c1m3                !sigma:  [mm]   -> [m]
        xyz_particle(6) = (((ejv(j)-e0)*e0)/e0f)/e0f   !psigma: [MeV]  -> [1]
        
        ! Average beam position
        xyz(1) = xyz(1) + xyz_particle(1)
        xyz(2) = xyz(2) + xyz_particle(2)
        xyz(3) = xyz(3) + xyz_particle(3)
        xyz(4) = xyz(4) + xyz_particle(4)
        xyz(5) = xyz(5) + xyz_particle(5)
        xyz(6) = xyz(6) + xyz_particle(6)
        
        ! Beam matrix (don't calulate identical elements twice (symmetry))
        xyz2(1,1) = xyz2(1,1) + xyz_particle(1)*xyz_particle(1)
        xyz2(2,1) = xyz2(2,1) + xyz_particle(1)*xyz_particle(2)
        xyz2(3,1) = xyz2(3,1) + xyz_particle(1)*xyz_particle(3)
        xyz2(4,1) = xyz2(4,1) + xyz_particle(1)*xyz_particle(4)
        xyz2(5,1) = xyz2(5,1) + xyz_particle(1)*xyz_particle(5)
        xyz2(6,1) = xyz2(6,1) + xyz_particle(1)*xyz_particle(6)
        
        xyz2(2,2) = xyz2(2,2) + xyz_particle(2)*xyz_particle(2)
        xyz2(3,2) = xyz2(3,2) + xyz_particle(2)*xyz_particle(3)
        xyz2(4,2) = xyz2(4,2) + xyz_particle(2)*xyz_particle(4)
        xyz2(5,2) = xyz2(5,2) + xyz_particle(2)*xyz_particle(5)
        xyz2(6,2) = xyz2(6,2) + xyz_particle(2)*xyz_particle(6)
        
        xyz2(3,3) = xyz2(3,3) + xyz_particle(3)*xyz_particle(3)
        xyz2(4,3) = xyz2(4,3) + xyz_particle(3)*xyz_particle(4)
        xyz2(5,3) = xyz2(5,3) + xyz_particle(3)*xyz_particle(5)
        xyz2(6,3) = xyz2(6,3) + xyz_particle(3)*xyz_particle(6)
        
        xyz2(4,4) = xyz2(4,4) + xyz_particle(4)*xyz_particle(4)
        xyz2(5,4) = xyz2(5,4) + xyz_particle(4)*xyz_particle(5)
        xyz2(6,4) = xyz2(6,4) + xyz_particle(4)*xyz_particle(6)
        
        xyz2(5,5) = xyz2(5,5) + xyz_particle(5)*xyz_particle(5)
        xyz2(6,5) = xyz2(6,5) + xyz_particle(5)*xyz_particle(6)
        
        xyz2(6,6) = xyz2(6,6) + xyz_particle(6)*xyz_particle(6)
      end do
    end if
    
    ! Normalize to get averages
    xyz = xyz/napx
    
    xyz2(:,1)  = xyz2(:,1) /napx
    xyz2(2:,2) = xyz2(2:,2)/napx
    xyz2(3:,3) = xyz2(3:,3)/napx
    xyz2(4:,4) = xyz2(4:,4)/napx
    xyz2(5:,5) = xyz2(5:,5)/napx
    xyz2(6,6)  = xyz2(6,6) /napx
    
    if (lhighprec) then
      write(unit,1991) napx, nturn, localDcum, xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6), &
        xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),&
                  xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),&
                            xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),&
                                      xyz2(4,4),xyz2(5,4),xyz2(6,4),&
                                                xyz2(5,5),xyz2(6,5),&
                                                          xyz2(6,6)
    else
      write(unit,1992) napx, nturn, localDcum, xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6), &
        xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),&
                  xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),&
                            xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),&
                                      xyz2(4,4),xyz2(5,4),xyz2(6,4),&
                                                xyz2(5,5),xyz2(6,5),&
                                                          xyz2(6,6)
    end if
    
    ! Flush
    endfile (unit,iostat=ierro)
    backspace (unit,iostat=ierro)
+if cr
    dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+1
+ei
  ! fmt 7 same as fmt 2,   but in normalized coordinates
  ! fmt 8 same as fmt 3,   but in normalized coordinates
  ! fmt 9 same as fmt 5/6, but in normalized coordinates
  else if (fmt .eq. 7 .or. fmt .eq. 8 .or. fmt .eq. 9) then
    if (i.eq.0 .and. ix.eq.0) then
      localDcum = zero
      localKtrack = 0
    else
      localDcum = dcum(i)
      localKtrack = ktrack(i)
    end if
    
    ! initialize parameters for writing of beam moments
    do l=1,6
      xyz(l) = zero
      do k=1,6
        xyz2(l,k) = zero
      end do
    end do
    
    ! normalize particle coordinates
    do j=1,napx
      xyz_particle(1) = xv(1,j)
      xyz_particle(2) = yv(1,j)
      xyz_particle(3) = xv(2,j)
      xyz_particle(4) = yv(2,j)
      xyz_particle(5) = sigmv(j)
      xyz_particle(6) = (ejv(j)-e0)/e0
      ! Remove closed orbit -> check units used in dumpclo (is x' or px used?)
      do m=1,6
        xyz_particle(m)=xyz_particle(m)-loc_clo(m)
      end do
      ! Convert to canonical variables
      xyz_particle(2)=xyz_particle(2)*((one+xyz_particle(6))+loc_clo(6))
      xyz_particle(4)=xyz_particle(4)*((one+xyz_particle(6))+loc_clo(6))
      ! Normalize nxyz=fma_tas_inv*xyz
      ! Initialize nxyz
      do m=1,6
        nxyz_particle(m)=zero
      end do
      do m=1,6
        do n=1,6
          nxyz_particle(m)=nxyz_particle(m)+tasinv(m,n)*xyz_particle(n)
        end do
        ! a) convert nxyzv(6) to 1.e-3 sqrt(m)
        ! unit: nx,npx,ny,npy,nsig,ndelta all in [1.e-3 sqrt(m)]
        if (m.eq.6) then
          nxyz_particle(m)=nxyz_particle(m)*c1e3
        end if
      end do
      
      if (fmt .eq. 7) then
        if (lhighprec) then
          write(unit,1985) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum, &
            nxyz_particle(1),nxyz_particle(2),nxyz_particle(3),nxyz_particle(4),nxyz_particle(5),nxyz_particle(6),localKtrack
        else
          write(unit,1986) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum, &
            nxyz_particle(1),nxyz_particle(2),nxyz_particle(3),nxyz_particle(4),nxyz_particle(5),nxyz_particle(6),localKtrack
        end if
        
      else if (fmt .eq. 8) then
        write(unit) nlostp(j)+(samplenumber-1)*npart,nturn,localDcum, &
          nxyz_particle(1),nxyz_particle(2),nxyz_particle(3),nxyz_particle(4),nxyz_particle(5),nxyz_particle(6),localKtrack
      
      else if (fmt .eq. 9) then
        ! Average beam position
        ! here we recycle xyz used also for fmt 5 and 6. These are
        ! all normalized coordinates in units
        ! nx,npx,ny,npy,nsig,ndelta [1.e-3 sqrt(m)]
        xyz(1) = xyz(1) + nxyz_particle(1)
        xyz(2) = xyz(2) + nxyz_particle(2)
        xyz(3) = xyz(3) + nxyz_particle(3)
        xyz(4) = xyz(4) + nxyz_particle(4)
        xyz(5) = xyz(5) + nxyz_particle(5)
        xyz(6) = xyz(6) + nxyz_particle(6)
        
        ! Beam matrix (don't calulate identical elements twice (symmetry))
        xyz2(1,1) = xyz2(1,1) + nxyz_particle(1)*nxyz_particle(1)
        xyz2(2,1) = xyz2(2,1) + nxyz_particle(1)*nxyz_particle(2)
        xyz2(3,1) = xyz2(3,1) + nxyz_particle(1)*nxyz_particle(3)
        xyz2(4,1) = xyz2(4,1) + nxyz_particle(1)*nxyz_particle(4)
        xyz2(5,1) = xyz2(5,1) + nxyz_particle(1)*nxyz_particle(5)
        xyz2(6,1) = xyz2(6,1) + nxyz_particle(1)*nxyz_particle(6)
        
        xyz2(2,2) = xyz2(2,2) + nxyz_particle(2)*nxyz_particle(2)
        xyz2(3,2) = xyz2(3,2) + nxyz_particle(2)*nxyz_particle(3)
        xyz2(4,2) = xyz2(4,2) + nxyz_particle(2)*nxyz_particle(4)
        xyz2(5,2) = xyz2(5,2) + nxyz_particle(2)*nxyz_particle(5)
        xyz2(6,2) = xyz2(6,2) + nxyz_particle(2)*nxyz_particle(6)
        
        xyz2(3,3) = xyz2(3,3) + nxyz_particle(3)*nxyz_particle(3)
        xyz2(4,3) = xyz2(4,3) + nxyz_particle(3)*nxyz_particle(4)
        xyz2(5,3) = xyz2(5,3) + nxyz_particle(3)*nxyz_particle(5)
        xyz2(6,3) = xyz2(6,3) + nxyz_particle(3)*nxyz_particle(6)
        
        xyz2(4,4) = xyz2(4,4) + nxyz_particle(4)*nxyz_particle(4)
        xyz2(5,4) = xyz2(5,4) + nxyz_particle(4)*nxyz_particle(5)
        xyz2(6,4) = xyz2(6,4) + nxyz_particle(4)*nxyz_particle(6)
        
        xyz2(5,5) = xyz2(5,5) + nxyz_particle(5)*nxyz_particle(5)
        xyz2(6,5) = xyz2(6,5) + nxyz_particle(5)*nxyz_particle(6)
        
        xyz2(6,6) = xyz2(6,6) + nxyz_particle(6)*nxyz_particle(6)
      end if
    end do ! END loop over particles (j)
    
    if (fmt .eq. 7) then
      ! Flush
      endfile (unit,iostat=ierro)
      backspace (unit,iostat=ierro)
+if cr
      dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
    else if (fmt .eq. 8) then
      ! Flush
      endfile (unit,iostat=ierro)
      backspace (unit,iostat=ierro)
+if cr
      dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
    else if (fmt .eq. 9) then
      ! Normalize to get averages
      xyz = xyz/napx
      
      xyz2(:,1)  = xyz2(:,1) /napx
      xyz2(2:,2) = xyz2(2:,2)/napx
      xyz2(3:,3) = xyz2(3:,3)/napx
      xyz2(4:,4) = xyz2(4:,4)/napx
      xyz2(5:,5) = xyz2(5:,5)/napx
      xyz2(6,6)  = xyz2(6,6) /napx
      
      if (lhighprec) then
        write(unit,1991) napx,nturn,localDcum,xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6), &
          xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),&
                    xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),&
                              xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),&
                                        xyz2(4,4),xyz2(5,4),xyz2(6,4),&
                                                  xyz2(5,5),xyz2(6,5),&
                                                            xyz2(6,6)
      else
        write(unit,1992) napx,nturn,localDcum,xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6), &
          xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),&
                    xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),&
                              xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),&
                                        xyz2(4,4),xyz2(5,4),xyz2(6,4),&
                                                  xyz2(5,5),xyz2(6,5),&
                                                            xyz2(6,6)
      end if
      
      ! Flush
      endfile (unit,iostat=ierro)
      backspace (unit,iostat=ierro)
+if cr
      dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+1
+ei
    end if
    
  ! Unrecognized format fmt
  else
    write (lout,*) "DUMP> Format",fmt, "not understood for unit", unit
    call prror(-1)
  end if
    
  return

1981 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE25.18)) !fmt 0 / hiprec
1982 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE16.9))  !fmt 0 / not hiprec

1983 format (2(1x,I8),1X,F12.5,5(1X,1PE25.18),1X,I8)  !fmt 1 / hiprec
1984 format (2(1x,I8),1X,F12.5,5(1X,1PE16.9),1X,I8)   !fmt 1 / not hiprec

1985 format (2(1x,I8),1X,F12.5,6(1X,1PE25.18),1X,I8)  !fmt 2&7 / hiprec
1986 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9),1X,I8)   !fmt 2&7 / not hiprec

1989 format (2(1x,I8),1X,F12.5,6(1X,1PE25.18))        !fmt 4 / hiprec
1990 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9))         !fmt 4 / not hiprec

1991 format (2(1x,I8),1X,F12.5,27(1X,1PE25.18))       !fmt 5&6 / hiprec
1992 format (2(1x,I8),1X,F12.5,27(1X,1PE16.9))        !fmt 5&6 / not hiprec
  
end subroutine dump_beam_population

! ================================================================================================================================ !
subroutine dump_comnul
  
  implicit none
  
  integer i1,i2,i3,i
  
  ldumphighprec = .false.
  ldumpfront    = .false.
  
  do i1=-1,nblz
    do i2=1,6
      dumpclo(i1,i2)=0
      do i3=1,6
        dumptas(i1,i2,i3)=0
      end do
    end do
  end do
  
  do i=-1,nele
    ldump(i)    = .false.
    ndumpt(i)   = 0
    dumpfirst(i) = 0
    dumplast(i)  = 0
    dumpunit(i) = 0
    dumpfmt(i)  = 0
+if cr
    dumpfilepos(i) = -1
+ei
  end do
  
end subroutine dump_comnul

! ================================================================================================================================ !
!  Begin Checkpoint Restart
! ================================================================================================================================ !
+if cr

! ================================================================================================================================ !
subroutine dump_crcheck_readdata(fileunit, readerr)
  
  implicit none
  
  integer, intent(in) :: fileunit
  logical, intent(out) :: readerr
  
  integer j
  
  read(fileunit,err=100,end=100) (dumpfilepos_cr(j),j=-1,nele)
  
  readerr = .false.
  return
  
100 continue
  readerr = .true.
  
end subroutine dump_crcheck_readdata

! ================================================================================================================================ !
subroutine dump_crcheck_positionFiles
  
  use crcoall
  use string_tools
  use mod_common
  
  implicit none
  
+ca crco ! arecord
  
  ! For skipping through binary DUMP files (format 3&8)
  integer tmp_ID, tmp_nturn, tmp_ktrack
  real(kind=fPrec) tmp_dcum, tmp_x,tmp_xp,tmp_y,tmp_yp,tmp_sigma,tmp_dEE
  
  integer i,j
  logical lerror,lopen
  character(len=256) filename
  
  do i=-1, il
    if (ldump(i)) then
      write(93,*) "SIXTRACR CRCHECK REPOSITIONING DUMP file"
      if (i .gt. 0) then
        write(93,*) "element=",bez(i), "unit=",dumpunit(i)," filename='"//trim(stringzerotrim(dump_fname(i)))// &
                    "' format=",dumpfmt(i)
      else if (i.eq.0) then
        write(93,*) "element=","ALL" , "unit=",dumpunit(i)," filename='"//trim(stringzerotrim(dump_fname(i)))// &
                    "' format=",dumpfmt(i)
      else if(i .eq. -1) then
        write(93,*) "element=","StartDump" , "unit=",dumpunit(i)," filename='"//trim(stringzerotrim(dump_fname(i)))// &
                    "' format=",dumpfmt(i)
      else
        write(93,*) "Error - index=",i,"is unknown"
        goto 111
      end if
      flush(93)
      
      inquire( unit=dumpunit(i), opened=lopen )
      if (dumpfmt(i).ne.3 .and. dumpfmt(i).ne.8) then ! ASCII
        if (.not. lopen) then
+if boinc
          call boincrf(dump_fname(i),filename)
          open(dumpunit(i),file=filename, status='old',form='formatted',action='readwrite')
+ei
+if .not.boinc
          open(dumpunit(i),file=dump_fname(i), status='old',form='formatted',action='readwrite')
+ei
        end if
        
        dumpfilepos(i) = 0
        do j=1,dumpfilepos_cr(i)
702       read(dumpunit(i),'(a1024)',end=111,err=111,iostat=ierro) arecord
          dumpfilepos(i) = dumpfilepos(i) + 1
        end do
        
      else                         ! BINARY (format = 3 & 8)
        if (.not. lopen) then
+if boinc
          call boincrf(dump_fname(i),filename)
          open(dumpunit(i),file=filename,status='old',form='unformatted',action='readwrite')
+ei
+if .not.boinc
          open(dumpunit(i),file=dump_fname(i),status='old',form='unformatted',action='readwrite')
+ei
        end if
        dumpfilepos(i) = 0
        do j=1,dumpfilepos_cr(i)
703       read(dumpunit(i),end=111,err=111,iostat=ierro) & 
            tmp_ID,tmp_nturn,tmp_dcum,tmp_x,tmp_xp,tmp_y,tmp_yp,tmp_sigma,tmp_dEE,tmp_ktrack
          dumpfilepos(i) = dumpfilepos(i) + 1
        end do
      end if
    end if
  end do
  
  ! Crop DUMP files (if used by multiple DUMPs,
  ! the actual position is the sum of the dumpfileposes
  do i=0,il
    if (ldump(i)) then
      ! This is not a FLUSH!
      endfile (dumpunit(i),iostat=ierro)
      
      ! Change from 'readwrite' to 'write'
      close(dumpunit(i))
      if (dumpfmt(i).ne.3 .and. dumpfmt(i).ne.8) then ! ASCII
+if boinc
        call boincrf(dump_fname(i),filename)
        open(dumpunit(i),file=filename, status='old',position='append',form='formatted',action='write')
+ei
+if .not.boinc
        open(dumpunit(i),file=dump_fname(i), status='old',position='append',form='formatted',action='write')
+ei
      else ! Binary (format = 3)
+if boinc
        call boincrf(dump_fname(i),filename)
        open(dumpunit(i),file=filename, status='old',position='append',form='unformatted',action='write')
+ei
+if .not.boinc
        open(dumpunit(i),file=dump_fname(i), status='old',position='append',form='unformatted',action='write')
+ei
      end if
    end if
  end do

  return
  
111 continue
  write(93,*) 'SIXTRACR DUMP_CRCHECK_POSITIONFILES *** ERROR *** reading DUMP file#', dumpunit(i),' iostat=',ierro
  write(93,*) 'dumpfilepos=',dumpfilepos(i),' dumpfilepos_cr=',dumpfilepos_cr(i)
  flush(93)
  write(lout,*)'SIXTRACR DUMP_CRCHECK_POSITIONFILES failure positioning DUMP file'
  call prror(-1)
  
end subroutine dump_crcheck_positionFiles

! ================================================================================================================================ !
subroutine dump_crpoint(fileunit,lerror,ierro)
  
  use parpro !nele
  implicit none
  
  integer, intent(in) :: fileunit
  logical, intent(out) :: lerror
  integer, intent(inout) :: ierro
  integer j
  
  write(95,err=100,iostat=ierro) (dumpfilepos(j),j=-1,nele)
  return
  
100 continue
  lerror = .true.
  return
  
end subroutine dump_crpoint
! ================================================================================================================================ !

+ei
! ================================================================================================================================ !
!  End Checkpoint Restart
! ================================================================================================================================ !
end module dump
