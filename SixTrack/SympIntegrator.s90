+dk ffsympintegrator
+if ffield
!! ---------------------------------------------------------------------------
!!      Subroutine for MAJ of the point (x,y,z,px,py,deltap1)
!! ---------------------------------------------------------------------------
subroutine SympIntegrator(x,px,y,py,zb,deltap1,n,m,s,dz,lx,ij_Ax,TAx,ly,ij_Ay,TAy,lz,ij_Az,TAz,inex)
   implicit none

   ! Definition of parameters
   ! -------------------------------------------------------------------------
   character(len=512) :: inex           ! Characterize if IN or OUT part of the Quad
   integer :: i                         ! Indice for loop in z
   integer :: n,m,s                     ! Expo. max for x and y, and Nb of step in z
   integer :: lx,ly,lz                  ! Number max of coefficient by step
   integer :: startp,endp,sens
   integer(kind=2) :: ij_Ax(0:1,0:lx,0:s),ij_Ay(0:1,0:ly,0:s),ij_Az(0:1,0:lz,0:s)
   double precision :: x, y, zb         ! Initial position x, y and curviligne z
   double precision :: px, py           ! Initial impulsion
   double precision :: dz               ! Step in z
   double precision :: valA             ! Coefficient of MAJ given by Horner subroutine
!   double precision :: g2d2inv
   double precision :: dzover2          ! Dsigma/2
   double precision :: deltap1          ! 1/(delta+1)
   double precision :: TAx(0:lx,0:s),TAy(0:ly,0:s),TAz(0:lz,0:s)! Coefficient of Vector Potential by step
   
   
   ! Initialise the step size in z
   ! -------------------------------------------------------------------------
   dzover2=0.5d0*dz !loc

   !                    ?????????????????????????????????
   ! -------------------------------------------------------------------------
!   g2d2inv=deltap1/gam0
!   g2d2inv=g2d2inv*g2d2inv*0.5d0
   
   
   ! Loop in z
   ! -------------------------------------------------------------------------
   startp = 0
   endp = s-1
!   endp = s
   sens = 1


   ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>> Inverse the reading of the table if OUT_O
   if (inex=="OUT_O") then
      startp = endp
      endp = 0
      sens = -1
      dz=-dz
      dzover2=-dzover2
   endif
   ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<< Inverse the reading of the table if OUT_O

   do i=startp,endp,sens
      !             * h1
!      zb=zb-dzover2*g2d2inv                                    ! ???????????

      !             * h2
      call HornerDX(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      px=px+dzover2*valA
      call HornerDY(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      py=py+dzover2*valA

      !             * h3
      !                 ** Change of variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px-valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py-valA

      x=x+dzover2*px*deltap1
 !     zb=zb-dzover2*0.5d0*px*px*deltap1*deltap1


      !                 ** Change of variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px+valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py+valA


      !             * h4
      !                 ** Change of variable
      call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      px=px-valA
      call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      py=py-valA

      y=y+dz*py*deltap1
      !zb=zb-dzover2*py*py*deltap1*deltap1


      !                 ** Change of variable
      call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      px=px+valA
      call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      py=py+valA


      !             * h3
      !                 ** Change of variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px-valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py-valA

      x=x+dzover2*px*deltap1
      !zb=zb-dzover2*0.5d0*px*px*deltap1*deltap1


      !                 ** Change of variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px+valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py+valA


      !             * h2
      call HornerDX(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      px=px+dzover2*valA
      call HornerDY(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      py=py+dzover2*valA

      !             * h1
!      zb=zb-dzover2*g2d2inv                                    ! ??????????
   enddo
end subroutine


!! ---------------------------------------------------------------------------
!!      Calcul de l'anti-Drift ou de l'anti-Quad suivant oper
!! ---------------------------------------------------------------------------
subroutine AntiDriftAntiQuad(x,px,y,py,K,Lff,Lin,Corx,Cory,CoK,oper,deltap1)
   implicit none

   ! Initialisation des parametres
   ! -------------------------------------------------------------------------
   character :: oper                  ! Operation to be executed ("AD" for anti-Drift, "AQ" for anti-Quad)
   double precision :: x, y           ! Initial position x, y
   double precision :: px, py         ! Initial momentum
   double precision :: x_tmp, y_tmp   ! Initial position x, y temporary
   double precision :: px_tmp, py_tmp ! Initial momentum temporary
   double precision :: K              ! Strength of the anti-Quad
   double precision :: Lff,Lin,Lin_tp ! Length in ConfigFringeField for the Quad
   double precision :: Corx, Cory, CoK!              and correctors
   double precision :: Corx_tp, Cory_tp!             and correctors
   double precision :: deltap1        ! 1/(delta+1)
   double precision :: a,b,c,d,bcmad  ! Parameter for the anti-Quad computation
   integer          :: NbDivQad=16, i  ! Number of Subdivision of the anti-Quad
   double precision :: DbNbDivQad

   if (oper=="D") then       ! [D(Lff-Lin)]^-1
      x_tmp = x - (Lff-Lin)*px*deltap1
      y_tmp = y - (Lff-Lin)*py*deltap1
      px_tmp = px
      py_tmp = py


   elseif (oper=="Q") then   ! [D(-Cor/2)*Q(KLin,Lin+Cor)*D(-Cor/2)]^-1
      DbNbDivQad = dble(NbDivQad)
      Lin_tp  = Lin /DbNbDivQad
      Corx_tp = Corx/DbNbDivQad
      Cory_tp = Cory/DbNbDivQad
      
      ! Focalisation in x
      a =  1.0d0 - (K - CoK)*(Lin_tp+Corx_tp)* Lin_tp         *0.5d0 *deltap1
      b = (1.0d0 - (K - CoK)*(Lin_tp+Corx_tp)*(Lin_tp-Corx_tp)*0.25d0*deltap1)*Lin_tp*deltap1
      c =        - (K - CoK)* Lin_tp
      d =  1.0d0 - (K - CoK)*(Lin_tp-Corx_tp)* Lin_tp         *0.5d0 *deltap1
      !bcmad = a*d - b*c
      
      do i = 1,NbDivQad 
        x_tmp  = (d*x -b*px)!/bcmad
        px_tmp = (a*px -c*x)!/bcmad
        
        x  =  x_tmp
        px = px_tmp
      enddo

      ! Defocalisation in y
      a =  1.0d0 + (K + CoK)*(Lin_tp+Cory_tp)* Lin_tp         *0.5d0 *deltap1
      b = (1.0d0 + (K + CoK)*(Lin_tp+Cory_tp)*(Lin_tp-Cory_tp)*0.25d0*deltap1)*Lin_tp*deltap1
      c =          (K + CoK)* Lin_tp
      d =  1.0d0 + (K + CoK)*(Lin_tp-Cory_tp)* Lin_tp         *0.5d0 *deltap1
      !bcmad = a*d-b*c

      do i = 1,NbDivQad 
         y_tmp  = (d*y -b*py)!/bcmad
         py_tmp = (a*py -c*y)!/bcmad
        
         y  =  y_tmp
         py = py_tmp
      enddo

   else
      x_tmp  = x
      y_tmp  = y
      px_tmp = px
      py_tmp = py


   endif
   x  =  x_tmp
   y  =  y_tmp
   px = px_tmp
   py = py_tmp
end subroutine


!! ---------------------------------------------------------------------------
!!     Generate Anti-Quad matrix for
!! ---------------------------------------------------------------------------
subroutine GenerateAntiQuad(deltap1,n,m,s,dz,lz,ij_Az,TAz,inex,a1,b1,c1,d1,a2,b2,c2,d2)
   
   implicit none

   ! Definition of parameters
   ! -------------------------------------------------------------------------
   character(len=512),intent(in) :: inex           ! Characterize if IN or OUT part of the Quad
   integer :: i,l                                  ! Indice for loop in z
   integer,intent(in) :: n,m,s                     ! Expo. max for x and y, and Nb of step in z
   integer,intent(in) :: lz                        ! Number max of coefficient by step
   integer :: startp,endp,sens
   integer(kind=2),intent(in) :: ij_Az(0:1,0:lz,0:s)
   double precision :: dz               ! Step in z
   double precision,intent(in) :: deltap1          ! 1/(delta+1)
   double precision,intent(in) :: TAz(0:lz,0:s)    ! Coefficient of Vector Potential by step
   
   double precision,intent(out) :: a1,b1,c1,d1,a2,b2,c2,d2
   
   double precision :: atp,btp,ctp,dtp,C0x,C0y,bcmad
   
   ! Initialisation of the parameter
   a1=1.0d0;   b1=0.0d0;   c1=0.0d0;   d1=1.0d0;
   a2=1.0d0;   b2=0.0d0;   c2=0.0d0;   d2=1.0d0;
   
   ! Loop in z
   ! -------------------------------------------------------------------------
   startp = 0
   endp = s-1
   sens = 1


   ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>> Inverse the reading of the table if OUT_O
   if (inex=="OUT_O") then
      startp = endp
      endp = 0
      sens = -1
      dz=-dz
   endif
   ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<< Inverse the reading of the table if OUT_O

   do i=startp,endp,sens
     C0x=0.0d0
     C0y=0.0d0
     
     do l=0,lz
       if ((ij_Az(0,l,i)==2).and.(ij_Az(1,l,i)==0)) then
         C0x=2.0d0*TAz(l,i)
       endif

       if ((ij_Az(0,l,i)==0).and.(ij_Az(1,l,i)==2)) then
         C0y=2.0d0*TAz(l,i)
       endif
     enddo

     
     ! Approx
!     atp= (1.0d0+deltap1*C0x*dz*dz*0.5d0)*a1 + ((1.0d0+deltap1*C0x*dz*dz*sixth)*deltap1*dz)*c1
!     btp= (1.0d0+deltap1*C0x*dz*dz*0.5d0)*b1 + ((1.0d0+deltap1*C0x*dz*dz*sixth)*deltap1*dz)*d1
!     ctp= (C0x*dz*(1.0d0+deltap1*C0x*dz*dz*sixth))*a1 + (1.0d0+deltap1*C0x*dz*dz*0.5d0)*c1
!     dtp= (C0x*dz*(1.0d0+deltap1*C0x*dz*dz*sixth))*b1 + (1.0d0+deltap1*C0x*dz*dz*0.5d0)*d1
     
     ! Thin
     atp= (1.0d0+deltap1*C0x*dz*dz*0.5d0)*a1 + ((1.0d0+deltap1*C0x*dz*dz*0.25d0)*deltap1*dz)*c1
     btp= (1.0d0+deltap1*C0x*dz*dz*0.5d0)*b1 + ((1.0d0+deltap1*C0x*dz*dz*0.25d0)*deltap1*dz)*d1
     ctp= (C0x*dz)*a1 + (1.0d0+deltap1*C0x*dz*dz*0.5d0)*c1
     dtp= (C0x*dz)*b1 + (1.0d0+deltap1*C0x*dz*dz*0.5d0)*d1
     a1=atp; b1=btp; c1=ctp; d1=dtp;
     
     
     ! Approx
!     atp= (1.0d0+deltap1*C0y*dz*dz*0.5d0)*a2 + ((1.0d0+deltap1*C0y*dz*dz*sixth)*deltap1*dz)*c2
!     btp= (1.0d0+deltap1*C0y*dz*dz*0.5d0)*b2 + ((1.0d0+deltap1*C0y*dz*dz*sixth)*deltap1*dz)*d2
!     ctp= (C0y*dz*(1.0d0+deltap1*C0y*dz*dz*sixth))*a2 + (1.0d0+deltap1*C0y*dz*dz*0.5d0)*c2
!     dtp= (C0y*dz*(1.0d0+deltap1*C0y*dz*dz*sixth))*b2 + (1.0d0+deltap1*C0y*dz*dz*0.5d0)*d2

     ! Thin
     atp= (1.0d0+deltap1*C0y*dz*dz*0.5d0)*a2 + ((1.0d0+deltap1*C0y*dz*dz*0.25d0)*deltap1*dz)*c2
     btp= (1.0d0+deltap1*C0y*dz*dz*0.5d0)*b2 + ((1.0d0+deltap1*C0y*dz*dz*0.25d0)*deltap1*dz)*d2
     ctp= (C0y*dz)*a2 + (1.0d0+deltap1*C0y*dz*dz*0.5d0)*c2
     dtp= (C0y*dz)*b2 + (1.0d0+deltap1*C0y*dz*dz*0.5d0)*d2
     a2=atp; b2=btp; c2=ctp; d2=dtp;
   enddo
   
   ! Inversion of the matrix
   bcmad=1.0d0/(a1*d1-b1*c1)
   atp=d1*bcmad;  btp=-b1*bcmad;  ctp=-c1*bcmad;  dtp=a1*bcmad;
   a1=atp; b1=btp; c1=ctp; d1=dtp;

   bcmad=1.0d0/(a2*d2-b2*c2)
   atp=d2*bcmad;  btp=-b2*bcmad;  ctp=-c2*bcmad;  dtp=a2*bcmad;
   a2=atp; b2=btp; c2=ctp; d2=dtp;
end subroutine


!! ---------------------------------------------------------------------------
!!     Compute Anti-Quad matrix for
!! ---------------------------------------------------------------------------
subroutine ComputeAntiQuad(x,px,y,py,a1,b1,c1,d1,a2,b2,c2,d2)
   implicit none

   ! Initialization of parameters
   ! -------------------------------------------------------------------------
   double precision,intent(inout) :: x, y           ! Initial position x, y
   double precision,intent(inout) :: px, py         ! Initial momentum 
   double precision,intent(out)   :: a1,b1,c1,d1,a2,b2,c2,d2
   
   double precision :: x_tmp, y_tmp   ! Initial position x, y temporary
   double precision :: px_tmp, py_tmp ! Initial momentum temporary
   
   x_tmp =a1*x + b1*px;   px_tmp=c1*x + d1*px;   x=x_tmp;   px=px_tmp;
   y_tmp =a2*y + b2*py;   py_tmp=c2*y + d2*py;   y=y_tmp;   py=py_tmp;
   
end subroutine
+ei
