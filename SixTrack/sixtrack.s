+cd version
      character*8 version  !Keep data type in sync with 'cr_version'
      character*10 moddate !Keep data type in sync with 'cr_moddate'
      integer itot,ttot
      data version /'4.6.22'/
      data moddate /'01.06.2017'/
+cd license
!!SixTrack
!!
!The code contains the SixTrack particle simulation code written by
!!F. Schmidt, DESY, CERN
!!E. Mcintosh, H. Ranshall, H. Grote, F. James,
!!K. Koelbig, K. Heinemann, M. Vaenttinen,
!!R. Assman, C. Bracco, R. Bruce, D. Mirarchi, V. Previtali,
!!S. Redaelli, G. Robert-Demolaize, E. Quaranta
!!A. Rossi, C. Tambasco, T. Weiler,
!!J. Barranco, Y. Sun, Y. Levinsen, M. Fjellstrom,
!!A. Santamaria, R. Kwee-Hinzmann, A. Mereghetti, K. Sjobak,
!!M. Fiascaris, J.F. Wagner, J. Wretborn, CERN
!!M. Fitterer, FNAL, CERN
!!A. Patapenka,  NIU, CERN
!!G. Robert-Demolaize, BNL
!!V. Gupta, Google Summer of Code (GSoC)
!!J. Molson (LAL)
!!
!!Copyright 2014 CERN. This software is distributed under the terms of the GNU
!!Lesser General Public License version 2.1, copied verbatim in the file
!!``COPYING''.
!!
!!In applying this licence, CERN does not waive the privileges and immunities
!!granted to it by virtue of its status as an Intergovernmental Organization or
!!submit itself to any jurisdiction.
+cd rhicelens
!GRDRHIC
      double precision tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz),totals,sampl(nblz)
      integer ielem
      integer namepart(npart)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy,sampl,namepart,totals
+if bnlelens
!GRDRHIC
!GRD-042008
      double precision twojx,twojy,twojr,sumtwojx,sumtwojy,             &
     &sumsquarex,sumsquarey,x_temp,xp_temp,y_temp,yp_temp
      double precision limit_twojx,limit_twojy,limit_twojr
      integer n_cut,n_nocut
      common /cumulsigma/ twojx,twojy,twojr,sumtwojx,sumtwojy,          &
     &sumsquarex,sumsquarey,x_temp,xp_temp,y_temp,yp_temp,n_cut,n_nocut,&
     &limit_twojx,limit_twojy,limit_twojr
      integer napx00
      parameter (napx00=64)
      integer   mynp
      common /mynp/ mynp
      double precision myx,myxp,myy,myyp,myp,mys
      common /coord/ myx(npart),myxp(npart),myy(npart),myyp(npart),     &
     &myp(npart),mys(npart)
      integer   samplenumber
      common /samplenumber/ samplenumber
!GRD-042008
!GRDRHIC
+ei
+cd bnlio
! This is empty if -crlibm and causes a problem with astuce
! if +crlibm we define parameters for dtostr
+if crlibm
      character*8192 ch
      character*25 ch1
      integer errno,l1,l2
      integer dtostr
+ei
+cd commtim
      real r1,timestart,timenow
      common /mytimes/timestart
+cd crco
      integer sixrecs,binrec,binrecs,bnlrec,bllrec,numlcr
      logical rerun,start,restart,checkp,fort95,fort96,read95,read96
      character*1024 arecord
      character*20 stxt
      character*80 runtim
! Note order of placement in COMMON crdata is important
! for the alignment of the data
      common /crdata/                                                   &
     &sixrecs,binrec,binrecs((npart+1)/2),bnlrec,bllrec,                &
     &numlcr,rerun,start,restart,checkp,                                &
     &fort95,fort96,read95,read96,arecord,stxt,runtim
      integer crnumlcr,crnuml,crnapxo,crnapx,crnumxv,crnnumxv,crnlostp, &
     &crsixrecs,crbinrec,crbinrecs,crbnlrec,crbllrec,cril
      logical crpstop,crsythck
      real crtime3
      double precision cre0,crxv,cryv,crsigmv,crdpsv,crdpsv1,crejv,     &
     &crejfv,craperv,crxvl,cryvl,crdpsvl,crejvl,crsigmvl

      character*8  cr_version !Keep data type in sync with 'version'
      character*10 cr_moddate !Keep data type in sync with 'moddate'
+if bnlelens
!GRDRHIC
!GRD-042008
      integer crnamepart,crn_nocut,crn_cut
      double precision crtotals,crsumtwojx,crsumtwojy,                  &
     &crsumsquarex,crsumsquarey,                                        &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr
!GRDRHIC
!GRD-042008
+ei
      common/crio/                                                      &
     &cre0,
     &crxv(2,npart),cryv(2,npart),                                      &
     &crsigmv(npart),crdpsv(npart),crdpsv1(npart),crejv(npart),         &
     &crejfv(npart),craperv(npart,2),crxvl(2,npart),cryvl(2,npart),     &
     &crdpsvl(npart),crejvl(npart),crsigmvl(npart),                     &
+if bnlelens
!GRDRHIC
!GRD-042008
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
!GRDRHIC
!GRD-042008
+ei
     &            crsixrecs,crbinrec,crbinrecs((npart+1)/2),crbnlrec,   &
     &crbllrec,cril,                                                    &
     &crnumlcr,crnuml,crsythck,                                         &
     &                crtime3,                                          &
     &crnapxo,crnapx,                                                   &
+if .not.bnlelens
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart)
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart),    &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crnamepart(npart)
!GRDRHIC
!GRD-042008
+ei

+cd parpro
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
+if .not.bignpart.and..not.hugenpart
      parameter(npart = 64,nmac = 1)
+ei
+if bignpart.and..not.hugenpart
!See also:
! - subroutine wzsubv
      parameter(npart = 2048,nmac = 1)
+ei
+if hugenpart.and..not.bignpart
!See also:
! - subroutine wzsubv
      parameter(npart = 65536,nmac = 1)
+ei

!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag" version:
! 6000/20000 -> 30% multipoles
+if .not.collimat
+if bignblz
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=200000,
     &nzfz = 3000000,mmul = 20) !up to 60'000 multipoles
+ei
+if hugenblz
      parameter(nele=1200,nblo=600,nper=16,nelb=280,nblz=400000,
     &nzfz = 6000000,mmul = 20) !up to 120'000 multipoles -> 48MB/nzfz-array (20%)
+ei
+if .not.bignblz.and..not.hugenblz
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
+ei
+ei ! / not collimat
+if collimat
+if beamgas
      parameter(nele=50000,nblo=10000,nper=16,nelb=140,nblz=200000,     &
     &nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / beamgas
+if .not.beamgas
+if bignblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=200000,        &
     &nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / bignblz
+if hugenblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=400000,        &
     &nzfz = 3840000,mmul = 11) !up to 120'000 multipoles (20%)
+ei ! / hugenblz
+if .not.bignblz.and..not.hugenblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=15000,         &
     &nzfz = 144000,mmul = 11) !up to 4500 multipoles
+ei ! / not bignblz
+ei ! / not beamgas
+ei ! / collimat

+if collimat
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
+ei
+if .not.collimat
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
+ei
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20)
+if .not.bignblz.and..not.hugenblz
      parameter(nbb = 350)
+ei
+if bignblz.or.hugenblz
      parameter(nbb = 500)
+ei
+cd parnum
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
+cd parbeam
      integer idim,kstep,nx,ny
      double precision h,half,hrecip,one,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77d0, ycut = 7.46d0 )
      parameter ( h = 1.d0/63.d0 )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      parameter ( half = 0.5d0, one = 1.d0 )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
+cd parbeam_exp
      integer beam_expflag      ! 0: Old BEAM block, 1: New BEAM::EXPERT
      common /beam_exp/ beam_expflag
+cd beamdim
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
+cd common
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,apx,apz,ape,bbcu,  &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,         &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
+if time
      double precision tcnst35,exterr35,zfz35
      integer icext35
+ei
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
+if time
      common/rand35/exterr35(nblz,40),icext35(nblz),zfz35(nzfz),        &
     &tcnst35(nblz)
+ei
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/apert/apx(nele),apz(nele),ape(3,nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,18),track6d(6,npart),    &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
! wire parameters for closed orbit calculation (FOX part)
! for FOX length of variable names must be smaller 8
      integer, parameter :: wire_max = 350 ! max. number of wires (same as BB interactions)
      double precision wire_clo            ! closed orbit at wire
      double precision wireclo0         ! initial coordinates for closed orbit
      integer wire_num_aux              ! auxiliary variable to count number of wires
      integer wire_num                  ! wire number for each structure element (default = 0 if no wire)
      common/wireco/ wire_clo(6,wire_max),wire_num(nblz)
+cd commons
      integer idz,itra
+if vvector
+if .not.datamods
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
+ei
+if datamods
      double precision chi0,chid,dp1,dps,exz,sigm
      common/syos/sigm(mpa),dps(mpa),idz(2)
+ei
      common/anf/chi0,chid,exz(2,6),dp1,itra
+ei
+if .not.vvector
      double precision a2,al,as,at,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,2,nele),at(6,2,2,nele),a2(6,2,2,nele),         &
     &al(6,2,2,nele),sigm(mpa),dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
+ei
+cd commont1
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
+cd commont2
      integer ichrom,issss
      double precision alf0,amp,bet0,clo,clop,cro,xxtr,yytr
      common/tra/xxtr(mpa,2),yytr(mpa,2),amp(2),                        &
     &bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),issss(2),ichrom
+cd common1
      integer iav,iconv,icow,icr,idis,iffw,ifh,imad,ipos,ires,iskip,    &
     &istw,itf,ivox,ivoz,iwg,kwtype,ndafi,nprint,nstart,nstop
      double precision cma1,cma2,dfft,dphix,dphiz,dres,qx0,qz0
      real hmal
      character*80 toptit,sixtit,commen
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/pawc/hmal(nplo)
+cd common2
      integer nnumxv
      common/postr2/nnumxv(npart)
+cd commonl
      double precision aml6,edcor
      common/sixdim/aml6(6,6),edcor(2)
+cd commonxz
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
+cd commonta
      double precision tasm
      common/tasm/tasm(6,6)
+cd commond1
      common/daele/alda,asda,aldaq,asdaq,smida,xx,yy,dpda,dpda1,sigmda, &
     &ej1,ejf1,rv
+cd commd1da
      integer alda_da,asda_da,aldaq_da,asdaq_da,smida_da,xx_da,         &
     &yy_da,dpda_da,dpda1_da,sigmda_da,ej1_da,ejf1_da,rv_da
      common/daele/alda_da(2,6),asda_da(2,6),aldaq_da(2,6),             &
     &asdaq_da(2,6),smida_da(mcor),xx_da(2),yy_da(2),dpda_da,dpda1_da,  &
     &sigmda_da,ej1_da,ejf1_da,rv_da
+cd commond2
      double precision ald6,asd6
      common/dael6/ald6(nele,2,6,nema),asd6(nele,2,6,nema)
+cd commonas
      integer idao,iscrri
      integer          iscrda
      double precision rscrri
      common/dascr/iscrda(100),rscrri(100),iscrri(100),idao
+cd commondl
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
+cd commadha
      integer iamp
      real x
      double precision ham,hama,hamp
      common/hamil1/ham(0:3),x(10)
      common/hamil2/hama(0:4),hamp(0:1),iamp
+cd commadh1
      integer jeltot,maxa,maxp
      double precision hda
      common/ad1/hda(0:3,3,0:3,0:4000),jeltot,maxa,maxp
+cd commadh2
      integer jeltot,nordp,nordm,norda
      double precision hda,hdp
      common/ad2/hda(0:4,5,0:8000),hdp(0:1,5,0:8000),jeltot,nordp,nordm,&
     &norda
+cd commonds
      integer icode,idam,its6d
      double precision dpscor,sigcor
      common/corcom/dpscor,sigcor,icode,idam,its6d
+cd commonmn
+if time
      double precision aaiv35,bbiv35
      common/timemain/aaiv35(mmul,nmac,nblz),bbiv35(mmul,nmac,nblz)
+ei
      integer iv,ixv,nlostp,nms,numxv
+if .not.datamods
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
+ei
+if datamods
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam,      &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,eps,epsa,fake,fi,fok,fok1,fokqv,     &
     &g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,     &
+ei
+if rvet
     &rvet,                                                             &
+ei
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
+if .not.datamods
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
+ei
+if datamods
     &fokqv(npart),aaiv(mmul,nmac,nblz),                                &
+ei
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
+if rvet
     &rvet(npart),                                                      &
+ei
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
+if .not.datamods
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
+ei
+if datamods
      common/main3/ clo6v(3,npart),clop6v(3,npart),                     &
     &tas(npart,6,6),qwcs(npart,3),di0xs(npart),                        &
+ei
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
+cd commonm1
      integer numx
      double precision e0f
+if cr
      logical sythckcr
      common/main4/ e0f,numx,sythckcr
+ei
+if .not.cr
      common/main4/ e0f,numx
+ei
+cd commontr
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
+cd commonc
      integer ichromc,ilinc,iqmodc
      double precision clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
+cd commonex
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
+cd exactvars
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
      double precision pz
+cd ex4Ddrift
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
            enddo
+cd ex6Ddrift
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              sigmv(j)=sigmv(j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              sigmv(j)=sigmv(j)+stracki*(one-(rvv(j)/pz))
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
              sigmv(j)=sigmv(j)*c1e3
            enddo
+cd exDAdrift
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
*FOX  X(1)=X(1)*C1M3 ;
*FOX  X(2)=X(2)*C1M3 ;
*FOX  Y(1)=Y(1)*C1M3 ;
*FOX  Y(2)=Y(2)*C1M3 ;
*FOX  SIGMDA=SIGMDA*C1M3 ;
*FOX  PZ=SQRT(ONE-Y(1)*Y(1)-Y(2)*Y(2)) ;
*FOX  X(1)=X(1)+EL(JX)*(Y(1)/PZ) ;
*FOX  X(2)=X(2)+EL(JX)*(Y(2)/PZ) ;
*FOX  SIGMDA=SIGMDA+(ONE-(RV/PZ))*EL(JX) ;
*FOX  X(1)=X(1)*C1E3 ;
*FOX  X(2)=X(2)*C1E3 ;
*FOX  Y(1)=Y(1)*C1E3 ;
*FOX  Y(2)=Y(2)*C1E3 ;
*FOX  SIGMDA=SIGMDA*C1E3 ;
!-----------------------------------------------------------------------
+cd commphin
      common/phasecom/ phase(3,npos+1)
      common/invari/ dani(ninv+1)
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!-----                                                                   -----
!-----    NEW BLOCKS PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----        G. ROBERT-DEMOLAIZE, October 27th, 2004                    -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
+cd collpara
      integer max_ncoll,maxn,numeff,numeffdpop,outlun,nc
      parameter (max_ncoll=100,nc=32,numeff=32,maxn=20000,              &
     &numeffdpop=29,outlun=54)
+cd database
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap

!SEPT2005 for slicing process
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr

      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap,
     &xbeat,xbeatphase,ybeat,ybeatphase,
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength

      character*24 name_sel
      character*80 coll_db
      character*16 castordir
      character*80 filename_dis

      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
     &emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap,
     &xbeat,xbeatphase,ybeat,ybeatphase,
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbtrthin

      integer   mynp
      common /mynp/ mynp

!++ Vectors of coordinates

      double precision mygammax,mygammay
!
      real rndm4
!
      character*80 dummy
!
      ! IN "+CD DBTRTHIN" and "+CD DBDATEN"
!      double precision remitx_dist,remity_dist,
!     &     remitx_collgap,remity_collgap
!      common  /remit/ remitx_dist, remity_dist,
!     &     remitx_collgap,remity_collgap
!

      double precision ielem,iclr,grd
      character*160 ch
      character*320 ch1
      logical flag
!
      integer k,np0
      integer   mclock_liar
!
      character*160 cmd
      character*160 cmd2
      character*1 ch0
      character*2 ch00
      character*3 ch000
      character*4 ch0000
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbdaten

      ! IN "+CD DBTRTHIN", "+CD DBDATEN" and "+CD DBTHIN6D"
!      logical cut_input
!      common /cut/ cut_input

      ! IN "+CD DBTRTHIN" and "+CD DBDATEN"
      double precision remitx_dist,remity_dist,
     &     remitx_collgap,remity_collgap
      common  /remit/ remitx_dist, remity_dist,
     &     remitx_collgap,remity_collgap
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dblinopt
!
! THIS BLOCK IS COMMON TO WRITELIN,LINOPT,TRAUTHIN,THIN6D AND MAINCR
!
      double precision tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Variables for finding the collimator with the smallest gap
! and defining, stroring the gap rms error
!
      character*16 coll_mingap1, coll_mingap2
      double precision gap_rms_error(max_ncoll), nsig_err, sig_offset
      double precision mingap,gap_h1,gap_h2,gap_h3,gap_h4
      integer coll_mingap_id

      common /gap_err/ gap_rms_error
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+cd dbthin6d
!
      integer ios,num_surhit,numbin,ibin,                               &
     &num_selabs,iturn_last_hit,iturn_absorbed,iturn_survive,imov,      &
     &ipart(npart),totalelem,selelem,unitnumber,distnumber,turnnumber,  &
     &jb,                                                               &
!MAY2005
     &flukaname(npart)
!MAY2005
!     SR, 29-08-2005: add the required variable for slicing collimators
      integer jjj, ijk
!
      double precision  ran_gauss, myran_gauss
      real rndm5,zbv
!
      double precision c_length    !length in m
      double precision c_rotation  !rotation angle vs vertical in radian
      double precision c_aperture  !aperture in m
      double precision c_offset    !offset in m
      double precision c_tilt(2)   !tilt in radian
      double precision cx(npart),cxp(npart),cy(npart),cyp(npart),       &
     &cp(npart),cs(npart),rcx(npart),rcxp(npart),rcy(npart),rcyp(npart),&
     &rcp(npart),rcs(npart),rcx0(npart),rcxp0(npart),rcy0(npart),       &
     &rcyp0(npart),rcp0(npart),enom_gev,betax,betay,xmax,ymax,          &
     &nsig,calc_aperture,gammax,gammay,gammax0,gammay0,gammax1,gammay1, &
     &xj,xpj,yj,ypj,pj,arcdx,arcbetax,xdisp,rxjco,ryjco,                &
     &rxpjco,rypjco,c_rmstilt,                                          &
     &c_systilt,scale_bx,scale_by,scale_bx0,scale_by0,xkick,            &
     &ykick,bx_dist,by_dist,xmax_pencil,ymax_pencil,xmax_nom,ymax_nom,  &
     &nom_aperture,pencil_aperture,xp_pencil(max_ncoll),                &
     &yp_pencil(max_ncoll),x_pencil0,y_pencil0,sum,sqsum,               &
     &csum(max_ncoll),csqsum(max_ncoll),average,sigma,sigsecut,nspxd,   &
     &xndisp,xgrd(npart),xpgrd(npart),ygrd(npart),ypgrd(npart),zpj,     &
     &pgrd(npart),ejfvgrd(npart),sigmvgrd(npart),rvvgrd(npart),         &
     &dpsvgrd(npart),oidpsvgrd(npart),dpsv1grd(npart),                  &
     &dnormx,dnormy,driftx,drifty,                                      &
     &xnorm,xpnorm,xangle,ynorm,ypnorm,yangle,                          &
     &grdpiover2,grdpiover4,grd3piover4

!SEPT2005-SR, 29-08-2005 --- add parameter for the array length ---- TW
      double precision x_sl(100),x1_sl(100),x2_sl(100),                 &
     &     y1_sl(100), y2_sl(100),                                      &
     &     angle1(100), angle2(100),                                    &
     &     max_tmp,                                                     &
     &     a_tmp1, a_tmp2, ldrift, mynex2, myney2, 
     &     Nap1pos,Nap2pos,Nap1neg,Nap2neg,
     &     tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2,
     &     beamsize1, beamsize2,betax1,betax2,betay1,betay2,
     &     alphax1, alphax2,alphay1,alphay2,minAmpl
!SEPT2005

      character*4 c_material     !material

      common /dbthinc/ cx,cxp,cy,cyp,                                   &
     &cp,cs,rcx,rcxp,rcy,rcyp,                                          &
     &rcp,rcs,rcx0,rcxp0,rcy0,                                          &
     &rcyp0,rcp0,enom_gev,betax,betay,xmax,ymax,                        &
     &nsig,calc_aperture,gammax,gammay,gammax0,gammay0,gammax1,gammay1, &
     &xj,xpj,yj,ypj,pj,arcdx,arcbetax,xdisp,rxjco,ryjco,                &
     &rxpjco,rypjco,c_rmstilt,                                          &
     &c_systilt,scale_bx,scale_by,scale_bx0,scale_by0,xkick,            &
     &ykick,bx_dist,by_dist,xmax_pencil,ymax_pencil,xmax_nom,ymax_nom,  &
     &nom_aperture,pencil_aperture,xp_pencil,                           &
     &yp_pencil,x_pencil0,y_pencil0,sum,sqsum,                          &
     &csum,csqsum,average,sigma,sigsecut,nspxd,                         &
     &xndisp,xgrd,xpgrd,ygrd,ypgrd,zpj,                                 &
     &pgrd,ejfvgrd,sigmvgrd,rvvgrd,                                     &
     &dpsvgrd,oidpsvgrd,dpsv1grd,                                       &
     &dnormx,dnormy,driftx,drifty,                                      &
     &xnorm,xpnorm,xangle,ynorm,ypnorm,yangle,                          &
     &grdpiover2,grdpiover4,grd3piover4,                                &
     &x_sl,x1_sl,x2_sl,                                                 &
     &     y1_sl, y2_sl,                                                &
     &     angle1, angle2,                                              &
     &     max_tmp,                                                     &
     &     a_tmp1, a_tmp2, ldrift, mynex2, myney2, 
     &     Nap1pos,Nap2pos,Nap1neg,Nap2neg,
     &     tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2,
     &     beamsize1, beamsize2,betax1,betax2,betay1,betay2,
     &     alphax1, alphax2,alphay1,alphay2,minAmpl,
     &ios,num_surhit,numbin,ibin,                                       &
     &num_selabs,iturn_last_hit,iturn_absorbed,iturn_survive,imov,      &
     &ipart,totalelem,selelem,unitnumber,distnumber,turnnumber,         &
     &jb,flukaname,                                                     &
     &jjj,ijk,zbv,ran_gauss,c_length,c_rotation,                        &
     &c_aperture,c_offset,c_tilt,c_material

! myran_gauss,rndm5,

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbcolcom
      logical firstcoll,found,onesided
      integer rnd_lux,rnd_k1,rnd_k2

      integer myix,myktrack

      double precision nspx,nspy,mux0,muy0
      double precision ax0,ay0,bx0,by0
      double precision totals

      ! IN "+CD DBTRTHIN", "+CD DBDATEN" and "+CD DBTHIN6D"
      logical cut_input
      common /cut/ cut_input

      double precision xbob(nblz),ybob(nblz),xpbob(nblz),ypbob(nblz),   &
     &xineff(npart),yineff(npart),xpineff(npart),ypineff(npart)

      common /xcheck/ xbob,ybob,xpbob,ypbob,xineff,yineff,xpineff,      &
     &ypineff
      double precision mux(nblz),muy(nblz)
      common /mu/ mux,muy

      common /collocal/ myix,myktrack,totals,firstcoll,found,onesided

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+cd dbcommon
!
! THIS BLOCK IS COMMON TO BOTH THIN6D AND TRAUTHIN SUBROUTINES
!
      integer ieff,ieffdpop
!
      double precision myemitx0_dist,myemity0_dist,                     &
     &     myemitx0_collgap,myemity0_collgap,                           &
     &     myemitx,myalphay,mybetay,myalphax,                           &
     &     mybetax,rselect
      common /ralph/ myemitx0_dist,myemity0_dist,                       &
     &     myemitx0_collgap,myemity0_collgap,                           &
     &     myalphax,myalphay,mybetax,                                   &
     &     mybetay,rselect


! M. Fiascaris for the collimation team
! variables for global inefficiencies studies
! of normalized and off-momentum halo
! Last modified: July 2016

      double precision neff(numeff),rsig(numeff)
      common  /eff/ neff,rsig

      integer counteddpop(npart,numeffdpop)
      integer counted2d(npart,numeff,numeffdpop)
      double precision neffdpop(numeffdpop),dpopbins(numeffdpop)
      integer npartdpop(numeffdpop)
      common  /effdpop/ neffdpop,dpopbins,npartdpop,counteddpop
      double precision dpopmin,dpopmax,mydpop,neff2d(numeff,numeffdpop)
      common /eff2d/ neff2d
!
      integer  nimpact(50)
      double precision sumimpact(50),sqsumimpact(50)
      common  /rimpact/ sumimpact,sqsumimpact,nimpact
!
      integer  nampl(nblz)
      character*16  ename(nblz)
      double precision sum_ax(nblz),sqsum_ax(nblz),sum_ay(nblz),        &
     &sqsum_ay(nblz),sampl(nblz)
      common  /ampl_rev/ sum_ax,sqsum_ax,sum_ay,sqsum_ay,sampl,ename,   &
     &nampl
!
      double precision neffx(numeff),neffy(numeff)
      common /efficiency/ neffx,neffy


      integer secondary(npart),tertiary(npart),other(npart),            &
     &part_hit_before(npart)
      double precision part_indiv(npart),part_linteract(npart)

      integer part_hit(npart),part_abs(npart),n_tot_absorbed,n_absorbed &
     &,part_select(npart),nabs_type(npart)
      double precision part_impact(npart)
      common /stats/ part_impact,part_hit,part_abs,nabs_type,part_indiv,&
     &part_linteract,secondary,tertiary,other
      common /n_tot_absorbed/ n_tot_absorbed,n_absorbed
      common /part_select/ part_select
!
!      double precision x00(maxn),xp00(maxn),y00(maxn),yp00(maxn)
!      common   /beam00/ x00,xp00,y00,yp00
!
      logical firstrun
      common /firstrun/ firstrun
!
      integer nsurvive,nsurvive_end,num_selhit,n_impact
      common /outcoll/ nsurvive,num_selhit,n_impact,nsurvive_end
!
      integer napx00
      common /napx00/ napx00
!
      integer  icoll
      common  /icoll/  icoll
!
!UPGRADE January 2005
!     INTEGER DB_NCOLL
      integer db_ncoll
!
! For re-initializtion of random generator (already decleared before)
!      integer   mclock_liar
!
      character*16 db_name1(max_ncoll),db_name2(max_ncoll)
      character*4 db_material(max_ncoll)
!APRIL2005
      double precision db_nsig(max_ncoll),db_length(max_ncoll),         &
     &db_offset(max_ncoll),db_rotation(max_ncoll),                      &
     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
      common /colldatabase/ db_nsig,db_length,db_rotation,db_offset,    &
     &db_bx,db_by,db_tilt,db_name1,db_name2,db_material,db_ncoll
!      double precision db_length(max_ncoll),db_rotation(max_ncoll),     &
!     &db_offset(max_ncoll),                                             &
!     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
!      common /colldatabase/ db_length,db_rotation,db_offset,db_bx,db_by,&
!!     &DB_TILT,DB_NAME1,DB_NAME2,DB_MATERIAL,DB_NCOLL
!     &db_tilt,db_name1,db_name2,db_material,db_ncoll,db_nabs,db_ntot,   &
!     &db_startabs
!APRIL2005
!
      integer cn_impact(max_ncoll),cn_absorbed(max_ncoll)
      double precision caverage(max_ncoll),csigma(max_ncoll)
      common /collsummary/ caverage,csigma,cn_impact,cn_absorbed
!
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn)
      common /coord/ myx,myxp,myy,myyp,myp,mys
!
      integer counted_r(npart,numeff),counted_x(npart,numeff),          &
     &counted_y(npart,numeff)
      common /counting/ counted_r,counted_x,counted_y

      integer   samplenumber
      character*4 smpl
      character*80 pfile
      common /samplenumber/ pfile,smpl,samplenumber
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbpencil
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      double precision xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbcollim
!     BLOCK DBCOLLIM
!     This block is common to collimaterhic and collimate2
!     It is NOT compatible with block DBCOMMON, as some variable names overlap...
      

      logical onesided,hit
      integer nprim,filel,mat,nev,j,nabs,nhit,np,icoll,nabs_tmp
!MAY2005
!      integer lhit(npart),part_abs(npart)
      integer lhit(npart),part_abs(npart),name(npart),nabs_type(npart)
!MAY2005
      double precision p0,xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax   &
     &,length,zlm,x,x00,xp,z,z00,zp,p,sp,dpop,s,enom,x_in(npart),       &
     &xp_in(npart),y_in(npart),yp_in(npart),p_in(npart),s_in(npart),    &
     &indiv(npart),lint(npart),
     &keeps,fracab,mybetax,mybetaz,mymux,mymuz,sigx,                    &
     &sigz,norma,xpmu,atdi,drift_length,mirror,tiltangle,impact(npart)
!
      double precision c_length    !length in m
      double precision c_rotation  !rotation angle vs vertical in radian
      double precision c_aperture  !aperture in m
      double precision c_offset    !offset in m
      double precision c_tilt(2)   !tilt in radian
      character*4      c_material  !material
!
      character*(nc) filen,tit
!
      real   rndm4,xlow,xhigh,xplow,xphigh,dx,dxp
!
!AUGUST2006 Added ran_gauss for generation of pencil/     ------- TW
!           sheet beam distribution  (smear in x and y)
!
      double precision ran_gauss
!
      common /cmom/xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax,length,  &
     &nev
      common /materia/mat
      common /phase/x,xp,z,zp,dpop
      common /nommom/p0
      common /cjaw1/zlm
      common /other/mybetax,mybetaz,mymux,mymuz,atdi
      common /icoll/  icoll
!
      data   dx,dxp/.5e-4,20.e-4/                                        !hr09
!
!     END BLOCK DBCOLLIM
+cd collMatNum
!     EQ 2016 added variables for collimator material numbers
      integer nmat, nrmat
      parameter(nmat=14,nrmat=12)

+cd flukavars
!     RB DM 2014 added variables for FLUKA output
      double precision xInt,xpInt,yInt,ypInt,sInt
      common/flukaVars/xInt,xpInt,yInt,ypInt,sInt
!
!
+cd info
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
+cd dbmkdist
!
!++ Vectors of coordinates
!
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
      ! IN "+CD DBTRTHIN", "+CD DBDATEN", "+CD DBTHIN6D", and "+CD DBMKDIST"
      logical cut_input
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd funint
      real tftot
      common/funint/tftot
+cd interac
      integer mat,mcurr
+ca collMatNum
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!electron density and plasma energy
      double precision edens, pleng
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat)
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
      common/cions/edens(nmat),pleng(nmat)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   dbdcum

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code

!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure

      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )

      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   dbdump
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K. Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     COMMON for dumping the beam population
!     always in main code

!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture check
!       post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldumpfront                     ! dump at the beginning of each element,
                                             !  not at the end.
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping

      double precision :: dump_tas (nblz,6,6) ! tas matrix used for FMA analysis (nomalisation of phase space)
      double precision :: dump_clo (nblz,6)   ! closed orbit used for FMA (normalisation of phase space)  -> check units used in dump_clo (is x' or px used?)

      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpfirst                      ! First turn for DUMP to be active
      integer dumplast                       ! Last turn for this DUMP to be active (-1=all)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump

      character dump_fname (0:nele)*(getfields_l_max_string)
      
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfirst(0:nele), dumplast(0:nele),
     &                dumpfmt(0:nele), ldumphighprec, ldumpfront,
     &                dump_fname
      common /dumpOptics/ dump_tas,dump_clo
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbdumpcr
      !For resetting file positions
      integer dumpfilepos, dumpfilepos_cr
      common /dumpdbCR/ dumpfilepos(0:nele), dumpfilepos_cr(0:nele)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd elensparam
!     M. Fitterer, FNAL
!     Common block for electron lens definition
      
      ! variables to save elens parameters for tracking etc.
      integer          :: elens_type(nele)      ! integer for elens type
                                                ! 0 : Un-initialized.
                                                ! 1 : Hollow annular elens, uniform profile
      double precision :: elens_theta_max(nele) ! maximum kick strength [mrad]
      double precision :: elens_r2(nele)        ! outer radius R2 [mm]
      double precision :: elens_r2ovr1(nele)    ! R2/R1 where R1 is the inner radius
      double precision :: elens_offset_x(nele),
     &                    elens_offset_y(nele)  ! hor./vert. offset of elens [mm]
      integer          :: elens_bend_entrance(nele),
     &                    elens_bend_exit(nele) ! switch for elens bends
      common /elensco/ elens_type,elens_theta_max,elens_r2,
     &elens_r2ovr1,elens_offset_x,elens_offset_y,elens_bend_entrance,
     &     elens_bend_exit
+cd elenstracktmp
!     Dummy variables used in tracking block for calculation
!     of the kick for the ideal annualar e-lens
      double precision :: rrelens,frrelens,r1elens,xelens,yelens
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd wireparam
!     A. Patapenka (NIU), M. Fitterer (FNAL)
!     Common block for wire definition
      ! variables to save wire parameters for tracking etc.
      double precision :: wire_current(nele)    ! wire current [A]
      double precision :: wire_lint(nele)       ! integrated length of the wire [m]
      double precision :: wire_lphys(nele)      ! physical length of the wire [m]
      ! integer to include or not closed orbit in the separation between beam and wire
      ! 0  : Un-initialized if wire element not found
      ! +1 : dispx is the distance between x0=y0=0 and the wire
      ! -1 : dispx is the distance between the closed orbit and the wire 
      !
      !    x=y=0    <->   xco     <->    xwire
      !               closed orbit    wire position
      ! wire_flagco = +1: dispx = xwire -> rx = x + xsep
      ! wire_flagco = -1: dispx = xwire - xco -> rx = x - xco + xsep
      ! -> rx = x + xwire
      integer          :: wire_flagco(nele)     
      double precision :: wire_dispx(nele),
     &                    wire_dispy(nele)      ! hor./vert. displacement of the wire [mm]
      double precision :: wire_tiltx(nele),
     &                    wire_tilty(nele)      ! hor./vert. tilt of the wire [degrees] -90 < tilty < 90, uses the same definition as the DISP block
      common /wireparamco/ wire_current,wire_lint,wire_lphys,
     &wire_flagco,wire_dispx,wire_dispy,wire_tiltx,wire_tilty
+cd wiretracktmp
! temporary variables
      double precision RTWO !RTWO=x^2+y^2
      double precision NNORM_, NNORM
      double precision l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd fma
!     M. Fitterer, for CERN BE-ABP/HSS and Fermilab
!     Common block for the FMA analysis postprocessing
      integer, parameter :: fma_max       = 200              !max. number of FMAs
      integer, parameter :: fma_nturn_max = 10000            !max. number of turns used for fft
      integer fma_numfiles                                   !number of FMAs
      logical fma_flag                                       !FMA input block exists
      character fma_fname  (fma_max)*(getfields_l_max_string)!name of input file from dump
      character fma_method (fma_max)*(getfields_l_max_string)!method used to find the tunes
      integer fma_nturn    (fma_max)                         !number of turns used for fft
      integer fma_norm_flag(fma_max)                         !fma_norm_flag=0, do not normalize phase space before FFT, otherwise normalize phase space coordinates
      common /fma_var/ fma_fname,fma_method,fma_numfiles,fma_flag,
     &fma_norm_flag,fma_nturn
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   comgetfields
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code

*     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and its fields
                                                 ! (nchars in daten +1 to always make room for \0)

*     array of fields
      character getfields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
*     number of identified fields
      integer getfields_nfields
*     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
*     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd stringzerotrim
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Used in DYNK and FMA.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen
      parameter (stringzerotrim_maxlen=20) !Note: This is also used for DYNK, and should AT LEAST be able to store a bez+char(0) -> 17.
      
      character(stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   comdynk

!     A.Mereghetti, for the FLUKA Team,
!     K.Sjobak and A. Santamaria, BE-ABP/HSS
!     last modified: 30/10-2014
!     
!     COMMON for dynamic kicks (DYNK)
!     always in main code
!     
!     See TWIKI for documentation
!
!     Needs blocks parpro (for nele) and stringzerotrim (for stringzerotrim_maxlen)


*     general-purpose variables
      logical ldynk            ! dynamic kick requested, i.e. DYNK input bloc issued in the fort.3 file
      logical ldynkdebug       ! print debug messages in main output
      logical ldynkfiledisable ! Disable writing dynksets.dat?

C     Store the FUN statements
      integer maxfuncs_dynk, maxdata_dynk, maxstrlen_dynk
      parameter (maxfuncs_dynk=100,maxdata_dynk=50000,
     &     maxstrlen_dynk=stringzerotrim_maxlen)

      integer funcs_dynk (maxfuncs_dynk,5) ! 1 row/FUN, cols are: 
                                           ! (1) = function name in fort.3 (points within cexpr_dynk),
                                           ! (2) = indicates function type
                                           ! (3,4,5) = arguments (often pointing within other arrays {i|f|c}expr_dynk)
      integer iexpr_dynk (maxdata_dynk)                  ! Data for DYNK FUNs
      double precision fexpr_dynk (maxdata_dynk)         ! Data for DYNK FUNs
      character(maxstrlen_dynk) cexpr_dynk(maxdata_dynk) ! Data for DYNK FUNs (\0 initialized in comnul)
      
      integer nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk !Number of used positions in arrays
            
C     Store the SET statements
      integer maxsets_dynk
      parameter (maxsets_dynk=200)
      integer sets_dynk(maxsets_dynk, 4) ! 1 row/SET, cols are:
                                         ! (1) = function index (points within funcs_dynk)
                                         ! (2) = first turn num. where it is active
                                         ! (3) =  last turn num. where it is active
                                         ! (4) = Turn shift - number added to turn before evaluating the FUN
      character(maxstrlen_dynk) csets_dynk (maxsets_dynk,2) ! 1 row/SET (same ordering as sets_dynk), cols are:
                                                            ! (1) element name
                                                            ! (2) attribute name

      integer nsets_dynk ! Number of used positions in arrays
      
      character(maxstrlen_dynk) csets_unique_dynk (maxsets_dynk,2) !Similar to csets_dynk,
                                                                   ! but only one entry per elem/attr
      double precision fsets_origvalue_dynk(maxsets_dynk) ! Store original value from dynk
      integer nsets_unique_dynk ! Number of used positions in arrays

      ! Some elements (multipoles) overwrites the general settings info when initialized.
      ! Store this information on the side.
      ! Also used by setvalue and getvalue
      integer dynk_izuIndex
      dimension dynk_izuIndex(nele)
      double precision dynk_elemdata(nele,3)
      
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug, ldynkfiledisable

      common /dynkComExpr/ funcs_dynk,
     &     iexpr_dynk, fexpr_dynk, cexpr_dynk,
     &     nfuncs_dynk, niexpr_dynk, nfexpr_dynk, ncexpr_dynk

      common /dynkComSet/ sets_dynk, csets_dynk, nsets_dynk
      common /dynkComUniqueSet/
     &     csets_unique_dynk, fsets_origvalue_dynk, nsets_unique_dynk
     
      common /dynkComReinitialize/ dynk_izuIndex, dynk_elemdata

+cd comdynkcr
C     Block with data/fields needed for checkpoint/restart of DYNK
      ! Number of records written to dynkfile (dynksets.dat)
      integer dynkfilepos, dynkfilepos_cr
      
      ! Data for DYNK FUNs
      integer                  iexpr_dynk_cr (maxdata_dynk)
      double precision         fexpr_dynk_cr (maxdata_dynk)
      character(maxstrlen_dynk)cexpr_dynk_cr (maxdata_dynk)
      ! Number of used positions in arrays
      integer niexpr_dynk_cr, nfexpr_dynk_cr, ncexpr_dynk_cr
      
      ! Store current settings from dynk
      double precision fsets_dynk_cr(maxsets_dynk)

      common /dynkComCR/ dynkfilepos,dynkfilepos_cr
      common /dynkComExprCR/
     &     iexpr_dynk_cr, fexpr_dynk_cr, cexpr_dynk_cr,
     &     niexpr_dynk_cr, nfexpr_dynk_cr, ncexpr_dynk_cr
      
      common /dynkComUniqueSetCR/
     &     fsets_dynk_cr
      
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd zipf
      integer zipf_maxfiles,zipf_numfiles
      parameter (zipf_maxfiles=256)
      character(stringzerotrim_maxlen) zipf_outfile                  !Name of output file (Default: Sixout.zip)
      character(stringzerotrim_maxlen) zipf_filenames(zipf_maxfiles) !Name of files to pack into the zip file.
      
      common /zipfCom/ zipf_numfiles, zipf_outfile, zipf_filenames
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd timefct
+if crlibm
          expt =  exp_rn(-dble(n)/tcnst35(i))
+ei
+if .not.crlibm
          expt =  exp(-dble(n)/tcnst35(i))
+ei
+cd dainicom
*FOX  D V DA EXT SIGMDA NORD NVAR ; D V DA EXT DPDA NORD NVAR ;
*FOX  D V DA EXT DPDA1 NORD NVAR ; D V DA EXT RV NORD NVAR ;
*FOX  D V DA EXT XX NORD NVAR 2 ; D V DA EXT YY NORD NVAR 2 ;
*FOX  D V DA EXT EJ1 NORD NVAR ; D V DA EXT EJF1 NORD NVAR ;
*FOX  D V DA EXT ALDA NORD NVAR 2 6 ; D V DA EXT ASDA NORD NVAR 2 6 ;
*FOX  D V DA EXT ALDAQ NORD NVAR 2 6 ; D V DA EXT ASDAQ NORD NVAR 2 6 ;
*FOX  D V DA EXT SMIDA NORD NVAR MCOR ;
+cd daini
*FOX  B D ;
*FOX  D V DA COM SIGMDA NORD NVAR ; D V DA COM DPDA NORD NVAR ;
*FOX  D V DA COM DPDA1 NORD NVAR ; D V DA COM RV NORD NVAR ;
*FOX  D V DA COM XX NORD NVAR 2 ; D V DA COM YY NORD NVAR 2 ;
*FOX  D V DA COM EJ1 NORD NVAR ; D V DA COM EJF1 NORD NVAR ;
*FOX  D V DA COM ALDA NORD NVAR 2 6 ; D V DA COM ASDA NORD NVAR 2 6 ;
*FOX  D V DA COM ALDAQ NORD NVAR 2 6 ; D V DA COM ASDAQ NORD NVAR 2 6 ;
*FOX  D V DA COM SMIDA NORD NVAR MCOR ;
*FOX  D V DA INT X NORD NVAR 2 ; D V DA INT Y NORD NVAR 2 ;
*FOX  D V DA INT YP NORD NVAR 2 ; D V DA INT DKIP NORD NVAR ;
*FOX  D V DA INT CORROLD NORD NVAR MCOP ;
*FOX  D V DA INT CORRNEW NORD NVAR MCOP ;
*FOX  D V DA INT CORRAU1 NORD NVAR MCOP ;
*FOX  D V DA INT CORRAU2 NORD NVAR MCOP ;
*FOX  D V DA INT AA NORD NVAR 11 ;  D V DA INT BB NORD NVAR 11 ;
*FOX  D V DA INT TRACKI NORD NVAR 6 ;
*FOX  D V DA INT PUX NORD NVAR ; D V DA INT PUZ NORD NVAR ;
*FOX  D V DA INT EJF0 NORD NVAR ; D V DA INT EKK NORD NVAR ;
*FOX  D V DA INT XL NORD NVAR ; D V DA INT ZL NORD NVAR ;
*FOX  D V DA INT CRKVE NORD NVAR ; D V DA INT CIKVE NORD NVAR ;
*FOX  D V DA INT CRKVEUK NORD NVAR ; D V DA INT CBZBF NORD NVAR ;
*FOX  D V DA INT YV1J NORD NVAR ; D V DA INT YV2J NORD NVAR ;
*FOX  D V DA INT CRKVEBF NORD NVAR ; D V DA INT CIKVEBF NORD NVAR ;
*FOX  D V DA INT RHO2BF NORD NVAR ; D V DA INT TKBF NORD NVAR ;
*FOX  D V DA INT XRBF NORD NVAR ; D V DA INT CCCC NORD NVAR ;
*FOX  D V DA INT ZRBF NORD NVAR ; D V DA INT XBBF NORD NVAR ;
*FOX  D V DA INT ZBBF NORD NVAR ; D V DA INT CRXBF NORD NVAR ;
*FOX  D V DA INT CBXBF NORD NVAR ; D V DA INT CRZBF NORD NVAR ;
*FOX  D V DA INT WX NORD NVAR ; D V DA INT WY NORD NVAR ;
*FOX  D V DA INT CRABAMP NORD NVAR ;
*FOX  D V DA INT CRABAMP2 NORD NVAR ;
*FOX  D V DA INT CRABAMP3 NORD NVAR ;
*FOX  D V DA INT CRABAMP4 NORD NVAR ;
+if rvet
*FOX  D V DA INT RVET NORD NVAR ;
+ei
*FOX  D V RE INT AAI NBLZ MMUL ; D V RE INT BBI NBLZ MMUL ;
*FOX  D V RE INT TILTC NBLZ ; D V RE INT TILTS NBLZ ;
*FOX  D V RE INT DPS MPA ; D V RE INT SIGM MPA ;
*FOX  D V RE INT DKI NELE 3 ; D V RE INT BL1 NBLO 2 6 ;
*FOX  D V RE INT EL NELE ; D V RE INT EJ MPA ; D V RE INT EJF MPA ;
*FOX  D V RE INT SMI NBLZ ; D V RE INT SMIZF NBLZ ;
*FOX  D V RE INT ED1 ; D V RE INT ED2 ;
*FOX  D V RE INT DPDAV2 6 ; D V RE INT RRTR NTR 6 6 ;
*FOX  D V RE INT COTR NTR 6 ; D V RE INT DPDAV ; D V RE INT BETR0 ;
*FOX  D V RE INT E0 ; D V RE INT E0F ; D V RE INT PMA ;
*FOX  D V RE INT XS ; D V RE INT ZS ; D V RE INT OX ; D V RE INT OXP ;
*FOX  D V RE INT OZ ; D V RE INT OZP ; D V RE INT SIGM1 ;
*FOX  D V RE INT BEAMOFF1 ; D V RE INT BEAMOFF2 ;
*FOX  D V RE INT BEAMOFF4 ; D V RE INT BEAMOFF5 ; D V RE INT BEAMOFF6 ;
*FOX  D V RE INT DPS1 ; D V RE INT RKBF ; D V RE INT RBF ;
*FOX  D V RE INT R2BF ; D V RE INT BBCU NBB 12 ;
*FOX  D V RE INT SIGMAN 2 NBB ; D V RE INT PTNFAC NELE ;
*FOX  D V RE INT CRAD ; D V RE INT GAMMAR ; D V RE INT PARBE NELE 18 ;
*FOX  D V RE INT PARTNUM ; D V RE INT PISQRT ; D V RE INT SCRKVEB ;
*FOX  D V RE INT SCIKVEB ; D V RE INT STARTCO ; D V RE INT RATIOE NELE ;
*FOX  D V RE INT PARBE14 ; D V RE INT PI ;
*FOX  D V RE INT SIGMDAC ; D V RE INT DUMMY ;
*FOX  D V RE INT ED NELE ; D V RE INT EK NELE ;
*FOX  D V RE INT WIRECLO0 ;
+if .not.fast
*FOX  D V RE INT C2E3 ; D V RE INT C1E6 ;
+ei
+if fast
*FOX  D V RE INT C5M4 ; D V RE INT C2E3 ; D V RE INT C1E6 ;
+ei
*FOX  D V RE INT C1E3 ; D V RE INT C1M3 ; D V RE INT C1M6 ;
*FOX  D V RE INT C1M9 ; D V RE INT C1M12 ; D V RE INT C1M15 ;
*FOX  D V RE INT C1M18 ; D V RE INT C1M21 ; D V RE INT C1M24 ;
*FOX  D V RE INT ONE ; D V RE INT TWO ; D V RE INT THREE ;
*FOX  D V RE INT FOUR ; D V RE INT ZERO ; D V RE INT HALF ;
*FOX  D V RE INT CRABFREQ ; D V RE INT CRABPHT ;
*FOX  D V RE INT CRABPHT2 ; D V RE INT CRABPHT3 ;
*FOX  D V RE INT CRABPHT4 ;
*FOX  D V RE INT CLIGHT ;
*FOX  D V IN INT IDZ 2 ; D V IN INT KX ; D V IN INT IX ; D V IN INT JX ;
*FOX  D V IN INT I ; D V IN INT IPCH ; D V IN INT K ; D V IN INT KKK ;
*FOX  D V IN INT IVAR ; D V IN INT IRRTR ; D V IN INT KK ;
*FOX  D V IN INT IMBB NBLZ ;
*FOX  D V IN INT WIRE_NUM NBLZ ;
*FOX  D F RE DARE 1 ;
*FOX  D V DA INT PZ NORD NVAR ;
*FOX  E D ;
+cd dump1
      write(32)                                                         &
+cd dump2
      read(32)                                                          &
+cd dump3
!
!  left out to do tracking
!  numl,niu,amp0,amp(2),damp,chi0,chid,rat,exz(2,6),time0,time1
!
!
+if time
     &tcnst35,exterr35,icext35,zfz35,                                   &
+ei
     &ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
     &ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
     &idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
     &iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
     &hsyc,phasc,dppoff,sigmoff,tlen,                                   &
     &iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
     &sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
     &zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
     &mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
     &dech,dsm0,itco,itcro,itqv,iout,qw0,iq,iqmod,kpa,iqmod6,bez,elbe,  &
     &bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac,pac,  &
     &bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,apx,apz,sigma0,iclo,   &
     &ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
     &icoe,ise,mesa,mp,m21,m22,m23,                                     &
     &ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
     &rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
     &qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
     &iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
     &nprint,ndafi,qwsk,betx,betz,                                      &
     &alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
     &sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
     &sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
     &ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,wire_num,          &
+if vvector
     &as,al,sigm,dps,idz,dp1,itra,                                      &
+ei
+if .not.vvector
     &as,at,a2,al,sigm,dps,idz,dp1,itra,                                &
+ei
     &x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
     &bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
     &nvar2,nsix,ncor,ipar,nordf,                                       &
     &nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
     &icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
     &ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
     &clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
     &dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
+if rvet
     &rvet,                                                             &
+ei
     &ejf0v,numxv,nms,nlostp,dpd,                                       &
     &dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
     &rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
     &ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
     &clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
     &di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr
+cd clor6
              if(iclo6r.eq.0) then
                clo6(1)=clo(1)
                clop6(1)=clop(1)
                clo6(2)=clo(2)
                clop6(2)=clop(2)
                clo6(3)=zero
                clop6(3)=zero
              else
+if fio
+if crlibm
                call enable_xp()
+ei
                read(33,*,round='nearest') (clo6(l),clop6(l), l=1,3)
+if crlibm
                call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
                read(33,*) (clo6(l),clop6(l), l=1,3)
+ei
+if crlibm
                read(33,*) ch 
                lineno=lineno+1
                ch1(:nchars+3)=ch(:nchars)//' / '
                call splitfld(errno,33,lineno,nofields,nf,ch1,fields)
                do l=1,3
                  if (nf.gt.0) then
                    clo6(l)=fround(errno,fields,l*2-1)
                    nf=nf-1
                  endif
                  if (nf.gt.0) then
                    clop6(l)=fround(errno,fields,l*2)
                    nf=nf-1
                  endif
                enddo
+ei
+ei
              endif
              call clorb(zero)
              call betalf(zero,qw)
              call phasad(zero,qwc)
              sigm(1)=clo6(3)
              dps(1)=clop6(3)
+if debug 
!     call dumpbin('bqmodda',1,3)
!     call abend('before qmodda 1 3                                 ')
!     write(*,*) '1st call qmodda'
+ei
              call qmodda(3,qwc)
+if debug 
!     call dumpbin('aqmodda',1,3)
!     call abend('after  qmodda 1 3                                 ')
+ei
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
                nlin=nlinoo
              endif
              dp1=dp10+clop6(3)
+if debug 
!     call dumpbin('ecdclor6',1,3)
!     call abend('end cd clor6                                      ')
+ei
+cd beamcou
+if debug
!       write(*,*) 'Beam coupling'
+ei
              dps0=dps(1)
              dps(1)=zero
              iqmodc=4
              call mydaini(1,2,nd2,nd,nd2,1)
              ilinc=2
              call mydaini(2,2,nd2,nd,nd2,1)
              dps(1)=dps0
+if debug
!     call dumpbin('abeamcou',2,22)
!     call abend('after beam coupling                               ')
+ei
+cd multini
!-- Initialize multipoles, combining settings from fort.2 with
!-- coefficients from MULT and random values from FLUC.
!-- Used in program maincr and from initialize_element.
      r0=ek(ix)
      if(abs(r0).le.pieni) goto 150 ! label 150 - just after this code
      nmz=nmu(ix)
      if(nmz.eq.0) then
         izu=izu+2*mmul
         goto 150
      endif
      im=irm(ix)
      r0a=one
      do k=1,nmz
         izu=izu+1
         aaiv(k,m,i)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a !hr05
+if time
         aaiv35(k,m,i)=(ed(ix)*(ak0(im,k)+zfz35(izu)*aka(im,k)))/r0a !hr05
+ei
         aai(i,k)=aaiv(k,m,i)
         izu=izu+1
         bbiv(k,m,i)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a !hr05
+if time
         bbiv35(k,m,i)=(ed(ix)*(bk0(im,k)+zfz35(izu)*bka(im,k)))/r0a !hr05
+ei
         bbi(i,k)=bbiv(k,m,i)
         
         r0a=r0a*r0
      enddo
      
      izu=izu+2*mmul-2*nmz
!------------------------------------------------------------------------------------

+cd alignf
+if .not.tilt
*FOX  XL=X(1)-XS ;
*FOX  ZL=X(2)-ZS ;
*FOX  CRKVE=XL ;
*FOX  CIKVE=ZL ;
+ei
+if tilt
*FOX  XL=(X(1)-XS)*TILTC(I)+(X(2)-ZS)*TILTS(I) ;
*FOX  ZL=-(X(1)-XS)*TILTS(I)+(X(2)-ZS)*TILTC(I) ;
*FOX  CRKVE=XL ;
*FOX  CIKVE=ZL ;
+ei
+cd alignu
+if .not.tilt
        xl=x(1,1)-xs
        zl=x(1,2)-zs
        crkve=xl
        cikve=zl
+ei
+if tilt
        xl=(x(1,1)-xs)*tiltc(k)+(x(1,2)-zs)*tilts(k)
        zl=(x(1,2)-zs)*tiltc(k)-(x(1,1)-xs)*tilts(k)                     !hr02
        crkve=xl
        cikve=zl
+ei
+cd alignsa
+if .not.tilt
                        xl=x(j,1)-xs
                        zl=x(j,2)-zs
                        crkve=xl
                        cikve=zl
+ei
+if tilt
                        xl=(x(j,1)-xs)*tiltc(i)+(x(j,2)-zs)*tilts(i)
                        zl=(x(j,2)-zs)*tiltc(i)-(x(j,1)-xs)*tilts(i)     !hr08
                        crkve=xl
                        cikve=zl
+ei
+cd alignsb
+if .not.tilt
                      xl=x(j,1)-xs
                      zl=x(j,2)-zs
+ei
+if tilt
                      xl=(x(j,1)-xs)*tiltc(i)+(x(j,2)-zs)*tilts(i)
                      zl=(x(j,2)-zs)*tiltc(i)-(x(j,1)-xs)*tilts(i)       !hr08
+ei
+cd alignl
+if .not.tilt
        xl=t(1,1)-xs
        zl=t(1,3)-zs
        crkve=xl
        cikve=zl
+ei
+if tilt
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
+ei
+cd alignva
+if .not.tilt
            xlv(j)=xv(1,j)-xsiv(1,i)
            zlv(j)=xv(2,j)-zsiv(1,i)
            crkve=xlv(j)
            cikve=zlv(j)
+ei
+if tilt
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
+ei
+cd alignvb
+if .not.tilt
            xlvj=xv(1,j)-xsiv(1,i)
            zlvj=xv(2,j)-zsiv(1,i)
+ei
+if tilt
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
+ei
+cd stra01
+if .not.tilt
        strack(i)=smiv(1,i)*c1e3
+ei
+if tilt
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra02
+if .not.tilt
        strack(i)=smiv(1,i)
+ei
+if tilt
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra2dpe
+if .not.tilt
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
+ei
+if tilt
        strack(i)=zero
        strackx(i)=ed(IX)*tiltc(i)
        stracks(i)=ed(IX)*tilts(i)
        strackz(i)=ek(IX)*tiltc(i)
        strackc(i)=ek(IX)*tilts(i)
+ei
+cd solenoid
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
+cd stra03
+if .not.tilt
        strack(i)=smiv(1,i)*c1m3
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra04
+if .not.tilt
        strack(i)=smiv(1,i)*c1m6
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra05
+if .not.tilt
        strack(i)=smiv(1,i)*c1m9
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra06
+if .not.tilt
        strack(i)=smiv(1,i)*c1m12
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra07
+if .not.tilt
        strack(i)=smiv(1,i)*c1m15
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra08
+if .not.tilt
        strack(i)=smiv(1,i)*c1m18
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra09
+if .not.tilt
        strack(i)=smiv(1,i)*c1m21
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra10
+if .not.tilt
        strack(i)=smiv(1,i)*c1m24
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra11
+if .not.tilt
              strack(i)=dki(ix,1)/dki(ix,3)
+ei
+if tilt
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra12
+if .not.tilt
              strack(i)=dki(ix,1)
+ei
+if tilt
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra13
+if .not.tilt
              strack(i)=dki(ix,2)/dki(ix,3)
+ei
+if tilt
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra14
+if .not.tilt
              strack(i)=dki(ix,2)
+ei
+if tilt
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd kickfho
*FOX  CRKVEUK=CRKVE*XL-CIKVE*ZL ;
*FOX  CIKVE=CRKVE*ZL+CIKVE*XL ;
*FOX  CRKVE=CRKVEUK ;
+cd kickf01h
+if .not.tilt
*FOX  Y(1)=Y(1)+EKK ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+EKK*TILTC(I) ;
*FOX  Y(2)=Y(2)+EKK*TILTS(I) ;
+ei
+cd kickfxxh
+if .not.tilt
*FOX  Y(1)=Y(1)+EKK*CRKVE ;
*FOX  Y(2)=Y(2)-EKK*CIKVE ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+EKK*(TILTC(I)*CRKVE+TILTS(I)*CIKVE) ;
*FOX  Y(2)=Y(2)+EKK*(-TILTC(I)*CIKVE+TILTS(I)*CRKVE) ;
+ei
+cd kickfdpe
+if .not.tilt
*FOX  Y(1)=Y(1)+ED(IX)*CRKVE/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)+EK(IX)*CIKVE/(ONE+DPDA) ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+(ED(IX)*TILTC(I)*CRKVE-EK(IX)*TILTS(I)*CIKVE)/
*FOX  (ONE+DPDA) ;
*FOX  Y(2)=Y(2)+(EK(IX)*TILTC(I)*CIKVE+ED(IX)*TILTS(I)*CRKVE)/
*FOX  (ONE+DPDA) ;
+ei
+cd kickfso1
*FOX  Y(1)=Y(1)-X(2)*ED(IX) ;
*FOX  Y(2)=Y(2)+X(1)*ED(IX) ;
*FOX  CRKVE=Y(1)-X(1)*ED(IX)*EK(IX) ;
*FOX  CIKVE=Y(2)-X(2)*ED(IX)*EK(IX) ;
*FOX  Y(1)=CRKVE*COS(EK(IX))+CIKVE*SIN(EK(IX)) ;
*FOX  Y(2)=-CRKVE*SIN(EK(IX))+CIKVE*COS(EK(IX)) ;
*FOX  CRKVE=X(1)*COS(EK(IX))+X(2)*SIN(EK(IX)) ;
*FOX  CIKVE=-X(1)*SIN(EK(IX))+X(2)*COS(EK(IX)) ;
*FOX  X(1)=CRKVE ;
*FOX  X(2)=CIKVE ;
*FOX  Y(1)=Y(1)+X(2)*ED(IX) ;
*FOX  Y(2)=Y(2)-X(1)*ED(IX) ;
+cd kickf01v
+if .not.tilt
*FOX  Y(2)=Y(2)+EKK ;
+ei
+if tilt
*FOX  Y(1)=Y(1)-EKK*TILTS(I) ;
*FOX  Y(2)=Y(2)+EKK*TILTC(I) ;
+ei
+cd kickfxxv
+if .not.tilt
*FOX  Y(1)=Y(1)+EKK*CIKVE ;
*FOX  Y(2)=Y(2)+EKK*CRKVE ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+EKK*(TILTC(I)*CIKVE-TILTS(I)*CRKVE) ;
*FOX  Y(2)=Y(2)+EKK*(TILTC(I)*CRKVE+TILTS(I)*CIKVE) ;
+ei
+cd kicksho
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
+cd kicks01h
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*tiltc(i)
                        y(j,2)=y(j,2)+ekk(j)*tilts(i)
+ei
+cd kicksxxh
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)*crkve
                        y(j,2)=y(j,2)-ekk(j)*cikve
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
                        y(j,2)=y(j,2)+ekk(j)*(tilts(i)*crkve-           &!hr02
     &tiltc(i)*cikve)                                                    !hr02
+ei
+cd kicks01v
+if .not.tilt
                        y(j,2)=y(j,2)+ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*tilts(i)
                        y(j,2)=y(j,2)+ekk(j)*tiltc(i)
+ei
+cd kicksxxv
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)*cikve
                        y(j,2)=y(j,2)+ekk(j)*crkve
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*(tiltc(i)*cikve-           &
     &tilts(i)*crkve)
                        y(j,2)=y(j,2)+ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
+ei
+cd kickb01h
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*tiltc(i)
                        y(j,2)=y(j,2)-ekk(j)*tilts(i)
+ei
+cd kickbxxh
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)*crkve
                        y(j,2)=y(j,2)+ekk(j)*cikve
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
                        y(j,2)=y(j,2)-ekk(j)*(tilts(i)*crkve-           &!hr02
     &tiltc(i)*cikve)                                                    !hr02
+ei
+cd kickb01v
+if .not.tilt
                        y(j,2)=y(j,2)-ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*tilts(i)
                        y(j,2)=y(j,2)-ekk(j)*tiltc(i)
+ei
+cd kickbxxv
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)*cikve
                        y(j,2)=y(j,2)-ekk(j)*crkve
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*(tiltc(i)*cikve-           &
     &tilts(i)*crkve)
                        y(j,2)=y(j,2)-ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
+ei
+cd kickvho
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
+cd kickv01h
+if .not.tilt
            yv(1,j)=yv(1,j)+strack(i)*oidpsv(j)
+ei
+if tilt
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
+ei
+cd kickvxxh
+if .not.tilt
            yv(1,j)=yv(1,j)+(strack(i)*oidpsv(j))*crkve                  !hr02
            yv(2,j)=yv(2,j)-(strack(i)*oidpsv(j))*cikve                  !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
+ei
+cd kickvdpe
+if .not.tilt
            yv(1,j)=yv(1,j)+(strackx(i)*oidpsv(j))*crkve                 !hr02
            yv(2,j)=yv(2,j)-(strackz(i)*oidpsv(j))*cikve                 !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
+ei
+cd kickvso1
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!
! TODO: Check if ejf0v should be e0f?? or oidpsv=ejf0v(j)/ejfv(j)=1/(1+delta)
!
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
+if crlibm
            yv(1,j)=crkve*cos_rn((strackz(i)*ejf0v(j))/ejfv(j))+        &!hr02
     &cikve*sin_rn((strackz(i)*ejf0v(j))/ejfv(j))                        !hr02
            yv(2,j)=cikve*cos_rn((strackz(i)*ejf0v(j))/ejfv(j))-        &!hr02
     &crkve*sin_rn((strackz(i)*ejf0v(j))/ejfv(j))                        !hr02
            crkve=xv(1,j)*cos_rn((strackz(i)*ejf0v(j))/ejfv(j))+        &!hr02
     &xv(2,j)*sin_rn((strackz(i)*ejf0v(j))/ejfv(j))                      !hr02
            cikve=xv(2,j)*cos_rn((strackz(i)*ejf0v(j))/ejfv(j))-        &!hr02
     &xv(1,j)*sin_rn((strackz(i)*ejf0v(j))/ejfv(j))                      !hr02
+ei
+if .not.crlibm
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
+ei
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
+cd kickvso2
        crkve=sigmv(j)-0.5d0*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))* &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
+cd kickelens
            select case (elens_type(ix))
              case (1)
! ANNULAR: hollow elens with uniform annular profile for collimation
! Space charge density is:
! 0     if r < R1
! Const if R1 < r < R2
! 0     if r > R2
! Parameters:
!   elens_theta_max is the maximum kick in radians
!   elens_r2 is R2 in mm
!   elens_r2ovr1 = R2 / R1 (by default, 1.5)
!   elens_offset_x - x offset
!   elens_offset_y - y offset
!   elens_bend_entrance - switch bends on at entrance
!   elens_bend_exit - switch bends on at exit
! internal parameters to calculate kick:
!   xelens = x(proton) + elens_offset_x
!   yelens = y(proton) + elens_offset_y
!   rrelens = sqrt(xelens**2+yelens**2)
!   r1elens = radius R1 [mm]
!   frrelens = shape function [1/mm]

! kick from ideal annular profile
! 1) apply offset of e-lens
                xelens=xv(1,j)+elens_offset_x(ix)
                yelens=xv(2,j)+elens_offset_y(ix)
! 2) calculate radius
                rrelens=sqrt((xelens)**2+(yelens**2)) ! radius of particle in p-beam relative to center of elens beam
                r1elens=elens_r2(ix)/elens_r2ovr1(ix) ! inner radius elens
! 3) calculate kick
                if (rrelens.gt.r1elens) then ! rrelens <= r1 -> no kick from elens
                  if (rrelens.lt.elens_r2(ix)) then ! r1 <= rrelens < r2
                    frrelens = (elens_r2(ix)/(rrelens**2))*
     &((((rrelens**2)/(r1elens**2))-1)/(elens_r2ovr1(ix)**2 - 1))
                  endif
                  if (rrelens.ge.elens_r2(ix)) then ! r1 < r2 <= rrelens
                    frrelens = elens_r2(ix)/(rrelens**2)
                  endif
                  yv(1,j)=yv(1,j)-elens_theta_max(ix)*frrelens*xelens
     &                 * oidpsv(j)
                  yv(2,j)=yv(2,j)-elens_theta_max(ix)*frrelens*yelens
     &                 * oidpsv(j)
                endif
! include bends at entrance and exit of elens
              case default
               write(lout,*) 'ERROR in deck kickelens: elens_type='
     &,elens_type(ix),' not recognized. Possible values for type are: ',
     &'1.'
                call prror(-1) 
              end select
+cd kickv01v
+if .not.tilt
            yv(2,j)=yv(2,j)+strack(i)*oidpsv(j)
+ei
+if tilt
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
+ei
+cd kickvxxv
+if .not.tilt
            yv(1,j)=yv(1,j)+(strack(i)*oidpsv(j))*cikve                  !hr02
            yv(2,j)=yv(2,j)+(strack(i)*oidpsv(j))*crkve                  !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
+ei
+cd kickl01h
+if .not.tilt
        dyy1=ekk
        dyy2=zero
+ei
+if tilt
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
+ei
+cd kicklxxh
+if .not.tilt
        dyy1=ekk*crkve
        dyy2=-ekk*cikve
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
+ei
+cd cclxxh
+if .not.tilt
        dyy1=ekk*crkve*cos((((sigz/clight)*ek(IX)*1e3)*2d0)*pi)
        dyy2=-ekk*cikve*cos((((sigz/clight)*ek(IX)*1e3)*2d0)*pi)
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
+ei
+cd kickldpe
+if .not.tilt
        dyy1=(ed(IX)*crkve)/(one+dpp)                                    !hr02
        dyy2=(ek(IX)*cikve)/(one+dpp)                                    !hr02
+ei
+if tilt
        dyy1=((ed(IX)*tiltc(k))*crkve-(ek(IX)*tilts(k))*cikve)/(one+dpp) !hr02
        dyy2=((ek(IX)*tiltc(k))*cikve+(ed(IX)*tilts(k))*crkve)/(one+dpp) !hr02
+ei
+cd kicklso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
+if crlibm
            dyy1=(crkve*cos_rn(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_rn(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_rn(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
+ei
+if .not.crlibm
            dyy1=(crkve*cos(ek(IX)/(one+dpp))+                          &!hr02
     &cikve*sin(ek(IX)/(one+dpp)))-y(1,1)                                !hr02
            dyy2=(cikve*cos(ek(IX)/(one+dpp))-                          &!hr02
     &crkve*sin(ek(IX)/(one+dpp)))-y(1,2)                                !hr02
+ei
+cd kickl01v
+if .not.tilt
        dyy1=zero
        dyy2=ekk
+ei
+if tilt
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr08
        dyy2=ekk*tiltc(k)
+ei
+cd kicklxxv
+if .not.tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
+ei
+cd kicku01h
+if .not.tilt
        y(1,1)=y(1,1)+ekk
+ei
+if tilt
        y(1,1)=y(1,1)+ekk*tiltc(k)
        y(1,2)=y(1,2)+ekk*tilts(k)
+ei
+cd kickuxxh
+if .not.tilt
        dyy1=ekk*crkve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+ei
+if tilt
        dyy1=ekk*crkve
        dyy2=(-1d0*ekk)*cikve                                            !hr08
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickudpe
+if .not.tilt
        dyy1=ed(IX)*crkve
        dyy2=ek(IX)*cikve
        y(1,1)=y(1,1)+dyy1/(one+dpp)
        y(1,2)=y(1,2)+dyy2/(one+dpp)
+ei
+if tilt
        dyy1=(ed(IX)*crkve)/(one+dpp)                                    !hr02
        dyy2=(ek(IX)*cikve)/(one+dpp)                                    !hr02
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickuso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
+if crlibm
            dyy1=(crkve*cos_rn(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_rn(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_rn(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
+ei
+if .not.crlibm
            dyy1=(crkve*cos(ek(IX)/(one+dpp))+                          &!hr02
     &cikve*sin(ek(IX)/(one+dpp)))-y(1,1)                                !hr02
            dyy2=(cikve*cos(ek(IX)/(one+dpp))-                          &!hr02
     &crkve*sin(ek(IX)/(one+dpp)))-y(1,2)                                !hr02
+ei
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+cd kicku01v
+if .not.tilt
        y(1,2)=y(1,2)+ekk
+ei
+if tilt
        y(1,1)=y(1,1)-ekk*tilts(k)
        y(1,2)=y(1,2)+ekk*tiltc(k)
+ei
+cd kickuxxv
+if .not.tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+ei
+if tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickq01h
        qu=zero
        qv=zero
+cd kickq02h
+if .not.tilt
        qu=ekk
        qv=zero
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
        qv=(-1d0*ekk)*tiltsk                                             !hr08
+ei
+cd kickqdpe
+if .not.tilt
        qu=ed(IX)/(one+dpp)
        quz=ek(IX)/(one+dpp)
        qv=zero
        qvz=zero
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
+ei
+cd kickqso1
        qu=ed(IX)
        qv=ek(IX)
+cd kickq03h
+if .not.tilt
        qu=(ekk*two)*crkve                                               !hr02
        qv=(ekk*two)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq04h
+if .not.tilt
        qu=(three*ekk)*crkve                                             !hr02
        qv=(three*ekk)*cikve                                             !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*crkve+tiltsk*cikve)                       !hr02
        qv=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
+ei
+cd kickq05h
+if .not.tilt
        qu=(four*ekk)*crkve                                              !hr02
        qv=(four*ekk)*cikve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(four*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        qv=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
+ei
+cd kickq06h
+if .not.tilt
        qu=(5d0*ekk)*crkve                                               !hr02
        qv=(5d0*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq07h
+if .not.tilt
        qu=(6d0*ekk)*crkve                                               !hr02
        qv=(6d0*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq08h
+if .not.tilt
        qu=(7d0*ekk)*crkve                                               !hr02
        qv=(7d0*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq09h
+if .not.tilt
        qu=(8d0*ekk)*crkve                                               !hr02
        qv=(8d0*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq10h
+if .not.tilt
        qu=(9d0*ekk)*crkve                                               !hr02
        qv=(9d0*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq01v
        qu=zero
        qv=zero
+cd kickq02v
+if .not.tilt
        qu=zero
        qv=-1d0*ekk                                                      !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(-1d0*ekk)*tiltsk                                             !hr02
        qv=(-1d0*ekk)*tiltck                                             !hr02
+ei
+cd kickq03v
+if .not.tilt
        qu=(ekk*two)*cikve                                               !hr02
        qv=((-1d0*ekk)*two)*crkve                                        !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=((-1d0*ekk)*two)*(tiltck*crkve+tiltsk*cikve)                  !hr02
+ei
+cd kickq04v
+if .not.tilt
        qu=(three*ekk)*cikve                                             !hr02
        qv=((-1d0*three)*ekk)*crkve                                      !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
        qv=((-1d0*three)*ekk)*(tiltck*crkve+tiltsk*cikve)                !hr02
+ei
+cd kickq05v
+if .not.tilt
        qu=(four*ekk)*cikve                                              !hr02
        qv=((-1d0*four)*ekk)*crkve                                       !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
        qv=((-1d0*four)*ekk)*(tiltck*crkve+tiltsk*cikve)                 !hr02
+ei
+cd kickq06v
+if .not.tilt
        qu=(5d0*ekk)*cikve                                               !hr02
        qv=(-5d0*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(5d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-5d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq07v
+if .not.tilt
        qu=(6d0*ekk)*cikve                                               !hr02
        qv=(-6d0*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(6d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-6d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq08v
+if .not.tilt
        qu=(7d0*ekk)*cikve                                               !hr02
        qv=(-7d0*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(7d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-7d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq09v
+if .not.tilt
        qu=(8d0*ekk)*cikve                                               !hr02
        qv=(-8d0*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(8d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-8d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq10v
+if .not.tilt
        qu=(9d0*ekk)*cikve                                               !hr02
        qv=(-9d0*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(9d0*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-9d0*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kicka01h
+if .not.tilt
        mpe=20
        dyy1=ekk
        dyy2=zero
        qu=zero
        qv=zero
+ei
+if tilt
        mpe=20
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
+ei
+cd kicka02h
+if .not.tilt
        dyy1=ekk*xl
        dyy2=(-1d0*ekk)*zl                                                     !hr02
        mpe=20
        qu=ekk
        qv=zero
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*xl+tilts(k)*zl)
        dyy2=ekk*(tilts(k)*xl-tiltc(k)*zl)                               !hr08
        mpe=20
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
        qv=(-1d0*ekk)*tiltsk                                             !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
+ei
+cd kickadpe
+if .not.tilt
        dyy1=(ed(IX)*xl)/(one+dpp)                                       !hr02
        dyy2=(ek(IX)*zl)/(one+dpp)                                       !hr02
        mpe=20
        qu=ed(IX)/(one+dpp)
        quz=ek(IX)/(one+dpp)
        qv=zero
        qvz=zero
+ei
+if tilt
        dyy1=((ed(IX)*tiltc(k))*xl-(ek(IX)*tilts(k))*zl)/(one+dpp)       !hr02
        dyy2=((ek(IX)*tiltc(k))*zl+(ed(IX)*tilts(k))*xl)/(one+dpp)       !hr02
        mpe=20
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
        qv=((-1d0*ed(IX))*tiltsk)/(one+dpp)                              !hr02
        quz=((-1d0*ek(IX))*tiltck)/(one+dpp)                             !hr02
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
+ei
+cd kickaso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
+if crlibm
            dyy1=(crkve*cos_rn(ek(IX))/(one+dpp))+                      &!hr02
     &(cikve*sin_rn(ek(IX))/(one+dpp))-y(1,1)                            !hr02
            dyy2=cikve*cos_rn(ek(IX)/(one+dpp))-                        &!hr02
     &crkve*sin_rn(ek(IX)/(one+dpp))-y(1,2)                              !hr02
+ei
+if .not.crlibm
            dyy1=(crkve*cos(ek(IX))/(one+dpp))+                         &!hr02
     &(cikve*sin(ek(IX))/(one+dpp))-y(1,1)                               !hr02
            dyy2=cikve*cos(ek(IX)/(one+dpp))-                           &!hr02
     &crkve*sin(ek(IX)/(one+dpp))-y(1,2)                                 !hr02
+ei
        mpe=20
        qu=ed(IX)
        qv=ek(IX)
+cd phas1so1
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
                phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
              else
                phibf(l)=pi2
              endif
            enddo
+cd phas2so1
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
+if crlibm
            t(i,2)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr02
            t(i,4)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr02
            crkve=t(i,1)*cos_rn(qv)+t(i,3)*sin_rn(qv)                    !hr02
            cikve=t(i,3)*cos_rn(qv)-t(i,1)*sin_rn(qv)                    !hr02
+ei
+if .not.crlibm
            t(i,2)=crkve*cos(qv)+cikve*sin(qv)                           
            t(i,4)=cikve*cos(qv)-crkve*sin(qv)                           !hr02
            crkve=t(i,1)*cos(qv)+t(i,3)*sin(qv)
            cikve=t(i,3)*cos(qv)-t(i,1)*sin(qv)                          !hr02
+ei
            t(i,1)=crkve
            t(i,3)=cikve
+cd phas3so1
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
                dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
              else
                dphi=pi2-phibf(l)             
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
+cd kicka03h
+if .not.tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        qu=(ekk*two)*xl                                                  !hr02
        qv=(ekk*two)*zl                                                  !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        ab1(3)=ekk
+ei
+if tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*xl+tiltsk*zl)                               !hr02
        qv=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltck
        ab2(3)=ekk*tiltsk
+ei
+cd kicka04h
+if .not.tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        qu=(three*ekk)*cxzyr                                             !hr02
        qv=(three*ekk)*cxzyi                                             !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(3)=(three*ekk)*xl                                            !hr02
        ab2(3)=((-1d0*three)*ekk)*zl                                     !hr02
        ab1(4)=ekk
+ei
+if tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                       !hr02
        qv=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        ab2(3)=(three*ekk)*(tiltsk*xl-tiltck*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltck
        ab2(4)=ekk*tiltsk
+ei
+cd kicka05h
+if .not.tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(3)=(6d0*ekk)*cxzyr                                           !hr02
        ab2(3)=(-6d0*ekk)*cxzyi                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*cxzyr                                              !hr02
        qv=(four*ekk)*cxzyi                                              !hr02
        ab2(2)=-1d0*qv                                                   !hr08
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(4)=(four*ekk)*xl                                             !hr02
        ab2(4)=((-1d0*four)*ekk)*zl                                      !hr02
        ab1(5)=ekk
+ei
+if tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        ab2(3)=(6d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        qv=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        ab2(4)=(four*ekk)*(tiltsk*xl-tiltck*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltck
        ab2(5)=ekk*tiltsk
+ei
+cd kicka06h
+if .not.tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(4)=(10d0*ekk)*cxzyr                                          !hr02
        ab2(4)=(-10d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(10d0*ekk)*cxzyr                                          !hr02
        ab2(3)=(-10d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(5d0*ekk)*cxzyr                                               !hr02
        qv=(5d0*ekk)*cxzyi                                               !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(5)=(5d0*ekk)*xl                                              !hr02
        ab2(5)=(-5d0*ekk)*zl                                             !hr02
        ab1(6)=ekk
+ei
+if tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(10d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(10d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(5)=(5d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltck
        ab2(6)=ekk*tiltsk
+ei
+cd kicka07h
+if .not.tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(5)=(15d0*ekk)*cxzyr                                          !hr02
        ab2(5)=(-15d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20d0*ekk)*cxzyr                                          !hr02
        ab2(4)=(-20d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(15d0*ekk)*cxzyr                                          !hr02
        ab2(5)=(-15d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(6d0*ekk)*cxzyr                                               !hr02
        qv=(6d0*ekk)*cxzyi                                               !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(6)=(6d0*ekk)*xl                                              !hr02
        ab2(6)=(-6d0*ekk)*zl                                             !hr02
        ab1(7)=ekk
+ei
+if tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(15d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(20d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(5)=(15d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(6)=(6d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltck
        ab2(7)=ekk*tiltsk
+ei
+cd kicka08h
+if .not.tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(6)=(21d0*ekk)*cxzyr                                          !hr02
        ab2(6)=(-21d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35d0*ekk)*cxzyr                                          !hr02
        ab2(5)=(-35d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35d0*ekk)*cxzyr                                          !hr02
        ab2(4)=(-35d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21d0*ekk)*cxzyr                                          !hr02
        ab2(3)=(-21d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(7d0*ekk)*cxzyr                                               !hr02
        qv=(7d0*ekk)*cxzyi                                               !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(7)=(7d0*ekk)*xl                                              !hr02
        ab2(7)=(-7d0*ekk)*zl                                             !hr02
        ab1(8)=ekk
+ei
+if tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        ab2(6)=(21d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(35d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(35d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(21d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(7)=(7d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltck
        ab2(8)=ekk*tiltsk
+ei
+cd kicka09h
+if .not.tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(7)=(28d0*ekk)*cxzyr                                          !hr02
        ab2(7)=(-28d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56d0*ekk)*cxzyr                                          !hr02
        ab2(6)=(-56d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70d0*ekk)*cxzyr                                          !hr02
        ab2(5)=(-70d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56d0*ekk)*cxzyr                                          !hr02
        ab2(4)=(-56d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28d0*ekk)*cxzyr                                          !hr02
        ab2(3)=(-28d0*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(8d0*ekk)*cxzyr                                               !hr02
        qv=(8d0*ekk)*cxzyi                                               !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-1d0*ekk)*cxzyi                                            !hr02
        ab1(8)=(8d0*ekk)*xl                                              !hr02
        ab2(8)=(-8d0*ekk)*zl                                             !hr02
        ab1(9)=ekk
+ei
+if tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        ab2(7)=(28d0*ekk)*(tiltsk5*cxzyr-tiltck5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        ab2(6)=(56d0*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(70d0*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(56d0*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(28d0*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(8)=(8d0*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltck
        ab2(9)=ekk*tiltsk
+ei
+cd kicka10h
+if .not.tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(9d0*ekk)*cxzyr                                               !hr02
        qv=(9d0*ekk)*cxzyi                                               !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=-ekk*cxzyi
+ei
+if tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
+ei
+cd kicka01v
+if .not.tilt
        mpe=20
        dyy1=zero
        dyy2=ekk
        qu=zero
        qv=zero
+ei
+if tilt
        mpe=20
        dyy1=(-1d0*ekk)*tilts(k)                                         !hr02
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
+ei
+cd kicka02v
+if .not.tilt
        dyy1=ekk*zl
        dyy2=ekk*xl
        mpe=2
        mx=-1
        qu=zero
        qv=-1d0*ekk                                                      !hr02
        ab2(2)=ekk
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*zl-tilts(k)*xl)
        dyy2=ekk*(tiltc(k)*xl+tilts(k)*zl)
        mpe=2
        mx=-1
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(-1d0*ekk)*tiltsk                                             !hr02
        qv=(-1d0*ekk)*tiltck                                             !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
+ei
+cd kicka03v
+if .not.tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        qu=(ekk*two)*zl                                                  !hr02
        qv=((-1d0*ekk)*two)*xl                                           !hr02
        ab2(2)=-1d0*qv
        ab2(3)=ekk
+ei
+if tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        qv=((-1d0*ekk)*two)*(tiltck*xl+tiltsk*zl)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltsk
        ab2(3)=ekk*tiltck
+ei
+cd kicka04v
+if .not.tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        qu=(three*ekk)*cxzyi                                             !hr02
        qv=((-1d0*three)*ekk)*cxzyr                                      !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(3)=(three*ekk)*zl                                            !hr02
        ab2(3)=(three*ekk)*xl                                            !hr02
        ab2(4)=ekk
+ei
+if tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        qv=((-1d0*three)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=(three*ekk)*(tiltck*zl-tiltsk*xl)                         !hr02
        ab2(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltsk
        ab2(4)=ekk*tiltck
+ei
+cd kicka05v
+if .not.tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(3)=(6d0*ekk)*cxzyi                                           !hr02
        ab2(3)=(6d0*ekk)*cxzyr                                           !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*cxzyi                                              !hr02
        qv=((-1d0*four)*ekk)*cxzyr                                       !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(4)=(four*ekk)*zl                                             !hr08
        ab2(4)=(four*ekk)*xl                                             !hr08
        ab2(5)=ekk
+ei
+if tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        ab1(3)=(6d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                   !hr02
        ab2(3)=(6d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=((-1d0*four)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)
        ab1(2)=qu
        ab2(2)=-1d0*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=(four*ekk)*(tiltck*zl-tiltsk*xl)                          !hr02
        ab2(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltsk
        ab2(5)=ekk*tiltck
+ei
+cd kicka06v
+if .not.tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(4)=(10d0*ekk)*cxzyi                                          !hr02
        ab2(4)=(10d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(10d0*ekk)*cxzyi                                          !hr02
        ab2(3)=(10d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(5d0*ekk)*cxzyi                                               !hr02
        qv=(-5d0*ekk)*cxzyr                                              !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(5)=(5d0*ekk)*zl                                              !hr02
        ab2(5)=(5d0*ekk)*xl                                              !hr02
        ab2(6)=ekk
+ei
+if tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        ab1(4)=(10d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(10d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(10d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(10d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(5d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-5d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=(5d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(5)=(5d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltsk
        ab2(6)=ekk*tiltck
+ei
+cd kicka07v
+if .not.tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(5)=(15d0*ekk)*cxzyi                                          !hr02
        ab2(5)=(15d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20d0*ekk)*cxzyi                                          !hr02
        ab2(4)=(20d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(15d0*ekk)*cxzyi                                          !hr02
        ab2(3)=(15d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(6d0*ekk)*cxzyi                                               !hr02
        qv=(-6d0*ekk)*cxzyr                                              !hr02
        ab2(2)=-1d0*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(6)=(6d0*ekk)*zl                                              !hr02
        ab2(6)=(6d0*ekk)*xl                                              !hr02
        ab2(7)=ekk
+ei
+if tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        ab1(5)=(15d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(15d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(20d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(15d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(15d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(6d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(-6d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=(6d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(6)=(6d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltsk
        ab2(7)=ekk*tiltck
+ei
+cd kicka08v
+if .not.tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(6)=(21d0*ekk)*cxzyi                                          !hr02
        ab2(6)=(21d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35d0*ekk)*cxzyi                                          !hr02
        ab2(5)=(35d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35d0*ekk)*cxzyi                                          !hr02
        ab2(4)=(35d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21d0*ekk)*cxzyi                                          !hr02
        ab2(3)=(21d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(7d0*ekk)*cxzyi                                               !hr02
        qv=(-7d0*ekk)*cxzyr                                              !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(7)=(7d0*ekk)*zl                                              !hr02
        ab2(7)=(7d0*ekk)*xl                                              !hr02
        ab2(8)=ekk
+ei
+if tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        ab1(6)=(21d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
        ab2(6)=(21d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(35d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(35d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(21d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(7d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-7d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=(7d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(7)=(7d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltsk
        ab2(8)=ekk*tiltck
+ei
+cd kicka09v
+if .not.tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(7)=(28d0*ekk)*cxzyi                                          !hr02
        ab2(7)=(28d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56d0*ekk)*cxzyi                                          !hr02
        ab2(6)=(56d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70d0*ekk)*cxzyi                                          !hr02
        ab2(5)=(70d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56d0*ekk)*cxzyi                                          !hr02
        ab2(4)=(56d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28d0*ekk)*cxzyi                                          !hr02
        ab2(3)=(28d0*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(8d0*ekk)*cxzyi                                               !hr02
        qv=(-8d0*ekk)*cxzyr                                              !hr02
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(8)=(8d0*ekk)*zl                                              !hr02
        ab2(8)=(8d0*ekk)*xl                                              !hr02
        ab2(9)=ekk
+ei
+if tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
        ab1(7)=(28d0*ekk)*(tiltck5*cxzyi-tiltsk5*cxzyr)                  !hr02
        ab2(7)=(28d0*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56d0*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
        ab2(6)=(56d0*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70d0*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(70d0*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56d0*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(56d0*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28d0*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(28d0*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(8d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-8d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-1d0*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=(8d0*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(8)=(8d0*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltsk
        ab2(9)=ekk*tiltck
+ei
+cd kicka10v
+if .not.tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(9d0*ekk)*cxzyi                                               !hr02
        qv=(-9d0*ekk)*cxzyr                                              !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
+ei
+if tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(9d0*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-9d0*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
+ei
+cd bpmdata
!---------Collect BPM data
          if(ix.gt.0.and.bez(ix)(1:3).eq.'BPM'.and.n.lt.100001) then
          if(n.eq.1) then
            open(ix+100,file=bez(ix),status='unknown')
            endif
            write(ix+100,'(7e18.10,1x)') xv(1,1),yv(1,1),xv(2,1),       &
     &yv(2,1), sigmv(1), dpsv(1),ejfv(1)
          if(n.eq.100000) then
            close(ix+100)
            endif
          endif
+cd crabkick
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
        crabfreq=ek(ix)*c1e3

        do j=1,napx ! loop over particles
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03

+if .not.tilt
+if crlibm
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))         !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3   !hr03
+ei
+if .not.crlibm
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
+ei
+ei
+if tilt
+if crlibm
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))         !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3   !hr03
+ei
+if .not.crlibm
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
+cd ccmul2
! JBG RF CC Multipoles
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 2', crabamp2
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph2(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))       
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((0.5d0*(crabamp2*oidpsv(j)))*(crkve**2-      &!hr13
     &cikve**2))*(((crabfreq*2d0)*pi)/clight))*c1m3)*                   &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))      
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((0.5d0*(crabamp2*oidpsv(j)))*(crkve**2-      &!hr13
     &cikve**2))*(((crabfreq*2d0)*pi)/clight))*c1m3)*                   &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))        
+ei
+ei
+if tilt
+if crlibm
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((0.5d0*(crabamp2*oidpsv(j)))*(crkve**2-      &!hr13
     &cikve**2))*(((crabfreq*2d0)*pi)/clight))*c1m3)*                   &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((0.5d0*(crabamp2*oidpsv(j)))*(crkve**2-      &!hr13
     &cikve**2))*(((crabfreq*2d0)*pi)/clight))*c1m3)*                   &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))           
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul2s
! JBG RF CC Multipoles 2
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*2d0)*pi)/clight))*c1m3)*                             & 
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
+ei
+if .not.crlibm
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*2d0)*pi)/clight))*c1m3)*                             & 
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
+ei
+ei
+if tilt
+if crlibm
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*2d0)*pi)/clight))*c1m3)*                             & 
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
+ei
+if .not.crlibm
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*2d0)*pi)/clight))*c1m3)*                             & 
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul3
! JBG RF CC Multipoles
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 3', crabamp3
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph3(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((2d0*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(crkve**3-    &!hr13
     &(3d0*cikve**2)*crkve))*(((crabfreq*2d0)*pi)/clight))*c1m6)*       &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((2d0*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(crkve**3-    &!hr13
     &(3d0*cikve**2)*crkve))*(((crabfreq*2d0)*pi)/clight))*c1m6)*       &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+ei
+if tilt
+if crlibm
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((2d0*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(crkve**3-    &!hr13
     &(3d0*cikve**2)*crkve))*(((crabfreq*2d0)*pi)/clight))*c1m6)*       &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((2d0*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(crkve**3-    &!hr13
     &(3d0*cikve**2)*crkve))*(((crabfreq*2d0)*pi)/clight))*c1m6)*       &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+ei
       ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul3s
! JBG RF CC Multipoles 2
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
!        yv(2,j)=yv(2,j)-2*(1/2.)*(crabamp3*oidpsv(j))*c1m3*             &
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((2d0*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(cikve**3-    &
     &((3d0*crkve**2)*cikve)))*(((crabfreq*2d0)*pi)/clight))*c1m6)*     & 
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+if .not.crlibm
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((2d0*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(cikve**3-    &
     &((3d0*crkve**2)*cikve)))*(((crabfreq*2d0)*pi)/clight))*c1m6)*     & 
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+ei
+if tilt
+if crlibm
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((2d0*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(cikve**3-    &
     &((3d0*crkve**2)*cikve)))*(((crabfreq*2d0)*pi)/clight))*c1m6)*     & 
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+if .not.crlibm
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((2d0*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(cikve**3-    &
     &((3d0*crkve**2)*cikve)))*(((crabfreq*2d0)*pi)/clight))*c1m6)*     & 
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul4
! JBG RF CC Multipoles
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 4', crabamp4
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph4(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(3d0*crkve)*cikve**2))*c1m6)*                           &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((3d0*cikve)*crkve**2-cikve**3))*c1m6)*                           &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((.25d0*(crabamp4*oidpsv(j)))*(crkve**4-      &!hr13
     &(6d0*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(3d0*crkve)*cikve**2))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((3d0*cikve)*crkve**2-cikve**3))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((.25d0*(crabamp4*oidpsv(j)))*(crkve**4-      &!hr13
     &(6d0*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+ei
+if tilt
+if crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(3d0*crkve)*cikve**2))*c1m6)*                           &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((3d0*cikve)*crkve**2-cikve**3))*c1m6)*                           &!hr13
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((0.25d0*(crabamp4*oidpsv(j)))*(crkve**4-     &!hr13
     &(6d0*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &!hr13
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(3d0*crkve)*cikve**2))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((3d0*cikve)*crkve**2-cikve**3))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((0.25d0*(crabamp4*oidpsv(j)))*(crkve**4-     &!hr13
     &(6d0*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul4s
! JBG RF CC Multipoles
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
          do j=1,napx
+ca alignva
+if .not.tilt
+if crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(3d0*cikve)*crkve**2))*c1m6)*                           &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((3d0*crkve)*cikve**2-crkve**3))*c1m6)*                           &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(3d0*cikve)*crkve**2))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((3d0*crkve)*cikve**2-crkve**3))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+ei
+if tilt
+if crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(3d0*cikve)*crkve**2))*c1m6)*                           &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((3d0*crkve)*cikve**2-crkve**3))*c1m6)*                           &
     &cos_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &
     &sin_rn((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+if .not.crlibm
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(3d0*cikve)*crkve**2))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((3d0*crkve)*cikve**2-crkve**3))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
+ei
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd acdipkick
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
+if .not.tilt
              if(nramp1.gt.nac) then
+if crlibm
                yv(xory,j)=yv(xory,j)+(((acdipamp*                      &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
+if .not.crlibm
                yv(xory,j)=yv(xory,j)+(((acdipamp*                      &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
+if crlibm
                yv(xory,j)=yv(xory,j)+(acdipamp*                        &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                   !hr03
+ei
+if .not.crlibm
                yv(xory,j)=yv(xory,j)+(acdipamp*                        &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
+ei
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
+if crlibm
              yv(xory,j)=yv(xory,j)+((acdipamp*                         &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
+if .not.crlibm
              yv(xory,j)=yv(xory,j)+((acdipamp*                         &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
              endif
+ei
+if tilt
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
+if crlibm
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
+if .not.crlibm
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
+if crlibm
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
+if .not.crlibm
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
+ei
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
+if crlibm
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                   !hr03
+ei
+if .not.crlibm
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
+ei
+if crlibm
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                   !hr03
+ei
+if .not.crlibm
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
+ei
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
+if crlibm
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
+if .not.crlibm
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
+if crlibm
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin_rn(((2d0*pi)*qd)*dble(nac)+acphase))*                         &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
+if .not.crlibm
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
+ei
              endif
+ei
      enddo
      endif
+cd kispa10h
+if .not.tilt
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          ekko=ekk
          cxzyr=cxzr**2-cxzi**2                                          !hr08
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36d0*ekko)*cxzyr                                          !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126d0*ekko)*cxzyr                                         !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84d0*ekko)*cxzyr                                          !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
          ekk=ekko*tiltck10
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36d0*ekko)*(tiltck8*cxzyr+tiltsk8*cxzyi)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126d0*ekko)*(tiltck6*cxzyr+tiltsk6*cxzyi)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84d0*ekko)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd kispa10v
+if .not.tilt
          ekko=ekk
          cxzyr=cxzr**2-cxzi**2                                          !hr08
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36d0*ekko)*cxzyi                                          !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126d0*ekko)*cxzyi                                         !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84d0*ekko)*cxzyi                                          !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
          ekk=(-1d0*ekko)*tiltsk10                                       !hr03
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36d0*ekko)*(tiltck8*cxzyi-tiltsk8*cxzyr)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126d0*ekko)*(tiltck6*cxzyi-tiltsk6*cxzyr)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84d0*ekko)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd beams1
!start: beam-beam element
      if(nbeam.ge.1) then
        do 15 i=1,nbb
          nbeaux(i)=0
   15   continue
        do i=1,iu
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(kz(ix).eq.20.and.parbe(ix,2).eq.0d0) then                 !hr03
!--round beam
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.2.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=1
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                endif
              endif
!--elliptic beam x>z
              if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=2
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
!--elliptic beam z>x
              if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.2) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=3
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
            endif
          endif
        enddo
      endif
!end: beam-beam element
+cd beams21
!--beam-beam element
        if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.0d0) then         !hr08
          strack(i)=crad*ptnfac(ix)
          if(abs(strack(i)).le.pieni) then
            ktrack(i)=31
            goto 290
          endif
          if(nbeaux(imbb(i)).eq.1) then
            ktrack(i)=41
            if(ibeco.eq.1) then
              do 42 j=1,napx
+cd beams22
   42         continue
            endif
          endif
          if(nbeaux(imbb(i)).eq.2) then
            ktrack(i)=42
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
+cd beams23
            endif
            endif
          endif
          if(nbeaux(imbb(i)).eq.3) then
            ktrack(i)=43
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
+cd beams24
            endif
            endif
          endif
          goto 290
!--Hirata's 6D beam-beam kick
        else if(kzz.eq.20.and.parbe(ix,2).gt.0d0) then                   !hr03
          ktrack(i)=44
          parbe(ix,4)=(((-1d0*crad)*ptnfac(ix))*half)*c1m6               !hr03
          if(ibeco.eq.1) then
            track6d(1,1)=parbe(ix,5)*c1m3
            track6d(2,1)=zero
            track6d(3,1)=parbe(ix,6)*c1m3
            track6d(4,1)=zero
            track6d(5,1)=zero
            track6d(6,1)=zero
            napx0=napx
            napx=1
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            beamoff(1,imbb(i))=track6d(1,1)*c1e3
            beamoff(2,imbb(i))=track6d(3,1)*c1e3
            beamoff(4,imbb(i))=track6d(2,1)*c1e3
            beamoff(5,imbb(i))=track6d(4,1)*c1e3
            beamoff(6,imbb(i))=track6d(6,1)
            napx=napx0
          endif
          goto 290
        endif
+cd wire
! wire
        if(kzz.eq.15) then
          ktrack(i)=45
          goto 290
        endif
+cd elens
!electron lens (HEL)
        if(kzz.eq.29) then
          ktrack(i)=63
          goto 290
        endif
+cd crab1
        if(kzz.eq.23) then
          ktrack(i)=53
          goto 290
        else if(kzz.eq.-23) then
          ktrack(i)=54
          goto 290
        endif
! JBG RF CC Multipoles
+cd crab_mult
        if(kzz.eq.26) then
          ktrack(i)=57
          goto 290
        else if(kzz.eq.-26) then
          ktrack(i)=58
          goto 290
        endif
        if(kzz.eq.27) then
          ktrack(i)=59
          goto 290
        else if(kzz.eq.-27) then
          ktrack(i)=60
          goto 290
        endif
        if(kzz.eq.28) then
          ktrack(i)=61
          goto 290
        else if(kzz.eq.-28) then
          ktrack(i)=62
          goto 290
        endif
+cd acdip1
        if(kzz.eq.16) then
          ktrack(i)=51
          goto 290
        else if(kzz.eq.-16) then
          ktrack(i)=52
          goto 290
        endif
+cd beamcof
*FOX  CRKVEBF=X(1) ;
*FOX  CIKVEBF=X(2) ;
            startco=(dare(x(1))-clobeam(1,imbb(i)))+parbe(ix,5)
+if debug
!     if (umcalls.eq.8) then
!       call wda('startco',startco,1,0,0,0)
!     endif
+ei
            call dapok(crkvebf,jj,startco)
            startco=(dare(x(2))-clobeam(2,imbb(i)))+parbe(ix,6)
+if debug
!     if (umcalls.eq.8) then
!       call wda('startco',startco,2,0,0,0)
!     endif
+ei
            call dapok(cikvebf,jj,startco)
            if(ibbc.eq.1) then
*FOX  CCCC=CRKVEBF ;
*FOX  CRKVEBF=CCCC*BBCU(IMBB(I),11)+CIKVEBF*BBCU(IMBB(I),12) ;
*FOX  CIKVEBF=-CCCC*BBCU(IMBB(I),12)+CIKVEBF*BBCU(IMBB(I),11) ;
            endif
+cd beamr1f
*FOX  RHO2BF=CRKVEBF*CRKVEBF+CIKVEBF*CIKVEBF ;
+cd beamr1of
            if(ibbc.eq.0) then
              crk=parbe(ix,5)
              cik=parbe(ix,6)
            else
               crk=parbe(ix,5)*bbcu(imbb(i),11) +
     &             parbe(ix,6)*bbcu(imbb(i),12)
               cik=parbe(ix,6)*bbcu(imbb(i),11) -
     &             parbe(ix,5)*bbcu(imbb(i),12)
            endif
            rho2b=crk**2+cik**2                                          !hr03
            if(rho2b.gt.pieni)
+cd beamr2f
      if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
*FOX  TKBF=RHO2BF/(TWO*SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I))) ;
+cd beamr2s
            if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
            tkbf=rho2bf/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))      !hr03
+cd beamr2of
            if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
            tkb=rho2b/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))        !hr03
+cd beamr3f
      if(ibbc.eq.0) then
*FOX   Y(1)=Y(1)+(CRAD*CRKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)/(ONE+DPDA) ;
*FOX   Y(2)=Y(2)+(CRAD*CIKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)/(ONE+DPDA) ;
      else
*FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),11)-
*FOX   (CRAD*CIKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),12) ;
*FOX   Y(1)=Y(1)+CCCC/(ONE+DPDA) ;
*FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),12)+
*FOX   (CRAD*CIKVEBF/RHO2BF*
*FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),11) ;
*FOX   Y(2)=Y(2)+CCCC/(ONE+DPDA) ;
      endif
+cd beamr3s1
+if crlibm
              qu1=((((crad*ptnfac(ix))*crkvebf)/                        &!hr03
     &rho2bf)*(one-exp_rn(-1d0*tkbf)))/(one+dpp)                         !hr03
+ei
+if .not.crlibm
              qu1=((((crad*ptnfac(ix))*crkvebf)/                        &!hr03
     &rho2bf)*(one-exp(-1d0*tkbf)))/(one+dpp)                            !hr03
+ei
+if crlibm
              qv1=((((crad*ptnfac(ix))*cikvebf)/                        &!hr03
     &rho2bf)*(one-exp_rn(-1d0*tkbf)))/(one+dpp)                         !hr03
+ei
+if .not.crlibm
              qv1=((((crad*ptnfac(ix))*cikvebf)/                        &!hr03
     &rho2bf)*(one-exp(-1d0*tkbf)))/(one+dpp)                            !hr03
+ei
+cd beamr3s2
+if crlibm
              qu=((qu1-((((crad*ptnfac(ix))*crkvebf)/                   &!hr03
     &rho2bf)*(one-exp_rn(-1d0*tkbf)))/(one+dpp))/crkve)*half            !hr03
+ei
+if .not.crlibm
              qu=((qu1-((((crad*ptnfac(ix))*crkvebf)/                   &!hr03
     &rho2bf)*(one-exp(-1d0*tkbf)))/(one+dpp))/crkve)*half               !hr03
+ei
+if crlibm
              qv=((qv1-((((crad*ptnfac(ix))*cikvebf)/                   &!hr03
     &rho2bf)*(one-exp_rn(-1d0*tkbf)))/(one+dpp))/cikve)*half            !hr03
+ei
+if .not.crlibm
              qv=((qv1-((((crad*ptnfac(ix))*cikvebf)/                   &!hr03
     &rho2bf)*(one-exp(-1d0*tkbf)))/(one+dpp))/cikve)*half               !hr03
+ei
+cd beamr3of
+if crlibm
            beamoff4=(((crad*ptnfac(ix))*crk)/                          &!hr03
     &rho2b)*(one-exp_rn(-1d0*tkb))                                      !hr03
+ei
+if .not.crlibm
            beamoff4=(((crad*ptnfac(ix))*crk)/                          &!hr03
     &rho2b)*(one-exp(-1d0*tkb))                                         !hr03
+ei
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!       write(*,*) 'beamoff4 1',beamoff4
!       call wda('beamoff4',beamoff4,1,0,0,0)
!     endif
+ei
+if crlibm
            beamoff5=(((crad*ptnfac(ix))*cik)/                          &!hr03
     &rho2b)*(one-exp_rn(-1d0*tkb))                                      !hr03
+ei
+if .not.crlibm
            beamoff5=(((crad*ptnfac(ix))*cik)/                          &!hr03
     &rho2b)*(one-exp(-1d0*tkb))                                         !hr03
+ei
+cd beam11s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2bf=two*(sigman(1,imbb(i))**2-                             &!hr08
     &sigman(2,imbb(i))**2)                                              !hr08
+cd beam21s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2bf=two*(sigman(2,imbb(i))**2-                             &!hr08
     &sigman(1,imbb(i))**2)                                              !hr08
+if debug
!     if (umcalls.eq.8) then
!       call wda('r2bf',r2bf,1,0,0,0)
!     endif
+ei
+cd beam11of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2b=two*(sigman(1,imbb(i))**2-                              &!hr08
     &sigman(2,imbb(i))**2)                                              !hr08
+cd beam21of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2b=two*(sigman(2,imbb(i))**2-                              &!hr08
     &sigman(1,imbb(i))**2)                                              !hr08
+cd beama1s
            rbf=sqrt(r2bf)
            rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
+if debug
!     if (umcalls.eq.8) then
!       call wda('rkbf',rkbf,1,0,0,0)
!     endif
+ei
+cd beama1of
            rb=sqrt(r2b)
            rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
+cd beama2f
*FOX  XRBF=CRKVEBF/RBF ;
      if(dare(xrbf).lt.zero) then
*FOX  XRBF=-XRBF ;
      endif
*FOX  ZRBF=CIKVEBF/RBF ;
      if(dare(zrbf).lt.zero) then
*FOX  ZRBF=-ZRBF ;
      endif
+cd beama2s
            xrbf=abs(crkvebf/rbf)
            zrbf=abs(cikvebf/rbf)
+cd beama2of
            if(ibbc.eq.0) then
               crk=parbe(ix,5)
               cik=parbe(ix,6)
            else
               crk=parbe(ix,5)*bbcu(imbb(i),11) +
     &             parbe(ix,6)*bbcu(imbb(i),12)
               cik=parbe(ix,6)*bbcu(imbb(i),11) -
     &             parbe(ix,5)*bbcu(imbb(i),12)
            endif
            xrb=abs(crk)/rb
            zrb=abs(cik)/rb
+cd beam12f
            call errff(xrbf,zrbf,crxbf,crzbf)
+cd beam12s
            call errf(xrbf,zrbf,crxbf,crzbf)
+cd beam12of
+if debug
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
            call errf(xrb,zrb,crxb,crzb)
+if debug
!     call wda('12ofcrxb',crxb,0,0,0,0)
!     call wda('12ofcrzb',crzb,0,0,0,0)
!     write(*,*) '12ofcrxb',crxb
!     write(*,*) '12ofcrzb',crzb
!
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
+cd beam22f
            call errff(zrbf,xrbf,crzbf,crxbf)
+cd beam22s
            call errf(zrbf,xrbf,crzbf,crxbf)
+cd beam22of
+if debug
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
            call errf(zrb,xrb,crzb,crxb)
+if debug
!     call wda('22ofcrxb',crxb,0,0,0,0)
!     call wda('22ofcrzb',crzb,0,0,0,0)
!     write(*,*) '22ofcrxb',crxb
!     write(*,*) '22ofcrzb',crzb
!
!     call wda('22ofxrb',xrb,0,0,0,0)
!     call wda('22ofzrb',zrb,0,0,0,0)
!     write(*,*) '22ofxrb',xrb
!     write(*,*) '22ofzrb',zrb
+ei
+cd beama3f
      if(abs(sigman(1,imbb(i))).lt.pieni.or.                            &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
*FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
*FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
*FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
*FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
+cd beama3s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            tkbf=(crkvebf**2/sigman(1,imbb(i))**2+                      &!hr03
     &cikvebf**2/sigman(2,imbb(i))**2)*half                              !hr03
            xbbf=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrbf              !hr03
            zbbf=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrbf              !hr03
+cd beama3of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            tkb=(crk**2/sigman(1,imbb(i))**2+                           &!hr03
     &cik**2/sigman(2,imbb(i))**2)*half                                  !hr03
            xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
            zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
+cd beam13f
            call errff(xbbf,zbbf,cbxbf,cbzbf)
+cd beam13s
            call errf(xbbf,zbbf,cbxbf,cbzbf)
+cd beam13of
            call errf(xbb,zbb,cbxb,cbzb)
+cd beam23f
            call errff(zbbf,xbbf,cbzbf,cbxbf)
+cd beam23s
            call errf(zbbf,xbbf,cbzbf,cbxbf)
+cd beam23of
            call errf(zbb,xbb,cbzb,cbxb)
+cd beama4f
      scrkveb=sign(one,dare(crkvebf))
      scikveb=sign(one,dare(cikvebf))
+if debug
!     call wda('a4f1',scrkveb,1,0,0,0)
!     call wda('a4f1',scikveb,1,0,0,0)
!     call wda('ibbc',0d0,ibbc,0,0,0)
+ei
      if(ibbc.eq.0) then
+if debug
!ERIC PROBLEM IS HERE before wda of y1/y2
!       if (umcalls.eq.8) then
!         call wda('bexpy1',0d0,1,0,0,0)
!         write(*,*) 'Here we are'
!         call dumpda('bexpy1',1,0)
!         read(444)
!       endif
+ei
*FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
*FOX  CBZBF)*SCRKVEB-BEAMOFF4)/(ONE+DPDA) ;
+if debug
!     if (umcalls.eq.8) then
!       call wda('aexpy1',y(1),1,0,0,0)
!       write(*,*) 'Hereafter'
!         call dumpda('aexpy1',1,0)
!       read(444)
!     endif
+ei
*FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
*FOX  CBXBF)*SCIKVEB-BEAMOFF5)/(ONE+DPDA) ;
+if debug
!     call wda('a4f1 0 y1',y(1),1,0,0,0)
!     call wda('a4f1 0 y2',y(2),2,0,0,0)
+ei
      else
*FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
*FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
*FOX  (RKBF*(CRXBF-EXP(-TKBF)*
*FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
*FOX   Y(1)=Y(1)+CCCC/(ONE+DPDA) ;
*FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
*FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
*FOX  (RKBF*(CRXBF-EXP(-TKBF)*
*FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
*FOX   Y(2)=Y(2)+CCCC/(ONE+DPDA) ;
+if debug
!     call wda('a4f1 n y1',y(1),1,0,0,0)
!     call wda('a4f1 n y2',y(2),2,0,0,0)
+ei
      endif
+cd beama4s1
+if crlibm
              qu1=((rkbf*(crzbf-exp_rn(-1d0*tkbf)*cbzbf))*               !hr03
     &sign(one,crkvebf))/(one+dpp)                                       !hr03
+ei
+if .not.crlibm
              qu1=((rkbf*(crzbf-exp(-1d0*tkbf)*cbzbf))*                 &!hr03
     &sign(one,crkvebf))/(one+dpp)                                       !hr03
+ei
+if crlibm
              qv1=((rkbf*(crxbf-exp_rn(-1d0*tkbf)*cbxbf))*               !hr03
     &sign(one,cikvebf))/(one+dpp)                                       !hr03
+ei
+if .not.crlibm
              qv1=((rkbf*(crxbf-exp(-1d0*tkbf)*cbxbf))*                 &!hr03
     &sign(one,cikvebf))/(one+dpp)                                       !hr03
+ei
+cd beama4s2
+if crlibm
              qu=((qu1-((rkbf*(crzbf-exp_rn(-1d0*tkbf)*cbzbf))*         &!hr03
     &sign(one,crkvebf))/(one+dpp))/crkve)*half                          !hr03
+ei
+if .not.crlibm
              qu=((qu1-((rkbf*(crzbf-exp(-1d0*tkbf)*cbzbf))*            &!hr03
     &sign(one,crkvebf))/(one+dpp))/crkve)*half                          !hr03
+ei
+if crlibm
              qv=((qv1-((rkbf*(crxbf-exp_rn(-1d0*tkbf)*cbxbf))*          !hr03
     &sign(one,cikvebf))/(one+dpp))/cikve)*half                          !hr03
+ei
+if .not.crlibm
              qv=((qv1-((rkbf*(crxbf-exp(-1d0*tkbf)*cbxbf))*             !hr03 &
     &sign(one,cikvebf))/(one+dpp))/cikve)*half                          !hr03
+ei
+cd beama4of
+if debug
!     call wda('4ofrkb',rkb,0,0,0,0)
!     call wda('4ofcrzb',crzb,0,0,0,0)
!     call wda('4oftkb',tkb,0,0,0,0)
!     call wda('4ofcbzb',cbzb,0,0,0,0)
!     call wda('4ofcrk',crk,0,0,0,0)
!     call wda('4ofexp',-exp_rn(-1d0*tkb),0,0,0,0)
!
!     write(*,*) '4ofrkb',rkb
!     write(*,*) '4ofcrzb',crzb
!     write(*,*) '4oftkb',tkb
!     write(*,*) '4ofcbzb',cbzb
!     write(*,*) '4ofcrk',crk
!     write(*,*) '4ofexp',-exp_rn(-1d0*tkb)
+ei
+if crlibm
              beamoff4=(rkb*(crzb-exp_rn(-1d0*tkb)*cbzb))*              &!hr03
     &sign(one,crk)                                                      !hr03
+ei
+if .not.crlibm
              beamoff4=(rkb*(crzb-exp(-1d0*tkb)*cbzb))*                 &!hr03
     &sign(one,crk)                                                      !hr03
+ei
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!       write(*,*) 'beamoff4 2',beamoff4
!       call wda('beamoff4',beamoff4,2,0,0,0)
!       call dumpda('beamoff4',0,0)
!       call dumpum('beamoff4',0,0)
!       read(222)
!     endif
+ei
+if crlibm
              beamoff5=(rkb*(crxb-exp_rn(-1d0*tkb)*cbxb))*              &!hr03
     &sign(one,cik)                                                      !hr03
+ei
+if .not.crlibm
              beamoff5=(rkb*(crxb-exp(-1d0*tkb)*cbxb))*                 &!hr03
     &sign(one,cik)                                                      !hr03
+ei
+cd beamco
              if(ibbc.eq.0) then
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6)
              else
                crkveb(j)=                                              &
     &((xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5))*bbcu(imbb(i),11) +     &
     &((xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6))*bbcu(imbb(i),12)
                cikveb(j)=                                              &
     &((xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6))*bbcu(imbb(i),11) -     &
     &((xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5))*bbcu(imbb(i),12)
              endif
+cd beamcoo
              if(ibbc.eq.0) then
                crkveb(j)=parbe(ix,5)
                cikveb(j)=parbe(ix,6)
              else
                crkveb(j)=parbe(ix,5)*bbcu(imbb(i),11) +
     &                parbe(ix,6)*bbcu(imbb(i),12)
                cikveb(j)=parbe(ix,6)*bbcu(imbb(i),11)-
     &               parbe(ix,5)*bbcu(imbb(i),12)
              endif
+cd beamr1
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
+cd beamr2
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
+cd beamr3
            if(ibbc.eq.0) then
+if crlibm
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(4,imbb(i)))                      !hr03
+ei
+if .not.crlibm
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
+ei
+if crlibm
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(5,imbb(i)))                      !hr03
+ei
+if .not.crlibm
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
+ei
            else
+if crlibm
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-   &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)     !hr03
+ei
+if .not.crlibm
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
+ei
!+if crlibm
!+ei
!+if .not.crlibm
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
+if crlibm
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+   &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp_rn(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)     !hr03
+ei
+if .not.crlibm
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
+ei
!+if crlibm
!+ei
!+if .not.crlibm
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
+cd beamr3o
+if crlibm
                beamoff(4,imbb(i))=((strack(i)*crkveb(j))/rho2b(j))*    &!hr03
     &(one-exp_rn(-1d0*tkb(j)))                                          !hr03
+ei
+if .not.crlibm
                beamoff(4,imbb(i))=((strack(i)*crkveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
+ei
+if crlibm
                beamoff(5,imbb(i))=((strack(i)*cikveb(j))/rho2b(j))*    &!hr03
     &(one-exp_rn(-1d0*tkb(j)))                                          !hr03
+ei
+if .not.crlibm
                beamoff(5,imbb(i))=((strack(i)*cikveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
+ei
+cd beam11
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
+cd beam21
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
+cd beama1
              rb(j)=sqrt(r2b(j))
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
+cd beama2
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
+cd beam12
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
+cd beam22
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
+cd beama3
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
+cd beam13
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
+cd beam23
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
+cd beama4
              if(ibbc.eq.0) then
+if crlibm
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp_rn(-1d0*tkb(j))*                                              &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
+ei
+if .not.crlibm
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
+ei
+if crlibm
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp_rn(-1d0*tkb(j))*                                              &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
+ei
+if .not.crlibm
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
+ei
              else
+if crlibm
                cccc=((rkb(j)*(crzb(j)-exp_rn(-1d0*tkb(j))*cbzb(j)))*   &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp_rn(-1d0*tkb(j))*cbxb(j)))* &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)           !hr03
+ei
+if .not.crlibm
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)           
+ei
+if crlibm
+ei
+if .not.crlibm
+ei
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
+if crlibm
                cccc=((rkb(j)*(crzb(j)-exp_rn(-1d0*tkb(j))*cbzb(j)))*   &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp_rn(-1d0*tkb(j))*cbxb(j)))* &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
+ei
+if .not.crlibm
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
+ei
!+if crlibm
!+ei
!+if .not.crlibm
!+ei
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
+cd beama4o
+if crlibm
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp_rn(-1d0*tkb(j))*  &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
+ei
+if .not.crlibm
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
+ei
+if crlibm
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp_rn(-1d0*tkb(j))*  &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
+ei
+if .not.crlibm
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
+ei
            enddo
+cd beamwzf1
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
+cd beamwzf2
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
+cd beam6d
!--Hirata's 6D beam-beam kick
            do j=1,napx
               track6d(1,j)=((xv(1,j)+parbe(ix,5)) -
     &              clobeam(1,imbb(i)))*c1m3
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+parbe(ix,6)) -
     &             clobeam(2,imbb(i)))*c1m3
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
+cd beam6dfi
          parbe(ix,4)=(((-1d0*crad)*ptnfac(ix))*half)*c1m6               !hr08
!--Hirata's 6D beam-beam kick
          dummy=dare(x(1))
*FOX      TRACKI(1)=(X(1)+PARBE(IX,5)-DUMMY)*C1M3 ;
*FOX      YP(1)=Y(1)*(ONE+DPDA) ;
          dummy=dare(yp(1))
*FOX      TRACKI(2)=(YP(1)-DUMMY)*C1M3 ;
          dummy=dare(x(2))
*FOX      TRACKI(3)=(X(2)+PARBE(IX,6)-DUMMY)*C1M3 ;
*FOX      YP(2)=Y(2)*(ONE+DPDA) ;
          dummy=dare(yp(2))
*FOX      TRACKI(4)=(YP(2)-DUMMY)*C1M3 ;
          dummy=dare(sigmda)
*FOX      TRACKI(5)=(SIGMDA-DUMMY)*C1M3 ;
          dummy=dare(dpda)
*FOX      TRACKI(6)=DPDA-DUMMY ;
          call beaminf(tracki,parbe,sigz,bbcu,imbb(i),ix,ibbc)
          if(ibeco.eq.1) then
            beamoff1=dare(tracki(1))*c1e3
            beamoff2=dare(tracki(3))*c1e3
            beamoff4=dare(tracki(2))*c1e3
            beamoff5=dare(tracki(4))*c1e3
            beamoff6=dare(tracki(6))
          else
            beamoff1=zero
            beamoff2=zero
            beamoff4=zero
            beamoff5=zero
            beamoff6=zero
          endif
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!         write(*,*) 'beamoff4 3',beamoff4
!       call wda('beamoff4',beamoff4,3,0,0,0)
!     endif
+ei
          dummy=dare(x(1))
*FOX      X(1)=TRACKI(1)*C1E3+DUMMY-BEAMOFF1 ;
          dummy=dare(x(2))
*FOX      X(2)=TRACKI(3)*C1E3+DUMMY-BEAMOFF2 ;
          dummy=dare(yp(1))
*FOX      YP(1)=TRACKI(2)*C1E3+DUMMY-BEAMOFF4 ;
          dummy=dare(yp(2))
*FOX      YP(2)=TRACKI(4)*C1E3+DUMMY-BEAMOFF5 ;
          dummy=dare(dpda)
*FOX      DPDA=TRACKI(6)+DUMMY-BEAMOFF6 ;
*FOX      DPDA1=DPDA*C1E3 ;
*FOX      Y(1)=YP(1)/(ONE+DPDA) ;
*FOX      Y(2)=YP(2)/(ONE+DPDA) ;
*FOX      EJF1=E0F*(ONE+DPDA) ;
*FOX      EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX      RV=EJ1/E0*E0F/EJF1 ;
          if(ithick.eq.1) call envada
+cd multf01
+if .not.tilt
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
*FOX  DKIP=DKI(IX,1)/(ONE+DPDA) ;
*FOX  Y(1)=Y(1)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*DKIP ;
            else
*FOX  Y(1)=Y(1)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
*FOX  SIGMDA=SIGMDA+RV*DKI(IX,1)*XL ;
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
*FOX  DKIP=DKI(IX,2)/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)-(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*DKIP ;
            else
*FOX  Y(2)=Y(2)+DKI(IX,2)*DPDA*C1E3/(ONE+DPDA) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
*FOX  SIGMDA=SIGMDA-RV*DKI(IX,2)*ZL ;
            endif
          endif
+ei
+if tilt
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
*FOX  DKIP=DKI(IX,1)/(ONE+DPDA) ;
*FOX  Y(1)=Y(1)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*
*FOX  TILTC(I)*DKIP
*FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*(ONE-TILTC(I)) ;
*FOX  Y(2)=Y(2)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*
*FOX  TILTS(I)*DKIP
*FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*TILTS(I) ;
            else
*FOX  Y(1)=Y(1)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA)*TILTC(I)
*FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*(ONE-TILTC(I)) ;
*FOX  Y(2)=Y(2)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA)*TILTS(I)
*FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*TILTS(I) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
*FOX  SIGMDA=SIGMDA+RV*DKI(IX,1)*XL ;
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
*FOX  DKIP=DKI(IX,2)/(ONE+DPDA) ;
*FOX  Y(1)=Y(1)+(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*
*FOX  TILTS(I)*DKIP
*FOX  +C1E3*DKI(IX,2)/(ONE+DPDA)*TILTS(I) ;
*FOX  Y(2)=Y(2)-(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*
*FOX  TILTC(I)*DKIP
*FOX  -C1E3*DKI(IX,2)/(ONE+DPDA)*(ONE-TILTC(I)) ;
            else
*FOX  Y(1)=Y(1)-DKI(IX,2)*DPDA*C1E3/(ONE+DPDA)*TILTS(I)
*FOX  +C1E3*DKI(IX,2)/(ONE+DPDA)*TILTS(I) ;
*FOX  Y(2)=Y(2)+DKI(IX,2)*DPDA*C1E3/(ONE+DPDA)*TILTC(I)
*FOX  -C1E3*DKI(IX,2)/(ONE+DPDA)*(ONE-TILTC(I)) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
*FOX  SIGMDA=SIGMDA-RV*DKI(IX,2)*ZL ;
            endif
          endif
+ei
+cd multf02
*FOX  YV1J=BBI(I,1)+BBI(I,2)*XL+AAI(I,2)*ZL ;
*FOX  YV2J=AAI(I,1)-BBI(I,2)*ZL+AAI(I,2)*XL ;
*FOX  CRKVE=XL ;
*FOX  CIKVE=ZL ;
+cd multf03
*FOX  CRKVEUK=CRKVE*XL-CIKVE*ZL ;
*FOX  CIKVE=CRKVE*ZL+CIKVE*XL ;
*FOX  CRKVE=CRKVEUK ;
*FOX  YV1J=YV1J+BBI(I,K)*CRKVE+AAI(I,K)*CIKVE ;
*FOX  YV2J=YV2J-BBI(I,K)*CIKVE+AAI(I,K)*CRKVE ;
+cd multf04
+if .not.tilt
*FOX  Y(1)=Y(1)+YV1J/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)+YV2J/(ONE+DPDA) ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+(TILTC(I)*YV1J-TILTS(I)*YV2J)/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)+(TILTC(I)*YV2J+TILTS(I)*YV1J)/(ONE+DPDA) ;
+ei
+cd multf05
+if .not.tilt
*FOX  Y(1)=Y(1)+BBI(I,1)/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)+AAI(I,1)/(ONE+DPDA) ;
+ei
+if tilt
*FOX  Y(1)=Y(1)+(TILTC(I)*BBI(I,1)-TILTS(I)*AAI(I,1))/(ONE+DPDA) ;
*FOX  Y(2)=Y(2)+(TILTC(I)*AAI(I,1)+TILTS(I)*BBI(I,1))/(ONE+DPDA) ;
+ei
+cd mults01
+if .not.tilt
                            y(j,1)=y(j,1)-(((dki(ix,1)/dki(ix,3))       &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)-((((dki(ix,1)/dki(ix,3))     &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)-((((dki(ix,1)/dki(ix,3))     &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd mults02
+if .not.tilt
                        y(j,1)=y(j,1)-((dki(ix,1)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)-(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)-(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd mults03
                            sigm(j)=sigm(j)+(rvf(j)*dki(ix,1))*xl        !hr03
+cd mults04
+if .not.tilt
                            y(j,2)=y(j,2)-(((dki(ix,2)/dki(ix,3))       &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)+((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)-((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei
+cd mults05
+if .not.tilt
                        y(j,2)=y(j,2)+((dki(ix,2)*dps(j))*c1e3)/(one+dps&!hr08
     &(j))                                                               !hr08
+ei
+if tilt
                            y(j,1)=(y(j,1)-(((dki(ix,2)*dps(j))*c1e3)*  &!hr08
     &tilts(i))/(one+dps(j)))                                           &!hr08
     &+((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr08
                            y(j,2)=(y(j,2)+(((dki(ix,2)*dps(j))*c1e3)*  &!hr08
     &tiltc(i))/(one+dps(j)))                                           &!hr08
     &-((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr08
+ei
+cd mults06
                            sigm(j)=sigm(j)-(rvf(j)*dki(ix,2))*zl        !hr03
+cd mults07
                          odps1=one/(one+dps(j))
                          yv1j=(bbi(i,1)+bbi(i,2)*xl)+aai(i,2)*zl        !hr03
                          yv2j=(aai(i,1)-bbi(i,2)*zl)+aai(i,2)*xl        !hr03
                          crkve=xl
                          cikve=zl
+cd mults08
                            crkveuk=crkve*xl-cikve*zl
                            cikve=crkve*zl+cikve*xl
                            crkve=crkveuk
                            yv1j=(yv1j+bbi(i,k)*crkve)+aai(i,k)*cikve    !hr03
                            yv2j=(yv2j-bbi(i,k)*cikve)+aai(i,k)*crkve    !hr03
+cd mults09
+if .not.tilt
                          y(j,1)=y(j,1)+yv1j*odps1
                          y(j,2)=y(j,2)+yv2j*odps1
+ei
+if tilt
                          y(j,1)=y(j,1)+(tiltc(i)*yv1j-tilts(i)*yv2j)   &
     &*odps1
                          y(j,2)=y(j,2)+(tiltc(i)*yv2j+tilts(i)*yv1j)   &
     &*odps1
+ei
+cd mults10
+if .not.tilt
                        y(j,1)=y(j,1)+bbi(i,1)*odps1
                        y(j,2)=y(j,2)+aai(i,1)*odps1
+ei
+if tilt
                        y(j,1)=y(j,1)+(tiltc(i)*bbi(i,1)-               &
     &tilts(i)*aai(i,1))*odps1
                        y(j,2)=y(j,2)+(tiltc(i)*aai(i,1)+               &
     &tilts(i)*bbi(i,1))*odps1
+ei
+cd multb01
+if .not.tilt
                            y(j,1)=y(j,1)+(((dki(ix,1)/dki(ix,3))       &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,1)/dki(ix,3))      &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)+(((dki(ix,1)/dki(ix,3))      &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd multb02
+if .not.tilt
                        y(j,1)=y(j,1)+((dki(ix,1)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)+(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd multb03
                            sigm(j)=sigm(j)-(rvf(j)*dki(ix,1))*xl        !hr03
+cd multb04
+if .not.tilt
                            y(j,2)=y(j,2)+(((dki(ix,2)/dki(ix,3))       &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))/(one                                 &!hr03
     &+dps(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)-((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)+((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei
+cd multb05
+if .not.tilt
                        y(j,2)=y(j,2)-((dki(ix,2)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,2)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)-(((dki(ix,2)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei                                    
+cd multb06
                            sigm(j)=sigm(j)+(rvf(j)*dki(ix,2))*zl        !hr03
+cd multb09
+if .not.tilt
                          y(j,1)=y(j,1)-yv1j*odps1
                          y(j,2)=y(j,2)-yv2j*odps1
+ei
+if tilt
                          y(j,1)=y(j,1)-(tiltc(i)*yv1j-tilts(i)*yv2j)   &
     &*odps1
                          y(j,2)=y(j,2)-(tiltc(i)*yv2j+tilts(i)*yv1j)   &
     &*odps1
+ei
+cd multb10
+if .not.tilt
                        y(j,1)=y(j,1)-bbi(i,1)*odps1
                        y(j,2)=y(j,2)-aai(i,1)*odps1
+ei
+if tilt
                        y(j,1)=y(j,1)-(tiltc(i)*bbi(i,1)-               &
     &tilts(i)*aai(i,1))*odps1
                        y(j,2)=y(j,2)-(tiltc(i)*aai(i,1)+               &
     &tilts(i)*bbi(i,1))*odps1
+ei
+cd mul4v01
+if .not.tilt
            yv(1,j)=yv(1,j)-((strack(i)*xlvj)*oidpsv(j)                 &!hr03
     &+dpsv1(j))*dki(ix,1)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
+ei
+cd mul4v02
+if .not.tilt
            yv(1,j)=yv(1,j)-strack(i)*dpsv1(j)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
+ei
+cd mul4v03
+if .not.tilt
            yv(2,j)=yv(2,j)-((strack(i)*zlvj)* oidpsv(j)                &!hr03
     &-dpsv1(j))*dki(ix,2)
+ei
+if tilt
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
+ei
+cd mul4v04
+if .not.tilt
            yv(2,j)=yv(2,j)+strack(i)*dpsv1(j)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
+ei
+cd mul4v05
+if time
              yv1j=(bbiv(1,1,i)*expt+bbiv35(1,1,i)*(1d0-expt))          &!hr03
     &+(bbiv(2,1,i)*expt+bbiv35(2,1,i)*(1d0-expt))*xlvj                 &!hr03
     &+(aaiv(2,1,i)*expt+aaiv35(2,1,i)*(1d0-expt))*zlvj                  !hr03
              yv2j=(aaiv(1,1,i)*expt+aaiv35(1,1,i)*(1d0-expt))          &!hr03
     &-(bbiv(2,1,i)*expt+bbiv35(2,1,i)*(1d0-expt))*zlvj                 &!hr03
     &+(aaiv(2,1,i)*expt+aaiv35(2,1,i)*(1d0-expt))*xlvj                  !hr03
              crkve=xlvj
              cikve=zlvj
+ei
+if .not.time
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
+ei
+cd mul4v06
+if time
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
                  yv1j=(yv1j+(bbiv(k,1,i)*expt+bbiv35(k,1,i)*(1d0-expt))&!hr03
     &*crkve)                                                           &!hr03
     &+(aaiv(k,1,i)*expt+aaiv35(k,1,i)*(1d0-expt))                      &!hr03
     &*cikve                                                             !hr03
                  yv2j=(yv2j-(bbiv(k,1,i)*expt+bbiv35(k,1,i)*(1d0-expt))&!hr03
     &*cikve)                                                           &!hr03
     &+(aaiv(k,1,i)*expt+aaiv35(k,1,i)*(1d0-expt))                      &!hr03
     &*crkve                                                             !hr03
+ei
+if .not.time
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
+ei
+cd mul4v07
+if .not.tilt
              yv(1,j)=yv(1,j)+yv1j*oidpsv(j)
              yv(2,j)=yv(2,j)+yv2j*oidpsv(j)
+ei
+if tilt
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
+ei
+cd mul4v08
+if .not.tilt
+if time
              yv(1,j)=yv(1,j)+(bbiv(1,1,i)*expt                         &
     &+bbiv35(1,1,i)*(1d0-expt))*oidpsv(j)                               !hr03
              yv(2,j)=yv(2,j)+(aaiv(1,1,i)                              &
     &+aaiv35(1,1,i)*(1d0-expt))*oidpsv(j)                               !hr03
+ei
+if .not.time
              yv(1,j)=yv(1,j)+bbiv(1,1,i)*oidpsv(j)
              yv(2,j)=yv(2,j)+aaiv(1,1,i)*oidpsv(j)
+ei
+ei
+if tilt
+if time
              yv(1,j)=yv(1,j)+(tiltc(i)*(bbiv(1,1,i)*expt               &
     &+bbiv35(1,1,i)*(1d0-expt))-                                       &!hr03
     &tilts(i)*(aaiv(1,1,i)*expt+aaiv35(1,1,i)*(1d0-expt)))             &!hr03
     &*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*(aaiv(1,1,i)*expt               &
     &+aaiv35(1,1,i)*(1d0-expt))+                                       &!hr03
     &tilts(i)*(bbiv(1,1,i)*expt+bbiv35(1,1,i)*(1d0-expt)))             &!hr03
     &*oidpsv(j)
+ei
+if .not.time
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
+ei
+ei
+cd mul6v01
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
+cd mul6v02
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
+cd multl01
+if .not.tilt
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)+qu*xl)-dppi*dpp                               !hr03
+ei
+if tilt
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
+ei
+cd multl02
+if .not.tilt
              t(i,2)=t(i,2)+qu*t(i,1)
+ei
+if tilt
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
+ei
+cd multl03
+if .not.tilt
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)-dppi*dpp
+ei
+if tilt
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
+ei
+cd multl04
+if .not.tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,4)=t(1,4)-qu*zl+dppi*dpp
+ei
+if tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
+ei
+cd multl05
+if .not.tilt
              t(i,4)=t(i,4)-qu*t(i,3)
+ei
+if tilt
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
+ei
+cd multl06
+if .not.tilt
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,4)=t(1,4)+dppi*dpp
+ei
+if tilt
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
+ei
+cd multl07a
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
+cd multl07b
          qu=bb(2)
          qv=-1d0*aa(2)
          dyy1=bb(1)+bb(2)*crkve+aa(2)*cikve
          dyy2=aa(1)-bb(2)*cikve+aa(2)*crkve
+cd multl07c
            l1=l-1
            qu=qu+dble(l1)*(bb(l)*crkve+aa(l)*cikve)                     !hr03
            qv=qv+dble(l1)*(bb(l)*cikve-aa(l)*crkve)                     !hr03
            crkveuk=crkve*xl-cikve*zl
            cikve=crkve*zl+cikve*xl
            crkve=crkveuk
            dyy1=(dyy1+bb(l)*crkve)+aa(l)*cikve                          !hr03
            dyy2=(dyy2-bb(l)*cikve)+aa(l)*crkve                          !hr03
+cd multl07d
          qu=zero
          qv=zero
          dyy1=bb(1)
          dyy2=aa(1)
+cd multl07e
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
+cd multl08
+if .not.tilt
            t(6,2)=t(6,2)-(qu*xl+dppi)/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-((qu*xl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
            t(6,4)=(t(6,4)-((qu*xl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
+ei
+cd multl09
+if .not.tilt
            t(6,2)=t(6,2)-dppi/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
            t(6,4)=(t(6,4)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)
+ei
+cd multl10
+if .not.tilt
            t(6,4)=t(6,4)+(qu*zl+dppi)/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-((qu*zl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
            t(6,4)=(t(6,4)+((qu*zl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
+ei
+cd multl11
+if .not.tilt
            t(6,4)=t(6,4)+dppi/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
            t(6,4)=(t(6,4)+(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
+ei
+cd multl12
+if .not.tilt
            if(iv.eq.2) ekk=(((((bb(4)+                                 &!hr03
     &4d0*(bb(5)*cr(2)+aa(5)*ci(2)))+10d0*                              &!hr03
     &(bb(6)*cr(3)+aa(6)*ci(3)))+20d0*(bb(7)*cr(4)+aa(7)*ci(4)))+35d0*  &!hr03
     &(bb(8)*cr(5)+aa(8)*ci(5)))+56d0*(bb(9)*cr(6)+aa(9)*ci(6)))+84d0*  &!hr03
     &(bb(10)*cr(7)+aa(10)*ci(7))                                        !hr03
           if(iv.eq.3) ekk=(((bb(6)+6d0*(bb(7)*cr(2)+aa(7)*ci(2)))+21d0*&!hr03
     &(bb(8)*cr(3)+aa(8)*ci(3)))+56d0*(bb(9)*cr(4)+aa(9)*ci(4)))+126d0* &!hr03
     &(bb(10)*cr(5)+aa(10)*ci(5))                                        !hr03
            if(iv.eq.4) ekk=(bb(8)+8d0*(bb(9)*cr(2)+aa(9)*ci(2)))+36d0* &!hr03
     &(bb(10)*cr(3)+aa(10)*ci(3))
            if(iv.eq.5) ekk=bb(10)
            call detune(iv,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
            tiltck=tiltc(k)**2-tilts(k)**2                               !hr03
            tiltsk=(two*tiltc(k))*tilts(k)                               !hr03
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck4=tiltckuk
            tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
            tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck6=tiltckuk
            tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
            tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck8=tiltckuk
            tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
            tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck10=tiltckuk
            if(iv.eq.2) then
              ekk= ((((((((((((tiltck4* bb(4)                     -     &!hr03
     &tiltsk4*(             aa(4)       ))+                             &!hr03
     &4d0  *tiltck4*(bb(5) *cr(2)+aa(5) *ci(2)))+                       &!hr03
     &4d0  *tiltsk4*(bb(5) *ci(2)-aa(5) *cr(2)))+                       &!hr03
     &10d0 *tiltck4*(bb(6) *cr(3)+aa(6) *ci(3)))+                       &!hr03
     &10d0 *tiltsk4*(bb(6) *ci(3)-aa(6) *cr(3)))+                       &!hr03
     &20d0 *tiltck4*(bb(7) *cr(4)+aa(7) *ci(4)))+                       &!hr03
     &20d0 *tiltsk4*(bb(7) *ci(4)-aa(7) *cr(4)))+                       &!hr03
     &35d0 *tiltck4*(bb(8) *cr(5)+aa(8) *ci(5)))+                       &!hr03
     &35d0 *tiltsk4*(bb(8) *ci(5)-aa(8) *cr(5)))+                       &!hr03
     &56d0 *tiltck4*(bb(9) *cr(6)+aa(9) *ci(6)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltsk4*(bb(10)*ci(7)-aa(10)*cr(7))
            endif
            if(iv.eq.3) then
              ekk= ((((((((tiltck6* bb(6)                     -         &!hr03
     &tiltsk6*(             aa(6)       ))+                             &!hr03
     &6d0  *tiltck6*(bb(7) *cr(2)+aa(7) *ci(2)))+                       &!hr03
     &6d0  *tiltsk6*(bb(7) *ci(2)-aa(7) *cr(2)))+                       &!hr03
     &21d0 *tiltck6*(bb(8) *cr(3)+aa(8) *ci(3)))+                       &!hr03
     &21d0 *tiltsk6*(bb(8) *ci(3)-aa(8) *cr(3)))+                       &!hr03
     &56d0 *tiltck6*(bb(9) *cr(4)+aa(9) *ci(4)))+                       &!hr03
     &56d0 *tiltsk6*(bb(9) *ci(4)-aa(9) *cr(4)))+                       &!hr03
     &126d0*tiltck6*(bb(10)*cr(5)+aa(10)*ci(5)))+                       &!hr03
     &126d0*tiltsk6*(bb(10)*ci(5)-aa(10)*cr(5))
            endif
            if(iv.eq.4) then
              ekk= ((((tiltck8* bb(8)                     -             &!hr03
     &tiltsk8*(             aa(8)       ))+                             &!hr03
     &8d0  *tiltck8*(bb(9) *cr(2)+aa(9) *ci(2)))+                       &!hr03
     &8d0  *tiltsk8*(bb(9) *ci(2)-aa(9) *cr(2)))+                       &!hr03
     &36d0 *tiltck8*(bb(10)*cr(3)+aa(10)*ci(3)))+                       &!hr03
     &36d0 *tiltsk8*(bb(10)*ci(3)-aa(10)*cr(3))
            endif
            if(iv.eq.5) then
              ekk= tiltck10*bb(10)-tiltsk10*aa(10)
            endif
            call detune(iv,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd multl13
          l1=l-1
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
          if(l.gt.2) then
            cxzyrr=cxzyr*cxzr-cxzyi*cxzi
            cxzyi=cxzyr*cxzi+cxzyi*cxzr
            cxzyr=cxzyrr
            cr(l)=cxzyr
            ci(l)=cxzyi
          endif
          dyy1=(dyy1+bb(l)*cr(l))+aa(l)*ci(l)                            !hr03
          dyy2=(dyy2-bb(l)*ci(l))+aa(l)*cr(l)                            !hr03
          if(l.gt.1.and.ium.ne.1) then
            qu=qu+dble(l1)*(bb(l)*cr(l1)+aa(l)*ci(l1))                   !hr03
            qv=qv+dble(l1)*(bb(l)*ci(l1)-aa(l)*cr(l1))                   !hr03
          endif
+cd multu01
+if .not.tilt
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            y(1,1)=(y(1,1)+qu*xl)-((dpp*c1e3)*dki(ix,1))/(one+dpp)       !hr03
+ei
+if tilt
            qu=(((-1d0*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            y(1,1)=(y(1,1)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tiltc(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
            y(1,2)=(y(1,2)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
+ei
+cd multu02
+if .not.tilt
              y(j,1)=y(j,1)+qu*x(j,1)
+ei
+if tilt
              y(j,1)=y(j,1)+(qu*x(j,1))*tiltc(k)                         !hr03
              y(j,2)=y(j,2)+(qu*x(j,2))*tilts(k)                         !hr03
+ei
+cd multu03
+if .not.tilt
            y(1,1)=y(1,1)-((dki(ix,1)*dpp)/(one+dpp))*c1e3               !hr03
+ei
+if tilt
            y(1,1)=(y(1,1)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
            y(1,2)=(y(1,2)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
+ei
+cd multu04
+if .not.tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            y(1,2)=(y(1,2)-qu*zl)+((dpp*c1e3)*dki(ix,2))/(one+dpp)       !hr03
+ei
+if tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            y(1,1)=(y(1,1)+(qu*zl-((dpp*c1e3)*dki(ix,2))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,2))/(one+dpp))*tilts(k)                             !hr03
            y(1,2)=(y(1,2)+(((dpp*c1e3)*dki(ix,2))                      &!hr03
     &/(one+dpp)-qu*zl)*tiltc(k))                                       &!hr03
     &-((c1e3*dki(ix,2))/(one+dpp))*(one-tiltc(k))                       !hr03
+ei
+cd multu05
+if .not.tilt
              y(j,2)=y(j,2)-qu*x(j,2)
+ei
+if tilt
              y(j,1)=y(j,1)+(qu*x(j,1))*tilts(k)                         !hr03
              y(j,2)=y(j,2)-(qu*x(j,2))*tiltc(k)                         !hr03
+ei
+cd multu06
+if .not.tilt
            y(1,2)=y(1,2)+((dki(ix,2)*dpp)/(one+dpp))*c1e3               !hr03
+ei
+if tilt
            y(1,1)=(y(1,1)-(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((dki(ix,2)/(one+dpp))*c1e3)*tilts(k)                             !hr03
            y(1,2)=(y(1,2)+(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &-((dki(ix,2)/(one+dpp))*c1e3)*(one-tiltc(k))                       !hr03
+ei
+cd bnlin
!GRDRHIC
!GRD-2007
!GRD-2007 REQUIRED FOR RHIC BEAM-BEAM STUDIES
!GRD-2007 OPTION IS ACTIVATED IF "LHC" PARAMETER IN BEAM-BEAM
!GRD-2007 BLOCK IN FORT.3 IS SET TO 9
!GRD-042008
           if(lhc.eq.9) then
! Write a line to fort.10 for all platforms (including LSF)
+if boinc
             if (.not.restart) then
               write(10,'(a10,a60)') 'title     ',sixtit(1:60)
               endfile (10,iostat=ierro)
               backspace (10,iostat=ierro)
               bnlrec=bnlrec+1
             endif
+ei
+if .not.boinc
             write(10,'(a60)') sixtit(1:60)
             endfile (10,iostat=ierro)
             backspace (10,iostat=ierro)
+ei
             call bnlrdis(20000)
               write(lout,*) 'Sample number 1'
!TEST
!ERIC              napx=napx00
               do j = 1, napx
                 pstop(nlostp(j))=.false.
               enddo
               do j = 1, napx
                  xv(1,j)  = 1e3*myx(j)+torbx(1)
                  yv(1,j)  = 1e3*myxp(j)+torbxp(1)
                  xv(2,j)  = 1e3*myy(j)+torby(1)
                  yv(2,j)  = 1e3*myyp(j)+torbyp(1)
                  sigmv(j) = mys(j)
                  ejv(j)   = myp(j)
                  ejfv(j)=sqrt(ejv(j)**2-pma**2)                         !hr03
                  rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
                  dpsv(j)=(ejfv(j)-e0f)/e0f
                  oidpsv(j)=one/(one+dpsv(j))
                  dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                      !hr03
cc2008
                  namepart(j) = samplenumber*100 + j
cc2008
               enddo
           endif
!GRD-2007
!GRD-042008
!GRDRHIC
+cd bnlout
!GRD-042008
!GRDRHIC
!GRD-2007
!GRD-2007 ADDITIONAL OUTPUT FILE FOR MULTI-PARTICLES BEAM-BEAM STUDIES
!GRD-2007
          do j=1,napx
            if(pstop(nlostp(j))) goto 599
!GRD-042008
+if debug
!           if (n.ge.990) then
!             write(99,*) 'before j ',j,xv(1,j),xv(2,j),yv(1,j),yv(2,j)
!             endfile (99,iostat=ierro)
!             backspace (99,iostat=ierro)
!           endif
+ei
            x_temp=(xv(1,j)-torbx(i-1))*1d-3                             !hr03
            y_temp=(xv(2,j)-torby(i-1))*1d-3                             !hr03
            xp_temp=(yv(1,j)-torbxp(i-1))*1d-3                           !hr03
            yp_temp=(yv(2,j)-torbyp(i-1))*1d-3                           !hr03
            twojx = (tbetax(i-1)*(xp_temp**2)+                          &!hr03
     &               ((2d0*talphax(i-1))*x_temp)*xp_temp)+              &!hr03
     &               ((1d0+talphax(i-1)**2)/tbetax(i-1))*(x_temp**2)     !hr03
            twojy = (tbetay(i-1)*(yp_temp**2)+                          &!hr03
     &               ((2d0*talphay(i-1))*y_temp)*yp_temp)+              &!hr03
     &               ((1d0+talphay(i-1)**2)/tbetay(i-1))*(y_temp**2)     !hr03
            twojr = sqrt(twojx**2+twojy**2)
            if(n.eq.1) then
               if(j.eq.1) then
+if debug
!                 write(*,*) 'coucou'
+ei
                  limit_twojx = 25d0*(2.5d-6/(e0/pma))                   !hr03
                  limit_twojy = 25d0*(2.5d-6/(e0/pma))                   !hr03
                  limit_twojr = 25d0*(2.5d-6/(e0/pma))                   !hr03
               endif
            endif
            if(twojr.le.limit_twojr) then
              sumtwojx=sumtwojx+twojx
              sumtwojy=sumtwojy+twojy
              sumsquarex=sumsquarex+x_temp**2
              sumsquarey=sumsquarey+y_temp**2
              n_nocut=n_nocut +1
            else
              n_cut=n_cut+1
+if .not.boinc
              write(53,'(i8,1x,i8)') n,namepart(j)
+ei
+if boinc
              write(10,'(a10,i8,1x,i8)') 'lostID    ',n,namepart(j)
+ei
+if cr
+if .not.boinc
              endfile (53,iostat=ierro)
              backspace (53,iostat=ierro)
              bllrec=bllrec+1
+ei
+if boinc
              endfile (10,iostat=ierro)
              backspace (10,iostat=ierro)
              bnlrec=bnlrec+1
+ei
+ei
            endif
!GRD-042008
 599        continue
          enddo
+if debug
!     write(99,*) 'after  update bnl n ',n
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napx)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
!GRD-042008
          if(mod(n,nwr(3)).eq.0) then
            write(lout,*) 'dumping stats at turn number ',n
+if crlibm
! Use dtostr for correct binary decimal conversion
           l1=1
+if .not.boinc
! use Unit 52 
+ei 
+if boinc
! use Unit 10 and initialise string with header
            ch(l1:l1+10)='output    '           
            l1=l1+11
+ei
! Now do conversions
! First the 3 integers using internal read
            write(ch(l1:l1+8),'(i8)') n
            l1=l1+9
            write(ch(l1:l1+9),'(1x,i8)') n_cut
            l1=l1+10
            write(ch(l1:l1+9),'(1x,i8)') n_nocut
            l1=l1+10
! and now the four double precision
! We return the length of the string (always 24)
            errno=dtostr(sumsquarex,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumsquarey,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumtwojx,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumtwojy,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
+if .not.boinc
! write string to 52
            write(52,'(a)') ch(1:l1-1)
+ei
+if boinc 
! write string to 10
            write(10,'(a)') ch(1:l1-1)
+ei
+ei
+if .not.crlibm
+if .not.boinc
            write(52,'(i8,2(1x,i8),4(1x,e15.8))')                       &
+ei
+if boinc
            write(10,'(a10,i8,2(1x,i8),4(1x,e15.8))')                   &
     &'output    ',                                                     &
+ei
     &n,n_cut,n_nocut,                                                  &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy
+ei
+if cr
+if .not.boinc
      endfile (52,iostat=ierro)
      backspace (52,iostat=ierro)
+ei
+if boinc
      endfile (10,iostat=ierro)
      backspace (10,iostat=ierro)
+ei
            bnlrec=bnlrec+1
+ei
            sumsquarex=zero
            sumsquarey=zero
            sumtwojx=zero
            sumtwojy=zero
            n_cut=0
            n_nocut=0
!05-2008
!
          endif
!GRD-042008
!GRD-2007
!GRD-042008
!GRDRHIC
+cd bnltwiss
!GRDRHIC
!GRD-042008
!GRD-2007
            if(n.eq.1.and.lhc.eq.9) then
               totals=totals+strack(i)
               sampl(i)=totals
+if crlibm
! Use dtostr for correct binary decimal conversion
               l1=1
+if .not.boinc
! Use Unit 51
+ei
+if boinc
! Use Unit 10 and initialise string with header
               ch(l1:l1+10)='SixTwiss  '
               l1=l1+11
+ei
! Now do the conversions
! A 5-digit integer, followed by 7 double precision numbers
               write(ch(l1:l1+5),'(i5)') i
               l1=l1+6
! and now the 7 double precision
! We return the length of the string (always 24)
            errno=dtostr(sampl(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(tbetax(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(tbetay(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(talphax(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(talphay(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(torbx(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(torby(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
+if .not.boinc
! write string to 51
            write(51,'(a)') ch(1:l1-1)
+ei
+if boinc
! write string to 10
            write(10,'(a)') ch(1:l1-1)
+ei
+ei
+if .not.crlibm
+if .not.boinc
               write(51,'(i5,(1x,f15.10),6(1x,f20.13))')                &
+ei
+if boinc
                 write(10,'(a10,i5,(1x,f15.10),6(1x,f20.13))')          &
     &'SixTwiss  ',                                                     &
+ei
     &i,sampl(i),tbetax(i),tbetay(i),talphax(i),talphay(i),torbx(i),    &
     &torby(i)
+ei
+if boinc
               bnlrec=bnlrec+1
               endfile (10,iostat=ierro)
               backspace (10,iostat=ierro)
+ei
+if .not.boinc
               endfile (51,iostat=ierro)
               backspace (51,iostat=ierro)
+ei
            endif
!GRDRHIC
!GRD-042008
!GRD-2007
+cd thcklin
+if debug
!     if (i.ge.673.and.j.le.2) then
!       call warr('bl30 i j',xv(1,2),i,j,0,0)
!       call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
+ei
                puxve1=xv(1,j)
                puzve1=yv(1,j)
                puxve2=xv(2,j)
                puzve2=yv(2,j)
         sigmv(j)=(((((sigmv(j)+as(1,1,j,jx))+puxve1*((as(2,1,j,jx)+ as &!hr03
     &(4,1,j,jx)*puzve1)+as(5,1,j,jx)*puxve1))+ puzve1*(as              &!hr03
     &(3,1,j,jx)+as(6,1,j,jx)*puzve1))                                  &!hr03
     &+as(1,2,j,jx))+puxve2*(as(2,2,j,jx)+ as                           &!hr03
     &(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2))+ puzve2*(as               &!hr03
     &(3,2,j,jx)+as(6,2,j,jx)*puzve2)                                    !hr03
        xv(1,j)=(al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(5,1,j,jx)                                                         !hr03
        xv(2,j)=(al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(5,2,j,jx)                                                         !hr03
        yv(1,j)=(al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(6,1,j,jx)                                                         !hr03
        yv(2,j)=(al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(6,2,j,jx)                                                         !hr03
+if debug
!     if (i.ge.673.and.j.le.2) then
!       call warr('al30 i j',xv(1,2),i,j,0,0)
!       call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
+ei
+cd sqrtfox0
+if rvet
*FOX  RVET=C1E3*PMA*PMA*(TWO+DPDA)*DPDA/E0/(ONE+DPDA) ;
*FOX  RVET=RVET/(E0*(ONE+DPDA)+SQRT(E0*E0+E0F*E0F*(TWO*DPDA+
*FOX  DPDA*DPDA))) ;
+ei
+if .not.rvet
!
+ei
+cd sqrtfox
+if rvet
*FOX  EL(JX)*(RVET-C5M4*RV*(Y(1)*Y(1)+Y(2)*Y(2))) ;
+ei
+if fast
*FOX  EL(JX)*(C1E3-RV*(C1E3+(Y(1)*Y(1)+Y(2)*Y(2))*C5M4)) ;
+ei
+if .not.fast.and..not.rvet
*FOX  EL(JX)*(C1E3-RV*SQRT(C1E6+Y(1)*Y(1)+Y(2)*Y(2))) ;
+ei
+cd sqrts
+if .not.fast
     &sqrt((c1e6+y(j,1)**2)+                                            &!hr03
     &y(j,2)**2))                                                        !hr03
+ei
+if fast
     &(c1e3+(y(j,1)**2+                                                 &!hr03
     &y(j,2)**2)*c5m4))                                                  !hr03
+ei
+cd sqrtv
+if rvet
      rvet(j)=((((c1e3*pma**2)*(two+dpsv(j)))*dpsv(j))/e0)/(one+dpsv(j))
            rvet(j)=rvet(j)/(e0*(one+dpsv(j))+                          &!hr03
     &sqrt(e0**2+e0f**2*(two*dpsv(j)+dpsv(j)**2)))                       !hr03
            sigmv(j)=sigmv(j)+stracki*(rvet(j)-(c5m4*rvv(j))*(yv(1,j)   &!hr03
     &**2+yv(2,j)**2))                                                   !hr03
+ei
+if fast
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &!hr03
     &**2+yv(2,j)**2)*c5m4))                                             !hr03
+ei
+if .not.fast.and..not.rvet
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt((c1e6+yv(1,j)   &!hr03
     &**2)+yv(2,j)**2))                                                  !hr03
+ei

+cd dumplines
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
               if (   (n.ge.dumpfirst(0)) .and.
     &              ( (n.le.dumplast(0)) .or. (dumplast(0).eq.-1) )
     &              ) then
                  call dump_beam_population( n, i, ix, dumpunit(0),
     &                 dumpfmt(0), ldumphighprec )
               endif
            endif
          endif
          if ( ktrack(i) .ne. 1 ) then
             ! The next "if" is only safe for SINGLE ELEMENTS, not BLOC where ix<0.
             if ( ldump(ix) ) then
                ! dump at this precise SINGLE ELEMENT
                if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
                   if (   (n.ge.dumpfirst(ix)) .and. 
     &                 ( (n.le.dumplast(ix)) .or. (dumplast(ix).eq.-1) )
     &                ) then
                      call dump_beam_population( n, i, ix, dumpunit(ix),
     &                     dumpfmt(ix), ldumphighprec )
                   endif
                endif
             endif
          endif

+cd lostpart
          llost=.false.
          do j=1,napx
             llost=llost.or.                                            &
     &abs(xv(1,j)).gt.aper(1).or.abs(xv(2,j)).gt.aper(2)
          enddo
          if (llost) then
             kpz=abs(kp(ix))
             if(kpz.eq.2) then
                call lostpar3(i,ix,nthinerr)
                if(nthinerr.ne.0) return
             elseif(kpz.eq.3) then
                call lostpar4(i,ix,nthinerr)
                if(nthinerr.ne.0) return
             else
                call lostpar2(i,ix,nthinerr)
                if(nthinerr.ne.0) return
             endif
          endif
+cd lost1a
      ilostch=0
      do 10 j=1,napx
        if(abs(xv(1,j)).gt.aper(1).or.abs(xv(2,j)).gt.aper(2).or.       &
!     &isnan(xv(1,j),xv(1,j)).or.isnan(xv(2,j),xv(2,j))) then
     &myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))) then
          ilostch=1
          pstop(nlostp(j))=.true.
        endif
  10  continue
      do 20 j=1,napx
        if(pstop(nlostp(j))) then
          aperv(nlostp(j),1)=aper(1)
          aperv(nlostp(j),2)=aper(2)
+cd lost1b
      ilostch=0
      do 10 j=1,napx
        if(abs(xv(1,j)).gt.apx(ix).or.abs(xv(2,j)).gt.apz(ix).or.       &
!     &isnan(xv(1,j),xv(1,j)).or.isnan(xv(2,j),xv(2,j))) then
     &myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))) then
          ilostch=1
          pstop(nlostp(j))=.true.
        endif
  10  continue
      do 20 j=1,napx
        if(pstop(nlostp(j))) then
          aperv(nlostp(j),1)=apx(ix)
          aperv(nlostp(j),2)=apz(ix)
+cd lost1c
      ilostch=0
      do 10 j=1,napx
        if(xv(1,j)**2*ape(1,ix)+xv(2,j)**2*ape(2,ix).gt.                &!hr03
     &ape(3,ix).or.                                                     &
!     &isnan(xv(1,j),xv(1,j)).or.isnan(xv(2,j),xv(2,j))) then
     &myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))) then
          ilostch=1
          pstop(nlostp(j))=.true.
        endif
  10  continue
      do 20 j=1,napx
        if(pstop(nlostp(j))) then
          aperv(nlostp(j),1)=apx(ix)
          aperv(nlostp(j),2)=apz(ix)
+cd lost2a
          iv(nlostp(j))=i
          ixv(nlostp(j))=ix
+cd lost2
          xvl(1,nlostp(j))=xv(1,j)
          xvl(2,nlostp(j))=xv(2,j)
          yvl(1,nlostp(j))=yv(1,j)
          yvl(2,nlostp(j))=yv(2,j)
          dpsvl(nlostp(j))=dpsv(j)
          ejvl(nlostp(j))=ejv(j)
          sigmvl(nlostp(j))=sigmv(j)
          numxv(nlostp(j))=numx
          nnumxv(nlostp(j))=numx
+cd lost3a
          if(mod(nlostp(j),2).eq.one) then
            write(lout,10000) nlostp(j),nms(nlostp(j))*izu0,
     &dp0v(nlostp(j)),numxv(nlostp(j)),abs(xvl(1,nlostp(j))),           &
     &aperv(nlostp(j),1),abs(xvl(2,nlostp(j))),                         &
     &aperv(nlostp(j),2)
          else
            write(lout,10000) nlostp(j),nms(nlostp(j)-1)*izu0,
     &dp0v(nlostp(j)-1),numxv(nlostp(j)),abs(xvl(1,nlostp(j))),         &
     &aperv(nlostp(j),1),abs(xvl(2,nlostp(j))),                         &
     &aperv(nlostp(j),2)
          endif
+cd lost3b
          if(mod(nlostp(j),2).eq.one) then
            write(lout,10000) nlostp(j),nms(nlostp(j))*izu0,
     &dp0v(nlostp(j)),numxv(nlostp(j)),iv(nlostp(j)),                   &
     &abs(xvl(1,nlostp(j))),aperv(nlostp(j),1),                         &
     &abs(xvl(2,nlostp(j))),aperv(nlostp(j),2),                         &
     &ixv(nlostp(j)),kz(ixv(nlostp(j))),bez(ixv(nlostp(j)))
          else
            write(lout,10000) nlostp(j),nms(nlostp(j)-1)*izu0,
     &dp0v(nlostp(j)-1),numxv(nlostp(j)),iv(nlostp(j)),                 &
     &abs(xvl(1,nlostp(j))),aperv(nlostp(j),1),                         &
     &abs(xvl(2,nlostp(j))),aperv(nlostp(j),2),                         &
     &ixv(nlostp(j)),kz(ixv(nlostp(j))),bez(ixv(nlostp(j)))
          endif
+cd lost4
        endif
   20 continue
      lnapx=napx
      do 30 j=napx,1,-1
        if(pstop(nlostp(j))) then
          if(j.ne.lnapx) then
            do 35 jj=j,lnapx-1
              jj1=jj+1
              nlostp(jj)=nlostp(jj1)
              xv(1,jj)=xv(1,jj1)
              xv(2,jj)=xv(2,jj1)
              yv(1,jj)=yv(1,jj1)
              yv(2,jj)=yv(2,jj1)
+if bnlelens
!GRDRHIC
!GRD-042008
              namepart(jj)=namepart(jj1)
!GRDRHIC
!GRD-042008
+ei
              dpsv(jj)=dpsv(jj1)
              sigmv(jj)=sigmv(jj1)
              ejfv(jj)=ejfv(jj1)
              ejv(jj)=ejv(jj1)
              rvv(jj)=rvv(jj1)
+if rvet
              rvet(jj)=rvet(jj1)
+ei
              oidpsv(jj)=oidpsv(jj1)
              dpsv1(jj)=dpsv1(jj1)
              clo6v(1,jj)=clo6v(1,jj1)
              clo6v(2,jj)=clo6v(2,jj1)
              clo6v(3,jj)=clo6v(3,jj1)
              clop6v(1,jj)=clop6v(1,jj1)
              clop6v(2,jj)=clop6v(2,jj1)
              clop6v(3,jj)=clop6v(3,jj1)
!--beam-beam element
              di0xs(jj)=di0xs(jj1)
              dip0xs(jj)=dip0xs(jj1)
              di0zs(jj)=di0zs(jj1)
              dip0zs(jj)=dip0zs(jj1)
              do 210 ib2=1,6
                do 210 ib3=1,6
                  tasau(jj,ib2,ib3)=tasau(jj1,ib2,ib3)
  210         continue
   35       continue
          endif
          lnapx=lnapx-1
        endif
   30 continue
      if(lnapx.eq.0) then
        write(lout,*) ''
        write(lout,*) ''
        write(lout,*) '***********************'
        write(lout,*) '** ALL PARTICLE LOST **'
        write(lout,*) '**   PROGRAM STOPS   **'
        write(lout,*) '***********************'
        write(lout,*) ''
        write(lout,*) ''
        nthinerr=3001
        nnuml=numl
        return
      endif
      if(ithick.eq.1.and.ilostch.eq.1) then
+if cr
+if debug
!       write(93,*) 'ERIC lostpar??? calling synuthck!!!'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
+ei
        call synuthck
      endif
      napx=lnapx
      return
+cd lost5a
10000 format(t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,       &
     &' RANDOM SEED ',i8,/ t10,' MOMENTUM DEVIATION ',g12.5,            &
     &' LOST IN REVOLUTION ',i8,/ t10,'HORIZ:  AMPLITUDE = ',f15.3,     &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',f15.3,         &
     &'   APERTURE = ',f15.3/)
      end
+cd lost5b
10000 format(t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,       &
     &' RANDOM SEED ',i8, ' MOMENTUM DEVIATION ',g12.5/ t10,            &
     &' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,                 &
     &'HORIZ:  AMPLITUDE = ',f15.3,'RE-APERTURE = ',f15.3/ t10,         &
     &'VERT:   AMPLITUDE = ',f15.3,'RE-APERTURE = ',f15.3/ t10,         &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
      end
+cd lost5c
10000 format(t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,       &
     &' RANDOM SEED ',i8, ' MOMENTUM DEVIATION ',g12.5/ t10,            &
     &' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,                 &
     &'HORIZ:  AMPLITUDE = ',f15.3,'EL-APERTURE = ',f15.3/ t10,         &
     &'VERT:   AMPLITUDE = ',f15.3,'EL-APERTURE = ',f15.3/ t10,         &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
      end
+cd umlalid
          iwrite=0
          if(nlin.eq.0) then
            iwrite=1
          else
            do ii=1,nlin
              if(typ.eq.bezl(ii)) iwrite=1
            enddo
          endif
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
*FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag1.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          else
            call dacop(dpda1,damap(5))
            do j1=1,4
              do ii=1,4
                jj(ii)=1
                call dapek(damap(j1),jj,rdd(j1,ii))
                jj(ii)=0
              enddo
            enddo
            jj(5)=1
            do j1=1,4
              call dapek(damap(j1),jj,rdd(j1,5))
            enddo
            jj(5)=0
            do j1=1,2
              ii=2*j1
              d(j1)=(((rdd(ii-1,1)*dicu(1)+rdd(ii-1,2)*dicu(2))+        &!hr03
     &rdd(ii-1,3)*dicu(3))+rdd(ii-1,4)*dicu(4))+rdd(ii-1,5)              !hr03
              dp(j1)=(((rdd(ii,1)*dicu(1)+rdd(ii,2)*dicu(2))+           &!hr03
     &rdd(ii,3)*dicu(3))+rdd(ii,4)*dicu(4))+rdd(ii,5)                    !hr03
            enddo
          endif
          call dacct(damap,nvar,aa2,nvar,damap,nvar)
!         calculate linear 6D optics parameter for each element
!         by calculating the matrix of eigenvectors (tas)
          do j=1,ndimf
            ii=2*j
            if(j.eq.1) then
              i2=4
              i3=6
            elseif(j.eq.2) then
              i2=2
              i3=6
            elseif(j.eq.3) then
              i2=2
              i3=4
            endif
            jj(ii-1)=1
            call dapek(damap(ii-1),jj,angp(1,ii-1))
            call dapek(damap(ii),jj,au(ii,ii-1))
            jj(ii-1)=0
            jj(ii)=1
            call dapek(damap(ii-1),jj,angp(1,ii))
            call dapek(damap(ii),jj,au(ii,ii))
            jj(ii)=0
            jj(i2-1)=1
            call dapek(damap(ii-1),jj,au(i2-1,i2-1))
            call dapek(damap(ii),jj,au(i2,i2-1))
            jj(i2-1)=0
            jj(i2)=1
            call dapek(damap(ii-1),jj,au(i2-1,i2))
            call dapek(damap(ii),jj,au(i2,i2))
            jj(i2)=0
            jj(i3-1)=1
            call dapek(damap(ii-1),jj,au(i3-1,i3-1))
            call dapek(damap(ii),jj,au(i3,i3-1))
            jj(i3-1)=0
            jj(i3)=1
            call dapek(damap(ii-1),jj,au(i3-1,i3))
            call dapek(damap(ii),jj,au(i3,i3))
            jj(i3)=0
!    store tas matrix (normalisation of phase space) and closed orbit for FMA analysis - variable added to DUMP block common variables (dbdump)
!    units dump_tas: mm,mrad,mm,mrad,mm,1.e-3
            if(fma_flag) then
              if(ic(i)-nblo.gt.0) then !check if structure element is a block
                if(ldump(ic(i)-nblo)) then !check if particles are dumped at this element
                  dump_tas(ic(i)-nblo,ii-1,ii-1)=angp(1,ii-1)
                  dump_tas(ic(i)-nblo,ii-1,ii  )=angp(1,ii)
                  dump_tas(ic(i)-nblo,ii  ,ii-1)=au(ii,ii-1)
                  dump_tas(ic(i)-nblo,ii  ,ii  )=au(ii,ii  )
                  dump_tas(ic(i)-nblo,ii-1,i2-1)=au(i2-1,i2-1)
                  dump_tas(ic(i)-nblo,ii  ,i2-1)=au(i2  ,i2-1)
                  dump_tas(ic(i)-nblo,ii-1,i2  )=au(i2-1,i2  )
                  dump_tas(ic(i)-nblo,ii  ,i2  )=au(i2  ,i2  )
                  dump_tas(ic(i)-nblo,ii-1,i3-1)=au(i3-1,i3-1)
                  dump_tas(ic(i)-nblo,ii  ,i3-1)=au(i3  ,i3-1)
                  dump_tas(ic(i)-nblo,ii-1,i3  )=au(i3-1,i3  )
                  dump_tas(ic(i)-nblo,ii  ,i3  )=au(i3  ,i3  )
!    closed orbit in canonical variables x,px,y,py,sig,delta [mm,mrad,mm,mrad,mm,1.e-3]
!    convert to x,xp,y,yp,sig,delta [mm,mrad,mm,mrad,mm,1]
!     -> check units used in dump_clo (is x' or px used?) 
                  dump_clo(ic(i)-nblo,2*j-1)=c(j)
                  if (j.eq.3) then !dp/p
                    dump_clo(ic(i)-nblo,2*j)  =cp(j)*c1m3
                  else ! xp,yp
                    dump_clo(ic(i)-nblo,2*j)  =cp(j)/(one+cp(3)*c1m3)
                  endif
                endif
              endif
            endif
            b1(j)=angp(1,ii-1)**2+angp(1,ii)**2                          !hr08
            b2(j)=au(i2-1,i2-1)**2+au(i2-1,i2)**2                        !hr08
            b3(j)=au(i3-1,i3-1)**2+au(i3-1,i3)**2                        !hr08
            al1(j)=-1d0*(angp(1,ii-1)*au(ii,ii-1)+angp(1,ii)*au(ii,ii))  !hr03
           al2(j)=-1d0*(au(i2-1,i2-1)*au(i2,i2-1)+au(i2-1,i2)*au(i2,i2)) !hr03
           al3(j)=-1d0*(au(i3-1,i3-1)*au(i3,i3-1)+au(i3-1,i3)*au(i3,i3)) !hr03
            g1(j)=au(ii,ii-1)**2+au(ii,ii)**2                            !hr04
            g2(j)=au(i2,i2-1)**2+au(i2,i2)**2                            !hr04
            g3(j)=au(i3,i3-1)**2+au(i3,i3)**2                            !hr04
            if(ndimf.eq.3) then
              call dainv(damap,nvar,damapi,nvar)
              jj(6)=1
              call dapek(damapi(5),jj,aui(1))
              call dapek(damapi(6),jj,aui(2))
              jj(6)=0
              if(j.lt.3) then
                d(j)=au(i3-1,i3-1)*aui(1)+au(i3-1,i3)*aui(2)
                dp(j)=au(i3,i3-1)*aui(1)+au(i3,i3)*aui(2)
              else
                d(j)=angp(1,ii-1)*aui(1)+angp(1,ii)*aui(2)
                dp(j)=au(ii,ii-1)*aui(1)+au(ii,ii)*aui(2)
              endif
            endif
            sx=angp(2,ii-1)*angp(1,ii)-angp(1,ii-1)*angp(2,ii)
            cx=angp(1,ii-1)*angp(2,ii-1)+angp(1,ii)*angp(2,ii)
            if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
+if crlibm
              dphi(j)=atan2_rn(sx,cx)/x2pi
+ei
+if .not.crlibm
              dphi(j)=atan2(sx,cx)/x2pi
+ei
            else
              dphi(j)=zero
            endif
            phi(j)=phi(j)+dphi(j)
          enddo !end optics calculation
          do j=1,ndimf
            ii=2*j
            angp(2,ii-1)=angp(1,ii-1)
            angp(2,ii)=angp(1,ii)
          enddo
!         write optics parameter for each element (LINE block)
          if(iwrite.eq.1) then
            iii=i
            if(typ(:8).eq.'START   ') iii=0
            write(lout,10030) iii,typ(:8),tl,phi(1),b1(1),al1(1),g1(1),
     &d(1),dp(1),c(1),cp(1)
            if(ndimf.eq.3) then
              write(lout,10040) b2(1),al2(1),g2(1)
              write(lout,10050) typ(9:16),b3(1),al3(1),g3(1)
            else
              write(lout,10055) typ(9:16),b2(1),al2(1),g2(1)
            endif
            write(lout,10060)
            write(lout,10070) phi(2),b1(2),al1(2),g1(2),d(2),dp(2),c(2),&
     &cp(2)
            write(lout,10080) b2(2),al2(2),g2(2)
            if(ndimf.eq.3) then
              write(lout,10090) b3(2),al3(2),g3(2)
              write(lout,10060)
              write(lout,10100) -phi(3),b1(3),al1(3),g1(3),d(3),dp(3),  &
     &c(3),
     &cp(3)
              write(lout,10080) b2(3),al2(3),g2(3)
              write(lout,10040) b3(3),al3(3),g3(3)
            endif
            write(lout,10010)
          endif
+cd umlalid1
          ibb=ibb+1
          if(ibb.gt.nbb) call prror(102)
          imbb(i)=ibb
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
*FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag2.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          endif
          call dainv(damap,nvar,damapi,nvar)
          call dacct(damap,nvar,aa2,nvar,aa2r,nvar)
          call dacct(damap,nvar,damap1,nvar,damap,nvar)
          call dacct(damap,nvar,damapi,nvar,damap,nvar)
+if debug
!         write(*,*) 'bbcu set in umlalid1'
!     call warr('umlid1bbcu',bbcu(ibb,1),ibb,1,0,0)
!     call warr('umlid1bbcu',bbcu(ibb,2),ibb,2,0,0)
!     call warr('umlid1bbcu',bbcu(ibb,3),ibb,3,0,0)
+ei
            do ii=1,3
              call damul(damap(i4(ii,1)),damap(i4(ii,2)),angno)
              call averaged(angno,aa2r,.false.,angno)
              do j=1,ndimf
                j1=2*j
                jj(j1-1)=1
                jj(j1)=1
                call dapek(angno,jj,angnoe(j))
                jj(j1-1)=0
                jj(j1)=0
              enddo
              if(ndimf.eq.3) then
                bbcu(ibb,ii)=two*((emitx*angnoe(1)+emity*angnoe(2))+    &!hr03
     &emitz*angnoe(3))
+if debug
!     call warr('umlid1bbcii',bbcu(ibb,ii),ibb,ii,1,0)
+ei
              else
                bbcu(ibb,ii)=two*(emitx*angnoe(1)+emity*angnoe(2))
+if debug
!     call warr('umlid1bbcii',bbcu(ibb,ii),ibb,ii,2,0)
+ei
              endif
            enddo
            if (beam_expflag .eq. 0) then !Old-style input
              if(parbe(ix,2).gt.0d0) then
                do ii=4,10
                  call damul(damap(i4(ii,1)),damap(i4(ii,2)),angno)
                  call averaged(angno,aa2r,.false.,angno)
                  do j=1,ndimf
                    j1=2*j
                    jj(j1-1)=1
                    jj(j1)=1
                    call dapek(angno,jj,angnoe(j))
                    jj(j1-1)=0
                    jj(j1)=0
                  enddo
                  if(ndimf.eq.3) then
                    bbcu(ibb,ii) = two *
     &               ((emitx*angnoe(1)+emity*angnoe(2))+emitz*angnoe(3))
                  else
                    bbcu(ibb,ii)=two*(emitx*angnoe(1)+emity*angnoe(2))
                  endif
                enddo
              endif
              if(lhc.eq.1) then
                dummy=bbcu(ibb,1)
                bbcu(ibb,1)=bbcu(ibb,2)
                bbcu(ibb,2)=dummy
                dummy=bbcu(ibb,4)
                bbcu(ibb,4)=bbcu(ibb,9)
                bbcu(ibb,9)=dummy
                dummy=bbcu(ibb,5)
                bbcu(ibb,5)=bbcu(ibb,7)
                bbcu(ibb,7)=dummy
                dummy=bbcu(ibb,6)
                bbcu(ibb,6)=bbcu(ibb,10)
                bbcu(ibb,10)=dummy
              endif
              if(lhc.eq.2) then
                bbcu(ibb,1)=bbbx(ix)
                bbcu(ibb,2)=bbby(ix)
                bbcu(ibb,3)=bbbs(ix)
              endif

            !Indentation break, sorry :(

          else if (beam_expflag .eq. 1) then !New style input
            if(parbe(ix,2).gt.0d0) then
               bbcu(ibb,1)=parbe(ix,7)
               bbcu(ibb,4)=parbe(ix,8)
               bbcu(ibb,6)=parbe(ix,9)
               bbcu(ibb,2)=parbe(ix,10)
               bbcu(ibb,9)=parbe(ix,11)
               bbcu(ibb,10)=parbe(ix,12)
               bbcu(ibb,3)=parbe(ix,13)
               bbcu(ibb,5)=parbe(ix,14)
               bbcu(ibb,7)=parbe(ix,15)
               bbcu(ibb,8)=parbe(ix,16)
            endif
            if(parbe(ix,2).eq.0d0) then
               bbcu(ibb,1)=parbe(ix,1)
               bbcu(ibb,2)=parbe(ix,3)
            endif
          else
             write(lout,'(a)') "ERROR in +cd umlalid1"
             write(lout,'(a)') "beam_expflag was", beam_expflag
             write(lout,'(a)') " expected 0 or 1. This is a BUG!"
             call prror(-1)
          end if

          if (beam_expflag .eq. 0) then
          write(lout,'(a)') " ******* NEW BEAM BLOCK ******"
          write(lout,'(a,g13.6,a,g13.6,a,g13.6,a)')
     &                  " ******* USING emitx=",emitx,
     &                               ", emity=",emity,
     &                               ", emitz=",emitz," ******"
          if(parbe(ix,2).eq.0.0) then !4D
             !Note: One should always use the CRLIBM version when converting,
             ! in order to guarantee the exact same results from the converted input file.
+if .not.crlibm
             write(lout,"(a16,1x,a1,1x,5g30.20)")
     &            bez(ix), "0", bbcu(ibb,1),bbcu(ibb,2),
     &            parbe(ix,5), parbe(ix,6), ptnfac(ix)
+ei
+if crlibm
             l1 = 1
             write(ch,'(a16,1x,a1)') bez(ix), "0"
             l1 = len(trim(ch))+1
             
             errno=dtostr(bbcu(ibb,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,2),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(ptnfac(ix),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(lout,*) trim(ch)
+ei
          else                      ! 6D
+if .not.crlibm
             write(lout,"(a16,1x,i4,1x,4g30.20)")
     &            bez(ix), int(parbe(ix,2)),
     &            parbe(ix,1), parbe(ix,3),
     &            parbe(ix,5), parbe(ix,6)
             write(lout,"(5g30.20)")
     &            bbcu(ibb,1), bbcu(ibb,4), bbcu(ibb,6),
     &            bbcu(ibb,2), bbcu(ibb,9)
             write(lout,"(6g30.20)")
     &            bbcu(ibb,10), bbcu(ibb,3), bbcu(ibb,5),
     &            bbcu(ibb,7), bbcu(ibb,8), ptnfac(ix)
+ei
+if crlibm
             l1 = 1
             write(ch,'(a16,1x,i4)') bez(ix), int(parbe(ix,2))
             l1 = len(trim(ch))+1

             errno=dtostr(parbe(ix,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,3),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
                          
             write(lout,*) trim(ch)

             l1 = 1
             ch = ' '

             errno=dtostr(bbcu(ibb,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,4),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,2),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(bbcu(ibb,9),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(lout,*) trim(ch)

             l1 = 1
             ch = ' '

             errno=dtostr(bbcu(ibb,10),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,3),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,7),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(bbcu(ibb,8),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(ptnfac(ix),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(lout,*) trim(ch)
+ei
            endif
          write(lout,'(a)') " ******* END NEW BEAM BLOCK ******"
          endif
          
        if((bbcu(ibb,1).le.pieni).or.(bbcu(ibb,2).le.pieni)) then 
            call prror(88)
          endif
          if(ibbc.eq.1) then
            sfac1=bbcu(ibb,1)+bbcu(ibb,2)
            sfac2=bbcu(ibb,1)-bbcu(ibb,2)
            sfac2s=one
            if(sfac2.lt.zero) sfac2s=-1d0*one                            !hr08
            sfac3=sqrt(sfac2**2+(four*bbcu(ibb,3))*bbcu(ibb,3))          !hr03
            if(sfac3.gt.sfac1) call prror(103)
            sfac4=(sfac2s*sfac2)/sfac3                                   !hr03
            sfac5=(((-1d0*sfac2s)*two)*bbcu(ibb,3))/sfac3                !hr03
            sigman(1,ibb)=sqrt(((sfac1+sfac2*sfac4)+                    &!hr03
     &(two*bbcu(ibb,3))*sfac5)*half)                                     !hr03
            sigman(2,ibb)=sqrt(((sfac1-sfac2*sfac4)-                    &!hr03
     &(two*bbcu(ibb,3))*sfac5)*half)                                     !hr03
            bbcu(ibb,11)=sqrt(half*(one+sfac4))
            bbcu(ibb,12)=(-1d0*sfac2s)*sqrt(half*(one-sfac4))            !hr03
            if(bbcu(ibb,3).lt.zero) bbcu(ibb,12)=-1d0*bbcu(ibb,12)       !hr03
          else
            bbcu(ibb,11)=one
            sigman(1,ibb)=sqrt(bbcu(ibb,1))
            sigman(2,ibb)=sqrt(bbcu(ibb,2))
          endif
          if(parbe(ix,2).gt.0d0) then !6D -> convert units
            do ii=1,10
              bbcu(ibb,ii)=bbcu(ibb,ii)*c1m6
            enddo
          endif
+cd trom01
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
+cd trom02
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
+cd trom03
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=-1d0*phibf(l)                                         !hr08
            endif
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr03
+cd trom04
            phi(l)=phi(l)+dphi/pie
          enddo
        endif
+cd trom05
            phi(l)=phi(l)+dphi
          enddo
        endif
+cd trom06
            phi(l)=phi(l)+dphi/pie
          enddo

          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          goto 500
        endif
+cd trom10
        if(kzz.eq.22) then
          do j=1,ium
            do kx=1,2
              ll=kx*2
              puf=x(j,kx)
           x(j,kx)=((cotr(imtr(ix),ll-1)+rrtr(imtr(ix),ll-1,ll-1)*puf)+ &!hr03
     &rrtr(imtr(ix),ll-1,ll)*y(j,kx))+dpr(j)*                           &!hr03
     &rrtr(imtr(ix),ll-1,6)                                              !hr03
           y(j,kx)=((cotr(imtr(ix),ll)+rrtr(imtr(ix),ll,ll-1)*puf)+     &!hr03
     &rrtr(imtr(ix),ll,ll)*y(j,kx))+dpr(j)*                             &!hr03
     &rrtr(imtr(ix),ll,6)                                                !hr03
            enddo
          enddo
        endif
+cd trom20
        if(kzz.eq.22) then
          irrtr=imtr(ix)
*FOX  SIGMDA=SIGMDA+COTR(IRRTR,5)+RRTR(IRRTR,5,1)*X(1)+
*FOX  RRTR(IRRTR,5,2)*Y(1)+RRTR(IRRTR,5,3)*X(2)+RRTR(IRRTR,5,4)*Y(2) ;
*FOX  PUX=X(1) ;
*FOX  PUZ=Y(1) ;
*FOX  X(1)=COTR(IRRTR,1)+RRTR(IRRTR,1,1)*PUX+RRTR(IRRTR,1,2)*PUZ+
*FOX  RRTR(IRRTR,1,6)*DPDA1 ;
*FOX  Y(1)=COTR(IRRTR,2)+RRTR(IRRTR,2,1)*PUX+RRTR(IRRTR,2,2)*PUZ+
*FOX  RRTR(IRRTR,2,6)*DPDA1 ;
*FOX  PUX=X(2) ;
*FOX  PUZ=Y(2) ;
*FOX  X(2)=COTR(IRRTR,3)+RRTR(IRRTR,3,3)*PUX+RRTR(IRRTR,3,4)*PUZ+
*FOX  RRTR(IRRTR,3,6)*DPDA1 ;
*FOX  Y(2)=COTR(IRRTR,4)+RRTR(IRRTR,4,3)*PUX+RRTR(IRRTR,4,4)*PUZ+
*FOX  RRTR(IRRTR,4,6)*DPDA1 ;
      endif
+cd trom30
        if(kzz.eq.22) then
          ktrack(i)=3
          goto 290
        endif
+cd trom40
          irrtr=imtr(ix)
          do j=1,napx
+cd trom41
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
+cd trom42
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo

!----------------------------------------------------------------------
! Wire element.

+cd wirekick
! MODEL OF STRAIGHT CURRENT WIRE
!
!     The model provides a transfer map of a straight current wire. 
!     Description:
!     1. Infinitly thin wire with arbitrary orientation.
!     2. Thin element in SixTrack (L)=0
!     3. Parameters: 
!     dx, dy: horizontal and vertical distances between wire midpoint
!     and closed orbit [mm] 
!     (parameters are given by dx and dy in WIRE block)
!     tx, ty: tilt of the wire w.r.t the closed orbit in the
!     horizontal and vertical planes (in degrees) 
!     (parameters are given by tiltx and tilty in WIRE block)
!     L - physical length of the wire element [m]
!     cur - current of the wire [Amperes]
!     embl - embedding drift (integrated length or integration interval) [m] 
!     4. The transport map is given for canonical variables (x,px...)
!
! The MAP is constructed out of the following steps:
!     1. Declaration of shifted canonical variables: 
!          rx = x+dx; ry = y+dy  in the same way as for the BEAM-BEAM element
!     2. Symplectic Rotation by the tilt angles tx, ty (in 4D space: px, rx, py, ry)
!     3. Wire kick for a longitudinally aligned wire (= kick for tx=ty=0)
!     4. Symplectic Rotation back by the tilt angles -ty, -yx (in 4D space: ...taking only PX, PY)
!--------------------------------------------------------------
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I

!     magnetic rigidity
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            

      tx = wire_tiltx(ix) !tilt x [degrees] 
      ty = wire_tilty(ix) !tilt y [degrees]
      tx = tx*(pi/180.0d0) ![rad]
      ty = ty*(pi/180.0d0) ![rad]
      dx = wire_dispx(ix) !displacement x [mm]
      dy = wire_dispy(ix) !displacement y [mm]
      embl = wire_lint(ix) !integrated length [m]
      l = wire_lphys(ix) !physical length [m]
      cur = wire_current(ix)

      if (abs(wire_flagco(ix)).ne.1) then
        write(lout,
     &fmt='((A,A,/),(A,I0,A,A,/),(A,I0,A,I0,/))')
     &'ERROR: in wirekick -  wire_flagco defined in WIRE block must ',
     &'be either 1 or -1! Did you define all wires in the WIRE block?',
     &'bez(',ix,') = ',bez(ix),
     &'wire_flagco(',ix,') = ',wire_flagco(ix)
        call prror(-1)
      endif
      NNORM=c1m7/chi

      IF (wire_flagco(ix).eq.1) THEN
         dxi = (dx+wire_clo(1,wire_num(i)) )*c1m3
         dyi = (dy+wire_clo(2,wire_num(i)) )*c1m3 
      ELSE IF (wire_flagco(ix).eq.-1) THEN
         dxi = (dx)*c1m3
         dyi = (dy)*c1m3
      END IF 
      
      do j=1, napx

      yv(1,j) = yv(1,j) * c1m3 !SI
      yv(2,j) = yv(2,j) * c1m3 !SI
    
! 1 shift
      IF (wire_flagco(ix).eq.1) THEN
         xi = (xv(1,j)+dx)*c1m3 !SI
         yi = (xv(2,j)+dy)*c1m3 !SI
      ELSE IF (wire_flagco(ix).eq.-1) THEN
         xi = (xv(1,j)+( dx-wire_clo(1,wire_num(i)) ))*c1m3 !SI
         yi = (xv(2,j)+( dy-wire_clo(2,wire_num(i)) ))*c1m3 !SI
      END IF 

! x'-> px; y'->py
      yv(1,j) = yv(1,j)*(1d0 + dpsv(j))
      yv(2,j) = yv(2,j)*(1d0 + dpsv(j))

! start not crlibm wire
+if .not.crlibm

! ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
          yi = yi-(((xi*sin(tx))*yv(2,j))/                              &
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-tx)                                                  
          xi = xi*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/                    &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))              
          yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin(atan(yv(1,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)

          xi = xi-(((yi*sin(ty))*yv(1,j))/                              &
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-ty)                                                  
          yi = yi*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/                    &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))              
          yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*                  &
     &sin(atan(yv(2,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty) 

! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO

! ibeco = 1:
      elseif(ibeco.eq.1) then
! 2 symplectic rotation of coordinate system (tx, ty) + closed orbit
          yi = yi-(((xi*sin(tx))*yv(2,j))/                              &
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-tx)                                                  
          xi = xi*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/                    &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))

          dyi = dyi-(((dxi*sin(tx))*yv(2,j))/                           &
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-tx)                                                  
          dxi = dxi*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/                  &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))
  
          yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin(atan(yv(1,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)

          xi = xi-(((yi*sin(ty))*yv(1,j))/                              &
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-ty)                                                  
          yi = yi*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/                    &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)) 
      
          dxi = dxi-(((dyi*sin(ty))*yv(1,j))/                           &
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &
     &yv(2,j)**2))-ty)                                                  
          dyi = dyi*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/                  &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))  
     
          yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*                  &
     &sin(atan(yv(2,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)             
 
! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO 
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO 
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
          RTWO = dxi**2+dyi**2
          yv(1,j) = yv(1,j)+(((CUR*NNORM)*dxi)*                         &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO 
          yv(2,j) = yv(2,j)+(((CUR*NNORM)*dyi)*                         &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO

      endif


! 4 symplectic rotation of coordinate system (-ty, -tx)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*                      &
     &sin(atan(yv(2,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*                      &
     &sin(atan(yv(1,j)/                                                 &
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)

+ei
!-----------------------------------------------------------------------
! end not crlibm wire
! start crlibm wire
+if crlibm
!ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
          yi = yi-(((xi*sin_rn(tx))*yv(2,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_rn(atan_rn(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx)
          xi = xi*(cos_rn(tx)-sin_rn(tx)*tan_rn(atan_rn(yv(1,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))
          yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin_rn(atan_rn(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx) 
      
          xi = xi-(((yi*sin_rn(ty))*yv(1,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_rn(atan_rn(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)
          yi = yi*(cos_rn(ty)-sin_rn(ty)*tan_rn(atan_rn(yv(2,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))  
          yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                  &
     &sin_rn(atan_rn(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)  
      
! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO

! ibeco = 1
      elseif(ibeco.eq.1) then
! 2 symplectic rotation of coordinate system (tx, ty)

          dyi = dyi-(((dxi*sin_rn(tx))*yv(2,j))/                        &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_rn(atan_rn(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx) 
          dxi = dxi*(cos_rn(tx)-sin_rn(tx)*tan_rn(atan_rn(yv(1,j)/      &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))
 
          yi = yi-(((xi*sin_rn(tx))*yv(2,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_rn(atan_rn(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx)
          xi = xi*(cos_rn(tx)-sin_rn(tx)*tan_rn(atan_rn(yv(1,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))

          yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin_rn(atan_rn(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)
              
          dxi = dxi-(((dyi*sin_rn(ty))*yv(1,j))/                        &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_rn(atan_rn(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)       
          dyi = dyi*(cos_rn(ty)-sin_rn(ty)*tan_rn(atan_rn(yv(2,j)/      &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)) 
      
          xi = xi-(((yi*sin_rn(ty))*yv(1,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_rn(atan_rn(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)                                                   
          yi = yi*(cos_rn(ty)-sin_rn(ty)*tan_rn(atan_rn(yv(2,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))  

         yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                   &
     &sin_rn(atan_rn(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)              

! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
          RTWO = dxi**2+dyi**2
          yv(1,j) = yv(1,j)+(((CUR*NNORM)*dxi)*                         &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)+(((CUR*NNORM)*dyi)*                         &
     &(sqrt((embl+L)**2+4d0*RTWO)-sqrt((embl-L)**2+4d0*RTWO) ))/RTWO 
      
      endif

! 4 SYMPLECTIC ROTATION OF COORDINATE SYSTEM (-ty, -tx)
      yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                      &
     &sin_rn(atan_rn(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)
      yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                      &
     &sin_rn(atan_rn(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)

+ei
! end crlibm wire

! px -> x'; py -> y'
      yv(1,j) = yv(1,j)/(1d0 + dpsv(j))
      yv(2,j) = yv(2,j)/(1d0 + dpsv(j))
!-----------------------------------------------------------------------
! END OF WIRE MAP
!-----------------------------------------------------------------------
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
!-----------------------------------------------------------------------
      enddo
!-----------------------------------------------------------------------
+cd open
!--OPENING DATA FILES
+if boinc
      call boincrf('fort.2',filename)
+if fio
      open(2,file=filename,form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(2,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(2,file='fort.2',form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(2,file='fort.2',form='formatted',status='unknown')
+ei

+ei !END of +if .not.boinc
+if boinc
      call boincrf('fort.3',filename)
+if fio
      open(3,file=filename,form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(3,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(3,file='fort.3',form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(3,file='fort.3',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

! Why no non-boinc version of fort fort.4?
! "Geometry and strength Parameters (format as file #2)"
+if boinc
      call boincrf('fort.4',filename)
      open(4,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(4,file='fort.4',form='formatted',status='unknown')
+ei !END of +if boinc

+if nagfor
+if boinc
      call boincrf('fort.7',filename)
      open(7,file=filename,form='formatted',status='unknown',recl=303)
+ei
+if .not.boinc
      open(7,file='fort.7',form='formatted',status='unknown',recl=303)
+ei
+ei !END of +if nagfor
+if .not.nagfor
+if boinc
      call boincrf('fort.7',filename)
      open(7,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(7,file='fort.7',form='formatted',status='unknown')
+ei
+ei !END of +if .not.nagfor

+if boinc
      call boincrf('fort.8',filename)
+if fio
      open(8,file=filename,form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(8,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(8,file='fort.8',form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(8,file='fort.8',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc
+if boinc
      call boincrf('fort.9',filename)
      open(9,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(9,file='fort.9',form='formatted',status='unknown')
+ei

! We no longer open fort.10 except for BOINC AND BNLELENS
! When we are returning everything from BOINC we can
! use the proper files as normal
+if bnlelens
+if nagfor
+if boinc
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei !END of +if boinc
+ei !END of +if nagfor
+if .not.nagfor
+if boinc
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+ei !END of +if .not.nagfor
+ei !END of +if bnlelens

+if boinc
      call boincrf('fort.11',filename)
+if fio
      open(11,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(11,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(11,file='fort.11',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(11,file='fort.11',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.12',filename)
+if fio
      open(12,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(12,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(12,file='fort.12',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(12,file='fort.12',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.13',filename)
+if fio
      open(13,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(13,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(13,file='fort.13',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(13,file='fort.13',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.14',filename)
+if fio
      open(14,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(14,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(14,file='fort.14',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(14,file='fort.14',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.15',filename)
+if fio
      open(15,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(15,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(15,file='fort.15',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(15,file='fort.15',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.16',filename)
+if fio
      open(16,file=filename,form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(16,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(16,file='fort.16',form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(16,file='fort.16',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.17',filename)
+if fio
      open(17,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(17,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(17,file='fort.17',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(17,file='fort.17',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.18',filename)
+if fio
      open(18,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(18,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(18,file='fort.18',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(18,file='fort.18',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.19',filename)
+if fio
      open(19,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(19,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(19,file='fort.19',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(19,file='fort.19',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.20',filename)
+if fio
      open(20,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(20,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(20,file='fort.20',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(20,file='fort.20',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc
      
+if boinc
      call boincrf('fort.21',filename)
+if fio
      open(21,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(21,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(21,file='fort.21',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(21,file='fort.21',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.22',filename)
+if fio
      open(22,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(22,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(22,file='fort.22',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(22,file='fort.22',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.23',filename)
+if fio
      open(23,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(23,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(23,file='fort.23',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(23,file='fort.23',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.24',filename)
+if fio
      open(24,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(24,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(24,file='fort.24',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(24,file='fort.24',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.25',filename)
+if fio
      open(25,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(25,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(25,file='fort.25',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(25,file='fort.25',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.26',filename)
+if fio
      open(26,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(26,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(26,file='fort.26',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(26,file='fort.26',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.27',filename)
+if fio
      open(27,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(27,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(27,file='fort.27',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(27,file='fort.27',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.28',filename)
+if fio
      open(28,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(28,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(28,file='fort.28',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(28,file='fort.28',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.29',filename)
+if fio
      open(29,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(29,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(29,file='fort.29',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(29,file='fort.29',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.30',filename)
+if fio
      open(30,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(30,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(30,file='fort.30',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(30,file='fort.30',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.31',filename)
+if fio
      open(31,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(31,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(31,file='fort.31',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(31,file='fort.31',form='formatted',status='unknown')
+ei
+ei

! Why no non-BOINC version of fort.32?
! "Binary dump of full accelerator description"
+if boinc
      call boincrf('fort.32',filename)
      open(32,file=filename,status='unknown',form='unformatted')
+ei
+if .not.boinc
      open(32,file='fort.32',form='unformatted',status='unknown')
+ei

+if boinc
      call boincrf('fort.33',filename)
+if fio
      open(33,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(33,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(33,file='fort.33',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(33,file='fort.33',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.34',filename)
+if fio
      open(34,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(34,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(34,file='fort.34',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(34,file='fort.34',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.35',filename)
+if fio
      open(35,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(35,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(35,file='fort.35',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(35,file='fort.35',form='formatted',status='unknown')
+ei
+ei

!     Tracking output files fort.91-i; i=1..32
!     used for postprocessing
+if .not.bnlelens
+if .not.stf !Separate output files (no SingleTrackFile)
+if boinc
      call boincrf('fort.59',filename)
      open(59,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(59,file='fort.59',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.60',filename)
      open(60,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(60,file='fort.60',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.61',filename)
      open(61,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(61,file='fort.61',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.62',filename)
      open(62,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(62,file='fort.62',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.63',filename)
      open(63,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(63,file='fort.63',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.64',filename)
      open(64,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(64,file='fort.64',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.65',filename)
      open(65,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(65,file='fort.65',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.66',filename)
      open(66,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(66,file='fort.66',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.67',filename)
      open(67,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(67,file='fort.67',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.68',filename)
      open(68,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(68,file='fort.68',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.69',filename)
      open(69,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(69,file='fort.69',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.70',filename)
      open(70,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(70,file='fort.70',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.71',filename)
      open(71,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(71,file='fort.71',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.72',filename)
      open(72,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(72,file='fort.72',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.73',filename)
      open(73,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(73,file='fort.73',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.74',filename)
      open(74,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(74,file='fort.74',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.75',filename)
      open(75,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(75,file='fort.75',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.76',filename)
      open(76,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(76,file='fort.76',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.77',filename)
      open(77,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(77,file='fort.77',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.78',filename)
      open(78,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(78,file='fort.78',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.79',filename)
      open(79,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(79,file='fort.79',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.80',filename)
      open(80,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(80,file='fort.80',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.81',filename)
      open(81,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(81,file='fort.81',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.82',filename)
      open(82,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(82,file='fort.82',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.83',filename)
      open(83,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(83,file='fort.83',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.84',filename)
      open(84,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(84,file='fort.84',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.85',filename)
      open(85,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(85,file='fort.85',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.86',filename)
      open(86,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(86,file='fort.86',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.87',filename)
      open(87,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(87,file='fort.87',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.88',filename)
      open(88,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(88,file='fort.88',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.89',filename)
      open(89,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(89,file='fort.89',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.90',filename)
      open(90,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(90,file='fort.90',form='unformatted',status='unknown')
+ei
+ei !END +if .not.stf
+if stf
+if boinc
      call boincrf('singletrackfile.dat',filename)
      open(90,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(90,file='singletrackfile.dat',form='unformatted',                 &
     &status='unknown')
+ei
+ei ! END +if stf
+ei ! END +if .not.bnlelens
      
+if boinc
      call boincrf('fort.98',filename)
      open(98,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(98,file='fort.98',form='formatted',status='unknown')
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
+if cr
! For BOINC all output now goes to fort.10
+if .not.boinc
+if fio
      open(51,file='fort.51',form='formatted',round='nearest')
+ei
+if .not.fio
      open(51,file='fort.51',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if .not.boinc
+if fio
      open(51,file='SixTwiss.dat',form='formatted',round='nearest')
+ei
+if .not.fio
      open(51,file='SixTwiss.dat',form='formatted')
+ei
+ei
+ei ! END +if .not.cr

+if cr
+if .not.boinc
+if fio
      open(52,file='fort.52',form='formatted',round='nearest')
+ei
+if .not.fio
      open(52,file='fort.52',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(52,file='beambeam-output.dat',form='formatted',              &
     &round='nearest')
+ei
+if .not.fio
      open(52,file='beambeam-output.dat',form='formatted')
+ei
+ei ! END +if .not.cr

+if cr
+if .not.boinc
+if fio
      open(53,file='fort.53',form='formatted',round='nearest')
+ei
+if .not.fio
      open(53,file='fort.53',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(53,file='beambeam-lostID.dat',form='formatted',              &
     &round='nearest')
+ei
+if .not.fio
      open(53,file='beambeam-lostID.dat',form='formatted')
+ei
+ei ! END +if .not.cr

+if cr
+if boinc
      call boincrf('fort.54',filename)
+if fio
      open(54,file=filename,form='formatted',round='nearest')
+ei
+if .not.fio
      open(54,file=filename,form='formatted')
+ei
+ei
+ei ! END +if cr
      
+if .not.boinc
+if fio
      open(54,file='fort.54',form='formatted',round='nearest')
+ei
+if .not.fio
      open(54,file='fort.54',form='formatted')
+ei
+ei
+if .not.cr
+if fio
      open(54,file='beambeamdist.dat',form='formatted',                 &
     &round='nearest')
+ei
+if .not.fio
      open(54,file='beambeamdist.dat',form='formatted')
+ei
+ei

+if cr
+if .not.boinc
+if fio
      open(97,file='fort.97',form='formatted',round='nearest')
+ei
+if .not.fio
      open(97,file='fort.97',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(97,file='checkdist.dat',form='formatted',round='nearest')
+ei
+if .not.fio
      open(97,file='checkdist.dat',form='formatted')
+ei
+ei ! END +if .not.cr
!GRDRHIC
!GRD-042008
+ei ! END +if bnlelens
      
!Eric for the DA coefficients in BINARY
      open(111,file='fort.111',form='unformatted')
! Write a BINARY fort.10 of sumda for checking
      open(110,file='fort.110',form='unformatted')

+if debug
!DUMPS 99
+if boinc
      call boincrf('dump',filename)
      open(99,file=filename,form='unformatted')
      call boincrf('arrays',filename)
      open(100,file=filename,form='unformatted')
+ei
+if .not.boinc
      open(99,file='dump',form='unformatted')
      open(100,file='arrays',form='unformatted')
+ei
+ei ! END +if debug

! END of +cd open
      
+cd rvet0
      e0f=sqrt(e0**2-pma**2)                                             !hr03
+if rvet
*FOX  RVET=C1E3*PMA*PMA*(TWO+DPDA)*DPDA/E0/DPD ;
*FOX  RVET=RVET/(E0*DPD+SQRT(E0*E0+E0F*E0F*(TWO*DPDA+DPDA*DPDA))) ;
+ei
+cd rvet1
+if rvet
        rvet(j)=((((c1e3*pma**2)*(two+dpsv(j)))*dpsv(j))/e0)/dpd(j)      !hr03
        rvet(j)=rvet(j)/(e0*dpd(j)+                                     &!hr03
     &sqrt(e0**2+e0f**2*(two*dpsv(j)+dpsv(j)**2)))                       !hr03
+ei
+if .not.rvet
!
+ei
+cd rvet2
+if .not.rvet
        rv=(ej(1)*e0f)/(e0*ejf(1))
+ei
+if rvet
        rv=(ej(1)*e0f)/(e0*ejf(1))
        rvet=((((c1e3*pma**2)*(two+dps(1)))*dps(1))/e0)/(one+dps(1))
        rvet=rvet/(e0*(one+dps(1))+sqrt(e0**2+e0f**2*(two*dps(1)+       &!hr03
     &dps(1)*dps(1))))                                                   !hr03
+ei
+cd dalin1
        jmel=mel(ix)
        if(idp.eq.0.or.ition.eq.0) then
          if(ithick.eq.1) then
            do jb=1,jmel
              jx=mtyp(ix,jb)
              do ip=1,6
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,1,ip,ien)
                enddo
                if(nvar2.eq.4) then
                  call darea6(alda(1,ip),zfeld1,4)
                else if(nvar2.eq.5) then
                  call darea6(alda(1,ip),zfeld1,5)
                endif
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,2,ip,ien)
                enddo
                if(nvar2.eq.4) then
                  call darea6(alda(2,ip),zfeld1,4)
                else if(nvar2.eq.5) then
                  call darea6(alda(2,ip),zfeld1,5)
                endif
              enddo
+cd dalin2
*FOX  PUX=X(1) ;
*FOX  PUZ=Y(1) ;
*FOX  X(1)=ALDA(1,1)*PUX+ALDA(1,2)*PUZ+ALDA(1,5)*IDZ(1) ;
*FOX  Y(1)=ALDA(1,3)*PUX+ALDA(1,4)*PUZ+ALDA(1,6)*IDZ(1) ;
*FOX  PUX=X(2) ;
*FOX  PUZ=Y(2) ;
*FOX  X(2)=ALDA(2,1)*PUX+ALDA(2,2)*PUZ+ALDA(2,5)*IDZ(2) ;
*FOX  Y(2)=ALDA(2,3)*PUX+ALDA(2,4)*PUZ+ALDA(2,6)*IDZ(2) ;
+cd dalin3
            enddo
          else
*FOX  X(1)=X(1)+BL1(IX,1,2)*Y(1) ;
*FOX  X(2)=X(2)+BL1(IX,2,2)*Y(2) ;
          endif
+cd dalin4
        else
          do jb=1,jmel
            jx=mtyp(ix,jb)
            if(ithick.eq.1) then
              do ip=1,6
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,1,ip,ien)
                  zfeld2(ien)=asd6(jx,1,ip,ien)
                enddo
                if(nvar2.eq.5) then
                  call darea6(alda(1,ip),zfeld1,5)
                  call darea6(asda(1,ip),zfeld2,5)
                else if(nvar2.eq.6) then
                  call darea6(alda(1,ip),zfeld1,6)
                  call darea6(asda(1,ip),zfeld2,6)
                endif
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,2,ip,ien)
                  zfeld2(ien)=asd6(jx,2,ip,ien)
                enddo
                if(nvar2.eq.5) then
                  call darea6(alda(2,ip),zfeld1,5)
                  call darea6(asda(2,ip),zfeld2,5)
                else if(nvar2.eq.6) then
                  call darea6(alda(2,ip),zfeld1,6)
                  call darea6(asda(2,ip),zfeld2,6)
                endif
              enddo
+cd dalin5
*FOX  PUX=X(1) ;
*FOX  PUZ=Y(1) ;
*FOX  SIGMDA=SIGMDA+ASDA(1,1)+ASDA(1,2)*PUX+
*FOX  ASDA(1,3)*PUZ+ASDA(1,4)*PUX*PUZ+ASDA(1,5)*PUX*PUX+
*FOX  ASDA(1,6)*PUZ*PUZ ;
*FOX  X(1)=ALDA(1,1)*PUX+ALDA(1,2)*PUZ+ALDA(1,5)*IDZ(1) ;
*FOX  Y(1)=ALDA(1,3)*PUX+ALDA(1,4)*PUZ+ALDA(1,6)*IDZ(1) ;
*FOX  PUX=X(2) ;
*FOX  PUZ=Y(2) ;
*FOX  SIGMDA=SIGMDA+ASDA(2,1)+ASDA(2,2)*PUX+
*FOX  ASDA(2,3)*PUZ+ASDA(2,4)*PUX*PUZ+ASDA(2,5)*PUX*PUX+
*FOX  ASDA(2,6)*PUZ*PUZ ;
*FOX  X(2)=ALDA(2,1)*PUX+ALDA(2,2)*PUZ+ALDA(2,5)*IDZ(2) ;
*FOX  Y(2)=ALDA(2,3)*PUX+ALDA(2,4)*PUZ+ALDA(2,6)*IDZ(2) ;
+cd dalin6
!            else !moved outside of dalin6 /Mattias
*FOX  X(1)=X(1)+EL(JX)*Y(1) ;
*FOX  X(2)=X(2)+EL(JX)*Y(2) ;
+cd dalino
          do 60 kx=1,2
            if(ithick.eq.1) then
*FOX  PUX=X(KX) ;
*FOX  PUZ=Y(KX) ;
            endif
            if(idp.eq.0.or.ition.eq.0) then
              if(ithick.eq.1) then
*FOX  X(KX)=BL1(IX,KX,1)*PUX+BL1(IX,KX,2)*PUZ+
*FOX  BL1(IX,KX,5)*IDZ(KX)*DPDA*C1E3 ;
*FOX  Y(KX)=BL1(IX,KX,3)*PUX+BL1(IX,KX,4)*PUZ+
*FOX  BL1(IX,KX,6)*IDZ(KX)*DPDA*C1E3 ;
              else
*FOX  X(KX)=X(KX)+BL1(IX,KX,2)*Y(KX) ;
              endif
            else
              do 50 jb=1,jmel
                jx=mtyp(ix,jb)
                if(ithick.eq.1) then
                  do 40 ip=1,6
                    do 30 ien=1,nord+1
                      zfeld1(ien)=ald6(jx,kx,ip,ien)
                      zfeld2(ien)=asd6(jx,kx,ip,ien)
   30               continue
                    if(nvar2.eq.5) then
                      call darea6(alda(kx,ip),zfeld1,5)
                      call darea6(asda(kx,ip),zfeld2,5)
                    else if(nvar2.eq.6) then
                      call darea6(alda(kx,ip),zfeld1,6)
                      call darea6(asda(kx,ip),zfeld2,6)
                    endif
   40             continue
*FOX  SIGMDA=SIGMDA+ASDA(KX,1)+ASDA(KX,2)*PUX+
*FOX  ASDA(KX,3)*PUZ+ASDA(KX,4)*PUX*PUZ+ASDA(KX,5)*PUX*PUX+
*FOX  ASDA(KX,6)*PUZ*PUZ ;
*FOX  X(KX)=ALDA(KX,1)*PUX+ALDA(KX,2)*PUZ+ALDA(KX,5)*IDZ(KX) ;
*FOX  Y(KX)=ALDA(KX,3)*PUX+ALDA(KX,4)*PUZ+ALDA(KX,6)*IDZ(KX) ;
*FOX  PUX=X(KX) ;
*FOX  PUZ=Y(KX) ;
                else
*FOX  X(KX)=X(KX)+EL(JX)*Y(KX) ;
                  if (kx.eq.1) then
+ca sqrtfox0
*FOX  SIGMDA=SIGMDA+
+ca sqrtfox
                  endif
                endif
   50         continue
            endif
   60     continue

+dk nocode
      !Dummy deck to satisfy astuce in case of no decks in the fortran file...
+if .not.datamods
      subroutine nodatamods
+ca crcoall
      write(lout,*)
     &"Dummy routine in bigmats.f if beamgas module is off."
      end subroutine
+ei

+dk datamods
      module bigmats
!     Module defining some very large matrices, which doesn't fit in BSS with common blocks.
      
      !Big arrays used for thick tracking
      double precision, allocatable :: al(:,:,:,:), as(:,:,:,:)
      double precision, allocatable :: ekv(:,:)
      double precision, allocatable :: hv(:,:,:,:), bl1v(:,:,:,:)
      
      save

      contains !Here comes the subroutines!

      subroutine allocate_thickarrays(npart,nele,nblo)
      implicit none
      integer, intent(in) :: npart,nele,nblo
      integer stat
      integer i1,i2,i3,i4,i
+ca crcoall
+ca parnum

+if .not.vvector
      write(lout,*) "ERROR: DATAMODS requires VVECTOR!"
      call prror(-1)
+ei      
      
      write(lout,*) "ALLOCATE_THICKARRAYS: npart/nele/nblo=",
     &npart,nele,nblo
      
      allocate(al(6,2,npart,nele), as(6,2,npart,nele),
     &     ekv(npart,nele),
     &     hv(6,2,npart,nblo), bl1v(6,2,npart,nblo), STAT = stat)
      if (stat.ne.0) then
         write(lout,*) "ERROR in allocate_thickarrays(); stat=",stat
         call prror(-1)
      endif

      !ZERO the newly allocated arrays

      !Code from MAINCR
      do i=1,npart
         do i1=1,nblo
            do i2=1,2
               do i3=1,6
                  hv(i3,i2,i,i1)=zero
                  bl1v(i3,i2,i,i1)=zero
               end do
            end do
         end do
      end do

      !Code from COMNUL
      do i=1,nele
         do i3=1,2
            do i4=1,6
               do i1=1,npart
                  al(i4,i3,i1,i)=zero
                  as(i4,i3,i1,i)=zero
               end do
            end do
         end do
      end do
      end subroutine
      
      subroutine deallocate_thickarrays
      
      end subroutine
      
      end module
+dk close
      subroutine closeUnits
      implicit none
+ca parpro
+ca common
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
      integer i
      logical lopen
!-----------------------------------------------------------------------
!--CLOSE(DATA FILES
      close(2,err=2)
 2    continue
      close(3,err=3)
 3    continue
      close(4,err=4)
 4    continue
      close(7,err=7)
 7    continue
      close(8,err=8)
 8    continue
      close(9,err=9)
 9    continue
      close(10,err=10)
 10    continue
      close(11,err=11)
 11    continue
      close(12,err=12)
 12    continue
      close(13,err=13)
 13    continue
      close(14,err=14)
 14    continue
      close(15,err=15)
 15    continue
      close(16,err=16)
 16    continue
      close(17,err=17)
 17    continue
      close(18,err=18)
 18    continue
      close(19,err=19)
 19    continue
      close(20,err=20)
 20    continue
      close(21,err=21)
 21    continue
      close(22,err=22)
 22    continue
      close(23,err=23)
 23    continue
      close(24,err=24)
 24    continue
      close(25,err=25)
 25    continue
      close(26,err=26)
 26    continue
      close(27,err=27)
 27    continue
      close(28,err=28)
 28    continue
      close(29,err=29)
 29    continue
      close(30,err=30)
 30    continue
      close(31,err=31)
 31    continue
      close(32,err=32)
 32    continue
      close(33,err=33)
 33    continue
      close(34,err=34)
 34    continue
      close(35,err=35)
 35    continue
+if .not.stf
      close(59,err=59)
 59    continue
      close(60,err=60)
 60    continue
      close(61,err=61)
 61    continue
      close(62,err=62)
 62    continue
      close(63,err=63)
 63    continue
      close(64,err=64)
 64    continue
      close(65,err=65)
 65    continue
      close(66,err=66)
 66    continue
      close(67,err=67)
 67    continue
      close(68,err=68)
 68    continue
      close(69,err=69)
 69    continue
      close(70,err=70)
 70    continue
      close(71,err=71)
 71    continue
      close(72,err=72)
 72    continue
      close(73,err=73)
 73    continue
      close(74,err=74)
 74    continue
      close(75,err=75)
 75    continue
      close(76,err=76)
 76    continue
      close(77,err=77)
 77    continue
      close(78,err=78)
 78    continue
      close(79,err=79)
 79    continue
      close(80,err=80)
 80    continue
      close(81,err=81)
 81    continue
      close(82,err=82)
 82    continue
      close(83,err=83)
 83    continue
      close(84,err=84)
 84    continue
      close(85,err=85)
 85    continue
      close(86,err=86)
 86    continue
      close(87,err=87)
 87    continue
      close(88,err=88)
 88    continue
      close(89,err=89)
 89    continue
+ei !END +if .not.stf
      close(90,err=90)
 90    continue
      close(98,err=98)
 98    continue

+if bnlelens
!GRDRHIC
!GRD-042008
+if .not.boinc
      close(51,err=51)
 51    continue
      close(52,err=52)
 52    continue
      close(53,err=53)
 53    continue
      close(97,err=97)
 97    continue
+ei
      close(54,err=54)
 54    continue
!GRDRHIC
!GRD-042008
+ei ! END +if bnlelens

+if hdf5
      call CLOSEHDF5()
+ei
+if debug
      close(99,err=99)
 99    continue
      close(100,err=100)
 100    continue
+ei
!Eric....and more to come
      close(110,err=110)
 110    continue
      close(111,err=111)
 111    continue

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-09-2014
!     close units for dumping particle population or statistics or beam matrix
!     always in main code
      do i=0,il
        if ( ldump(i) ) then
!         the same file could be used by more than one SINGLE ELEMENT
          inquire( unit=dumpunit(i), opened=lopen )
          if ( lopen ) close(dumpunit(i))
        endif
      enddo
!     A.Mereghetti, for the FLUKA Team
!     last modified: 02-09-2014
!     close units for logging dynks
!     always in main code
      if (ldynk) then
         ! dynksets.dat
         inquire(unit=665, opened=lopen)
         if (lopen) close(665,err=665)
 665     continue
         
         do i=1,nfuncs_dynk
            if ( funcs_dynk(i,2).eq.3) then !PIPE FUN
               ! InPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)), opened=lopen)
               if ( lopen ) close(iexpr_dynk(funcs_dynk(i,3)))
               
               ! OutPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)+1), opened=lopen)
               if ( lopen ) then
                  write(iexpr_dynk(funcs_dynk(i,3))+1,"(a)")
     &                 "CLOSEUNITS"
                  close(iexpr_dynk(funcs_dynk(i,3))+1)
               endif
            endif
         end do
      end if
      

      return
      end subroutine
+dk cor_ord
      subroutine coruord
!-----------------------------------------------------------------------
!---- PROGRAM FOR THE TUNESHIFT CORRECTIONS
!----
!----   =========>      FIRST & SECOND ORDER CORRECTIONS      <=========
!----   =========>            AMPLITUDE & CHROMATIC           <=========
!----   =========>                  EFFECTS                   <=========
!----
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ifail,istate,iter,iuser,iwork,j,jaord,jbound,jcol,jcomp,&
     &jconf,jord,jpord,jrow,jsex,jvar,k,kcol,l,liwork,lwork,mcor,n,     &
     &nclin,ncnln,nconf,ndim2,nout,nrel,nrowa,nrowj,nrowr
      real a,bl,bu,c,cjac,clamda,objf,objgrd,r,user,work
      double precision ainv,bmat,chia,chib,cmat,cvec,det,detinv,dvec,   &
     &pi2in,sex,sgn
      external e04udm,objfun1
      parameter(mcor = 10)
      parameter(ndim2 = 6)
+ca commondl
+ca commadha
+ca commadh1
      dimension a(2,10),cjac(1,1),c(1)
      dimension r(10,10),bu(20),bl(20),clamda(20),objgrd(10)
      dimension ainv(2,2),bmat(2,10),cmat(2,10),cvec(2),dvec(2)
      dimension work(450),user(500),sex(10),sgn(10,10)
      dimension istate(20),iwork(40),iuser(3)
      data sgn/100*1.d0/ainv,bmat,cmat,cvec,dvec/48*0.d0/
      save
!-----------------------------------------------------------------------
+if crlibm
      pi2in=1d0/(8d0*atan_rn(1d0))
+ei
+if .not.crlibm
      pi2in=1d0/(8d0*atan(1d0))
+ei
!-----------------------------------------------------------------------
      do 40 i=0,3
        do 30 j=1,3
          do 20 k=0,3
            do 10 l=0,4000
              hda(i,j,k,l)=0.d0
   10       continue
   20     continue
   30   continue
   40 continue
!-----------------------------------------------------------------------
      do 50 j=1,10
        sgn(j,j)=-1d0
   50 continue
!-----------------------------------------------------------------------
!---- SPECIFIES THE I/O UNITS FOR THE NAG ROUTINES
!-----------------------------------------------------------------------
      nout=26
      call x04abf(1,nout)
!-----------------------------------------------------------------------
      jeltot=ncor
!-----------------------------------------------------------------------
      jaord=namp
      jpord=nmom
!-----------------------------------------------------------------------
      call readd1(user,jaord,jpord)
!-----------------------------------------------------------------------
      if(jaord.eq.2.or.jpord.eq.3) goto 130
!-----------------------------------------------------------------------
!---- DEFINES THE MATRIX WITH THE LINEAR CONSTRAINTS
!-----------------------------------------------------------------------
      do 80 jrow=1,2
        do 60 jcol=1,jeltot
          a(jrow,jcol)=hda(jrow-1,1,1,3**(jcol-1))
   60   continue
        do 70 jcol=1,jeltot-2
          bmat(jrow,jcol)=-1d0*a(jrow,jcol+2)                            !hr04
   70   continue
!-----------------------------------------------------------------------
        cvec(jrow)=-1d0*hda(jrow-1,1,1,0)                                !hr04
   80 continue
!-----------------------------------------------------------------------
!---- DEFINES THE RELATION BETWEEN THE FIRST TWO SEXTUPOLES AND THE
!---- OTHERS
!-----------------------------------------------------------------------
      det=(a(1,1)*a(2,2)-a(2,1)*a(1,2))
      detinv=1d0/det
      ainv(1,1)=detinv*a(2,2)
      ainv(1,2)=-1d0*detinv*a(1,2)                                       !hr04
      ainv(2,1)=-1d0*detinv*a(2,1)                                       !hr04
      ainv(2,2)=detinv*a(1,1)
!-----------------------------------------------------------------------
      do 120 jrow=1,2
!-----------------------------------------------------------------------
        do 100 jcol=1,jeltot
          do 90 kcol=1,2
            cmat(jrow,jcol)=cmat(jrow,jcol)+ainv(jrow,kcol) *bmat       &
     &(kcol,jcol)
   90     continue
  100   continue
!-----------------------------------------------------------------------
        do 110 jcol=1,2
          dvec(jrow)=dvec(jrow)+ainv(jrow,jcol)*cvec(jcol)
  110   continue
  120 continue
!-----------------------------------------------------------------------
!---- WRITES ON THE EXIT FILE
!-----------------------------------------------------------------------
  130 write(lout,10000)
      write(lout,10010)
      write(lout,10020) jeltot,jaord,jpord
      write(lout,10030)
!-----------------------------------------------------------------------
      nrel=2
      nconf=jeltot-2
      if(jaord.eq.2.or.jpord.eq.3) then
        nrel=0
        nconf=1
      end if
!-----------------------------------------------------------------------
      do 240 jconf=1,jeltot
!-----------------------------------------------------------------------
!---- DEFINES EXTRA PARAMETERS
!-----------------------------------------------------------------------
        n=jeltot
        nclin=nrel
        ncnln=0
        nrowa=2
        nrowj=1
        nrowr=10
!-----------------------------------------------------------------------
        liwork=30
        lwork=450
!-----------------------------------------------------------------------
        do 140 jbound=1,n
          bu(jbound)=1d10
          bl(jbound)=-1d10
  140   continue
!-----------------------------------------------------------------------
        do 150 jbound=1,nclin
          bu(n+jbound)=-hda(jbound-1,1,1,0)
          bl(n+jbound)=bu(n+jbound)
  150   continue
!-----------------------------------------------------------------------
        do 160 jvar=1,n
          x(jvar)=0.d0
  160   continue
!-----------------------------------------------------------------------
        if(nrel.eq.2) then
!-----------------------------------------------------------------------
!---- DEFINES THE INITIAL GUESS SO THAT IT SATISFIES THE LINEAR
!---- CONSTRAINTS
!-----------------------------------------------------------------------
          do 180 jvar=1,2
            do 170 jcol=1,n-2
              x(jvar)=(x(jvar)+cmat(jvar,jcol)*sgn(jcol,jconf)) +dvec   &!hr04
     &(jvar)
              x(jcol+2)=sgn(jcol,jconf)
  170       continue
  180     continue
!-----------------------------------------------------------------------
        else if(nrel.eq.0) then
!-----------------------------------------------------------------------
          do 190 jvar=1,n
            x(jvar)=sgn(jvar,jconf)
  190     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        iuser(1)=jaord
        iuser(2)=jpord
        if(iuser(1).eq.0) iuser(3)=1
        if(iuser(2).eq.0) iuser(3)=iuser(1)+1
!-----------------------------------------------------------------------
        ifail=-1
!-----------------------------------------------------------------------
        call e04uef('MAJOR ITERATION LIMIT = 100')
!-----------------------------------------------------------------------
        call e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,e04udm,     &
     &objfun1,iter,istate,c,cjac,clamda,objf,objgrd,r,x,iwork,liwork,   &
     &work,lwork,iuser,user,ifail)
!-----------------------------------------------------------------------
        if(ifail.ne.0.and.ifail.ne.5) then
!-----------------------------------------------------------------------
          write(lout,10040) ifail
          call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
          stop
+ei
        end if
!-----------------------------------------------------------------------
        do 200 jsex=1,jeltot
          sex(jsex)=x(jsex)
          write(lout,10050) coel(jsex),sex(jsex)
  200   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN DP/P AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 210 jord=1,maxp
          call hamilton1(1,jord)
!-----------------------------------------------------------------------
!---- WRITES THE VALUES OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10060) jord
          write(lout,10070)
          write(lout,10080) hda(1,1,jord,0),hda(0,1,jord,0)
          write(lout,10090)
          write(lout,10080) ham(1),ham(0)
          write(lout,10100)
!-----------------------------------------------------------------------
  210   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN AMP AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 230 jord=2,maxa
!-----------------------------------------------------------------------
          call hamilton1(jord,0)
!-----------------------------------------------------------------------
!---- COMPUTES THE FUNCTION CHI
!-----------------------------------------------------------------------
          if(jord.eq.2) then
!-----------------------------------------------------------------------
            chib=(pi2in/sqrt(3.d0))*sqrt((((2.d0*hda(0,2,0,0)**2 +hda   &!hr04
     &(1,2,0,0)**2)+2.d0*hda(2,2,0,0)**2)+hda(0,2,0,0) *hda(1,2,0,0)    &!hr04
     &)+hda(1,2,0,0)*hda(2,2,0,0))                                       !hr04
          chia=(pi2in/sqrt(3.d0))*sqrt((((2.d0*ham(0)**2+ham(1)**2)+2.d0&!hr04
     &*ham(2)**2)+ham(0)*ham(1))+ham(1)*ham(2))                          !hr04
!-----------------------------------------------------------------------
          else if(jord.eq.3) then
!-----------------------------------------------------------------------
      chib=(pi2in/sqrt(30.d0))*sqrt((((((((27.d0*hda(3,3,0,0)**2 +5.d0  &!hr04
     &*hda(2,3,0,0)**2)+5.d0*hda(1,3,0,0)**2)+27.d0*hda(0,3,0,0)**2)    &!hr04
     &+(9.d0*hda(3,3,0,0))*hda(2,3,0,0))+(9.d0*hda(1,3,0,0))*hda        &!hr04
     &(0,3,0,0))+(6.d0*hda(2,3,0,0))*hda(1,3,0,0))+(3.d0*hda(3,3,0,0)   &!hr04
     &)*hda(1,3,0,0)) +(3.d0*hda(2,3,0,0))*hda(0,3,0,0))                 !hr04
      chia=(pi2in/sqrt(30.d0))*sqrt((((((((27.d0*ham(3)**2 +5.d0*ham(2) &!hr04
     &**2)+5.d0*ham(1)**2)+27.d0*ham(0)**2)+(9.d0*ham(3))*ham(2))+(9.d0 &!hr04
     &*ham(1))*ham(0))+(6.d0*ham(2))*ham(1))+(3.d0*ham(3))*ham(1))+(3.d0&!hr04
     &*ham(2))*ham(0))
!-----------------------------------------------------------------------
          end if
!-----------------------------------------------------------------------
!---- WRITES THE VALUE OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10110) jord
          write(lout,10120)
!-----------------------------------------------------------------------
          do 220 jcomp=0,jord
!-----------------------------------------------------------------------
            write(lout,10130)jcomp,jord-jcomp,hda(jcomp,jord,0,0),jcomp,
     &jord-jcomp,ham(jcomp)
!-----------------------------------------------------------------------
  220     continue
          write(lout,10140) jord-1,chib,jord-1,chia
          write(lout,10100)
!-----------------------------------------------------------------------
  230   continue
!-----------------------------------------------------------------------
  240 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
10000 format(//80('-')//t10,29('O')/t10,2('O'),25x,2('O')/t10,          &
     &'OO  TUNE-SHIFT CORRECTION  OO', /t10,2('O'),25x,2('O')/t10,29('O'&
     &)//80('-')//)
10010 format(//t26,'*** ORDER-BY-ORDER CORRECTIONS ***'//)
10020 format(t10,'NUMBER OF CORRECTOR ELEMENTS ',t48,i8/ t10,           &
     &'TUNE-SHIFT ORDER (AMPLITUDE) ',t48,i8/ t10,                      &
     &'TUNE-SHIFT ORDER (MOMENTUM) ',t48,i8)
10030 format(/,t10,'VALUES OF THE INTEGRATED GRADIENTS OF THE ',        &
     &'CORRECTOR MULTIPOLES',/)
10040 format(//,t10,' ERROR IN ROUTINE E04UCF. IFAIL = ',i8)
10050 format(/,t10,'CORRECTOR ELEMENT  - ',a16,' - ',4x,e20.14)
10060 format(//,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,       &
     &'MOMENTUM DEPENDENCE ')
10070 format(/,t10,'BEFORE CORRECTION ')
10080 format(/,'H_1,0    = ',2x,e16.8,7x,'H_0,1    = ', 2x,e16.8)
10090 format(/,t10,'AFTER CORRECTION ')
10100 format(//80('-'))
10110 format(//,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,       &
     &'AMPLITUDE DEPENDENCE',/)
10120 format(/,t10,'BEFORE CORRECTION ',20x,'AFTER CORRECTION ')
10130 format(/,t10,'H_',i1,',',i1,'    = ',e16.8,11x, 'H_',i1,',',i1,   &
     &'    = ',e16.8)
10140 format(/,t10,'CHI_',i1,',0  = ',e16.8,11x, 'CHI_',i1,',0  = ',e16.&
     &8)
      end
      subroutine readd1(user,jaord,jpord)
!-----------------------------------------------------------------------
!---- SUBROUTINE TO READ DATA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer icont,ind,j,j1,j2,j3,j4,j5,j6,jaord,jcomp,jel,jord,jpord, &
     &maxcomp,njx,njx1,njz,njz1,nmax,np,ncoef,nord,point,kointer
      real user
      double precision cc
+ca commadha
+ca commadh1
      dimension ind(10),user(500)
+if crlibm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=20)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      nmax=40
!-----------------------------------------------------------------------
      maxa=jaord+1
      maxp=jpord
      if(jpord.eq.0) then
        maxp=jaord+1
        maxcomp=maxa
      else if(jaord.eq.0) then
        maxa=jpord
        maxcomp=1
      end if
!-----------------------------------------------------------------------
      rewind 23
!-----------------------------------------------------------------------
! Unit 23 is opened with round='nearest' if fio is selected
+if .not.crlibm
   10 read(23,'(I6,2X,G20.14,I5,4X,18(2I2,1X))',end=30) ncoef,cc,nord,  &
     &njx,njx1,njz,njz1,np,(ind(jel),jel=1,jeltot)
      read(23,*,end=30) cc
+ei
+if crlibm
   10 read(23,*,end=30) ch
      ch1(:nchars+3)=ch(:nchars)//' / '
      lineno=lineno+1
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read (fields(1),*) ncoef
        nf=nf-1
      endif
      if (nf.gt.0) then
        cc=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(3),*) nord
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(4),*) njx
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(5),*) njx1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(6),*) njz
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(7),*) njz1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(8),*) np
        nf=nf-1
      endif
      do jel=1,jeltot
        if (nf.gt.0) then
          read (fields(8+jel),*) ind(jel)
          nf=nf-1
        endif
      enddo
      read(23,*,end=30) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cc=fround(errno,fields,1)
        nf=nf-1
      endif
+ei
!-----------------------------------------------------------------------
!---- CODING IND IN BASE 3
!-----------------------------------------------------------------------
      if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).le.maxa.and. np.le.  &
     &maxp) then
        point=0
        do 20 j=1,jeltot
          point=point+ind(j)*3**(j-1)
   20   continue
        if(point.gt.4000) then
          write(lout,10000)
          call closeUnits
+if cr
      call abend('Problem with data in fort.23')
+ei
+if .not.cr
          stop
+ei
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hda(njx,njx+njz,np,point)=cc+hda(njx,njx+njz,np,point)
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      goto 10
!-----------------------------------------------------------------------
!---- DEFINES DATA FOR THE ROUTINE OBJFUN
!-----------------------------------------------------------------------
   30 if(jeltot.eq.1) then
!-----------------------------------------------------------------------
        do 50 jcomp=0,maxcomp
          icont=0
          do 40 jord=0,2
            j1=jord
!-----------------------------------------------------------------------
            icont=icont+1
            kointer=j1
!-----------------------------------------------------------------------
            user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,kointer)
   40     continue
   50   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
        do 80 jcomp=0,maxcomp
          icont=0
          do 70 jord=0,2
            do 60 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              icont=icont+1
              kointer=j1+j2*3
!-----------------------------------------------------------------------
              user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,kointer)
   60       continue
   70     continue
   80   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
        do 120 jcomp=0,maxcomp
          icont=0
          do 110 jord=0,2
            do 100 j1=0,jord
              do 90 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                icont=icont+1
                kointer=(j1+j2*3)+j3*3**2                                !hr04
!-----------------------------------------------------------------------
                user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord, kointer)
   90         continue
  100       continue
  110     continue
  120   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
        do 170 jcomp=0,maxcomp
          icont=0
          do 160 jord=0,2
            do 150 j1=0,jord
              do 140 j2=0,jord-j1
                do 130 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                  icont=icont+1
                  kointer=((j1+j2*3)+j3*3**2)+j4*3**3                    !hr04
!-----------------------------------------------------------------------
                  user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,       &
     &kointer)
  130           continue
  140         continue
  150       continue
  160     continue
  170   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
        do 230 jcomp=0,maxcomp
          icont=0
          do 220 jord=0,2
            do 210 j1=0,jord
              do 200 j2=0,jord-j1
                do 190 j3=0,jord-j1-j2
                  do 180 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    icont=icont+1
                    kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4        !hr04
!-----------------------------------------------------------------------
                    user(jcomp*nmax+icont)=hda(jcomp,jaord+1, jpord,    &
     &kointer)
  180             continue
  190           continue
  200         continue
  210       continue
  220     continue
  230   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
        do 300 jcomp=0,maxcomp
          icont=0
          do 290 jord=0,2
            do 280 j1=0,jord
              do 270 j2=0,jord-j1
                do 260 j3=0,jord-j1-j2
                  do 250 j4=0,jord-j1-j2-j3
                    do 240 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      icont=icont+1
                 kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5 !hr04
!-----------------------------------------------------------------------
                      user(jcomp*nmax+icont)=hda(jcomp,jaord+1, jpord,  &
     &kointer)
  240               continue
  250             continue
  260           continue
  270         continue
  280       continue
  290     continue
  300   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(//,t10,' INDEX OUT OF BOUND IN ROUTINE READD ')
      end
      subroutine hamilton1(ja,jp)
!-----------------------------------------------------------------------
!---- COMPUTES THE VALUE OF THE HAMILTONIAN AFTER CORRECTIONS
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer j1,j2,j3,j4,j5,j6,ja,jcomp,jel,jord,jp,l,ncoef,kointer
      double precision tham
      dimension tham(0:3)
+ca commadha
+ca commadh1
      save
!-----------------------------------------------------------------------
      do 10 jcomp=0,3
        tham(jcomp)=0d0
   10 continue
!-----------------------------------------------------------------------
      if(jp.eq.0) then
        ncoef=ja
      else
        ncoef=1
      end if
!-----------------------------------------------------------------------
      goto(20,50,90,140,200,270) jeltot
      goto 350
!-----------------------------------------------------------------------
   20 do 40 jord=0,2
        j1=jord
!-----------------------------------------------------------------------
        kointer=j1
!-----------------------------------------------------------------------
        do 30 l=0,ncoef
          tham(l)=tham(l)+hda(l,ja,jp,kointer)*(x(1)**j1)
   30   continue
   40 continue
!-----------------------------------------------------------------------
      goto 350
!-----------------------------------------------------------------------
   50 do 80 jord=0,2
        do 70 j1=0,jord
          j2=jord-j1
!-----------------------------------------------------------------------
          kointer=j1+j2*3
!-----------------------------------------------------------------------
          do 60 l=0,ncoef
            tham(l)=tham(l)+(hda(l,ja,jp,kointer)*(x(1)**j1))*(x(2)**j2) !hr04
   60     continue
   70   continue
   80 continue
!-----------------------------------------------------------------------
      goto 350
!-----------------------------------------------------------------------
   90 do 130 jord=0,2
        do 120 j1=0,jord
          do 110 j2=0,jord-j1
            j3=jord-j1-j2
!-----------------------------------------------------------------------
            kointer=(j1+j2*3)+j3*3**2                                    !hr04
!-----------------------------------------------------------------------
            do 100 l=0,ncoef
              tham(l)=tham(l)+((hda(l,ja,jp,kointer)*(x(1)**j1))        &!hr04
     &*(x(2)**j2))*(x(3)**j3)                                            !hr04
  100       continue
  110     continue
  120   continue
  130 continue
!-----------------------------------------------------------------------
      goto 350
!-----------------------------------------------------------------------
  140 do 190 jord=0,2
        do 180 j1=0,jord
          do 170 j2=0,jord-j1
            do 160 j3=0,jord-j1-j2
              j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
              kointer=((j1+j2*3)+j3*3**2)+j4*3**3                        !hr04
!-----------------------------------------------------------------------
              do 150 l=0,ncoef
                tham(l)=tham(l)+(((hda(l,ja,jp,kointer)*(x(1)**j1))     &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
  150         continue
  160       continue
  170     continue
  180   continue
  190 continue
!-----------------------------------------------------------------------
      goto 350
!-----------------------------------------------------------------------
  200 do 260 jord=0,2
        do 250 j1=0,jord
          do 240 j2=0,jord-j1
            do 230 j3=0,jord-j1-j2
              do 220 j4=0,jord-j1-j2-j3
                j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4            !hr04
!-----------------------------------------------------------------------
                do 210 l=0,ncoef
                  tham(l)=tham(l)+((((hda(l,ja,jp,kointer)*(x(1)**j1))  &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
  210           continue
  220         continue
  230       continue
  240     continue
  250   continue
  260 continue
!-----------------------------------------------------------------------
      goto 350
!-----------------------------------------------------------------------
  270 do 340 jord=0,2
        do 330 j1=0,jord
          do 320 j2=0,jord-j1
            do 310 j3=0,jord-j1-j2
              do 300 j4=0,jord-j1-j2-j3
                do 290 j5=0,jord-j1-j2-j3-j4
                  j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                 kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5 !hr04
!-----------------------------------------------------------------------
                  do 280 l=0,ncoef
                 tham(l)=tham(l)+(((((hda(l,ja,jp,kointer) *(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
  280             continue
  290           continue
  300         continue
  310       continue
  320     continue
  330   continue
  340 continue
!-----------------------------------------------------------------------
  350 do 360 jel=0,ncoef
        ham(jel)=tham(jel)
  360 continue
!-----------------------------------------------------------------------
      return
!-----------------------------------------------------------------------
      end
      subroutine objfun1(mode,n,x,objf,objgrd,nstate,iuser,user)
!-----------------------------------------------------------------------
!---- ROUTINE TO COMPUTE THE VALUE OF THE FUNCTION AND OF ITS
!---- DERIVATIVES
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer icont,iuser,j1,j2,j3,j4,j5,j6,jel,jord,jvar,l,mode,n,nmax,&
     &nstate,kointer
      real user
      double precision fder,fun,objf,objgrd,x
      dimension iuser(*),x(10),objgrd(10),user(*),fun(0:3),fder(0:3,10)
      save
!-----------------------------------------------------------------------
      nmax=40
!-----------------------------------------------------------------------
      do 20 jel=0,3
        do 10 jvar=1,n
          fder(jel,jvar)=0d0
   10   continue
        fun(jel)=0d0
   20 continue
!-----------------------------------------------------------------------
      if(n.eq.1) then
!-----------------------------------------------------------------------
        do 40 l=0,iuser(3)
          icont=0
          do 30 jord=0,2
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
            icont=icont+1
!-----------------------------------------------------------------------
            fun(l)=fun(l)+user(l*nmax+icont)*(x(1)**j1)
            fder(l,1)=fder(l,1)+(user(l*nmax+icont)*dble(j1))*(x(1)     &!hr04
     &**(j1-1))                                                          !hr04
   30     continue
   40   continue
!-----------------------------------------------------------------------
      else if(n.eq.2) then
!-----------------------------------------------------------------------
        do 70 l=0,iuser(3)
          icont=0
          do 60 jord=0,2
            do 50 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*3
              icont=icont+1
!-----------------------------------------------------------------------
              fun(l)=fun(l)+(user(l*nmax+icont)*(x(1)**j1))*(x(2)**j2)
              fder(l,1)=fder(l,1)+((user(l*nmax+icont)*dble(j1))*(x(1)  &!hr04
     &**(j1-1)))*(x(2)**j2)                                              !hr04
              fder(l,2)=fder(l,2)+((user(l*nmax+icont)*dble(j2))        &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1))                                        !hr04
   50       continue
   60     continue
   70   continue
!-----------------------------------------------------------------------
      else if(n.eq.3) then
!-----------------------------------------------------------------------
        do 110 l=0,iuser(3)
          icont=0
          do 100 jord=0,2
            do 90 j1=0,jord
              do 80 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*3)+j3*3**2                                !hr04
                icont=icont+1
!-----------------------------------------------------------------------
              fun(l)=fun(l)+((user(l*nmax+icont)*(x(1)**j1))*(x(2)**j2))&!hr04
     &*(x(3)**j3)                                                        !hr04
              fder(l,1)=fder(l,1)+(((user(l*nmax+icont)*dble(j1))*(x(1) &!hr04
     &**(j1-1)))*(x(2)**j2))*(x(3)**j3)                                  !hr04
                fder(l,2)=fder(l,2)+(((user(l*nmax+icont)*dble(j2))     &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3)                            !hr04
                fder(l,3)=fder(l,3)+(((user(l*nmax+icont)*dble(j3))     &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1))                            !hr04
   80         continue
   90       continue
  100     continue
  110   continue
!-----------------------------------------------------------------------
      else if(n.eq.4) then
!-----------------------------------------------------------------------
        do 160 l=0,iuser(3)
          icont=0
          do 150 jord=0,2
            do 140 j1=0,jord
              do 130 j2=0,jord-j1
                do 120 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                  kointer=j1+j2*3+j3*3**2+j4*3**3
                  icont=icont+1
!-----------------------------------------------------------------------
                  fun(l)=fun(l)+(((user(l*nmax+icont)*(x(1)**j1))       &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
                fder(l,1)=fder(l,1)+((((user(l*nmax+icont)*dble(j1))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3 )**j3))*(x(4)**j4)                  !hr04
                  fder(l,2)=fder(l,2)+((((user(l*nmax+icont)*dble(j2))  &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3 )**j3))*(x(4)**j4)               !hr04
                  fder(l,3)=fder(l,3)+((((user(l*nmax+icont)*dble(j3))  &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3 )**(j3-1)))*(x(4)**j4)               !hr04
                  fder(l,4)=fder(l,4)+((((user(l*nmax+icont)*dble(j4))  &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3 )**j3))*(x(4)**(j4-1))               !hr04
  120           continue
  130         continue
  140       continue
  150     continue
  160   continue
!-----------------------------------------------------------------------
      else if(n.eq.5) then
!-----------------------------------------------------------------------
        do 220 l=0,iuser(3)
          icont=0
          do 210 jord=0,2
            do 200 j1=0,jord
              do 190 j2=0,jord-j1
                do 180 j3=0,jord-j1-j2
                  do 170 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4        !hr04
                    icont=icont+1
!-----------------------------------------------------------------------
                    fun(l)=fun(l)+((((user(l*nmax+icont)*(x(1)**j1))    &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
                 fder(l,1)=fder(l,1)+(((((user(l*nmax+icont) *dble(j1)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                 fder(l,2)=fder(l,2)+(((((user(l*nmax+icont) *dble(j2)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                 fder(l,3)=fder(l,3)+(((((user(l*nmax+icont) *dble(j3)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                 fder(l,4)=fder(l,4)+(((((user(l*nmax+icont) *dble(j4)) &
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &
     &*(x(5)**j5)
                 fder(l,5)=fder(l,5)+(((((user(l*nmax+icont) *dble(j5)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)            &!hr04
     &**(j5-1))                                                          !hr04
  170             continue
  180           continue
  190         continue
  200       continue
  210     continue
  220   continue
!-----------------------------------------------------------------------
      else if(n.eq.6) then
!-----------------------------------------------------------------------
        do 290 l=0,iuser(3)
          icont=0
          do 280 jord=0,2
            do 270 j1=0,jord
              do 260 j2=0,jord-j1
                do 250 j3=0,jord-j1-j2
                  do 240 j4=0,jord-j1-j2-j3
                    do 230 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                 kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5
                      icont=icont+1
!-----------------------------------------------------------------------
                     fun(l)=fun(l)+(((((user(l*nmax+icont) *(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
                fder(l,1)=fder(l,1)+((((((user(l*nmax+icont) *dble(j1)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
                fder(l,2)=fder(l,2)+((((((user(l*nmax+icont) *dble(j2)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
                fder(l,3)=fder(l,3)+((((((user(l*nmax+icont) *dble(j3)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
                fder(l,4)=fder(l,4)+((((((user(l*nmax+icont) *dble(j4)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
                fder(l,5)=fder(l,5)+((((((user(l*nmax+icont) *dble(j5)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x               &!hr04
     &(5)**(j5-1)))*(x(6)**j6)                                           !hr04
                fder(l,6)=fder(l,6)+((((((user(l*nmax+icont) *dble(j6)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))                  &!hr04
     &*(x(5)**j5))*(x(6)**(j6-1))                                        !hr04
  230               continue
  240             continue
  250           continue
  260         continue
  270       continue
  280     continue
  290   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      if(iuser(2).eq.0) then
!-----------------------------------------------------------------------
        if(iuser(1).eq.1) then
!-----------------------------------------------------------------------
          objf=(((2.d0*fun(0)**2+fun(1)**2)+2.d0*fun(2)**2)+fun         &
     &(0)*fun(1))+fun(2)*fun(1)
!-----------------------------------------------------------------------
          do 300 jvar=1,n
          objgrd(jvar)=((4.d0*fun(0)+fun(1))*fder(0,jvar)+ ((2.d0*fun(1)&!hr04
     &+fun(0))+fun(2))*fder(1,jvar))+ (4.d0*fun(2)+fun(1))*fder         &!hr04
     &(2,jvar)                                                           !hr04
  300     continue
!-----------------------------------------------------------------------
        else
!-----------------------------------------------------------------------
          objf=(((((((27.d0*fun(3)**2+5.d0*fun(2)**2)+5.d0*fun(1)**2)+  &!hr04
     &27.d0*fun(0)**2)+                                                 &!hr04
     &9.d0*fun(3)*fun(2))+9.d0*fun(1)*fun(0))+6.d0*fun(2)*fun           &!hr04
     &(1))+3.d0*fun(3)*fun(1))+3.d0*fun(2)*fun(0)                        !hr04
!-----------------------------------------------------------------------
          do 310 jvar=1,n
        objgrd(jvar)=((((54.d0*fun(3)+9.d0*fun(2))+3.d0*fun(1)) *fder   &!hr04
     &(3,jvar) +(((10.d0*fun(2)+9.d0*fun(3))+6.d0*fun(1))+3.d0* fun(0)  &!hr04
     &)*fder(2,jvar))+(((10.d0*fun(1)+9.d0*fun(0))+6.d0*fun(2))+3.d0*   &!hr04
     &fun(3))*fder(1,jvar))+((54.d0*fun(0)+9.d0*fun(1))+3.d0*fun(2))    &!hr04
     &*fder(0,jvar)                                                      !hr04
  310     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
      else
!-----------------------------------------------------------------------
        objf=fun(0)**2+fun(1)**2                                         !hr04
        do 320 jvar=1,n
          objgrd(jvar)=(2.d0*fun(0))*fder(0,jvar) +(2.d0*fun(1))*fder   &!hr04
     &(1,jvar)                                                           !hr04
  320   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      return
      end
+dk cor_glo
      subroutine coruglo
!-----------------------------------------------------------------------
!---- PROGRAM FOR THE TUNESHIFT CORRECTIONS
!----
!----   =========>            CHROMATIC EFFECTS                <========
!----   =========>           GLOBAL MINIMIZATION               <========
!----
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ifail,istate,iter,itype,iuser,iwork,j,jbound,jcol,      &
     &jcomp,jconf,jord,jrow,jsex,jvar,kcol,l,liwork,lwork,mcor,n,nclin, &
     &ncnln,ndim2,nout,nrowa,nrowj,nrowr
      real a,bl,bu,c,cjac,clamda,objf,objgrd,r,user,work
      double precision ainv,bmat,chia,chib,cmat,cvec,delta,detinv,dvec, &
     &pi2in,sex,sgn,value
      external e04udm,objfun2
      parameter(mcor = 10)
      parameter(ndim2 = 6)
+ca commondl
+ca commadha
+ca commadh2
      dimension a(2,10),cjac(1,1),c(1)
      dimension r(10,10),bu(20),bl(20),clamda(20),objgrd(10)
      dimension ainv(2,2),bmat(2,10),cmat(2,10),cvec(2),dvec(2)
      dimension work(450),user(500),sex(10),sgn(10,10)
      dimension istate(20),iwork(40),iuser(2)
      data sgn/100*1d0/ainv,bmat,cmat,cvec,dvec/48*0d0/
      save
!-----------------------------------------------------------------------
+if crlibm
      pi2in=1d0/(8d0*atan_rn(1d0))
+ei
+if .not.crlibm
      pi2in=1d0/(8d0*atan(1d0))
+ei
!-----------------------------------------------------------------------
      do 30 i=0,4
        do 20 j=1,5
          do 10 l=0,8000
            hda(i,j,l)=0d0
            if(i.le.1) hdp(i,j,l)=0d0
   10     continue
   20   continue
   30 continue
!-----------------------------------------------------------------------
      do 40 j=1,10
        sgn(j,j)=-1d0
   40 continue
!-----------------------------------------------------------------------
!---- SPECIFIES THE I/O UNITS FOR THE NAG ROUTINES
!-----------------------------------------------------------------------
      nout=26
      call x04abf(1,nout)
!-----------------------------------------------------------------------
      jeltot=ncor
!-----------------------------------------------------------------------
      delta=dpmax
      nordm=nmom1
      nordp=nmom2
!-----------------------------------------------------------------------
      value=0.d0
!-----------------------------------------------------------------------
      itype=0
!-----------------------------------------------------------------------
      call readd2(user)
!-----------------------------------------------------------------------
!---- DEFINES THE MATRIX WITH THE LINEAR CONSTRAINTS
!-----------------------------------------------------------------------
      do 70 jrow=1,2
        do 50 jcol=1,jeltot
          a(jrow,jcol)=hdp(jrow-1,1,(nordp+1)**(jcol-1))
   50   continue
        do 60 jcol=1,jeltot-2
          bmat(jrow,jcol)=-1d0*a(jrow,jcol+2)                            !hr04
   60   continue
!-----------------------------------------------------------------------
        cvec(jrow)=-1d0*hdp(jrow-1,1,0)                                  !hr04
   70 continue
!-----------------------------------------------------------------------
!---- DEFINES THE RELATION BETWEEN THE FIRST TWO SEXTUPOLES AND THE
!---- OTHERS
!-----------------------------------------------------------------------
      detinv=1.d0/(a(1,1)*a(2,2)-a(2,1)*a(1,2))
      ainv(1,1)=detinv*a(2,2)
      ainv(1,2)=(-1d0*detinv)*a(1,2)                                     !hr04
      ainv(2,1)=(-1d0*detinv)*a(2,1)                                     !hr04
      ainv(2,2)=detinv*a(1,1)
!-----------------------------------------------------------------------
      do 110 jrow=1,2
!-----------------------------------------------------------------------
        do 90 jcol=1,jeltot
          do 80 kcol=1,2
            cmat(jrow,jcol)=cmat(jrow,jcol)+ainv(jrow,kcol) *bmat       &
     &(kcol,jcol)
   80     continue
!-----------------------------------------------------------------------
   90   continue
        do 100 jcol=1,2
          dvec(jrow)=dvec(jrow)+ainv(jrow,jcol)*cvec(jcol)
  100   continue
  110 continue
!-----------------------------------------------------------------------
!---- WRITES ON THE EXIT FILE
!-----------------------------------------------------------------------
      write(lout,10000)
      write(lout,10010)
      write(lout,10020) jeltot,nordm,nordp,delta,weig1,weig2,value
      write(lout,10030)
!-----------------------------------------------------------------------
      do 210 jconf=1,jeltot-2
!-----------------------------------------------------------------------
!---- INITIALIZATION
!-----------------------------------------------------------------------
        iuser(1)=nordp
        iuser(2)=nordm
        user(1)=weig1
        user(2)=weig2
        user(3)=value
        user(4)=delta*1.d3
        user(5)=1.d0/(user(4)**(2*nordm+1))
!-----------------------------------------------------------------------
!---- DEFINES EXTRA PARAMETERS
!-----------------------------------------------------------------------
        n=jeltot
        nclin=2
        ncnln=0
        nrowa=2
        nrowj=1
        nrowr=10
!-----------------------------------------------------------------------
        liwork=30
        lwork=450
!-----------------------------------------------------------------------
        do 120 jbound=1,n
          bu(jbound)=1.d2
          bl(jbound)=-1.d2
  120   continue
!-----------------------------------------------------------------------
        do 130 jbound=1,nclin
          bu(n+jbound)=-1d0*hdp(jbound-1,1,0)                            !hr04
          bl(n+jbound)=-1d0*hdp(jbound-1,1,0)                            !hr04
  130   continue
!-----------------------------------------------------------------------
        do 140 jvar=1,n
          x(jvar)=0.d0
  140   continue
!-----------------------------------------------------------------------
!---- DEFINES THE INITIAL GUESS SO THAT IT SATISFIES THE LINEAR
!---- CONSTRAINTS
!-----------------------------------------------------------------------
        do 160 jvar=1,2
          do 150 jcol=1,n-2
            x(jvar)=(x(jvar)+cmat(jvar,jcol)*sgn(jcol,jconf))+dvec(jvar) !hr04
            x(jcol+2)=sgn(jcol,jconf)
  150     continue
  160   continue
!-----------------------------------------------------------------------
        ifail=-1
!-----------------------------------------------------------------------
        call e04uef('MAJOR ITERATION LIMIT = 100')
!-----------------------------------------------------------------------
        call e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,e04udm,     &
     &objfun2,iter,istate,c,cjac,clamda,objf,objgrd,r,x,iwork,liwork,   &
     &work,lwork,iuser,user,ifail)
!-----------------------------------------------------------------------
        if(ifail.ne.0.and.ifail.ne.5) then
!-----------------------------------------------------------------------
          write(lout,10040) ifail
          call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
          stop
+ei
        end if
!-----------------------------------------------------------------------
        do 170 jsex=1,jeltot
          sex(jsex)=x(jsex)
          write(lout,10050) coel(jsex),sex(jsex)
  170   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN DP/P AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 180 jord=1,nordp
!-----------------------------------------------------------------------
          iamp=0
!-----------------------------------------------------------------------
          call hamilton2(jord)
!-----------------------------------------------------------------------
!---- WRITES THE VALUES OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10060) jord
          write(lout,10070)
          write(lout,10080) hdp(1,jord,0),hdp(0,jord,0)
          write(lout,10090)
          write(lout,10080) hamp(1),hamp(0)
          write(lout,10100)
!-----------------------------------------------------------------------
  180   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN AMP AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 200 jord=2,norda
!-----------------------------------------------------------------------
          iamp=1
!-----------------------------------------------------------------------
          call hamilton2(jord)
!-----------------------------------------------------------------------
!---- COMPUTES THE FUNCTION CHI
!-----------------------------------------------------------------------
          if(jord.eq.2) then
!-----------------------------------------------------------------------
         chib=(pi2in/sqrt(3.d0))*sqrt((((2.d0*hda(0,2,0)**2 +hda(1,2,0) &!hr04
     &**2)+2.d0*hda(2,2,0)**2)+hda(0,2,0) *hda(1,2,0))+hda(1,2,0)*hda   &!hr04
     &(2,2,0))                                                           !hr04
            chia=(pi2in/sqrt(3.d0))*sqrt((((2.d0*hama(0)**2+hama(1)**2) &
     &+2.d0*hama(2)**2)+hama(0)*hama(1))+hama(1)*hama(2))
!-----------------------------------------------------------------------
          else if(jord.eq.3) then
!-----------------------------------------------------------------------
            chib=(pi2in/sqrt(30.d0))*                                   &!hr04
     &sqrt((((((((27.d0*hda(3,3,0)**2 +5.d0*hda                         &!hr04
     &(2,3,0)**2)+5.d0*hda(1,3,0)**2)+27.d0*hda(0,3,0)**2)+9.d0*hda     &!hr04
     &(3,3,0)*hda(2,3,0))+9.d0*hda(1,3,0)*hda(0,3,0))+6.d0*hda          &!hr04
     &(2,3,0)* hda(1,3,0))+3.d0*hda(3,3,0)*hda(1,3,0))+3.d0*hda         &!hr04
     &(2,3,0)*hda(0,3,0))                                                !hr04
            chia=(pi2in/sqrt(30.d0))*                                   &!hr04
     &sqrt((((((((27.d0*hama(3)**2 +5.d0*hama(2)                        &!hr04
     &**2)+5.d0*hama(1)**2)+27.d0*hama(0)**2)+9.d0*hama(3)*hama(2))     &!hr04
     &+9.d0*hama(1)*hama(0))+6.d0*hama(2)*hama(1))+3.d0*hama(3)         &!hr04
     &*hama(1))+3.d0*hama(2)*hama(0))                                    !hr04
!-----------------------------------------------------------------------
          end if
!-----------------------------------------------------------------------
!---- WRITES THE VALUE OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10110) jord
          write(lout,10120)
!-----------------------------------------------------------------------
          do 190 jcomp=0,jord
!-----------------------------------------------------------------------
            write(lout,10130) jcomp,jord-jcomp,hda(jcomp,jord,0), jcomp,
     &jord-jcomp,hama(jcomp)
!-----------------------------------------------------------------------
  190     continue
          write(lout,10140) jord-1,chib,jord-1,chia
          write(lout,10100)
!-----------------------------------------------------------------------
  200   continue
!-----------------------------------------------------------------------
  210 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
10000 format(//80('-')//t10,29('O')/t10,2('O'),25x,2('O')/t10,          &
     &'OO  TUNE-SHIFT CORRECTION  OO', /t10,2('O'),25x,2('O')/t10,29('O'&
     &)//80('-')//)
10010 format(//t26,'*** GLOBAL CHROMATIC CORRECTIONS ***'//)
10020 format(t10,'NUMBER OF CORRECTOR ELEMENTS ',t48,i8/ t10,           &
     &'MINIMUM ORDER OF THE MINIMIZATION ',t48,i8/ t10,                 &
     &'MAXIMUM ORDER OF THE MINIMIZATION ',t48,i8/ t10,                 &
     &'MAXIMUM VALUE OF MOMENTUM DEVIATION ',t48,f9.3/ t10,             &
     &'WEIGHT HORIZONTAL TUNE ',t48,f9.3/ t10,'WEIGHT VERTICAL TUNE ',  &
     &t48,f9.3/ t10,'QUADRATIC COEFFICIENT IN DP/P',t48,f9.3)
10030 format(//,t10,'VALUES OF THE INTEGRATED GRADIENTS OF THE ',       &
     &'CORRECTOR MULTIPOLES',//,t10,'GLOBAL MOMENTUM CORRECTIONS')
10040 format(//,t10,' ERROR IN ROUTINE E04UCF. IFAIL = ',i8)
10050 format(//,t10,'CORRECTOR ELEMENT  - ',a16,' - ',4x,e20.14)
10060 format(///,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,      &
     &'MOMENTUM DEPENDENCE ')
10070 format(//,t10,'BEFORE CORRECTION ')
10080 format(//,'H_1,0    = ',2x,e16.8,7x,'H_0,1    = ', 2x,e16.8)
10090 format(//,t10,'AFTER CORRECTION ')
10100 format(//80('-'))
10110 format(///,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,      &
     &'AMPLITUDE DEPENDENCE',/)
10120 format(//,t10,'BEFORE CORRECTION ',20x,'AFTER CORRECTION ')
10130 format(//,t10,'H_',i1,',',i1,'    = ',e16.8,11x, 'H_',i1,',',i1,  &
     &'    = ',e16.8)
10140 format(//,t10,'CHI_',i1,',0  = ',e16.8,11x, 'CHI_',i1,',0  = ',e16&
     &.8)
      end
      subroutine readd2(user)
!-----------------------------------------------------------------------
!---- SUBROUTINE TO READ DATA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer icont,ind,j,j1,j2,j3,j4,j5,j6,jcomp,jel,jord,jp,ncoef,njx,&
     &njx1,njz,njz1,nor,np,point,kointer
      real user
      double precision cc
+ca commadha
+ca commadh2
      dimension ind(10),user(500)
+if crlibm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      integer nofields
      parameter (nofields=20)
      character*(nchars) fields(nofields)
      integer errno,nfields,nunit,lineno,maxf,nf
      double precision fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      rewind 23
!-----------------------------------------------------------------------
! Unit 23 is opened round='nearest' if fio is selected
+if .not.crlibm
   10 read(23,*,end=40) ncoef,cc,nor,njx,njx1,njz,njz1,np,(ind(jel),jel &
     &=1,jeltot)
      read(23,*,end=40) cc
+ei
+if crlibm
   10 nunit=23
      read(23,*,end=40) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read (fields(1),*) ncoef
        nf=nf-1
      endif
      if (nf.gt.0) then
        cc=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(3),*) nor
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(4),*) njx
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(5),*) njx1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(6),*) njz
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(7),*) njz1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(8),*) np
        nf=nf-1
      endif
      do jel=1,jeltot
        if (nf.gt.0) then
          read (fields(8+jel),*) ind(jel)
          nf=nf-1
        endif
      enddo
      read(23,*,end=40) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cc=fround(errno,fields,1)
        nf=nf-1
      endif
+ei
!-----------------------------------------------------------------------
!---- CODING IND IN BASE NORDP+1
!-----------------------------------------------------------------------
      if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).eq.1.and. np.gt.0.and&
     &.np.le.nordp) then
        point=0
        do 20 j=1,jeltot
          point=point+ind(j)*(nordp+1)**(j-1)
   20   continue
        if(point.gt.8000) then
          write(lout,10000)
          call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
          stop
+ei
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hdp(njx,np,point)=cc+hdp(njx,np,point)
!-----------------------------------------------------------------------
      else if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).lt.10.and. np   &
     &.eq.0) then
        point=0
        norda=njx+njz
        do 30 j=1,jeltot
          point=point+ind(j)*(nordp+1)**(j-1)
   30   continue
        if(point.gt.8000) then
          write(lout,10000)
          call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
          stop
+ei
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hda(njx,njx+njz,point)=cc+hda(njx,njx+njz,point)
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      goto 10
!-----------------------------------------------------------------------
!---- DEFINES DATA FOR THE ROUTINE OBJFUN
!-----------------------------------------------------------------------
   40 icont=5
!-----------------------------------------------------------------------
      if(jeltot.eq.1) then
!-----------------------------------------------------------------------
        do 70 jcomp=0,1
          do 60 jp=nordm,nordp
            do 50 jord=0,jp
              j1=jord
!-----------------------------------------------------------------------
              icont=icont+1
              kointer=j1
!-----------------------------------------------------------------------
              user(icont)=hdp(jcomp,jp,kointer)
   50       continue
   60     continue
   70   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
        do 110 jcomp=0,1
          do 100 jp=nordm,nordp
            do 90 jord=0,jp
              do 80 j1=0,jord
                j2=jord-j1
!-----------------------------------------------------------------------
                icont=icont+1
                kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
                user(icont)=hdp(jcomp,jp,kointer)
   80         continue
   90       continue
  100     continue
  110   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
        do 160 jcomp=0,1
          do 150 jp=nordm,nordp
            do 140 jord=0,jp
              do 130 j1=0,jord
                do 120 j2=0,jord-j1
                  j3=jord-j1-j2
!-----------------------------------------------------------------------
                  icont=icont+1
                  kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2              !hr04
!-----------------------------------------------------------------------
                  user(icont)=hdp(jcomp,jp,kointer)
  120           continue
  130         continue
  140       continue
  150     continue
  160   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
        do 220 jcomp=0,1
          do 210 jp=nordm,nordp
            do 200 jord=0,jp
              do 190 j1=0,jord
                do 180 j2=0,jord-j1
                  do 170 j3=0,jord-j1-j2
                    j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                    icont=icont+1
                    kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4      &!hr04
     &*(nordp+1)**3                                                      !hr04
!-----------------------------------------------------------------------
                    user(icont)=hdp(jcomp,jp,kointer)
  170             continue
  180           continue
  190         continue
  200       continue
  210     continue
  220   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
        do 290 jcomp=0,1
          do 280 jp=nordm,nordp
            do 270 jord=0,jp
              do 260 j1=0,jord
                do 250 j2=0,jord-j1
                  do 240 j3=0,jord-j1-j2
                    do 230 j4=0,jord-j1-j2-j3
                      j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                      icont=icont+1
                      kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4   &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                      user(icont)=hdp(jcomp,jp,kointer)
  230               continue
  240             continue
  250           continue
  260         continue
  270       continue
  280     continue
  290   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
        do 370 jcomp=0,1
          do 360 jp=nordm,nordp
            do 350 jord=0,jp
              do 340 j1=0,jord
                do 330 j2=0,jord-j1
                  do 320 j3=0,jord-j1-j2
                    do 310 j4=0,jord-j1-j2-j3
                      do 300 j5=0,jord-j1-j2-j3-j4
                        j6=jord-j1-j2-j3-j4-j6
!-----------------------------------------------------------------------
                        icont=icont+1
                        kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)   &!hr04
     &+j4*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                 !hr04
!-----------------------------------------------------------------------
                        user(icont)=hdp(jcomp,jp,kointer)
  300                 continue
  310               continue
  320             continue
  330           continue
  340         continue
  350       continue
  360     continue
  370   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(//,t10,' INDEX OUT OF BOUND IN ROUTINE READD ')
      end
      subroutine hamilton2(jp)
!-----------------------------------------------------------------------
!---- COMPUTES THE VALUE OF THE HAMILTONIAN AFTER CORRECTIONS
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer j,j1,j2,j3,j4,j5,j6,jel,jord,jp,l,kointer
      double precision thama,thamp
+ca commadha
+ca commadh2
      dimension thamp(0:1),thama(0:4)
      save
!-----------------------------------------------------------------------
      if(iamp.eq.0) then
!-----------------------------------------------------------------------
        thamp(0)=0d0
        thamp(1)=0d0
!-----------------------------------------------------------------------
        if(jeltot.eq.1) then
!-----------------------------------------------------------------------
          do 20 jord=0,jp
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
!-----------------------------------------------------------------------
            do 10 l=0,1
              thamp(l)=thamp(l)+hdp(l,jp,kointer)*(x(1)**j1)
   10       continue
   20     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
          do 50 jord=0,jp
            do 40 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
              do 30 l=0,1
                thamp(l)=thamp(l)+hdp(l,jp,kointer)*(x(1)**j1)          &
     &*(x(2)**j2)
   30         continue
   40       continue
   50     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
          do 90 jord=0,jp
            do 80 j1=0,jord
              do 70 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2                !hr04
!-----------------------------------------------------------------------
                do 60 l=0,1
                  thamp(l)=thamp(l)+((hdp(l,jp,kointer)*(x(1)**j1))     &!hr04
     &*(x(2)**j2))*(x(3)**j3)                                            !hr04
   60           continue
   70         continue
   80       continue
   90     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
          do 140 jord=0,jp
            do 130 j1=0,jord
              do 120 j2=0,jord-j1
                do 110 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
               kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4*(nordp+1) &!hr04
     &**3                                                                !hr04
!-----------------------------------------------------------------------
                  do 100 l=0,1
                    thamp(l)=thamp(l)+(((hdp(l,jp,kointer)*(x(1)**j1))  &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
  100             continue
  110           continue
  120         continue
  130       continue
  140     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
          do 200 jord=0,jp
            do 190 j1=0,jord
              do 180 j2=0,jord-j1
                do 170 j3=0,jord-j1-j2
                  do 160 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4     &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                    do 150 l=0,1
                    thamp(l)=thamp(l)+((((hdp(l,jp,kointer)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
  150               continue
  160             continue
  170           continue
  180         continue
  190       continue
  200     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
          do 270 jord=0,jp
            do 260 j1=0,jord
              do 250 j2=0,jord-j1
                do 240 j3=0,jord-j1-j2
                  do 230 j4=0,jord-j1-j2-j3
                    do 220 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4  &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                    !hr04
!-----------------------------------------------------------------------
                      do 210 l=0,1
                   thamp(l)=thamp(l)+(((((hdp(l,jp,kointer)*(x(1)**j1)) &
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &
     &*(x(6)**j6)
  210                 continue
  220               continue
  230             continue
  240           continue
  250         continue
  260       continue
  270     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        do 280 jel=0,1
          hamp(jel)=thamp(jel)
  280   continue
!-----------------------------------------------------------------------
      else
!-----------------------------------------------------------------------
        do 290 j=0,4
          thama(j)=0.d0
  290   continue
!-----------------------------------------------------------------------
        if(jeltot.eq.1) then
!-----------------------------------------------------------------------
          do 310 jord=0,jp
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
!-----------------------------------------------------------------------
            do 300 l=0,jp
              thama(l)=thama(l)+hda(l,jp,kointer)*(x(1)**j1)
  300       continue
  310     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
          do 340 jord=0,jp
            do 330 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
              do 320 l=0,jp
                thama(l)=thama(l)+hda(l,jp,kointer)*(x(1)**j1)          &
     &*(x(2)**j2)
  320         continue
  330       continue
  340     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
          do 380 jord=0,jp
            do 370 j1=0,jord
              do 360 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2                !hr04
!-----------------------------------------------------------------------
                do 350 l=0,jp
                  thama(l)=thama(l)+((hda(l,jp,kointer)*(x(1)**j1))     &!hr04
     &*(x(2)**j2))*(x(3)**j3)                                            !hr04
  350           continue
  360         continue
  370       continue
  380     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
          do 430 jord=0,jp
            do 420 j1=0,jord
              do 410 j2=0,jord-j1
                do 400 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
               kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4*(nordp+1) &!hr04
     &**3                                                                !hr04
!-----------------------------------------------------------------------
                  do 390 l=0,jp
                    thama(l)=thama(l)+(((hda(l,jp,kointer)*(x(1)**j1))  &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
  390             continue
  400           continue
  410         continue
  420       continue
  430     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
          do 490 jord=0,jp
            do 480 j1=0,jord
              do 470 j2=0,jord-j1
                do 460 j3=0,jord-j1-j2
                  do 450 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4     &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                    do 440 l=0,jp
                    thama(l)=thama(l)+((((hda(l,jp,kointer)*(x(1)**j1)) &
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)
  440               continue
  450             continue
  460           continue
  470         continue
  480       continue
  490     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
          do 560 jord=0,jp
            do 550 j1=0,jord
              do 540 j2=0,jord-j1
                do 530 j3=0,jord-j1-j2
                  do 520 j4=0,jord-j1-j2-j3
                    do 510 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4  &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                    !hr04
!-----------------------------------------------------------------------
                      do 500 l=0,jp
                   thama(l)=thama(l)+(((((hda(l,jp,kointer)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
  500                 continue
  510               continue
  520             continue
  530           continue
  540         continue
  550       continue
  560     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        do 570 jel=0,jp
          hama(jel)=thama(jel)
  570   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      return
!-----------------------------------------------------------------------
      end
      subroutine objfun2(mode,n,x,objf,objgrd,nstate,iuser,user)
!-----------------------------------------------------------------------
!---- ROUTINE TO COMPUTE THE VALUE OF THE FUNCTION AND OF ITS
!---- DERIVATIVES
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer icont,iuser,j1,j2,j3,j4,j5,j6,jel,jord,jp,jvar,kord,l,    &
     &mode,n,nstate,kointer
      real user
      double precision add1,add2,fder,fun,objf,objgrd,sgn,tunedx,       &
     &tunedy,tunex,tuney,weight,x
      dimension x(10),objgrd(10),user(*),fun(0:1,10),fder(0:1,10,10)
      dimension iuser(*),tunedx(10),tunedy(10)
      save
!-----------------------------------------------------------------------
      do 30 jel=0,1
        do 20 jord=1,iuser(1)
          do 10 jvar=1,n
            fder(jel,jord,jvar)=0.d0
   10     continue
          fun(jel,jord)=0.d0
   20   continue
   30 continue
!-----------------------------------------------------------------------
      icont=5
!-----------------------------------------------------------------------
      if(n.eq.1) then
!-----------------------------------------------------------------------
        do 60 l=0,1
          do 50 jp=iuser(2),iuser(1)
            do 40 jord=0,jp
              j1=jord
!-----------------------------------------------------------------------
              kointer=j1
              icont=icont+1
!-----------------------------------------------------------------------
              fun(l,jp)=fun(l,jp)+user(icont)*(x(1)**j1)
              fder(l,jp,1)=fder(l,jp,1)+(user(icont)*dble(j1))*(x(1)    &!hr04
     &**(j1-1))                                                          !hr04
   40       continue
   50     continue
   60   continue
!-----------------------------------------------------------------------
      else if(n.eq.2) then
!-----------------------------------------------------------------------
        do 100 l=0,1
          do 90 jp=iuser(2),iuser(1)
            do 80 jord=0,jp
              do 70 j1=0,jord
                j2=jord-j1
!-----------------------------------------------------------------------
                kointer=j1+j2*(iuser(1)+1)
                icont=icont+1
!-----------------------------------------------------------------------
                fun(l,jp)=fun(l,jp)+(user(icont)*(x(1)**j1))*(x(2)**j2)  !hr04
                fder(l,jp,1)=fder(l,jp,1)+((user(icont)*dble(j1))*(x(1) &!hr04
     &**(j1-1)))*(x(2)**j2)                                              !hr04
                fder(l,jp,2)=fder(l,jp,2)+((user(icont)*dble(j2))       &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1))                                        !hr04
   70         continue
   80       continue
   90     continue
  100   continue
!-----------------------------------------------------------------------
      else if(n.eq.3) then
!-----------------------------------------------------------------------
        do 150 l=0,1
          do 140 jp=iuser(2),iuser(1)
            do 130 jord=0,jp
              do 120 j1=0,jord
                do 110 j2=0,jord-j1
                  j3=jord-j1-j2
!-----------------------------------------------------------------------
                  kointer=(j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2        !hr04
                  icont=icont+1
!-----------------------------------------------------------------------
               fun(l,jp)=fun(l,jp)+((user(icont)*(x(1)**j1))*(x(2)**j2))&!hr04
     &*(x(3)**j3)                                                        !hr04
                  fder(l,jp,1)=fder(l,jp,1)+(((user(icont)*dble(j1))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3)                               !hr04
                  fder(l,jp,2)=fder(l,jp,2)+(((user(icont)*dble(j2))    &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3)                            !hr04
                  fder(l,jp,3)=fder(l,jp,3)+(((user(icont)*dble(j3))    &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1))                            !hr04
  110           continue
  120         continue
  130       continue
  140     continue
  150   continue
!-----------------------------------------------------------------------
      else if(n.eq.4) then
!-----------------------------------------------------------------------
        do 210 l=0,1
          do 200 jp=iuser(2),iuser(1)
            do 190 jord=0,jp
              do 180 j1=0,jord
                do 170 j2=0,jord-j1
                  do 160 j3=0,jord-j1-j2
                    j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                    kointer=((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2)+j4&!hr04
     &*(iuser(1)+1)**3                                                   !hr04
                    icont=icont+1
!-----------------------------------------------------------------------
                    fun(l,jp)=fun(l,jp)+(((user(icont)*(x(1)**j1))      &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
                 fder(l,jp,1)=fder(l,jp,1)+((((user(icont)*dble(j1))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                   !hr04
                    fder(l,jp,2)=fder(l,jp,2)+((((user(icont)*dble(j2)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4)                !hr04
                    fder(l,jp,3)=fder(l,jp,3)+((((user(icont)*dble(j3)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4)                !hr04
                    fder(l,jp,4)=fder(l,jp,4)+((((user(icont)*dble(j4)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1))                !hr04
  160             continue
  170           continue
  180         continue
  190       continue
  200     continue
  210   continue
!-----------------------------------------------------------------------
      else if(n.eq.5) then
!-----------------------------------------------------------------------
        do 280 l=0,1
          do 270 jp=iuser(2),iuser(1)
            do 260 jord=0,jp
              do 250 j1=0,jord
                do 240 j2=0,jord-j1
                  do 230 j3=0,jord-j1-j2
                    do 220 j4=0,jord-j1-j2-j3
                      j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                   kointer=(((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2)+j4&!hr04
     &*(iuser(1)+1)**3)+j5*(iuser(1)+1)**4                               !hr04
                      icont=icont+1
!-----------------------------------------------------------------------
                      fun(l,jp)=fun(l,jp)+((((user(icont)*(x(1)**j1))   &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
                   fder(l,jp,1)=fder(l,jp,1)+(((((user(icont)*dble(j1)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                   fder(l,jp,2)=fder(l,jp,2)+(((((user(icont)*dble(j2)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                   fder(l,jp,3)=fder(l,jp,3)+(((((user(icont)*dble(j3)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                   fder(l,jp,4)=fder(l,jp,4)+(((((user(icont)*dble(j4)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &!hr04
     &*(x(5)**j5)                                                        !hr04
                   fder(l,jp,5)=fder(l,jp,5)+(((((user(icont)*dble(j5)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x               &!hr04
     &(5)**(j5-1))                                                       !hr04
  220               continue
  230             continue
  240           continue
  250         continue
  260       continue
  270     continue
  280   continue
!-----------------------------------------------------------------------
      else if(n.eq.6) then
!-----------------------------------------------------------------------
        do 360 l=0,1
          do 350 jp=iuser(2),iuser(1)
            do 340 jord=0,jp
              do 330 j1=0,jord
                do 320 j2=0,jord-j1
                  do 310 j3=0,jord-j1-j2
                    do 300 j4=0,jord-j1-j2-j3
                      do 290 j5=0,jord-j1-j2-j3-j4
                        j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                    kointer=((((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2) &!hr04
     &+j4*(iuser(1)+1)**3) +j5*(iuser(1)+1)**4)+j6                      &!hr04
     &*(iuser(1)+1)**4                                                   !hr04
                        icont=icont+1
!-----------------------------------------------------------------------
                       fun(l,jp)=fun(l,jp)+(((((user(icont)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
                       fder(l,jp,1)=fder(l,jp,1)+((((((user(icont)*dble &!hr04
     &(j1))*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))                     &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)
                       fder(l,jp,2)=fder(l,jp,2)+((((((user(icont)*dble &!hr04
     &(j2))*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))                     &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)                                !hr04
                       fder(l,jp,3)=fder(l,jp,3)+((((((user(icont)*dble &!hr04
     &(j3))*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))                     &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)                                !hr04
                       fder(l,jp,4)=fder(l,jp,4)+((((((user(icont)*dble &!hr04
     &(j4))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)                   &!hr04
     &**(j4-1)))*(x(5)**j5))*(x(6)**j6)                                  !hr04
                       fder(l,jp,5)=fder(l,jp,5)+((((((user(icont)*dble &!hr04
     &(j5))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))                         &!hr04
     &*(x(4)**j4))*(x(5)**(j5-1)))*(x(6)**j6)                            !hr04
                       fder(l,jp,6)=fder(l,jp,6)+((((((user(icont)*dble &!hr04
     &(j6))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))                         &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**(j6-1))                            !hr04
  290                 continue
  300               continue
  310             continue
  320           continue
  330         continue
  340       continue
  350     continue
  360   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      tunex=0.d0
      tuney=0.d0
!-----------------------------------------------------------------------
      do 370 jvar=1,n
        tunedx(jvar)=0.d0
        tunedy(jvar)=0.d0
  370 continue
!-----------------------------------------------------------------------
      do 400 jord=iuser(2),iuser(1)
        do 390 kord=iuser(2),iuser(1)
          sgn=1.d0
          if(((jord+kord)/2)*2.ne.(jord+kord)) sgn=-1.d0
          add1=1.d0/dble((jord+kord)+1)                                  !hr04
          add2=user(3)/dble((jord+kord)+3)                               !hr04
          weight=((user(4)**((jord+kord)+1))*(1.d0+sgn))*(add1+add2)*   &!hr04
     &user(5)                                                            !hr04
          tunex=tunex+(fun(0,jord)*fun(0,kord))*weight                   !hr04
          tuney=tuney+(fun(1,jord)*fun(1,kord))*weight                   !hr04
          do 380 jvar=1,n
            tunedx(jvar)=tunedx(jvar)+(fun(0,jord)*fder(0,kord, jvar))  &!hr04
     &*weight                                                            !hr04
            tunedy(jvar)=tunedy(jvar)+(fun(1,jord)*fder(1,kord, jvar))  &!hr04
     &*weight                                                            !hr04
  380     continue
  390   continue
  400 continue
!-----------------------------------------------------------------------
      objf=user(1)**2*tunex+user(2)**2*tuney                             !hr04
!-----------------------------------------------------------------------
      do 410 jvar=1,n
        objgrd(jvar)=(2.d0*user(1)**2)*tunedx(jvar)+ (2.d0*user(2)**2)  &
     &*tunedy(jvar)
  410 continue
!-----------------------------------------------------------------------
      return
      end
+dk errf
      subroutine errf(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! purpose:                                                             *
!   modification of wwerf, double precision complex error function,    *
!   written at cern by k. koelbig.                                     *
!   taken from mad8                                                    *
! input:                                                               *
!   xx, yy    (real)    argument to cerf.                              *
! output:                                                              *
!   wx, wy    (real)    function result.                               *
!----------------------------------------------------------------------*
!---- double precision version.
      implicit none
+if crlibm
+ca crlibco
+ei
      integer n,nc,nu
      double precision cc,h,one,q,rx,ry,saux,sx,sy,tn,two,tx,ty,wx,wy,x,&
     &xh,xl,xlim,xx,y,yh,ylim,yy
      parameter(cc = 1.12837916709551d0)
      parameter(one = 1.d0)
      parameter(two = 2.d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension rx(33),ry(33)
      save
!-----------------------------------------------------------------------
      x=abs(xx)
      y=abs(yy)
      if(y.lt.ylim.and.x.lt.xlim) then
        q=(one-y/ylim)*sqrt(one-(x/xlim)**2)
        h=one/(3.2d0*q)
        nc=7+int(23.0d0*q)                                               !hr05
!       xl=h**(1-nc)
+if crlibm
        xl=exp_rn((1-nc)*log_rn(h))                                      !yil11
+ei
+if .not.crlibm
        xl=exp((1-nc)*log(h))                                            !yil11
+ei
+if debug
!       call wda('errfq',q,nc,0,0,0)
!       call wda('errfh',h,nc,0,0,0)
!       call wda('errfxl',xl,nc,0,0,0)
+ei
+if debug
!       call wda('errfxlrn',xl,nc,0,0,0)
+ei
        xh=y+0.5d0/h
        yh=x
        nu=10+int(21d0*q)
+if debug
!       call wda('errfxh',xh,nu,0,0,0)
!       call wda('errfyh',yh,nu,0,0,0)
+ei
        rx(nu+1)=0d0
        ry(nu+1)=0d0
        do 10 n=nu,1,-1
          tx=xh+dble(n)*rx(n+1)                                          !hr05
          ty=yh-dble(n)*ry(n+1)                                          !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(n)=(0.5d0*tx)/tn                                            !hr05
          ry(n)=(0.5d0*ty)/tn                                            !hr05
   10   continue
        sx=0d0
        sy=0d0
        do 20 n=nc,1,-1
          saux=sx+xl
          sx=rx(n)*saux-ry(n)*sy
          sy=rx(n)*sy+ry(n)*saux
          xl=h*xl
   20   continue
        wx=cc*sx
        wy=cc*sy
      else
        xh=y
        yh=x
        rx(1)=0d0
        ry(1)=0d0
        do 30 n=9,1,-1
          tx=xh+dble(n)*rx(1)                                            !hr05
          ty=yh-dble(n)*ry(1)                                            !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(1)=(0.5d0*tx)/tn                                            !hr05
          ry(1)=(0.5d0*ty)/tn                                            !hr05
   30   continue
        wx=cc*rx(1)
        wy=cc*ry(1)
      endif
!      if(y.eq.0.) wx=exp(-x**2)
      if(yy.lt.0.d0) then
+if crlibm
        wx=(two*exp_rn(y**2-x**2))*cos_rn((two*x)*y)-wx                  !hr05
+ei
+if .not.crlibm
        wx=(two*exp(y**2-x**2))*cos((two*x)*y)-wx                        !hr05
+ei
+if crlibm
        wy=((-1d0*two)*exp_rn(y**2-x**2))*sin_rn((two*x)*y)-wy           !hr05
+ei
+if .not.crlibm
        wy=((-1d0*two)*exp(y**2-x**2))*sin((two*x)*y)-wy                 !hr05
+ei
        if(xx.gt.0.d0) wy=-1d0*wy                                        !hr05
      else
        if(xx.lt.0.d0) wy=-1d0*wy
      endif
      end
      subroutine wzsubv(n,vx,vy,vu,vv)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!  Vectorised for up to 64 argument values by E.McIntosh, 30.10.1997.
!  Much impoved using short vector buffers Eric 1st May, 2014.
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
!  *********************************************************************
      implicit none
      dimension vx(*),vy(*),vu(*),vv(*)
      integer i,j,k,n,vmu,vnu
      double precision a1,a2,b1,b2,vd12i,vd12r,vd23i,vd23r,             &
     &vd34i,vd34r,vp,vq,vqsq,vr,vsimag,vsreal,vt,vtdd13i,vtdd13r,       &
     &vtdd24i,vtdd24r,vtdddi,vtdddr,vti,vtr,vu,vusum,vusum3,vv,         &
     &vvsum,vvsum3,vw1i,vw1r,vw2i,vw2r,vw3i,vw3r,vw4i,vw4r,vx,          &
     &vxh,vxhrel,vy,vyh,vyhrel
      integer npart
+if .not.bignpart.and..not.hugenpart
      parameter(npart = 64)
+ei
+if bignpart.and..not.hugenpart
! See also +cd parpro
      parameter(npart = 2048)
+ei
+if hugenpart.and..not.bignpart
! See also +cd parpro
      parameter(npart = 65536)
+ei
      integer idim,kstep,nx,ny
      double precision h,half,hrecip,one,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77d0, ycut = 7.46d0 )
      parameter ( h = 1.d0/63.d0 )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      parameter ( half = 0.5d0, one = 1.d0 )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      parameter ( a1 = 0.5124242248d0, a2 = 0.0517653588d0 )
      parameter ( b1 = 0.2752551286d0, b2 = 2.7247448714d0 )
      double precision xm,xx,yy
      parameter (xm=1d120)
!     temporary arrays to facilitate vectorisation
      integer in,out,ins,outs
      dimension ins(npart),outs(npart)
!-----------------------------------------------------------------------
      save
      in=0
      out=0
      do i=1,n
        if (vx(i).ge.xcut.or.vy(i).ge.ycut) then
          out=out+1
          outs(out)=i
          if (out.eq.npart) then
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
            do j=1,out
              xx=vx(outs(j))
              yy=vy(outs(j))
              if (xx.ge.xm) xx=xm
              if (yy.ge.xm) yy=xm
              vp=xx**2-yy**2
              vq=(2.d0*xx)*yy
              vqsq=vq**2
!  First term.
              vt=vp-b1
              vr=a1/(vt**2+vqsq)
              vsreal=vr*vt
              vsimag=-vr*vq                              
!  Second term
              vt=vp-b2
              vr=a2/(vt**2+vqsq)
              vsreal=vsreal+vr*vt
              vsimag=vsimag-vr*vq
!  Multiply by i*z.
              vu(outs(j))=-(yy*vsreal+xx*vsimag)
              vv(outs(j))=xx*vsreal-yy*vsimag
            enddo
            out=0
          endif
        else
          in=in+1
          ins(in)=i
          if (in.eq.npart) then
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
            do j=1,in
              vxh = hrecip*vx(ins(j))
              vyh = hrecip*vy(ins(j))
              vmu = int(vxh)
              vnu = int(vyh)
!  Compute divided differences.
              k = 2 + vmu + vnu*kstep
              vw4r = wtreal(k)
              vw4i = wtimag(k)
              k = k - 1
              vw3r = wtreal(k)
              vw3i = wtimag(k)
              vd34r = vw4r - vw3r
              vd34i = vw4i - vw3i
              k = k + kstep
              vw2r = wtreal(k)
              vw2i = wtimag(k)
              vd23r = vw2i - vw3i
              vd23i = vw3r - vw2r
              vtr = vd23r - vd34r
              vti = vd23i - vd34i
              vtdd24r = vti - vtr
              vtdd24i = -1d0* ( vtr + vti )                             !hr05
              k = k + 1
              vw1r = wtreal(k)
              vw1i = wtimag(k)
              vd12r = vw1r - vw2r
              vd12i = vw1i - vw2i
              vtr = vd12r - vd23r
              vti = vd12i - vd23i
              vtdd13r = vtr + vti
              vtdd13i = vti - vtr
              vtdddr = vtdd13i - vtdd24i
              vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
              vxhrel = vxh - dble(vmu)
              vyhrel = vyh - dble(vnu)
              vusum3=half*(vtdd13r+                                     &
     &       (vxhrel*vtdddr-vyhrel*vtdddi))
              vvsum3=half*(vtdd13i+                                     &
     &       (vxhrel*vtdddi+vyhrel*vtdddr))
              vyhrel = vyhrel - one
              vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
              vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
              vxhrel = vxhrel - one
              vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
              vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
            enddo
            in=0
          endif
        endif
      enddo
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
      do j=1,out
        xx=vx(outs(j))
        yy=vy(outs(j))
        if (xx.ge.xm) xx=xm
        if (yy.ge.xm) yy=xm
        vp=xx**2-yy**2
        vq=(2.d0*xx)*yy
        vqsq=vq**2
!  First term.
        vt=vp-b1
        vr=a1/(vt**2+vqsq)
        vsreal=vr*vt
        vsimag=-vr*vq                              
!  Second term
        vt=vp-b2
        vr=a2/(vt**2+vqsq)
        vsreal=vsreal+vr*vt
        vsimag=vsimag-vr*vq
!  Multiply by i*z.
        vu(outs(j))=-(yy*vsreal+xx*vsimag)
        vv(outs(j))=xx*vsreal-yy*vsimag
      enddo
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
      do j=1,in
        vxh = hrecip*vx(ins(j))
        vyh = hrecip*vy(ins(j))
        vmu = int(vxh)
        vnu = int(vyh)
!  Compute divided differences.
        k = 2 + vmu + vnu*kstep
        vw4r = wtreal(k)
        vw4i = wtimag(k)
        k = k - 1
        vw3r = wtreal(k)
        vw3i = wtimag(k)
        vd34r = vw4r - vw3r
        vd34i = vw4i - vw3i
        k = k + kstep
        vw2r = wtreal(k)
        vw2i = wtimag(k)
        vd23r = vw2i - vw3i
        vd23i = vw3r - vw2r
        vtr = vd23r - vd34r
        vti = vd23i - vd34i
        vtdd24r = vti - vtr
        vtdd24i = -1d0* ( vtr + vti )                             !hr05
        k = k + 1
        vw1r = wtreal(k)
        vw1i = wtimag(k)
        vd12r = vw1r - vw2r
        vd12i = vw1i - vw2i
        vtr = vd12r - vd23r
        vti = vd12i - vd23i
        vtdd13r = vtr + vti
        vtdd13i = vti - vtr
        vtdddr = vtdd13i - vtdd24i
        vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
        vxhrel = vxh - dble(vmu)
        vyhrel = vyh - dble(vnu)
        vusum3=half*(vtdd13r+                                           &
     & (vxhrel*vtdddr-vyhrel*vtdddi))
        vvsum3=half*(vtdd13i+                                           &
     & (vxhrel*vtdddi+vyhrel*vtdddr))
        vyhrel = vyhrel - one
        vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
        vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
        vxhrel = vxhrel - one
        vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
        vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
      enddo
      return
      end
      subroutine wzsub(x,y,u,v)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!  *********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer k,mu,nu
      double precision a1,a2,b1,b2,d12i,d12r,d23i,d23r,d34i,d34r,p,     &
     &q,qsq,r,simag,sreal,t,tdd13i,tdd13r,tdd24i,tdd24r,tdddi,tdddr,ti, &
     &tr,u,usum,usum3,v,vsum,vsum3,w1i,w1r,w2i,w2r,w3i,w3r,w4i,w4r,x,xh,&
     &xhrel,y,yh,yhrel
+ca parpro
+ca parbeam
      parameter ( a1 = 0.5124242248d0, a2 = 0.0517653588d0 )
      parameter ( b1 = 0.2752551286d0, b2 = 2.7247448714d0 )
      save
!-----------------------------------------------------------------------
      if ( x.ge.xcut .or. y.ge.ycut ) goto 1000
      xh = hrecip*x
      yh = hrecip*y
      mu = int(xh)
      nu = int(yh)
!  Compute divided differences.
      k = 2 + mu + nu*kstep
      w4r = wtreal(k)
      w4i = wtimag(k)
      k = k - 1
      w3r = wtreal(k)
      w3i = wtimag(k)
      d34r = w4r - w3r
      d34i = w4i - w3i
      k = k + kstep
      w2r = wtreal(k)
      w2i = wtimag(k)
      d23r = w2i - w3i
      d23i = w3r - w2r
      tr = d23r - d34r
      ti = d23i - d34i
      tdd24r = ti - tr
      tdd24i = -1d0* ( tr + ti )                                         !hr05
      k = k + 1
      w1r = wtreal(k)
      w1i = wtimag(k)
      d12r = w1r - w2r
      d12i = w1i - w2i
      tr = d12r - d23r
      ti = d12i - d23i
      tdd13r = tr + ti
      tdd13i = ti - tr
      tdddr = tdd13i - tdd24i
      tdddi = tdd24r - tdd13r
!  Evaluate polynomial.
      xhrel = xh - dble(mu)
      yhrel = yh - dble(nu)
      usum3 = half*( tdd13r + ( xhrel*tdddr - yhrel*tdddi ) )
      vsum3 = half*( tdd13i + ( xhrel*tdddi + yhrel*tdddr ) )
      yhrel = yhrel - one
      usum = d12r + ( xhrel*usum3 - yhrel*vsum3 )
      vsum = d12i + ( xhrel*vsum3 + yhrel*usum3 )
      xhrel = xhrel - one
      u = w1r + ( xhrel*usum - yhrel*vsum )
      v = w1i + ( xhrel*vsum + yhrel*usum )
      return
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
 1000 p=x**2-y**2
      q=(2.d0*x)*y                                                       !hr05
      qsq=q**2
!  First term.
      t=p-b1
      r=a1/(t**2+qsq)
      sreal=r*t
      simag=(-1d0*r)*q                                                   !hr05
!  Second term
      t=p-b2
      r=a2/(t**2+qsq)
      sreal=sreal+r*t
      simag=simag-r*q
!  Multiply by i*z.
      u=-1d0*(y*sreal+x*simag)                                           !hr05
      v=x*sreal-y*simag
      return
!
      end
+dk adia
      subroutine adia(numx,e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-INCREASE
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer numx
      double precision e0f
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      if(numx.eq.1) phas0=phas
      if(numx.le.nde(1)) phas=zero
      if(numx.le.nde(1)) return
      if(numx.gt.nde(2)) phas=zero
      if(numx.gt.nde(2)) return
      phas=phas0
+if crlibm
      e0=e0+hsy(1)*sin_rn(phas)
+ei
+if .not.crlibm
      e0=e0+hsy(1)*sin(phas)
+ei
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
+dk adib
      subroutine adib(e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-DECREASE
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      double precision e0f
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      if(abs(phas0).le.pieni) return
+if crlibm
      e0=e0+hsy(1)*sin_rn(phas)
+ei
+if .not.crlibm
      e0=e0+hsy(1)*sin(phas)
+ei
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
+dk daten
      subroutine daten
!-----------------------------------------------------------------------
!  READS INPUT DATA FROM FILE FORT.3 AND/OR FORT.2
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,i1,i2,i3,ia,icc,ichrom0,iclr,ico,icy,idi,iexnum,iexread,&
     &ifiend16,ifiend8,ii,il1,ilin0,im,imo,imod,imtr0,irecuin,iw,iw0,ix,&
     &izu,j,j0,j1,j2,jj,k,k0,k10,k11,ka,ke,ki,kk,kpz,kzz,l,l1,l2,l3,l4, &
     &ll,m,mblozz,mout,mout1,mout3,mout4,nac,nbidu,ncy2,ndum,nfb,nft,   &
     &i4,i5
+if time
      integer ifiend35
      double precision tcnst
+ei
      double precision ak0d,akad,alc,alignx,alignz,apxx,apzz,bk0d,bkad, &
     &cosy,dummy,emitnx,emitny,extaux,halc,halc2,halc3,harm,phag,pmat,  &
     &qbet,qigam,r0,r0a,rdev,rmean,rsqsum,rsum,tilt,u0,                 &
     &xang,xstr,xpl0,xplane,xrms0,zpl0,zrms0
      !For BEAM-EXP
      double precision separx,separy
      double precision mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11
      
      character*16 sing,stru,prin,trac,diff,sync,ende,bloc,comm
      character*16 fluc,chro,tune,iter,limi,orbi,deco
      character*16 beze,bez0,go,rect,elli,comb,sear,subr
      character*16 free,geom,cavi,disp,reso,bezext
      character*16 idat,next,mult,line,init,ic0,imn,icel,irel
      character*16 iss,iqq,iele,ilm,ilm0,idum,corr,norm
      character*16 kl,kr,orga,post,ripp,beam,trom
      character*16 coll
      character*60 ihead
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      logical beam_xstr
+if crlibm
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,nf
      double precision fround
+ei
+if .not.crlibm
      integer nunit
+ei
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/
+ca parpro
+ca parnum
+ca commonex
+ca common
+ca commons
+ca commont1
+ca commondl
!
+if collimat
+ca collpara
+ca dbdaten
+ca dbpencil
+ca database
+ca dbcolcom
      logical has_coll
+ei
+if .not.collimat
      logical do_coll
+ei
!
+if bnlelens
+ca rhicelens
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca fma
+ca elensparam
+ca wireparam
+ca zipf
+ca parbeam_exp
      dimension icel(ncom,20),iss(2),iqq(5)
      dimension beze(nblo,nelb),ilm(nelb),ilm0(40),bez0(nele),ic0(10)
      dimension extaux(40),bezext(nblz)
      data sing,stru,prin,sync,ende,next,comm                           &
     &/'SING','STRU','PRIN','SYNC','ENDE','NEXT','COMM'/
      data fluc,mult,chro,iter,tune,line,trac,diff                      &
     &/'FLUC','MULT','CHRO','ITER','TUNE','LINE','TRAC','DIFF'/
      data limi,orbi,bloc,init,go,sear,subr,reso,disp,post,ripp,deco    &
     &/'LIMI','ORBI','BLOC','INIT','GO','SEAR','SUBR',                  &
     &'RESO','DISP','POST','RIPP','DECO'/
      data rect,elli,comb,free,geom,cavi,beam,trom                      &
     &/'RE','EL','COMB','FREE','GEOM','CAV','BEAM','TROM'/
      data idum,kl,kr,orga,norm,corr/' ','(',')','ORGA','NORM','CORR'/
      data coll /'COLL'/
!     - dump beam population:
      character*16 dump
      data dump /'DUMP'/
!     - dynamic kicks
      character*16 dynk
      data dynk /'DYNK'/
!     - fma
      character*16 fma
      data fma /'FMA'/
!     - elens
      character*16 elens
      data elens /'ELEN'/
!     - wire
      character*16 wire
      data wire /'WIRE'/
!     - zipf
      character*16 zipf
      data zipf /'ZIPF'/
+if crlibm
      double precision round_near
+ei
      save
!-----------------------------------------------------------------------
      if(mmul.lt.10.or.mmul.gt.20) call prror(85)
      irecuin=0
      iss(1)=' '
      iss(2)=' '
      do 10 i=1,5
        iqq(i)=' '
   10 continue
      do 20 i=1,nele
        bez0(i)=' '
   20 continue
      do 30 i=1,nblo
        do 30 j=1,nelb
          beze(i,j)=' '
   30 continue
      do 40 i=1,40
        ilm0(i)=' '
        extaux(i)=zero
   40 continue
      do 50 i=1,10
        coel(i)=' '
   50 continue
      do 60 i=1,ncom
        do 60 j=1,20
          icel(i,j)=' '
   60 continue
      do 70 i=1,10
        ic0(i)=' '
   70 continue
      do 80 i=1,nelb
        ilm(i)=' '
   80 continue
      emitnx=zero
      emitny=zero
      ihead=' '
      sixtit=' '
      nbidu=0
      iclo6=0
      iclo6r=0
      iclr=0
      icy=0
      ncy=0
      ncy2=0
      ndum=0
      numl=1
!  Initialise new input parameters
      numlmax=1000000
      numlcp=0
      napx=0
      amp(1)=c1m3
      amp0=zero
      ird=0
      imc=0
      idial=0
      idz(1)=1
      idz(2)=1
      idfor=0
      irew=0
      nde(1)=0
      nde(2)=0
      nwr(1)=1
      nwr(2)=1
      nwr(3)=1
      nwr(4)=10000
      ntwin=1
      harm=one
      alc=c1m3
      phag=zero
      tlen=one
      pma=pmap
      ition=0
      dpscor=one
      sigcor=one
      iconv=0
      imad=0
      iskip=1
      cma1=one
      cma2=one
      qs=zero
      itra=0
      chi0=zero
      chid=zero
      rat=zero
      ipos=0
      iav=1
      iwg=1
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      ivox=1
      ivoz=1
      ires=1
      dres=one
      ifh=0
      dfft=one
      idis=0
      icow=0
      istw=0
      iffw=0
      nprint=1
      ndafi=1
      itco=50
      dma=c1m12
      dmap=c1m15
      itcro=10
      dech=c1m10
      de0=c1m9
      ded=c1m9
      dsi=c1m9
      dsm0=c1m10
      itqv=10
      dkq=c1m10
      dqq=c1m10
      ichrom=0
      iqmod=0
      im=0
      imtr0=0
      ilin=0
      nlin=0
      iout=0
      idp=0
      izu0=0
      mmac=1
      mcut=0
      mout=0
      mout1=0
      mout2=0
      mout3=0
      mout4=0
      kanf=1
      iclo=0
      isub=0
      irmod2=0
      iorg=0
      ise=0
      iskew=0
      preda=c1m38
+if .not.collimat
      do_coll = .false.
+ei
+if collimat
      has_coll = .false.
+ei
   90 read(3,10010,end=1530,iostat=ierro) idat,ihead
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 90
      if(idat.ne.free.and.idat.ne.geom) call prror(1)
      imod=1
! imod=1: free, definition of elements in fort.3
! imod=2: geom, definition of elements in fort.2
      if(idat.eq.geom) imod=2
      write(lout,10130)
      write(lout,10030)
      write(lout,10180) ihead
      sixtit(1:60)=ihead
      if(imod.eq.1) write(lout,10190)
      if(imod.eq.2) write(lout,10200)
      write(lout,10130)
      if(imod.eq.2) then
  100   read(2,10000,end=1520,iostat=ierro) idat
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(idat(1:1).eq.'/') goto 100
! single elements
        if(idat.eq.sing) goto 120
          write(lout,*) "idat = '"//idat//"'"
          call prror(15)
        endif
  110 read(3,10000,end=1530,iostat=ierro) idat
      if(ierro.gt.0) call prror(58)
      nunit=3
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 110
      if(idat.eq.sing) goto 120
      if(idat.eq.bloc) goto 190
      if(idat.eq.stru) goto 320
      if(idat.eq.prin) goto 550
      if(idat.eq.disp) goto 170
      if(idat.eq.tune) goto 600
      if(idat.eq.sync) goto 710
      if(idat.eq.iter) goto 940
      if(idat.eq.fluc) goto 790
      if(idat.eq.mult) goto 740
      if(idat.eq.chro) goto 560
      if(idat.eq.trac) goto 510
      if(idat.eq.diff) goto 520
      if(idat.eq.line) goto 660
      if(idat.eq.limi) goto 950
      if(idat.eq.orbi) goto 980
      if(idat.eq.init) goto 500
      if(idat.eq.comb) goto 1030
      if(idat.eq.subr) goto 1110
      if(idat.eq.reso) goto 1120
      if(idat.eq.sear) goto 1200
      if(idat.eq.orga) goto 880
      if(idat.eq.post) goto 1280
      if(idat.eq.ripp) goto 1290
      if(idat.eq.deco) goto 1320
      if(idat.eq.comm) goto 1390
      if(idat.eq.norm) goto 1400
      if(idat.eq.corr) goto 1410
      if(idat.eq.beam) goto 1600
      if(idat.eq.trom) goto 1700
!GRD
      if(idat.eq.coll) goto 1285
!GRD

!     - dump beam population:
      if(idat.eq.dump) goto 2000

!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     brand new input block for dynamic kicks
!     always in main code
      if(idat.eq.dynk)  goto 2200
      if(idat.eq.fma)   goto 2300
      if(idat.eq.elens) goto 2400
      if(idat.eq.wire)  goto 2500
      !Reserved:
      !DIST = 2600
      !HION = 2700
      if(idat.eq.zipf) goto 2800
      
      if(idat.eq.next) goto 110
      if(idat.eq.ende) goto 771
      write(lout,*) "idat = '"//idat//"'"
      call prror(15)
!-----------------------------------------------------------------------
!  DATENBLOCK SINGLE ELEMENTS
!  ELLEMENTLISTE
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  120 i=1
  130 if(imod.eq.1) then
  140   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 140
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  150   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 150
        if(ch(:4).eq.next) then
  160     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 160
          if(idat.ne.bloc) then
            write(lout,*) "idat = '"//idat//"'"
            call prror(15)
          endif
          goto 190
        endif
      endif
!      if(ch(17:17).ne." ") call prror(104)
      i2=0
      do i1=1,80
        if(ch(i1:i1).ne." ".and.i2.eq.0) then
          i2=i1
        elseif(i2.gt.0) then
          if(ch(i1:i1).eq." ") then
            if(i1-i2.gt.16) then
              call prror(104)
            else
              goto 165
            endif
          endif
        endif
      enddo
 165  if(i1.gt.72) call prror(104)
      call intepr(1,1,ch,ch1) ! read in single element
!     write (*,*) 'ch1:'//ch1//':'
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,kz(i),ed(i),ek(i),el(i),bbbx(i),bbby(i),bbbs(i) !read fort.2 (or fort.3), idat -> bez = single element name, kz = type of element, ed,ek,el = strength, random error on strenght,length (can be anything),bbbx,bbby,bbbs = beam-beam, beam-beam parameters will be removed soon
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
!     write (*,*) 'ERIC'
      read(ch1,*) idat,kz(i),ed(i),ek(i),el(i),bbbx(i),bbby(i),bbbs(i)!read fort.2 (or fort.3), idat -> bez = single element name, kz = type of element, ed,ek,el = strength, random error on strenght,length (can be anything),bbbx,bbby,bbbs = beam-beam, beam-beam parameters will be removed soon
+ei
+if crlibm
!     write(*,*) 'eric'
      if (nunit.eq.2) then
        call splitfld(errno,nunit,lineno2,nofields,nf,ch1,fields) !fort.2 input
      elseif (nunit.eq.3) then
        call splitfld(errno,nunit,lineno3,nofields,nf,ch1,fields) !fort.3 input
      else
      call abend('ERIC!!! daten nunit NOT 2 nor 3!!!                ') 
      endif
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) kz(i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ed(i)=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ek(i)=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        el(i)=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbx(i)=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbby(i)=fround(errno,fields,7)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbs(i)=fround(errno,fields,8)
        nf=nf-1
      endif
+ei
+ei
      !Check that the name is unique
      do j=1,i-1! i = index of current line
         if ( bez(j).eq.idat ) then
            write(lout,*) "ERROR in DATEN:"
            write(lout,*) "Got multiple copies of element ", bez(j)
            call prror(-1)
         endif
      enddo

      if(kz(i).eq.25) then
        ed(i)=ed(i)/two
        ek(i)=ek(i)/two
      endif
!--CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
      if((kz(i).eq.4.or.kz(i).eq.5).and.abs(el(i)).gt.pieni)            &
     &ed(i)=-1d0*ed(i)                                                   !hr05
!--CAVITIES
      if(abs(kz(i)).eq.12) then
        if(abs(ed(i)).gt.pieni.and.abs(ek(i)).gt.pieni) then
          ncy2=ncy2+1
          itionc(i)=kz(i)/abs(kz(i))
          kp(i)=6
        endif
      endif
!----------------------------------------
! Handled by initialize_element subroutine:
!-----------------------------------------
!-- CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
!-- THIN LENS (+/- 1-10)
!-- MULTIPOLES (11)
!-- CAVITY (+/- 12)
!-- CRABCAVITY (23/-23) / CC multipoles order 2/3/4 (+/- 23/26/27/28)
!-- ELECTRON LENSE (29)
      call initialize_element(i,.true.)

!--ACDIPOLE
      if(abs(kz(i)).eq.16) then
        if(abs(ed(i)).le.pieni) then
           kz(i)=0
           ed(i)=0d0                                                     !hr05
           ek(i)=0d0                                                     !hr05
           el(i)=0d0                                                     !hr05
        else
           acdipph(i)=el(i)
           el(i)=0d0                                                     !hr05
        endif
      endif
!--General
      if(abs(el(i)).gt.pieni.and.kz(i).ne.0) ithick=1
      if(i.gt.nele-1) call prror(16)
      if(abs(kz(i)).ne.12 .or. (abs(kz(i)).eq.12.and.ncy2.eq.0) )kp(i)=0
! set element name
      bez(i)=idat
      bez0(i)=idat
      if(ncy2.eq.0) then
        !If no active RF cavities are seen so far in the single element list,
        ! add a CAV element to the end of the list.
        ! This is then overwritten when reading the next element, so that if
        ! and only if no active RF cavities are found, a CAV element can be
        ! used in the structure to enable 6D tracking using the parameters
        ! from the SYNC block.
        i=i+1
        il=i
        bez(i)=cavi
        bez0(i)=cavi
        kp(i)=6
      else
        il=i
        i=i+1
      endif
      goto 130
!-----------------------------------------------------------------------
!  DATENBLOCK DISPLACEMENT OF ELEMENTS
!-----------------------------------------------------------------------
  170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 170
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      xpl0=zero
      xrms0=zero
      zpl0=zero
      zrms0=zero
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,xpl0,xrms0,zpl0,zrms0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,xpl0,xrms0,zpl0,zrms0
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        xpl0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        xrms0=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zpl0=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zrms0=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
      do 180 j=1,il
        if(idat.ne.bez(j)) goto 180
        xpl(j)=xpl0
        xrms(j)=xrms0
        zpl(j)=zpl0
        zrms(j)=zrms0
!----Insertion for AC dipole
        if(abs(kz(j)).eq.16) then
          nturn1(j)=int(xpl0)
          nturn2(j)=int(xrms0)
          nturn3(j)=int(zpl0)
          nturn4(j)=int(zrms0)
          xpl(j)=0d0
          xrms(j)=0d0
          zpl(j)=0d0
          zrms(j)=0d0
          if(xrms0.eq.0d0.and.zpl0.eq.0d0.and.zrms0.eq.0d0) then         !hr05
            write(lout,*) "ac dipole disregarded (0 length)"
            kz(j)=0
            ed(j)=0d0                                                    !hr05
            ek(j)=0d0                                                    !hr05
          endif
        endif
  180 continue
      goto 170
!-----------------------------------------------------------------------
!  BLOCK DEFINITIONS
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  190 if(imod.eq.1) then
  200   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 200
      endif
      if(imod.eq.2) then
  210   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 210
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) mper,(msym(k),k=1,mper)
      if(mper.gt.nper) call prror(17)
      i=0
  220 do 230 m=1,40
  230 ilm0(m)=idum
      if(imod.eq.1) then
  240   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 240
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  250   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 250
        if(ch(:4).eq.next) then
  260     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 260
          if(idat.ne.stru) then
            write(lout,*) "idat = '"//idat//"'"
            call prror(15)
          endif
          goto 320
        endif
      endif
      call intepr(2,1,ch,ch1)
! reading character strings so OK
      read(ch1,*) idat,(ilm0(m),m=1,40)
      if(idat.eq.idum) goto 270
      i=i+1 ! Current BLOC number
      if(i.gt.nblo-1) call prror(18)
      bezb(i)=idat
      k0=0
      mblo=i ! Update total number of BLOCs
  270 ka=k0+1
      ke=k0+40
      do 300 l=ka,ke
        if(l.gt.nelb) call prror(26)
        ilm(l)=ilm0(l-k0)
        if(ilm(l).eq.idum) goto 310
        mel(i)=l         ! Number of single elements in this block
        beze(i,l)=ilm(l) ! Name of the current single element
        do 280 j=1,il    ! Search for the single element idx j
          if(bez0(j).eq.ilm(l)) goto 290
  280   continue
        erbez=ilm(l)
        call prror(19)
  290   mtyp(i,l)=j ! Block i / sub-element l has single element index j
        if(kz(j).ne.8) elbe(i)=elbe(i)+el(j) ! Count block length (kz=8 -> edge focusing->skip!)
  300 continue
  310 k0=l-1
      goto 220
!-----------------------------------------------------------------------
!  STRUCTURE INPUT
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  320 i=0
  330 do 340 k=1,40
  340 ilm0(k)=idum
      if(imod.eq.1) then
  350   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 350
      endif
      if(imod.eq.2) then
  360   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 360
      endif
      if(ch(:4).eq.next) goto 110
      i2=1
      ! Look for repetition with syntax N( ... )
      do 420 ii=1,80
        if(ch(ii:ii).eq.kl) then !kl='('
          if(ii.gt.1) then
            do 370 jj=1,ii-1
  370       if(ch(jj:jj).ne.' ') goto 380
          endif
          iw=1
          goto 390
  380     read(ch(:ii-1),*) iw
  390     ia=i
          iw0=iw-1
          i2=ii+1
          goto 430
        endif
        if(ch(ii:ii).eq.kr) then !kr=')'
          if(iw0.le.0) goto 330
          idi=i-ia
          do 410 k=1,iw0
            do 400 j=1,idi
  400       ic(i+j)=ic(i+j-idi)
            i=i+idi
  410     continue
          mbloz=i
          goto 330
        endif
  420 continue
      ! Create the structure
  430 call intepr(3,i2,ch,ch1)
! reading character strings so OK
      read(ch1,*) (ilm0(k),k=1,40)
      do 490 k=1,40
        if(ilm0(k).eq.idum) goto 490
        if(ilm0(k).eq.go) goto 480
        i=i+1
        do 440 j=1,mblo !is it a BLOC?
          if(bezb(j).eq.ilm0(k)) goto 470
  440   continue
        do 450 l=1,il   !is it a SINGLE ELEMENT?
          if(bez0(l).eq.ilm0(k)) goto 460
  450   continue
        ! It was neither BLOC or SINGLE ELEMENT! ERROR!
        erbez=ilm0(k)
        call prror(20)
        
        ! Handle SINGLE ELEMENT
  460   continue
        ic(i)=l+nblo
        if(bez0(l).eq.cavi) icy=icy+1
        goto 490

        !Handle BLOC
  470   ic(i)=j
        goto 490
        !Handle GO
  480   kanf=i+1
  490 continue
      mbloz=i
      if(mbloz.gt.nblz-2) call prror(21)
      goto 330
!-----------------------------------------------------------------------
!  INITIAL COORDINATES
!-----------------------------------------------------------------------
  500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then !iclr = line number in initial coordinate block
        iclr=iclr+1
      else
        goto 500
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & itra,chi0,chid,rat,iver
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) itra,chi0,chid,rat,iver
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itra
          nf=nf-1
        endif
        if (nf.gt.0) then
          chi0=fround(errno,fields,2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          chid=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          rat=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
            read (fields(5),*) iver
            nf=nf-1
        endif
+ei
+ei
        if(itra.gt.2) call prror(40)
      endif
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & exz(1,1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) exz(1,1)
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & exz(1,2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) exz(1,2)
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & exz(1,3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.4) read(ch1,*) exz(1,3)
+ei
+if crlibm
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.5) read(ch1,*,round='nearest')                         &
     & exz(1,4)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.5) read(ch1,*) exz(1,4)
+ei
+if crlibm
      if(iclr.eq.5) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.6) read(ch1,*,round='nearest')                         &
     & exz(1,5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.6) read(ch1,*) exz(1,5)
+ei
+if crlibm
      if(iclr.eq.6) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.7) read(ch1,*,round='nearest')                         &
     & exz(1,6)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.7) read(ch1,*) exz(1,6)
+ei
+if crlibm
      if(iclr.eq.7) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.8) read(ch1,*,round='nearest')                         &
     & exz(2,1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.8) read(ch1,*) exz(2,1)
+ei
+if crlibm
      if(iclr.eq.8) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.9) read(ch1,*,round='nearest')                         &
     & exz(2,2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.9) read(ch1,*) exz(2,2)
+ei
+if crlibm
      if(iclr.eq.9) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.10) read(ch1,*,round='nearest')                        &
     & exz(2,3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.10) read(ch1,*) exz(2,3)
+ei
+if crlibm
      if(iclr.eq.10) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.11) read(ch1,*,round='nearest')                        &
     & exz(2,4)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.11) read(ch1,*) exz(2,4)
+ei
+if crlibm
      if(iclr.eq.11) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.12) read(ch1,*,round='nearest')                        &
     & exz(2,5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.12) read(ch1,*) exz(2,5)
+ei
+if crlibm
      if(iclr.eq.12) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.13) read(ch1,*,round='nearest')                        &
     & exz(2,6)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.13) read(ch1,*) exz(2,6)
+ei
+if crlibm
      if(iclr.eq.13) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.14) read(ch1,*,round='nearest')                        &
     & e0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.14) read(ch1,*) e0
+ei
+if crlibm
      if(iclr.eq.14) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          e0=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.15) read(ch1,*,round='nearest')                        &
     & ej(1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.15) read(ch1,*) ej(1)
+ei
+if crlibm
      if(iclr.eq.15) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.16) read(ch1,*,round='nearest')                        &
     & ej(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.16) read(ch1,*) ej(2)
+ei
+if crlibm
      if(iclr.eq.16) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.16) goto 500
      dp1=exz(1,6)
      iclr=0
      if(iver.ne.0.and.iver.ne.1) iver=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  TRACKING PARAMETERS
!-----------------------------------------------------------------------
  510 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
        iclr=iclr+1
      else
        goto 510
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
! Two new options for Turns to checkpoint and max turns/job.
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     &numl,numlr,napx,amp(1),amp0,ird,imc,niu(1),niu(2),numlcp,numlmax
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) then
        read(ch1,*)                                                     &
     &numl,numlr,napx,amp(1),amp0,ird,imc,niu(1),niu(2),numlcp,numlmax
      endif
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) numl
        nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) numlr
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) napx
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp0=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(6),*) ird
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) imc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) niu(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) niu(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(10),*) numlcp
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(11),*) numlmax
          nf=nf-1
        endif
! and default nnmul to numl
        nnuml=numl
! and numlcp to 1000
        if(numlcp.eq.0) numlcp=1000
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & idz(1),idz(2),idfor,irew,iclo6
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      if(iclr.eq.2) read(ch1,*) idz(1),idz(2),idfor,irew,iclo6
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & nde(1),nde(2),                                                   &
     &nwr(1),nwr(2),nwr(3),nwr(4),ntwin,ibidu,iexact
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      if(iclr.eq.3) read(ch1,*) nde(1),nde(2),                          &
     &nwr(1),nwr(2),nwr(3),nwr(4),ntwin,ibidu,iexact
+ei
      if(iclo6.eq.5.or.iclo6.eq.6) then
        iclo6=iclo6-4
        iclo6r=1
      endif
      if(iclo6.eq.2.and.idfor.eq.0) idfor=1
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(iclr.ne.3) goto 510
      iclr=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  DIFFERENTIAL ALGEBRA
!-----------------------------------------------------------------------
  520 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 520
      ndum=ndum+1
      if(ch(:4).eq.next) then
        ndum=0
        goto 110
      endif
      if(ndum.eq.1) then
        ch1(:nchars+3)=ch(:nchars)//' / '
        idial=1
        numlr=0
        napx=1
        imc=1
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & nord,nvar,preda,nsix,ncor
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) nord,nvar,preda,nsix,ncor
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) nord
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(2),*) nvar
          nf=nf-1
        endif
        if (nf.gt.0) then
          preda=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(4),*) nsix
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(5),*) ncor
          nf=nf-1
        endif
+ei
+ei
        if(nvar.le.4) ition=0
        if(nord.le.0.or.nvar.le.0) call prror(91)
      else
        call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
        read(ch1,*) (ilm0(i),i=1,ncor)
      endif
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(nvar.ne.6) then
      nsix=0
      iclo6=0
      endif
      if(nvar.eq.5) then
        idp=1
        ition=1
        hsy(1)=zero
      endif
      if(ndum.eq.1) then
      if(nsix.ne.1) nsix=0
      if(nord.gt.nema) call prror(52)
      nvar2=nvar
      goto 520
      else
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
        do 540 j1=1,ncor
          do 530 j2=1,il
            if(ilm0(j1).eq.bez(j2)) then
              if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
              ipar(j1)=j2
              goto 540
            endif
  530     continue
          call prror(66)
  540   continue
      else
        ncor=0
        write(lout,*)' '
        write(lout,*)'NO EXTRA PARAMETERS FOR THE MAP SPECIFIED'
        write(lout,*)' '
      endif
      ndum=0
      nvar=nvar2+ncor
      goto 110
      endif
!-----------------------------------------------------------------------
!  PRINTOUT INPUT PARAMETERS
!-----------------------------------------------------------------------
  550 iout=1
      goto 110
!-----------------------------------------------------------------------
!  CHROMATCITY ADJUSTMENT
!-----------------------------------------------------------------------
  560 ichrom=1
      ichrom0=0
      do 580 l=1,2
  570 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 570
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.1) read(ch1,*,round='nearest')                            &
     & iss(1),cro(1),ichrom0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.1) read(ch1,*) iss(1),cro(1),ichrom0
+ei
+if crlibm
      if(l.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) iss(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(3),*) ichrom0
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iss(2),cro(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.2) read(ch1,*) iss(2),cro(2)
+ei
+if crlibm
      if (l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iss(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
  580 continue
      do 590 j=1,il
      if(iss(1).eq.bez(j)) is(1)=j
  590 if(iss(2).eq.bez(j)) is(2)=j
      if(ichrom0.ge.1.and.ichrom0.le.3) ichrom=ichrom0
      goto 110
!-----------------------------------------------------------------------
!  TUNE ADJUSTMENT
!-----------------------------------------------------------------------
  600 iqmod=1
      do 630 l=1,3
  610 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 610
      if(ch(:4).eq.next) then
        if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni) then
          do 620 j=1,il
            if(iqq(1).eq.bez(j)) iq(1)=j
  620     if(iqq(2).eq.bez(j)) iq(2)=j
          goto 110
        else
          write(lout,10370)
          iqmod=0
          iqmod6=0
          goto 110
        endif
      endif
      call intepr(1,1,ch,ch1)
      if(l.eq.1) then
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & iqq(1),qw0(1),iqmod6
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) iqq(1),qw0(1),iqmod6
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) iqmod6
          nf=nf-1
        endif
+ei
+ei
        if(iqmod6.eq.1) then
          iqmod6=0
        elseif(iqmod6.eq.2) then
          iqmod6=1
          iqmod=0
        elseif(iqmod6.eq.3) then
          iqmod6=1
        endif
      endif
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iqq(2),qw0(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.2) read(ch1,*) iqq(2),qw0(2)
+ei
+if crlibm
      if(l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.3) read(ch1,*,round='nearest')                            &
     & iqq(3),qw0(3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.3) read(ch1,*) iqq(3),qw0(3)
+ei
+if crlibm
      if(l.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(3)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(3)=fround(errno,fields,2)
        nf=nf-1
        endif
      endif
+ei
+ei
  630 continue
  640 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 640
      call intepr(4,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & iqq(4),iqq(5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) iqq(4),iqq(5)
+ei
      if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni                  &
     &.and.abs(qw0(3)).gt.pieni) then
        do 650 j=1,il
          if(iqq(1).eq.bez(j)) iq(1)=j
          if(iqq(2).eq.bez(j)) iq(2)=j
          if(iqq(3).eq.bez(j)) iq(3)=j
          if(iqq(4).eq.bez(j)) kpa(j)=1
          if(iqq(5).eq.bez(j)) kpa(j)=2
 650    continue
        goto 110
      else
        write(lout,10370)
        iqmod=0
        iqmod6=0
        write(lout,*) 'TUNE ADJUSTED'
        goto 110
      endif
!-----------------------------------------------------------------------
!  LINEAR OPTICS CALCULATION
!  - in the 4D case (ilin=1) the subroutine linopt is called
!  - in the 6d case (ilin=2) the optics parameters are calculated and 
!    printed in the subroutine umlauda (calculated in the common block
!    umlalid)
!-----------------------------------------------------------------------
 660  continue
      ilin0=1
      read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 660
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,nt,ilin0,ntco,eui,euii
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,nt,ilin0,ntco,eui,euii
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nt
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ilin0
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(4),*) ntco
        nf=nf-1
      endif
      if (nf.gt.0) then
        eui=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        euii=fround(errno,fields,6)
        nf=nf-1
      endif
+ei
+ei
      iprint=0
      if(idat.ne.'BLOCK'.and.idat.ne.'ELEMENT') call prror(45)
      if(idat.eq.'BLOCK') iprint=1
      ilin=1
      if(ilin0.ge.1.and.ilin0.le.3) ilin=ilin0
  670 do 680 m=1,40
  680 ilm0(m)=idum
  690 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 690
      if(ch(:4).eq.next) goto 110
      call intepr(2,1,ch,ch1)
! ilm0 are character strings, should be OK
      read(ch1,*) (ilm0(m),m=1,40)
      do 700 m=1,40
      if(ilm0(m).eq.idum) goto 700
      nlin=nlin+1
      if(nlin.gt.nele) call prror(81)
      bezl(nlin)=ilm0(m)
  700 continue
      goto 670
!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!-----------------------------------------------------------------------
  710 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 710
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & harm,alc,u0,phag,tlen,pma,ition,dppoff
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) read(ch1,*) harm,alc,u0,phag,tlen,pma,ition,dppoff
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          harm=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          alc=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          u0=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          phag=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          tlen=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          pma=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ition
          nf=nf-1
        endif
        if (nf.gt.0) then
          dppoff=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & dpscor,sigcor
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) dpscor,sigcor
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          dpscor=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          sigcor=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.2) goto 710
      iclr=0
      if(abs(pma-pmap).le.c1m1) pmat=pmap
      if(abs(pma-pmae).le.c1m1) pmat=pmae
      if(pmat.ne.pmap.and.pmat.ne.pmae) then
        write(lout,*)
        write(lout,*) 'Warning: Particle is neither proton nor electron'
        write(lout,*)
      endif
      if(pma.lt.pieni) call prror(27)
      crad=(crade*pmae)/pma                                              !hr05
      if(abs(tlen).le.pieni) call prror(25)
      if(ncy2.eq.0) then
        ncy=icy*mper
        idp=1
        if(ncy.ne.0) goto 720
        idp=0
        write(lout,10130)
        write(lout,10340)
  720   phas=phag*rad
        if(ncy.ne.0) then
          hsy(1)=u0/dble(ncy)
        else
          hsy(1)=u0
        endif
        if(nvar.eq.5) then
          idp=1
          ition=1
          hsy(1)=zero
        endif
        halc=harm*alc
        halc2=harm/tlen
        hsy(3)=(two*pi)*halc2                                            !hr05
+if crlibm
        cosy=cos_rn(phas)
+ei
+if .not.crlibm
        cosy=cos(phas)
+ei
        qigam=(pma**2/e0)/e0                                             !hr05
        qbet=one-qigam
        halc3=((((((-1d0*(qigam-alc))*dble(ition))*harm)*u0)/e0)*cosy)/ &!hr05
     &((two*pi)*qbet)                                                    !hr05
        if(halc3.lt.zero) call prror(28)
        qs=sqrt(halc3)
      else
        idp=1
        ncy=0
        do 725 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(abs(kz(ix)).eq.12) ncy=ncy+1
          endif
  725   continue
        do 730 j=1,il
          if(abs(kz(j)).eq.12) then
            hsyc(j)=((two*pi)*ek(j))/tlen                                !hr05
            if(nvar.eq.5) then
              ition=1
              ed(j)=zero
            endif
          endif
  730   continue
      endif
      goto 110
!-----------------------------------------------------------------------
!  MULTIPOLE COEFFICIENTS  FOR KZ = 11
!-----------------------------------------------------------------------
  740 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 740
      ! Get first data line: name, R_0, \delta_0
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & imn,r0,benki
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) imn,r0,benki
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) imn
        nf=nf-1
      endif
      if (nf.gt.0) then
        r0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        benki=fround(errno,fields,3)
        nf=nf-1
      endif
+ei
+ei
      ! Renaming variables?
      i=1
      r0a=one
      im=im+1
      benkc(im)=benki
      r00(im)=r0
      ! Find single element which matches the name, set its
      ! irm from the MULT block counter im.
      do 750 j=1,il
      if(imn.eq.bez(j)) then
        irm(j)=im
        goto 760
      endif
  750 continue
  760 write(lout,10130)
      write(lout,10210) imn,r0,benki
      ! Read data lines: B_n rms-B_n A_n rms-A_n
  770 bk0d=zero
      bkad=zero
      ak0d=zero
      akad=zero
  780 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 780
      if(ch(:4).eq.next) goto 110
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & bk0d,bkad,ak0d,akad
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) bk0d,bkad,ak0d,akad
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        bk0d=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bkad=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ak0d=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        akad=fround(errno,fields,4)
        nf=nf-1
      endif
+ei
+ei
      ! Set nmu for the current single element (j)
      ! to the currently highest multipole seen (i)
      if(abs(bk0d).gt.pieni.or.abs(bkad).gt.pieni                       &
     &.or.abs(ak0d).gt.pieni.or.abs(akad).gt.pieni) nmu(j)=i
      write(lout,10220) i,bk0d,bkad,ak0d,akad
      bk0(im,i)=(benki*bk0d)/r0a                                         !hr05
      ak0(im,i)=(benki*ak0d)/r0a                                         !hr05
      bka(im,i)=(benki*bkad)/r0a                                         !hr05
      aka(im,i)=(benki*akad)/r0a                                         !hr05
      i=i+1
      r0a=r0a*r0
      if(i.gt.mmul+1) call prror(105)
      if(ch(:4).ne.next) goto 770 ! loop
      write(lout,10380)
      write (lout,*) 'BENKI done'
      goto 770
!-----------------------------------------------------------------------
!  FLUCTUATION RANDOM STARTING NUMBER
!-----------------------------------------------------------------------
  790 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 790
      ! Read izu0, mmac, mout, mcut
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & izu0, mmac, mout, mcut
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) izu0, mmac, mout, mcut
+ei
      mcut=iabs(mcut)
+if vvector
      if(mmac.gt.nmac) call prror(55)
+ei
      !Generate normal distributed random numbers into zfz
      call recuin(izu0,irecuin)
      call ranecu(zfz,nzfz,mcut)
      rsum=zero
      do 800 i=1,nzfz
  800 rsum=rsum+zfz(i)
      rmean=rsum/dble(nzfz)                                              !hr05
      rsqsum=zero
      do 810 i=1,nzfz
  810 rsqsum=rsqsum+(zfz(i)-rmean)**2                                    !hr05
      rdev=sqrt(rsqsum/dble(nzfz))                                       !hr05
      write(lout,10410) izu0,nzfz,rmean,rdev
      if(mcut.eq.0) write(lout,10430)
      if(mcut.gt.0) write(lout,10440) mcut
      write(lout,10130)
      ! Set flags mout1, mout2, mount3, mout4 depending on mout
      ! Enables/disables different functionality
      if(mout.ge.8) mout4=1
      if(mout.eq.7.or.mout.eq.15) then
        mout1=1
        mout2=1
        mout3=1
      else if(mout.eq.6.or.mout.eq.14) then
        mout2=1
        mout3=1
      else if(mout.eq.5.or.mout.eq.13) then
        mout1=1
        mout3=1
      else if(mout.eq.4.or.mout.eq.12) then
        mout3=1
      else if(mout.eq.3.or.mout.eq.11) then
        mout1=1
        mout2=1
      else if(mout.eq.2.or.mout.eq.10) then
        mout2=1
      else if(mout.eq.1.or.mout.eq.9) then
        mout1=1
      endif
      
      ! Reads from fort.16 IF mout1==1
      if(mout1.eq.1) then
        write(lout,*)
        write(lout,*) '          Multipole errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0 ! Reading regular multipoles(1) or skew components (2)
        ifiend16=0
        iexnum=0
        read(16,10020,end=861)
        rewind 16

        do 860 i=1,mper*mbloz ! Loop over all structure elements
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend16.eq.0) then
                read(16,10020,end=820,iostat=ierro) ch
                lineno16=lineno16+1
              else
                goto 820
              endif
              call intepr(3,1,ch,ch1) ! Read the name of element
! ilm0 are character strings, should be OK
              read(ch1,*) ilm0(1)
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
+if fio
+if crlibm
      call enable_xp()
+ei
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)

              
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
+ei
+if crlibm
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 840
  820         ifiend16=1
              if(iexnum.eq.0) call prror(80)
              do 830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
  830         continue
  840         continue
            endif ! closing if(iexread.eq.0) then
            if(ilm0(1).eq.bez(ix)) then
+if debug
!             call warr('ilm0(1)',0d0,1,i,0,0)
+ei
              icext(i)=ix
              do 850 k=1,40
                exterr(i,k)=extaux(k)
+if debug
!     call warr('extaux',extaux(k),i,k,0,0)
+ei
  850         continue
              iexread=0
              goto 860
            endif
          endif
  860   continue
  861   continue
        write(lout,*) '        From file fort.16 :',iexnum,             &
     &' values read in.'
        write(lout,*)
      endif
+if time
      if(mout1.eq.1) then
        write(lout,*)
        write(lout,*) '  Time-d  Multipole errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0
        ifiend35=0
        iexnum=0
        read(35,10020,end=1861)
        rewind 35
        do 1860 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend35.eq.0) then
                read(35,10020,end=1820,iostat=ierro) ch
                lineno35=lineno35+1
              else
                goto 1820
              endif
              call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),tcnst
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(ch1,*) ilm0(1),tcnst
+ei
+if crlibm
              call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tcnst=fround(errno,fields,2)
                nf=nf-1
              endif
+ei
+ei
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(1),&
     &extaux(2),                                                        &
     &extaux(3)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(4),&
     &extaux(5),                                                        &
     &extaux(6)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(7),&
     &extaux(8),                                                        &
     &extaux(9)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(10)&
     &,extaux(11),                                                      &
     &extaux(12)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(13)&
     &,extaux(14),                                                      &
     &extaux(15)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(16)&
     &,extaux(17),                                                      &
     &extaux(18)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(19)&
     &,extaux(20)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(21)&
     &,extaux(22),                                                      &
     &extaux(23)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(24)&
     &,extaux(25),                                                      &
     &extaux(26)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(27)&
     &,extaux(28),                                                      &
     &extaux(29)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(30)&
     &,extaux(31),                                                      &
     &extaux(32)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(33)&
     &,extaux(34),                                                      &
     &extaux(35)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(36)&
     &,extaux(37),                                                      &
     &extaux(38)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(39)&
     &,extaux(40)
              lineno35=lineno35+1
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(35,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(19),extaux(20)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(39),extaux(40)
              lineno35=lineno35+1
+ei
+if crlibm
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(35,10020,end=870,iostat=ierro) ch
        lineno35=lineno35+1
        ch1(:nchars+3)=ch(:nchars)//' / '
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(35,10020,end=870,iostat=ierro) ch
      lineno35=lineno35+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
      if (nf.gt.0) then
          extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
          extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(35,10020,end=870,iostat=ierro) ch
        lineno35=lineno35+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(35,10020,end=870,iostat=ierro) ch
      lineno35=lineno35+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 1840
 1820        ifiend35=1
              if(iexnum.eq.0) call prror(80)
              do 1830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
 1830        continue
 1840        continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icext35(i)=ix
                tcnst35(i)=tcnst
               do 1850 k=1,40
                exterr35(i,k)=extaux(k)
1850        continue
              iexread=0
              goto 1860
            endif
          endif
 1860  continue
 1861  continue
        write(lout,*) '        From file fort.35 :',iexnum,             &
     &' values read in.'
        write(lout,*)
      endif
+ei
      if(mout3.eq.1) then
        write(lout,*)
        write(lout,*) '          Alignment errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0
        ifiend8=0
        iexnum=0
        read(8,10020,end=1581)
        rewind 8
        do 1580 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(8,10020,end=1550,iostat=ierro) ch
                if(ierro.gt.0) call prror(86)
                lineno8=lineno8+1
              else
                goto 1550
              endif
              call intepr(1,1,ch,ch1)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),alignx,alignz,tilt
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(ch1,*) ilm0(1),alignx,alignz,tilt
+ei
+if crlibm
              call splitfld(errno,8,lineno8,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignx=fround(errno,fields,2)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignz=fround(errno,fields,3)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tilt=fround(errno,fields,4)
                nf=nf-1
              endif
!             alignx=DBLE(SNGL(alignx))
!             alignz=DBLE(SNGL(alignz))
!             tilt=DBLE(SNGL(tilt))
!             call roundnulp(alignx,1024)
!             call roundnulp(alignz,1024)
!             call roundnulp(tilt,1024)
+ei
+ei
+if debug
!     call warr('ilm0(1)',0d0,1,0,0,0)
!     call warr('alignx',alignx,I,1,0,0)
!     call warr('alignz',alignz,I,2,0,0)
!     call warr('tilt',tilt,I,3,0,0)
+ei
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1570
 1550         ifiend8=1
              if(iexnum.eq.0) call prror(86)
              do 1560 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(86)
 1560         continue
 1570         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1580
            endif
          endif
 1580   continue
 1581   continue
        write(lout,*) '        From file fort.8 :',iexnum,              &
     &' values read in.'
        write(lout,*)
      endif
      izu=0
      iexnum=0
      if(mout4.eq.1) then
        read(30,10020,end=1591)
        rewind 30
        do 1590 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 1590
            if(kzz.eq.15) goto 1590
            izu=izu+3
            read(30,10020,end=1591,iostat=ierro) ch
            if(ierro.gt.0) call prror(87)
            lineno30=lineno30+1
            call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
            read(ch1,*,round='nearest')                                 &
     & ilm0(1),zfz(izu-2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
            read(ch1,*) ilm0(1),zfz(izu-2)
+ei
            iexnum=iexnum+1
            if(kz(ix).eq.11) izu=izu+2*mmul
          endif
 1590   continue
        if(iexnum.gt.0) then
          write(lout,*)
          write(lout,*)'          Single (random) kick errors read in ',&
     &'from external file'
          write(lout,*)
          write(lout,*) '        From file fort.30 :',iexnum,           &
     &' values read in.'
          write(lout,*)
        endif
        iexread=0
        ifiend8=0
        iexnum=0
        rewind 30
        do 1593 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
 1595         ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(30,10020,end=1594,iostat=ierro) ch
                if(ierro.gt.0) call prror(87)
                lineno30=lineno30+1
              else
                goto 1594
              endif
              call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),dummy,alignx,alignz,tilt
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
              read(ch1,*) ilm0(1),dummy,alignx,alignz,tilt
+ei
              if(((abs(alignx)+abs(alignz))+abs(tilt)).le.pieni)        &!hr05
     &goto 1595
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1596
 1594         ifiend8=1
              do 1597 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(87)
 1597         continue
 1596         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1593
            endif
          endif
 1593   continue
 1591   continue
      endif
      goto 110
  870 call prror(80)
!-----------------------------------------------------------------------
!  ORGANISATION OF RANDOM NUMBERS
!-----------------------------------------------------------------------
  880 write(lout,10130)
      write(lout,10350)
      do 890 i=1,3
      do 890 j=1,nele
  890 bezr(i,j)=idum !Initialize all bezr to idum=' '
      
  900 iorg=iorg+1
  910 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 910
      if(ch(:4).eq.next) goto 110
      call intepr(3,1,ch,ch1)
      ! bezr are character strings, should be OK
      read(ch1,*) idat,bezr(2,iorg),bezr(3,iorg)
      if(idat.ne.next) then !Isn't this already checked for above?
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).eq.idum)
     &        write(lout,10360) idat
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).ne.idum)
     &        write(lout,10390) idat,bezr(2,iorg)
         if(idat.ne.mult)
     &        bezr(1,iorg)=idat
         if(idat.eq.mult.and.
     &        bezr(2,iorg).ne.idum.and.bezr(3,iorg).ne.idum) then
            write(lout,10400) bezr(2,iorg),bezr(3,iorg)
            im=im+1
            j0=0
            j1=0
            do 920 i=1,il
               if(bez(i).eq.bezr(2,iorg)) j1=i
 920           if(bez(i).eq.bezr(3,iorg)) j0=i
            if(j0.eq.0.or.j1.eq.0.or.kz(j0).ne.11.or.kz(j1).ne.11)          &
     &              call prror(29)

            irm(j0)=im
            benkc(j0)=benkc(j1)
            r00(j0)=r00(j1)
            imo=irm(j1)
            nmu(j0)=nmu(j1)
            do 930 i1=1,nmu(j0)
               bk0(im,i1)=bk0(imo,i1)
               bka(im,i1)=bka(imo,i1)
               ak0(im,i1)=ak0(imo,i1)
 930           aka(im,i1)=aka(imo,i1)

         endif
         goto 900
      endif
      write(lout,10130)
      goto 110
!-----------------------------------------------------------------------
!  ITERATION ERRORS FOR CLOSED ORBIT ,TUNE ADJUSTMENT AND CHROMATICITY
!-----------------------------------------------------------------------
  940 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 940
      endif
      if(ch(:4).eq.next) then
      iclr=0
      goto 110
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.1) read(ch1,*,round='nearest')                         
     & itco,dma,dmap
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) read(ch1,*) itco,dma,dmap
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itco
        endif
        if (nf.gt.0) then
          dma=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dmap=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         
     & itqv,dkq,dqq
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) itqv,dkq,dqq
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itqv
          nf=nf-1
        endif
        if (nf.gt.0) then
          dkq=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dqq=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
      if(iclr.eq.3) read(ch1,*,round='nearest')                         
     & itcro,dsm0,dech
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) itcro,dsm0,dech
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itcro
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsm0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dech=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & de0,ded,dsi,aper(1),aper(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.4) read(ch1,*) de0,ded,dsi,aper(1),aper(2)
+ei
+if crlibm
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          de0=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          ded=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsi=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(2)=fround(errno,fields,5)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.4) goto 940
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  APERTURE LIMITATIONS
!-----------------------------------------------------------------------
  950 write(lout,10320)
  960 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 960
      apxx=zero
      apzz=zero
      call intepr(8,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,irel,apxx,apzz
+if crlibm
      call disable_xp()
+ei
+ei

+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,irel,apxx,apzz
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) irel
        nf=nf-1
      endif
      if (nf.gt.0) then
        apxx=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        apzz=fround(errno,fields,4)
          nf=nf-1
      endif
+ei
+ei
      do 970 j=1,il
      if(idat.ne.bez(j)) goto 970
      kp(j)=1
      if(irel.eq.rect) kp(j)=2
      apx(j)=apxx
      apz(j)=apzz
      if(irel.eq.rect) then
        kp(j)=3
        ape(1,j)=apzz**2                                                 !hr05
        ape(2,j)=apxx**2                                                 !hr05
        ape(3,j)=apxx**2*apzz**2                                         !hr05
      endif
      write(lout,10330) bez(j),irel,apxx,apzz
  970 continue
! Eric temporary fix for BUG??? Uncommnted for Riccardo 14/2/2015
      if(idat.ne.next) goto 960
      goto 110
!-----------------------------------------------------------------------
!  ORBIT CORRECTION
!-----------------------------------------------------------------------
  980 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 980
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & sigma0,ncorru,ncorrep
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) sigma0,ncorru,ncorrep
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        sigma0(1)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sigma0(2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) ncorru 
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ncorrep
        nf=nf-1
      endif
+ei
+ei
      iclo=1
  990 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 990
      iele=idum
      call intepr(4,1,ch,ch1)
! integers so should be OK
      read(ch1,*) idat,iele
      if(idat.eq.next) goto 110
      if(idat.ne.'HMON='.and.idat.ne.'HCOR='.and. idat.ne.'VMON='.and.  &
     &idat.ne.'VCOR=') call prror(44)
      if(idat.eq.'HMON='.or.idat.eq.'VMON=') goto 1010
      do 1000 j=1,il
      if(iele.ne.bez(j)) goto 1000
      if(idat.eq.'HCOR=') then
        if(kp(j).eq.-4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.1.and.kz(j).ne.11) call prror(82)
        kp(j)=4
      endif
      if(idat.eq.'VCOR=') then
        if(kp(j).eq.4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.-1.and.kz(j).ne.11) call prror(82)
        kp(j)=-4
      endif
 1000 continue
      goto 990
 1010 do 1020 j=1,il
      if(iele.ne.bez(j)) goto 1020
      if(idat.eq.'HMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.-3) call prror(83)
        kp(j)=3
      endif
      if(idat.eq.'VMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.3) call prror(83)
        kp(j)=-3
      endif
 1020 continue
      goto 990
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
 1030 ii=0
      do 1040 jj=1,ncom
      do 1040 ll=1,20
 1040 icel(jj,ll)=idum
      write(lout,10130)
      write(lout,10300)
 1050 ii=ii+1
      if(ii.gt.ncom) goto 1100
 1060 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1060
      if(ch(:4).eq.next) goto 110
      icoe=ii
      call intepr(5,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,(ratio(ii,l),icel(ii,l),l=1,20)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,(ratio(ii,l),icel(ii,l),l=1,20)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      do l=1,20
        if (nf.gt.0) then
          ratio(ii,l)=fround(errno,fields,l*2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(l*2+1),*) icel(ii,l)
          nf=nf-1
        endif
      enddo
+ei
+ei
      do 1080 j=1,il
      if(idat.ne.bez(j)) goto 1070
      kp(j)=5
      icomb0(ii)=j
      ratioe(j)=one
 1070 do 1080 l=1,20
        if(bez(j).eq.icel(ii,l)) then
          icomb(ii,l)=j
          ratioe(j)=ratio(ii,l)
        endif
 1080 continue
      jj=icomb0(ii)
      if(jj.eq.0) goto 1050
      do 1090 m=1,20
        ico=icomb(ii,m)
        if(ico.eq.jj) call prror(92)
        if(ico.eq.0) goto 1090
        write(lout,10310) bez(jj),bez(ico),ratio(ii,m)
        iratioe(ico)=jj
        if(el(jj).le.pieni) then
          if(el(ico).le.pieni) then
            ed(ico)=ed(jj)*ratio(ii,m)
          else
            ek(ico)=ed(jj)*ratio(ii,m)
          endif
        else
          if(el(ico).le.pieni) then
            ed(ico)=ek(jj)*ratio(ii,m)
          else
            ek(ico)=ek(jj)*ratio(ii,m)
          endif
        endif
 1090 continue
      goto 1050
 1100 write(lout,10290) ncom
      goto 110
!-----------------------------------------------------------------------
!  SUBRESONANCE CALCULATION
!-----------------------------------------------------------------------
 1110 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1110
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & nta,nte,qxt,qzt,tam1,tam2,ipt,totl
+if crlibm
      call enable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) nta,nte,qxt,qzt,tam1,tam2,ipt,totl
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nta
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nte
        qxt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(7),*) ipt
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,8)
        nf=nf-1
      endif
+ei
+ei
      if(nta.lt.2) call prror(37)
      if(nte.lt.nta.or.nte.gt.9) call prror(37)
      isub=1
      goto 110
!-----------------------------------------------------------------------
!  RESONANCE-COMPENSATION
!-----------------------------------------------------------------------
 1120 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1120
      ch1(:nchars+3)=ch(:nchars)//' / '
! all integers so should be OK
      read(ch1,*) nre
      if(nre.ne.0) read(ch1,*) nre,npp,nrr(1),nrr(2),nrr(3),            &
     &ipr(1),ipr(2),ipr(3)
      if(nre.ne.0.and.(npp.lt.2.or.npp.gt.nrco)) call prror(46)
      if(nre.lt.0.or.nre.gt.3) call prror(47)
      if(abs(nrr(1)).gt.npp.or.abs(nrr(2)).gt.npp                       &
     &.or.abs(nrr(3)).gt.npp) call prror(48)
 1130 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1130
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nur
      if(nur.ne.0) read(ch1,*) nur,nu(1),nu(2),nu(3)
      if(nur.lt.0.or.nur.gt.3) call prror(49)
      if(nu(1).gt.9.or.nu(2).gt.9.or.nu(3).gt.9                         &
     &.or.nu(1).lt.0.or.nu(2).lt.0.or.nu(3).lt.0) call prror(50)
 1140 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1140
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & totl,qxt,qzt,tam1,tam2
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) totl,qxt,qzt,tam1,tam2
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        totl=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qxt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
 1150 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1150
      call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
      read(ch1,*) (ilm0(i),i=1,6)
 1160 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1160
      call intepr(6,1,ch,ch1)
      read(ch1,*) nch
      if(nch.ne.0) read(ch1,*) nch,ilm0(7),ilm0(8)
 1170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1170
      call intepr(7,1,ch,ch1)
      read(ch1,*) nqc
+if fio
+if crlibm
      call enable_xp()
+ei
      if(nqc.ne.0) read(ch1,*,round='nearest')                          &
     & nqc,ilm0(9),ilm0(10),qw0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(nqc.ne.0) read(ch1,*) nqc,ilm0(9),ilm0(10),qw0
+ei
+if crlibm
      if(nqc.ne.0) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) nqc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) ilm0(9)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ilm0(10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,4)
          nf=nf-1
        endif
      endif
+ei
+ei
      do 1190 k=1,10
      do 1180 j=1,il
        if(ilm0(k).ne.bez(j)) goto 1180
        ire(k)=j
        if(nre.eq.1.and.k.lt.3.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.2.and.k.lt.5.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.3.and.k.lt.7.and.abs(kz(j)).ne.npp) call prror(39)
        if(nch.eq.1.and.(k.eq.7.or.k.eq.8).and.kz(j).ne.3) call prror   &
     &(11)
        if(nqc.eq.1.and.(k.eq.9.or.k.eq.10).and.kz(j).ne.2) call prror  &
     &(8)
        goto 1190
 1180 continue
      if((nre.eq.1.and.k.lt.3).or.(nre.eq.2.and.k.lt.5).or.             &
     &(nre.eq.3.and.k.lt.7).or.(nch.eq.1.and.(k.eq.7.or.k.eq.8)).or.    &
     &(nqc.eq.1.and.(k.eq.9.or.k.eq.10))) call prror(3)
 1190 continue
      irmod2=1
      goto 110
!-----------------------------------------------------------------------
!  SEARCH FOR OPTIMUM PLACES TO COMPENSATE RESONANCES
!-----------------------------------------------------------------------
 1200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1200
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & qxt,qzt,tam1,tam2,totl
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) qxt,qzt,tam1,tam2,totl
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        qxt=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
          tam2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
 1210 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1210
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & mesa,mp,m21,m22,m23,ise1,ise2,ise3
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) mesa,mp,m21,m22,m23,ise1,ise2,ise3
+ei
      if(mp.lt.2.or.mp.gt.9) call prror(37)
      if(abs(m21).gt.mp.or.abs(m22).gt.mp                               &
     &.or.abs(m23).gt.mp) call prror(48)
      ise=1
      k0=0
 1220 do 1230 m=1,40
 1230 ilm0(m)=idum
 1240 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1240
      call intepr(3,1,ch,ch1)
! character strings so should be OK
      read(ch1,*) idat,(ilm0(m),m=2,40)
      if(idat.eq.next) goto 110
      ilm0(1)=idat
      ka=k0+1
      ke=k0+40
      do 1260 k=ka,ke
      if(k.gt.nele) call prror(2)
      if(k.gt.mesa) goto 110
      ki=k-k0
      if(ilm0(ki).eq.idum) goto 1270
      do 1250 j=1,il
        if(ilm0(ki).ne.bez(j)) goto 1250
        isea(k)=j
        if(abs(kz(j)).ne.mp) call prror(39)
        goto 1260
 1250 continue
      call prror(3)
 1260 continue
 1270 k0=k-1
      goto 1220
!-----------------------------------------------------------------------
!  POSTPROCESSING
!-----------------------------------------------------------------------
 1280 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 1280
      endif
      ch1(:83)=ch(:80)//' / '

      !Line 1
      if(iclr.eq.1) toptit(1)=ch
      
      
      !Line 2
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & iav,nstart,nstop,iwg,dphix,dphiz,                                &
     &iskip,iconv,imad,cma1,cma2
+if crlibm
      call disable_xp()
+ei
+ei ! END +if fio
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) iav,nstart,nstop,iwg,dphix,dphiz,       &
     &iskip,iconv,imad,cma1,cma2
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iav
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) nstart
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) nstop
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) iwg
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphix=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphiz=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) iconv
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) imad
        nf=nf-1
        endif
        if (nf.gt.0) then
          cma1=fround(errno,fields,10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cma2=fround(errno,fields,11)
          nf=nf-1
        endif
      endif
+ei
+ei ! END +if .not.fio

      !Line 3
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
+if crlibm
      call disable_xp()
+ei
+ei ! END +if fio
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          qx0=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qz0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ivox
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) ivoz
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(5),*) ires
          nf=nf-1
        endif
        if (nf.gt.0) then
          dres=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ifh
          nf=nf-1
        endif
        if (nf.gt.0) then
          dfft=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
+ei
+ei ! END +if .not.fio

      !Line 4
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & kwtype,itf,icr,idis,icow,istw,iffw,                              &
     &nprint,ndafi
+if crlibm
      call disable_xp()
+ei
+ei !END +if fio
+if .not.fio
      if(iclr.eq.4) read(ch1,*) kwtype,itf,icr,idis,icow,istw,iffw,     &
     &nprint,ndafi
+ei !END +if .not.fio

+if stf
      if (imad.eq.1) then
         write(lout,*) "ERROR in daten::POST:"
         write(lout,*) "imad not supported for STF version."
         call prror(-1)
      endif
+ei !END +if stf
      
      kwtype=0
      icr=0
      if(iskip.le.0) iskip=1
      if(iclr.ne.4) goto 1280
      if(nprint.ne.1) nprint=0
      iclr=0
      if(nstart.lt.0) nstart=0
      if(nstop.lt.0) nstop=0
      if(nstop.lt.nstart) then
         nstart=0
         nstop=0
      endif
      if(iconv.ne.1) iconv=0
      if(abs(cma1).le.pieni) cma1=one
      cma1=cma1*c1e3
      if(abs(cma2).le.pieni) cma2=one
      ipos=1
      goto 110
!-----------------------------------------------------------------------
!  POWER SUPPLY RIPPLE
!-----------------------------------------------------------------------
 1290 continue
      write(lout,*)
      write(lout,*) "ERROR: old RIPP module is no longer supported"
      write(lout,*) "Please convert your RIPP block (in fort.3) to DYNK"
      write(lout,*) "The script rippconvert.py (in the pytools folder)"
      write(lout,*) " can be used to automatically convert the fort.3!"
      write(lout,*)
      call prror(-1)

!Code for just skipping over the RIPP block, which runs the simulation without RIPP:
 1300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      write(lout,*) 'ignoring line:'
      write(lout,*) ch
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1300
      if(ch(:4).eq.next) goto 110
      goto 1300
!-----------------------------------------------------------------------
!  DECOUPLING ROUTINE
!-----------------------------------------------------------------------
 1320 iskew=1
 1330 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1330
      call intepr(3,1,ch,ch1)
! character strings again
      read(ch1,*) idat,(ilm0(m),m=2,4)
      if(idat.eq.next) then
      iskew=0
      goto 110
      endif
      ilm0(1)=idat
      do 1350 i=1,2
 1340 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1340
      if(ch(:4).eq.next) then
        iskew=2
        goto 1360
      endif
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & ilm0(4+i),qwsk(i)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) ilm0(4+i),qwsk(i)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) ilm0(4+i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qwsk(i)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
 1350 continue
 1360 continue
      do 1380 i=1,6
      do 1380 j=1,il
        if(iskew.eq.2.and.i.gt.4) goto 1380
        if(ilm0(i).eq.bez(j)) then
          if(i.le.4) then
            if(kz(j).ne.-2) call prror(62)
          else
            if(kz(j).ne.2) call prror(8)
          endif
          nskew(i)=j
          do 1370 i2=1,6
            if(nskew(i2).ne.0.and.(nskew(i2).eq.nskew(i)) .and.(i2.ne.i)&
     &) call prror(63)
 1370     continue
        endif
 1380 continue
      goto 110
!GRD-----------------------------------------------------------------------
!  COLLIMATION INPUT BLOCK
!GRD-----------------------------------------------------------------------
 1285 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1

+if collimat
      has_coll = .true. !We have a collimation block.
+ei

      if(ch(1:1).ne.'/') then
         iclr=iclr+1
      else
         goto 1285
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      
+if .not.collimat
      if (iclr.eq.1) then
         read(ch1,*) do_coll
         if (do_coll) then
           write(lout,*)
           write(lout,*) "ERR> Collimation not forseen in this version;"
           write(lout,*) "ERR> Please use proper version"
           write(lout,*) "ERR> or set do_coll to .FALSE."
           write(lout,*)
           call prror(-1)
         endif
      endif
+ei ! END +if .not.collimat

+if collimat
!APRIL2005
+if fio
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & do_coll !Does not make sense with round=nearest: do_coll is a logical...
+ei
+if .not.fio
      if(iclr.eq.1) read(ch1,*) do_coll
+ei

      if(do_coll .and. numl.ge.10000) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "Collimation supports a maximum of 10000 turns;"
         write(lout,*) " trying to use more than this "//
     &        "corrupts the output files."
         write(lout,*) "Sorry!"
         write(lout,*) ""
         
         call prror(-1)
      endif
      

      
+if fio
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & nloop,myenom
+ei
+if .not.fio
      if(iclr.eq.2) read(ch1,*) nloop,myenom
+ei
      !Does not work for bnlelens, but collimat+bnlelens doesn't work anyway...
      !Note: After daten, napx = napx*2; in daten napx is the number of particle pairs.
      if(iclr.eq.2 .and. nloop*napx*2.gt.maxn) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "nloop =", nloop
         write(lout,*) "napx  =", napx,"(-> napx*2=",napx*2,"particles)"
         write(lout,*) "maxn  =", maxn
         write(lout,*) "mynp  = nloop*napx*2 =",nloop*napx*2,"> maxn"
         write(lout,*) "Please reduce the number of particles or loops"
         write(lout,*) ""
         
         call prror(-1)
      endif
      
+if fio
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & do_thisdis,mynex,mdex,myney,mdey,       &
+ei
+if .not.fio
      if(iclr.eq.3) read(ch1,*) do_thisdis,mynex,mdex,myney,mdey,       &
+ei
     &filename_dis,enerror,bunchlength
!JUNE2005
!UPGRADE JANUARY 2005
+if fio
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        &
     & NSIG_PRIM,NSIG_SEC
+ei
+if .not.fio
!      if(iclr.eq.4) read(ch1,*) NSIG_PRIM,NSIG_SEC
+ei
+if fio
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        
     & nsig_prim,nsig_sec,nsig_ter
+ei
+if .not.fio
!      if(iclr.eq.4) read(ch1,*) nsig_prim,nsig_sec,nsig_ter
+ei
+if fio
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & do_nsig,                                &
+ei
+if .not.fio
      if(iclr.eq.4) read(ch1,*) do_nsig,                                &
+ei
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,             &
     &nsig_tcli,                                                        &
!     &nsig_tcth,nsig_tctv,                                              &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi
+if fio
      if(iclr.eq.5) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.5) read(ch1,*)                                         &
+ei
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcxrp,nsig_tcryo
+if fio
      if(iclr.eq.6) read(ch1,*,round='nearest')                         &
     & n_slices,smin_slices,smax_slices,                                &
+ei
+if .not.fio
      if(iclr.eq.6) read(ch1,*) n_slices,smin_slices,smax_slices,       &
+ei
     &recenter1,recenter2
+if fio
      if(iclr.eq.7) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.7) read(ch1,*)                                         &
+ei
     & fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1
+if fio
      if(iclr.eq.8) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.8) read(ch1,*)                                         &
+ei
     & fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2
!
+if fio
      if(iclr.eq.9) read(ch1,*,round='nearest')                         &
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
+ei
+if .not.fio
      if(iclr.eq.9) read(ch1,*)
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
+ei
+if fio
      if(iclr.eq.10) read(ch1,*,round='nearest')                        &
     & do_select,do_nominal,                  &
+ei
+if .not.fio
      if(iclr.eq.10) read(ch1,*) do_select,do_nominal,                  &
+ei
     &rnd_seed,dowrite_dist,name_sel,do_oneside,                        &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude
+if fio
      if(iclr.eq.11) read(ch1,*,round='nearest')                        &
     & xbeat,xbeatphase,ybeat,                                          &
+ei
+if .not.fio
      if(iclr.eq.11) read(ch1,*) xbeat,xbeatphase,ybeat,                &
+ei
     &ybeatphase
!AUGUST2006 ADDED offset variables for mechanical errors    ---- TW
!JANUAR2007 added rms error for gap and switch to min gap   ---- TW
+if fio
      if(iclr.eq.12) read(ch1,*,round='nearest')                        &
     & c_rmstilt_prim,c_rmstilt_sec,                                    &
+ei
+if .not.fio
      if(iclr.eq.12) read(ch1,*) c_rmstilt_prim,c_rmstilt_sec,          &
+ei
     &c_systilt_prim,c_systilt_sec,c_rmsoffset_prim,c_rmsoffset_sec,    &
     &c_sysoffset_prim,c_sysoffset_sec,c_offsettilt_seed,               &
     &c_rmserror_gap,do_mingap
+if fio
      if(iclr.eq.13) read(ch1,*,round='nearest')                        &
     & radial,nr,ndr
+ei
+if .not.fio
      if(iclr.eq.13) read(ch1,*) radial,nr,ndr
+ei
+if fio
      if(iclr.eq.14) read(ch1,*,round='nearest')                        &
     & driftsx,driftsy,cut_input,                                       &
+ei
+if .not.fio
      if(iclr.eq.14) read(ch1,*) driftsx,driftsy,cut_input,             &
+ei
     &systilt_antisymm
!AUGUST2006 ADDED rmsx, rmsy and distr. type for pencil beam ---- TW
+if fio
      if(iclr.eq.15) read(ch1,*,round='nearest')                        &
     &                                                                  &
+ei
+if .not.fio
      if(iclr.eq.15) read(ch1,*)                                        &
+ei
     &ipencil,pencil_offset,pencil_rmsx,pencil_rmsy,pencil_distr
!APRIL2005
+if fio
      if(iclr.eq.16) read(ch1,*,round='nearest')                        &
     & coll_db,ibeam
+ei
+if .not.fio
      if(iclr.eq.16) read(ch1,*) coll_db,ibeam
+ei
!APRIL2005
+if fio
      if(iclr.eq.17) read(ch1,*,round='nearest')                        &
     & dowritetracks, cern, castordir,                                  &
+ei
+if .not.fio
      if(iclr.eq.17) read(ch1,*) dowritetracks, cern, castordir,        &
+ei
     &jobnumber, sigsecut2, sigsecut3
!
+ei ! END +if collimat

!     Use this code for both collimat and non-collimat
      if(iclr.ne.17) goto 1285
 1287 continue
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  COMMENT LINE
!-----------------------------------------------------------------------
 1390 read(3,10020,end=1530,iostat=ierro) commen
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(commen(1:1).eq.'/') goto 1390
      if(commen(:4).eq.next) then
      commen=' '
      endif
      goto 110
!-----------------------------------------------------------------------
!  NORMAL FORMS
!-----------------------------------------------------------------------
 1400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1400
      if(ch(:4).eq.next) then
      goto 110
      else
      if(idial.eq.0.and.numl.ne.0) then
        write(lout,10130)
        write(lout,*)
        call prror(78)
      endif
      inorm=1
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
      read(ch1,*,round='nearest')                                       &
     & nordf,nvarf,nord1,idptr
+ei
+if .not.fio
      read(ch1,*) nordf,nvarf,nord1,idptr
+ei
      if(nord.ne.0.and.nordf.gt.nord+1) imod1=1
      if(nvar.ne.0.and.nvarf.gt.nvar) then
        nvarf=nvar
        imod2=1
      endif
      if(idptr.lt.0.or.idptr.gt.6) idptr=0
      endif
!-----------------------------------------------------------------------
!  TUNESHIFT CORRECTIONS
!-----------------------------------------------------------------------
 1410 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1410
      if(ch(:4).eq.next) goto 110
      icorr=1
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
      read(ch1,*,round='nearest')                                       &
     & nctype,ncor
+ei
+if .not.fio
      read(ch1,*) nctype,ncor
+ei
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
      read(3,10020,end=1530,iostat=ierro) ch
      lineno3=lineno3+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call intepr(3,1,ch,ch1)
! coel are character strings so should be OK
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & (coel(i),i=1,ncor)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) (coel(i),i=1,ncor)
+ei
      do 1430 j1=1,ncor
        do 1420 j2=1,il
          if(coel(j1).eq.bez(j2)) then
            if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
            ipar(j1)=j2
            goto 1430
          endif
 1420   continue
        call prror(66)
 1430 continue
      else
      call prror(70)
      endif
      if(nctype.eq.0) then
      read(3,*) namp,nmom,dummy,dummy,dummy
      lineno3=lineno3+1
      if(namp+nmom.eq.0) call prror(71)
      if(namp*nmom.ne.0) call prror(72)
      if(namp.lt.0.or.namp.gt.2) call prror(73)
      if(nmom.lt.0.or.nmom.eq.1.or.nmom.gt.3) call prror(74)
      if(namp.eq.1.or.nmom.eq.2) then
        nord=6
      else
        nord=7
      endif
      else
+if fio
+if crlibm
      call enable_xp()
+ei
      read(3,*, round='nearest') nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(3,*) nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
+ei
+if crlibm
      read(3,*) ch1
      lineno3=lineno3+1
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nmom1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nmom2
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        dpmax=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
      if(nmom1.lt.2.or.nmom1.gt.3) call prror(75)
      if(nmom1.gt.nmom2) call prror(76)
      if(nmom2.lt.2.or.nmom2.gt.3) call prror(77)
      nord=2*(nmom2+1)
      endif
!-----------------------------------------------------------------------
      idial=1
      numlr=0
      napx=1
      imc=1
      preda=1.d-38
      nsix=1
      nvar=5
      nvar2=nvar
      nvar=nvar2+ncor
!-----------------------------------------------------------------------
      inorm=1
      nordf=nord+1
      nvarf=nvar
!-----------------------------------------------------------------------
      goto 1410
!-----------------------------------------------------------------------
!  Beam-Beam Element
!-----------------------------------------------------------------------
      ! ! ! Read 1st line of BEAM block ! ! !
 1600 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1600
      if(ch(:4).eq.next) goto 110

      if (nbeam.ge.1) then
         write(lout,*)
     &        "ERROR: There can only be one BEAM block in fort.3"
         call prror(-1)
      endif
      
      if (ch(:6) .eq."EXPERT") then
         beam_expflag = 1
         
 1601    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1601
         if(ch(:4).eq.next) goto 110
         ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                       &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*)
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')
     &           "First line should have 9 fields, got", nf
            call prror(-1)
         endif
         
         partnum = fround(errno,fields,1)
         emitnx  = fround(errno,fields,2)
         emitny  = fround(errno,fields,3)
         sigz    = fround(errno,fields,4)
         sige    = fround(errno,fields,5)
         read(fields(6),*) ibeco
         read(fields(7),*) ibtyp
         read(fields(8),*) lhc
         read(fields(9),*) ibbc
+ei
+ei
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
!GRD-2007
+if bnlelens
!GRDRHIC
!GRD-042008
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2).and.(lhc.ne.9))
     &      lhc=1
!GRDRHIC
!GRD-042008
+ei
+if .not.bnlelens
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
+ei
!GRD-2007
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset !Initialize complex error function for FAST BB kick

         ! ! ! Read other lines of BEAM block ! ! !
 1660    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1660
         if(ch(:4).eq.next) goto 110

+if fio
!+if crlibm
!         call enable_xp()
!+ei
!         read(ch1,*,round='nearest')                                       &
!     &      idat,i,xang,xplane,separx,separy,
!     &      mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8, &
!     &      mm9,mm10,mm11
!+if crlibm
!         call disable_xp()
!+ei
        write(lout,*)
     &       'ERROR in BEAM block (EXPERT mode): '//
     &       'fortran IO currently not supported.'
        call prror(-1)
+ei
+if .not.fio
+if .not.crlibm
         call intepr(1,1,ch,ch1)
         read(ch1,*) idat,i

         if (i.gt.0) then !6D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            read(ch,*) mm1,mm2,mm3,mm4,mm5
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            read(ch,*) mm6,mm7,mm8,mm9,mm10,mm11
            
         else if (i.eq.0) then  !4D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
         else
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')
     &           "Expected number of slices >= 0; but got",
     &           i, " in element ",idat
            call prror(-1)
         endif
+ei
+if crlibm  !The CRLIBM version has much more robust error checking...
         call intepr(1,1,ch,ch1)
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (.not.(nf.eq.6 .or. nf.eq.7)) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')
     &           "First line of an element definition should "//
     &           "have 6 or 7 fields, got", nf
            call prror(-1)
         endif
         
         read(fields(2),*) i !read number of slices
         
         if (i.gt.0) then  !6D
            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')
     &              "First line of a 6D element definition should "//
     &              "have 6 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat !Name
            read(fields(2),*) i    !slices (ibsix)
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            ch1(:nchars+3)=ch(:nchars)//' / '
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.5) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')
     &              "Second line of a 6D element definition should "//
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm1=fround(errno,fields,1)
            mm2=fround(errno,fields,2)
            mm3=fround(errno,fields,3)
            mm4=fround(errno,fields,4)
            mm5=fround(errno,fields,5)
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            ch1(:nchars+3)=ch(:nchars)//' / '
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')
     &              "Third line of a 6D element definition should "//
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm6=fround(errno,fields,1)
            mm7=fround(errno,fields,2)
            mm8=fround(errno,fields,3)
            mm9=fround(errno,fields,4)
            mm10=fround(errno,fields,5)
            mm11=fround(errno,fields,6)
            
         else if(i.eq.0) then ! 4D
            if (nf.ne.7) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')
     &              "First line of a 6D element definition should "//
     &              "have 7 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            mm1=fround(errno,fields,7)
         else
            read(fields(1),*) idat
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')
     &           "Expected number of slices >= 0; but got",
     &           i, " in element ",idat
            call prror(-1)
         endif
+ei
+ei
         
         do j=1,il !loop over single lements
            if(idat.eq.bez(j)) then
               if(kz(j).ne.20) then
                  write(lout,'(a)') "ERROR when reading BEAM block:"
                  write(lout,'(a,a16,a,i5,a)')
     &                 "Found element named ",bez(j),
     &                 " but type is",kz(j), ", expected type 20!"
                  call prror(-1)
               else
                  
                  if(parbe(j,5).ne.0d0 .or. parbe(j,6).ne.0d0
     &                 .or. ptnfac(j).ne.0d0
     &                 .or. bbbx(j).ne.0d0 .or. bbby(j).ne.0d0
     &                 .or. bbbs(j).ne.0d0 ) then
                     !Note: Data moved from ed/ek/el to parbe/ptnfac in initialize_element
                     write(lout,'(a)') "ERROR when reading BEAM block:"
                     write(lout,'(a,a16,a)')
     &                    "Using EXPERT mode, but element ", bez(j),
     &                    " does not have ed=ek=el=bbbx=bbby=bbbs=0.0"//
     &                    " in the SINGLE ELEMENTS list."
                     call prror(-1)
                  endif
                  if (i.gt.0) then ! 6D, allow 1 or more slices
                     parbe(j,17)=1      ! Is 6D
                     parbe(j,2)=dble(i) ! Number of slices
                     parbe(j,1)=xang
                     parbe(j,3)=xplane
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     parbe(j,7)=mm1
                     parbe(j,8)=mm2
                     parbe(j,9)=mm3
                     parbe(j,10)=mm4
                     parbe(j,11)=mm5
                     parbe(j,12)=mm6
                     parbe(j,13)=mm7
                     parbe(j,14)=mm8
                     parbe(j,15)=mm9
                     parbe(j,16)=mm10
                     ptnfac(j)=mm11
                     goto 1660
                  else if(i.eq.0) then ! 4D, single slice only
                     parbe(j,17)=0      ! Type is 4D
                     parbe(j,2)=dble(i) ! Number of slices is always 0
                     parbe(j,1)=xang    ! not the crossing angle but sigmaxx
                     parbe(j,3)=xplane  ! not the xplane but sigmayy
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     ptnfac(j)=mm1
                     goto 1660
                  endif
               endif
            endif
         end do
         goto 1660
         
      else ! Old-style BEAM block
         write (lout,'(a)') "READING OLD-STYLE BEAM BLOCK"
         write (lout,'(a)') " Look for 'NEW BEAM BLOCK' later"//
     &        " in the output for conversion"//
     &        " to the new 'EXPERT' format."
         write (lout,'(a)') " To convert to the new format,"//
     &        " copy-paste these lines (removing the *** lines"//
     &        " above and below each data line) into the BEAM"//
     &        " block in fort.3, replacing line 2 onwards."
         write (lout,'(a)') " Then write EXPERT on the first line"//
     &        " of the BEAM block, above the current first line."
         write(lout,'(a)') " Finally, in the SINGLE ELEMENTS list"//
     &        " (normally in fort.2) set the parameters of all"//
     &        " beam-beam lenses (type 20) to 0.0."
         write(lout,'(a)') " "
         write(lout,'(a)') " This procedure produces a new"//
     &        " set of input files that should have bit-for-bit"//
     &        " identical results to this one."
         write(lout,'(a)') " The easiest way to check this is"//
     &        " to run both simulations side-by-side and compare"//
     &        " the standard output in a text diff tool like meld."
         write(lout,'(a)') " If the results are not identical,"//
     &        " this is a bug; please report it to the developers!"
+if .not.crlibm
         write(lout,'(a)') " "
         write(lout,'(a)') "NOTE: THIS SIXTRACK BINARY WAS"//
     &        " NOT COMPILED WITH CRLIBM, CONVERSION WILL NOT BE EXACT."
+ei
         write(lout,'(a)') " "
         
         ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                       &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*)
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)')
     &           "WARNING in DATEN reading BEAM (not EXPERT)"
            write(lout,'(a,i4)') "First line should have 9 fields,"//
     &           " got ", nf
            !Treating this as a warning, or else we would invalidate
            !lots of working inpuit files
            !call prror(-1)
         endif
         
         if (nf.gt.0) then
            partnum=fround(errno,fields,1)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitnx=fround(errno,fields,2)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitny=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sigz=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sige=fround(errno,fields,5)
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(6),*) ibeco
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(7),*) ibtyp
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(8),*) lhc
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(9),*) ibbc
            nf=nf-1
         endif
+ei
+ei
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
!GRD-2007
+if bnlelens
!GRDRHIC
!GRD-042008
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2).and.(lhc.ne.9))
     &      lhc=1
!GRDRHIC
!GRD-042008
+ei
+if .not.bnlelens
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
+ei
!GRD-2007
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset
         
         ! ! ! Read other lines of BEAM block ! ! !
 1610    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1610
         if(ch(:4).eq.next) goto 110  ! Done yet?

         !Check number of arguments gotten
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(-1)
         beam_xstr = .false.
         if (getfields_nfields .eq. 5) then
            beam_xstr=.true.
         elseif (getfields_nfields .eq. 4) then
            beam_xstr=.false.
         else
            write(lout,*) "ERROR in parsing BEAM block"
            write(lout,*) "Number of arguments in data line 2,..."
            write(lout,*) " is expected to be 4 or 5"
            call prror(-1)
         end if
         call intepr(1,1,ch,ch1)
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                       &
     &      idat,i,xang,xplane,xstr
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*) idat,i,xang,xplane,xstr
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.gt.0) then
            read(fields(1),*) idat
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(2),*) i
            nf=nf-1
         endif
         if (nf.gt.0) then
            xang=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xplane=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xstr=fround(errno,fields,5)
            nf=nf-1
         endif
+ei
+ei
         if ( .not. beam_xstr ) then
            write(lout,*) "WARNING in parsing BEAM block"
            write(lout,*) "No xstr present, assuming xstr=xang"
            xstr = xang
         endif
      
         if(i.lt.0) i=0
         do 1620 j=1,il
            if(idat.eq.bez(j).and.kz(j).eq.20) then
               ibb6d=1
               parbe(j,2)=dble(i) !hr12
               parbe(j,1)=xang
               parbe(j,3)=xplane
               parbe(j,18)=xstr
               goto 1610
            endif
 1620    continue
         goto 1610
      endif
!-----------------------------------------------------------------------
!  TROMBONE ELEMENT KZ=22
!-----------------------------------------------------------------------
 1700 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1700
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
+if fio
      read(ch1,*,round='nearest')                                       &
     & imn
+ei
+if .not.fio
      read(ch1,*) imn
+ei
      imtr0=imtr0+1
      if(imtr0.gt.ntr) call prror(100)
      do 1710 j=1,il
        if(imn.eq.bez(j)) then
          imtr(j)=imtr0
          goto 1720
        endif
 1710 continue
      call prror(98)
 1720 j1=0
      if(imtr0.eq.1) write(lout,10130)
      if(imtr0.eq.1) write(lout,10700)
      write(lout,10710) imtr0,imn
 1730 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1730
      if(ch(:4).eq.next) call prror(99)
      ch1(:nchars+3)=ch(:nchars)//' / '
      j1=j1+3
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cotr(imtr0,j1-2)=fround(errno,fields,1) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1-1)=fround(errno,fields,2) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1)=fround(errno,fields,3) 
        nf=nf-1
      endif
+ei
+ei
      if(j1.lt.6) goto 1730
      do j=1,6
        j1=0
 1740   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 1740
        if(ch(:4).eq.next) call prror(99)
        ch1(:nchars+3)=ch(:nchars)//' / '
        j1=j1+3
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),                           &
     &rrtr(imtr0,j,j1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),              &
     &rrtr(imtr0,j,j1)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-1)=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1)=fround(errno,fields,3)
        nf=nf-1
      endif
+ei
+ei
        if(j1.lt.6) goto 1740
      enddo
      goto 1700
!-----------------------------------------------------------------------
!  DUMP BEAM POPULATION
!  A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!  K.Sjobak, BE-ABP/HSS
!  last modified: 03-09-2015
!  always in main code
!-----------------------------------------------------------------------
 2000 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2000 !Skip comment line

      !Done with DUMP, write out!
      if(ch(:4).eq.next) then
        ! HEADER
        write(lout,10460) dump
        write(lout,*) ''
        write(lout,*) '       The last column states the format'
        write(lout,*) '            of the output file (see manual):'
        
        ! ldump(0)=.true. : DUMP all elements found
        if ( ldump(0) ) then
           write(lout,10470) 'ALL SING. ELEMS.', ndumpt(0),
     &          dumpunit(0), dump_fname(0), dumpfmt(0),
     &          dumpfirst(0), dumplast(0)
        endif
        do ii=1,il
          if(ldump(ii)) then
            write(lout,10470)
     &     bez(ii), ndumpt(ii), dumpunit(ii),dump_fname(ii),dumpfmt(ii),
     &     dumpfirst(ii), dumplast(ii)
      
!           At which structure indices is this single element found? (Sanity check)
            kk = 0
            do jj=1,mper*mbloz      ! Loop over all structure elements
              if ( ic(jj)-nblo .eq. ii ) then
                write (ch1,*) jj    ! internal write for left-adjusting
                write (lout,10472)
     &               " -> Found as structure element no. "
     &               // trim(adjustl(ch1))
                kk = kk + 1
              end if
            end do
            if (kk .eq. 0) then
               write (lout,10472) " !! Warning: No structure elements "
     &              // "found for '" // bez(ii) // "'!"
               write (lout,10472)
     &              " !! This element is probably only found"
     &              // " in a BLOC, or it is not used at all."
               write (lout,10472) " !! Please fix your DUMP block"
     &              // " in fort.3"

               call prror(-1)
            endif
          endif
        enddo

        if ( ldumphighprec ) then
          write(lout,*) ''
          write(lout,*) '        --> requested high precision dumping!'
        endif
        if ( ldumpfront ) then
          write(lout,*) ''
          write(lout,*) '        --> requested FRONT dumping!'
        endif
        goto 110
      endif

!     initialise reading variables, to avoid storing non sense values
      idat = ' '
      i1 = 0  ! frequency
      i2 = 0  ! unit
      i3 = 0  ! format
      i4 = 1  ! first turn
      i5 = -1 ! last turn

      if(ch(:4).eq.'HIGH') then
        ldumphighprec = .true.
        goto 2000
      else if(ch(:5).eq.'FRONT') then
         ldumpfront = .true.
         goto 2000
      endif
      
!     requested element
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) call prror(-1)
      
      if ( (getfields_nfields .lt. 4) .or. 
     &     (getfields_nfields .gt. 7) .or.
     &     (getfields_nfields .eq. 6)      ) then
         write(lout,*) "ERROR in DUMP:"
         write(lout,*) "Expected 4 to 7 (but not 6) arguments, got",
     &        getfields_nfields
         write(lout,*)
     &        ("'"//getfields_fields(kk)(1:getfields_lfields(kk))//"' ",
     &        kk=1,getfields_nfields)
         call prror(-1)
      endif
      if (getfields_lfields(1) > 16) then
         write(lout,*) "ERROR in DUMP:"
         write(lout,*) "element names are max. 16 characters"
         call prror(-1)

      endif
      idat = getfields_fields(1)(1:getfields_lfields(1))
      read(getfields_fields(2)(1:getfields_lfields(2)),*) i1
      read(getfields_fields(3)(1:getfields_lfields(3)),*) i2
      read(getfields_fields(4)(1:getfields_lfields(4)),*) i3
      if (getfields_nfields .eq. 4) then
         !Automatic fname
         write(ch1,"(a5,I0)") "fort.", i2
      else if ( (getfields_nfields .eq. 5) .or. 
     &          (getfields_nfields .eq. 7)     ) then
         !Given fname
         ch1 = getfields_fields(5)(1:getfields_lfields(5))
      else
         !ERROR
         call prror(-1)
      endif
      if (getfields_nfields .eq. 7) then
         read(getfields_fields(6)(1:getfields_lfields(6)),*) i4
         read(getfields_fields(7)(1:getfields_lfields(7)),*) i5
      endif
      
!Check that first/last turn is sane
      if ( i5.ne.-1 ) then
         if ( i5 .lt. i4 ) then
            write(lout,*)
     &           "Error in DUMP: Expect last turn >= first turn, ",
     &           "unless last turn = -1 (infinity), got", i4,i5
           call prror(-1)
         endif
      endif
      if ( i4 .lt. 1 ) then
         write(lout,*)
     &        "Error in DUMP: Expect first turn >= 1, got", i4
         call prror(-1)
      endif

!     find it in the list of SINGLE ELEMENTs:
      do j=1,il
         if(bez(j).eq.idat) then
            if (ldump(j)) then !Only enable once/element!
               write(lout,*) "Error in parsing DUMP block:"
               write(lout,*) "Element '",idat, "' was specified",
     &              " more than once"
               call prror(-1)
            endif
            goto 2001
         endif
      enddo
      if ( idat(:3).eq.'ALL' ) then
         j=0
         if (ldump(j)) then
            write(lout,*) "ERROR in parsing DUMP block:"
            write(lout,*) "'Element' ALL was specified "//
     &           "(at least) twice"
            call prror(-1)
         endif
         goto 2001
      endif
!     search failed:
      write(lout,*) ''
      write(lout,*) " Un-identified SINGLE ELEMENT '", idat, "'"
      write(lout,*) '   in block ',dump, '(fort.3)'
      write(lout,*) '   parsed line:'
      write(lout,*) ch(:80)
      write(lout,*) ''
      call prror(-1)

!     element found:
 2001 ldump(j) = .true.
      ndumpt(j) = i1
      if (ndumpt(j).le.0) ndumpt(j)=1
      dumpunit(j) = i2
      dumpfmt(j)  = i3
      dump_fname(j) = ch1
      dumpfirst(j) = i4
      dumplast(j) = i5
!     go to next line
      goto 2000

!-----------------------------------------------------------------------
!  DYNAMIC KICKS
!  A.Mereghetti, for the FLUKA Team
!  K.Sjobak & A. Santamaria, BE-ABP/HSS
!  last modified: 21-01-2014
!  always in main code
!-----------------------------------------------------------------------
 2200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2200 ! skip comment line

      ! Which type of block? Look at start of string (no leading blanks allowed)

      if (ch(:4).eq."DEBU") then
         ldynkdebug = .true.
         write (lout,*)
     &        "DYNK> DYNK block debugging is ON"
         goto 2200 !loop DYNK
         
      else if (ch(:6).eq."NOFILE") then
         ldynkfiledisable = .true.
         write (lout,*)
     &        "DYNK> Disabled writing dynksets.dat"
         goto 2200 !loop DYNK
         
      else if (ch(:3).eq."FUN") then
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write (lout,'(1x,A,I4,A)')
     &           "DYNKDEBUG> Got a FUN block, len=",
     &           len(ch), ": '"// trim(ch)// "'"
            do ii=1,getfields_nfields
               write (lout,*)
     &              "DYNKDEBUG> Field(",ii,") ='",
     &              getfields_fields(ii)(1:getfields_lfields(ii)),"'"
            enddo
         endif
         call dynk_parseFUN(getfields_fields,
     &        getfields_lfields, getfields_nfields)
         goto 2200 !loop DYNK

      else if (ch(:3).eq."SET") then
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write (lout,'(1x,A,I4,A)')
     &           "DYNKDEBUG> Got a SET block, len=",
     &           len(ch), ": '"//trim(ch)//"'"
            do ii=1,getfields_nfields
               write (lout,*)
     &              "DYNKDEBUG> Field(",ii,") ='",
     &              getfields_fields(ii)(1:getfields_lfields(ii)),"'"
            enddo
         endif
         call dynk_parseSET(getfields_fields,
     &        getfields_lfields, getfields_nfields)
         goto 2200 !loop DYNK

      else if (ch(:4).eq.next) then
         if (ldynkdebug) then
            write (lout,*)
     &           "DYNKDEBUG> Finished parsing DYNK block"
            call dynk_dumpdata
         endif
         if (ldynk) then
            write (lout,*)
            write (lout,*) "******************************************"
            write (lout,*) "** More than one DYNK block encountered **"
            write (lout,*) "******************************************"
            call prror(51)
         else
            ldynk = .true.
         endif
         call dynk_inputsanitycheck
         goto 110 ! Read next block or ENDE

      else
         write (lout,*)
         write (lout,*) "*******************************************"
         write (lout,*) "ERROR while parsing DYNK block in fort.3"
         write (lout,*)
     &        "Expected keywords FUN, SET, DEBU, NOFILE or NEXT"
         write (lout,*) "Got ch:"
         write (lout,*) "'"//ch//"'"
         write (lout,*) "*******************************************"
         call prror(51)
      endif
      ! Should never arrive here
      write (lout,*) "*****************************"
      write (lout,*) "*LOGIC ERROR IN PARSING DYNK*"
      write (lout,*) "*****************************"
      call prror(51)
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!  FMA
!  M. Fitterer, R. De Maria, K. Sjobak, BE/ABP-HSS
!  last modified: 07-01-2016
!  always in main code
!-----------------------------------------------------------------------
 2300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2300 ! skip comment lines

      if (ch(:4).eq.next) then
         goto 110 ! loop to next BLOCK in fort.3
      endif
 
      if(fma_numfiles.ge.fma_max) then
        write(lout,*)
     &       'ERROR: you can only do ',fma_max,' number of FMAs'
        call prror(-1) 
      endif

      fma_numfiles=fma_numfiles+1 !Initially initialized to 0 in COMNUL
!     read in input parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)
     &       'ERROR in FMA block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif
      if(getfields_nfields.eq.1 .or. getfields_nfields.ge.4) then
        write(lout,*)
     &       'ERROR in FMA block: wrong number of input ',
     &       'parameters: ninput = ', getfields_nfields, ' != 2 (or 3)'
        call prror(-1)
      endif

      fma_fname(fma_numfiles)  =
     &     getfields_fields(1)(1:getfields_lfields(1))
      fma_method(fma_numfiles) =
     &     getfields_fields(2)(1:getfields_lfields(2))
      if(getfields_nfields.eq.2) then
        fma_norm_flag(fma_numfiles) = 1 !default: normalize phase space
      endif
      if(getfields_nfields.eq.3) then
         read (getfields_fields(3)(1:getfields_lfields(3)),'(I10)')
     &        fma_norm_flag(fma_numfiles)
      endif

      ! Input sanity checks
      if (.not. (
     &    trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNELASK"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFFTI"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFFT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEAPA"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEFIT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNENEWT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEABT2"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNEABT"
     &.or.trim(stringzerotrim(fma_method(fma_numfiles))).eq."TUNENEWT1")
     &   ) then
         write(lout,*)
     &        "ERROR in DATEN::FMA: The FMA method '"//
     &        trim(stringzerotrim(fma_method(fma_numfiles)))
     &        //"' is unknown. FMA index = ", fma_numfiles
         write(lout,*)
     &       "Please use one of TUNELASK, TUNEFFTI, TUNEFFT, "//
     &       "TUNEAPA, TUNEFIT, TUNENEWT, TUNEABT2, TUNEABT2. "//
     &       "Note that it is case-sensitive, so use uppercase only."
         call prror(-1)
      end if

      if (.not. (fma_norm_flag(fma_numfiles).eq.0 .or.
     &           fma_norm_flag(fma_numfiles).eq.1      )) then
         write(lout,*)
     &        "ERROR in DATEN::FMA: Expected  fma_norm_flag = 1 or 0."//
     &        "Got:", fma_norm_flag(fma_numfiles),
     &        "FMA index =",fma_numfiles
      end if
      
      fma_flag = .true.
      goto 2300
!-----------------------------------------------------------------------
!  Electron Lense, kz=29,ktrack=63
!  M. Fitterer,  FNAL
!  last modified: 20-06-2016
!-----------------------------------------------------------------------
 2400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2400 ! skip comment lines

      if (ch(:4).eq.next) then
!       4) loop over single elements to check that they have been defined in the fort.3 block
        do j=1,nele
          if(kz(j).eq.29) then
            if(elens_type(j).eq.0) then
              write(lout,*)
     &'ERROR: elens ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '//
     &'not defined in fort.3. You must define every elens in the '//
     &'ELEN block in fort.3!'
               call prror(-1)
            endif
          endif
        enddo
        goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
+if fio
        write(lout,*)
     &       'ERROR in ELEN block: fortran IO format currently not ',
     &       'supported!'
        call prror(-1)
+ei

!     1) read in elens parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)
     &       'ERROR in ELEN block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check number of arguments
!     If a new type of elens is implemented, may need to modify this!
      if(getfields_nfields.ne.9) then
        write(lout,*)
     &       'ERROR in ELEN block: wrong number of input ',
     &       'parameters: ninput = ', getfields_nfields, ' != 9'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)
     &        "ERROR in ELEN block: Element name max 16 characters;"//
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of elens
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_elens=29)
            if(kz(j).ne.29) then
               write(lout,*)
     &              'ERROR: element type mismatch for ELEN!'//
     &              'Element type is kz(',j,') = ',kz(j),'!= 29'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_elens=29)
               write(lout,*)
     &'ERROR: length el(j) (elens is treated as thin element), '//
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,
     &')=',ek(j),'. Please check your input in the single element '//
     &'definition of your ELEN. All values except for the type need '//
     &'to be zero.'
               call prror(-1)
            endif
            if (elens_type(j).ne.0) then
               write(lout,*) "ERROR in ELEN block:"//
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            select case ( getfields_fields(2)(1:getfields_lfields(2)) )
            case ("ANNULAR")
               ! Read in this case
               elens_type(j) = 1
+if .not.crlibm
               read (getfields_fields(3)(1:getfields_lfields(3)),*)
     &              elens_theta_max(j)
               read (getfields_fields(4)(1:getfields_lfields(4)),*)
     &              elens_r2(j)
               read (getfields_fields(5)(1:getfields_lfields(5)),*)
     &              elens_r2ovr1(j)
               read (getfields_fields(6)(1:getfields_lfields(6)),*)
     &              elens_offset_x(j)
               read (getfields_fields(7)(1:getfields_lfields(7)),*)
     &              elens_offset_y(j)
+ei
+if crlibm
               elens_theta_max(j)= round_near (
     &              errno,getfields_lfields(3)+1, getfields_fields(3) )
               if (errno.ne.0) call rounderr (
     &              errno,getfields_fields,3,elens_theta_max(j) )
               elens_r2(j)       = round_near (
     &              errno,getfields_lfields(4)+1, getfields_fields(4) )
               if (errno.ne.0) call rounderr (
     &              errno,getfields_fields,4,elens_r2(j) )
               elens_r2ovr1(j)   = round_near (
     &              errno,getfields_lfields(5)+1, getfields_fields(5) )
               if (errno.ne.0) call rounderr (
     &              errno,getfields_fields,5,elens_r2ovr1(j) )
               elens_offset_x(j) = round_near (
     &              errno,getfields_lfields(6)+1, getfields_fields(6) )
               if (errno.ne.0) call rounderr (
     &              errno,getfields_fields,6,elens_offset_x(j) )
               elens_offset_y(j) = round_near (
     &              errno,getfields_lfields(7)+1, getfields_fields(7) )
               if (errno.ne.0) call rounderr (
     &              errno,getfields_fields,7,elens_offset_y(j) )
+ei
               read(getfields_fields(8)(1:getfields_lfields(8)),'(I10)')
     &              elens_bend_entrance(j)
               read(getfields_fields(9)(1:getfields_lfields(9)),'(I10)')
     &              elens_bend_exit(j)
               
               ! Make checks for this case
               if(elens_r2ovr1(j).le.1) then
                  write(lout,*)
     &'ERROR: ELEN radius ratio r2/r1 must be larger than 1, but is ',
     &elens_r2ovr1(j),'<1'
                 call prror(-1)
              end if
              if(elens_bend_entrance(j).ne. 1 .and.
     &           elens_bend_entrance(j).ne.-1 .and.
     &           elens_bend_entrance(j).ne. 0      ) then
                 write(lout,*)
     &'ERROR: ELEN flag for taking bends at entrance into account must'
     &//' be -1,0,1, but elens_bend_entrance =',
     &elens_bend_entrance(j)
                 call prror(-1)
              end if
              if(elens_bend_exit(j).ne. 1 .and.
     &           elens_bend_exit(j).ne.-1 .and.
     &           elens_bend_exit(j).ne.0       ) then
                 write(lout,*)
     &'ERROR: ELEN flag for taking bends at exit into account must'
     &//' be -1,0,1, but elens_bend_exit =',
     &elens_bend_exit(j)
                 call prror(-1)
              end if

              ! print a summary of elens parameters
              write(lout,
     &fmt='((A,/),(A,A,/),(A,A,A,I4,/),5(A,D9.3,A,/),(A,/),'
     &//'2(A,I4,/))')
     &'ELENS found in list of single elements with: ',
     &'name     = ',bez(j),
     &'type     = ',getfields_fields(2)(1:getfields_lfields(2)),
     &        ' = ',elens_type(j),
     &'thetamax = ',elens_theta_max(j),' mrad',
     &'r2       = ',elens_r2(j),' mm',
     &'r2/r1    = ',elens_r2ovr1(j),'',
     &'offset_x = ',elens_offset_x(j),' mm',
     &'offset_y = ',elens_offset_y(j),' mm',
     &'enable bends at:',
     &'  entrance = ',elens_bend_entrance(j),
     &'  exit     = ',elens_bend_exit(j)
      
            case default
               write(lout,*) "ERROR in ELEN: "//
     &              "Elens type '"//
     &              getfields_fields(2)(1:getfields_lfields(2))//
     &              "' not recognized. Remember to use all UPPER CASE!"
               call prror(-1)
            end select
            
            goto 2401           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in ELEN: "//
     &     "Un-identified SINGLE ELEMENT '",
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2401 continue
      
      goto 2400 ! at NEXT statement -> check that all single elements with kz(j) = 29 (elens) have been defined in ELEN block

!-----------------------------------------------------------------------
!  Wire, kz=+/-15,ktrack=45
!  A. Patapenka (NIU), M. Fitterer,  FNAL
!  last modified: 22-12-2016
!-----------------------------------------------------------------------
 2500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2500 ! skip comment lines
     
      if (ch(:4).eq.next) then
!       4) loop over single elements to check that they have been defined in the fort.3 block
        do j=1,nele
          if(kz(j).eq.15) then
            if(wire_flagco(j).eq.0) then
              write(lout,*)
     &'ERROR: wire ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '//
     &'not defined in fort.3. You must define every wire in the '//
     &'WIRE block in fort.3!'
               call prror(-1)
            endif
          endif
        enddo
        goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
+if fio
        write(lout,*)
     &       'ERROR in WIRE block: fortran IO format currently not ',
     &       'supported!'
        call prror(-1)
+ei

!     1) read in wire parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)
     &       'ERROR in WIRE block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check number of arguments
      if(getfields_nfields.ne.9) then
        write(lout,*)
     &       'ERROR in WIRE block: wrong number of input ',
     &       'parameters: ninput = ', getfields_nfields, ' != 9'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)
     &        "ERROR in WIRE block: Element name max 16 characters;"//
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of wire
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_wire=15)
            if(kz(j).ne.15) then
               write(lout,*)
     &              'ERROR: element type mismatch for WIRE! '//
     &'Element type is kz(',j,') = ',kz(j),'!= +15'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_wire=+/-15)
               write(lout,*)
     &'ERROR: length el(j) (wire is treated as thin element), '//
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,
     &')=',ek(j),'. Please check your input in the single element '//
     &'definition of your WIRE. All values except for the type need '//
     &'to be zero.'
               call prror(-1)
            endif
            if (wire_flagco(j).ne.0) then
               write(lout,*) "ERROR in WIRE block:"//
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            read(getfields_fields(2)(1:getfields_lfields(2)),'(I10)')
     &           wire_flagco(j)
+if .not.crlibm
            read (getfields_fields(3)(1:getfields_lfields(3)),*)
     &           wire_current(j)
            read (getfields_fields(4)(1:getfields_lfields(4)),*)
     &           wire_lint(j)
            read (getfields_fields(5)(1:getfields_lfields(5)),*)
     &           wire_lphys(j)
            read (getfields_fields(6)(1:getfields_lfields(6)),*)
     &           wire_dispx(j)
            read (getfields_fields(7)(1:getfields_lfields(7)),*)
     &           wire_dispy(j)
            read (getfields_fields(8)(1:getfields_lfields(8)),*)
     &           wire_tiltx(j)
            read (getfields_fields(9)(1:getfields_lfields(9)),*)
     &           wire_tilty(j)
+ei
+if crlibm
            wire_current(j)= round_near (
     &           errno,getfields_lfields(3)+1, getfields_fields(3) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,3,wire_current(j) )
            wire_lint(j)       = round_near (
     &           errno,getfields_lfields(4)+1, getfields_fields(4) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,4,wire_lint(j) )
            wire_lphys(j)   = round_near (
     &           errno,getfields_lfields(5)+1, getfields_fields(5) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,5,wire_lphys(j) )
            wire_dispx(j) = round_near (
     &           errno,getfields_lfields(6)+1, getfields_fields(6) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,6,wire_dispx(j) )
            wire_dispy(j) = round_near (
     &           errno,getfields_lfields(7)+1, getfields_fields(7) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,7,wire_dispy(j) )
            wire_tiltx(j) = round_near (
     &           errno,getfields_lfields(8)+1, getfields_fields(8) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,8,wire_tiltx(j) )
            wire_tilty(j) = round_near (
     &           errno,getfields_lfields(9)+1, getfields_fields(9) )
            if (errno.ne.0) call rounderr (
     &           errno,getfields_fields,9,wire_tilty(j) )
+ei
            
            ! Make checks for the wire parameters
            if(wire_flagco(j).ne. 1 .and. wire_flagco(j).ne.-1) then
               write(lout,*)
     &"ERROR: WIRE flag for defining the wire separation "//
     &"must be -1 (disp* = distance closed orbit and beam)"//
     &"or 1 (disp* = distance from x=y=0 <-> beam), but "//
     &"wire_flagco = ",wire_flagco(j)
               call prror(-1)
            end if
            if((wire_lint(j).lt.0) .or. (wire_lphys(j).lt.0)) then
              write(lout,*)
     &'ERROR: WIRE integrated and physical length must larger than 0! '
     &// 'wire_lint = ',wire_lint(j),', wire_lphys = ',wire_lphys(j)
              call prror(-1)
            end if
            if((abs(wire_tiltx(j)) .ge. 90) .or. 
     &         (abs(wire_tilty(j)) .ge. 90)) then
              write(lout,*)
     &'ERROR: WIRE tilt angle must be within [-90,90] degrees! '
     &//'wire_tiltx = ',wire_tiltx(j),', wire_tilty = ',wire_tilty(j)
              call prror(-1)
            end if

! print a summary of the wire parameters
            write(lout,
     &fmt='((A,/),(A,A,/),(A,I4,/),7(A,D9.3,A,/))')
     &'WIRE found in list of single elements with: ',
     &'name               = ',bez(j),
     &'flagco             = ',wire_flagco(j),
     &'current            = ',wire_current(j),' A',
     &'integrated length  = ',wire_lint(j),' m',
     &'physical length    = ',wire_lphys(j),' m',
     &'hor. displacement  = ',wire_dispx(j),' mm',
     &'vert. displacement = ',wire_dispy(j),' mm',
     &'hor. tilt          = ',wire_tiltx(j),' degrees',
     &'vert. tilt         = ',wire_tilty(j),' degrees'
! ignore wire if current, length or displacment are 0 or
! wire_flagco not set (case wire_flagco = 0)
! for displacement only ignore if wire_dispx = wire_dispy = 0
            if( abs(wire_flagco(j)*(wire_current(j)*(wire_lint(j)
     &*(wire_lphys(j)*(wire_dispx(j)+wire_dispy(j)))))).le.pieni ) then
              kz(j) = 0 ! treat element as marker

              write(lout,
     &fmt='((A,A,A,/),(A,A,/),4(A,I0,A,D9.3,/))')
     &'WARNING: WIRE element ',bez(j),'ignored!',
     &'Elements are ignored if current, displacment, integrated ',
     &'or physical length are 0! ',
     &'wire_dispx(',j,') = ',wire_dispx(j),
     &'wire_dispy(',j,') = ',wire_dispy(j),
     &'wire_lint(',j,') = ',wire_lint(j),
     &'wire_lphys(',j,') = ',wire_lphys(j)
            end if

            goto 2501           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in WIRE: "//
     &     "Un-identified SINGLE ELEMENT '",
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2501 continue
      
      goto 2500 ! at NEXT statement -> check that all single elements with kz(j) = 15 (wire) have been defined in WIRE block

!-----------------------------------------------------------------------
!  ZIPF
!  K. Sjobak, BE-ABP/HSS
!  Last modified: 7/2 2017
!-----------------------------------------------------------------------
 2800 read(3,10020, end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2800 ! skip comment line
      
      if (ch(:4).eq.next) then
         zipf_outfile(1:10) = "Sixout.zip" ! Output name fixed for now
            write(lout,'(a)')       "**** ZIPF ****"
            write(lout,'(a,a,a)')   " Output file name = '",
     &           trim(stringzerotrim(zipf_outfile)),"'"
            write(lout,'(a,1x,i5)') " Number of files to pack=",
     &           zipf_numfiles
            write(lout,'(a)')       " Files:"
         do ii=1,zipf_numfiles
            write(lout,'(1x,i5,a,1x,a)') ii,":",
     &            trim(stringzerotrim(zipf_filenames(ii)))
         end do

         if (.not.(zipf_numfiles.gt.0)) then
            write(lout,'(a)') "ERROR in ZIPF:"
            write(lout,'(a)') " ZIPF block was empty;"
            write(lout,'(a)') " no files specified!"
            call prror(-1)
         endif

+if .not.libarchive
         write(lout,'(a)') "ERROR in ZIPF:"
         write(lout,'(a)') " ZIPF needs LIBARCHIVE to work,"
         write(lout,'(a)') " but this SixTrack was "//
     &        "compiled without it."
         call prror(-1)
+ei
         goto 110                  !Read next block or ENDE
      endif

      !Read filenames
      call getfields_split( ch, getfields_fields, getfields_lfields,
     &     getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) call prror(-1)

      if (getfields_nfields .ne. 1) then
         write(lout,'(a)')         "ERROR in ZIPF:"
         write(lout,'(a,1x,i3,a)') "Expected 1 filename per line, got",
     &                              getfields_nfields, ", line=",ch
         call prror(-1)
      end if

      zipf_numfiles = zipf_numfiles + 1
      if (zipf_numfiles .ge. zipf_maxfiles) then
         write(lout,'(a)')       "ERROR in ZIPF:"
         write(lout,'(a,1x,i5)') " Too many files, max=",
     &         zipf_maxfiles
         call prror(-1)
      endif
      
      zipf_filenames(zipf_numfiles)(1:getfields_lfields(1)) =
     &     getfields_fields(1)(1:getfields_lfields(1))
      
      goto 2800                 !Read the next line of the ZIPF block
!----------------------------------------------------------------------------
!     ENDE was reached; we're done parsing fort.3, now do some postprocessing.
!-----------------------------------------------------------------------------
  771 if(napx.ge.1) then
        if(e0.lt.pieni.or.e0.le.pma) call prror(27)
        if(nbeam.ge.1) parbe14=                                         &!hr05
     &(((((-1d0*crad)*partnum)/four)/pi)/emitnx)*c1e6                    !hr05
        gammar=pma/e0
        crad=(((two*crad)*partnum)*gammar)*c1e6                          !hr05
        emitx=emitnx*gammar
        emity=emitny*gammar
+if collimat
        remitx_dist=emitnx0_dist*gammar
        remity_dist=emitny0_dist*gammar
        remitx_collgap=emitnx0_collgap*gammar
        remity_collgap=emitny0_collgap*gammar
+ei
      endif
+if collimat
      if (.not.has_coll) then
         !Breaks at least DUMP (negative particle IDs) and DYNK (1-pass actions).
         write(lout,*) ""
         write(lout,*) "ERROR in parsing fort.3:"
         write(lout,*) "This is the collimation version of SixTrack,"
         write(lout,*) " but no COLL block was found,"
         write(lout,*) " not even one with do_coll = .false."
         write(lout,*) "Please use the non-collimation version!"
         call prror(-1)
      endif
+ei
      if(idp.eq.0.or.ition.eq.0.or.nbeam.lt.1) then
        do j=1,il   ! converting 6D lenses to 4D
          if (beam_expflag .eq. 1) then
             if (parbe(j,2) .gt. 0) then
               parbe(j,2)=0d0
               parbe(j,1)=parbe(j,7)
               parbe(j,3)=parbe(j,10)
             endif
          else
             parbe(j,2)=0d0
          endif
        enddo
      else
        do j=1,il
          if(parbe(j,2).gt.dble(mbea)) then
             write(lout,'(a,i5,a,i5,a,a16,a,i5)')
     &            'ERROR: Requested ',
     &            int(parbe(j,2)), " slices for 6D beam-beam element"//
     &            ' #',j, " named ", bez(j), ", maximum is mbea =",mbea
            parbe(j,2)=dble(mbea)
            call prror(-1) !Treat this warning as an error
         endif
        enddo
      endif
      if(iout.eq.0) return
      write(lout,10050)
      write(lout,10060)
      il1=il
      if(ncy2.eq.0) il1=il-1
      do 1435 k=1,il1
      if(abs(kz(k)).eq.12) then
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),phasc(k),xpl(k),   &
     &xrms(k),zpl(k),zrms(k)
        kz(k)=abs(kz(k))
        phasc(k)=phasc(k)*rad
      else
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),el(k),xpl(k),      &
     &xrms(k),                                                          &
     &zpl(k),zrms(k)
      endif
 1435 continue
      write(lout,10130)
      write(lout,10080)
      write(lout,10090) mper,(msym(k),k=1,mper)
      write(lout,10250) mblo,mbloz
      write(lout,10100)
      do 1450 l=1,mblo
      kk=mel(l)
      ll=kk/6
      if(ll.ne.0) then
        do 1440 l1=1,ll
          l2=(l1-1)*6+1
          l3=l2+5
          if(l2.eq.1) then
            write(lout,10260) l,bezb(l),kk,(beze(l,k),k=1,6)
          else
            write(lout,10270) (beze(l,k),k=l2,l3)
          endif
 1440   continue
        if(mod(kk,6).ne.0) then
          l4=ll*6+1
          write(lout,10270) (beze(l,k),k=l4,kk)
        endif
      else
        write(lout,10260) l,bezb(l),kk,(beze(l,k),k=1,kk)
      endif
 1450 continue
      write(lout,10120)
      mblozz=mbloz/5+1
      do 1480 k=1,mblozz
      k10=(k-1)*5
      if((mbloz-k10).eq.0) goto 1480
      do 1470 l=1,5
        if((k10+l).gt.mbloz) ic0(l)=' '
        if((k10+l).gt.mbloz) goto 1470
        icc=ic(k10+l)
        if(icc.gt.nblo) goto 1460
        ic0(l)=bezb(icc)
        goto 1470
 1460   ic0(l)=bez0(icc-nblo)
 1470 continue
      k11=k10+1
      write(lout,10280) k11,(ic0(l),l=1,5)
 1480 continue
      write(lout,10130)
 1490 if(idp.eq.0) goto 1500
      if(nbeam.ge.1) then !Write out with BB parameters
         if(beam_expflag .eq. 0) then  !The old BEAM format
            if(partnum.gt.zero) then !Beams have same charge
               write(lout,
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               write(lout,
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            endif
            
         elseif (beam_expflag .eq. 1) then ! The new BEAM-EXPERT format
            if(partnum.gt.zero) then !Beams have same charge
               write(lout, ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               write(lout,  ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t71,f9.4/   &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t71,f9.4/     &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            endif
         else
            write(lout,'(a)') "ERROR in subroutine daten"
            write(lout,'(a)') "beam_expflag was", beam_expflag
            write(lout,'(a)') " expected 0 or 1. This is a BUG!"
            call prror(-1)
         endif
      else !No beam beam
        write(lout,10142) ncy,dp1,dppoff,tlen,pma,e0
      endif
      if(ncy2.eq.0) then
        write(lout,10143) harm,u0,phag,qs,alc
      else
        write(lout,*)
      endif
      if(beam_expflag .eq. 0) then
         if(ibb6d.eq.1) then
            write(lout,
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    CROSSING_ANGLE',            &
     &'    CROSSING_PLANE    COUPLING_ANGLE'/t10,85('-')/)")
            do j=1,il
               if(parbe(j,2).gt.0d0)
     &              write(lout,"(t10,a16,5x,i4,7x,d16.10,2x,d16.10)")
     &              bez(j),int(parbe(j,2)),parbe(j,1),parbe(j,3)
            enddo
         endif
         
      elseif(beam_expflag .eq. 1) then
         write(lout,
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    XING_ANGLE',                &
     &'  XING_PLANE   HOR_SEP     VER_SEP        S11        S12      ', &
     &'  S22         S33         S34         S44         S13         ', &
     &'S14         S23         S24'/t10,200('-')/)")
         do j=1,il
            if(kz(j).eq.20.and.parbe(j,17).eq.1)then
               write(lout,
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,      &
     &2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,        &
     &1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6),      &
     &parbe(j,7),parbe(j,8),parbe(j,9),parbe(j,10),parbe(j,11),         &
     &parbe(j,12),parbe(j,13),parbe(j,14),parbe(j,15),parbe(j,16)
            endif
         enddo
         write(lout,
     &"(//,t30,'4D BEAM-BEAM ELEMENTS'/t30,24('-')//                    &
     &t10,'ELEMENT           #_OF_SLICES        S11   ',                &
     &'     S22       HOR_SEP     VER_SEP'/t10,80('-')/)")
         do j=1,il
            if (kz(j).eq.20.and.parbe(j,17).eq.0) then
               write(lout,                                              &
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")    &
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6)
            endif
         enddo
         
      else
         write(lout,'(a)') "ERROR in subroutine daten"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
      write(lout,10130)
 1500 continue
      write(lout,10150)
      nfb=nde(1)
      nac=nde(2)
      nft=numl-nde(2)
      if(numl.le.nde(2)) nft=0
      if(numl.le.nde(2)) nac=numl
      if(numl.le.nde(1)) nac=0
      if(numl.le.nde(1)) nfb=numl
      write(lout,10160) numl,numlr,nwr(4),nfb,nwr(1),nac,nwr(2),nft,    &
     &nwr(3),                                                           &
     &kanf,amp(1),rat,itco,dma,dmap,itqv,dkq,dqq
      write(lout,10170) itcro,dsm0,dech,de0,ded,dsi
      write(lout,10130)
      write(lout,10040)
      write(lout,10130)
      goto 1540
 1520 call prror(41)
 1530 call prror(42)
 1540 continue
+if vvector
      !Check that the number of particles is OK
      if(((2*mmac)*imc)*napx.gt.npart) call prror(54)                    !hr05
+ei

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(11(a4,1x))
10010 format(a4,8x,a60)
10020 format(a)
10030 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
     &'OO  SIXTRACK-INPUT  OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10040 format(t10,21('O')/t10,2('O'),17x,2('O')/t10,                     &
     &'OO  PREPROCESSING  OO', /t10,2('O'),17x,2('O')/t10,21('O'))
10050 format(//131('-')//t43,'*** RING PARAMETERS ***'/)
10060 format(t30,'SINGLE ELEMENTS:'/'  NO   NAME  TYP      ',           &
     &' 1/RHO          STRENGTH          LENGTH           X-POS     ',  &
     &'     X-RMS            Y-PO          Y-RMS     ' /131('-'))
10080 format(/t30,'RINGSTRUCTURE:'//)
10090 format(t10,'NO. OF SUPERPERIODS AND SYMMETRY ' ,t50,i3,'   ',15i4,&
     &'   ')
10100 format(//131('-')//t30,'BLOCKSTRUCTURE:'/ t30,                    &
     &'(BLOCKTYP--NO. OF SINGLE ELEMENTS--SINGLE ELEMENT TYPES)'//)
!10110 format(t10,i3,' ---',i3,' --- ',30i3)
10120 format(//131('-')//t30,'BLOCKSTRUCTURE OF SUPERPERIOD:'//)
10130 format(/131('-')/)
10142 format(t30,'SYNCHROTRON OSCILLATIONS'//                           &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10143 format(                                                           &
     &t10,'HARMONIC NUMBER',t74,f6.0/                                   &
     &t10,'CIRCUMF. VOLTAGE   (MV)',t66,f14.9/                          &
     &t10,'EQUILIBRIUM PHASE     (DEG)',t66,f14.9/                      &
     &t10,'FREQUENCY (IN UNITS OF REVOLUTION-FREQ.) QS-LINEAR',         &
     &t66 ,f14.9/                                                       &
     &t10,'MOMENTUM COMPACTION',t66,f14.9/)
10150 format(//t43,'*** TRACKING PARAMETERS ***'/)
10160 format(t10,'NUMBER OF REVOLUTIONS  ',t48,i8/ t10,                 &
     &'NUMBER OF REVERSE-REVOLUTIONS',t48,i8/ t10,                      &
     &'TURNS PER COOR.-PRINTOUT',t48,i8/ t10,'FLAT BOTTOM UP TO TURN ', &
     &t48,i8/ t10,'TURNS PER PRINT ON DATASET',t48,i8/ t10,             &
     &'ACCELERATION UP TO TURN',t48,i8/ t10,'TURNS PER PRINT ON DATASET'&
     &,t48,i8/ t10,'FLAT TOP NUMBER OF TURNS',t48,i8/ t10,              &
     &'TURNS PER PRINT ON DATASET',t48,i8/ t10,                         &
     &'TRACKING START AT ELEMENT NO.',t48,i8/ t10,                      &
     &'INITIAL AMPLITUDE-H IN (MM)',t49,f7.3/ t10,                      &
     &'COUPLING  EPS-Y/EPS-X',t49,f7.3/ t10,                            &
     &'NUMBER OF C.-O. ITERATIONS ',t48,i8/ t10,                        &
     &'PRECISION OF C.-O. DEVIATION',t47,d9.3/ t10,                     &
     &'PRECISION OF C.-O. SLOPE   ',t47,d9.3/ t10,                      &
     &'NUMBER OF Q-ADJ. ITERATIONS',t48,i8/ t10,                        &
     &'CHANGE IN K-STRENGTH BY',t47,d9.3/ t10,                          &
     &'PRECISION OF Q-ADJUSTEMENT',t47,d9.3)
10170 format(t10,'NUMBER OF CHROMAT.-ADJ. ITER.',t48,i8/ t10,           &
     &'CHANGE IN SEX.-STRENGTH BY',t47,d9.3/ t10,                       &
     &'PRECISION OF CHROMAT.-ADJ.',t47,d9.3/ t10,                       &
     &'DP-INTERVAL F. CROMAT.-ADJ.',t47,d9.3/ t10,                      &
     &'DP-INTERVAL FOR DISPERSION',t47,d9.3/ t10,                       &
     &'PRECISION FOR C.-O. RMS',t47,d9.3/)
10180 format(t5/t10,a60)
10190 format(t10,'PROGRAM MODE : FREE FORMAT INPUT')
10200 format(t10,'PROGRAM MODE : FREE FORMAT INPUT --READ FROM ',       &
     &'EXTRA GEOMETRY STRENGTH FILE--')
10220 format(t10,i4,2(' ',d15.8),5x,2(' ',d15.8))
10250 format(t10,'NUMBER OF DIFFERENT BLOCKS',t50,i3/ t10,              &
     &'BLOCKS PER PERIOD',t49,i5//)
10290 format(t10,'MORE THAN ',i5,' COMBINATIONS SPECIFIED'/)
10300 format(//131('-')//t10,'DATA BLOCK COMBINATION OF ELEMENTS',      &
     &'  THE FOLLOWING ELEMENTS ARE RELATED IN STRENGTHS--->'/ t10,     &
     &'ELEMENT RELATED TO ELEMENT BY THE RATIO'/)
10320 format(//131('-')//t10,'DATA BLOCK APERTURE LIMITATIONS'/ /t10,   &
     &'TYP',t20,'FORM',t30,'APERT-H',t40,'APERT-V')
10340 format(t10,'NO CAVITIES SPECIFIED'/)
10350 format(//131('-')//t10,'DATA BLOCK ORGANISATION OF RANDOM NUMBERS'&
     &/5x,'|          |      OWN RANDOM NUMBERS      |      SAME RAN' , &
     &'DOM NUMBERS      |   SAME MULTIPOLECOEFFICIENTS  |'/131('-'))
10370 format(t10,'DESIRED TUNE TO ADJUST IS ZERO'/ t10,                 &
     &'DATA BLOCK TUNE ADJUSTMENT  IGNORED')
10380 format(t10,'HIGHER MULTIPOLES THAN 20-POLES ARE NOT ALLOWED' ,    &
     &' AND THEREFORE IGNORED')
10410 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
!10420 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
!     &'OO   NORMAL FORMS   OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10430 format(/5x,'No cut on random distribution'//)
10440 format(/5x,'Random distribution has been cut to: ',i4,' sigma.'//)
10460 format(//131('-')//t10,'DATA BLOCK ',a4,' INFOs'/ /t10,           &
     &'ELEMENT NAME',8x,'EVERY # TURNs',2x,
     &'LOGICAL UNIT',2x,'FILENAME',24x,'FORMAT',5x,
     &"FirstTurn",6x,"LastTurn") !DUMP/STAT/BMAT
10070 format(1x,i3,1x,a16,1x,i3,1x,d16.10,1x,d16.10,1x,d16.10,1x,d13.7, &
     &1x,d12.6,1x,d13.7,1x,d12.6)
10210 format(t10,'DATA BLOCK MULTIPOLE COEFFICIENTS'/ t10,              &
     &'MULTIPOLE                    ',a16/t10,'RADIUS IN MM            '&
     &,f15.7/ t10,'BENDING STRENGTH IN MRAD',f15.7// t10,19x,'NORMAL',25&
     &x,'      SKEW '// t10,'      MEAN            RMS-VALUE     ',     &
     &'       MEAN            RMS-VALUE'/)
!10240 format(t10,a16,3(2x,d16.10),2x,i10)
10260 format(t4,i4,1x,a16,1x,i2,1x,6(1x,a16))
10270 format(t28,6(1x,a16))
10280 format(t3,i6,1x,5(a16,1x))
10310 format(t10,a16,10x,a16,6x,f20.15)
10330 format(t8,a16,t18,a2,t30,f8.2,t40,f8.2)
10360 format(5x,'| ELEMENT  |           ',a16,'           |           ',&
     &'    |               |               |               |')
10390 format(5x,'| ELEMENTS |                              |    ',a16,  &
     &'   |    ',a16,'   |               |               |')
10400 format(5x,'| ELEMENTS |                              |          ' &
     &,'     |               |    ',a16,'   |    ',a16,'   |')
10470 format(t10,a16,4x,i13,2x,i12,2x,a32,i6,2x,i12,2x,i12) !BMAT/STAT/DUMP
10472 format(t10,a)                           !BMAT/STAT/DUMP
10700 format(t10,'DATA BLOCK TROMBONE ELEMENT'/                         &
     &t10,'TROMBONE #      NAME'/)
10710 format(t22,i4,5x,a16)
      end
      
      subroutine write4
!-----------------------------------------------------------------------
!     WRITE MODIFIED GEOMETRY FILE ON UNIT 4
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ii,ikz
      double precision rdum1,rdum2,rel1
      character*160  ch
      character*320 ch1
      character*16 idat
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/ 
+ca parpro
+ca parnum
+ca common
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ii=0
      rewind 2
 1    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
        goto 1
      elseif(ch(:4).eq.'SING') then
        write(4,*) ch
      else
        return
      endif
 2    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
      else
        ii=ii+1
        if(ch(:4).ne.'NEXT') then
          call intepr(1,1,ch,ch1)
+if fio
          read(ch1,*,round='nearest')                                   &
     & idat,ikz,rdum1,rdum2,rel1
+ei
+if .not.fio
          read(ch1,*) idat,ikz,rdum1,rdum2,rel1
+ei
          if(ikz.eq.11) then
            write(4,10000) idat,ikz,rdum1,rdum2,rel1
          else
            if(abs(rel1).le.pieni) then
              if(ncororb(ii).eq.0) then
                write(4,10000) idat,ikz,sm(ii),rdum2,rel1
              else
                write(4,10000) idat,ikz,sm(ii),ek(ii),rel1
              endif
            else
              write(4,10000) idat,ikz,rdum1,ek(ii),rel1
            endif
          endif
        else
          write(4,*) ch
          goto 3
        endif
      endif
      goto 2
 3    read(2,*,end=90) ch
      lineno2=lineno2+1
      write(4,*) ch
      goto 3
 90   continue
10000 format(a16,1x,i2,1x,d21.15,1x,d21.15,1x,d16.10)
      end
      subroutine intepr(i,j,ch,ch1)
!-----------------------------------------------------------------------
!     SUBROUTINE TO INTEPRET INPUT WITH CHARACTERS AND NUMBERS MIXED
!
!     I ... TYPE OF COMBINATION
!
!         1  LINE WITH 1 CHARACTERSTRING FOLLOWED BY NUMBERS
!         2  LINE WITH CHARACTERSTRINGS, IF THE FIRST 5 CHARACTERS
!            ARE BLANKS THIS IS INTERPRETED AS A BLANK CHARACTER
!         3  LINE WITH CHARACTERSTRINGS
!         4  LINE WITH 2 CHARACTERSTRINGS
!         5  LINE WITH 1 CHARACTERSTRING AND N*(NUMBER,CHA.STRING)
!         6  LINE WITH 1 NUMBER AND 2 CHARACTERSTRINGS
!         7  LINE WITH 1 NUMBER, 2 CHARACTERSTRINGS AND NUMBERS
!         8  LINE WITH 2 CHARACTERSTRINGS AND NUMBERS
!
!     J ... SKIP THE FIRST (J-1) CHARACTERS OF CHARACTERSTRING CH
!    CH ... INPUT CHARACTERSTRING
!   CH1 ... OUTPUT CHARACTERSTRING
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
!ERIC
      integer i,i0,i1,i2,i3,i4,iev,ii,j
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      save
!-----------------------------------------------------------------------
+if bnlelens
!GRDRHIC
!GRD-042008
      ch1=""
!GRDRHIC
!GRD-042008
+ei
      i0=0
      i1=j
      i2=1
      i4=0
      do 10 ii=j,nchars
        if(i0.eq.0.and.ch(ii:ii).eq.' ') then
          if(i.eq.2.and.ii.eq.5.and.ch(:5).eq.'     ') then
            ch1(:4)=''' '' '
            i2=5
          endif
          i1=ii+1
          goto 10
        endif
        i0=1
        if(ch(ii:ii).eq.' ') then
          i4=i4+1
          iev=1
          if(mod(i4,2).eq.0) iev=0
          if(i.eq.1) goto 20
          if(i.eq.2.or.i.eq.3.or.i.eq.4.or. (i.eq.5.and.iev.eq.1.).or.  &
     &(i.eq.6.and.i4.ge.2).or. (i.eq.7.and.(i4.eq.2.or.i4.eq.3)).or.    &
     &(i.eq.8.and.i4.lt.3)) then
            i3=((i2+ii)-i1)+2                                            !hr05
            ch1(i2:i3)=''''//ch(i1:ii-1)//''' '
            if(i.eq.4.and.i4.eq.2) goto 30
            i2=i3+1
          endif
          if((i.eq.5.and.iev.eq.0).or. (i4.eq.1.and.(i.eq.6.or.i.eq.7)))&
     &then
            i3=(i2+ii)-i1                                                !hr05
            ch1(i2:i3)=ch(i1:ii)
            i2=i3+1
          endif
          if((i.eq.7.and.i4.gt.3).or.(i.eq.8.and.i4.eq.3)) goto 40
          i0=0
          i1=ii+1
        endif
   10 continue
      goto 30
   20 ch1(1:nchars+nchars)=''''//ch(i1:ii-1)//''''//ch(ii:nchars)//' / '
      return
   30 i3=i3+1
      ch1(i3:i3+2)=' / '
      return
   40 i3=i2+nchars+3-i1
      ch1(i2:i3)=ch(i1:nchars)//' / '
      return
      end
      
      subroutine initialize_element(ix,lfirst)
!
!-----------------------------------------------------------------------
!     K.Sjobak & A.Santamaria, BE-ABP/HSS
!     last modified: 23-12-2016
!     Initialize a lattice element with index elIdx,
!     such as done when reading fort.2 (GEOM) and in DYNK.
!     
!     Never delete an element from the lattice, even if it is not making a kick.
!     If the element is not recognized, do nothing (for now).
!     If trying to initialize an element (not lfirst) which is disabled,
!     print an error and exit.
!-----------------------------------------------------------------------
!
      implicit none
      
      integer, intent(in) :: ix
      logical, intent(in) :: lfirst

      integer im, izu, k, m, nmz, r0, r0a !needed to use multini

+ca parpro !needed for common
+ca parnum !zero
+ca common
+ca commonmn
+ca commontr
+ca commonxz
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca wireparam
+ca crcoall

      !Temp variables
      integer i

!--Nonlinear Elements
! TODO: Merge these cases into 1 + subcases?
      if(abs(kz(ix)).eq.1) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)             ! Also done in envar() which is called from clorb()
                 smiv(1,i)=sm(ix)+smizf(i) ! Also done in program maincr
                 smi(i)=smiv(1,i)          ! Also done in program maincr
+ca stra01                                 ! Also done in trauthin()/trauthck()
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.2) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra02
               endif
            enddo
         endif
      elseif(abs(kz(ix)).eq.3) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra03
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.4) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra04
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.5) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra05
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.6) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra06
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.7) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra07
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.8) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra08
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.9) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra09
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.10) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra10
               endif
            enddo
         endif

!--Multipoles
      elseif(kz(ix).eq.11) then
         
         !MULT support removed until we have a proper use case.
c$$$         if (lfirst) then
c$$$            dynk_elemdata(ix,1) = el(ix) !Flag for type
c$$$            dynk_elemdata(ix,2) = ed(ix) !Bending strenght
c$$$            dynk_elemdata(ix,3) = ek(ix) !Radius
c$$$         else
c$$$            el(ix) = dynk_elemdata(ix,1)
c$$$            dynk_elemdata(ii,2) = ed(ii) !Updated in dynk_setvalue
c$$$            ek(ii) = dynk_elemdata(ix,3)
c$$$         end if
         
         ! Moved from daten():
         if (abs(el(ix)+one).le.pieni) then
            dki(ix,1) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         else if(abs(el(ix)+two).le.pieni) then
            dki(ix,2) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         endif
         !Otherwise, i.e. when el=0, dki(:,1) = dki(:,2) = dki(:,3) = 0.0

         !MULT support removed until we have a proper use case.
c$$$         !All multipoles:
c$$$         if(.not.lfirst) then
c$$$            do i=1,iu
c$$$               if ( ic(i)-nblo.eq.ix ) then
c$$$                  if(ktrack(i).eq.31) goto 100 !ERROR
c$$$                  !--Initialize smiv as usual
c$$$                  sm(ix)=ed(ix)
c$$$                  smiv(m,i)=sm(ix)+smizf(i)
c$$$                  smi(i)=smiv(m,i)
c$$$
c$$$                  !--Using the right izu & setting aaiv, bbiv (see multini)
c$$$                  izu = dynk_izuIndex(ix)
c$$$+ca multini !Also in program maincr()
c$$$ 150              continue ! needs to be after a multini block
c$$$
c$$$                  ! From trauthin()&trauthck() (they are identical)
c$$$                  r0=ek(ix)
c$$$                  nmz=nmu(ix)
c$$$                  if(abs(r0).le.pieni.or.nmz.eq.0) then
c$$$                     if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                    abs(dki(ix,2)).le.pieni) then
c$$$C                       ktrack(i)=31
c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
c$$$     &                       abs(dki(ix,2)).le.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                          ktrack(i)=33
c$$$+ca stra11
c$$$                        else
c$$$C                          ktrack(i)=35
c$$$+ca stra12
c$$$                        endif
c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                       abs(dki(ix,2)).gt.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=37
c$$$+ca stra13
c$$$                        else
c$$$C                            ktrack(i)=39
c$$$+ca stra14
c$$$                        endif
c$$$                     endif
c$$$                  else
c$$$                     if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                    abs(dki(ix,2)).le.pieni) then
c$$$C                        ktrack(i)=32
c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
c$$$     &                       abs(dki(ix,2)).le.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=34
c$$$+ca stra11
c$$$                        else
c$$$C                           ktrack(i)=36
c$$$+ca stra12
c$$$                        endif
c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
c$$$     &                       abs(dki(ix,2)).gt.pieni) then
c$$$                        if(abs(dki(ix,3)).gt.pieni) then
c$$$C                           ktrack(i)=38
c$$$+ca stra13
c$$$                        else
c$$$C                           ktrack(i)=40
c$$$+ca stra14
c$$$                        endif
c$$$                     endif
c$$$                  endif
c$$$               endif
c$$$            enddo
c$$$         endif

!--Cavities (ktrack = 2 for thin)
      elseif(abs(kz(ix)).eq.12) then
         !Moved from daten
         phasc(ix) = el(ix)
         el(ix) = zero
         dynk_elemdata(ix,3) = phasc(ix)
         if (.not.lfirst) then

            ! Doesn't work, as i is not initialized here.
            !if (.not.ktrack(i).eq.2) goto 100 !ERROR
            
            phasc(ix) = phasc(ix)*rad
            
            hsyc(ix) = ((two*pi)*ek(ix))/tlen         ! daten SYNC block
            hsyc(ix)=(c1m3*hsyc(ix))*dble(itionc(ix)) ! trauthin/trauthck
         endif
!--BEAM-BEAM
      elseif(kz(ix).eq.20) then
         if (lfirst) then
            ! Only for old-style BEAM-BEAM lenses
            ! if DYNK-ified, there needs to be checks for parbeam_exp as well,
            ! as in this case modifying ed/ek/el and then calling initialize_element
            ! would be neccessary...
            ! Note that the BEAM::EXPERT block input checker relies on the data from
            ! ed/ek/el has been moved to parbe/ptnfac.
            ! For DYNKification of BEAM, I think lots of the code from
            ! trauthin/trauthck needs to be copied here?
            ptnfac(ix)=el(ix)
            el(ix)=zero

            parbe(ix,5) = ed(ix)
            ed(ix)=zero
            parbe(ix,6) = ek(ix)
            ek(ix)=zero
         endif
!--Crab Cavities
!   Note: If setting something else than el(),
!   DON'T call initialize_element on a crab, it will reset the phase to 0.
      elseif(abs(kz(ix)).eq.23) then
         !Moved from daten()
         crabph(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 2
      elseif(abs(kz(ix)).eq.26) then
         !Moved from daten()
         crabph2(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 3
      elseif(abs(kz(ix)).eq.27) then
         !Moved from daten()
         crabph3(ix)=el(ix)
         el(ix)=0d0
!--CC Mult kick order 4
      else if(abs(kz(ix)).eq.28) then
         !Moved from daten()
         crabph4(ix)=el(ix)
         el(ix)=0d0
!--Wire
      else if(kz(ix).eq.15) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
!--e-lens
      else if(kz(ix).eq.29) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
      endif

      return

      !Error handlers
 100  continue
      write (lout,*) "ERROR in initialize_element, tried to set"
      write (lout,*) "the strength of an element which is disabled."
      write (lout,*) "bez = ", bez(ix)
      call prror(-1)

      end subroutine

+if crlibm
      
      subroutine splitfld(errno,nunit,lineno,nfields,nf,chars,fields)
      implicit none
+ca crcoall
      integer errno,nunit,lineno,nfields,nf,i,j,k,l,lf
      character*(*) chars
      character*(*) fields(*)
      character*999 localstr
!     This routine splits the chars input into space separated
!     fields, up to nfields maximum. It returns the no of
!     fields in nf. All spaces are ignored but treated as separators.
!     A / is a line terminator as provided in ch1 typically.
!     This corresponds to Fortran treatment with an * format spec.
            
      j=0
      nf=0
      do i=1,nfields
        fields(i)=' '
         
        ! Get the length we can use to store a field,
        ! should be equal to maxf in the calling function
        lf=len(fields(i))

 8889   k=0   !Index into the current field; goto label for new field or no field yet
 8888   j=j+1 !Index into the input array; goto label for reading another character
        ! Check that we stay within the given length of chars
        if (j.gt.len(chars)) then
          errno=1
          go to 8887
        endif

        !Don't start a new field before we hit a non-space
        if (k.eq.0.and.chars(j:j).eq.' ') go to 8888

        if (chars(j:j).ne.' '.and.chars(j:j).ne.'/') then
          !We have a field
          k=k+1
          if (k.ge.lf) then
            !Field is too long;
            ! remember that the last position (#lf in FORTRAN, lf-1 in C)
            ! is reseved for a \0, to be used in the C code.
            do j=1,nf
              l=len(fields(j))
              localstr=fields(j)(1:l)
              write(lout,*) 'splitfld:'//localstr(1:lf)//':'
            enddo
            errno=2
            call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
          endif
          fields(i)(k:k)=chars(j:j)
          go to 8888
        else
          if (chars(j:j).eq.'/') then
! we are all through but may have a field
            if (k.ne.0) nf=nf+1
! Eric for debug
!     do j=1,nf
!       l=len(fields(j)
!       localstr=fields(j)(1:l)
!       write(*,*) 'splitfld:'//localstr)//':'
!     enddo
            return
          else
! Must have a space, field separator
            nf=nf+1
          endif
        endif
      enddo
      
 8890 continue
! If we get here we have a problem unless there
! is nothing left but ' '*/
 8886 j=j+1
      if (j.gt.len(chars)) go to 8887
      if (chars(j:j).eq.'/') return
      if (chars(j:j).eq.' ') go to 8886
      errno=3
 8887 continue
! Eric for debug
      do j=1,nf
        l=len(fields(j)) 
        localstr=fields(j)(1:l)
        write(lout,*) 'splitfld:'//localstr//':'
      enddo
      call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      end
      
      double precision function fround(errno,fields,f)
      implicit none
      integer maxf
      ! MAXF be kept in sync with maxf in various routines
      ! We maybe should use len(field(f)) here, like is done in splitfld...
      parameter (maxf=30)
      integer errno,f
      character*(*) fields(*)
      double precision round_near,value
      fround=round_near(errno,maxf,fields(f))
      if (errno.ne.0) then
        value=fround
        call rounderr(errno,fields,f,value)
      endif
      return
      end
      
      subroutine rounderr(errno,fields,f,value)
      implicit none
+ca crcoall
      integer nchars,nofields
      integer errno,nfields,f,l
      character*(*) fields(*)
      character*999 localstr
      double precision value

      write (lout,10000)
      write (lout,*) 'Data Input Error (probably in subroutine daten)'
      write (lout,*) 'Overfow/Underflow in strtod()'
      write (lout,*) 'Errno: ',errno
      l=len(fields(f))
      localstr=fields(f)(1:l)
      write (lout,*) 'f:fieldf:',f,':'//localstr
      write (lout,*) 'Function fround (rounderr) returning:',value
      
      call abend('Treating this as FATAL!!!                         ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
      return
      end
      
      subroutine spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      implicit none
+ca crcoall
      integer errno,nunit,lineno,nfields,nf,lf,l
      character* (*) chars
      character*999 localstr
      write (lout,10000)
      write (lout,*) 'Data Input Error (probably in subroutine daten)'
      write (lout,*) 'Reading unit no (fort.)',nunit,' Line',lineno
      l=len(chars)
      localstr=chars(1:l)
      write (lout,*) 'Input line:'//localstr//':'
      if (errno.eq.1) then
        write (lout,*)                                                     &
     &  'Input string too long, exceeds',len(chars),' characters'
      endif
      if (errno.eq.2) then
        write (lout,*)                                                     &
     &  'Field too long, exceeds',lf,' characters'
      endif
      if (errno.eq.3) then
        write (lout,*)                                                     &
     &  'Too many input fields, maximum of',nfields,' exceeded'
      endif
      
      call abend('Treating this error as FATAL!!!                   ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      end
      
      integer function dtostr(x,results)
! Uses the dtoa_c.c version of dtoa via the dtoaf.c interface in
! crlibm
      implicit none
+ca crcoall
      double precision x
      character*(24) results
      integer dtoaf 
      integer ilen,mode,ndigits,decpoint,mysign
      integer i,l,d,e
      character*1 str(17)
      character*24 lstr
      character*3 e3
      
      mode=2
      ndigits=17
      ilen=dtoaf(x,mode,ndigits,decpoint,mysign,str(1),1)
      if (ilen.le.0.or.ilen.gt.17) then
! Always returns 17 or less characters as requested
      write (lout,10000)
      write (lout,*) 'Routine dtoa[f] returned string length ',ilen
      call abend('Error from dtostr, string length not 17           ')
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      endif
      lstr=' '
      do i=1,ilen
        lstr(i:i)=str(i)
      enddo
! Now try my formatting
      d=decpoint
      e=0
      l=1
      lstr=' '
      if (mysign.ne.0) then
        lstr(l:l)='-'
      endif
      if (decpoint.eq.9999) then
! Infinity or Nan
        do i=1,ilen
          lstr(l+i:l+i)=str(i)
        enddo
      else
! Pad with zeros
        do i=ilen+1,17
          str(i)='0'
        enddo
        if (decpoint.le.0) then
          e=decpoint-1
          d=1
        else
! I am using 17 as decision point to avoid dddd.e+eee
! but rather d.ddde+eee
          if (decpoint.ge.17) then
            e=decpoint-1
            d=1
          else
            d=decpoint
          endif
        endif
! and copy with the decimal point
        do i=1,17
          lstr(l+i:l+i)=str(i)
          if (i.eq.d) then
            l=l+1
            lstr(l+i:l+i)='.'
          endif
        enddo
! and add exponent e+/-nnn
        l=20
        lstr(l:l)='e'
        l=21
        lstr(l:l)='+'
        if (e.lt.0) then
          lstr(l:l)='-'
          e=-e
        endif
        l=22
        write (e3,'(I3.3)') e
        lstr(l:l+2)=e3(1:3)
      endif  
      results=lstr(1:24)
      dtostr=24
      return
      end
      
      double precision function acos_rn(x)
      implicit none
      double precision atan_rn,x,pi,pi2
      logical myisnan
      data pi  /3.1415926535897932d0/
      data pi2 /1.5707963267948966d0/
      if (myisnan(x,x)) then
        acos_rn=x
      elseif (abs(x).eq.0.0d0) then
        acos_rn=pi2
      else
!       acos_rn=atan_rn(sqrt(1.0d0-x*x)/x)
! Try using (1-x)*(1+x) in case x is very small.........
! or close to 1.....write a test program!!!
         acos_rn=atan_rn(sqrt((1.0d0-x)*(1.0d0+x))/x)
        if (x.lt.0.0d0) then
          acos_rn=pi+acos_rn
        endif
      endif
      end
      
      double precision function asin_rn(x)
      implicit none
      double precision atan_rn,x,pi2
      logical myisnan
      data pi2 /1.5707963267948966d0/
      if (myisnan(x,x)) then
        asin_rn=x
        return
      endif
      if (abs(x).eq.1.0d0) then
        asin_rn=sign(pi2,x)
      else 
!       asin_rn=atan_rn(x/sqrt(1.0d0-x*x))
! Try using (1-x)*(1+x) in case x is very small.........
! or close to 1.....write a test program!!!
        asin_rn=atan_rn(x/sqrt((1.0d0-x)*(1.0d0+x)))
      endif
      end
      
      double precision function atan2_rn(y,x)
      implicit none
      double precision atan_rn,x,y,pi,pi2
      logical myisnan
      data pi  /3.1415926535897932d0/
      data pi2 /1.5707963267948966d0/
      if (x.eq.0d0) then
         if (y.eq.0d0) then
C Should get me a NaN 
           atan2_rn=atan_rn(y/x)
         else
           atan2_rn=sign(pi2,y)
         endif
      else
        if (y.eq.0d0) then
          if (x.gt.0d0) then
            atan2_rn=0d0
          else
            atan2_rn=pi
          endif
        else          
          atan2_rn=atan_rn(y/x)
          if (x.lt.0d0) then
            atan2_rn=sign(pi,y)+atan2_rn
          endif
        endif
      endif
      end
+ei ! END of crlibm-specific functions
      
      subroutine wzset
!  *********************************************************************
!
!  This subroutine must be called before subroutine WZSUB can be used to
!  compute values of the complex error function w(z).
!
!  Parameters xcut and ycut specify the opposite corners (xcut,0) and
!  (0,ycut) of the rectangle inside which interpolation is to be used
!  by subroutine WZSUB.
!
!  Parameter h is the side of the squares of the interpolation grid.
!
!  Parameters nx and ny must be set to the nearest integers to xcut/h
!  and ycut/h respectively (or to larger values).
!
!  Calls MYWWERF new version of (CERN library) WWERF (C335)
!
!  (G.A.Erskine, 29.09.1995)
!
!  *********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,j,k
      double precision wi,wr,x,y
+ca parpro
+ca parbeam
      save
!-----------------------------------------------------------------------
      hrecip = 1.d0/h
      kstep = nx+2
      k = 0
      do 2 j=0,ny+1
         do 1 i=0,nx+1
            k = k+1
            x=dble(i)*h                                                  !hr05
            y=dble(j)*h                                                  !hr05
            call mywwerf(x,y,wr,wi)
            wtreal(k)=wr
            wtimag(k)=wi
 1       continue
 2    continue
      end
      subroutine mywwerf(x,y,wr,wi)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer n
      double precision c,c1,c2,c3,c4,hf,p,rr,ri,sr0,sr,si,tr,ti,vi,vr,  &
     &wi,wr,x,xa,xl,y,ya,zhi,zhr,z1,z10
      parameter (z1=1,hf=z1/2d0,z10=10d0)
      parameter (c1=74d0/z10,c2=83d0/z10,c3=z10/32d0,c4=16d0/z10)
!     parameter (c=1.12837916709551257d0,p=(2d0*c4)**33)
      parameter (c=1.12837916709551257d0,p=46768052394588893.3825d0)
      dimension rr(37),ri(37)
      save
!-----------------------------------------------------------------------
      xa=abs(x)
      ya=abs(y)
      if(ya.lt.c1.and.xa.lt.c2) then
!        zh=dcmplx(ya+c4,xa)
        zhr=ya+c4
        zhi=xa
        rr(37)=0d0
        ri(37)=0d0
        do n=36,1,-1
!          t=zh+n*dconjg(r(n+1))
          tr=zhr+dble(n)*rr(n+1)                                         !hr05
          ti=zhi-dble(n)*ri(n+1)                                         !hr05
!          r(n)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(n)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(n)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
        xl=p
        sr=0d0
        si=0d0
        do n=33,1,-1
          xl=c3*xl
!          s=r(n)*(s+xl)
          sr0=rr(n)*(sr+xl)-ri(n)*si
          si=rr(n)*si+ri(n)*(sr+xl)
          sr=sr0
        enddo
!        v=c*s
        vr=c*sr
        vi=c*si
      else
        zhr=ya
        zhi=xa
        rr(1)=0d0
        ri(1)=0d0
        do n=9,1,-1
!          t=zh+n*dconjg(r(1))
          tr=zhr+dble(n)*rr(1)                                           !hr05
          ti=zhi-dble(n)*ri(1)                                           !hr05
!          r(1)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(1)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(1)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
!        v=c*r(1)
        vr=c*rr(1)
        vi=c*ri(1)
      endif
      if(ya.eq.0d0) then                                                 !hr05
!        v=dcmplx(exp(-xa**2),dimag(v))
+if crlibm
        vr=exp_rn(-1d0*xa**2)                                            !hr05
+ei
+if .not.crlibm
        vr=exp(-1d0*xa**2)                                               !hr05
+ei
      endif
      if(y.lt.0d0) then
!        v=2*exp(-dcmplx(xa,ya)**2)-v
+if crlibm
        vr=(2d0*exp_rn(ya**2-xa**2))*cos_rn((2d0*xa)*ya)-vr              !hr05
+ei
+if .not.crlibm
        vr=(2d0*exp(ya**2-xa**2))*cos((2d0*xa)*ya)-vr                    !hr05
+ei
+if crlibm
        vi=(-2d0*exp_rn(ya**2-xa**2))*sin_rn((2d0*xa)*ya)-vi             !hr05
+ei
+if .not.crlibm
        vi=(-2d0*exp(ya**2-xa**2))*sin((2d0*xa)*ya)-vi                   !hr05
+ei
        if(x.gt.0d0) vi=-1d0*vi                                          !hr05
      else
        if(x.lt.0d0) vi=-1d0*vi                                          !hr05
      endif
      wr=vr
      wi=vi
      return
      end
+dk stringhandling
      subroutine getfields_split( tmpline, getfields_fields,
     &         getfields_lfields, getfields_nfields, getfields_lerr)
!
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak and A.Santamaria, BE-ABP-HSS
!     last modified: 24-02-2015
!     parse a line and split it into its fields
!       fields are returned as 0-terminated and padded string
!     always in main code
! input:
!  tmpline: usually line read in from fort.2 or fort.3. Values must be 
!           separated by spaces
! output:
!  array of values with 
!   getfields_fields(i):  (char) value of field
!   getfields_lfields(i): (int) length of field
!   getfields_nfields:    (int) number of fields
!   getfields_lerr:       (logical)
!-----------------------------------------------------------------------
!
      implicit none
+ca comgetfields
+ca crcoall
      
      character tmpline*(getfields_l_max_string-1) !nchars in daten is 160

      intent(in) tmpline
      intent(out) getfields_fields, getfields_lfields,
     &     getfields_nfields, getfields_lerr
      
*     runtime variables
      integer ii, jj
      logical lchar
      integer lenstr, istart

*     initialise output variables
      getfields_lerr = .false.
      getfields_nfields=0
      do ii=1,getfields_n_max_fields
         do jj=1,getfields_l_max_string
            getfields_fields(ii)(jj:jj) = char(0) ! ZERO terminate/pad
         enddo
         getfields_lfields(ii)=0
      enddo

*     parse the line
      lchar = .false.
      do ii=1, getfields_l_max_string-1 !For \0 termination
         if ( tmpline(ii:ii) .eq. ' ' ) then
*           blank char
            if ( lchar ) then
*              end of a string: record it
               getfields_lfields(getfields_nfields)          = lenstr
               getfields_fields (getfields_nfields)
     &              (1:getfields_lfields(getfields_nfields)) =
     &              tmpline(istart:
     &               istart+getfields_lfields(getfields_nfields))
               lchar = .false.
            endif
         else
*           non-blank char
            if ( .not. lchar ) then
*              a new what starts
               getfields_nfields = getfields_nfields +1
               if ( getfields_nfields.gt.getfields_n_max_fields ) then
                  write (lout,*)'error! too many fields in line:'
                  write (lout,*) tmpline
                  write (lout,*)'please increase getfields_n_max_fields'
                  getfields_lerr = .true.
                  exit !Break do
               endif
               istart = ii
               lchar = .true.
               lenstr = 0
            endif
            lenstr = lenstr+1
         endif
      enddo

      end subroutine

      function stringzerotrim(instring)
!----------------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 30-10-2014
!     Replace "\0" with ' ' in strings.
!     Usefull before output, else "write (*,*)" will actually write all the \0s
!
!     Warning: Do not add any write(*,*) inside this function:
!     if this function is called by a write(*,*) and then does a write,
!     the program may deadlock!
!----------------------------------------------------------------------------
      implicit none
+ca stringzerotrim
      character(stringzerotrim_maxlen) instring
      intent(in) instring
      
      integer ii
      
      do ii=1,stringzerotrim_maxlen
         if ( instring(ii:ii) .ne. char(0) ) then
            stringzerotrim(ii:ii) = instring(ii:ii)
         else 
            stringzerotrim(ii:ii) = ' '
         end if
      end do
      stringzerotrim = trim(stringzerotrim)

      end function


+dk ranecu
      subroutine ranecu(rvec,len,mcut)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,is1,is2,iseed1,iseed2,iz,j,k,len,mcut
      double precision rvec0,rvec,pi,r
+ca parnum
      dimension rvec(*),r(2)
      data iseed1,iseed2 / 12345, 67890 /
      save
!-----------------------------------------------------------------------
+if crlibm
      pi = four*atan_rn(one)
+ei
+if .not.crlibm
      pi = four*atan(one)
+ei
!     DO 100 I = 1,LEN
      i=1
   10 do 20 j = 1,2
        k = iseed1/53668
        iseed1 = 40014*(iseed1-k*53668) - k*12211
        if (iseed1.lt.0) iseed1 = iseed1+2147483563
        k = iseed2/52774
        iseed2 = 40692*(iseed2-k*52774) - k*3791
        if (iseed2.lt.0) iseed2 = iseed2+2147483399
        iz = iseed1-iseed2
        if (iz.lt.1) iz = iz+2147483562
        r(j) = dble(iz)*4.656613d-10                                     !hr05
   20 continue

      if (mcut.ge.0) then !mcut = -1 => Generate uniform numbers!
!     Convert r(1), r(2) from U(0,1) -> rvec0 as Gaussian with cutoff mcut (#sigmas):
+if crlibm
         rvec0 = sqrt(((-1d0*two)*log_rn(r(1))))*cos_rn((two*pi)*r(2))      !hr05
+ei
+if .not.crlibm
         rvec0 = (sqrt((-1d0*two)*log(r(1))))*cos((two*pi)*r(2))            !hr05
+ei
      else if (mcut.eq.-1) then
         rvec0 = r(1)
      end if
      
      if(abs(rvec0).le.dble(mcut) .or. mcut.eq.0 .or. mcut.eq.-1) then
        rvec(i) = rvec0
        i=i+1
      endif
      if(i.le.len) goto 10
!     RVEC(I) = ((-TWO*LOG(R(1)))**HALF)*COS(TWO*PI*R(2))
! 100 CONTINUE
      return
      entry recuin(is1,is2)
      iseed1 = is1
      iseed2 = is2
      return
      entry recuut(is1,is2)
      is1 = iseed1
      is2 = iseed2
      return
      end
+dk envars
      subroutine envars(j,dpp,rv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!-----------------------------------------------------------------------
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ih,j,kz1,l,ll
      double precision aek,afok,as3,as4,as6,co,dpd,dpp,dpsq,fi,fok,fok1,&
     &fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoc,rhoi,rv,si,siq,sm1,         &
     &sm12,sm2,sm23,sm3,sm5,sm6,wf,wfa,wfhi
+if .not.vvector
      integer jm,k,m,na,ne
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 190 i=1,il
        do ll=1,6
          do l=1,2
            al(ll,l,j,i)=zero
            as(ll,l,j,i)=zero
+if .not.vvector
            at(ll,l,j,i)=zero
            a2(ll,l,j,i)=zero
+ei
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 190
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          al(1,l,j,i)=one
          al(2,l,j,i)=el(i)
          al(3,l,j,i)=zero
          al(4,l,j,i)=one
   20   as(6,l,j,i)=((-1d0*rv)*al(2,l,j,i))/c2e3                         !hr05
        as(1,1,j,i)=(el(i)*(one-rv))*c1e3                                !hr05
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        fok1=(tan_rn(fok*half))/rho
+ei
+if .not.crlibm
        fok1=(tan(fok*half))/rho
+ei
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        al(1,ih,j,i)=one
        al(2,ih,j,i)=rho*si
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
        al(5,ih,j,i)=((-1d0*dpp)*((rho*(one-co))/dpsq))*c1e3             !hr05
+if crlibm
        al(6,ih,j,i)=((-1d0*dpp)*((two*tan_rn(fok*half))/dpsq))*c1e3     !hr05
+ei
+if .not.crlibm
        al(6,ih,j,i)=((-1d0*dpp)*((two*tan(fok*half))/dpsq))*c1e3        !hr05
+ei
+if crlibm
        sm1=cos_rn(fok)
+ei
+if .not.crlibm
        sm1=cos(fok)
+ei
+if crlibm
        sm2=sin_rn(fok)*rho
+ei
+if .not.crlibm
        sm2=sin(fok)*rho
+ei
+if crlibm
        sm3=(-1d0*sin_rn(fok))/rho                                       !hr05
+ei
+if .not.crlibm
        sm3=(-1d0*sin(fok))/rho                                          !hr05
+ei
        sm5=((-1d0*rho)*dpsq)*(one-sm1)                                  !hr05
        sm6=((-1d0*sm2)*dpsq)/rho                                        !hr05
        sm12=el(i)-sm1*sm2
        sm23=sm2*sm3
        as3=(-1d0*rv)*(((dpp*rho)/(two*dpsq))*sm23+sm5)                  !hr05
        as4=((-1d0*rv)*sm23)/c2e3                                        !hr05
        as6=((-1d0*rv)*(el(i)+sm1*sm2))/c4e3                             !hr05
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12+      &!hr05
     &dpp*(el(i)-sm2)))*c1e3                                             !hr05
        as(2,ih,j,i)=fok1*as3-rv*((dpp/((two*rho)*dpsq))*sm12+sm6)       !hr05
        as(3,ih,j,i)=as3
        as(4,ih,j,i)=as4+(two*as6)*fok1                                  !hr05
        as(5,ih,j,i)=(as6*fok1*2+fok1*as4)-(rv*sm12)/(c4e3*rho**2)       !hr05
        as(6,ih,j,i)=as6
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
+if crlibm
        g=tan_rn(fok*half)/rho
+ei
+if .not.crlibm
        g=tan(fok*half)/rho
+ei
        gl=el(i)*g
        al(1,ih,j,i)=one-gl
        al(2,ih,j,i)=el(i)
        al(3,ih,j,i)=(-1d0*g)*(two-gl)                                   !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
        as6=((-1d0*rv)*al(2,ih,j,i))/c2e3                                !hr05
        as(4,ih,j,i)=((-1d0*two)*as6)*fok1                               !hr05
        as(5,ih,j,i)=as6*fok1**2                                         !hr05
        as(6,ih,j,i)=as6
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        rhoc=(rho*(one-co))/dpsq                                         !hr05
        siq=si/dpsq
        al(1,ih,j,i)=co
        al(2,ih,j,i)=rho*si
        al(3,ih,j,i)=(-1d0*si)/rho                                       !hr05
        al(4,ih,j,i)=co
        al(5,ih,j,i)=((-1d0*dpp)*rhoc)*c1e3                              !hr05
        al(6,ih,j,i)=((-1d0*dpp)*siq)*c1e3                               !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12 +     &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))*c1e3                                    !hr05
        as(2,ih,j,i)=(-1d0*rv)*((dpp/((two*rho)*dpsq))*sm12-dpd*siq)     !hr05
        as(3,ih,j,i)=(-1d0*rv)*(((dpp*rho)/(two*dpsq))*sm23-dpd*rhoc)    !hr05
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=((-1d0*rv)*sm12)/(c4e3*rho**2)                      !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        al(1,ih,j,i)=one
        al(2,ih,j,i)=el(i)
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
        as(6,ih,j,i)=((-1d0*rv)*al(2,ih,j,i))/c2e3                       !hr05
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        aek=abs(fok)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(aek)
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
+if crlibm
        al(1,ih,j,i)=cos_rn(fi)
+ei
+if .not.crlibm
        al(1,ih,j,i)=cos(fi)
+ei
+if crlibm
        hi1=sin_rn(fi)
+ei
+if .not.crlibm
        hi1=sin(fi)
+ei
        al(2,ih,j,i)=hi1/hi
        al(3,ih,j,i)=(-1d0*hi1)*hi                                       !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv))*c1e3                               !hr05
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-1d0*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  110   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.1) goto 100
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
        fok=fokq/(dpd)-wf**2                                             !hr05
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        wfa=((wf/afok)*(one-co))/dpsq                                    !hr05
        wfhi=((wf/hi)*si)/dpsq                                           !hr05
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
        al(3,ih,j,i)=(-1d0*si)*hi                                        !hr05
        al(4,ih,j,i)=co
        al(5,ih,j,i)=((-1d0*wfa)*dpp)*c1e3                               !hr05
        al(6,ih,j,i)=((-1d0*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv)-((rv*((dpp**2/(four*dpd))*sm12+    &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))/afok)*wf**2)*c1e3                       !hr05
        as(2,ih,j,i)=(-1d0*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
        as(3,ih,j,i)=(-1d0*rv)*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-   &!hr05
     &dpd*wfa)                                                           !hr05
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=(((-1d0*rv)*sm12)*afok)/c4e3                        !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=el(i)
        if(abs(hi).le.pieni) goto 150
        al(2,ih,j,i)=hs/hi
  150   al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        wfa=((wf/afok)*(one-hc))/dpsq                                    !hr05
        wfhi=((wf/hi)*hs)/dpsq                                           !hr05
        al(5,ih,j,i)= (wfa*dpp)*c1e3                                     !hr05
        al(6,ih,j,i)=((-1d0*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(((rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-        &!hr05
     &al(2,ih,j,i))))/afok)*wf**2+el(i)*(one-rv))*c1e3                   !hr05
        as(2,ih,j,i)=(-1d0*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
        as(3,ih,j,i)=rv*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-dpd*wfa)   !hr05
        as(4,ih,j,i)=((-1d0*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=((rv*sm12)*afok)/c4e3                               !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
        al(3,ih,j,i)=(-1d0*si)*hi                                        !hr05
        al(4,ih,j,i)=co
        as(4,ih,j,i)=(((-1d0*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-1d0*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
        as(6,ih,j,i)=((-1d0*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
        fokq=-1d0*ek(i)                                                  !hr05
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
+if crlibm
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr05
+ei
+if .not.crlibm
        fok=rhoi*tan((el(i)*rhoi)*half)                                  !hr05
+ei
        al(1,1,j,i)=one
        al(2,1,j,i)=zero
        al(3,1,j,i)=fok
        al(4,1,j,i)=one
        al(1,2,j,i)=one
        al(2,2,j,i)=zero
        al(3,2,j,i)=-1d0*fok                                             !hr05
        al(4,2,j,i)=one
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
+if .not.vvector
      do 220 k=1,mblo
        jm=mel(k)
        do 210 m=1,jm
          na=mtyp(k,m)
          ne=mtyp(k,jm-m+1)
          do 200 l=1,2
            at(1,l,j,na)=as(1,l,j,ne)
            at(2,l,j,na)=as(2,l,j,ne)
            at(3,l,j,na)=as(3,l,j,ne)
            at(4,l,j,na)=as(4,l,j,ne)
            at(5,l,j,na)=as(5,l,j,ne)
            at(6,l,j,na)=as(6,l,j,ne)
            a2(1,l,j,na)=al(1,l,j,ne)
            a2(2,l,j,na)=al(2,l,j,ne)
            a2(3,l,j,na)=al(3,l,j,ne)
            a2(4,l,j,na)=al(4,l,j,ne)
            a2(5,l,j,na)=al(5,l,j,ne)
            a2(6,l,j,na)=al(6,l,j,ne)
  200     continue
  210   continue
  220 continue
+ei
      return
      end
+dk envada
      subroutine envada
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ien,ih,ip,kz1,l,idaa
      double precision dare,result
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commond1
+ca commond2
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
+ca dainicom
*FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
*FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
*FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
*FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
*FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
*FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
*FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
*FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
*FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
*FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
*FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
*FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
*FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
*FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
*FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
*FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
*FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
*FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
*FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
*FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
*FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
*FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
*FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
*FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
*FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
*FOX  D F RE DARE 1 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
*FOX  DPD=ONE+DPDA ;
*FOX  DPSQ=SQRT(DPD) ;
      do 220 i=1,il
        do 10 ih=1,2
          do 10 ip=1,6
*FOX  ALDA(IH,IP)=ZERO ;
*FOX  ASDA(IH,IP)=ZERO ;
   10   continue
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
!       goto(20,40,100,60,80,90,130,170,180),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 100
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 80
        if (kz1.eq.6) goto 90
        if (kz1.eq.7) goto 130
        if (kz1.eq.8) goto 170
        if (kz1.eq.9) goto 180
        goto 220
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 l=1,2
*FOX  ALDA(L,1)=ONE  ;
*FOX  ALDA(L,2)=EL(I) ;
*FOX  ALDA(L,3)=ZERO ;
*FOX  ALDA(L,4)=ONE ;
*FOX  ASDA(L,6)=-RV*ALDA(L,2)/C2E3 ;
   30   continue
*FOX  ASDA(1,1)=EL(I)*(ONE-RV)*C1E3 ;
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   ih=1
   50   continue
        if(abs(ed(i)).le.pieni) goto 20
*FOX  FOK=EL(I)*ED(I)/DPSQ ;
*FOX  RHO=ONE/ED(I)*DPSQ ;
*FOX  FOK1=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
*FOX  SI=SIN(FOK) ;
*FOX  CO=COS(FOK) ;
*FOX  ALDA(IH,1)=ONE ;
*FOX  ALDA(IH,2)=RHO*SI ;
*FOX  ALDA(IH,3)=ZERO ;
*FOX  ALDA(IH,4)=ONE ;
*FOX  ALDA(IH,5)=-DPDA*RHO*(ONE-CO)/DPSQ*C1E3 ;
*FOX  ALDA(IH,6)=-DPDA*TWO*SIN(FOK*HALF)/COS(FOK*HALF)/DPSQ*C1E3 ;
*FOX  SM1=COS(FOK) ;
*FOX  SM2=SIN(FOK)*RHO ;
*FOX  SM3=-SIN(FOK)/RHO ;
*FOX  SM5=-RHO*DPSQ*(ONE-SM1) ;
*FOX  SM6=-SM2*DPSQ/RHO ;
*FOX  SM12=EL(I)-SM1*SM2 ;
*FOX  SM23=SM2*SM3 ;
*FOX  AS3=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23+SM5) ;
*FOX  AS4=-RV*SM23/C2E3 ;
*FOX  AS6=-RV*(EL(I)+SM1*SM2)/C4E3 ;
*FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA*(EL(I)-SM2))
*FOX  +EL(I)*(ONE-RV))*C1E3 ;
*FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12+SM6)+FOK1*AS3 ;
*FOX  ASDA(IH,3)=AS3 ;
*FOX  ASDA(IH,4)=AS4+TWO*AS6*FOK1 ;
*FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO)+AS6*FOK1*FOK1+FOK1*AS4  ;
*FOX  ASDA(IH,6)=AS6 ;
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
*FOX  G=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
*FOX  GL=EL(I)*G ;
*FOX  ALDA(IH,1)=ONE-GL ;
*FOX  ALDA(IH,2)=EL(I) ;
*FOX  ALDA(IH,3)=-G*(TWO-GL) ;
*FOX  ALDA(IH,4)=ALDA(IH,1) ;
*FOX  AS6=-RV*ALDA(IH,2)/C2E3 ;
*FOX  ASDA(IH,4)=-TWO*AS6*FOK1 ;
*FOX  ASDA(IH,5)=AS6*FOK1*FOK1 ;
*FOX  ASDA(IH,6)=AS6 ;
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   ih=1
   70   continue
        if(abs(ed(i)).le.pieni) goto 20
*FOX  FOK=EL(I)*ED(I)/DPSQ ;
*FOX  RHO=(ONE/ED(I))*DPSQ ;
*FOX  SI=SIN(FOK) ;
*FOX  CO=COS(FOK) ;
*FOX  RHOC=RHO*(ONE-CO)/DPSQ ;
*FOX  SIQ=SI/DPSQ ;
*FOX  ALDA(IH,1)=CO ;
*FOX  ALDA(IH,2)=RHO*SI ;
*FOX  ALDA(IH,3)=-SI/RHO ;
*FOX  ALDA(IH,4)=CO ;
*FOX  ALDA(IH,5)=-DPDA*RHOC*C1E3 ;
*FOX  ALDA(IH,6)=-DPDA*SIQ*C1E3 ;
*FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
*FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
*FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12
*FOX  +DPDA*(EL(I)-ALDA(IH,2)))+EL(I)*(ONE-RV))*C1E3 ;
*FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12-DPD*SIQ) ;
*FOX  ASDA(IH,3)=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23-DPD*RHOC) ;
*FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
*FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO) ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
*FOX  ALDA(IH,1)=ONE ;
*FOX  ALDA(IH,2)=EL(I) ;
*FOX  ALDA(IH,3)=ZERO ;
*FOX  ALDA(IH,4)=ONE ;
*FOX  ASDA(IH,6)=-RV*ALDA(IH,2)/C2E3 ;
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 50
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   90   ih=2
        goto 70
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
  100   continue
        if(abs(ek(i)).le.pieni) goto 20
*FOX  FOK=EK(I)/(ONE+DPDA) ;
*FOX  AEK=FOK ;
        if(dare(aek).lt.zero) then
*FOX  AEK=-AEK ;
        endif
        ih=0
*FOX  HI=SQRT(AEK) ;
*FOX  FI=EL(I)*HI ;
        if(ek(i).gt.zero) goto 120
  110   ih=ih+1
*FOX  ALDA(IH,1)=COS(FI) ;
*FOX  HI1=SIN(FI) ;
*FOX  ALDA(IH,2)=HI1/HI ;
*FOX  ALDA(IH,3)=-HI1*HI ;
*FOX  ALDA(IH,4)=ALDA(IH,1) ;
*FOX  ASDA(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
*FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
*FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  120   ih=ih+1
*FOX  HP=EXP(FI) ;
*FOX  HM=ONE/HP ;
*FOX  HC=(HP+HM)*HALF ;
*FOX  HS=(HP-HM)*HALF ;
*FOX  ALDA(IH,1)=HC ;
*FOX  ALDA(IH,2)=HS/HI ;
*FOX  ALDA(IH,3)=HS*HI ;
*FOX  ALDA(IH,4)=HC ;
*FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
*FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.1) goto 110
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  130   ih=0
*FOX  FOKQ=EK(I) ;
  140   continue
        if(abs(ek(i)).le.pieni) goto 60
        if(abs(ed(i)).le.pieni) goto 100
        if(abs(ek(i)-ed(i)**2).le.pieni) goto 20                         !hr08
*FOX  WF=ED(I)/DPSQ ;
*FOX  FOK=FOKQ/DPD-WF*WF ;
*FOX  AFOK=FOK ;
      if(dare(afok).lt.zero) then
*FOX  AFOK=-AFOK ;
      endif
*FOX  HI=SQRT(AFOK) ;
*FOX  FI=HI*EL(I) ;
        if(dare(fok).gt.zero) goto 160
  150   ih=ih+1
*FOX  SI=SIN(FI) ;
*FOX  CO=COS(FI) ;
*FOX  WFA=WF/AFOK*(ONE-CO)/DPSQ ;
*FOX  WFHI=WF/HI*SI/DPSQ ;
*FOX  ALDA(IH,1)=CO ;
*FOX  ALDA(IH,2)=SI/HI ;
*FOX  ALDA(IH,3)=-SI*HI ;
*FOX  ALDA(IH,4)=CO ;
*FOX  ALDA(IH,5)=-WFA*DPDA*C1E3 ;
*FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
*FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
*FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
*FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA
*FOX  *(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
*FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
*FOX  ASDA(IH,3)=-RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
*FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
*FOX  ASDA(IH,5)=-RV*SM12*AFOK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
*FOX  AEK=EK(I)/DPD ;
      if(dare(aek).lt.zero) then
*FOX  AEK=-AEK ;
      endif
*FOX  HI=SQRT(AEK) ;
*FOX  FI=HI*EL(I) ;
*FOX  HP=EXP(FI) ;
*FOX  HM=ONE/HP ;
*FOX  HC=(HP+HM)*HALF ;
*FOX  HS=(HP-HM)*HALF ;
*FOX  ALDA(IH,1)=HC ;
*FOX  ALDA(IH,2)=EL(I) ;
*FOX  ALDA(IH,2)=HS/HI ;
*FOX  ALDA(IH,3)=HS*HI ;
*FOX  ALDA(IH,4)=HC ;
*FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
*FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
*FOX  HP=EXP(FI) ;
*FOX  HM=ONE/HP ;
*FOX  HC=(HP+HM)*HALF ;
*FOX  HS=(HP-HM)*HALF ;
*FOX  ALDA(IH,1)=HC ;
*FOX  ALDA(IH,2)=HS/HI ;
*FOX  ALDA(IH,3)=HS*HI ;
*FOX  ALDA(IH,4)=HC ;
*FOX  WFA=WF/AFOK*(ONE-HC)/DPSQ ;
*FOX  WFHI=WF/HI*HS/DPSQ ;
*FOX  ALDA(IH,5)= WFA*DPDA*C1E3 ;
*FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
*FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
*FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
*FOX  ASDA(IH,1)=(RV*(DPDA*DPDA/(FOUR*DPD)*SM12
*FOX  +DPDA*(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
*FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
*FOX  ASDA(IH,3)=RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
*FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
*FOX  ASDA(IH,5)=+RV*SM12*AFOK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
*FOX  AEK=EK(I)/DPD ;
      if(dare(aek).lt.zero) then
*FOX  AEK=-AEK ;
      endif
*FOX  HI=SQRT(AEK) ;
*FOX  FI=HI*EL(I) ;
*FOX  SI=SIN(FI) ;
*FOX  CO=COS(FI) ;
*FOX  ALDA(IH,1)=CO ;
*FOX  ALDA(IH,2)=SI/HI ;
*FOX  ALDA(IH,3)=-SI*HI ;
*FOX  ALDA(IH,4)=CO ;
*FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
*FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
*FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
*FOX  FOKQ=-EK(I) ;
        goto 140
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   continue
*FOX  RHOI=ED(I)/DPSQ ;
*FOX  FOK=RHOI*SIN(EL(I)*RHOI*HALF)/COS(EL(I)*RHOI*HALF) ;
*FOX  ALDA(1,1)=ONE ;
*FOX  ALDA(1,2)=ZERO ;
*FOX  ALDA(1,3)=FOK ;
*FOX  ALDA(1,4)=ONE ;
*FOX  ALDA(2,1)=ONE ;
*FOX  ALDA(2,2)=ZERO ;
*FOX  ALDA(2,3)=-FOK ;
*FOX  ALDA(2,4)=ONE ;
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190   continue
        do 210 ih=1,2
          do 210 ip=1,6
            do 200 ien=1,nord+1
              if (nvar2.eq.5) then
                call dapri6(alda(ih,ip),result,ien,5)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,5)
                asd6(i,ih,ip,ien) = result
              else if (nvar2.eq.6) then
                call dapri6(alda(ih,ip),result,ien,6)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,6)
                asd6(i,ih,ip,ien) = result
              else if (nvar2.eq.4) then
                call dapri6(alda(ih,ip),result,ien,4)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,4)
                asd6(i,ih,ip,ien) = result
              endif
  200       continue
  210   continue
  220 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine envquad(i,ipch)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ih,ipch,idaa
      double precision dare
+ca parpro
+ca parnum
+ca common
+ca commondl
+ca commond1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
+ca dainicom
*FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
*FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
*FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
*FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
*FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
*FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
*FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
*FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
*FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
*FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
*FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
*FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
*FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
*FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
*FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
*FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
*FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
*FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
*FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
*FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
*FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
*FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
*FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
*FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
*FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
*FOX  D F RE DARE 1 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
*FOX  DPD=ONE+DPDA ;
*FOX  DPSQ=SQRT(DPD) ;
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
      if(abs(ek(i)).le.pieni) goto 100
*FOX  FOK=(SMIDA(IPCH)*RATIOE(I))/(ONE+DPDA) ;
*FOX  AEK=FOK ;
      if(dare(aek).lt.zero) then
*FOX  AEK=-AEK ;
      endif
      ih=0
*FOX  HI=SQRT(AEK) ;
*FOX  FI=EL(I)*HI ;
      if(ek(i).gt.zero) goto 30
   20 ih=ih+1
*FOX  ALDAQ(IH,1)=COS(FI) ;
*FOX  HI1=SIN(FI) ;
*FOX  ALDAQ(IH,2)=HI1/HI ;
*FOX  ALDAQ(IH,3)=-HI1*HI ;
*FOX  ALDAQ(IH,4)=ALDAQ(IH,1) ;
*FOX  ASDAQ(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
*FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
*FOX  ASDAQ(IH,5)=-RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
*FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.2) goto 100
!--DEFOCUSSING
   30 ih=ih+1
*FOX  HP=EXP(FI) ;
*FOX  HM=ONE/HP ;
*FOX  HC=(HP+HM)*HALF ;
*FOX  HS=(HP-HM)*HALF ;
*FOX  ALDAQ(IH,1)=HC ;
*FOX  ALDAQ(IH,2)=HS/HI ;
*FOX  ALDAQ(IH,3)=HS*HI ;
*FOX  ALDAQ(IH,4)=HC ;
*FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
*FOX  ASDAQ(IH,5)=+RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
*FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.1) goto 20
  100 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
+dk runda
      subroutine runda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR NORMAL FORWARD-TRACKING
!        SPECIALLY PREPARED FOR NEW D.A.
!        5 --> 6  AND  ASD6 / ALD6
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ich,i11,i480,icav,ien,ifam,iflag,iflag1,iflag2,ii,ip,   &
     &ipch,irrtr,iverg,ix,j,jb,jj,jmel,jx,k,kk,kkk,kpz,kzz,n,ncyo,nmz,  &
     &nsta,nsto,idaa
      double precision beamoff1,beamoff2,beamoff4,beamoff5,             &
     &beamoff6,benkcc,betr0,c5m4,cbxb,cbzb,cik,crk,crxb,crzb,dare,dpdav,&
     &dpdav2,dummy,fake,ox,oxp,oz,ozp,r0,r000,r0a,r2b,r2bf,rb,rbf,rho2b,&
     &rkb,rkbf,scikveb,scrkveb,sigmdac,startco,tkb,xbb,xrb,xs,zbb,      &
     &zfeld1,zfeld2,zrb,zs, crabfreq, crabpht, crabpht2, crabpht3,      &
     &crabpht4
      character*300 ch
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonxz
+ca commonm1
+ca commond1
+ca commond2
+ca commonc
      dimension zfeld1(100),zfeld2(100)
      dimension iverg(mcor)
      dimension fake(2,20),dpdav2(6),jj(100)
      save
!-----------------------------------------------------------------------
+ca daini
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0d-4
+ei
      if(mout2.eq.1) then
+if nagfor
+if boinc
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown',recl=303)
+ei
+if .not.boinc
      open(99,file='fort.99',form='formatted',status='unknown',recl=303)
+ei
+ei
+if .not.nagfor
+if boinc
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(99,file='fort.99',form='formatted',status='unknown')
+ei
+ei
      endif
      do i=1,100
        jj(i)=0
      enddo
      if(mout2.eq.1) write(7,*) e0,pma
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      betr0=sqrt(one-(pma/e0)**2)
      do 10 i=1,mcor
   10 iverg(i)=0
      do 15 i=1,20
        fake(1,i)=zero
        fake(2,i)=zero
   15 continue
      time1=0.
      call timex(time1)
      if(niu(1).gt.1) then
        do i=1,2
          ii=2*i
          xxtr(1,i)=clon(ii-1)
          yytr(1,i)=clon(ii)
        enddo
        sigm(1)=clon(5)
        dps(1)=clon(6)
      endif
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      if(nvar2.ge.1) call davar(x(1),zero,1)
*FOX  X(1)=X(1)+OX ;
      if(nvar2.ge.2) call davar(yp(1),zero,2)
*FOX  YP(1)=YP(1)+OXP*(ONE+DPS(1)) ;
      if(nvar2.ge.3) call davar(x(2),zero,3)
*FOX  X(2)=X(2)+OZ ;
      if(nvar2.ge.4) call davar(yp(2),zero,4)
*FOX  YP(2)=YP(2)+OZP*(ONE+DPS(1)) ;
      if(nvar2.lt.5) then
*FOX  DPDA1=DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.5) then
        call davar(dpda1,zero,5)
*FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.6) then
        call davar(sigmda,zero,5)
        call davar(dpda1,zero,6)
*FOX  SIGMDA=SIGMDA+SIGM(1) ;
*FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;
      else
*FOX  SIGMDA=SIGM(1) ;
      endif
*FOX  CORROLD(1)=X(1) ;
*FOX  CORROLD(2)=YP(1) ;
*FOX  CORROLD(3)=X(2) ;
*FOX  CORROLD(4)=YP(2) ;
*FOX  CORROLD(5)=SIGMDA ;
*FOX  CORROLD(6)=DPDA1 ;
      do 5 kkk=1,6
        dpdav=dare(corrold(kkk))
*FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
    5   continue
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      write(lout,*) ' ENTERING MAP '
      write(lout,*) 'INITIAL COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      if(ncor.gt.0) then
        do 20 i=1,ncor
          do 20 ii=1,iu
            if(ipar(i).eq.(ic(ii)-nblo).and.iverg(i).eq.0) then
              iverg(i)=1
              call davar(smida(i),ed(ic(ii)-nblo),nvar2+i)
            endif
   20   continue
      endif
      nsta=niu(1)
      nsto=niu(2)
      if(niu(2).lt.niu(1)) nsto=nsto+iu
      do 490 n=1,numl
        numx=n-1
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
        ncyo=ncy
        if(ncy.eq.0) ncy=1
        if(ithick.eq.1) call envada
        ncy=ncyo
        iflag=0
        iflag1=0
        iflag2=0
        icav=0
        do 480 i480=nsta,nsto
          if(i480.gt.iu) then
            i=i480-iu
          else
            i=i480
          endif
          if(mout2.eq.1.and.i480.eq.nsta.and.n.eq.1) call write4
          if(iflag.eq.1) then
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
            if(ithick.eq.1) then
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
              if(icav.eq.0) then
*FOX  CORRNEW(1)=X(1) ;
*FOX  CORRNEW(2)=YP(1) ;
*FOX  CORRNEW(3)=X(2) ;
*FOX  CORRNEW(4)=YP(2) ;
*FOX  CORRNEW(5)=SIGMDA ;
*FOX  CORRNEW(6)=DPDA1 ;
                do 24 kkk=1,6
                  dpdav=dare(corrnew(kkk))
*FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24           continue
              else
*FOX  CORRAU2(1)=X(1) ;
*FOX  CORRAU2(2)=YP(1) ;
*FOX  CORRAU2(3)=X(2) ;
*FOX  CORRAU2(4)=YP(2) ;
*FOX  CORRAU2(5)=SIGMDA ;
*FOX  CORRAU2(6)=DPDA1 ;
                do 25 kkk=1,6
*FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                  dpdav=dare(corrau2(kkk))
*FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25           continue
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
*FOX  CORRAU2(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
*FOX  CORRAU1(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
              endif
              dpdav=dare(x(1))
*FOX  X(1)=CORROLD(1)+DPDAV ;
              dpdav=dare(yp(1))
*FOX  YP(1)=CORROLD(2)+DPDAV ;
              dpdav=dare(x(2))
*FOX  X(2)=CORROLD(3)+DPDAV ;
              dpdav=dare(yp(2))
*FOX  YP(2)=CORROLD(4)+DPDAV ;
              dpdav=dare(sigmda)
*FOX  SIGMDA=CORROLD(5)+DPDAV ;
              dpdav=dare(dpda1)
*FOX  DPDA1=CORROLD(6)+DPDAV ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
              icav=icav+1
              call envada
            endif
            iflag=0
          endif
          ix=ic(i)
          if(mout2.eq.1) then
            if(i480.eq.nsta.and.n.eq.1) then
              write(ch,*) 'START ',dare(x(1)),dare(y(1)),dare(x(2)),    &
     &dare(y(2)),dare(sigmda),dare(dpda)
              do ich=300,1,-1
                if(ch(ich:ich).ne.' ') goto 700
              enddo
 700          write(99,'(a)') ch(:ich)
            else
              if(ic(i-1).le.nblo) then
                write(ch,*) bez(mtyp(ic(i-1),mel(ic(i-1)))),dare(x(1)), &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 701
                enddo
 701            write(99,'(a)') ch(:ich)
              else
                write(ch,*) bez(ic(i-1)-nblo),dare(x(1)),               &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 702
                enddo
 702            write(99,'(a)') ch(:ich)
              endif
            endif
          endif
          if(ix.gt.nblo) goto 70
          if(mout2.eq.1.and.n.eq.1) then
            jmel=mel(ix)
            do jb=1,jmel
              jx=mtyp(ix,jb)
              if(el(jx).eq.zero) then
                write(7,*) '0'
                write(7,*) bez(jx)
              else
                if(ithick.eq.1) then
                  ifam=0
                  do ip=1,il
                    if(kz(ip).eq.kz(jx).and.el(ip).ne.zero) then
                      if((ed(jx).ne.zero.and.ed(ip).ne.zero).or.        &
     &(ek(jx).ne.zero.and.ek(ip).ne.zero)) then
                        ifam=ifam+1
                        if(bez(ip).eq.bez(jx)) goto 35
                      endif
                    endif
                  enddo
 35               continue
                  write(7,*) '1'
                  write(7,*) bez(jx)
                  if(kz(jx).eq.1.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.3.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.4.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.5.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.8.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.2.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &abs(ed(jx)).le.pieni.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).le.pieni.and.abs(ek(jx)).gt.pieni)) then
                    write(7,*) '2 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).gt.pieni.and.abs(ek(jx)).le.pieni)) then
                    write(7,*) '3 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  else
                    write(7,*) kz(jx),ifam
                    write(7,*) ed(jx),ek(jx),el(jx)
                  endif
                else
                  write(7,*) '2'
                  write(7,*) bez(jx)
                  write(7,*) el(jx)
                endif
              endif
            enddo
          endif
          if(ix.le.0) then
            call prror(93)
          endif
+ca dalin1
+ca dalin2
+ca dalin3
+ca dalin4
+ca dalin5
+ca dalin6
+ca sqrtfox0
*FOX  SIGMDA=SIGMDA+
+ca sqrtfox
              endif
            enddo
          endif
          goto 480
   70     ix=ix-nblo
          if(abs(dare(x(1))).gt.aint(aper(1)).or.                       &
     &abs(dare(x(2))).gt.aint(aper(2))) then
            write(lout,10000) j,numx,i,dare(x(1)),aper(1),dare(x(2)),
     &aper(2),ix, kz(ix),bez(ix)
            goto 520
          endif
          kpz=abs(kp(ix))
          if(kpz.eq.0) goto 110
          goto(110,110,110,110,110,90),kpz
          goto 480
   90     if(nvar2.le.4.or.(nvar2.eq.5.and.nsix.ne.2)) goto 480
          ixcav=ix
          iicav=i
          if(nsix.eq.2) then
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
            call dapri(x(1),19)
            call dapri(yp(1),19)
            call dapri(x(2),19)
            call dapri(yp(2),19)
            call dapri(sigmda,19)
            call dapri(dpda1,19)
            if(ncor.gt.0) then
              write(lout,*) ' WARNING: in the 5*6 mode no extra ',
     &'parameters allowed'
            endif
            rewind 19
!     DADAL AUTOMATIC INCLUSION
            return
          endif
          if(ition.ne.0) then
*FOX  EJF0=EJF1 ;
            if(abs(dppoff).gt.pieni) then
              sigmdac=sigmoff(i)
*FOX  SIGMDA=SIGMDA-SIGMDAC ;
            endif
            call synoda
            if(mout2.eq.1.and.n.eq.1) then
              write(7,*) '5'
              if(kz(ix).eq.12) then
                write(7,*) bez(ix)
                write(ch,*) ed(ix),hsyc(ix),itionc(ix),phasc(ix)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 703
                enddo
 703            write(7,'(a)') ch(:ich)
              else
                write(7,*) 'CAV'
                write(ch,*) hsy(1),hsy(3),ition,phas
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 704
                enddo
 704            write(7,'(a)') ch(:ich)
              endif
            endif
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
          goto 480
  110     kzz=kz(ix)
          if(mout2.eq.1.and.n.eq.1) then
            if(kzz.eq.0) then
              write(7,*) '0'
              write(7,*) bez(ix)
            elseif((kzz.ge.1.and.kzz.le.10).or.                         &
     &(kzz.le.-1.and.kzz.ge.-10)) then
              write(7,*) '3'
              write(7,*) bez(ix)
+if tilt
+if crlibm
              write(7,*) xsi(i),zsi(i),atan2_rn(tilts(i),tiltc(i))
+ei
+if .not.crlibm
              write(7,*) xsi(i),zsi(i),atan2(tilts(i),tiltc(i))
+ei
+ei
+if .not.tilt
              write(7,*) xsi(i),zsi(i),zero
+ei
              write(7,*) kzz,smi(i)
            elseif(kzz.eq.11) then
              nmz=nmu(ix)
              write(7,*) '4'
              write(7,*) bez(ix)
+if tilt
+if crlibm
              write(7,*) xsi(i),zsi(i),atan2_rn(tilts(i),tiltc(i))
+ei
+if .not.crlibm
              write(7,*) xsi(i),zsi(i),atan2(tilts(i),tiltc(i))
+ei
+ei
+if .not.tilt
              write(7,*) xsi(i),zsi(i),zero
+ei
              if(abs(dki(ix,1)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 1',' 1'
                  write(7,*) dki(ix,1),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 1',' 0'
                  write(7,*) dki(ix,1),dki(ix,3)
                endif
              elseif(abs(dki(ix,2)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 0',' 1'
                  write(7,*) dki(ix,2),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 0',' 0'
                  write(7,*) dki(ix,2),dki(ix,3)
                endif
              else
                write(7,*) nmz,' 0',' 0',' 0'
              endif
              if(nmz.ge.1) then
                do ip=1,nmz
                  write(7,*) bbi(i,ip),aai(i,ip)
                enddo
              endif
            endif
          endif
          if(kzz.eq.15) then
*FOX  XX(1)=X(1) ;
*FOX  XX(2)=X(2) ;
*FOX  YY(1)=Y(1) ;
*FOX  YY(2)=Y(2) ;
          call wireda(ix,i)
*FOX  Y(1)=YY(1) ;
*FOX  Y(2)=YY(2) ;
             goto 480
          endif

          if(kzz.eq.20.and.parbe(ix,2).eq.0d0) then                      !hr08
            if(nbeam.ge.1) then
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then                                     &
+ca beamr1of
     &then
+ca beamr2of
+ca beamr3of
                  endif
                endif
+ca beamcof
+ca beamr1f
                if(abs(dare(rho2bf)).gt.pieni) then
+ca beamr2f
+ca beamr3f
                endif
              else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
+ca beam11of
+ca beama1of
+ca beama2of
+ca beam12of
+ca beama3of
+ca beam13of
+ca beama4of
                endif
+ca beam11s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam12f
+ca beama3f
+ca beam13f
+ca beama4f
              else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
+ca beam21of
+ca beama1of
+ca beama2of
+ca beam22of
+ca beama3of
+ca beam23of
+ca beama4of
                endif
+ca beam21s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam22f
+ca beama3f
+ca beam23f
+ca beama4f
              endif
              goto 480
            endif
            goto 480
          endif
          if(kzz.eq.20.and.parbe(ix,2).gt.0d0) then                      !hr08
+ca beam6dfi
            goto 480
          endif
+ca trom20
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) then
            if(bez(ix).eq.'DAMAP') then
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
              if(icav.eq.0.or.ithick.ne.1) then
                if(nvar2.ge.1) call dapri(x(1),17)
                if(nvar2.ge.2) call dapri(yp(1),17)
                if(nvar2.ge.3) call dapri(x(2),17)
                if(nvar2.ge.4) call dapri(yp(2),17)
                if(nvar2.eq.5.and.nsix.ne.2) call dapri(dpda1,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(sigmda,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(dpda1,17)
              else
*FOX  CORRAU1(1)=X(1) ;
*FOX  CORRAU1(2)=YP(1) ;
*FOX  CORRAU1(3)=X(2) ;
*FOX  CORRAU1(4)=YP(2) ;
*FOX  CORRAU1(5)=SIGMDA ;
*FOX  CORRAU1(6)=DPDA1 ;
                do 115 kkk=1,6
                  dpdav2(kkk)=dare(corrau1(kkk))
*FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  115           continue
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
*FOX  CORRAU1(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
*FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
                do 116 kkk=1,6
*FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  116           continue
                call dapri(corrau2(1),17)
                call dapri(corrau2(2),17)
                call dapri(corrau2(3),17)
                call dapri(corrau2(4),17)
                call dapri(corrau2(5),17)
                call dapri(corrau2(6),17)
              endif
              if(ncor.gt.0) then
                do 120 i11=1,ncor
  120           call dapri(smida(i11),17)
              endif
            endif
            goto 480
          endif
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei

          if(kzz.eq.23) then
*FOX  CRABAMP=ED(IX)/(EJF1) ;
             crabfreq=ek(ix)*c1e3
             crabpht=crabph(ix)
*FOX  Y(1)=Y(1) - CRABAMP*C1E3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(1)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-23) then
*FOX  CRABAMP=ED(IX)/(EJF1) ;
             crabfreq=ek(ix)*c1e3
             crabpht=crabph(ix)
*FOX  Y(2)=Y(2) - CRABAMP*C1E3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(2)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
! JBG RF CC Multipoles
          if(kzz.eq.26) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
*FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  DPDA1=DPDA1 - (1/2.)*(CRABAMP2)*(CRKVE*CRKVE-
*FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
! JBG RF CC Multipoles
          if(kzz.eq.-26) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
*FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  DPDA1=DPDA1 - (CRABAMP2)*(CIKVE*CRKVE)
*FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
*FOX  Y(1)=Y(1) + 2*(1/2.)*CRABAMP3*((CRKVE*CRKVE)-
*FOX  (CIKVE*CIKVE))*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  Y(2)=Y(2) - 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  DPDA1=DPDA1 - 2*(1/6.)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
*FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  C1M6*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-27) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
*FOX  Y(2)=Y(2) - 2*(1/2.)*CRABAMP3*((CIKVE*CIKVE)-
*FOX  (CRKVE*CRKVE))*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  Y(1)=Y(1) + 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  DPDA1=DPDA1 + 2*(1/6.)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
*FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  C1M6*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
*FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
*FOX  (CRKVE*CRKVE*CRKVE-(3*CRKVE*CIKVE*CIKVE))*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  Y(2)=Y(2) - 6*(1/6.)*(CRABAMP4)*
*FOX  (3*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  DPDA1=DPDA1-6*(1/24.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
*FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
*FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-28) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
*FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
*FOX  (CIKVE*CIKVE*CIKVE-(3*CIKVE*CRKVE*CRKVE))*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  Y(2)=Y(2) + 6*(1/6.)*(CRABAMP4)*
*FOX  (3*CRKVE*CIKVE*CIKVE-CRKVE*CRKVE*CRKVE)*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  DPDA1=DPDA1+6*(1/6.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CIKVE-
*FOX  CIKVE*CIKVE*CIKVE*CRKVE)*
*FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          ipch=0
          if(ncor.gt.0) then
            do 130 i11=1,ncor
  130       if(ipar(i11).eq.ix) ipch=i11
          endif
          if(ipch.ne.0) then
*FOX  EKK=(SMIDA(IPCH)+SMIZF(I))/(ONE+DPDA) ;
          else
*FOX  EKK=SMI(I)/(ONE+DPDA) ;
          endif
          xs=xsi(i)
          zs=zsi(i)
          if(mout2.eq.1.and.n.eq.1.and.icextal(i).ne.0) then
            write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),               &
     &extalign(i,1),extalign(i,2),extalign(i,3)
          endif
+ca alignf
          if(kzz.lt.0) goto 370
          goto(140,150,160,170,180,190,200,210,220,230,240,480,480,480, &
     &         480,480,480,480,480,480,480,480,480,235,236),kzz
          goto 480
!--HORIZONTAL DIPOLE
  140     continue
*FOX  EKK=EKK*C1E3 ;
+ca kickf01h
          goto 480
!--NORMAL QUADRUPOLE
  150     continue
+ca kickfxxh
          goto 480
!---NORMAL SEXTUPOLE
  160     continue
*FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxh
          goto 480
!--NORMAL OCTUPOLE
  170     continue
*FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!--NORMAL DECAPOLE
  180     continue
*FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!---NORMAL DODECAPOL
  190     continue
*FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!---NORMAL 14-POL
  200     continue
*FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!---NORMAL 16-POL
  210     continue
*FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!---NORMAL 18-POL
  220     continue
*FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!---NORMAL 20-POL
  230     continue
*FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          goto 480
!--DIPEDGE ELEMENT
  235     continue
+ca kickfdpe
          goto 480
!--solenoid
  236     continue
+ca kickfso1
          goto 480
  240     r0=ek(ix)
          nmz=nmu(ix)
+ca multf01
          if(abs(r0).le.pieni.or.nmz.eq.0) goto 480
          if(mout2.eq.1.and.n.eq.1) then
            benkcc=ed(ix)*benkc(irm(ix))
            r0a=one
            r000=r0*r00(irm(ix))
            do 243 j=1,mmul
              fake(1,j)=(bbi(i,j)*r0a)/benkcc                            !hr08
              fake(2,j)=(aai(i,j)*r0a)/benkcc                            !hr08
              r0a=r0a*r000
  243       continue
            write(9,'(a16)') bez(ix)
            write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
            write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
            do 246 j=1,20
              fake(1,j)=zero
              fake(2,j)=zero
  246       continue
          endif
          if(nmz.ge.2) then
+ca multf02
              do 250 k=3,nmz
+ca multf03
  250         continue
+ca multf04
          else
+ca multf05
          endif
          goto 480
!--SKEW ELEMENTS
  370     kzz=-kzz
          goto(380,390,400,410,420,430,440,450,460,470),kzz
          goto 480
!---VERTICAL DIPOLE
  380     continue
*FOX  EKK=EKK*C1E3 ;
+ca kickf01v
          goto 480
!---SKEW QUADRUPOLE
  390     continue
+ca kickfxxv
          goto 480
!---SKEW SEXTUPOLE
  400     continue
*FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW OCTUPOLE
  410     continue
*FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW DECAPOLE
  420     continue
*FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW DODECAPOL
  430     continue
*FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW 14-POL
  440     continue
*FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW 16-POL
  450     continue
*FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW 18-POL
  460     continue
*FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          goto 480
!---SKEW 20-POL
  470     continue
*FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
  480   continue
        if(mout2.eq.1) then
          if(ic(iu).le.nblo) then
            write(ch,*) bez(mtyp(ic(iu),mel(ic(iu)))),dare(x(1)),       &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 705
            enddo
 705        write(99,'(a)') ch(:ich)
          else
            write(ch,*) bez(ic(iu)-nblo),dare(x(1)),                    &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 706
            enddo
 706        write(99,'(a)') ch(:ich)
          endif
        endif
  490 continue
  500 continue
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
      if(nsix.eq.2) nsix=0
      if(icav.eq.0.or.ithick.ne.1) then
        if(nvar2.ge.1) call dapri(x(1),18)
        if(nvar2.ge.2) call dapri(yp(1),18)
        if(nvar2.ge.3) call dapri(x(2),18)
        if(nvar2.ge.4) call dapri(yp(2),18)
        if(nvar2.eq.5) call dapri(dpda1,18)
        if(nvar2.eq.6) call dapri(sigmda,18)
        if(nvar2.eq.6) call dapri(dpda1,18)
      else
*FOX  CORRAU1(1)=X(1) ;
*FOX  CORRAU1(2)=YP(1) ;
*FOX  CORRAU1(3)=X(2) ;
*FOX  CORRAU1(4)=YP(2) ;
*FOX  CORRAU1(5)=SIGMDA ;
*FOX  CORRAU1(6)=DPDA1 ;
        do 505 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
*FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  505   continue
        if(ncor.gt.0) then
          do kkk=1,ncor
            kk=6+kkk
*FOX  CORRAU1(KK)=SMIDA(KKK) ;
            dpdav=dare(smida(kkk))
*FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
          enddo
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
        do 506 kkk=1,6
*FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  506   continue
*FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
*FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
*FOX  X(1)=CORRAU2(1) ;
*FOX  Y(1)=CORRAU1(2) ;
*FOX  X(2)=CORRAU2(3) ;
*FOX  Y(2)=CORRAU1(4) ;
*FOX  SIGMDA=CORRAU2(5) ;
*FOX  DPDA1=CORRAU2(6) ;
*FOX  DPDA=DPDA1*C1M3 ;
        call dapri(corrau2(1),18)
        call dapri(corrau2(2),18)
        call dapri(corrau2(3),18)
        call dapri(corrau2(4),18)
        call dapri(corrau2(5),18)
        call dapri(corrau2(6),18)
      endif
      if(ncor.gt.0) then
        do 510 i11=1,ncor
  510   call dapri(smida(i11),18)
      endif
      write(lout,*) 'END COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      
      write(12,*) dare(x(1))
      write(12,*) dare(y(1))
      write(12,*) dare(x(2))
      write(12,*) dare(y(2))
      write(12,*) dare(sigmda)
      write(12,*) dare(dpda)

      write(lout,10010)
      
  520 continue
!     DADAL AUTOMATIC INCLUSION
      time2=0.
      call timex(time2)
!     time=time2-time1
      write(lout,10020) time1-time0
      write(lout,10030) nord,time2-time1
!-----------------------------------------------------------------------
      return
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. ',     &
     &i7,' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,              &
     &'HORIZ:  AMPLITUDE = ',f15.3,'   APERTURE = ',f15.3/ t10,         &
     &'VERT:   AMPLITUDE = ',f15.3,'   APERTURE = ',f15.3/ t10,         &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
10010 format(//t10,30('*')/t10,'**** ONE TURN COMPLETED ****'/ t10,30(  &
     &'*')/)
10020 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10030 format(/10x,'DA-Calculation of Order : ',i7,' took ', f12.3,      &
     &' second(s) of CPU Time'//131('-')//)
      end
+dk umlau6
      subroutine umlauda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR 6-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ibb,iii,i2,i3,i4,icav,icoonly,ien,iflag,iflag1,iflag2,  &
     &ii,ii2,ip,ipch,irrtr,ivar,ivar1,iwrite,ix,j,j1,jb,jj,jmel,jx,k,   &
     &kkk,kpz,kzz,mfile,nd2,nmz,idaa,angno,damap,damapi,damap1,f,aa2,   &
     &aa2r,a1,a1r,xy,h,df
      double precision al1,al2,al3,angp,angnoe,au,aui,b1,b2,b3,beamoff1,&
     &beamoff2,beamoff4,beamoff5,beamoff6,betr0,c,c5m4,cbxb,cbzb,coefh1,&
     &cik,coefh2,coefv1,coefv2,cp,crk,crxb,crzb,cx,d,dicu,dare,det1,dp, &
     &dpdav,dpdav2,dphi,dps1,dps11,dummy,ed1,ed2,g1,g2,g3,ox,oxp,oxp1,  &
     &oz,ozp,ozp1,phi,r0,r2b,r2bf,rb,rbf,rdd,rho2b,rkb,rkbf,rrad,       &
     &scikveb,scrkveb,sfac1,sfac2,sfac2s,sfac3,sfac4,sfac5,sigm1,       &
     &sigmdac,startco,sx,tas,tkb,tl,x2pi,xbb,xrb,xs,zbb,zfeld1,zfeld2,  &
     &zrb,zs,  crabfreq, crabpht, crabpht2, crabpht3, crabpht4
      character*16 typ
+ca parpro
+ca parnum
+ca commonex
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonl
+ca commonxz
+ca commonm1
+ca commond1
+ca commond2
+ca commonc
+ca commonta
      dimension damap(6),damapi(6),damap1(6)
      dimension aa2(6),aa2r(6),a1(6),a1r(6),xy(6),df(6)
      dimension zfeld1(100),zfeld2(100)
      dimension jj(100),dpdav2(6),rrad(3),rdd(6,6),dicu(20)
      dimension angnoe(3),angp(2,6),phi(3),dphi(3)
      dimension b1(3),b2(3),b3(3),al1(3),al2(3),al3(3),g1(3),g2(3),g3(3)
      dimension d(3),dp(3),c(3),cp(3),au(6,6),aui(2)
      dimension i4(10,2)
+if bnlelens
+ca rhicelens
+ei
!     for FMA analysis
+ca comgetfields
+ca dbdump
+ca dbdumpcr
+ca fma
!     for FMA analysis
+ca wireparam
+if debug
!     integer umcalls,dapcalls,dokcalls,dumpl
!     common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
+ei
+ca parbeam_exp
+if crlibm
      !For conversion of BEAM parameters to the new format
      character*1000 ch
      character*25 ch1
      integer errno,l1
      integer dtostr
+ei
      save
!-----------------------------------------------------------------------
+ca daini
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
+if debug
!     umcalls=umcalls+1
!     call wda('umcalls',0d0,1,umcalls,0,0)
+ei
      nd2=ndimf*2
      call etall(damap,6)
      call etall(damapi,6)
      call etall(damap1,6)
      call etall(angno,1)
      call etall(f,1)
      call etall(aa2,6)
      call etall(aa2r,6)
      call etall(a1,6)
      call etall(a1r,6)
      call etall(xy,6)
      call etall(h,1)
      call etall(df,6)
+if debug
!     call wda('uml2',0d0,2,0,0,0)
+ei
      if(iqmodc.eq.1) call danot(2)
      if(iqmodc.eq.3) call danot(1)
      if(ichromc.eq.1) call danot(3)
+if debug
!     call wda('uml3',0d0,3,0,0,0)
+ei
      icoonly=0
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ichromc.eq.2) icoonly=1
+if fast
      c5m4=5.0d-4
+ei
      do j=1,2
        angnoe(j)=zero
        do i=1,6
          angp(j,i)=zero
        enddo
      enddo
      do i=1,100
        jj(i)=0
      enddo
+if crlibm
      x2pi=atan_rn(one)*8d0
+ei
+if .not.crlibm
      x2pi=atan(one)*8d0
+ei
      i4(1,1)=1
      i4(1,2)=1
      i4(2,1)=3
      i4(2,2)=3
      i4(3,1)=1
      i4(3,2)=3
      i4(4,1)=1
      i4(4,2)=2
      i4(5,1)=1
      i4(5,2)=4
      i4(6,1)=2
      i4(6,2)=2
      i4(7,1)=2
      i4(7,2)=3
      i4(8,1)=2
      i4(8,2)=4
      i4(9,1)=3
      i4(9,2)=4
      i4(10,1)=4
      i4(10,2)=4
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      betr0=sqrt(one-(pma/e0)**2)
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      sigm1=sigm(1)
      dps1=dps(1)
      if(iqmodc.eq.1) then
        if(el(iq(1)).le.pieni) then
          ed1=ed(iq(1))
        else
          ed1=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          ed2=ed(iq(2))
        else
          ed2=ek(iq(2))
        endif
      endif
      if(ichromc.eq.1) then
        ed1=ed(issss(1))
        ed2=ed(issss(2))
      endif
+if debug
!     call wda('uml4',0d0,4,0,0,0)
+ei
      call davar(x(1),ox,1)
      oxp1=oxp*(one+dps1)
      call davar(yp(1),oxp1,2)
      ivar=2
      if(nvar2.ge.4) then
        call davar(x(2),oz,3)
        ozp1=ozp*(one+dps1)
        call davar(yp(2),ozp1,4)
        ivar=4
      else
*FOX  X(2)=OZ ;
*FOX  YP(2)=OZP*(ONE+DPS1) ;
      endif
      dps11=dps1*c1e3
      if(nvar2.eq.3) then
        call davar(dpda1,dps11,3)
        ivar=ivar+1
      elseif(nvar2.eq.5) then
        call davar(dpda1,dps11,5)
        ivar=ivar+1
      elseif(nvar2.eq.6) then
        call davar(sigmda,sigm1,5)
        call davar(dpda1,dps11,6)
        ivar=ivar+2
      else
*FOX  SIGMDA=SIGM1 ;
*FOX  DPDA1=DPS1*C1E3 ;
      endif
      ivar1=ivar
      if(iqmodc.eq.1.or.ichromc.eq.1) then
        call davar(smida(1),ed1,ivar+1)
        call davar(smida(2),ed2,ivar+2)
        ivar=ivar+2
      endif
!--Normal Form Analysis for calculation of linear lattice functions
+if debug
!     call wda('uml5',0d0,5,ilinc,0,0)
+ei
      if(ilinc.eq.1.or.ilinc.eq.2) then
        mfile=18
!Eric
        rewind mfile
        rewind 111
!ERIC HERE
        call daread(damap,nvar,mfile,1.d0)
+if debug
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml6',0d0,6,0,0,0)
+ei
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
        do j=1,nvar
          call dacop(damap(j),damap1(j))
          dummy=dare(damap1(j))
          call dacsu(damap1(j),dummy,damap1(j))
        enddo
        if(ndimf.eq.3) then
          call damul(damap1(5),damap1(5),angno)
          call averaged(angno,damap1,.true.,angno)
          jj(5)=1
          jj(6)=1
+if debug
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml7',0d0,7,0,0,0)
+ei
          call dapek(angno,jj,emitz)
+if debug
!     call warr('emitz',emitz,1,0,0,0)
!     call wda('uml8',0d0,8,0,0,0)
+ei
          jj(5)=0
          jj(6)=0
          if(abs(emitz).le.pieni) then
            emitz=zero
          else
            emitz=((sigz**2/emitz)*half)*c1e6                            !hr05
          endif
        endif
+if debug
!     call warr('emitz',emitz,2,0,0,0)
!     call wda('uml9',0d0,9,0,0,0)
+ei
+if debug
!     call dumpbin('emitz',1,1)
!     call dumpda('emitz',1,0)
!     call abend('          emitz                                   ')
+ei
        jj(5)=1
        do j=1,nd2
          call dapek(a1(j),jj,dicu(j))
        enddo
        jj(5)=0
      endif
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  CORROLD(1)=X(1) ;
*FOX  CORROLD(2)=YP(1) ;
*FOX  CORROLD(3)=X(2) ;
*FOX  CORROLD(4)=YP(2) ;
*FOX  CORROLD(5)=SIGMDA ;
*FOX  CORROLD(6)=DPDA1 ;
            do 5 kkk=1,6
              dpdav=dare(corrold(kkk))
*FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
    5       continue
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      iflag=0
      iflag1=0
      iflag2=0
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
      if(ithick.eq.1) call envada
      icav=0
      typ='START'
      phi(1)=zero
      phi(2)=zero
      phi(3)=zero
      ibb=0
      wire_num_aux=0
+if debug
!     call wda('biu',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('biu',0,0)
!     call abend('biu                                               ')
!     endif
+ei
!     start loop over single elements
      do 430 i=1,iu
        if(iqmodc.eq.2.or.iqmodc.eq.4) then
          if(i.eq.niu(1)) then
            do ii=1,2
              ii2=2*ii
              clon(ii2-1)=dare(x(ii))
              clon(ii2)=dare(y(ii))
            enddo
            clon(5)=dare(sigmda)
            clon(6)=dare(dpda)
          endif
        endif
+if debug
!     call wda('aclon',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aclon',0,0)
!     call abend('aclon                                             ')
!     endif
+ei
        if(ilinc.eq.1.and.i.eq.1) then
          write(lout,10000) nd2
          if(iprint.eq.1) write(lout,10130)
          write(lout,10010)
          write(lout,10020)
          write(lout,10010)
          tl=zero
+ca umlalid
        endif
+if debug
!     call wda('biflag',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call wda('biflag',0d0,iflag,0,0,0)
!       call dumpda('biflag',0,0)
!     call abend('biflag                                            ')
!     endif
+ei
        if(iflag.eq.1) then
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
          if(ithick.eq.1) then
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
            if(icav.eq.0) then
*FOX  CORRNEW(1)=X(1) ;
*FOX  CORRNEW(2)=YP(1) ;
*FOX  CORRNEW(3)=X(2) ;
*FOX  CORRNEW(4)=YP(2) ;
*FOX  CORRNEW(5)=SIGMDA ;
*FOX  CORRNEW(6)=DPDA1 ;
              do 24 kkk=1,6
                dpdav=dare(corrnew(kkk))
*FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24         continue
            else
*FOX  CORRAU2(1)=X(1) ;
*FOX  CORRAU2(2)=YP(1) ;
*FOX  CORRAU2(3)=X(2) ;
*FOX  CORRAU2(4)=YP(2) ;
*FOX  CORRAU2(5)=SIGMDA ;
*FOX  CORRAU2(6)=DPDA1 ;
              do 25 kkk=1,6
*FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                dpdav=dare(corrau2(kkk))
*FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25         continue
              if(ivar.gt.ivar1) then
*FOX  CORRAU2(7)=SMIDA(1) ;
*FOX  CORRAU2(8)=SMIDA(2) ;
                dpdav=dare(smida(1))
*FOX  CORRAU1(7)=SMIDA(1)-DPDAV ;
                dpdav=dare(smida(2))
*FOX  CORRAU1(8)=SMIDA(2)-DPDAV ;
              endif
+if debug
!     call wda('dacct',0d0,1,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('bdacct',0,0)
!     call abend('bdaccct                                           ')
!     endif
+ei
              call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
            endif
+if debug
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
+ei
            dpdav=dare(x(1))
*FOX  X(1)=CORROLD(1)+DPDAV ;
            dpdav=dare(yp(1))
*FOX  YP(1)=CORROLD(2)+DPDAV ;
            dpdav=dare(x(2))
*FOX  X(2)=CORROLD(3)+DPDAV ;
            dpdav=dare(yp(2))
*FOX  YP(2)=CORROLD(4)+DPDAV ;
            dpdav=dare(sigmda)
*FOX  SIGMDA=CORROLD(5)+DPDAV ;
            dpdav=dare(dpda1)
*FOX  DPDA1=CORROLD(6)+DPDAV ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  RV=EJ1/E0*E0F/EJF1 ;
            icav=icav+1
            call envada
          endif
          iflag=0
        endif
        ix=ic(i)
        if(ix.gt.nblo) goto 50
        if(ix.le.0) then
          call prror(93)
        endif
+ca dalin1
+if debug
!     call wda('adlin1',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adlin1',0,0)
!     call abend('adlin1                                            ')
!     endif
+ei
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
+if debug
!     call wda('aenvquad',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aenvquad',0,0)
!     call abend('aenvquad                                          ')
!     endif
+ei
*FOX  PUX=X(1) ;
*FOX  PUZ=Y(1) ;
*FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
*FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
*FOX  PUX=X(2) ;
*FOX  PUZ=Y(2) ;
*FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
*FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
+ca dalin2
              endif
+ca dalin3
          if(ilinc.eq.1) then
            do jb=1,jmel
              jx=mtyp(ix,jb)
              typ=bez(jx)
              tl=tl+el(jx)
+ca umlalid
              if(i.eq.nt) goto 470
            enddo
          endif
+ca dalin4
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
*FOX  PUX=X(1) ;
*FOX  PUZ=Y(1) ;
*FOX  SIGMDA=SIGMDA+ASDAQ(1,1)+ASDAQ(1,2)*PUX+
*FOX  ASDAQ(1,3)*PUZ+ASDAQ(1,4)*PUX*PUZ+ASDAQ(1,5)*PUX*PUX+
*FOX  ASDAQ(1,6)*PUZ*PUZ ;
*FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
*FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
*FOX  PUX=X(2) ;
*FOX  PUZ=Y(2) ;
*FOX  SIGMDA=SIGMDA+ASDAQ(2,1)+ASDAQ(2,2)*PUX+
*FOX  ASDAQ(2,3)*PUZ+ASDAQ(2,4)*PUX*PUZ+ASDAQ(2,5)*PUX*PUX+
*FOX  ASDAQ(2,6)*PUZ*PUZ ;
*FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
*FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
+ca dalin5
              endif
            else
              if(iexact.eq.1) then
+ca exDAdrift
              else
! Regular drift
+ca dalin6
+ca sqrtfox0
*FOX  SIGMDA=SIGMDA+
+ca sqrtfox
              endif
            endif
            if(ilinc.eq.1) then
              typ=bez(jx)
              tl=tl+el(jx)
+ca umlalid
              if(i.eq.nt) goto 470
            endif
          enddo
        endif
+if debug
!     if (umcalls.eq.8) then
!     call wda('bgoto430',0d0,2,0,0,0)
!       call dumpda('bgoto430',0,0)
!     call abend('bgoto430                                          ')
!     endif
+ei
        goto 430
   50   ix=ix-nblo
+if debug
!     if (umcalls.eq.8) then
!     call wda('a50',0d0,ix,nblo,ix-nblo,0)
!       call dumpda('a50',0,0)
!     call abend('a50                                               ')
!     endif
+ei
        if(abs(dare(x(1))).gt.aint(aper(1)).or.                         &
     &abs(dare(x(2))).gt.aint(aper(2))) then
          write(lout,10120)j,i,dare(x(1)),aper(1),dare(x(2)),aper(2),ix,
     &kz(ix),bez(ix)
          call prror(97)
        endif
        kpz=abs(kp(ix))
        if(kpz.eq.0) goto 80
        goto(80,80,80,80,80,70),kpz
        goto 430
   70   continue
        if(ition.ne.0) then
*FOX  EJF0=EJF1 ;
          ixcav=ix
          if(abs(dppoff).gt.pieni) then
            sigmdac=dare(sigmda)
            sigmoff(i)=sigmdac
*FOX  SIGMDA=SIGMDA-SIGMDAC ;
          endif
          call synoda
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
        endif
        goto 440
   80   kzz=kz(ix)
        if(kzz.eq.15) then
! the same as in umlalid1
          wire_num_aux = wire_num_aux+1
! is the error number correct?
          if(wire_num_aux.gt.wire_max) then
               write(lout,
     &*) 'ERROR: maximum number of wires exceeded! Number of wires ='//
     &'wire_num_aux = ',wire_num_aux,' > ',wire_max,' = wire_max'
            call prror(-1)
          endif
          wire_num(i) = wire_num_aux
*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
*FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag2.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          endif
          call dainv(damap,nvar,damapi,nvar)
          call dacct(damap,nvar,aa2,nvar,aa2r,nvar)
          call dacct(damap,nvar,damap1,nvar,damap,nvar)
          call dacct(damap,nvar,damapi,nvar,damap,nvar)
! the same as in umlalid1
      
*FOX  XX(1)=X(1) ;
*FOX  XX(2)=X(2) ;
*FOX  YY(1)=Y(1) ;
*FOX  YY(2)=Y(2) ;
      wire_clo(1,wire_num(i))=dare(x(1))
      wire_clo(2,wire_num(i))=dare(x(2))
      wire_clo(4,wire_num(i))=dare(y(1))*(one+dare(DPDA))
      wire_clo(5,wire_num(i))=dare(y(2))*(one+dare(DPDA))
      if(ndimf.eq.3) then
         wire_clo(3,wire_num(i))=dare(SIGMDA)
         wire_clo(6,wire_num(i))=dare(DPDA)
      endif

      call wireda(ix,i)

*FOX  Y(1)=YY(1) ;
*FOX  Y(2)=YY(2) ;
          goto 440
        endif
        if(ilinc.eq.2.and.kzz.eq.20) then
          if(nbeam.ge.1) then
+ca umlalid1
          endif
          goto 440
        endif
        if(kzz.eq.20.and.iqmodc.eq.4) goto 440
        if(kzz.eq.20.and.parbe(ix,2).eq.0d0) then                        !hr12
          if(nbeam.ge.1) then
            if(ilinc.eq.0) then
              clobeam(1,imbb(i))=dare(x(1))
              clobeam(2,imbb(i))=dare(x(2))
              clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
              clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
              if(ndimf.eq.3) then
                clobeam(3,imbb(i))=dare(sigmda)
                clobeam(6,imbb(i))=dare(dpda)
              endif
            endif
            if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then                                       &
+ca beamr1of
     &then
+ca beamr2of
+ca beamr3of
                endif
              endif
+ca beamcof
+ca beamr1f
              if(abs(dare(rho2bf)).gt.pieni) then
+ca beamr2f
+ca beamr3f
              endif
            else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
+ca beam11of
+ca beama1of
+ca beama2of
+ca beam12of
+ca beama3of
+ca beam13of
+ca beama4of
              endif
+ca beam11s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam12f
+ca beama3f
+ca beam13f
+ca beama4f
            else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
+ca beam21of
+ca beama1of
+ca beama2of
+ca beam22of
+ca beama3of
+ca beam23of
+ca beama4of
              endif
+ca beam21s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam22f
+ca beama3f
+ca beam23f
+ca beama4f
            endif
            goto 440
          endif
          goto 440
        endif
        if(kzz.eq.20.and.parbe(ix,2).gt.0d0) then                        !hr12
          if(ilinc.eq.0)then
            clobeam(1,imbb(i))=dare(x(1))
            clobeam(2,imbb(i))=dare(x(2))
            clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
            clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
            if(ndimf.eq.3)then
              clobeam(3,imbb(i))=dare(sigmda)
              clobeam(6,imbb(i))=dare(dpda)
            endif
          endif
+ca beam6dfi
          goto 440
        endif
+if crlibm
          pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
          pi=4d0*atan(1d0)
+ei
        if(kzz.eq.23) then
*FOX  CRABAMP=ED(IX)/(EJF1) ;
!       call dapri(EJF1,234)
!       write(*,*) crabamp, EJF1, EJF0,clight, "HELLO"
        crabfreq=ek(ix)*c1e3
        crabpht=crabph(ix)
*FOX  Y(1)=Y(1) - CRABAMP*C1E3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(1)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
        if(kzz.eq.-23) then
*FOX  CRABAMP=ED(IX)/(EJF1) ;
           crabfreq=ek(ix)*c1e3
           crabpht=crabph(ix)
*FOX  Y(2)=Y(2) - CRABAMP*C1E3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(2)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif

! JBG RF CC Multipoles
        if(kzz.eq.26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
+ca alignf ! JBG Including misalignments
*FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
!       call dapri(EJF1,234)
!       write(*,*) crabamp, EJF1, EJF0,clight, "HELLO"
        crabfreq=ek(ix)*c1e3 !JBG Input in MHz changed to kHz
        crabpht2=crabph2(ix)
*FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  DPDA1=DPDA1 - (1/2.)*(CRABAMP2)*(CRKVE*CRKVE-
*FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
          if(kzz.eq.-26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
*FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
*FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
*FOX  DPDA1=DPDA1 - (CRABAMP2)*(CIKVE*CRKVE)
*FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
*FOX  Y(1)=Y(1) + 2*(1/2.)*CRABAMP3*((CRKVE*CRKVE)-
*FOX  (CIKVE*CIKVE))*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  Y(2)=Y(2) - 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  DPDA1=DPDA1 - 2*(1/6.)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
*FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  C1M6*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
*FOX  Y(2)=Y(2) - 2*(1/2.)*CRABAMP3*((CIKVE*CIKVE)-
*FOX  (CRKVE*CRKVE))*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  Y(1)=Y(1) + 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
*FOX  DPDA1=DPDA1 + 2*(1/6.)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
*FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  C1M6*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
*FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
*FOX  (CRKVE*CRKVE*CRKVE-(3*CRKVE*CIKVE*CIKVE))*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  Y(2)=Y(2) - 6*(1/6.)*(CRABAMP4)*
*FOX  (3*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  DPDA1=DPDA1-6*(1/24.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
*FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
*FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
*FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
*FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
*FOX  (CIKVE*CIKVE*CIKVE-(3*CIKVE*CRKVE*CRKVE))*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  Y(2)=Y(2) + 6*(1/6.)*(CRABAMP4)*
*FOX  (3*CRKVE*CIKVE*CIKVE-CRKVE*CRKVE*CRKVE)*C1M3*C1M3*
*FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
*FOX  DPDA1=DPDA1+6*(1/6.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CIKVE-
*FOX  CIKVE*CIKVE*CIKVE*CRKVE)*
*FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
*FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
*FOX  EJF0=EJF1 ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  Y(1)=EJF0/EJF1*Y(1) ;
*FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
+ca trom20
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 440
        if(kzz.eq.15) goto 440
        ipch=0
        if(iqmodc.eq.1) then
          if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
            ipch=1
          else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
            ipch=2
          endif
        endif
        if(ichromc.eq.1) then
          if(ix.eq.issss(1).or.iratioe(ix).eq.issss(1)) then
            ipch=1
          else if(ix.eq.issss(2).or.iratioe(ix).eq.issss(2)) then
            ipch=2
          endif
        endif
        if(ipch.ne.0) then
*FOX  EKK=(SMIDA(IPCH)*RATIOE(IX)+SMIZF(I))/(ONE+DPDA) ;
        else
*FOX  EKK=SMI(I)/(ONE+DPDA) ;
        endif
        xs=xsi(i)
        zs=zsi(i)
+ca alignf
        if(kzz.lt.0) goto 320
        goto(90,100,110,120,130,140,150,160,170,180,190,440,440,440,    &
     &       440,440,440,440,440,440,440,440,440,185,186),kzz
        goto 440
!--HORIZONTAL DIPOLE
   90   continue
*FOX  EKK=EKK*C1E3 ;
+ca kickf01h
        goto 440
!--NORMAL QUADRUPOLE
  100   continue
+ca kickfxxh
        goto 440
!---NORMAL SEXTUPOLE
  110   continue
*FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxh
        goto 440
!--NORMAL OCTUPOLE
  120   continue
*FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!--NORMAL DECAPOLE
  130   continue
*FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!---NORMAL DODECAPOL
  140   continue
*FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!---NORMAL 14-POL
  150   continue
*FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!---NORMAL 16-POL
  160   continue
*FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!---NORMAL 18-POL
  170   continue
*FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!---NORMAL 20-POL
  180   continue
*FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        goto 440
!--DIPEDGE ELEMENT
  185   continue 
+ca kickfdpe
        goto 440
!--solenoid
  186   continue 
+ca kickfso1
        goto 440
  190   r0=ek(ix)
        nmz=nmu(ix)
+ca multf01
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 440
        if(nmz.ge.2) then
+ca multf02
          do 200 k=3,nmz
+ca multf03
  200     continue
+ca multf04
        else
+ca multf05
        endif
        goto 440
!--SKEW ELEMENTS
  320   kzz=-kzz
        goto(330,340,350,360,370,380,390,400,410,420),kzz
        goto 440
!---VERTICAL DIPOLE
  330   continue
*FOX  EKK=EKK*C1E3 ;
+ca kickf01v
        goto 440
!---SKEW QUADRUPOLE
  340   continue
+ca kickfxxv
        goto 440
!---SKEW SEXTUPOLE
  350   continue
*FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW OCTUPOLE
  360   continue
*FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW DECAPOLE
  370   continue
*FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW DODECAPOL
  380   continue
*FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW 14-POL
  390   continue
*FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW 16-POL
  400   continue
*FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW 18-POL
  410   continue
*FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        goto 440
!---SKEW 20-POL
  420   continue
*FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
 440  continue
+if debug
!     if (umcalls.eq.8) then
!     call wda('a440   ',0d0,2,0,0,0)
!       call dumpda('a440   ',0,0)
!     call abend('a440                                              ')
!     endif
+ei
      if(ilinc.eq.1) then
        typ=bez(ix)
+ca umlalid
        if(i.eq.nt) goto 470
      endif
 430  continue ! END LOOP OVER SINGLE ELEMENTS IN UMLAUDA

*FOX  YP(1)=Y(1)*(ONE+DPDA) ;
*FOX  YP(2)=Y(2)*(ONE+DPDA) ;
+if debug
!     call wda('afox   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('afox   ',0,0)
!     call abend('afox                                              ')
!     endif
+ei
      if(icav.eq.0.or.ithick.ne.1) then
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      else
*FOX  CORRAU1(1)=X(1) ;
*FOX  CORRAU1(2)=YP(1) ;
*FOX  CORRAU1(3)=X(2) ;
*FOX  CORRAU1(4)=YP(2) ;
*FOX  CORRAU1(5)=SIGMDA ;
*FOX  CORRAU1(6)=DPDA1 ;
+if debug
!     call wda('b435   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b435   ',0,0)
!     call abend('b435                                              ')
!     endif
+ei
        do 435 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
*FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  435   continue
        if(ivar.gt.ivar1) then
*FOX  CORRAU1(7)=SMIDA(1) ;
*FOX  CORRAU1(8)=SMIDA(2) ;
          dpdav=dare(smida(1))
*FOX  CORRNEW(7)=SMIDA(1)-DPDAV ;
          dpdav=dare(smida(2))
*FOX  CORRNEW(8)=SMIDA(2)-DPDAV ;
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
+if debug
!     call wda('b436   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b436   ',0,0)
!     call abend('b436                                              ')
!     endif
+ei
        do 436 kkk=1,6
*FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  436   continue
*FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
*FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
*FOX  X(1)=CORRAU2(1) ;
*FOX  YP(1)=CORRAU2(2) ;
*FOX  X(2)=CORRAU2(3) ;
*FOX  YP(2)=CORRAU2(4) ;
*FOX  SIGMDA=CORRAU2(5) ;
*FOX  DPDA1=CORRAU2(6) ;
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      endif
      call dacop(x(1),damap(1))
      call dacop(x(2),damap(3))
      if(ndimf.eq.3) call dacop(sigmda,damap(5))
      if(icoonly.eq.1.or.iqmodc.eq.3) then
        call dacop(y(1),damap(2))
        call dacop(y(2),damap(4))
        if(ndimf.eq.3) call dacop(dpda,damap(6))
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(damap(ii),jj,aml6(ii,i))
            if(i.eq.6) aml6(ii,i)=aml6(ii,i)*c1e3
          enddo
          jj(i)=0
        enddo
        do i=1,nd2
          aml6(i,i)=aml6(i,i)-one
        enddo
      endif
+if debug
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
+ei
      call dacop(yp(1),damap(2))
      call dacop(yp(2),damap(4))
      if(ndimf.eq.3) then
        call dacop(sigmda,damap(5))
        call dacop(dpda1,damap(6))
      else
        call dacop(dpda1,damap(5))
      endif
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ilin.ge.2) then
        rewind 18
!Eric
        rewind 111
        call daprid(damap,1,nvar,18)
      endif
+if debug
!     call wda('boutput',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('boutput',0,0)
!     call abend('boutput                                           ')
!     endif
+ei
!--now do the output
      if(iqmodc.eq.1) call danot(3)
      if(iqmodc.eq.3) call danot(2)
      if(ichromc.eq.1) call danot(4)
      if(ilinc.eq.1.or.ilinc.eq.2.or.iqmodc.eq.1.or.iqmodc.eq.3.or.     &
     &ichromc.eq.1) then
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
      endif
      if(iqmodc.eq.1.or.iqmodc.eq.3) then
        call gettura(wxys,rrad)
        wxys(3)=abs(wxys(3))
        write(lout,*) (wxys(i),i=1,ndimf)
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(aa2(ii),jj,tas)
            if(i.eq.6.and.ii.ne.6) tas=tas*c1e3
            if(ii.eq.6.and.i.ne.6) tas=tas*c1m3
            tasm(ii,i)=tas
          enddo
          jj(i)=0
        enddo
      endif
      if(iqmodc.eq.1) then
        call dhdj(h,df)
        do i=1,ndimf
          call dapek(df(ndimf+i),jj,corr(1,i))
        enddo
        corr(1,3)=abs(corr(1,3))
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+1)=0
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+2)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(90)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-1d0*coefh2)/det1                                     !hr05
        corr(3,1)=(-1d0*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
      if(ichromc.eq.1) then
        call dhdj(h,df)
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,corr(1,1))
        call dapek(df(ndimf+2),jj,corr(1,2))
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+2)=0
        jj(nd2+3)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+3)=0
        jj(nd2+1)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(96)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-1d0*coefh2)/det1                                     !hr05
        corr(3,1)=(-1d0*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
 470  continue
+if debug
!     call wda('a470   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('a470   ',0,0)
!     call abend('a470                                              ')
!     endif
+ei
      call dadal(damap,6)
      call dadal(damapi,6)
      call dadal(damap1,6)
      call dadal(angno,1)
      call dadal(f,1)
      call dadal(aa2,6)
      call dadal(aa2r,6)
      call dadal(a1,6)
      call dadal(a1r,6)
      call dadal(xy,6)
      call dadal(h,1)
      call dadal(df,6)
!     DADAL AUTOMATIC INCLUSION
      return
!-----------------------------------------------------------------------
10000 format(/t5 ,'---- ENTRY ',i1,'D LINOPT ----')
10010 format(132('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f12.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format('|',6x,'|',8x,'|',12x,'|','Y','|',12x,'|',f12.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10050 format('|',6x,'|',a8,'|',12x,'|','S','|',12x,'|',f12.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10055 format('|',6x,'|',a8,'|',12x,'|','Y','|',12x,'|',f12.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10060 format('|',6x,'|',8x,'|',12x,'|',102('-'))
10070 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f12.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10080 format('|',6x,'|',8x,'|',12x,'|','X','|',12x,'|',f12.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10090 format('|',6x,'|',8x,'|',12x,'|','S','|',12x,'|',f12.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10100 format('|',6x,'|',8x,'|',12x,'|','S','|',f12.7,'|',f12.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10110 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',f15.3,          &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',f15.3,         &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10120 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',f15.3,          &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',f15.3,         &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10130 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
      end
!
!-----------------------------------------------------------------------
! WIRE DIFFERENTIAL ALGEBRA
+dk wireda
      subroutine wireda(ix,i)
! MODEL OF STRAIGHT CURRENT WIRE
!
!     The model provides a transfer map of a straight current wire. 
!     Description:
!     1. Infinitly thin wire with arbitrary orientation.
!     2. Thin element in SixTrack (L)=0
!     3. Parameters: 
!     dx, dy: horizontal and vertical distances between wire midpoint
!     and closed orbit [mm] 
!     (parameters are given by dx and dy in WIRE block)
!     tx, ty: tilt of the wire w.r.t the closed orbit in the
!     horizontal and vertical planes (in degrees) 
!     (parameters are given by tiltx and tilty in WIRE block)
!     L - physical length of the wire element [m]
!     cur - current of the wire [Amperes]
!     embl - embedding drift (integrated length or integration interval) [m] 
!     4. The transport map is given for canonical variables (x,px...)
!
! The MAP is constructed out of the following steps:
!     1. Declaration of shifted canonical variables: 
!          rx = x+dx; ry = y+dy  in the same way as for the BEAM-BEAM element
!     2. Symplectic Rotation by the tilt angles tx, ty (in 4D space: px, rx, py, ry)
!     3. Wire kick for a longitudinally aligned wire (= kick for tx=ty=0)
!     4. Symplectic Rotation back by the tilt angles -ty, -yx (in 4D space: ...taking only PX, PY)
!--------------------------------------------------------------
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I

      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ix,idaa,i
      double precision NNORM_, XCLO, YCLO
      double precision l,cur,dx,dy,tx,ty,embl,chi
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont2
+ca commond1
+ca commondl
+ca commonl
+ca commonxz
+ca wireparam
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
+ca dainicom
*FOX  D V DA INT XI NORD NVAR ; D V DA INT YI NORD NVAR ;
*FOX  D V DA INT DXI NORD NVAR ; D V DA INT DYI NORD NVAR ;
*FOX  D V RE INT EMBL ; D V RE INT TX ; D V RE INT TY ;
*FOX  D V RE INT DX ; D V RE INT DY ;
*FOX  D V RE INT XCLO ; D V RE INT YCLO ;
*FOX  D V RE INT CHI ;
*FOX  D V RE INT CUR ;
*FOX  D V RE INT L ; D V RE INT ONE ; D V RE INT TWO ;
*FOX  D V RE INT C1M7 ;
*FOX  D V RE INT C1E3 ; D V RE INT C1M3 ;
*FOX  D V DA INT RTWO_ NORD NVAR ; 
*FOX  D V RE INT NNORM_ ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!-- WIRE
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I
!     magnetic rigidity

      CHI = (sqrt(e0**2-pmap**2)*c1e6)/clight
      TX = wire_tiltx(ix) !tilt x [degrees] 
      TY = wire_tilty(ix) !tilt y [degrees]
      TX = TX*(pi/180.0d0) ![rad]
      TY = TY*(pi/180.0d0) ![rad]
      DX = wire_dispx(ix) !displacement x [mm]
      DY = wire_dispy(ix) !displacement y [mm]
      EMBL = wire_lint(ix) !integrated length [m]
      L = wire_lphys(ix) !physical length [m]
      CUR = wire_current(ix)
      XCLO = wire_clo(1,wire_num(i))
      YCLO = wire_clo(2,wire_num(i))
      NNORM_=c1m7/chi

      if (abs(wire_flagco(ix)).ne.1) then
        write(lout,
     &fmt='((A,A,/),(A,I0,A,A,/),(A,I0,A,I0,/))')
     &'ERROR: in wirekick -  wire_flagco defined in WIRE block must ',
     &'be either 1 or -1!','bez(',ix,') = ',bez(ix),
     &'wire_flagco(',ix,') = ',wire_flagco(ix)
        call prror(-1)
      endif

*FOX  YY(1)=YY(1)*C1M3;
*FOX  YY(2)=YY(2)*C1M3;

!*FOX  DXI=DX*C1M3;
!*FOX  DYI=DY*C1M3;
      IF (wire_flagco(ix).eq.1) THEN
*FOX  DXI=(DX+XCLO)*C1M3;
*FOX  DYI=(DY+YCLO)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
*FOX  DXI=DX*C1M3;
*FOX  DYI=DY*C1M3;
      END IF



!-----------------------------------------------------------------------
! X' -> PX'; Y' -> PY
*FOX  YY(1)=YY(1)*(ONE+DPDA) ;
*FOX  YY(2)=YY(2)*(ONE+DPDA) ;

! 1 SHIFT - see the part of the code were wireda is called ....

      IF (wire_flagco(ix).eq.1) THEN
*FOX  XI=(XX(1)+DX)*C1M3;
*FOX  YI=(XX(2)+DY)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
*FOX  XI=(XX(1)+(DX-XCLO))*C1M3;
*FOX  YI=(XX(2)+(DY-YCLO))*C1M3;
      END IF

! ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
*FOX  YI=YI-((XI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
*FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
*FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

*FOX  XI=XI-((YI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
*FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
*FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
*FOX  RTWO_=XI*XI+YI*YI;
*FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
*FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;

! ibeco =1
      elseif(ibeco.eq.1) then

*FOX  DYI=DYI-((DXI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
*FOX  DXI=DXI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
*FOX  YI=YI-XI*SIN(TX)*YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
*FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
*FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

*FOX  DXI=DXI-((DYI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
*FOX  DYI=DYI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
*FOX  XI=XI-YI*SIN(TY)*YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
*FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
*FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
*FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
*FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
*FOX  RTWO_=XI*XI+YI*YI;
*FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
*FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
*FOX  RTWO_=DXI*DXI+DYI*DYI;
*FOX  YY(1)=YY(1)+(((CUR*NNORM_)*DXI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
*FOX  YY(2)=YY(2)+(((CUR*NNORM_)*DYI)
*FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
*FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
      endif

! 4 symplectic backward rotation of coordinate system (-ty, -tx)
*FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TY) ;
*FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
*FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TX) ;

! PX -> X'; PY -> Y'
*FOX  YY(1)=YY(1)/(ONE+DPDA) ;
*FOX  YY(2)=YY(2)/(ONE+DPDA) ;

*FOX  YY(1)=YY(1)*C1E3;
*FOX  YY(2)=YY(2)*C1E3;

!     DADAL AUTOMATIC INCLUSION
      end
+dk runcav
      subroutine runcav
!-----------------------------------------------------------------------
!               DIFFERENTIAL ALGEBRA FOR CAVITY
!                          AUGUST 1994
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer idaa
      double precision betr0,dare,sigmdac
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonxz
+ca commonm1
+ca commond1
      save
!-----------------------------------------------------------------------
+ca daini
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      betr0=sqrt(one-(pma/e0)**2)
      write(lout,*) ' REENTERING MAP '
      call davar(x(1),zero,1)
      call davar(yp(1),zero,2)
      call davar(x(2),zero,3)
      call davar(yp(2),zero,4)
      call davar(sigmda,zero,5)
      call davar(dpda1,zero,6)
      call darea(x(1),18)
      call darea(yp(1),18)
      call darea(x(2),18)
      call darea(yp(2),18)
      call darea(sigmda,18)
      call darea(dpda1,18)
      rewind 18
!Eric
        rewind 111
      if(ition.ne.0) then
      e0f=sqrt(e0**2-pma**2)                                             !hr08
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  EJF1=E0F*(ONE+DPDA) ;
*FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
*FOX  EJF0=EJF1 ;
        if(abs(dppoff).gt.pieni) then
          sigmdac=sigmoff(iicav)
*FOX  SIGMDA=SIGMDA-SIGMDAC ;
        endif
        call synoda
*FOX  DPDA=DPDA1*C1M3 ;
*FOX  Y(1)=YP(1)/(ONE+DPDA) ;
*FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      endif
      if(nvar2.ge.1) call dapri(x(1),18)
      if(nvar2.ge.2) call dapri(yp(1),18)
      if(nvar2.ge.3) call dapri(x(2),18)
      if(nvar2.ge.4) call dapri(yp(2),18)
      if(nvar2.eq.5) call dapri(dpda1,18)
      if(nvar2.eq.6) call dapri(sigmda,18)
      if(nvar2.eq.6) call dapri(dpda1,18)
      
      write(lout,*) 'END COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      
      write(12,*) dare(x(1))
      write(12,*) dare(y(1))
      write(12,*) dare(x(2))
      write(12,*) dare(y(2))
      write(12,*) dare(sigmda)
      write(12,*) dare(dpda)
      
      write(lout,10010)
!-----------------------------------------------------------------------
!     DADAL AUTOMATIC INCLUSION
      time2=0.
      call timex(time2)
!     time=time2-time1
      write(lout,10020) time1-time0
      write(lout,10030) nord,time2-time1
      return
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. ',     &
     &i7,' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,              &
     &'HORIZ:  AMPLITUDE = ',f15.3,'   APERTURE = ',f15.3/ t10,         &
     &'VERT:   AMPLITUDE = ',f15.3,'   APERTURE = ',f15.3/ t10,         &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
10010 format(//t10,30('*')/t10,'**** ONE TURN COMPLETED ****'/ t10,30(  &
     &'*')/)
10020 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10030 format(/10x,'DA-Calculation of Order : ',i7,' took ', f12.3,      &
     &' second(s) of CPU Time'//131('-')//)
      end
+dk synoda
      subroutine synoda
!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!        SPECIALLY PREPARED FOR NEW D.A.
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ix,idaa
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commond1
+ca commonm1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
+ca dainicom
*FOX  D V RE INT E0 ; D V RE INT PMA ; D V RE EXT E0F ;
*FOX  D V RE INT HSY 3 ; D V RE INT PHAS ;
*FOX  D V RE EXT ED NELE ; D V RE EXT HSYC NELE ;
*FOX  D V RE EXT PHASC NELE ;
*FOX  D V RE INT C1E3 ; D V RE INT ONE ;
*FOX  D V IN EXT ITIONC NELE ; D V IN INT ITION ; D V IN INT IX ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      ix=ixcav
      if(kz(ix).eq.12) then
*FOX  EJ1=EJ1+ED(IX)*SIN(HSYC(IX)*SIGMDA/C1E3*
*FOX  ITIONC(IX)+PHASC(IX)) ;
      else
*FOX  EJ1=EJ1+HSY(1)*SIN(HSY(3)*SIGMDA/C1E3*ITION+PHAS) ;
      endif
*FOX  EJF1=SQRT(EJ1*EJ1-PMA*PMA) ;
*FOX  DPDA1=(EJF1-E0F)/E0F*C1E3 ;
      return
      end
+dk errff
      subroutine errff(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! PURPOSE:                                                             *
!   MODIFICATION OF WWERF, DOUBLE PRECISION COMPLEX ERROR FUNCTION,    *
!   WRITTEN AT CERN BY K. KOELBIG.                                     *
!   TAKEN FROM MAD8                                                    *
!   VERSION FOR MAP PRODUCTION USING BERZ'S DA PACKAGE                 *
! INPUT:                                                               *
!   XX, YY    (REAL)    ARGUMENT TO CERF.                              *
! OUTPUT:                                                              *
!   WX, WY    (REAL)    FUNCTION RESULT.                               *
!----------------------------------------------------------------------*
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer n,n1,nc,nuu,nuu1,idaa
      double precision cc,dare,dum,xlim,ylim
+ca parpro
+ca parnum
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonl
+ca commonxz
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT XX NORD NVAR ; D V DA EXT YY NORD NVAR ;
*FOX  D V DA EXT WX NORD NVAR ; D V DA EXT WY NORD NVAR ;
*FOX  D V DA INT X NORD NVAR ; D V DA INT Y NORD NVAR ;
*FOX  D V DA INT Q NORD NVAR ; D V DA INT H NORD NVAR ;
*FOX  D V DA INT XH NORD NVAR ; D V DA INT YH NORD NVAR ;
*FOX  D V DA INT RX NORD NVAR 33 ; D V DA INT RY NORD NVAR 33 ;
*FOX  D V DA INT TX NORD NVAR ; D V DA INT TN NORD NVAR ;
*FOX  D V DA INT TY NORD NVAR ;D V DA INT SAUX NORD NVAR ;
*FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
*FOX  D V DA INT XL NORD NVAR ;
*FOX  D V RE INT XLIM ; D V RE INT YLIM ; D V RE INT TWO ;
*FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT HALF ;
*FOX  D V RE INT CC ; D V RE INT DUM ;
*FOX  D V IN INT NC ; D V IN INT N ; D V IN INT N1 ; D V IN INT NUU ;
*FOX  D V IN INT NUU1 ; D V IN INT NCC ;
*FOX  D F RE DARE 1 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
*FOX  X=XX ;
*FOX  Y=YY ;
      if(dare(x).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(x) < 0'
*FOX    X=-X ;
      endif
      if(dare(y).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(y) < 0'
*FOX    Y=-Y ;
      endif
      if(dare(y).lt.ylim.and.dare(x).lt.xlim) then
*FOX    Q=(ONE-Y/YLIM)*SQRT(ONE-X*X/XLIM/XLIM) ;
*FOX    DUM=3.2D0 ;
*FOX    H=ONE/(DUM*Q) ;
        nc=7+int(23.0d0*dare(q))
*FOX    XL=EXP((1-NC)*LOG(H)) ;
*FOX    XH=Y+HALF/H ;
*FOX    YH=X ;
        nuu=10+int(21.0d0*dare(q))
        nuu1=nuu+1
*FOX    RX(NUU1)=ZERO ;
*FOX    RY(NUU1)=ZERO ;
        do 10 n=nuu,1,-1
          n1=n+1
*FOX      TX=XH+N*RX(N1) ;
*FOX      TY=YH-N*RY(N1) ;
*FOX      TN=TX*TX+TY*TY ;
*FOX      RX(N)=HALF*TX/TN ;
*FOX      RY(N)=HALF*TY/TN ;
   10   continue
*FOX    SX=ZERO ;
*FOX    SY=ZERO ;
        do 20 n=nc,1,-1
*FOX      SAUX=SX+XL ;
*FOX      SX=RX(N)*SAUX-RY(N)*SY ;
*FOX      SY=RX(N)*SY+RY(N)*SAUX ;
*FOX      XL=H*XL ;
   20   continue
*FOX    WX=CC*SX ;
*FOX    WY=CC*SY ;
      else
*FOX    XH=Y ;
*FOX    YH=X ;
*FOX    RX(1)=ZERO ;
*FOX    RY(1)=ZERO ;
        do 30 n=9,1,-1
*FOX      TX=XH+N*RX(1) ;
*FOX      TY=YH-N*RY(1) ;
*FOX      TN=TX*TX+TY*TY ;
*FOX      RX(1)=HALF*TX/TN ;
*FOX      RY(1)=HALF*TY/TN ;
   30   continue
*FOX    WX=CC*RX(1) ;
*FOX    WY=CC*RY(1) ;
      endif
!      if(dare(y).eq.0.) then
!*FOX    WX=EXP(-X*X) ;
!      endif
      if(dare(yy).lt.0.d0) then                                          !hr05
*FOX    WX=TWO*EXP(Y*Y-X*X)*COS(TWO*X*Y)-WX ;
*FOX    WY=-TWO*EXP(Y*Y-X*X)*SIN(TWO*X*Y)-WY ;
        if(dare(xx).gt.0.d0) then                                        !hr05
*FOX      WY=-WY ;
        endif
      else
        if(dare(xx).lt.0.d0) then                                        !hr05
*FOX      WY=-WY ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      return
      end
+dk beam6df
      subroutine beaminf(track,param,sigzs,bcu,ibb,ne,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999         
!
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ibb,ibbc,ne,nsli,idaa
      double precision alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,star,tphi,phi2,cphi2,sphi2,tphi2
+ca parpro
+ca parnum
+ca commondl
      dimension param(nele,18),bcu(nbb,12),star(3,mbea)
+if bnlelens
+ca rhicelens
+ei
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT TRACK NORD NVAR 6 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/dble(nsli)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/dble(nsli)
         !sepax=param(ne,5)     !Not actually used anywhere?
         !sepay=param(ne,6)     !Not actually used anywhere?
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beaminf"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
+if crlibm
      sphi=sin_rn(phi)
      sphi2=sin_rn(phi2)
+ei
+if .not.crlibm
      sphi=sin(phi)
      sphi2=sin(phi2)
+ei
+if crlibm
      cphi=cos_rn(phi)
      cphi2=cos_rn(phi2)
+ei
+if .not.crlibm
      cphi=cos(phi)
      cphi2=cos(phi2)
+ei
+if crlibm
      tphi=tan_rn(phi)
      tphi2=tan_rn(phi2)
+ei
+if .not.crlibm
      tphi=tan(phi)
      tphi2=tan(phi2)
+ei
+if crlibm
      salpha=sin_rn(alpha)
+ei
+if .not.crlibm
      salpha=sin(alpha)
+ei
+if crlibm
      calpha=cos_rn(alpha)
+ei
+if .not.crlibm
      calpha=cos(alpha)
+ei
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boostf(sphi,cphi,tphi,salpha,calpha,track)
      call sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
      call boostif(sphi,cphi,tphi,salpha,calpha,track)
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine boostf(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
! BOOSTF Boost Operation *******************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer idaa
      double precision calpha,cphi,salpha,sphi,tphi,cphi2,sphi2,tphi2    &
+ca parpro
+ca parnum
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A NORD NVAR ;
*FOX  D V DA INT H NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
*FOX  D V DA INT A1 NORD NVAR ; D V DA INT HD1 NORD NVAR ;
*FOX  D V DA INT H1X NORD NVAR ; D V DA INT H1Y NORD NVAR ;
*FOX  D V DA INT H1Z NORD NVAR ; D V DA INT X1 NORD NVAR ;
*FOX  D V DA INT Y1 NORD NVAR ;
*FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
*FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
*FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
*FOX  D V RE INT ONE ; D V RE INT C1E3 ;
*FOX  D V DA INT DET NORD NVAR ; D V DA INT H1 NORD NVAR ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
*FOX    H=TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
*FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
*FOX    TRACK(6)=TRACK(6)-CALPHA*TPHI*TRACK(2)
*FOX              -TRACK(4)*SALPHA*TPHI+H*TPHI*TPHI ;
*FOX    TRACK(2)=(TRACK(2)-TPHI*H*CALPHA)/CPHI ;
*FOX    TRACK(4)=(TRACK(4)-TPHI*H*SALPHA)/CPHI ;
*FOX    HD1=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-TRACK(2)*TRACK(2)-
*FOX    TRACK(4)*TRACK(4)) ;
*FOX    H1X=TRACK(2)/HD1 ;
*FOX    H1Y=TRACK(4)/HD1 ;
*FOX    H1Z=ONE-(ONE+TRACK(6))/HD1 ;
*FOX    X1=CALPHA*TPHI*TRACK(5)+(ONE+CALPHA*SPHI*H1X)*TRACK(1)
*FOX       +TRACK(3)*SALPHA*SPHI*H1X ;
*FOX    Y1=SALPHA*TPHI*TRACK(5)+(ONE+SALPHA*SPHI*H1Y)*TRACK(3)
*FOX       +TRACK(1)*CALPHA*SPHI*H1Y ;
*FOX    TRACK(5)=TRACK(5)/CPHI+H1Z*(SPHI*CALPHA*TRACK(1)
*FOX       +SPHI*SALPHA*TRACK(3)) ;
*FOX    TRACK(1)=X1 ;
*FOX    TRACK(3)=Y1 ;
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**SBCF ***Synchro-Beam for headon collision*********************
!****************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ibb,ibbc,ibbc1,jsli,nsli,idaa
      double precision bcu,cphi,cphi2,dare,f,sfac,star
+ca parpro
+ca parnum
+ca commondl
      dimension star(3,mbea),bcu(nbb,12)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT TRACK NORD NVAR 6 ;
*FOX  D V DA INT S NORD NVAR ; D V DA INT SP NORD NVAR ;
*FOX  D V DA INT DD NORD NVAR ;
*FOX  D V DA INT DUM NORD NVAR 13 ;
*FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
*FOX  D V DA INT SEPX NORD NVAR ; D V DA INT SEPY NORD NVAR ;
*FOX  D V DA INT SEPX0 NORD NVAR ; D V DA INT SEPY0 NORD NVAR ;
*FOX  D V DA INT COSTH NORD NVAR ; D V DA INT SINTH NORD NVAR ;
*FOX  D V DA INT COSTHP NORD NVAR ; D V DA INT SINTHP NORD NVAR ;
*FOX  D V DA INT BBFX NORD NVAR ; D V DA INT BBFY NORD NVAR ;
*FOX  D V DA INT BBF0 NORD NVAR ; D V DA INT BBGX NORD NVAR ;
*FOX  D V DA INT BBGY NORD NVAR ;
*FOX  D V RE EXT STAR 3 MBEA ; D V RE EXT F ; D V RE EXT BCU NBB 12 ;
*FOX  D V IN EXT IBB ;
*FOX  D V RE INT HALF ; D V RE INT TWO ; D V RE INT FOUR ;
*FOX  D V RE INT ZERO ; D V RE INT ONE ; D V RE INT C1E3 ;
*FOX  D V RE INT SFAC ; D V RE INT CPHI ; D V RE INT CPHI2 ;
*FOX  D V IN INT JSLI ;
*FOX  D F RE DARE 1 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
*FOX    S=(TRACK(5)-STAR(3,JSLI))*HALF ;
*FOX    SP=S/CPHI2 ;
*FOX    DUM(1)=BCU(IBB,1)+TWO*BCU(IBB,4)*SP+BCU(IBB,6)*SP*SP ;
*FOX    DUM(2)=BCU(IBB,2)+TWO*BCU(IBB,9)*SP+BCU(IBB,10)*SP*SP ;
*FOX    DUM(3)=BCU(IBB,3)+(BCU(IBB,5)+BCU(IBB,7))*SP+
*FOX    BCU(IBB,8)*SP*SP ;
*FOX    DUM(4)=DUM(1)-DUM(2) ;
*FOX    DUM(5)=DUM(4)*DUM(4)+FOUR*DUM(3)*DUM(3) ;
        if(ibbc.eq.1.and.(abs(dare(dum(4))).gt.pieni.and.               &
     &abs(dare(dum(5))).gt.pieni)) then
          ibbc1=1
*FOX    DUM(5)=SQRT(DUM(5)) ;
        else
          ibbc1=0
        endif
*FOX    SEPX0=TRACK(1)+TRACK(2)*S-STAR(1,JSLI) ;
*FOX    SEPY0=TRACK(3)+TRACK(4)*S-STAR(2,JSLI) ;
        if(ibbc1.eq.1) then
          sfac=one
          if(dare(dum(4)).lt.zero) sfac=(-1d0*one)                       !hr05
*FOX    DUM(6)=SFAC*DUM(4)/DUM(5) ;
*FOX    DUM(7)=DUM(1)+DUM(2) ;
*FOX    COSTH=HALF*(ONE+DUM(6)) ;
          if(abs(dare(costh)).gt.pieni) then
*FOX    COSTH=SQRT(COSTH) ;
          else
*FOX    COSTH=ZERO ;
          endif
*FOX    SINTH=HALF*(ONE-DUM(6)) ;
          if(abs(dare(sinth)).gt.pieni) then
*FOX    SINTH=-SFAC*SQRT(SINTH) ;
          else
*FOX    SINTH=ZERO ;
          endif
          if(dare(dum(3)).lt.zero) then
*FOX    SINTH=-SINTH ;
          endif
*FOX    SY=SFAC*DUM(5) ;
*FOX    SX=(DUM(7)+SY)*HALF ;
*FOX    SY=(DUM(7)-SY)*HALF ;
*FOX    SEPX=SEPX0*COSTH+SEPY0*SINTH ;
*FOX    SEPY=-SEPX0*SINTH+SEPY0*COSTH ;
        else
*FOX    SX=DUM(1) ;
*FOX    SY=DUM(2) ;
*FOX    SEPX=SEPX0 ;
*FOX    SEPY=SEPY0 ;
        endif
        if(dare(sx).gt.dare(sy)) then
          call bbff(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy)
        else
          call bbff(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx)
        endif
*FOX    BBFX=F*BBFX ;
*FOX    BBFY=F*BBFY ;
*FOX    BBGX=F*BBGX ;
*FOX    BBGY=F*BBGY ;
        if(ibbc1.eq.1) then
*FOX    DUM(8)=TWO*(BCU(IBB,4)-BCU(IBB,9)+(BCU(IBB,6)-BCU(IBB,10))*SP) ;
*FOX    DUM(9)=BCU(IBB,5)+BCU(IBB,7)+TWO*BCU(IBB,8)*SP ;
*FOX    DUM(10)=(DUM(4)*DUM(8)+FOUR*DUM(3)*DUM(9))/
*FOX    DUM(5)/DUM(5)/DUM(5) ;
*FOX    DUM(11)=SFAC*(DUM(8)/DUM(5)-DUM(4)*DUM(10)) ;
*FOX    DUM(12)=BCU(IBB,4)+BCU(IBB,9)+(BCU(IBB,6)+BCU(IBB,10))*SP ;
*FOX    DUM(13)=SFAC*(DUM(4)*DUM(8)*HALF+TWO*DUM(3)*DUM(9))/DUM(5) ;
          if(abs(dare(costh)).gt.pieni) then
*FOX    COSTHP=DUM(11)/FOUR/COSTH ;
          else
*FOX    COSTHP=ZERO ;
          endif
          if(abs(dare(sinth)).gt.pieni) then
*FOX    SINTHP=-DUM(11)/FOUR/SINTH ;
          else
*FOX    SINTHP=ZERO ;
          endif
*FOX    TRACK(6)=TRACK(6)-
*FOX    (BBFX*(COSTHP*SEPX0+SINTHP*SEPY0)+
*FOX    BBFY*(-SINTHP*SEPX0+COSTHP*SEPY0)+
*FOX    BBGX*(DUM(12)+DUM(13))+BBGY*(DUM(12)-DUM(13)))/
*FOX    CPHI*HALF ;
*FOX    BBF0=BBFX ;
*FOX    BBFX=BBF0*COSTH-BBFY*SINTH ;
*FOX    BBFY=BBF0*SINTH+BBFY*COSTH ;
        else
*FOX    TRACK(6)=TRACK(6)-
*FOX    (BBGX*(BCU(IBB,4)+BCU(IBB,6)*SP)+
*FOX    BBGY*(BCU(IBB,9)+BCU(IBB,10)*SP))/CPHI ;
        endif
*FOX    TRACK(6)=TRACK(6)-(BBFX*(TRACK(2)-BBFX*HALF)+
*FOX    BBFY*(TRACK(4)-BBFY*HALF))*HALF ;
*FOX    TRACK(1)=TRACK(1)+S*BBFX ;
*FOX    TRACK(2)=TRACK(2)-BBFX ;
*FOX    TRACK(3)=TRACK(3)+S*BBFY ;
*FOX    TRACK(4)=TRACK(4)-BBFY ;
 2000 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine boostif(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
! BOOSTIF **************inverse boost ****************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer idaa
      double precision calpha,cphi,salpha,sphi,tphi
+ca parpro
+ca parnum
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A1 NORD NVAR ;
*FOX  D V DA INT H1 NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
*FOX  D V DA INT H1D NORD NVAR ; D V DA INT H1X NORD NVAR ;
*FOX  D V DA INT H1Y NORD NVAR ; D V DA INT H1Z NORD NVAR ;
*FOX  D V DA INT DET NORD NVAR ; D V DA INT X1 NORD NVAR ;
*FOX  D V DA INT Y1 NORD NVAR ; D V DA INT Z1 NORD NVAR ;
*FOX  D V RE INT ONE ; D V RE INT TWO ;
*FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
*FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
*FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
*FOX    H1D=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
*FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
*FOX    H1X=TRACK(2)/H1D ;
*FOX    H1Y=TRACK(4)/H1D ;
*FOX    H1Z=ONE-(ONE+TRACK(6))/H1D ;
*FOX    H1=(TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
*FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)))*CPHI*CPHI ;
*FOX    DET=ONE/CPHI+TPHI*(H1X*CALPHA+H1Y*SALPHA-H1Z*SPHI) ;
*FOX    X1= TRACK(1)*(ONE/CPHI+SALPHA*(H1Y-H1Z*SALPHA*SPHI)*TPHI)
*FOX       +TRACK(3)*SALPHA*TPHI*(-H1X+H1Z*CALPHA*SPHI)
*FOX       -TRACK(5)*(CALPHA+H1Y*CALPHA*SALPHA*SPHI
*FOX       -H1X*SALPHA*SALPHA*SPHI)*TPHI ;
*FOX    Y1= TRACK(1)*CALPHA*TPHI*(-H1Y+H1Z*SALPHA*SPHI)
*FOX       +TRACK(3)*(ONE/CPHI+CALPHA*(H1X-H1Z*CALPHA*SPHI)*TPHI)
*FOX       -TRACK(5)*(SALPHA-H1Y*CALPHA*CALPHA*SPHI
*FOX       +H1X*CALPHA*SALPHA*SPHI)*TPHI ;
*FOX    Z1=-TRACK(1)*H1Z*CALPHA*SPHI
*FOX       -TRACK(3)*H1Z*SALPHA*SPHI
*FOX       +TRACK(5)*(ONE+H1X*CALPHA*SPHI+H1Y*SALPHA*SPHI) ;
*FOX    TRACK(1)=X1/DET ;
*FOX    TRACK(3)=Y1/DET ;
*FOX    TRACK(5)=Z1/DET ;
*FOX    TRACK(6)=TRACK(6)+CALPHA*SPHI*TRACK(2)
*FOX            +SALPHA*SPHI*TRACK(4) ;
*FOX    TRACK(2)=(TRACK(2)*CPHI+CALPHA*TPHI*H1) ;
*FOX    TRACK(4)=(TRACK(4)*CPHI+SALPHA*TPHI*H1) ;
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine bbff(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**********************************************************************
! BBFF gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer idaa
      double precision dare,hundred,sqrpi2
+ca parpro
+ca parnum
      parameter(sqrpi2 = 3.544907701811032d0,hundred = 100d0)
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
*FOX  B D ;
*FOX  D V DA EXT SEPX NORD NVAR ; D V DA EXT SEPY NORD NVAR ;
*FOX  D V DA EXT SIGXX NORD NVAR ; D V DA EXT SIGYY NORD NVAR ;
*FOX  D V DA EXT BBFX NORD NVAR ; D V DA EXT BBFY NORD NVAR ;
*FOX  D V DA EXT BBGX NORD NVAR ; D V DA EXT BBGY NORD NVAR ;
*FOX  D V DA INT SIGXY NORD NVAR ; D V DA INT EXPFAC NORD NVAR ;
*FOX  D V DA INT X NORD NVAR ; D V DA INT FAC NORD NVAR ;
*FOX  D V DA INT FAC2 NORD NVAR ; D V DA INT CONST NORD NVAR ;
*FOX  D V DA INT ARG1X NORD NVAR ; D V DA INT ARG1Y NORD NVAR ;
*FOX  D V DA INT ARG2X NORD NVAR ; D V DA INT ARG2Y NORD NVAR ;
*FOX  D V DA INT WX1 NORD NVAR ; D V DA INT WY1 NORD NVAR ;
*FOX  D V DA INT WX2 NORD NVAR ; D V DA INT WY2 NORD NVAR ;
*FOX  D V DA INT COMFAC NORD NVAR ; D V DA INT COMFAC2 NORD NVAR ;
*FOX  D V RE INT ZERO ; D V RE INT HALF ; D V RE INT ONE ;
*FOX  D V RE INT TWO ; D V RE INT FOUR ; D V RE INT HUNDRED ;
*FOX  D V RE INT SQRPI2 ;
*FOX  D F RE DARE 1 ;
*FOX  E D ;
*FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if(dare(sigxx).eq.dare(sigyy)) then
*FOX    X=SEPX*SEPX+SEPY*SEPY ;
        if(abs(dare(sigxx)+dare(sigyy)).gt.pieni) then
*FOX      CONST=X/(SIGXX+SIGYY) ;
        else
*FOX      CONST=ZERO ;
        endif
*FOX    EXPFAC=EXP(-CONST) ;
        if(abs(dare(x)).gt.pieni) then
*FOX      BBFX=TWO*SEPX*(ONE-EXPFAC)/X ;
*FOX      BBFY=TWO*SEPY*(ONE-EXPFAC)/X ;
*FOX      COMFAC=-SEPX*BBFX+SEPY*BBFY ;
          if(dare(sigxx).lt.zero) then
*FOX        SIGXX=-SIGXX ;
          endif
          if(dare(sigyy).lt.zero) then
*FOX        SIGYY=-SIGYY ;
          endif
*FOX      COMFAC2=(SIGXX+SIGYY)*(SIGXX+SIGYY) ;
*FOX      BBGX=(COMFAC+FOUR*SEPX*SEPX*CONST/X*EXPFAC)/(TWO*X) ;
*FOX      BBGY=(-COMFAC+FOUR*SEPY*SEPY*CONST/X*EXPFAC)/(TWO*X) ;
        else
*FOX      BBFX=ZERO ;
*FOX      BBFY=ZERO ;
*FOX      BBGX=ZERO ;
*FOX      BBGY=ZERO ;
        endif
      else
*FOX    X=SEPX*SEPX/SIGXX+SEPY*SEPY/SIGYY ;
*FOX    FAC2=TWO*(SIGXX-SIGYY) ;
        if(dare(sigxx).lt.dare(sigyy)) then
*FOX      FAC2=TWO*(SIGYY-SIGXX) ;
        endif
*FOX    FAC=SQRT(FAC2) ;
*FOX    CONST=SQRPI2/FAC ;
*FOX    SIGXY=SQRT(SIGXX/SIGYY) ;
*FOX    ARG1X=(SEPX/FAC) ;
        if(dare(sepx).lt.zero) then
*FOX      ARG1X=-(SEPX/FAC) ;
        endif
*FOX    ARG1Y=(SEPY/FAC) ;
        if(dare(sepy).lt.zero) then
*FOX      ARG1Y=-(SEPY/FAC) ;
        endif
        call errff(arg1x,arg1y,wy1,wx1)
        if(dare(x).lt.hundred) then
*FOX      EXPFAC=EXP(-X*HALF) ;
*FOX      ARG2X=ARG1X/SIGXY ;
*FOX      ARG2Y=ARG1Y*SIGXY ;
          call errff(arg2x,arg2y,wy2,wx2)
*FOX      BBFX=CONST*(WX1-EXPFAC*WX2) ;
*FOX      BBFY=CONST*(WY1-EXPFAC*WY2) ;
          if(dare(sepx).lt.zero) then
*FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
*FOX        BBFY=-BBFY ;
          endif
*FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
*FOX      BBGX=-(COMFAC+TWO*(EXPFAC/SIGXY-ONE))/FAC2 ;
*FOX      BBGY= (COMFAC+TWO*(EXPFAC*SIGXY-ONE))/FAC2 ;
        else
*FOX      BBFX=CONST*WX1 ;
*FOX      BBFY=CONST*WY1 ;
          if(dare(sepx).lt.zero) then
*FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
*FOX        BBFY=-BBFY ;
          endif
*FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
*FOX      BBGX=-(COMFAC-TWO)/FAC2 ;
*FOX      BBGY= -BBGX ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      return
      end
+dk maincr
      program maincr
+if datamods
      use bigmats
+ei
      use, intrinsic :: iso_fortran_env, only : output_unit
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  F. SCHMIDT, M. VANTTINEN
!
!  COLLIMATION VERSION, NOVEMBER 2004
!
!  G. ROBERT-DEMOLAIZE
!
!  COLLIMATION UPGRADE, JUNE 2005
!
!  G. ROBERT-DEMOLAIZE, S. REDAELLI
!
!-----------------------------------------------------------------------
!  SIXTRACR CHECKPOINT/RESTART and CRLIBM (ENS Lyon)
!
!  E. MCINTOSH FEBRUARY 2005
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!  DATA FOR SUMMARY OF THE POSTPROCESSING   : UNIT 10
!  AUXILIARY FILE FOR THE INPUT             : UNIT 11
!  ASCII FILE WITH THE HORIZONTAL FFT DATA  : UNIT 14
!  ASCII FILE WITH THE VERTICAL FFT DATA    : UNIT 15
!  METAFILE FOR PLOTTING WITH GKS           : UNIT 20
!
+if cr
!  CHECKPOINT/RESTART FILES                 : UNIT 95,96
!  OPTIONAL DUMP.DEBUG FILE                 : UNIT 99
!  PROGRESS FILE                            : UNIT 91
!  INTERMEDIATE OUTPUT FILE (LOUT)          : UNIT 92
!  CHECKPOINT/RESTART LOGFILE               : UNIT 93
!  TEMPORARY SCRATCH FILE for C/R           : UNIT 94
+ei
!-----------------------------------------------------------------------
+ca parpro
+ca parnum
+ca common
+ca commonex
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
! Eric needs nwri (clean up new variables and common blocks!)
+ca commontr
+if bnlelens
+ca rhicelens
+ei
+ca commonc
+if cr
+ca crco
+ei
+ca comgetfields
+ca dbdump
+if cr
+ca dbdumpcr
+ei
+ca stringzerotrim
+ca comdynk
+ca fma
+ca zipf
      integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,&
     &idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
     &jm,k,kpz,kzz,l,lkk,ll,m,mkk,ncorruo,ncrr,nd,nd2,ndafi2,           &
     &nerror,nlino,nlinoo,nmz,nthinerr
      double precision alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
     &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
     &dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
     &gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
     &rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
     &tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
     &taus,x11,x13
      integer idummy(6)
      character*10 cmonth
      character*4 cpto
+if cr
      character*80 day
+ei
+if .not.cr
      character*80 day,runtim
+ei
      character*8 cdate,ctime,progrm
+if boinc
      character*256 filename
+ei
+if crlibm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
+ei
+if debug
!     integer umcalls,dapcalls,dokcalls,dumpl
!     common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
+ei
      logical lopen
      dimension cmonth(12)
      data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
     &'  April   ','   May    ','   June   ','   July   ',' August  ',  &
     &' September',' October  ',' November ',' December '/
+ca version
!-----------------------------------------------------------------------
+if crlibm
! Removed the call to disable_xp for Laurent
! but re-instated it
      call disable_xp()
+ei
+if debug
!     umcalls=0
!     dapcalls=0
!     dokcalls=0
!     dumpl=0
+ei
! Set napx,napxo,trtime for error handling
      napx=0
      napxo=0
      trtime=0.0
      napxto=0
      runtim=''
+if cr
      stxt=''
+ei
+if hdf5
       call INITHDF5()
+ei
+if boinc
      call boinc_init()
!     call boinc_init_graphics()
+ei
+if cr
! Main start for Checkpoint/Restart
      sythckcr=.false.
      numlcr=1
      rerun=.false.
      start=.true.
      restart=.false.
      checkp=.false.
      fort95=.false.
      fort96=.false.
      sixrecs=0
      binrec=0
      bnlrec=0
      bllrec=0
      do i=1,(npart+1)/2
        binrecs(i)=0
      enddo
      crtime3=0.
+if debug
                   !call system('../crmain  >> crlog')
+ei
+if boinc
 611  continue
+ei
      lout=92
!--   Very first get rid of any previous partial output
+if boinc
      call boincrf('fort.92',filename)
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
      rewind lout
      endfile (lout,iostat=ierro)
      close(lout)
+if boinc
      call boincrf('fort.92',filename)
+if fio
      open(lout,file=filename,form='formatted',status='unknown',        &
     &round='nearest')
+ei
+if .not.fio
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(lout,file='fort.92',form='formatted',status='unknown',       &
     &round='nearest')
+ei
+if .not.fio
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
+ei
!--   Now position the checkpoint/restart logfile=93
+if boinc
      call boincrf('fort.93',filename)
+if fio
      open(93,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(93,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(93,file='fort.93',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(93,file='fort.93',form='formatted',status='unknown')
+ei
+ei
  606 read(93,'(a1024)',end=607) arecord
      goto 606
  607 backspace (93,iostat=ierro)
! and if BOINC issue an informatory message
+if boinc
      if (start) then
        write(93,*) 'SIXTRACR starts very first time'
      else
        write(93,*) 'SIXTRACR retry after unzip of Sixin.zip'
      endif
+ei
! Now we see if we have a fort.6 which implies
! that we can perhaps just restart using all exisiting files
! including the last checkpoints
! if not, we just do a start (with an unzip for BOINC)
+if boinc
      call boincrf('fort.6',filename)
+if fio
      open(output_unit,
     &file=filename,form='formatted',status='old',err=602,
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,
     &file=filename,form='formatted',status='old',err=602)
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
+ei
+if .not.boinc
+if fio
      open(output_unit,
     &file='fort.6',form='formatted',status='old',err=602,
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,
     &file='fort.6',form='formatted',status='old',err=602)
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
+ei
      rerun=.true.
      goto 605
+if boinc
  602 continue
! No fort.6 so we do an unzip of Sixin.zip
! BUT ONLY IF WE HAVE NOT DONE IT ALREADY
! and CLOSE 92 and 93
      if (start) then
        start=.false.
        close(92)
        close(93)
! Now, if BOINC, after no fort.6, call UNZIP Sixin.zip
! name hard-wired in our boinc_unzip_.
! Either it is only the fort.* input data or it is a restart.
! Removed temporarily??? because of problems.
! Re-instated and REQUIRED version 4516
        !call boinc_unzip()
        !call system('unzip Sixin.zip')
        call f_read_archive("Sixin.zip",".")
        go to 611
      endif
+if fio
      open(output_unit,
     &file=filename,form='formatted',status='unknown',
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,
     &file=filename,form='formatted',status='unknown')
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
+ei
+if .not.boinc
+if fio
 602  open(output_unit,
     &file='fort.6',form='formatted',status='new',
     &round='nearest')
+ei
+if .not.fio
 602  open(output_unit,
     &file='fort.6',form='formatted',status='new')
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
+ei
!--   Now check for restart files fort.95/96 and OPEN them
+if boinc
  605 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='old',err=600)
+ei
+if .not.boinc
  605 open(95,file='fort.95',form='unformatted',status='old',err=600)
+ei
      fort95=.true.
      goto 608
+if boinc
  600 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='new')
+ei
+if .not.boinc
  600 open(95,file='fort.95',form='unformatted',status='new')
+ei
+if boinc
  608 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='old',err=601)
+ei
+if .not.boinc
  608 open(96,file='fort.96',form='unformatted',status='old',err=601)
+ei
      fort96=.true.
      goto 609
+if boinc
  601 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='new')
+ei
+if .not.boinc
  601 open(96,file='fort.96',form='unformatted',status='new')
+ei
+if boinc
  609 call boincrf('fort.91',filename)
+if fio
      open(91,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(91,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
  609 open(91,file='fort.91',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
  609 open(91,file='fort.91',form='formatted',status='unknown')
+ei
+ei
+ei ! END +if cr -- END of Main start for Checkpoint/Restart

+if .not.cr
      lout=output_unit
+ei
      
+if debug
                   !call system('../crmain  >> crlog')
+ei
!-----------------------------------------------------------------------
+ca open
      write(lout,10010) version,moddate
      tlim=1e7
      call timest(tlim)
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'st of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'nd of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'rd of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else
+if cr
        day=stxt//cdate(5:6)//'th of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)// &
     &'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(lout,'(a80)') runtim
+if cr
!     Log start messages
      write(93,*)
      write(93,*) 'SIXTRACR MAINCR ',runtim
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+ei
+if debug
                   !call system('../crmain  >> crlog')
+ei
!     A normal start, time0 is beginning
      pretime=0.0
      trtime=0.0
      posttime=0.0
      tottime=0.0
      time0=0.0
      time1=0.0
      time2=0.0
      time3=0.0
      tlim=1e7
      call timest(tlim)
      call timex(time0)
      do 10 i=1,nblz
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
   10 continue
      do 20 i=1,mmul
        cr(i)=zero
        ci(i)=zero
   20 continue
      do 30 i=1,2
        eps(i)=zero
        epsa(i)=zero
        ekk(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      do 60 i=1,npart
        nnumxv(i)=0
        xv(1,i)=zero
        xv(2,i)=zero
        yv(1,i)=zero
        yv(2,i)=zero
        dam(i)=zero
        ekkv(i)=zero
        sigmv(i)=zero
        dpsv(i)=zero
        dp0v(i)=zero
        ejv(i)=zero
        ejfv(i)=zero
        xlv(i)=zero
        zlv(i)=zero
        rvv(i)=one
+if rvet
        rvet(i)=zero
+ei
        ejf0v(i)=zero
        dpd(i)=zero
        dpsq(i)=zero
        fok(i)=zero
        rho(i)=zero
        fok1(i)=zero
        si(i)=zero
        co(i)=zero
        g(i)=zero
        gl(i)=zero
        sm1(i)=zero
        sm2(i)=zero
        sm3(i)=zero
        sm12(i)=zero
        as3(i)=zero
        as4(i)=zero
        as6(i)=zero
        sm23(i)=zero
        rhoc(i)=zero
        siq(i)=zero
        aek(i)=zero
        afok(i)=zero
        hp(i)=zero
        hm(i)=zero
        hc(i)=zero
        hs(i)=zero
        wf(i)=zero
        wfa(i)=zero
        wfhi(i)=zero
        rhoi(i)=zero
        hi(i)=zero
        fi(i)=zero
        hi1(i)=zero
        xvl(1,i)=zero
        xvl(2,i)=zero
        yvl(1,i)=zero
        yvl(2,i)=zero
        ejvl(i)=zero
        dpsvl(i)=zero
        oidpsv(i)=one
        sigmvl(i)=zero
        iv(i)=0
        aperv(i,1)=zero
        aperv(i,2)=zero
        ixv(i)=0
        clov(1,i)=zero
        clov(2,i)=zero
        clo6v(1,i)=zero
        clo6v(2,i)=zero
        clo6v(3,i)=zero
        clopv(1,i)=zero
        clopv(2,i)=zero
        clop6v(1,i)=zero
        clop6v(2,i)=zero
        clop6v(3,i)=zero
        alf0v(i,1)=zero
        alf0v(i,2)=zero
        bet0v(i,1)=zero
        bet0v(i,2)=zero
        ampv(i)=zero
+if .not.datamods !This code moved to bigmats.allocate_thickarrays
        do 40 i1=1,nblo
          do 40 i2=1,2
            do 40 i3=1,6
              hv(i3,i2,i,i1)=zero
              bl1v(i3,i2,i,i1)=zero
   40   continue
+ei
        do 50 i1=1,6
          do 50 i2=1,6
            tas(i,i1,i2)=zero
   50   continue
        qwcs(i,1)=zero
        qwcs(i,2)=zero
        qwcs(i,3)=zero
        di0xs(i)=zero
        di0zs(i)=zero
        dip0xs(i)=zero
        dip0zs(i)=zero
   60 continue
      qwc(3)=zero
      call comnul
      commen=' '
      progrm='SIXTRACK'
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      pi2=pi*half
      pisqrt=sqrt(pi)
      rad=pi/180d0                                                       !hr05
      call daten
+if datamods
      if (ithick.eq.1) call allocate_thickarrays(npart,nele,nblo)
+ei
+if debug
!     call dumpbin('adaten',999,9999)
!     call abend('after  daten                                      ')
+ei
+if debug.and.cr
!     write(93,*) 'ERIC IL= ',il
!     endfile (93,iostat=ierro)
!     backspace (93,iostat=ierro)
+ei
+if cr
      checkp=.true.
+if debug
                   !call system('../crmain  >> crlog')
+ei
      call crcheck
+ei
      if(ithick.eq.1) write(lout,10030)
      if(ithick.eq.0) write(lout,10040)
      if(ibidu.eq.2) then
        write(lout,10025)
        goto 550
      endif
!--SETTING UP THE PLOTTING
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call hlimit(nplo)
        call hplint(kwtype)
        call igmeta(-20,-111)
        cpto='NPTO'
        if(icr.eq.1) cpto='PTO '
        call hplopt(cpto,1)
        call hplopt('DATE',1)
        call hplset('DATE',1.)
        call hplset('CSIZ',.15)
      endif

      !Postprocessing is on, but there are no particles
      if(ipos.eq.1.and.napx.eq.0) then
! and now we open fort.10 unless already opened for
! BOINC AND BNLELENS

+if nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',         &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei ! END +if nagfor

+if .not.nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei ! END +if .not.bnlelens
+ei ! END +if boinc
+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown')
+ei
+ei ! END +if .not.boinc
+ei ! END +if .not.nagfor

+if .not.stf
      do 70 i=1,ndafi !ndafi = number of files to postprocess (set by fort.3)
+if .not.cr
         call postpr(91-i)
+ei
+if cr
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(91-i,nnuml)
+ei
 70      continue
+ei ! END +if .not.stf
+if stf
!--   ndafi normally set in fort.3 to be "number of files to postprocess"
!--   Inside the postpr subroutine ndafi is modified as:
!--   ndafi=itopa(total particles) if once particle per header i.e ntwin=1,
!--   ndafi=itopa/2 if 2 particle per header i.e ntwin=2
      do 70 i=1,(2*ndafi),2
+if .not.cr
         call postpr(i)
+ei
+if cr
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(i,nnuml)
+ei
 70      continue
+ei ! END +if stf

      call sumpos
      goto 520 !Jump to after particle&optics initialization,
               ! and also after tracking.
      endif !if(ipos.eq.1.and.napx.eq.0)
      
      do 90 i=1,20
        fake(1,i)=zero
   90 fake(2,i)=zero
      itra=2
      amp00=amp(1)
      if(napx.ne.1) damp=((amp00-amp0)/dble(napx-1))/2d0                 !hr05
      napx=2*napx
      iation=abs(ition)
      ib0=0
      dp00=dp1
      if(napx.le.0.or.imc.le.0) goto 490
      do 260 m=1,mmac
+if debug
!       call warr('mmac and m',0d0,nmac,m,0,0)
!       write(*,*) 'do 260 mmac/m',mmac,m
+ei
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
        if(m.ge.2) then
          call recuin(m*izu0,irecuin)
          call ranecu(zfz,nzfz,mcut)
          rsum=zero
          do 100 i=1,nzfz
  100     rsum=rsum+zfz(i)
          rmean=rsum/dble(nzfz)                                          !hr05
          rsqsum=zero
          do 110 i=1,nzfz
  110     rsqsum=rsqsum+(zfz(i)-rmean)*(zfz(i)-rmean)
          rdev=sqrt(rsqsum/dble(nzfz))                                   !hr05
          write(lout,10320) m*izu0,nzfz,rmean,rdev
          write(lout,10070)
        endif
        if(m.eq.1) call ord
        call clorb(ded)
+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
        do 120 l=1,2
          clo0(l)=clo(l)
  120   clop0(l)=clop(l)
        call clorb(zero)
+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
        do 130 l=1,2
          ll=2*l
          di0(l)=(clo0(l)-clo(l))/ded
  130   dip0(l)=(clop0(l)-clop(l))/ded
        call corrorb
        if(irmod2.eq.1) call rmod(dp1)
        if(iqmod.ne.0) call qmod0
        if(ichrom.eq.1.or.ichrom.eq.3) call chroma
        if(iskew.ne.0) call decoup
        if(ilin.eq.1.or.ilin.eq.3) then
          call linopt(dp1)
        endif
+if debug
!     call dumpbin('bbb',96,996)
!     call abend('bbb                                               ')
+ei
!--beam-beam element
        nlino=nlin
        nlin=0
        if(nbeam.ge.1) then
          do 135 i=1,nele
            if(kz(i).eq.20) then
              nlin=nlin+1
              if(nlin.gt.nele) call prror(81)
              bezl(nlin)=bez(i)
            endif
  135     continue
        endif
        if(isub.eq.1) call subre(dp1)
        if(ise.eq.1) call search(dp1)
+if debug
!     call dumpbin('asearch',95,995)
!     call abend('asearch                                           ')
+ei

        !! Initialize kicks
        izu=0
        do 150 i=1,iu
+if debug
!       call warr('i/iu',0d0,i,iu,0,0)
!       write(*,*) 'do 150 i/iu',i,iu
+ei
          ix=ic(i)
          if(ix.le.nblo) goto 150
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 150
          if(kzz.eq.15) goto 150
          if(iorg.lt.0) mzu(i)=izu
          izu=mzu(i)+1
          smizf(i)=zfz(izu)*ek(ix)
          smiv(m,i)=sm(ix)+smizf(i) ! Also in initalize_element!
          smi(i)=smiv(m,i)          ! Also in initalize_element!
+if debug
!         call warr('smizf(i)',smizf(i),i,0,0,0)
!         call warr('smiv(m,i)',smiv(m,i),m,i,0,0)
!         call warr('smi(i)',smi(i),i,0,0,0)
+ei
          izu=izu+1
          xsiv(m,i)=xpl(ix)+zfz(izu)*xrms(ix)
          xsi(i)=xsiv(m,i)
          izu=izu+1
          zsiv(m,i)=zpl(ix)+zfz(izu)*zrms(ix)
          zsi(i)=zsiv(m,i)
          if(mout2.eq.1) then
            if(kzz.eq.11) zfz(izu-2)=zero
            if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
            if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
            if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
            write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),           &
     &zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
          endif
         
!-- MULTIPOLE BLOCK
          if(kzz.eq.11) then
             dynk_izuIndex(ix)=izu
+ca multini
          endif
 150   continue
+if debug
!     call dumpbin('ado 150',150,150)
!     call abend('ado 150                                           ')
+ei
        dp1=zero
        if(ichrom.gt.1) then
          itiono=ition
          ition=0
          call chromda
          ition=itiono
          do ncrr=1,iu
            ix=ic(ncrr)
            if(ix.gt.nblo) ix=ix-nblo
            if(ix.eq.is(1).or.iratioe(ix).eq.is(1)) then
              smiv(m,ncrr)=smi(ncrr)
            else if(ix.eq.is(2).or.iratioe(ix).eq.is(2)) then
              smiv(m,ncrr)=smi(ncrr)
            endif
          enddo
        endif
        dp1=dp00
        dp0=dp00
        if(imc.gt.1) then
          ddp1=(two*dp0)/(dble(imc)-one)                                 !hr05
        endif
        do 250 ib=1,imc
          if(imc.gt.1) then
            dp1=dp0-(dble(ib)-1d0)*ddp1                                  !hr05
          endif
          dp10=dp1
!-----------------------------------------------------------------------
          if(idp.ne.1.or.iation.ne.1) iclo6=0
          if (iclo6.eq.1.or.iclo6.eq.2) then
            if(ib.eq.1) then
+ca clor6
+if debug
!     call dumpbin('aclor6',1,1)
!     call abend('after  clor6                                      ')
+ei
            endif
            if(iqmod6.eq.1) then
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif
            do 190 ib1=1,napx
              ib3=ib1+(m+ib-2)*napx
!--beam-beam element
              clo6v(1,ib3)=clo6(1)
              clo6v(2,ib3)=clo6(2)
              clo6v(3,ib3)=clo6(3)
              clop6v(1,ib3)=clop6(1)
              clop6v(2,ib3)=clop6(2)
              clop6v(3,ib3)=clop6(3)
              di0xs(ib3)=di0(1)
              di0zs(ib3)=di0(2)
              dip0xs(ib3)=dip0(1)
              dip0zs(ib3)=dip0(2)
              qwcs(ib3,1)=qwc(1)
              qwcs(ib3,2)=qwc(2)
              qwcs(ib3,3)=qwc(3)
              do 180 i2=1,6
                do 180 j2=1,6
                  tas(ib3,i2,j2)=tasm(i2,j2)
  180         continue
  190       continue
          else
            if(idp.eq.1.and.iation.eq.1) then
              ncorruo=ncorru
              ncorru=1
              call clorb(zero)
+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
              call betalf(zero,qw)
              call phasad(zero,qwc)
+if debug
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
+ei
!--beam-beam element
              if(nbeam.ge.1) then
              nd=3
              nd2=6
+ca beamcou
              endif
              ncorru=ncorruo
              iqmodc=3
              call mydaini(2,2,6,3,6,1)
+if debug
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
+ei
              do i=1,2
                qwc(i)=dble(int(qwc(i)))+wxys(i)
              enddo
              if(ilin.ge.2) then
+if debug
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
+ei
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
+if debug
!     call dumpbin('amydaini',999,9999)
!     call abend('after  mydaini                                    ')
+ei
                nlin=nlinoo
              endif
            else
              dps(1)=dp1
              ncorruo=ncorru
              ncorru=1
              call clorb(dp1)
              call betalf(dp1,qw)
              call phasad(dp1,qwc)
+if debug
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
+ei
              dp1=zero
!--beam-beam element
+if debug
!     call dumpbin('bbeam',1,1)
!     call abend('after bbeam                                       ')
!     write(*,*) 'call qmodda at beam-beam'
+ei
              dp1=dps(1)
              ncorru=ncorruo
              if(nvar2.le.5) then
                itiono=ition
                ition=0
              endif
              call qmodda(2,qwc)
+if debug 
!     call dumpbin('aqmodda',3,2)
!     call abend('after  qmodda 3 2                                 ')
+ei
              if(nvar2.le.5) ition=itiono
              if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                iqmodc=2
                call mydaini(1,2,5,2,5,1)
                ilinc=1
                call mydaini(2,2,5,2,5,1)
                nlin=nlinoo
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif
            do 170 i=1,napx
              iar=(m+ib-2)*napx+i
              clo6v(1,iar)=clo(1)
              clop6v(1,iar)=clop(1)
              clo6v(2,iar)=clo(2)
              clop6v(2,iar)=clop(2)
              di0xs(iar)=di0(1)
              di0zs(iar)=di0(2)
              dip0xs(iar)=dip0(1)
              dip0zs(iar)=dip0(2)
              qwcs(iar,1)=qwc(1)
              qwcs(iar,2)=qwc(2)
              qwcs(iar,3)=zero
              do 160 i2=1,4
                do 160 j2=1,4
  160         tas(iar,i2,j2)=tasm(i2,j2)
  170       continue
          endif
          iar=(m+ib-2)*napx+1
          tasiar16=tas(iar,1,6)*c1m3
          tasiar26=tas(iar,2,6)*c1m3
          tasiar36=tas(iar,3,6)*c1m3
          tasiar46=tas(iar,4,6)*c1m3
          tasiar56=tas(iar,5,6)*c1m3
          tasiar61=tas(iar,6,1)*c1e3
          tasiar62=tas(iar,6,2)*c1e3
          tasiar63=tas(iar,6,3)*c1e3
          tasiar64=tas(iar,6,4)*c1e3
          tasiar65=tas(iar,6,5)*c1e3
          bet0(1)=tas(iar,1,1)**2+tas(iar,1,2)**2                        !hr05
          bet0x2 =tas(iar,1,3)**2+tas(iar,1,4)**2                        !hr05
          bet0x3 =tas(iar,1,5)**2+tasiar16**2                            !hr05
          gam0x1 =tas(iar,2,1)**2+tas(iar,2,2)**2                        !hr05
          gam0x2 =tas(iar,2,3)**2+tas(iar,2,4)**2                        !hr05
          gam0x3 =tas(iar,2,5)**2+tasiar26**2                            !hr05
      alf0(1)=-1d0*(tas(iar,1,1)*tas(iar,2,1)+tas(iar,1,2)*tas(iar,2,2)) !hr05
      alf0x2 =-1d0*(tas(iar,1,3)*tas(iar,2,3)+tas(iar,1,4)*tas(iar,2,4)) !hr05
      alf0x3 =-1d0*(tas(iar,1,5)*tas(iar,2,5)+tasiar16*tasiar26)         !hr05
          bet0(2)=tas(iar,3,3)**2+tas(iar,3,4)**2                        !hr05
          bet0z2 =tas(iar,3,1)**2+tas(iar,3,2)**2                        !hr05
          bet0z3 =tas(iar,3,5)**2+tasiar36**2                            !hr05
          gam0z1 =tas(iar,4,3)**2+tas(iar,4,4)**2                        !hr05
          gam0z2 =tas(iar,4,1)**2+tas(iar,4,2)**2                        !hr05
          gam0z3 =tas(iar,4,5)**2+tasiar46**2                            !hr05
      alf0(2)=-1d0*(tas(iar,3,3)*tas(iar,4,3)+tas(iar,3,4)*tas(iar,4,4)) !hr05
      alf0z2 =-1d0*(tas(iar,3,1)*tas(iar,4,1)+tas(iar,3,2)*tas(iar,4,2)) !hr05
      alf0z3 =-1d0*(tas(iar,3,5)*tas(iar,4,5)+tasiar36*tasiar46)         !hr05
          bet0s1 =tas(iar,5,5)**2+tasiar56**2                            !hr05
          bet0s2 =tas(iar,5,1)**2+tas(iar,5,2)**2                        !hr05
          bet0s3 =tas(iar,5,3)**2+tas(iar,5,4)**2                        !hr05
          gam0s1 =tasiar65**2+tas(iar,6,6)**2                            !hr05
          gam0s2 =tasiar61**2+tasiar62**2                                !hr05
          gam0s3 =tasiar63**2+tasiar64**2                                !hr05
          alf0s1 =-1d0*(tas(iar,5,5)*tasiar65+tasiar56*tas(iar,6,6))     !hr05
          alf0s2 =-1d0*(tas(iar,5,1)*tasiar61+tas(iar,5,2)*tasiar62)     !hr05
          alf0s3 =-1d0*(tas(iar,5,3)*tasiar63+tas(iar,5,4)*tasiar64)     !hr05
+if debug
!     call dumpbin('abib1',1,1)
!     call abend('after bib1                                        ')
+ei
          do 220 ib1=1,napx
            iar=ib1+(m+ib-2)*napx
            do 200 ib2=1,6
              do 200 ib3=1,6
  200       tau(ib2,ib3)=tas(iar,ib3,ib2)
            if(abs(tau(1,1)).le.pieni.and.abs(tau(2,2)).le.pieni) then
              tau(1,1)=one
              tau(2,2)=one
            endif
            if(abs(tau(3,3)).le.pieni.and.abs(tau(4,4)).le.pieni) then
              tau(3,3)=one
              tau(4,4)=one
            endif
            if(abs(tau(5,5)).le.pieni.and.abs(tau(6,6)).le.pieni) then
              tau(5,5)=one
              tau(6,6)=one
              call dinv(6,tau,6,idummy,nerror)
              its6d=0
              if(ntwin.ne.2) then
                taus=(((((((((((((((((((                                &!hr05
     &abs(tau(5,1))+abs(tau(5,2)))+abs(tau(5,3)))+abs                   &!hr05
     &(tau(5,4)))+abs(tau(5,5)))+abs(tau(5,6)))+abs(tau(6,1)))          &!hr05
     &+abs(tau(6,2)))+abs(tau(6,3)))+abs(tau(6,4)))+abs                 &!hr05
     &(tau(6,5)))+abs(tau(6,6)))+abs(tau(1,5)))+abs(tau(2,5)))          &!hr05
     &+abs(tau(3,5)))+abs(tau(4,5)))+abs(tau(1,6)))+abs                 &!hr05
     &(tau(2,6)))+abs(tau(3,6)))+abs(tau(4,6)))-two                      !hr05
                if(abs(taus).ge.pieni) its6d=1
              endif
              do 210 ib2=1,6
                do 210 ib3=1,6
                  tasau(iar,ib2,ib3)=tau(ib2,ib3)
  210         continue
            endif
  220     continue
          if(ierro.ne.0) then
            write(lout,10230) dp1
            goto 520
          endif
          write(lout,10070)
          phag=(phas*180d0)/pi                                           !hr05
          if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))         &
     &write(lout,10170)                                                 &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
            if(iclo6.eq.0) then
              write(lout,10150) phag,                                   &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10160) phag,                                   &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)            &
     &write(lout,10190) phag,                                           &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
            if(iclo6.eq.0) then
              write(lout,10210)                                         &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10220)                                         &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          write(lout,10080) dp1
          e0f=sqrt(e0**2-pma**2)                                         !hr05
          if(iclo6.eq.0) then
            write(lout,10110) clo(1),clop(1),clo(2),clop(2),idz(1),     &
     &idz(2),                                                           &
     &iver, idfor,iclo6,ition
          else
            write(lout,10120) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),&
     &clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
          endif
          do 240 ib1=1,napx
            ib2=ib0+ib1
            clov(1,ib2)=clo(1)
            clov(2,ib2)=clo(2)
            clopv(1,ib2)=clop(1)
            clopv(2,ib2)=clop(2)
            bet0v(ib2,1)=bet0(1)
            bet0v(ib2,2)=bet0(2)
            alf0v(ib2,1)=alf0(1)
            alf0v(ib2,2)=alf0(2)
            ampv(ib2)=amp(1)-damp*dble(ib1-1)                            !hr05
            dp0v(ib2)=dp10
            dpsv(ib2)=dp10
            oidpsv(ib2)=one/(one+dp1)
            nms(ib2)=m
            if (ithick.eq.1) then
               do 230 i=1,nele
                  ekv(ib2,i)=ek(i)
 230           continue
            endif
  240     continue
          ib0=ib0+napx
  250   continue
  260 continue
+if debug
!     call dumpbin('ado 260',260,260)
!     call abend('ado 260                                           ')
+ei

      napx=(napx*imc)*mmac                                               !hr05
+if cr
      write(93,*) 'MAINCR setting napxo=',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+ei
      napxo=napx
      if(ibidu.eq.1) then
+ca dump1
+ca dump3
      endif
  550 continue
      if(ibidu.eq.2) then
+ca dump2
+ca dump3
        damp=((amp(1)-amp0)/dble(napx/2-1))/2d0                          !hr05
      endif
      do 80 i=1,npart
        pstop(i)=.false.
        nnumxv(i)=numl
   80 numxv(i)=numl
      rat0=rat
      do 340 ia=1,napx,2
        if(idfor.ne.2) then
!---------------------------------------  SUBROUTINE 'ANFB' IN-LINE
          write(lout,10050)
          tasia56=tas(ia,5,6)*c1m3
          bet0x2=tas(ia,1,3)**2+tas(ia,1,4)**2                           !hr05
          bet0z2=tas(ia,3,1)**2+tas(ia,3,2)**2                           !hr05
          bet0s1=tas(ia,5,5)**2+tasia56**2                               !hr05
          dsign=one
          rat=rat0
          if(tas(ia,3,3).lt.(-1d0*pieni)) rat=-1d0*rat                   !hr05
          if(rat.lt.(-1d0*pieni)) dsign=-1d0*one                         !hr05
          x11=ampv(ia)/(sqrt(bet0v(ia,1))+sqrt(abs(rat)*bet0x2))
          x13=(x11*dsign)*sqrt(abs(rat))                                 !hr05
          amp(2)=(dsign*dble(1-iver))*(abs(x11)*sqrt(bet0z2)+abs(x13)*  &!hr05
     &sqrt(bet0v(ia,2)))                                                 !hr05
          x1(5)=zero
          x1(6)=dpsv(ia)*sqrt(bet0s1)
          chi=chi0*rad
          dchi=chid*rad
          do 320 i2=1,2
            i3=ia+i2-1
+if crlibm
            sic=sin_rn(chi)
+ei
+if .not.crlibm
            sic=sin(chi)
+ei
+if crlibm
            coc=cos_rn(chi)
+ei
+if .not.crlibm
            coc=cos(chi)
+ei
            x1(1)=x11*coc
            x1(2)=x11*sic
            x1(3)=x13*coc
            x1(4)=x13*sic
            do 300 ii=1,6
              x2(ii)=zero
              do 290 jj=1,6
                x2(ii)=x2(ii)+tas(ia,ii,jj)*x1(jj)
  290         continue
  300       continue
            if(iclo6.eq.1.or.iclo6.eq.2) then
              x2(2)=x2(2)/((one+x2(6))+clop6v(3,ia))                     !hr05
              x2(4)=x2(4)/((one+x2(6))+clop6v(3,ia))                     !hr05
            endif
            if(abs(bet0s1).le.pieni) x2(6)=dpsv(ia)
            if(iver.eq.1) then
              x2(3)=zero
              x2(4)=zero
            endif
            do 310 l=1,2
              ll=(l-1)*2
              xv(l,i3)=x2(1+ll)+exz(i2,1+ll)
              yv(l,i3)=x2(2+ll)+exz(i2,2+ll)
  310       continue
            sigmv(i3)=x2(5)+exz(i2,5)
            dpsv(i3)=x2(6)
            dpsic=dpsv(i3)+clop6v(3,ia)
            if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
              xv(1,i3)=xv(1,i3)+di0xs(ia)*dpsic
              xv(2,i3)=xv(2,i3)+di0zs(ia)*dpsic
              yv(1,i3)=yv(1,i3)+dip0xs(ia)*dpsic
              yv(2,i3)=yv(2,i3)+dip0zs(ia)*dpsic
            endif
            chi=chi+dchi
  320     continue
          write(lout,10260) ia,nms(ia)*izu0,dpsv(ia)
          write(lout,10060) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),        &
     &sigmv(ia),                                                        &
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1)
!---------------------------------------  END OF 'ANFB'
          if(iclo6.eq.2) then
            xv(1,ia)=xv(1,ia)+clo6v(1,ia)
            yv(1,ia)=yv(1,ia)+clop6v(1,ia)
            xv(2,ia)=xv(2,ia)+clo6v(2,ia)
            yv(2,ia)=yv(2,ia)+clop6v(2,ia)
            sigmv(ia)=sigmv(ia)+clo6v(3,ia)
            dpsv(ia)=dpsv(ia)+clop6v(3,ia)
            xv(1,ia+1)=xv(1,ia+1)+clo6v(1,ia)
            yv(1,ia+1)=yv(1,ia+1)+clop6v(1,ia)
            xv(2,ia+1)=xv(2,ia+1)+clo6v(2,ia)
            yv(2,ia+1)=yv(2,ia+1)+clop6v(2,ia)
            sigmv(ia+1)=sigmv(ia+1)+clo6v(3,ia)
            dpsv(ia+1)=dpsv(ia+1)+clop6v(3,ia)
            oidpsv(ia)=one/(one+dpsv(ia))
            oidpsv(ia+1)=one/(one+dpsv(ia+1))
          endif
          if(iclo6.ne.2) then
            xv(1,ia)=xv(1,ia)+(clov(1,ia)*dble(idz(1)))*dble(1-idfor)    !hr05
            yv(1,ia)=yv(1,ia)+(clopv(1,ia)*dble(idz(1)))*dble(1-idfor)   !hr05
            xv(2,ia)=xv(2,ia)+(clov(2,ia)*dble(idz(2)))*dble(1-idfor)    !hr05
            yv(2,ia)=yv(2,ia)+(clopv(2,ia)*dble(idz(2)))*dble(1-idfor)   !hr05
          xv(1,ia+1)=xv(1,ia+1)+(clov(1,ia)*dble(idz(1)))*dble(1-idfor)  !hr05
          yv(1,ia+1)=yv(1,ia+1)+(clopv(1,ia)*dble(idz(1)))*dble(1-idfor) !hr05
          xv(2,ia+1)=xv(2,ia+1)+(clov(2,ia)*dble(idz(2)))*dble(1-idfor)  !hr05
          yv(2,ia+1)=yv(2,ia+1)+(clopv(2,ia)*dble(idz(2)))*dble(1-idfor) !hr05
          endif
          ejfv(ia)=e0f*(one+dpsv(ia))
          ejfv(ia+1)=e0f*(one+dpsv(ia+1))
          ejv(ia)=sqrt(ejfv(ia)**2+pma**2)                               !hr05
          ejv(ia+1)=sqrt(ejfv(ia+1)**2+pma**2)                           !hr05
          epsa(1)=(ampv(ia)**2/bet0v(ia,1))                              !hr05
          epsa(2)=(amp(2)**2/bet0v(ia,2))                                !hr05
          write(lout,10020) ampv(ia),amp(2),epsa
        else
          read(13,*,iostat=ierro) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),  &
     &sigmv(ia),dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv            &
     &(2,ia+1), sigmv(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
          if(ierro.ne.0) call prror(56)
          e0f=sqrt(e0**2-pma**2)                                         !hr05
          ejfv(ia)=sqrt(ejv(ia)**2-pma**2)                               !hr05
          ejfv(ia+1)=sqrt(ejv(ia+1)**2-pma**2)                           !hr05
          oidpsv(ia)=one/(one+dpsv(ia))
          oidpsv(ia+1)=one/(one+dpsv(ia+1))
        endif
        write(lout,10090) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),&
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
        idam=3
        icode=0
        if(abs(xv(1,ia)).le.pieni.and.abs(yv(1,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+1
        endif
        if(abs(xv(2,ia)).le.pieni.and.abs(yv(2,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+2
        endif
        if(idp.eq.0.or.abs(ition).eq.0) then
          idam=idam-1
        else
          icode=icode+4
        endif
        if(idam.le.0) idam=1
        if(icode.le.0) icode=1
        ia2=(ia+1)/2
        if(ntwin.ne.2) then
          if(mod(ia+1,2).eq.0) then
            xau(1,1)= xv(1,ia)
            xau(1,2)= yv(1,ia)
            xau(1,3)= xv(2,ia)
            xau(1,4)= yv(2,ia)
            xau(1,5)=sigmv(ia)
            xau(1,6)= dpsv(ia)
            xau(2,1)= xv(1,ia+1)
            xau(2,2)= yv(1,ia+1)
            xau(2,3)= xv(2,ia+1)
            xau(2,4)= yv(2,ia+1)
            xau(2,5)=sigmv(ia+1)
            xau(2,6)= dpsv(ia+1)
            cloau(1)= clo6v(1,ia)
            cloau(2)=clop6v(1,ia)
            cloau(3)= clo6v(2,ia)
            cloau(4)=clop6v(2,ia)
            cloau(5)= clo6v(3,ia)
            cloau(6)=clop6v(3,ia)
            di0au(1)= di0xs(ia)
            di0au(2)=dip0xs(ia)
            di0au(3)= di0zs(ia)
            di0au(4)=dip0zs(ia)
            do 330 ib2=1,6
              do 330 ib3=1,6
                tau(ib2,ib3)=tasau(ia,ib2,ib3)
  330       continue
            call distance(xau,cloau,di0au,tau,dam1)
            dam(ia)=dam1
            dam(ia+1)=dam1
          endif
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.eq.9) then
            write(lout,*)                                               &
     & 'SKIPPING Binary File Initialisation for BNLELENS'
            go to 340
          endif
!GRDRHIC
!GRD-042008
+ei !END +if bnlelens

!     Write header of track output file(s) used by postprocessing
!     for case ntwin.ne.2
+if cr
          if (.not.restart) then
+ei
+if .not.stf
          write(91-ia2,iostat=ierro) sixtit,commen,cdate, ctime,progrm, &
     &ia,ia,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),clo6v     &
     &(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v(3,ia),        &
     &clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs(ia),zero,     &
     &one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas(ia,1,4),tas          &
     &(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas(ia,2,3),tas    &
     &(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas(ia,3,2),tas    &
     &(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas(ia,4,1),tas    &
     &(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas(ia,4,6), tas    &
     &(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas(ia,5,5), tas     &
     &(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas(ia,6,4),tas     &
     &(ia,6,5), tas(ia,6,6),                                            &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
+if cr
          endfile (91-ia2,iostat=ierro)
          backspace (91-ia2,iostat=ierro)
          binrecs(ia2)=1
          endif
+ei
+ei ! END +if .not.stf
+if stf
          write(90,iostat=ierro) sixtit,commen,cdate, ctime,progrm,     &
     &ia,ia,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),clo6v     &
     &(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v(3,ia),        &
     &clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs(ia),zero,     &
     &one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas(ia,1,4),tas          &
     &(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas(ia,2,3),tas    &
     &(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas(ia,3,2),tas    &
     &(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas(ia,4,1),tas    &
     &(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas(ia,4,6), tas    &
     &(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas(ia,5,5), tas     &
     &(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas(ia,6,4),tas     &
     &(ia,6,5), tas(ia,6,6),                                            &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
+if cr
          endfile (90,iostat=ierro)
          backspace (90,iostat=ierro)
          binrecs(ia2)=1
          endif
+ei
+ei ! END +if stf
        else !ELSE for "if(ntwin.ne.2)"
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.eq.9) then
            write(lout,*)                                               &
     & 'SKIPPING Binary File Initialisation for BNLELENS'
            go to 340
          endif
!GRDRHIC
!GRD-042008
+ei !END +if bnlelens

!     Write header of track output file(s) used by postprocessing
!     for case ntwin.eq.2

+if cr
          if (.not.restart) then
+ei
+if .not.stf
          write(91-ia2,iostat=ierro) sixtit,commen,cdate, ctime,progrm, &
     &ia,ia+1,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),        &
     &clo6v(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v          &
     &(3,ia),clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs        &
     &(ia),zero,one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas            &
     &(ia,1,4),tas(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas    &
     &(ia,2,3),tas(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas    &
     &(ia,3,2),tas(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas    &
     &(ia,4,1),tas(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas     &
     &(ia,4,6), tas(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas     &
     &(ia,5,5), tas(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas    &
     &(ia,6,4),tas(ia,6,5), tas(ia,6,6),                                &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
+if cr
          endfile (91-ia2,iostat=ierro)
          backspace (91-ia2,iostat=ierro)
          binrecs(ia2)=1
          endif
+ei
+ei ! END +if .not.stf
+if stf
          write(90,iostat=ierro) sixtit,commen,cdate, ctime,progrm,     &
     &ia,ia+1,napx,icode,numl,qwcs(ia,1),qwcs(ia,2), qwcs(ia,3),        &
     &clo6v(1,ia),clop6v(1,ia),clo6v(2,ia),clop6v(2,ia), clo6v          &
     &(3,ia),clop6v(3,ia), di0xs(ia),dip0xs(ia),di0zs(ia),dip0zs        &
     &(ia),zero,one, tas(ia,1,1),tas(ia,1,2),tas(ia,1,3),tas            &
     &(ia,1,4),tas(ia,1,5), tas(ia,1,6), tas(ia,2,1),tas(ia,2,2),tas    &
     &(ia,2,3),tas(ia,2,4),tas(ia,2,5), tas(ia,2,6), tas(ia,3,1),tas    &
     &(ia,3,2),tas(ia,3,3),tas(ia,3,4),tas(ia,3,5), tas(ia,3,6), tas    &
     &(ia,4,1),tas(ia,4,2),tas(ia,4,3),tas(ia,4,4),tas(ia,4,5), tas     &
     &(ia,4,6), tas(ia,5,1),tas(ia,5,2),tas(ia,5,3),tas(ia,5,4),tas     &
     &(ia,5,5), tas(ia,5,6), tas(ia,6,1),tas(ia,6,2),tas(ia,6,3),tas    &
     &(ia,6,4),tas(ia,6,5), tas(ia,6,6),                                &
     &dble(mmac),dble(nms(ia)),dble(izu0),                              &
     &dble(numlr),sigcor,dpscor,zero,zero,zero,zero,                    &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,                &
     &zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
+if cr
          endfile (90,iostat=ierro)
          backspace (90,iostat=ierro)
          binrecs(ia2)=1
          endif
+ei
+ei ! END +if stf
        endif
        if(ierro.ne.0) then
          write(lout,*)
          write(lout,*) '*** ERROR ***,PROBLEMS WRITING TO FILE # : ',91&
     &-ia2
          write(lout,*) 'ERROR CODE : ',ierro
          write(lout,*)
          goto 520
        endif
  340 continue
+if cr
      if (lhc.ne.9) binrec=1    ! binrec:
                                ! The maximum number of reccords writen for all tracking data files
                                ! Thus crbinrecs(:) .le. binrec
+ei
      if(e0.gt.pieni) then
        do 350 j=1,napx
  350   rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      else
        call prror(79)
      endif

      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)

!!! Really only neccessary for thick 4d tracking !!!
!!! In FLUKA version, this is moved to new subroutine "blocksv" (in a new deck)
!-------------------------------------  START OF 'BLOCK'
      if (ithick.eq.1) then

      do 440 k=1,mblo
        jm=mel(k)
        ikk=mtyp(k,1)
        do 370 lkk=1,2
          do 370 mkk=1,6
            do 360 ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(mkk,lkk,ia,1)=al(mkk,lkk,ia,ikk)
  360       if(mkk.eq.5.or.mkk.eq.6) hv(mkk,lkk,ia,1)=hv(mkk,lkk,ia,1)  &
     &/dpoff
  370   continue
        if(jm.eq.1) goto 410
        do 400 j=2,jm
          ikk=mtyp(k,j)
          do 390 lkk=1,2
            do 380 ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(1,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(2,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(3,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(4,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(5,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(2,lkk,ia,ikk))+al(5,lkk,ia,ikk)/dpoff               !hr05
              hv(6,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(4,lkk,ia,ikk))+al(6,lkk,ia,ikk)/dpoff               !hr05
  380       continue
  390     continue
  400   continue
  410   do 430 lkk=1,2
          do 430 mkk=1,6
            do 420 ia=1,napx
  420       bl1v(mkk,lkk,ia,k)=hv(mkk,lkk,ia,jm)
  430   continue
  440 continue

      end if
!---------------------------------------END OF 'BLOCK'

!     A.Mereghetti, P. G. Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-07-2014
!     call routine for calculating dcum, necessary for the online
!        aperture check and in case of dumping particle population
!        or statistics or beam matrix
!     always in main code
      call cadcum

!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     K. Sjobak, for BE/ABP-HSS
!     last modified: 21/02-2016
!     open units for dumping particle population or statistics
!     always in main code
      do i=0,il
+if cr
        if (dumpfilepos(i).ge.0) then
           ! Expect the file to be opened already, in crcheck
           inquire( unit=dumpunit(i), opened=lopen )
           if ( .not.lopen ) then
              write(lout,*) "ERROR in DUMP: The unit",dumpunit,
     &             "has dumpfilepos=", dumpfilepos(i), ".ge.0, ",
     &             "but the file is NOT open. This is probably a bug."
              call prror(-1)
           endif
           cycle !Everything OK, don't try to open the files again.
        endif 
+ei
        if (ldump(i)) then
!         the same file could be used by more than one SINGLE ELEMENT
          inquire( unit=dumpunit(i), opened=lopen )
          if ( .not.lopen ) then
             if ( dumpfmt(i).eq.3 ) then
                 open(dumpunit(i),file=dump_fname(i),
     &                status='replace',form='unformatted')
             else
                 open(dumpunit(i),file=dump_fname(i),
     &                status='replace',form='formatted')
             endif
+if cr
             dumpfilepos(i) = 0
+ei
          else
             !Sanity check: If already open, it should be by another DUMP
             ! (can't guarantee for files after this one)
             ! Also should not be shared with element 0 (all)
             ! Also should be same format -- if so, add to the header.
             
             !reuse the lopen flag as a temp variable
             lopen = .false.
             do j=0,i-1
                if (dumpunit(j).eq.dumpunit(i)) then
                   if (dumpfmt(j).ne.dumpfmt(i)) then
                      write(lout,*)
     & "ERROR in DUMP: ouput unit",dumpunit(i), " used by two DUMPS,",
     & " formats are not the same."
                      call prror(-1)
                   else if (j.eq.0) then
                      write(lout,*)
     & "ERROR in DUMP: ouput unit",dumpunit(i), " used by two DUMPS,",
     & " one of which is ALL"
                      call prror(-1)
                   else if (dump_fname(j).ne.dump_fname(i)) then
                      write(lout,*)
     & "ERROR in DUMP: Output unit",dumpunit(i),"is used by to DUMPS,"//
     & " but filenames differ:", dump_fname(i), " vs ", dump_fname(j)
                      call prror(-1)
                   else
                      ! Everything is fine
                      lopen = .true.
+if cr
                      !Dumpfilepos is separate for every element, even if they share files.
                      dumpfilepos(i) = 0
+ei
                   endif
                endif
             end do
             ! LOPEN not set to true by sanity check in loop above
             ! => File was already open, but not by DUMP.
             if ( .not.lopen ) then
                write (lout,*)
     & "ERROR in DUMP: unit", dumpunit(i), " is already open, ",
     & " but not by DUMP. Please pick another unit! ",
     & " Note: This test is not watertight, as other parts of",
     & " the program may later open the same file/unit."
                call prror(-1)
             endif
          endif

          ! Write format-specific headers
          if ( dumpfmt(i).eq.1 ) then ! Format 1 is special
             write(dumpunit(i),'(a)')
     &  '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] dE/E[1] ktrack'
                
             !Flush file
             endfile   (dumpunit(i))
             backspace (dumpunit(i))
+if cr
             dumpfilepos(i) = dumpfilepos(i) + 1
+ei
          else if ( dumpfmt(i).eq.2 .or.
     &              dumpfmt(i).eq.4 .or.
     &              dumpfmt(i).eq.5 .or.
     &              dumpfmt(i).eq.6      ) then

             ! Write the general header
             if (i.eq.0) then
                write(dumpunit(i),
     &               '(a,i0,a,4(a,i12),2(a,L1))')
     & '# DUMP format #',dumpfmt(i),', ALL ELEMENTS,',
     & ' number of particles=',napx, ', dump period=',ndumpt(i),
     & ', first turn=', dumpfirst(i), ', last turn=',dumplast(i),
     & ', HIGH=',ldumphighprec, ', FRONT=',ldumpfront
             else
                write(dumpunit(i),
     &               '(a,i0,a,a16,4(a,i12),2(a,L1))')
     & '# DUMP format #',dumpfmt(i), ', bez=', bez(i),
     & ', number of particles=',napx,', dump period=',ndumpt(i),
     & ', first turn=',dumpfirst(i), ', last turn=',dumplast(i),
     & ', HIGH=',ldumphighprec, ', FRONT=',ldumpfront
             endif
             
             !Write the format-specific headers:
             if ( dumpfmt(i).eq.2 ) then ! FORMAT 2
                write(dumpunit(i),'(a,a)')
     &  '# ID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] z[mm] dE/E[1] ',
     &  'ktrack'

             else if ( dumpfmt(i).eq.4 ) then ! FORMAT 4
                write(dumpunit(i),'(a)')
     &               '# napx turn s[m] ' //
     &   '<x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <z>[mm] <dE/E>[1]'
                
             else if ( dumpfmt(i).eq.5 ) then ! FORMAT 5
                write(dumpunit(i),'(a)')
     &               '# napx turn s[m] ' //
     &   '<x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <z>[mm] <dE/E>[1] '//
     &   '<x^2> <x*xp> <x*y> <x*yp> <x*z> <x*(dE/E)> '//
     &   '<xp^2> <xp*y> <xp*yp> <xp*z> <xp*(dE/E)> '//
     &   '<y^2> <y*yp> <y*z> <y*(dE/E)> '//
     &   '<yp^2> <yp*z> <yp*(dE/E)> '//
     &   '<z^2> <z*(dE/E)> '//
     &   '<(dE/E)^2>'
                
             else if ( dumpfmt(i).eq.6 ) then ! FORMAT 6
                write(dumpunit(i),'(a)')
     &               '# napx turn s[m] ' //
     &   '<x>[m] <px>[1] <y>[m] <py>[1] <sigma>[m] <psigma>[1] '//
     &   '<x^2> <x*px> <x*y> <x*py> <x*sigma> <x*psigma> '//
     &   '<px^2> <px*y> <px*py> <px*sigma> <px*psigma> '//
     &   '<y^2> <y*py> <y*sigma> <y*psigma> '//
     &   '<py^2> <py*sigma> <py*psigma> '//
     &   '<sigma^2> <sigma*psigma> '//
     &   '<psigma^2>'
                
             end if  !Format-specific headers

             ! Flush file
             endfile   (dumpunit(i))
             backspace (dumpunit(i))
+if cr
             dumpfilepos(i) = dumpfilepos(i) + 2
+ei
             
          end if !If format 2/4/5/6 -> General header
        endif !If ldump(i) -> Dump on this element
      enddo !Loop over elements with index i

!                                !
!     ****** TRACKING ******     !
!                                !
      write(lout,10200)
+if debug
!     call dumpbin('btrack',1,1)
!     call abend('btrack                                            ')
+ei
+if debug
                   !call system('../crmain  >> crlog')
+ei
      time1=0.
      call timex(time1)
! time1 is now pre-processing CPU
! note that this will be reset evry restart as we redo pre-processing
      pretime=time1-time0
!---------------------------------------  LOOP OVER TURNS TO BE TRACKED
      if(ithick.eq.0) call trauthin(nthinerr)
      if(ithick.eq.1) call trauthck(nthinerr)
+if debug
!     call dumpbin('atrack',1,1)
!     call abend('atrack                                            ')
+ei
      time2=0.
      call timex(time2)
! trtime is now the tracking time, BUT we must add other time for C/R
      trtime=time2-time1
+if cr
! because now crpoint will write tracking time
! using time3 as a temp
! and crcheck/crstart will reset crtime3
      trtime=trtime+crtime3
+ei
      if(nthinerr.eq.3000) goto 520
      if(nthinerr.eq.3001) goto 460
!---------------------------------------  END OF LOOP OVER TURNS
  460 continue
      napxto=0
! and set numx=nnuml (for writebin) NOT for LOST particles
! because all lost set nnuml=numl
      numx=nnuml
      id=0
+if cr
      if (.not.restart) then  
! If restart is true , we haven't done any tracking
! and must be running from very last checkpoint
        write(93,*) 'Very last call to WRITEBIN?'
        write(93,*) 'numlmax,nnuml,numl',numlmax,nnuml,numl
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        if (nnuml.eq.numl) then
! We REALLY have finished (or all particles lost)
! When all lost, nthinerr=3001, we set nnuml=numl
! and make sure we do the last WRITEBIN
          write(93,*) 'Very last call to WRITEBIN'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          call writebin(nthinerr)
          if(nthinerr.eq.3000) goto 520
        else
! I assume we are stopping because we have done nnuml turns
! which should be numlmax and do a writebin only if time
          write(93,*) 'Very last call to WRITEBIN?'
          write(93,*) 'numlmax,nnuml,nwri',numlmax,nnuml,nwri
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          if(mod(nnuml,nwri).eq.0) then
            write(93,*) 'Very last call to WRITEBIN'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call writebin(nthinerr)
            if(nthinerr.eq.3000) goto 520
          endif
        endif
! and do the very last checkpoint
        call callcrp()
      endif
+ei
+if .not.cr
      call writebin(nthinerr)
      if(nthinerr.eq.3000) goto 520
+ei
! If CR we have to worry about turns printed in fort.6
! If lost should be OK, otherwise we need to use nnuml instead
! of the numl in numxv/nnumxv???? Eric.
! where we reset [n]numxv to nnuml UNLESS particle lost
! Now we shall try using that fix at start of tracking
      do 470 ia=1,napxo,2
        ie=ia+1
        ia2=(ie)/2
        napxto=(napxto+numxv(ia))+numxv(ie)                              !hr05
        if(pstop(ia).and.pstop(ie)) then
!-- BOTH PARTICLES LOST
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),         &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),         &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(lout,10280)                                             &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          if(ierro.ne.0) write(lout,*)
     &'Warning from maincr: fort.12 has ',                              &
     &'corrupted output probably due to lost particle: ',ia,            &
     &' or: ',ie
        endif
        if(.not.pstop(ia).and.pstop(ie)) then
!-- SECOND PARTICLE LOST
          id=id+1
          write(lout,10240) ia,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),         &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(lout,10280)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          if(ierro.ne.0)
     &         write(lout,*) 'Warning from maincr: fort.12 has ',
     &         'corrupted output probably due to lost particle: ',ie
        endif
        if(pstop(ia).and..not.pstop(ie)) then
!-- FIRST PARTICLE LOST
          id=id+1
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),         &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(lout,10240) ie,nms(ia)*izu0,dp0v(ia),numxv(ie)
          write(lout,10280)                                             &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          if(ierro.ne.0)
     &         write(lout,*) 'Warning from maincr: fort.12 has ',
     &         'corrupted output probably due to lost particle: ',ia
        endif
        if(.not.pstop(ia).and..not.pstop(ie)) then
!-- BOTH PARTICLES STABLE
          id=id+1
          ig=id+1
          write(lout,10270) ia,ie,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(lout,10280)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          if(ierro.ne.0)
     &         write(lout,*) 'Warning from maincr: fort.12 has ',
     &         'corrupted output although particles stable'
          id=ig
        endif
  470 continue

! POSTPROCESSING (POSTPR)

+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) go to 520
!GRDRHIC
!GRD-042008
+ei
! and we need to open fort.10 unless already opened
! for BOINC AND BNLELENS
+if nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',         &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei

+if .not.nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei
+ei

+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown')
+ei
+ei
+ei

+if .not.stf
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
          do 480 ia=1,napxo,2
            ia2=(ia+1)/2
            iposc=iposc+1
+if .not.cr
            call postpr(91-ia2) !Postprocess file "fort.(91-ia2)"
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia2,nnuml)
+ei
  480     continue
          if(iposc.ge.1) call sumpos
        endif !END if(ipos.eq.1)
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,ndafi2
            if(ia.gt.ndafi) goto 510
+if .not.cr
            call postpr(91-ia)
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia,nnuml)
+ei
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
+ei !END +if .not.stf
+if stf
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
           do 480 ia=1,napxo,2
              iposc=iposc+1
+if .not.cr
              call postpr(ia) !Postprocess particle ia (and ia+1 if ntwin=2)
+ei
+if cr
              write(93,*) 'Calling POSTPR nnuml=',nnuml
              endfile (93,iostat=ierro)
              backspace (93,iostat=ierro)
              call postpr(ia,nnuml)
+ei
  480      continue
          if(iposc.ge.1) call sumpos
        endif
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,(2*ndafi2),2
            if(ia.gt.ndafi) goto 510
+if .not.cr
            call postpr(ia)
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(ia,nnuml)
+ei
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
+ei !END +if stf

 520  continue !Finished postprocessing (POST in fort.3)
      
!     start fma
      if(fma_flag) then
        write(lout,*)'Calling FMA_POSTPR'
        call fma_postpr
      endif
!--HPLOTTING END
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call igmeta(999,0)
        call hplend
      endif
      time3=0.
      call timex(time3)
! Note that crpoint no longer destroys time2
      posttime=time3-time2
+if debug
      write(lout,*) 'BUG:',time3,time2,pretime,trtime,posttime
+if cr
      write(93,*)   'BUG:',time3,time2,pretime,trtime,posttime
+ei
+ei
! and now get grand total including post-processing
      tottime=(pretime+trtime)+posttime
      write(lout,10290) pretime
+if cr
! and TRY a FIX for napxto
!     if (nnuml.ne.numl) then
!       napxto=0
!       write(lout,*) 'numl=',numl,' nnuml=',nnuml
! We may have stopped because of numlmax
!       do ia=1,napxo
!         if (numxv(ia).eq.numl) then
! assumed stable
!     write(lout,*) 'ia=',ia,nnuml
!           napxto=napxto+nnuml
!         else
! assumed lost
!     write(lout,*) 'ia=',ia,' numxv=',numxv
!           napxto=napxto+numxv(ia)
!         endif
!       enddo 
!     endif
+ei
      write(lout,10300) napxto,trtime
      write(lout,10310) tottime
+if debug
!     call wda('THE END',0d0,9,9,9,9)
!     call dumpum('THE END',999,9999)
!     call dumpbin('THE END',999,9999)
!     call dumpzfz('THE END',9,9)
+ei
      call closeUnits

      if (zipf_numfiles.gt.0) then
         call zipf
      endif
      
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,      &
     &' RANDOM SEED ',i8,/ t10,' MOMENTUM DEVIATION ',g12.5,            &
     &' LOST IN REVOLUTION ',i8,/ t10,'HORIZ:  AMPLITUDE = ',f15.3,     &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',f15.3,         &
     &'   APERTURE = ',f15.3/)
+if .not.tilt
+if cr
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
+ei
+if .not.cr
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
+ei
+ei
+if tilt
+if cr
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
+ei
+if .not.cr
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
+ei
+ei
10020 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y = ',f15.3, '  PI*MRAD*MM')
10025 format(/t10,'Run started from binary dump file # 32')
10030 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10040 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10050 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
10060 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10070 format(/131('-'))
10080 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t8,                &
     &'========================================')
10090 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10110 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10120 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10150 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9,f15.9/)
10160 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10170 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10180 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10190 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10200 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10210 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10220 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10230 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,                &
     &'RELATIVE MOMENTUM DEVIATION')
10240 format(1x/5x,'PARTICLE ',i7,' STABLE - RANDOM SEED ', i8,         &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
!10250 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
!     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10260 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5/)
10270 format(1x/5x,'PARTICLE ',i7,' AND ',i7,' STABLE - RANDOM SEED ',  &
     &i8,' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10280 format(10x,f47.33)
10290 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10300 format(/10x,'For ',i12,' Turn(s)',g12.3,' second(s) of ',         &
     &'Computing Time was needed'//131('-'))
10310 format(//10x,'Total Time used: ',g12.3,' second(s)'//131('-'))
10320 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
10330 format(/10x,'ERROR IN OPENING FILES')
      end
+dk tra_thin
!>
!!--------------------------------------------------------------------------
!!  TRACK THIN LENS PART
!!  F. SCHMIDT
!!  CHANGES FOR COLLIMATION MADE BY G. ROBERT-DEMOLAIZE, October 29th, 2004
!!--------------------------------------------------------------------------
!<
      subroutine trauthin(nthinerr)
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      double precision benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
      logical lopen
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
      dimension nbeaux(nbb)
+if collimat
+ca collpara
+ca dbtrthin
+ca database
+ca dbcommon
+ca dblinopt
+ca dbpencil
+ca info
+ca dbcolcom
+ei
+if bnlelens
+ca rhicelens
+ei
+ca stringzerotrim
+ca comdynk
      logical dynk_isused
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
      do 5 i=1,npart
        nlostp(i)=i
   5  continue
      do 10 i=1,nblz
        ktrack(i)=0
        strack(i)=zero
        strackc(i)=zero
        stracks(i)=zero
   10 continue
+ca beams1

      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        !BLOC
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        goto 290
        !Non-linear/NOT BLOC
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
        kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        else if(kzz.eq.12) then
          !Disabled cavity; enabled cavities have kp=6 and are handled above
          ! Note: kz=-12 are transformed into +12 in daten after reading ENDE.
          ktrack(i)=31
          goto 290
        endif
+ca beams21
+ca beamcoo
+ca beamr1
     &goto 42
+ca beamr2
+ca beamr3o
+ca beams22
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4o
+ca beams23
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4o
+ca beams24

+ca wire
+ca acdip1
+ca crab1
+ca crab_mult
+ca elens
+ca trom30
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),   &
     &extalign(i,2),extalign(i,3)
        endif
        if(kzz.lt.0) goto 180
        goto(50,60,70,80,90,100,110,120,130,140,150,290,290,290,        &
     &       290,290,290,290,290,290,290,290,290,145,146),kzz
        ktrack(i)=31
        goto 290
   50   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=11
+ca stra01
        goto 290
   60   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=12
+ca stra02
        goto 290
   70   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=13
+ca stra03
        goto 290
   80   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=14
+ca stra04
        goto 290
   90   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=15
+ca stra05
        goto 290
  100   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=16
+ca stra06
        goto 290
  110   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=17
+ca stra07
        goto 290
  120   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=18
+ca stra08
        goto 290
  130   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=19
+ca stra09
        goto 290
  140   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=20
+ca stra10
        goto 290
!--DIPEDGE ELEMENT
  145   continue 
+ca stra2dpe
        ktrack(i)=55
        goto 290
!--solenoid
  146   continue
+ca solenoid
        ktrack(i)=56
        goto 290
!--Multipole block (also in initialize_element)
  150   r0=ek(ix)
        nmz=nmu(ix)
        if(abs(r0).le.pieni.or.nmz.eq.0) then
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            if ( dynk_isused(i) ) then
              write(lout,*)
     &        "ERROR: Element of type 11 (bez=",bez(ix),
     &        ") is off in fort.2, but on in DYNK. Not implemented."
              call prror(-1)
            endif
            ktrack(i)=31
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=33
+ca stra11
            else
              ktrack(i)=35
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=37
+ca stra13
            else
              ktrack(i)=39
+ca stra14
            endif
          endif
        else
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=32
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=34
+ca stra11
            else
              ktrack(i)=36
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=38
+ca stra13
            else
              ktrack(i)=40
+ca stra14
            endif
          endif
        endif
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
        if(mout2.eq.1) then
          benkcc=ed(ix)*benkc(irm(ix))
          r0a=one
          r000=r0*r00(irm(ix))
          do 160 j=1,mmul
            fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
            fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
  160     r0a=r0a*r000
          write(9,'(a16)') bez(ix)
          write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
          write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
          do 170 j=1,20
            fake(1,j)=zero
  170     fake(2,j)=zero
        endif
        goto 290
        
        !Negative KZZ
  180   kzz=-kzz
        goto(190,200,210,220,230,240,250,260,270,280),kzz
        ktrack(i)=31
        goto 290
  190   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=21
+ca stra01
        goto 290
  200   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=22
+ca stra02
        goto 290
  210   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=23
+ca stra03
        goto 290
  220   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=24
+ca stra04
        goto 290
  230   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=25
+ca stra05
        goto 290
  240   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=26
+ca stra06
        goto 290
  250   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=27
+ca stra07
        goto 290
  260   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=28
+ca stra08
        goto 290
  270   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=29
+ca stra09
        goto 290
  280   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=30
+ca stra10
  290 continue
      do 300 j=1,napx
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  300 continue
      nwri=nwr(3)
      if(nwri.eq.0) nwri=(numl+numlr)+1                                  !hr01

!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak, BE-ABP-HSS
!     last modified: 24-02-2015
!     save original kicks
!     always in main code
      if (ldynk) call dynk_pretrack

+if collimat
      if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then
+ei
+if .not.collimat
      if(idp.eq.0.or.ition.eq.0) then
+ei
        write(lout,*) ''
        write(lout,*) 'Calling thin4d subroutine'
        write(lout,*) ''
        call thin4d(nthinerr)
      else
+if collimat
        if (idp.eq.0.or.ition.eq.0) then
           write(lout,*) ""
           write(lout,*) "******* WARNING *******"
           write(lout,*) "Calling 6D tracking due to collimation!"
           write(lout,*) "Would normally have called thin4d"
           write(lout,*) ""
        endif
+ei

        hsy(3)=(c1m3*hsy(3))*dble(ition)                                 !hr01
        do 310 jj=1,nele
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*dble(itionc(jj))     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(lout,*) ''
          write(lout,*) 'Calling thin6dua subroutine'
          write(lout,*) ''

+if collimat
          if (do_coll) then
            write(lout,*)
            write(lout,*) "ERROR"
            write(lout,*) "thin6dua not supported by collimation"
            STOP
          endif
+ei
          call thin6dua(nthinerr)
        else
+if collimat
          call collimate_init()
!================================================================================
!Ralph make loop over 1e6/napx, a read xv(1,j) etc
!Du solltest zur Sicherheit dies resetten bevor Du in thin6d gehst
!Im Falle von Teilchenverluste werden n mlich pstop und nnumxv umgesetzt
!      do 80 i=1,npart
!        pstop(i)=.false.
!        nnumxv(i)=numl
!   80 numxv(i)=numl
!================================================================================
          do j = 1, int(mynp/napx00)
            write(lout,*) 'Sample number ', j, int(mynp/napx00)

            call collimate_start_sample(j)

            write(lout,*) ''
            write(lout,*) 'Calling thin6d subroutine'
            write(lout,*) ''
            call thin6d(nthinerr)

            call collimate_end_sample(j)

          end do
+ei ! endif collimat
+if .not.collimat
          write(lout,*) ''
          write(lout,*) 'Calling thin6d subroutine'
          write(lout,*) ''
          call thin6d(nthinerr)
+ei
        endif !end if(abs(phas).ge.pieni) then
      endif !end if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then ... else
+if collimat
      call collimate_exit()
+ei
      return
      end

!>
!!  TRACK THIN LENS 4D
!!  F. SCHMIDT
!<
      subroutine thin4d(nthinerr)
+if datamods
      use bigmats
+ei
      implicit none
+ca exactvars
+ca commonex
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,xlvj,xrb, &
     &yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca dbdcum
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
!-----------------------------------------------------------------------
      nthinerr=0
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN4D SIXTRACR restart numlcr',numlcr,'numl',numl
      endif
! and now reset numl to do only numlmax turns
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 640, n=numlcr,nnuml
+ei
+if .not.cr
      do 640 n=1,numl !loop over turns
+ei
+if boinc
!        call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
        numx=n-1

        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif


        do 630 i=1,iu !loop over structure elements, single element: name + type + parameter, structure element = order of single elements/blocks
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo ! ix = index of single element
!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
+ca dumplines
      endif

+if time
+ca timefct
+ei
          goto(10,  630,  740, 630, 630, 630, 630, 630, 630, 630, !1-10
     &         30,  50,   70,   90, 110, 130, 150, 170, 190, 210, !11-20
     &         420, 440, 460,  480, 500, 520, 540, 560, 580, 600, !21-30
     &         620, 390, 230,  250, 270, 290, 310, 330, 350, 370, !31-40
     &         680, 700, 720,  630, 748, 630, 630, 630, 630, 630, !41-50
     &         745, 746, 751,  752, 753, 754, 630, 630, 630, 630, !51-60
     &         630, 630, 761),ktrack(i) ! 630 = skip element
          goto 630
   10     stracki=strack(i) 
          if(iexact.eq.0) then ! exact drift?
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
            enddo
          else
+ca ex4Ddrift
          endif
          goto 630
!--HORIZONTAL DIPOLE
   30     do 40 j=1,napx
+ca kickv01h ! astuce block with kick for element
   40     continue
          goto 620
!--NORMAL QUADRUPOLE
   50     do 60 j=1,napx
+ca alignva
+ca kickvxxh
   60     continue
          goto 620
!--NORMAL SEXTUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
   80     continue
          goto 620
!--NORMAL OCTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  100     continue
          goto 620
!--NORMAL DECAPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 620
!--NORMAL DODECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 620
!--NORMAL 14-POLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 620
!--NORMAL 16-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 620
!--NORMAL 18-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 620
!--NORMAL 20-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 620
  230     continue
          do 240 j=1,napx
+ca alignvb
+ca mul4v01
  240     continue
          goto 620
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
  260     continue
          goto 390
  270     continue
          do 280 j=1,napx
+ca mul4v02
  280     continue
          goto 620
  290     continue
          do 300 j=1,napx
+ca mul4v02
  300     continue
          goto 390
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v03
  320     continue
          goto 620
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
  340     continue
          goto 390
  350     continue
          do 360 j=1,napx
+ca mul4v04
  360     continue
          goto 620
  370     continue
          do 380 j=1,napx
+ca mul4v04
  380     continue
  390     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 410 j=1,napx
+ca alignvb
+ca mul4v05
                do 400 k=3,nmz
+ca mul4v06
  400           continue
+ca mul4v07
  410       continue
          else
            do 415 j=1,napx
+ca mul4v08
  415       continue
          endif
          goto 620
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  420     do 430 j=1,napx
+ca kickv01v
  430     continue
          goto 620
!--SKEW QUADRUPOLE
  440     do 450 j=1,napx
+ca alignva
+ca kickvxxv
  450     continue
          goto 620
!--SKEW SEXTUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  470     continue
          goto 620
!--SKEW OCTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  490     continue
          goto 620
!--SKEW DECAPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 620
!--SKEW DODECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 620
!--SKEW 14-POLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 620
!--SKEW 16-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 620
!--SKEW 18-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 620
!--SKEW 20-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 620
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 620
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 620
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 620
  740     continue
+ca trom40
+ca trom42
          goto 620
  745     continue
          xory=1
+ca acdipkick
          goto 620
  746     continue
          xory=2
+ca acdipkick
          goto 620
  751     continue
          xory=1
+ca crabkick
          goto 620
  752     continue
          xory=2
+ca crabkick
          goto 620
!--DIPEDGE ELEMENT
  753      continue
         do j=1,napx
+ca alignva
+ca kickvdpe
         enddo
          goto 620
!--solenoid
  754      continue
         do j=1,napx
+ca kickvso1
         enddo
          goto 620
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
          goto 620
!--Wire

  748     continue
+ca wirekick
  750     continue
          goto 620

!----------------------------

  620     continue

+ca lostpart

      if (.not. ldumpfront) then
+ca dumplines
      endif

  630   continue
        call lostpart(nthinerr)
        if(nthinerr.ne.0) return
        if(ntwin.ne.2) call dist1
        if(mod(n,nwr(4)).eq.0) call write6(n)
+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei
  640 continue
      return
      end

!>
!!  TRACK THIN LENS 6D
!!  F. SCHMIDT
!<
      subroutine thin6d(nthinerr)
+if datamods
      use bigmats
+ei
+if beamgas
! <b>Additions/modifications:</b>
! - YIL: Added call to beamGas subroutine if element name starts with 
!   'press' or 'PRESS' (only for first turn)
! - YIL: Added call to beamGasInit just after readcollimator
+ei
      implicit none
+ca exactvars
+ca commonex
+ca crcoall
+if crlibm
+ca crlibco
+ei
+if hdf5
!   YIL: In order to make sure we are sending the correct
!        data types to appendreading..
       INTEGER hdfturn,hdfpid,hdftyp
       DOUBLE PRECISION hdfx,hdfxp,hdfy,hdfyp,hdfdee,hdfs
+ei
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,  &
     &xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,acdipamp1,       &
     &crabamp,crabfreq,                                                 &
     &crabamp2,crabamp3,crabamp4
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim

+if collimat
+ca collpara
+ca dbcommon
+ca dbthin6d
+ca database
+ca dblinopt
+ca dbpencil
+ca info
+ca dbcolcom
+ei

+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei

+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca dbdcum
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0d-4
+ei
      nthinerr=0
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei

!This is the loop over turns: label 660
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
      endif
! and now reset numl to do only numlmax turns
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 660 n=numlcr,nnuml
+ei
+if .not.cr
      do 660 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
+if collimat
        call collimate_start_turn(n)
+ei
        numx=n-1

        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei
      
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

!! This is the loop over each element: label 650
        do 650 i=1,iu
+if collimat
      call collimate_start_element(i)
+ei
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo

+if beamgas
!YIL Call beamGas subroutine whenever a pressure-element is found
! should be faster/safer to first check the turn then do the name search
      if( iturn.eq.1 ) then
        if (bez(myix)(1:5).eq.'PRESS' .or.     
     &    bez(myix)(1:5).eq.'press' ) then
               call beamGas(myix, secondary,totals,myenom,ipart)
         endif
      endif
+ei beamgas

!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
+ca dumplines
      endif
      
+if time
+ca timefct
+ei

+if .not.collimat
!---------count:44
+if debug
!         if (n.eq.1) then
!           write (93,*) 'ktrack(i)=',ktrack(i)
!           endfile (93,iostat=ierro)
!           backspace (93,iostat=ierro)
!         endif
+ei
! JBG RF CC Multipoles
! JBG adding CC multipoles elements in tracking. ONLY in thin6d!!!
! JBG 755 -RF quad, 756 RF Sext, 757 RF Oct
          goto( 10, 30,740,650,650,650,650,650,650,650,!1-10
     &          50, 70, 90,110,130,150,170,190,210,230,!11-20
     &         440,460,480,500,520,540,560,580,600,620,!21-30
     &         640,410,250,270,290,310,330,350,370,390,!31-40
     &         680,700,720,730,748,650,650,650,650,650,!41-50
     &         745,746,751,752,753,754,755,758,756,759,!51-60
     &         757,760,761),ktrack(i)
+ei
+if collimat
!          if (myktrack .eq. 1) then !BLOCK of linear elements
!             write (*,*) "Kick for element", i,ix, "[BLOCK]"
!          else
!             write(*,*) "Kick for element", i,ix,bez(ix),myktrack,kp(ix)
!          endif
          goto(10,  30, 740, 650, 650, 650, 650, 650, 650, 650, !1-10
     &         50,  70,  90, 110, 130, 150, 170, 190, 210, 230, !11-20
     &        440, 460, 480, 500, 520, 540, 560, 580, 600, 620, !21-30
     &        640, 410, 250, 270, 290, 310, 330, 350, 370, 390, !31-40
     &        680, 700, 720, 730, 748, 650, 650, 650, 650, 650, !41-50
     &        745, 746, 751, 752, 753, 754, 755, 758, 756, 759, !51-60
     &        757, 760, 761 ),myktrack
          write (lout,*) "WARNING: Non-handled element in thin6d()!",
     &                " i=", i, "ix=", ix, "myktrack=",  myktrack,
     &                " bez(ix)='", bez(ix),"' SKIPPED"
+ei
          goto 650

   10     stracki=strack(i)
+if collimat

!==========================================
!Ralph drift length is stracki
!bez(ix) is name of drift
          totals=totals+stracki
!          write(*,*) 'ralph> Drift, total length: ', stracki,totals

!________________________________________________________________________
!++  If we have a collimator then...
!
!Feb2006
!GRD (June 2005) 'COL' option is for RHIC collimators
!
!     SR (17-01-2006): Special assignment to the TCS.TCDQ for B1 and B4,
!     using the new naming as in V6.500.
!     Note that this must be in the loop "if TCSG"!!
!
!     SR, 17-01-2006: Review the TCT assignments because the MADX names
!     have changes (TCTH.L -> TCTH.4L)
!
! JULY 2008 added changes (V6.503) for names in TCTV -> TCTVA and TCTVB 
! both namings before and after V6.503 can be used 
!
          if (do_coll .and.
     &         (bez(myix)(1:2).eq.'TC'                                  &
     &         .or. bez(myix)(1:2).eq.'tc'                              &
     &         .or. bez(myix)(1:2).eq.'TD'                              &
     &         .or. bez(myix)(1:2).eq.'td'                              &
     &         .or. bez(myix)(1:3).eq.'COL'                             &
     &         .or. bez(myix)(1:3).eq.'col')) then

          call collimate_start_collimator(stracki)

!++ For known collimators
          if (found) then
            call collimate_do_collimator(stracki)
            call collimate_end_collimator()
          endif ! end of check for 'found'
!------------------------------------------------------------------
!++  Here leave the known collimator IF loop...
!_______________________________________________________________________
!++  If it is just a drift...
          else
            do 23 j=1,napx
                xv(1,j)=xv(1,j)+stracki*yv(1,j)
                xv(2,j)=xv(2,j)+stracki*yv(2,j)
+if rvet
            rvet(j)=c1e3*pma*pma*(two+dpsv(j))*dpsv(j)/e0/(one+dpsv(j))
            rvet(j)=rvet(j)/(e0*(one+dpsv(j))+                          &
     &sqrt(e0*e0+e0f*e0f*(two*dpsv(j)+dpsv(j)*dpsv(j))))
            sigmv(j)=sigmv(j)+stracki*(rvet(j)-c5m4*rvv(j)*(yv(1,j)     &
     &*yv(1,j)+yv(2,j)*yv(2,j)))
+ei
+if fast
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &
     &*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
+ei
+if .not.fast.and..not.rvet
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt(c1e6+yv(1,j)    &
     &*yv(1,j)+yv(2,j)*yv(2,j)))
+ei
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
              pj     = ejv(j)/1.e3

              if(firstrun) then
                if (iturn.eq.1.and.j.eq.1) then
                  sum_ax(ie)=0d0
                  sum_ay(ie)=0d0
                endif
              endif

              gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
              gammay = (1d0 + talphay(ie)**2)/tbetay(ie)

              if (part_abs(j).eq.0) then
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &2d0*talphax(ie)*xj*xpj +                                          &
     &tbetax(ie)*xpj**2 )/myemitx0_collgap
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &2d0*talphay(ie)*yj*ypj +                                          &
     &tbetay(ie)*ypj**2 )/myemity0_collgap
     &)
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
              else
                nspx = 0d0
                nspy = 0d0
              endif
                sampl(ie)    = totals
                ename(ie)    = bez(myix)(1:16)

 23           continue

          endif
          goto 650
!GRD END OF THE CHANGES FOR COLLIMATION STUDIES, BACK TO NORMAL SIXTRACK STUFF
+ei

+if .not.collimat
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
+ca sqrtv
            enddo
          else
+ca ex6Ddrift
          endif
          goto 650
+ei
   30     do 40 j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(kz(ix).eq.12) then
+if crlibm
              ejv(j)=ejv(j)+ed(ix)*sin_rn(hsyc(ix)*sigmv(j)+
+ei
+if .not.crlibm
              ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+               &
+ei
     &phasc(ix))
            else
+if crlibm
              ejv(j)=ejv(j)+hsy(1)*sin_rn(hsy(3)*sigmv(j))
+ei
+if .not.crlibm
              ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j))
+ei
            endif
            ejfv(j)=sqrt(ejv(j)**2-pma**2)                               !hr01
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
            yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
 40       continue
          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
+ca kickv01h
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvxxh
   80     continue
          goto 640
  755     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul2
          goto 640
  758     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul2s
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  100     continue
          goto 640
  756     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul3
          goto 640 
  759     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul3s
          goto 640 
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 640
! JBG RF CC Multipoles
  757     continue
          xory=1
+ca ccmul4
          goto 640
  760     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul4s
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
+ca alignvb
+ca mul4v05
                do 420 k=3,nmz
+ca mul4v06
  420           continue
+ca mul4v07
  430       continue
          else
            do 435 j=1,napx
+ca mul4v08
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
+ca kickv01v
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvxxv
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  630     continue
          goto 640

!--4D BB kick
  680     continue
          do 690 j=1,napx
+ca beamco     !Get x-y offset
+ca beamr1     !Get r**2
     &goto 690 !The radius was too small -> Skip
+ca beamr2
+ca beamr3     !Kick the particles
  690     continue
          goto 640

  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then ! fast kick
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 640
  730     continue
+ca beam6d
          goto 640
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 640
  745     continue
          xory=1
+ca acdipkick
          goto 640
  746     continue
          xory=2
+ca acdipkick
          goto 640
  751     continue
          xory=1
+ca crabkick
          goto 640
  752     continue
          xory=2
+ca crabkick
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 640
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 640
!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 640

!----------------------------
+if collimat
! end of the loop over element type (myktrack and ktrack(i))
+ei

  640     continue
!GRD UPGRADE JANUARY 2005
+if collimat
      call collimate_end_element(i)
+ei
!GRD END OF UPGRADE

+if .not.collimat
+ca lostpart
+ei

      if (.not. ldumpfront) then
+ca dumplines
      endif

 650  continue !END loop over structure elements


+if collimat
      call collimate_end_turn(n)
+ei

+if .not.collimat
        call lostpart(nthinerr)
        if(nthinerr.ne.0) return
        if(ntwin.ne.2) call dist1
        if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei

  660 continue

+if collimat
      close(99)
      close(53)

!GRD HERE WE SET THE FLAG FOR INITIALIZATION TO FALSE AFTER TURN 1
      firstrun = .false.
+ei

      return
      end

!==============================================================================
!
      subroutine thin6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THIN LENS 6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+ca exactvars
+ca commonex
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,e0fo,e0o,r0,r2b,rb,rho2b,rkb,stracki, &
     &tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca dbdcum
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0d-4
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
      nthinerr=0
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN6DUA ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 660 n=numlcr,nnuml
+ei
+if .not.cr
      do 660 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
        numx=n-1

        if(n.le.nde(1)) nwri=nwr(1)
        if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
        if(n.gt.nde(2)) nwri=nwr(3)
        if(nwri.eq.0) nwri=numl+numlr+1
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

        do 650 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo
!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
+ca dumplines
      endif
      
+if time
+ca timefct
+ei
!--------count44
          goto(10 ,30 ,740,650,650,650,650,650,650,650,!1-10
     &         50 ,70 ,90 ,110,130,150,170,190,210,230,!11-20
     &         440,460,480,500,520,540,560,580,600,620,!21-30
     &         640,410,250,270,290,310,330,350,370,390,!31-40
     &         680,700,720,730,748,650,650,650,650,650,!41-50
     &         745,746,751,752,753,754,650,650,650,650,!51-60
     &         650,650,761),ktrack(i)
          goto 650
   10     stracki=strack(i)
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
+ca sqrtv
            enddo
          else
+ca ex6Ddrift
          endif
          goto 650
   30     e0o=e0
          e0fo=e0f
          call adia(n,e0f)
          do 40 j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr
            if(kz(ix).eq.12) then
+if crlibm
              ejv(j)=ejv(j)+ed(ix)*sin_rn((hsyc(ix)*sigmv(j)+phas)+     &!hr01
     &phasc(ix))                                                         !hr01
+ei
+if .not.crlibm
              ejv(j)=ejv(j)+ed(ix)*sin((hsyc(ix)*sigmv(j)+phas)+        &
     &phasc(ix))                                                         !hr01
+ei
            else
+if crlibm
              ejv(j)=ejv(j)+hsy(1)*sin_rn(hsy(3)*sigmv(j)+phas)
+ei
+if .not.crlibm
              ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j)+phas)
+ei
            endif
!           ejfv(j)=sqrt(ejv(j)**2-pma**2)                               !hr01
            ejfv(j)=sqrt((ejv(j)-pma)*(ejv(j)+pma))
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
            if(sigmv(j).gt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
   40     yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                             !hr01
          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
+ca kickv01h
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvxxh
   80     continue
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  100     continue
          goto 640
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
+ca alignvb
+ca mul4v05
                do 420 k=3,nmz
+ca mul4v06
  420           continue
+ca mul4v07
  430       continue
          else
            do 435 j=1,napx
+ca mul4v08
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
+ca kickv01v
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvxxv
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  630     continue
          goto 640
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 640
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 640
  730     continue
+ca beam6d
          goto 640
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 640
  745     continue
          xory=1
+ca acdipkick
          goto 640
  746     continue
          xory=2
+ca acdipkick
          goto 640
  751     continue
          xory=1
+ca crabkick
          goto 640
  752     continue
          xory=2
+ca crabkick
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 640
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 640

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 640

!----------------------------

  640     continue

+ca lostpart

      if (.not. ldumpfront) then
+ca dumplines
      endif

  650   continue
        call lostpart(nthinerr)
        if(nthinerr.ne.0) return
        if(ntwin.ne.2) call dist1
        if(mod(n,nwr(4)).eq.0) call write6(n)
+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei
  660 continue
      return
      end

      subroutine writebin(nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if cr
+ca crco
+ei
      integer ia,ia2,ie,nthinerr
+if cr
      integer ncalls
+ei
+if boinc
      integer timech
+ei
+if bnlelens
+ca rhicelens
+ei
+if cr
      data ncalls /0/
+ei
      save
!-----------------------------------------------------------------------
+if cr
      ncalls=ncalls+1 
      write(91,*,iostat=ierro,err=11) numx,numl
      rewind 91
      if (restart) then
        write(93,*) 'WRITEBIN bailing out on restart'
        write(93,*) 'numl, nnuml, numx, numlcr '
        write(93,*)  numl,nnuml,numx,numlcr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        return
      else
+if .not.debug
        if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*) 'WRITEBIN numl, nnuml, numlcr, numx, nwri, numlcp '
        write(93,*) ' ',numl,nnuml,numlcr,numx,nwri,numlcp
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      endif
+ei
+if cr
+if .not.debug
      if (ncalls.le.20.or.numx.ge.nnuml-20) then      
+ei
+if bnlelens
        if (lhc.ne.9) then
          write(93,*) 'WRITEBIN writing binrec ',binrec+1
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        else
          write(93,*) 'WRITEBIN skipping write for bnlelens',binrec+1
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        endif
+ei
+if .not.bnlelens
        write(93,*) 'WRITEBIN writing binrec ',binrec+1
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+ei
+if .not.debug
      endif
+ei
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.ne.9) then
!GRDRHIC
!GRD-042008
+ei
        do 10 ia=1,napx-1
!GRD
!     PSTOP=true -> particle lost,
!     nlostp(ia)=particle ID that is not changing
!     (the particle arrays are compressed to remove lost particles)
!     In the case of no lost particles, all nlostp(i)=i for 1..npart
           if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.   &
     &(mod(nlostp(ia),2).ne.0)) then !Skip odd particle IDs
            ia2=(nlostp(ia)+1)/2     !File ID for non-STF & binrecs
            ie=ia+1                  !ia = Particle ID 1, ie = Particle ID 2
            if(ntwin.ne.2) then !Write particle nlostp(ia) only
+if .not.stf
              write(91-ia2,iostat=ierro)                                &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0
              endfile (91-ia2,iostat=ierro)
              backspace (91-ia2,iostat=ierro)
+ei
+if stf
              write(90,iostat=ierro)                                    &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0
              endfile (90,iostat=ierro)
              backspace (90,iostat=ierro)
+ei
+if cr
              binrecs(ia2)=binrecs(ia2)+1
+ei
            else !Write particle nlostp(ia) and nlostp(ia)+1
                 ! Note that dam(ia) (distance in angular phase space)
                 ! is written twice.
+if .not.stf
              write(91-ia2,iostat=ierro)                                &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0,        &
     &nlostp(ia)+1,dam(ia),                                             &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),e0
              endfile (91-ia2,iostat=ierro)
              backspace (91-ia2,iostat=ierro)
+ei
+if stf
              write(90,iostat=ierro)                                    &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0,        &
     &nlostp(ia)+1,dam(ia),                                             &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),e0
              endfile (90,iostat=ierro)
              backspace (90,iostat=ierro)
+ei
+if cr
              binrecs(ia2)=binrecs(ia2)+1
+ei
            endif
            if(ierro.ne.0) then
              write(lout,*)
              write(lout,*) '*** ERROR ***,PROBLEM WRITING TO FILE# : ',&
     &91-ia2
              write(lout,*) 'ERROR CODE : ',ierro
              write(lout,*)
+if cr
              endfile (lout,iostat=ierro)
              backspace (lout,iostat=ierro)
+ei
+if .not.cr
              endfile (12,iostat=ierro)
              backspace (12,iostat=ierro)
+ei
              nthinerr=3000
              return
            endif
          endif
   10 continue !END "do 10 ia=1,napx-1"
+if bnlelens
!GRDRHIC
!GRD-042008
      endif ! END "if (lhc.ne.9)"
!GRDRHIC
!GRD-042008
+ei
+if cr
+if .not.bnlelens
      binrec=binrec+1
+if .not.debug
      if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*) 'WRITEBIN written binrec ',binrec
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.ne.9) then
        binrec=binrec+1
+if .not.debug
        if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
          write(93,*) 'WRITEBIN written binrec ',binrec
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      endif
!GRDRHIC
!GRD-042008
+ei
      return
   11 write(lout,*)                                                     &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : 91',ierro
      call abend('SIXTRACR WRITEBIN IO ERROR on Unit 91             ')
+ei
      return
      end
      subroutine callcrp()
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if cr
+ca crco
+ei
      integer ia,ia2,ie,nthinerr
+if cr
      integer ncalls
+ei
+if boinc
      integer timech
+ei
+if bnlelens
+ca rhicelens
+ei
+if cr
      data ncalls /0/
+ei
      save
!-----------------------------------------------------------------------
+if cr
      ncalls=ncalls+1 
      write(91,*,iostat=ierro,err=11) numx,numl
      rewind 91
      if (restart) then
        write(93,*) 'CALLCRP/CRPOINT bailing out'
        write(93,*) 'numl, nnuml, numx, numlcr ',numl,nnuml,numx,numlcr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        return
      else
+if .not.debug
        if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*) 'CALLCRP numl, nnuml, numlcr, numx, nwri, numlcp '
        write(93,*) numl,nnuml,numlcr,numx,nwri,numlcp
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      endif
+if boinc
      if (checkp) then
! Now ALWAYS checkpoint
! NO, re-instated at user request
        call boinc_time_to_checkpoint(timech)
        if (timech.ne.0) then
          call crpoint
          call boinc_checkpoint_completed()
        endif
      endif
+ei
+if .not.boinc
      if (checkp) call crpoint
+ei
      return
   11 write(lout,*)                                                     &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : 91',ierro
      call abend('SIXTRACR WRITEBIN IO ERROR on Unit 91             ')
+ei
      return
      end
      subroutine lostpart(nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
!      logical isnan
      logical myisnan
      integer ib2,ib3,ilostch,j,jj,jj1,lnapx,nthinerr
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+ca lost1a
+ca lost2
+ca lost3a
+ca lost4
+ca lost5a
      subroutine lostpar2(i,ix,nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
!      logical isnan
      logical myisnan
      integer i,ib2,ib3,ilostch,ix,j,jj,jj1,lnapx,nthinerr
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+ca lost1a
+ca lost2a
+ca lost2
+ca lost3b
+ca lost4
+ca lost5b
      subroutine lostpar3(i,ix,nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
!      logical isnan
      logical myisnan
      integer i,ib2,ib3,ilostch,ix,j,jj,jj1,lnapx,nthinerr
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+ca lost1b
+ca lost2a
+ca lost2
+ca lost3b
+ca lost4
+ca lost5b
      subroutine lostpar4(i,ix,nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
!      logical isnan
      logical myisnan
      integer i,ib2,ib3,ilostch,ix,j,jj,jj1,lnapx,nthinerr
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+ca lost1c
+ca lost2a
+ca lost2
+ca lost3b
+ca lost4
+ca lost5c

      subroutine dist1
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ia,ib2,ib3,ie
      double precision dam1
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 20 ia=1,napx,2
        if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.     &
     &(mod(nlostp(ia),2).ne.0)) then
          ie=ia+1
          dam(ia)=zero
          dam(ie)=zero
          xau(1,1)= xv(1,ia)
          xau(1,2)= yv(1,ia)
          xau(1,3)= xv(2,ia)
          xau(1,4)= yv(2,ia)
          xau(1,5)=sigmv(ia)
          xau(1,6)= dpsv(ia)
          xau(2,1)= xv(1,ie)
          xau(2,2)= yv(1,ie)
          xau(2,3)= xv(2,ie)
          xau(2,4)= yv(2,ie)
          xau(2,5)=sigmv(ie)
          xau(2,6)= dpsv(ie)
          cloau(1)= clo6v(1,ia)
          cloau(2)=clop6v(1,ia)
          cloau(3)= clo6v(2,ia)
          cloau(4)=clop6v(2,ia)
          cloau(5)= clo6v(3,ia)
          cloau(6)=clop6v(3,ia)
          di0au(1)= di0xs(ia)
          di0au(2)=dip0xs(ia)
          di0au(3)= di0zs(ia)
          di0au(4)=dip0zs(ia)
          do 10 ib2=1,6
            do 10 ib3=1,6
              tau(ib2,ib3)=tasau(ia,ib2,ib3)
   10     continue
          call distance(xau,cloau,di0au,tau,dam1)
          dam(ia)=dam1
          dam(ie)=dam1
        endif
   20 continue
      return
      end
      subroutine write6(n)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ia,ia2,id,ie,ig,n
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      id=0
      do 10 ia=1,napxo,2
        ig=ia+1
        ia2=ig/2
+if .not.cr
+if .not.bnlelens
        endfile (91-ia2,iostat=ierro)
        backspace (91-ia2,iostat=ierro)
+ei
+ei
!-- PARTICLES STABLE
        if(.not.pstop(ia).and..not.pstop(ig)) then
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),n
          id=id+1
          ie=id+1
          write(lout,10010)
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          id=id+1
!-- FIRST PARTICLES LOST
        else if(pstop(ia).and..not.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
!-- SECOND PARTICLES LOST
        else if(.not.pstop(ia).and.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejv(id),ejvl(ig)
!-- BOTH PARTICLES LOST
        else if(pstop(ia).and.pstop(ig)) then
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejvl(ia),ejvl(ig)
        endif
   10 continue
+if .not.cr
      if(ierro.ne.0) write(lout,*) 'Warning from write6: fort.12 has ', &
     &'corrupted output probably due to lost particles'
      if(ierro.ne.0) then                                                !hr09
+if debug
!       call dumpbin(' write6',0,0)                                      !hr09
+ei
        call abend(' abend in write6                                  ') !hr09
      endif                                                              !hr09
+ei
      endfile (12,iostat=ierro)
      backspace (12,iostat=ierro)
+if cr
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
+ei
      return
10000 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10010 format(10x,f47.33)
      end

      subroutine dump_beam_population( nturn, i, ix, unit, fmt,         &
     &  lhighprec )
!-----------------------------------------------------------------------
!     By A.Mereghetti, D.Sinuela-Pastor & P.Garcia Ortega, for the FLUKA Team
!     K.Sjobak and A.Santamaria, BE-ABP-HSS
!     last modified: 21-09-2015
!     dump beam particles
!     always in main code
!
!     nturn     : Current turn number
!     i         : Current structure element
!     ix        : Corresponding single element (<0 for BLOC, only for ALL)
!     unit      : Unit to dump from
!     fmt       : Dump output format (0/1/2)
!     lhighprec : High precission output y/n
!-----------------------------------------------------------------------

      implicit none

!     interface variables:
      integer nturn, i, ix, unit, fmt
      logical lhighprec
      intent (in) nturn, i, ix, unit, fmt, lhighprec
+ca parpro
+ca parnum
+ca common
+ca commonmn
+ca commonm1
+ca commontr
+ca dbdcum

+if cr
+ca comgetfields
+ca dbdump
+ca dbdumpcr
+ei

+ca crcoall

+if collimat
+ca collpara
+ca dbcommon
+ei
+if .not.collimat
      integer, parameter :: samplenumber = 1
+ei


!     temporary variables
      integer j,k,l
      character*16 localBez

      double precision xyz_particle(6)
      double precision xyz(6)
      double precision xyz2(6,6)
      
+if cr      
      !For accessing dumpfilepos
      integer dumpIdx
      if( unit .eq. dumpunit(0) ) then
         ! ALL output must be on separate unit
         dumpIdx = 0
      else
         dumpIdx = ix
      endif
+ei
      if ( ktrack(i) .ne. 1 ) then
         localBez = bez(ix)
      else
         localBez = bezb(ic(i))
      endif
      
      ! General format
      if ( fmt .eq. 0 ) then
         if ( lhighprec ) then
            do j=1,napx
               write(unit,1981) nturn, i, ix, localBez, dcum(i),        &
     &xv(1,j)*1d-3, yv(1,j)*1d-3, xv(2,j)*1d-3, yv(2,j)*1d-3,           &
     &ejfv(j)*1d-3, (ejv(j)-e0)*1d6, -1.0d-03*(sigmv(j)/clight)*(e0/e0f)
            enddo
         else
            do j=1,napx
               write(unit,1982) nturn, i, ix, localBez, dcum(i),        &
     &xv(1,j)*1d-3, yv(1,j)*1d-3, xv(2,j)*1d-3, yv(2,j)*1d-3,           &
     &ejfv(j)*1d-3, (ejv(j)-e0)*1d6, -1.0d-03*(sigmv(j)/clight)*(e0/e0f)
            enddo
         endif
         write(unit,*) ''
         write(unit,*) ''
         
         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx+2
+ei
      
      ! Format for aperture check
      else if (fmt .eq. 1) then
         if ( lhighprec ) then
            do j=1,napx
               write(unit,1983) nlostp(j)+(samplenumber-1)*npart,
     &              nturn, dcum(i), xv(1,j),
     &              yv(1,j), xv(2,j), yv(2,j), (ejv(j)-e0)/e0, ktrack(i)
            enddo
         else
            do j=1,napx
               write(unit,1984) nlostp(j)+(samplenumber-1)*npart,
     &              nturn, dcum(i), xv(1,j),
     &              yv(1,j), xv(2,j), yv(2,j), (ejv(j)-e0)/e0, ktrack(i)
            enddo
         endif
         
         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei

      ! Same as fmt 1, but also include z (for crab cavities etc.)
      else if (fmt .eq. 2) then
         if ( lhighprec ) then
            do j=1,napx
               write(unit,1985) nlostp(j)+(samplenumber-1)*npart,
     &              nturn, dcum(i), xv(1,j),
     &              yv(1,j), xv(2,j), yv(2,j), sigmv(j),
     &              (ejv(j)-e0)/e0, ktrack(i)
            enddo
         else
            do j=1,napx
               write(unit,1986) nlostp(j)+(samplenumber-1)*npart,
     &              nturn, dcum(i), xv(1,j),
     &              yv(1,j), xv(2,j), yv(2,j), sigmv(j),
     &              (ejv(j)-e0)/e0, ktrack(i)
            enddo
         endif

         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
      
      else if (fmt .eq. 3) then
         do j=1,napx
            write(unit) nlostp(j)+(samplenumber-1)*npart,
     &           nturn, dcum(i), xv(1,j),
     &           yv(1,j), xv(2,j), yv(2,j), sigmv(j),
     &           (ejv(j)-e0)/e0, ktrack(i)
         enddo
         
         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+napx
+ei
      else if (fmt .eq. 4) then
         do l=1,6
            xyz(l) = 0.0
         end do
         
         do j=1,napx
            xyz(1) = xyz(1) + xv(1,j)
            xyz(2) = xyz(2) + yv(1,j)
            xyz(3) = xyz(3) + xv(2,j)
            xyz(4) = xyz(4) + yv(2,j)
            xyz(5) = xyz(5) + sigmv(j)
            xyz(6) = xyz(6) + (ejv(j)-e0)/e0
         enddo

         xyz = xyz/napx
         if ( lhighprec ) then
            write(unit,1989) napx, nturn, dcum(i),
     &           xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6)
         else
            write(unit,1990) napx, nturn, dcum(i),
     &           xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6)
         endif

         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+1
+ei
      
      else if (fmt.eq.5 .or. fmt.eq.6) then !Matrix
         do l=1,6
            xyz(l) = 0.0
            do k=1,6
               xyz2(l,k) = 0.0
            end do
         end do
         
         if(fmt.eq.5) then !Raw
            do j=1,napx
               xyz_particle(6)=(ejv(j)-e0)/e0

               !Average beam position
               xyz(1) = xyz(1) + xv(1,j)
               xyz(2) = xyz(2) + yv(1,j)
               xyz(3) = xyz(3) + xv(2,j)
               xyz(4) = xyz(4) + yv(2,j)
               xyz(5) = xyz(5) + sigmv(j)
               xyz(6) = xyz(6) + xyz_particle(6)
               
               !Beam matrix (don't calulate identical elements twice (symmetry))
               xyz2(1,1) = xyz2(1,1) + xv(1,j)*xv(1,j)
               xyz2(2,1) = xyz2(2,1) + xv(1,j)*yv(1,j)
               xyz2(3,1) = xyz2(3,1) + xv(1,j)*xv(2,j)
               xyz2(4,1) = xyz2(4,1) + xv(1,j)*yv(2,j)
               xyz2(5,1) = xyz2(5,1) + xv(1,j)*sigmv(j)
               xyz2(6,1) = xyz2(6,1) + xv(1,j)*xyz_particle(6)
               
               xyz2(2,2) = xyz2(2,2) + yv(1,j)*yv(1,j)
               xyz2(3,2) = xyz2(3,2) + yv(1,j)*xv(2,j)
               xyz2(4,2) = xyz2(4,2) + yv(1,j)*yv(2,j)
               xyz2(5,2) = xyz2(5,2) + yv(1,j)*sigmv(j)
               xyz2(6,2) = xyz2(6,2) + yv(1,j)*xyz_particle(6)
               
               xyz2(3,3) = xyz2(3,3) + xv(2,j)*xv(2,j)
               xyz2(4,3) = xyz2(4,3) + xv(2,j)*yv(2,j)
               xyz2(5,3) = xyz2(5,3) + xv(2,j)*sigmv(j)
               xyz2(6,3) = xyz2(6,3) + xv(2,j)*xyz_particle(6)
               
               xyz2(4,4) = xyz2(4,4) + yv(2,j)*yv(2,j)
               xyz2(5,4) = xyz2(5,4) + yv(2,j)*sigmv(j)
               xyz2(6,4) = xyz2(6,4) + yv(2,j)*xyz_particle(6)
               
               xyz2(5,5) = xyz2(5,5) + sigmv(j)*sigmv(j)
               xyz2(6,5) = xyz2(6,5) + sigmv(j)*xyz_particle(6)
               
               xyz2(6,6) = xyz2(6,6) + xyz_particle(6)*xyz_particle(6)
            enddo
         else if (fmt.eq.6) then !Canonical
            do j=1,napx
               xyz_particle(1) = xv(1,j)*c1m3                 !x:      [mm]   -> [m]
               xyz_particle(2) = (yv(1,j)*c1m3)*(one+dpsv(j)) !px:     [mrad] -> [1]
               xyz_particle(3) = xv(2,j)*c1m3                 !y:      [mm]   -> [m]
               xyz_particle(4) = (yv(2,j)*c1m3)*(one+dpsv(j)) !py:     [mrad] -> [1]
               xyz_particle(5) = sigmv(j)*c1m3                !sigma:  [mm]   -> [m]
               xyz_particle(6) = (((ejv(j)-e0)*e0)/e0f)/e0f   !psigma: [MeV]  -> [1]
               
               !Average beam position
               xyz(1) = xyz(1) + xyz_particle(1)
               xyz(2) = xyz(2) + xyz_particle(2)
               xyz(3) = xyz(3) + xyz_particle(3)
               xyz(4) = xyz(4) + xyz_particle(4)
               xyz(5) = xyz(5) + xyz_particle(5)
               xyz(6) = xyz(6) + xyz_particle(6)
               
               !Beam matrix (don't calulate identical elements twice (symmetry))
               xyz2(1,1) = xyz2(1,1) + xyz_particle(1)*xyz_particle(1)
               xyz2(2,1) = xyz2(2,1) + xyz_particle(1)*xyz_particle(2)
               xyz2(3,1) = xyz2(3,1) + xyz_particle(1)*xyz_particle(3)
               xyz2(4,1) = xyz2(4,1) + xyz_particle(1)*xyz_particle(4)
               xyz2(5,1) = xyz2(5,1) + xyz_particle(1)*xyz_particle(5)
               xyz2(6,1) = xyz2(6,1) + xyz_particle(1)*xyz_particle(6)
               
               xyz2(2,2) = xyz2(2,2) + xyz_particle(2)*xyz_particle(2)
               xyz2(3,2) = xyz2(3,2) + xyz_particle(2)*xyz_particle(3)
               xyz2(4,2) = xyz2(4,2) + xyz_particle(2)*xyz_particle(4)
               xyz2(5,2) = xyz2(5,2) + xyz_particle(2)*xyz_particle(5)
               xyz2(6,2) = xyz2(6,2) + xyz_particle(2)*xyz_particle(6)
               
               xyz2(3,3) = xyz2(3,3) + xyz_particle(3)*xyz_particle(3)
               xyz2(4,3) = xyz2(4,3) + xyz_particle(3)*xyz_particle(4)
               xyz2(5,3) = xyz2(5,3) + xyz_particle(3)*xyz_particle(5)
               xyz2(6,3) = xyz2(6,3) + xyz_particle(3)*xyz_particle(6)
               
               xyz2(4,4) = xyz2(4,4) + xyz_particle(4)*xyz_particle(4)
               xyz2(5,4) = xyz2(5,4) + xyz_particle(4)*xyz_particle(5)
               xyz2(6,4) = xyz2(6,4) + xyz_particle(4)*xyz_particle(6)
               
               xyz2(5,5) = xyz2(5,5) + xyz_particle(5)*xyz_particle(5)
               xyz2(6,5) = xyz2(6,5) + xyz_particle(5)*xyz_particle(6)
               
               xyz2(6,6) = xyz2(6,6) + xyz_particle(6)*xyz_particle(6)
            enddo
         end if
         
         !Normalize
         xyz = xyz/napx
         
         xyz2(:,1)  = xyz2(:,1) /napx
         xyz2(2:,2) = xyz2(2:,2)/napx
         xyz2(3:,3) = xyz2(3:,3)/napx
         xyz2(4:,4) = xyz2(4:,4)/napx
         xyz2(5:,5) = xyz2(5:,5)/napx
         xyz2(6,6)  = xyz2(6,6) /napx
         
         if ( lhighprec ) then
            write(unit,1991) napx, nturn, dcum(i),
     &           xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6),
     &      xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),
     &                xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),
     &                          xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),
     &                                    xyz2(4,4),xyz2(5,4),xyz2(6,4),
     &                                              xyz2(5,5),xyz2(6,5),
     &                                                        xyz2(6,6)
         else
            write(unit,1992) napx, nturn, dcum(i),
     &           xyz(1),xyz(2),xyz(3),xyz(4),xyz(5),xyz(6),
     &      xyz2(1,1),xyz2(2,1),xyz2(3,1),xyz2(4,1),xyz2(5,1),xyz2(6,1),
     &                xyz2(2,2),xyz2(3,2),xyz2(4,2),xyz2(5,2),xyz2(6,2),
     &                          xyz2(3,3),xyz2(4,3),xyz2(5,3),xyz2(6,3),
     &                                    xyz2(4,4),xyz2(5,4),xyz2(6,4),
     &                                              xyz2(5,5),xyz2(6,5),
     &                                                        xyz2(6,6)
         endif

         !Flush
         endfile (unit,iostat=ierro)
         backspace (unit,iostat=ierro)
+if cr
         dumpfilepos(dumpIdx) = dumpfilepos(dumpIdx)+1
+ei

      !Unrecognized format fmt
      else
         write (lout,*)
     & "DUMP> Format",fmt, "not understood for unit", unit
         call prror(-1)
      endif
      return

 1981 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE25.18)) !fmt 0 / hiprec
 1982 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE16.9))  !fmt 0 / not hiprec

 1983 format (2(1x,I8),1X,F12.5,5(1X,1PE25.18),1X,I8)  !fmt 1 / hiprec
 1984 format (2(1x,I8),1X,F12.5,5(1X,1PE16.9),1X,I8)   !fmt 1 / not hiprec

 1985 format (2(1x,I8),1X,F12.5,6(1X,1PE25.18),1X,I8)  !fmt 2 / hiprec
 1986 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9),1X,I8)   !fmt 2 / not hiprec

 1989 format (2(1x,I8),1X,F12.5,6(1X,1PE25.18))        !fmt 4 / hiprec
 1990 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9))         !fmt 4 / not hiprec
      
 1991 format (2(1x,I8),1X,F12.5,27(1X,1PE25.18))       !fmt 5&6 / hiprec
 1992 format (2(1x,I8),1X,F12.5,27(1X,1PE16.9))        !fmt 5&6 / not hiprec
      
      end subroutine

+dk tra_thck
      subroutine trauthck(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      double precision benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
      dimension nbeaux(nbb)
+ca stringzerotrim
+ca comdynk
      logical dynk_isused
+if collimat
+ca database
+ei
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
+if collimat
      if (do_coll) then
         write(lout,*) "Error: in trauthck and do_coll is TRUE"
         write(lout,*) "Collimation is not supported for thick tracking"
         STOP
      endif
+ei

      do 5 i=1,npart
        nlostp(i)=i
   5  continue
      do 10 i=1,nblz
        ktrack(i)=0
        strack(i)=zero
        strackc(i)=zero
        stracks(i)=zero
   10 continue
+ca beams1
      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        !BLOC
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        !Non-linear/NOT BLOC
        goto 290
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
        kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        else if(kzz.eq.12) then
          !Disabled cavity; enabled cavities have kp=6 and are handled above
          ! Note: kz=-12 are transformed into +12 in daten after reading ENDE.
          ktrack(i)=31
          goto 290
        endif
+ca beams21
+ca beamcoo
+ca beamr1
     &goto 42
+ca beamr2
+ca beamr3o
+ca beams22
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4o
+ca beams23
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4o
+ca beams24
+ca wire
+ca elens
+ca acdip1
+ca crab1
+ca crab_mult
+ca trom30
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),   &
     &extalign(i,2),extalign(i,3)
        endif
        if(kzz.lt.0) goto 180
        goto(50,60,70,80,90,100,110,120,130,140,150,290,290,290,        &
     &       290,290,290,290,290,290,290,290,290,145,146),kzz
        ktrack(i)=31
        goto 290
   50   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=11
+ca stra01
        goto 290
   60   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=12
+ca stra02
        goto 290
   70   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=13
+ca stra03
        goto 290
   80   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=14
+ca stra04
        goto 290
   90   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=15
+ca stra05
        goto 290
  100   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=16
+ca stra06
        goto 290
  110   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=17
+ca stra07
        goto 290
  120   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=18
+ca stra08
        goto 290
  130   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=19
+ca stra09
        goto 290
  140   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=20
+ca stra10
        goto 290
!--DIPEDGE ELEMENT
  145   continue 
+ca stra2dpe
        ktrack(i)=55
        goto 290
!--solenoid
  146   continue 
+ca solenoid
        ktrack(i)=56
        goto 290
!--Multipole block (also in initialize_element)
  150   r0=ek(ix)
        nmz=nmu(ix)
        if(abs(r0).le.pieni.or.nmz.eq.0) then
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            if ( dynk_isused(i) ) then
              write(lout,*)
     &        "ERROR: Element of type 11 (bez=",bez(ix),
     &        ") is off in fort.2, but on in DYNK. Not implemented."
              call prror(-1)
            endif
            ktrack(i)=31
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=33
+ca stra11
            else
              ktrack(i)=35
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=37
+ca stra13
            else
              ktrack(i)=39
+ca stra14
            endif
          endif
        else
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=32
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=34
+ca stra11
            else
              ktrack(i)=36
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=38
+ca stra13
            else
              ktrack(i)=40
+ca stra14
            endif
          endif
        endif
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
        if(mout2.eq.1) then
          benkcc=ed(ix)*benkc(irm(ix))
          r0a=one
          r000=r0*r00(irm(ix))
          do 160 j=1,mmul
            fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
            fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
  160     r0a=r0a*r000
          write(9,'(a16)') bez(ix)
          write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
          write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
          do 170 j=1,20
            fake(1,j)=zero
  170     fake(2,j)=zero
        endif
        goto 290
        
        !Negative KZZ
  180   kzz=-kzz
        goto(190,200,210,220,230,240,250,260,270,280),kzz
        ktrack(i)=31
        goto 290
  190   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=21
+ca stra01
        goto 290
  200   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=22
+ca stra02
        goto 290
  210   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=23
+ca stra03
        goto 290
  220   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=24
+ca stra04
        goto 290
  230   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=25
+ca stra05
        goto 290
  240   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=26
+ca stra06
        goto 290
  250   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=27
+ca stra07
        goto 290
  260   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=28
+ca stra08
        goto 290
  270   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=29
+ca stra09
        goto 290
  280   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=30
+ca stra10
  290 continue
      do 300 j=1,napx
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  300 continue
      nwri=nwr(3)
      if(nwri.eq.0) nwri=numl+numlr+1

!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     save original kicks
!     always in main code
      if (ldynk) call dynk_pretrack

      if(idp.eq.0.or.ition.eq.0) then
        write(lout,*) ''
        write(lout,*) 'Calling thck4d subroutine'
        write(lout,*) ''
        call thck4d(nthinerr)
      else
        hsy(3)=(c1m3*hsy(3))*dble(ition)                                 !hr01
        do 310 jj=1,nele
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*dble(itionc(jj))     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(lout,*) ''
          write(lout,*) 'Calling thck6dua subroutine'
          write(lout,*) ''
          call thck6dua(nthinerr)
        else
          write(lout,*) ''
          write(lout,*) 'Calling thck6d subroutine'
          write(lout,*) ''
          call thck6d(nthinerr)
        endif
      endif
      return
      end
      subroutine thck4d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 4D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,idz1,idz2,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve,puzve,r0,r2b,rb,rho2b,rkb,tkb,xbb,xlvj, &
     &xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1,crabamp,crabfreq
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
!-----------------------------------------------------------------------
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK4D ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 490 n=numlcr,nnuml
+ei
+if .not.cr
      do 490 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

          do 480 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
         write (lout,*) 
     & "DUMP/FRONT not yet supported on thick elements "//
     & "due to lack of test cases. Please contact developers!"
      stop
!+ca dumplines
      endif
      
+if time
+ca timefct
+ei
            endif

!----------count=43
            goto( 20,480,740,480,480,480,480,480,480,480,!1-10
     &            40, 60, 80,100,120,140,160,180,200,220,!11-20
     &           270,290,310,330,350,370,390,410,430,450,!21-30
     &           470,240,500,520,540,560,580,600,620,640,!31-40
     &           680,700,720,480,748,480,480,480,480,480,!41-50
     &           745,746,751,752,753,754,480,480,480,480,!51-60
     &           480,480,761),ktrack(i)
            goto 480
   20       do 30 j=1,napx
              puxve=xv(1,j)
              puzve=yv(1,j)
              xv(1,j)=bl1v(1,1,j,ix)*puxve+bl1v(2,1,j,ix)*puzve+        &!hr01
     &((dble(idz1)*bl1v(5,1,j,ix))*dpsv(j))*c1e3                         !hr01
              yv(1,j)=bl1v(3,1,j,ix)*puxve+bl1v(4,1,j,ix)*puzve+        &!hr01
     &((dble(idz1)*bl1v(6,1,j,ix))*dpsv(j))*c1e3                         !hr01
              puxve=xv(2,j)
              puzve=yv(2,j)
              xv(2,j)=bl1v(1,2,j,ix)*puxve+bl1v(2,2,j,ix)*puzve+        &!hr01
     &((dble(idz2)*bl1v(5,2,j,ix))*dpsv(j))*c1e3                         !hr01
              yv(2,j)=bl1v(3,2,j,ix)*puxve+bl1v(4,2,j,ix)*puzve+        &!hr01
     &((dble(idz2)*bl1v(6,2,j,ix))*dpsv(j))*c1e3                         !hr01
   30       continue
            goto 480
!--HORIZONTAL DIPOLE
   40       do 50 j=1,napx
+ca kickv01h
   50       continue
            goto 470
!--NORMAL QUADRUPOLE
   60       do 70 j=1,napx
+ca alignva
+ca kickvxxh
   70       continue
            goto 470
!--NORMAL SEXTUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
   90       continue
            goto 470
!--NORMAL OCTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  110       continue
            goto 470
!--NORMAL DECAPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 470
!--NORMAL DODECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 470
!--NORMAL 14-POLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 470
!--NORMAL 16-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 470
!--NORMAL 18-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 470
!--NORMAL 20-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 470
  500     continue
          do 510 j=1,napx
+ca alignvb
+ca mul4v01
  510     continue
          goto 470
  520     continue
          do 530 j=1,napx
+ca alignvb
+ca mul4v01
  530     continue
          goto 240
  540     continue
          do 550 j=1,napx
+ca mul4v02
  550     continue
          goto 470
  560     continue
          do 570 j=1,napx
+ca mul4v02
  570     continue
          goto 240
  580     continue
          do 590 j=1,napx
+ca alignvb
+ca mul4v03
  590     continue
          goto 470
  600     continue
          do 610 j=1,napx
+ca alignvb
+ca mul4v03
  610     continue
          goto 240
  620     continue
          do 630 j=1,napx
+ca mul4v04
  630     continue
          goto 470
  640     continue
          do 650 j=1,napx
+ca mul4v04
  650     continue
  240       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 260 j=1,napx
+ca alignvb
+ca mul4v05
                do 250 k=3,nmz
+ca mul4v06
  250           continue
+ca mul4v07
  260       continue
          else
            do 265 j=1,napx
+ca mul4v08
  265       continue
          endif
            goto 470
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  270       do 280 j=1,napx
+ca kickv01v
  280       continue
            goto 470
!--SKEW QUADRUPOLE
  290       do 300 j=1,napx
+ca alignva
+ca kickvxxv
  300       continue
            goto 470
!--SKEW SEXTUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  320       continue
            goto 470
!--SKEW OCTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  340       continue
            goto 470
!--SKEW DECAPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 470
!--SKEW DODECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 470
!--SKEW 14-POLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 470
!--SKEW 16-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 470
!--SKEW 18-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 470
!--SKEW 20-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
          goto 470
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 470
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 470
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 470
  740     continue
+ca trom40
+ca trom42
          goto 470
  745     continue
          xory=1
+ca acdipkick
          goto 470
  746     continue
          xory=2
+ca acdipkick
          goto 470
  751     continue
          xory=1
+ca crabkick
          goto 470
  752     continue
          xory=2
+ca crabkick
          goto 470
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 470
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
          enddo
          goto 470
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 470

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 470

!----------------------------

  470     continue

+ca lostpart

      if (.not. ldumpfront) then
+ca dumplines
      endif

  480     continue
          call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei
  490 continue
      return
      end
      subroutine thck6d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 6D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,rb,rho2b,  &
     &rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
!GRDRHIC
!GRD-042008
+ca rhicelens
+ca bnlio
!GRDRHIC
!GRD-042008
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
+if debug
!-----------------------------------------------------------------------
!===================================================================
! Eric beginthck6dstart
!===================================================================
+ei
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
! Now the outer loop over turns
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 510 n=numlcr,nnuml
+ei
+if .not.cr
      do 510 n=1,numl
+ei
! To do a dump and abend
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

+if debug
! Now comes the loop over elements do 500/501
          do 501 i=1,iu
+ei
+if .not.debug
          do 500 i=1,iu
+ei
+if bnlelens
+ca bnltwiss
+ei
+if debug
!===================================================================
!===================================================================
! Eric endthck6dstart
! Nothing should be changed in the rest of this loop
!===================================================================
!===================================================================
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
         write (lout,*) 
     & "DUMP/FRONT not yet supported on thick elements "//
     & "due to lack of test cases. Please contact developers!"
      stop
!+ca dumplines
      endif

+if time
+ca timefct
+ei
            endif

+if debug
!     if (i.ge.673) then
!     call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
!     if (i.eq.676) stop
+ei
!----------count 44
!----------count 54! Eric
            goto( 20, 40,740,500,500,500,500,500,500,500,!1-10
     &            60, 80,100,120,140,160,180,200,220,240,!11-20
     &           290,310,330,350,370,390,410,430,450,470,!21-30
     &           490,260,520,540,560,580,600,620,640,660,!31-40
     &           680,700,720,730,748,500,500,500,500,500,!41-50
     &           745,746,751,752,753,754,500,500,500,500,!51-60
     &           500,500,761),ktrack(i)
            goto 500
   20       jmel=mel(ix)
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 20 j=1 991 before ',               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
            do 30 jb=1,jmel
              jx=mtyp(ix,jb)
              do 30 j=1,napx
+ca thcklin
   30       continue
            goto 500
   40       do 50 j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
              if(kz(ix).eq.12) then
+if crlibm
                ejv(j)=ejv(j)+ed(ix)*sin_rn(hsyc(ix)*sigmv(j)+
+ei
+if .not.crlibm
                ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+             &
+ei
     &phasc(ix))
              else
+if crlibm
                ejv(j)=ejv(j)+hsy(1)*sin_rn(hsy(3)*sigmv(j))
+ei
+if .not.crlibm
                ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j))
+ei
              endif
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
   50       yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 40 j=1 991 after  ',               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endif
+ei
+ei
+if cr
!       write(93,*) 'ERIC loop at 40 calling synuthck!!!'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
            call synuthck
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 40 j=1 991 after synuthck ',       &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
+ca kickv01h
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvxxh
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
+ca alignvb
+ca mul4v05
                do 270 k=3,nmz
+ca mul4v06
  270           continue
+ca mul4v07
  280       continue
          else
            do 275 j=1,napx
+ca mul4v08
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
+ca kickv01v
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvxxv
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 490
  720     continue
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 720 j=1 991 before ',              &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 720 j=1 991 after  ',              &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
          goto 490
  730     continue
+ca beam6d
          goto 490
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 490
  745     continue
          xory=1
+ca acdipkick
          goto 490
  746     continue
          xory=2
+ca acdipkick
          goto 490
  751     continue
          xory=1
+ca crabkick
          goto 490
  752     continue
          xory=2
+ca crabkick
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 490
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 490

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 490

!----------------------------

  490     continue

+ca lostpart

      if (.not. ldumpfront) then
+ca dumplines
      endif

+if debug
  500 continue
!     if (n.ge.990) then
!     write(99,*) 'after element i, ktrack ',i,ktrack(i),               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
  501     continue
+ei
+if .not.debug
  500     continue
+ei
+if debug
! End of loop over elements
!===================================================================
!===================================================================
! Eric beginthck6dend
!===================================================================
!===================================================================
+ei
          call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei
  510 continue
+if debug
! end loop over turns
!===================================================================
!===================================================================
! Eric endthck6dend
!===================================================================
!===================================================================
+ei
      return
      end
      subroutine thck6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS  6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,e0fo,e0o,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,  &
     &rb,rho2b,rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      double precision expt
+ei
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca dbdump
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca wireparam
+ca elenstracktmp
      save
!-----------------------------------------------------------------------
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK6DUA ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,nnuml)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 510 n=numlcr,nnuml
+ei
+if .not.cr
      do 510 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

          if(n.le.nde(1)) nwri=nwr(1)
          if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
          if(n.gt.nde(2)) nwri=nwr(3)
          if(nwri.eq.0) nwri=numl+numlr+1
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

          do 500 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
         write (lout,*) 
     & "DUMP/FRONT not yet supported on thick elements "//
     & "due to lack of test cases. Please contact developers!"
      stop
!+ca dumplines
      endif

+if time
+ca timefct
+ei
            endif

!----------count 56
            goto( 20, 40,740,500,500,500,500,500,500,500,!1-10
     &            60, 80,100,120,140,160,180,200,220,240,!11-20
     &           290,310,330,350,370,390,410,430,450,470,!21-30
     &           490,260,520,540,560,580,600,620,640,660,!31-40
     &           680,700,720,730,748,500,500,500,500,500,!41-50
     &           745,746,751,752,753,754,500,500,500,500,!51-60
     &           500,500,761),ktrack(i)
            goto 500
   20       jmel=mel(ix)
            do 30 jb=1,jmel
              jx=mtyp(ix,jb)
              do 30 j=1,napx
+ca thcklin
   30       continue
            goto 500
   40       e0o=e0
            e0fo=e0f
            call adia(n,e0f)
            do 50 j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01
              if(kz(ix).eq.12) then
+if crlibm
                ejv(j)=ejv(j)+ed(ix)*sin_rn((hsyc(ix)*sigmv(j)+phas)+   &!hr01
+ei
+if .not.crlibm
                ejv(j)=ejv(j)+ed(ix)*sin((hsyc(ix)*sigmv(j)+phas)+      &!hr01
+ei
     &phasc(ix))
              else
+if crlibm
                ejv(j)=ejv(j)+hsy(1)*sin_rn(hsy(3)*sigmv(j)+phas)
+ei
+if .not.crlibm
                ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j)+phas)
+ei
              endif
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
            if(sigmv(j).gt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
   50       yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
+if cr
+if debug
!       write(93,*) 'ERIC Thck6dua calling synuthck!!!'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
+ei
            call synuthck
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
+ca kickv01h
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvxxh
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
+ca alignvb
+ca mul4v05
                do 270 k=3,nmz
+ca mul4v06
  270           continue
+ca mul4v07
  280       continue
          else
            do 275 j=1,napx
+ca mul4v08
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
+ca kickv01v
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvxxv
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 490
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 490
  730     continue
+ca beam6d
          goto 490
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 490
  745     continue
          xory=1
+ca acdipkick
          goto 490
  746     continue
          xory=2
+ca acdipkick
          goto 490
  751     continue
          xory=1
+ca crabkick
          goto 490
  752     continue
          xory=2
+ca crabkick
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 490
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 490

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue                                                      `
          goto 490

!----------------------------

  490     continue

+ca lostpart

      if (.not. ldumpfront) then
+ca dumplines
      endif

  500     continue
          call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei
  510 continue
      return
      end
      subroutine synuthck
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ih1,ih2,j,kz1,l
      double precision fokm
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!---------------------------------------  SUBROUTINE 'ENVARS' IN-LINE
+if cr
+if debug
!       write(93,*) 'ERIC synuthck called!!!'
!       write(93,*) 'ERIC il= ',il
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
      sythckcr=.true.
+ei
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
+ca rvet1
   10 continue
      do 160 l=1,il
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
!       goto 160
!Eric
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
        if (kz1.eq.1) then
          goto 20
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
        elseif (kz1.eq.2.or.kz1.eq.5) then
   40     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.2) then
            ih1=1
            ih2=2
          else
!  RECTANGULAR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 50 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
+if crlibm
            fok1(j)=(tan_rn(fok(j)*half))/rho(j)
+ei
+if .not.crlibm
            fok1(j)=(tan(fok(j)*half))/rho(j)
+ei
+if crlibm
            si(j)=sin_rn(fok(j))
+ei
+if .not.crlibm
            si(j)=sin(fok(j))
+ei
+if crlibm
            co(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
            co(j)=cos(fok(j))
+ei
            al(2,ih1,j,l)=rho(j)*si(j)
      al(5,ih1,j,l)=((-1d0*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr01
+if crlibm
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan_rn(fok(j)*half))/dpsq(j)))&!hr01
     &*c1e3                                                              !hr01
+ei
+if .not.crlibm
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan(fok(j)*half))/dpsq(j)))   &!hr01
     &*c1e3                                                              !hr01
+ei
+if crlibm
            sm1(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
            sm1(j)=cos(fok(j))
+ei
+if crlibm
            sm2(j)=sin_rn(fok(j))*rho(j)
+ei
+if .not.crlibm
            sm2(j)=sin(fok(j))*rho(j)
+ei
+if crlibm
            sm3(j)=-sin_rn(fok(j))/rho(j)
+ei
+if .not.crlibm
            sm3(j)=-sin(fok(j))/rho(j)
+ei
            sm12(j)=el(l)-sm1(j)*sm2(j)
            sm23(j)=sm2(j)*sm3(j)
      as3(j)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-   &!hr01
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                    &!hr01
            as4(j)=((-1d0*rvv(j))*sm23(j))/c2e3                          !hr01
            as6(j)=((-1d0*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3            !hr01
+if rvet
            as(1,ih1,j,l)=el(l)*rvet(j)-(c1e3*rvv(j))*((dpsv(j)**2/     &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j)))                     !hr01
+ei
+if .not.rvet
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
+ei
         as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))* &!hr01
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr01
            as(3,ih1,j,l)=as3(j)
            as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                    !hr01
            as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/(c4e3*rho(j)**2)+     &!hr01
     &as6(j)*fok1(j)**2+fok1(j)*as4(j)                                   !hr01
            as(6,ih1,j,l)=as6(j)
!--VERTIKAL
+if crlibm
            g(j)=tan_rn(fok(j)*half)/rho(j)
+ei
+if .not.crlibm
            g(j)=tan(fok(j)*half)/rho(j)
+ei
            gl(j)=el(l)*g(j)
            al(1,ih2,j,l)=one-gl(j)
            al(3,ih2,j,l)=(-1d0*g(j))*(two-gl(j))                        !hr01
            al(4,ih2,j,l)=al(1,ih2,j,l)
            as6(j)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3                    !hr01
            as(4,ih2,j,l)=((-1d0*two)*as6(j))*fok1(j)                    !hr01
            as(5,ih2,j,l)=(as6(j)*fok1(j))*fok1(j)                       !hr01
            as(6,ih2,j,l)=as6(j)
   50     continue
          goto 160
        elseif (kz1.eq.4.or.kz1.eq.6) then
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.4) then
            ih1=1
            ih2=2
          else
!  SECTOR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 70 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
+if crlibm
            si(j)=sin_rn(fok(j))
+ei
+if .not.crlibm
            si(j)=sin(fok(j))
+ei
+if crlibm
            co(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
            co(j)=cos(fok(j))
+ei
            rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                         !hr01
            siq(j)=si(j)/dpsq(j)
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=rho(j)*si(j)
            al(3,ih1,j,l)=(-1d0*si(j))/rho(j)                            !hr01
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-1d0*dpsv(j))*rhoc(j))*c1e3                  !hr01
            al(6,ih1,j,l)=((-1d0*dpsv(j))*siq(j))*c1e3                   !hr01
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
            as(1,ih1,j,l)=el(l)*rvet(j)-(c1e3*rvv(j))*((dpsv(j)**2/     &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l)))              !hr01
+ei
+if .not.rvet
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
+ei
      as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/(two*rho(j)*dpsq(j)))*      &!hr01
     &sm12(j)-dpd(j)*siq(j))                                             !hr01
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*    &!hr01
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr01
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr01
            as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/((c4e3*rho(j))*rho(j)) !hr01
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr01
     &c4e3
!--VERTIKAL
            as(6,ih2,j,l)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3             !hr01
   70     continue
          goto 160
        elseif (kz1.eq.3) then
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
            fok(j)=ekv(j,l)*oidpsv(j)
            aek(j)=abs(fok(j))
            hi(j)=sqrt(aek(j))
            fi(j)=el(l)*hi(j)
            if(fok(j).le.zero) then
+if crlibm
              al(1,1,j,l)=cos_rn(fi(j))
+ei
+if .not.crlibm
              al(1,1,j,l)=cos(fi(j))
+ei
+if crlibm
              hi1(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
              hi1(j)=sin(fi(j))
+ei
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hi1(j)/hi(j)
              endif
              al(3,1,j,l)=-hi1(j)*hi(j)
              al(4,1,j,l)=al(1,1,j,l)
+if rvet
              as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
+ei
              as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
           as(5,1,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
       as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3  !hr01
!--DEFOCUSSING
+if crlibm
              hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
              hp(j)=exp(fi(j))
+ei
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,2,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hs(j)/hi(j)
              endif
              al(3,2,j,l)=hs(j)*hi(j)
              al(4,2,j,l)=hc(j)
              as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
              as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr01
            else
+if crlibm
              al(1,2,j,l)=cos_rn(fi(j))
+ei
+if .not.crlibm
              al(1,2,j,l)=cos(fi(j))
+ei
+if crlibm
              hi1(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
              hi1(j)=sin(fi(j))
+ei
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hi1(j)/hi(j)
              endif
              al(3,2,j,l)=(-1d0*hi1(j))*hi(j)                            !hr01
              al(4,2,j,l)=al(1,2,j,l)
+if rvet
              as(1,2,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
+ei
              as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
           as(5,2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3 !hr01
!--DEFOCUSSING
+if crlibm
              hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
              hp(j)=exp(fi(j))
+ei
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,1,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hs(j)/hi(j)
              endif
              al(3,1,j,l)=hs(j)*hi(j)
              al(4,1,j,l)=hc(j)
              as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
              as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3 !hr01
            endif
   90     continue
          goto 160
        elseif (kz1.eq.7.or.kz1.eq.8) then
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100     if(kz1.eq.7) then
            do 110 j=1,napx
              fokqv(j)=ekv(j,l)
  110       continue
            ih1=1
            ih2=2
          else
!  COMBINED FUNCTION MAGNET VERTICAL
            do 120 j=1,napx
              fokqv(j)=-ekv(j,l)
  120       continue
            ih1=2
            ih2=1
          endif
          do 130 j=1,napx
            wf(j)=ed(l)/dpsq(j)
            fok(j)=fokqv(j)/dpd(j)-wf(j)**2                              !hr01
            afok(j)=abs(fok(j))
            hi(j)=sqrt(afok(j))
            fi(j)=hi(j)*el(l)
            if(afok(j).le.pieni) then
              as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                     !hr01
              as(6,2,j,l)=as(6,1,j,l)
+if rvet
              as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
+ei
            endif
            if(fok(j).lt.(-1d0*pieni)) then                              !hr06
+if crlibm
              si(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
              si(j)=sin(fi(j))
+ei
+if crlibm
              co(j)=cos_rn(fi(j))
+ei
+if .not.crlibm
              co(j)=cos(fi(j))
+ei
              wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                      !hr01
              al(1,ih1,j,l)=co(j)
              al(2,ih1,j,l)=si(j)/hi(j)
              al(3,ih1,j,l)=(-1d0*si(j))*hi(j)                           !hr01
              al(4,ih1,j,l)=co(j)
              al(5,ih1,j,l)=((-1d0*wfa(j))*dpsv(j))*c1e3                 !hr01
              al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
              as(1,ih1,j,l)=el(l)*rvet(j)-(((c1e3*rvv(j))*((dpsv(j)**2/ &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/           &!hr01
     &afok(j))*wf(j)**2                                                  !hr01
+ei
+if .not.rvet
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                                &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3    !hr06
+ei
           as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr01
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr01
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr01
              as(5,ih1,j,l)=(((-1d0*rvv(j))*sm12(j))*afok(j))/c4e3       !hr01
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
+if crlibm
              hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
              hp(j)=exp(fi(j))
+ei
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih2,j,l)=hc(j)
              if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
              al(3,ih2,j,l)=hs(j)*hi(j)
              al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr01
            as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
!--DEFOCUSSING
            if(fok(j).gt.pieni) then
+if crlibm
              hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
              hp(j)=exp(fi(j))
+ei
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih1,j,l)=hc(j)
              al(2,ih1,j,l)=hs(j)/hi(j)
              al(3,ih1,j,l)=hs(j)*hi(j)
              al(4,ih1,j,l)=hc(j)
              wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                      !hr01
              al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                       !hr01
              al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
              as(1,ih1,j,l)=el(l)*rvet(j)+(((c1e3*rvv(j))*((dpsv(j)**2/ &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/           &!hr06
     &afok(j))*wf(j)**2                                                  !hr06
+ei
+if .not.rvet
              as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*      &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*  &!hr06
     &(one-rvv(j)))*c1e3                                                 !hr06
+ei
           as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))* ed(l))  &!hr01
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr01
              as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                 !hr01
              as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3              !hr01
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
+if crlibm
              si(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
              si(j)=sin(fi(j))
+ei
+if crlibm
              co(j)=cos_rn(fi(j))
+ei
+if .not.crlibm
              co(j)=cos(fi(j))
+ei
              al(1,ih2,j,l)=co(j)
              al(2,ih2,j,l)=si(j)/hi(j)
              al(3,ih2,j,l)=(-1d0*si(j))*hi(j)                           !hr01
              al(4,ih2,j,l)=co(j)
        as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3 !hr01
      as(5,ih2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr01
     &*aek(j))/c4e3                                                      !hr01
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
  130     continue
          goto 160
        elseif (kz1.eq.9) then
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140     do 150 j=1,napx
            rhoi(j)=ed(l)/dpsq(j)
+if crlibm
            fok(j)=rhoi(j)*tan_rn((el(l)*rhoi(j))*half)                  !hr01
+ei
+if .not.crlibm
            fok(j)=rhoi(j)*tan((el(l)*rhoi(j))*half)                     !hr01
+ei
            al(3,1,j,l)=fok(j)
            al(3,2,j,l)=-fok(j)
  150     continue
          goto 160
        else
!Eric
! Is really an error but old code went to 160
          goto 160
        endif
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                         !hr01
          as(6,2,j,l)=as(6,1,j,l)
+if rvet
          as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr01
+ei
   30   continue
  160 continue
!---------------------------------------  END OF 'ENVARS' (2)
      return
      end
+dk envarsv
      subroutine envarsv(dpsv,oidpsv,rvv,ekv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!  CAUTION:
!          A SPECIAL VERSION FOR VECTORIZATION - AUGUST   1994
!-----------------------------------------------------------------------
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei

      implicit none
+if crlibm
+ca crlibco
+ei
      integer ih1,ih2,j,kz1,l,l1,l2
      double precision aek,afok,as3,as4,as6,co,dpd,dpsq,dpsv,ekv,fi,    &
     &fok,fok1,fokm,fokqv,g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,rho,rhoc,rhoi, &
     &rvv,si,siq,sm1,sm12,sm2,sm23,sm3,wf,wfa,wfhi
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+if bnlelens
+ca rhicelens
+ei
!-----------------------------------------------------------------------
      save
!-----------------------------------------------------------------------
      dimension ekv(npart,nele),fokqv(npart),dpsv(npart)
      dimension rvv(npart),oidpsv(npart)
      dimension dpd(npart),dpsq(npart),fok(npart),rho(npart)
      dimension fok1(npart),si(npart),co(npart),g(npart),gl(npart)
      dimension sm1(npart),sm2(npart),sm3(npart),sm12(npart)
      dimension as3(npart),as4(npart),as6(npart),sm23(npart)
      dimension rhoc(npart),siq(npart),aek(npart),afok(npart)
      dimension hp(npart),hm(npart),hc(npart),hs(npart),wf(npart)
      dimension wfa(npart),wfhi(npart),rhoi(npart)
      dimension hi(npart),fi(npart),hi1(npart)
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
   10 continue
      do 160 l=1,il
        do l1=1,6
          do j=1,napx
            do l2=1,2
              al(l1,l2,j,l)=zero
              as(l1,l2,j,l)=zero
            enddo
          enddo
        enddo
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 80
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 40
        if (kz1.eq.6) goto 60
        if (kz1.eq.7) goto 100
        if (kz1.eq.8) goto 100
        if (kz1.eq.9) goto 140
        goto 160
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          al(1,1,j,l)=one
          al(1,2,j,l)=one
          al(2,1,j,l)=el(l)
          al(2,2,j,l)=el(l)
          al(3,1,j,l)=zero
          al(3,2,j,l)=zero
          al(4,1,j,l)=one
          al(4,2,j,l)=one
          as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                         !hr06
          as(6,2,j,l)=as(6,1,j,l)
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr06
   30   continue
        goto 160
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.2) then
          ih1=1
          ih2=2
        else
!  RECTANGULAR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 50 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
+if crlibm
          fok1(j)=(tan_rn(fok(j)*half))/rho(j)
+ei
+if .not.crlibm
          fok1(j)=(tan(fok(j)*half))/rho(j)
+ei
+if crlibm
          si(j)=sin_rn(fok(j))
+ei
+if .not.crlibm
          si(j)=sin(fok(j))
+ei
+if crlibm
          co(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
          co(j)=cos(fok(j))
+ei
          al(1,ih1,j,l)=one
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=zero
          al(4,ih1,j,l)=one
      al(5,ih1,j,l)=((-1d0*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr06
+if crlibm
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan_rn(fok(j)*half))/dpsq(j)))&!hr06
     &*c1e3                                                              !hr06
+ei
+if .not.crlibm
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan(fok(j)*half))/dpsq(j)))   &!hr06
     &*c1e3                                                              !hr06
+ei
+if crlibm
          sm1(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
          sm1(j)=cos(fok(j))
+ei
+if crlibm
          sm2(j)=sin_rn(fok(j))*rho(j)
+ei
+if .not.crlibm
          sm2(j)=sin(fok(j))*rho(j)
+ei
+if crlibm
          sm3(j)=(-1d0*sin_rn(fok(j)))/rho(j)                            !hr06
+ei
+if .not.crlibm
          sm3(j)=(-1d0*sin(fok(j)))/rho(j)                               !hr06
+ei
          sm12(j)=el(l)-sm1(j)*sm2(j)
          sm23(j)=sm2(j)*sm3(j)
         as3(j)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr06
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr06
          as4(j)=((-1d0*rvv(j))*sm23(j))/c2e3                            !hr06
          as6(j)=((-1d0*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3              !hr06
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/            &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
      as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*    &!hr06
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr06
          as(3,ih1,j,l)=as3(j)
          as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                      !hr06
          as(5,ih1,j,l)=(as6(j)*fok1(j)**2                              &!hr06
     &-(rvv(j)*sm12(j))/(c4e3*rho(j)**2))+fok1(j)*as4(j)                 !hr06
          as(6,ih1,j,l)=as6(j)
!--VERTIKAL
+if crlibm
          g(j)=tan_rn(fok(j)*half)/rho(j)
+ei
+if .not.crlibm
          g(j)=tan(fok(j)*half)/rho(j)
+ei
          gl(j)=el(l)*g(j)
          al(1,ih2,j,l)=one-gl(j)
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=(-1d0*g(j))*(two-gl(j))                          !hr06
          al(4,ih2,j,l)=al(1,ih2,j,l)
          as6(j)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3                      !hr06
          as(4,ih2,j,l)=((-1d0*two)*as6(j))*fok1(j)                      !hr06
          as(5,ih2,j,l)=as6(j)*fok1(j)**2                                !hr06
          as(6,ih2,j,l)=as6(j)
   50   continue
        goto 160
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.4) then
          ih1=1
          ih2=2
        else
!  SECTOR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 70 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
+if crlibm
          si(j)=sin_rn(fok(j))
+ei
+if .not.crlibm
          si(j)=sin(fok(j))
+ei
+if crlibm
          co(j)=cos_rn(fok(j))
+ei
+if .not.crlibm
          co(j)=cos(fok(j))
+ei
          rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                           !hr06
          siq(j)=si(j)/dpsq(j)
          al(1,ih1,j,l)=co(j)
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=(-1d0*si(j))/rho(j)                              !hr06
          al(4,ih1,j,l)=co(j)
          al(5,ih1,j,l)=((-1d0*dpsv(j))*rhoc(j))*c1e3                    !hr06
          al(6,ih1,j,l)=((-1d0*dpsv(j))*siq(j))*c1e3                     !hr06
          sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
          sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
       as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/           &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
       as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*   &!hr06
     &sm12(j)-dpd(j)*siq(j))                                             !hr06
         as(3,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))* &!hr06
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr06
          as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                     !hr06
          as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/(c4e3*rho(j)**2)         !hr06
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr06
     &c4e3                                                               !hr06
!--VERTIKAL
          al(1,ih2,j,l)=one
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=zero
          al(4,ih2,j,l)=one
          as(6,ih2,j,l)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3               !hr06
   70   continue
        goto 160
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
          fok(j)=ekv(j,l)*oidpsv(j)
          aek(j)=abs(fok(j))
          hi(j)=sqrt(aek(j))
          fi(j)=el(l)*hi(j)
          if(fok(j).le.zero) then
+if crlibm
            al(1,1,j,l)=cos_rn(fi(j))
+ei
+if .not.crlibm
            al(1,1,j,l)=cos(fi(j))
+ei
+if crlibm
            hi1(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
            hi1(j)=sin(fi(j))
+ei
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hi1(j)/hi(j)
            endif
            al(3,1,j,l)=(-1d0*hi1(j))*hi(j)                              !hr06
            al(4,1,j,l)=al(1,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
!--DEFOCUSSING
+if crlibm
            hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
            hp(j)=exp(fi(j))
+ei
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,2,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hs(j)/hi(j)
            endif
            al(3,2,j,l)=hs(j)*hi(j)
            al(4,2,j,l)=hc(j)
            as(4,2,j,l)=((-1d0*rvv(j))*al(2,2,j,l)*al(3,2,j,l))/c2e3     !hr06
          as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
          else
+if crlibm
            al(1,2,j,l)=cos_rn(fi(j))
+ei
+if .not.crlibm
            al(1,2,j,l)=cos(fi(j))
+ei
+if crlibm
            hi1(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
            hi1(j)=sin(fi(j))
+ei
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hi1(j)/hi(j)
            endif
            al(3,2,j,l)=(-1d0*hi1(j))*hi(j)                              !hr06
            al(4,2,j,l)=al(1,2,j,l)
            as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3   !hr06
          as(5,2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
!--DEFOCUSSING
+if crlibm
            hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
            hp(j)=exp(fi(j))
+ei
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,1,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hs(j)/hi(j)
            endif
            al(3,1,j,l)=hs(j)*hi(j)
            al(4,1,j,l)=hc(j)
            as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
          endif
   90   continue
        goto 160
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100   if(kz1.eq.7) then
          do 110 j=1,napx
            fokqv(j)=ekv(j,l)
  110     continue
          ih1=1
          ih2=2
        else
!  COMBINED FUNCTION MAGNET VERTICAL
          do 120 j=1,napx
            fokqv(j)=-1d0*ekv(j,l)                                       !hr06
  120     continue
          ih1=2
          ih2=1
        endif
        do 130 j=1,napx
          wf(j)=ed(l)/dpsq(j)
          fok(j)=fokqv(j)/dpd(j)-wf(j)**2                                !hr06
          afok(j)=abs(fok(j))
          hi(j)=sqrt(afok(j))
          fi(j)=hi(j)*el(l)
          if(afok(j).le.pieni) then
            al(1,1,j,l)=one
            al(1,2,j,l)=one
            al(2,1,j,l)=el(l)
            al(2,2,j,l)=el(l)
            al(3,1,j,l)=zero
            al(3,2,j,l)=zero
            al(4,1,j,l)=one
            al(4,2,j,l)=one
            as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                       !hr06
            as(6,2,j,l)=as(6,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
          endif
          if(fok(j).lt.(-1d0*pieni)) then                                !hr06
+if crlibm
            si(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
            si(j)=sin(fi(j))
+ei
+if crlibm
            co(j)=cos_rn(fi(j))
+ei
+if .not.crlibm
            co(j)=cos(fi(j))
+ei
            wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                        !hr06
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=si(j)/hi(j)
            al(3,ih1,j,l)=(-1d0*si(j))*hi(j)                             !hr06
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-1d0*wfa(j))*dpsv(j))*c1e3                   !hr06
            al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                          &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3   !hr06
      as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*     &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr06
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr06
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=(((-1d0*rvv(j))*sm12(j))*afok(j))/c4e3         !hr06
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
+if crlibm
            hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
            hp(j)=exp(fi(j))
+ei
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih2,j,l)=hc(j)
            al(2,ih2,j,l)=el(l)
            if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
            al(3,ih2,j,l)=hs(j)*hi(j)
            al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
          as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*  &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
!--DEFOCUSSING
          if(fok(j).gt.pieni) then
+if crlibm
            hp(j)=exp_rn(fi(j))
+ei
+if .not.crlibm
            hp(j)=exp(fi(j))
+ei
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih1,j,l)=hc(j)
            al(2,ih1,j,l)=hs(j)/hi(j)
            al(3,ih1,j,l)=hs(j)*hi(j)
            al(4,ih1,j,l)=hc(j)
            wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                        !hr06
            al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                         !hr06
            al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*sm12(j) &
     &+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*         &
     &(one-rvv(j)))*c1e3
          as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))* &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
        as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))*ed(l)) &!hr06
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr06
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3                !hr06
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
+if crlibm
            si(j)=sin_rn(fi(j))
+ei
+if .not.crlibm
            si(j)=sin(fi(j))
+ei
+if crlibm
            co(j)=cos_rn(fi(j))
+ei
+if .not.crlibm
            co(j)=cos(fi(j))
+ei
            al(1,ih2,j,l)=co(j)
            al(2,ih2,j,l)=si(j)/hi(j)
            al(3,ih2,j,l)=(-1d0*si(j))*hi(j)                             !hr06
            al(4,ih2,j,l)=co(j)
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
      as(5,ih2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr06
     &*aek(j))/c4e3                                                      !hr06
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
  130   continue
        goto 160
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140   do 150 j=1,napx
          rhoi(j)=ed(l)/dpsq(j)
+if crlibm
          fok(j)=rhoi(j)*tan_rn((el(l)*rhoi(j))*half)                    !hr06
+ei
+if .not.crlibm
          fok(j)=rhoi(j)*tan((el(l)*rhoi(j))*half)                       !hr06
+ei
          al(1,1,j,l)=one
          al(2,1,j,l)=zero
          al(3,1,j,l)=fok(j)
          al(4,1,j,l)=one
          al(1,2,j,l)=one
          al(2,2,j,l)=zero
          al(3,2,j,l)=-fok(j)
          al(4,2,j,l)=one
  150   continue
  160 continue
      return
      end
+dk mainda
      program mainda
      use, intrinsic :: iso_fortran_env, only : output_unit
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,iation,itiono,idate,im,imonth,itime,ix,izu,j,jj,k,kpz,  &
     &kzz,l,ll,ncorruo,ndim,nlino,nlinoo,nmz
      double precision alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
     &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,clo0,clop0,&
     &dp0,dp10,e0f,eps,epsa,gam0s1,gam0s2,gam0s3,gam0x1,gam0x2,gam0x3,  &
     &gam0z1,gam0z2,gam0z3,phag,qw,qwc,r0,r0a,rv,                       &
+if rvet
     &rvet,                                                             &
+ei
     &tas,tas16,tas26,                                                  &
     &tas36,tas46,tas56,tas61,tas62,tas63,tas64,tas65
!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  DIFFERENTIAL ALGEBRA INCLUDED
!
!  ONE TURN MAP
!
!  NO POSTPROCESSING FORSEEN
!
!
!  DEVELOPPED FROM <RACETRACK> A. WRULICH (DESY 84-026)
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!-----------------------------------------------------------------------
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonc
!-----------------------------------------------------------------------
      character*10 cmonth
      character*80 day,runtim
      character*8 cdate,ctime
      dimension qw(2),qwc(3),clo0(2),clop0(2)
      dimension eps(2),epsa(2)
      dimension cmonth(12)
      dimension tas(6,6)
!-----------------------------------------------------------------------
      data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
     &'  April   ','   May    ','   June   ','   July   ',' August  ',  &
     &' September',' October  ',' November ',' December '/
!-----------------------------------------------------------------------
+if crlibm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
+ei
+ca version

+if .not.cr
      lout=output_unit
+ei

+ca open
      write(lout,10000) version,moddate
      tlim=1e7
      call timest(tlim)
      time0=0.
      call timex(time0)
      idate=0
      itime=0
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)// &
     &'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(lout,'(a80)') runtim
      do 10 i=1,2
        eps(i)=zero
        epsa(i)=zero
        qw(i)=zero
        qwc(i)=zero
   10 continue
      qwc(3)=zero
      call comnul
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      pi2=pi*half
      pisqrt=sqrt(pi)
      rad=pi/180d0                                                       !hr08
      call daten
      if(nord.le.0.or.nvar.le.0) call prror(91)
      if(ithick.eq.1) write(lout,10020)
      if(ithick.eq.0) write(lout,10030)
      if(ibidu.eq.2) then
        write(lout,10025)
        goto 550
      endif
      call ord
      call clorb(ded)
      do 20 l=1,2
        clo0(l)=clo(l)
   20 clop0(l)=clop(l)
      call clorb(zero)
      do 30 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
   30 dip0(l)=(clop0(l)-clop(l))/ded
      amp00=amp(1)
      iation=abs(ition)
      call corrorb
      if(irmod2.eq.1) call rmod(dp1)
      if(iqmod.ne.0) call qmod0
      if(ichrom.eq.1.or.ichrom.eq.3) call chroma
      if(iskew.ne.0) call decoup
      dp0=dp1
!--FOR THE MOMENTUM-SCAN THE MOMENTUM IS THE SAME FOR BOTH PARTICLES
      exz(1,6)=dp1
      exz(2,6)=dp1
      if(ilin.eq.1.or.ilin.eq.3) then
        call linopt(dp1)
      endif
      if(isub.eq.1) call subre(dp1)
      if(ise.eq.1) call search(dp1)
      if(napx.eq.0) goto 160
!-----------------------------------------------------------------------
!--beam-beam element
      nlino=nlin
      nlin=0
      if(nbeam.ge.1) then
        do 135 i=1,nele
          if((kz(i).eq.20).or.(kz(i).eq.15)) then
            nlin=nlin+1
            if(nlin.gt.nele) call prror(81)
            bezl(nlin)=bez(i)
          endif
  135   continue
      endif
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
      izu=0
      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(kzz.eq.15) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        smizf(i)=zfz(izu)*ek(ix)
        smi(i)=sm(ix)+smizf(i)
        izu=izu+1
        xsi(i)=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zsi(i)=zpl(ix)+zfz(izu)*zrms(ix)
        if(mout2.eq.1) then
          if(kzz.eq.11) zfz(izu-2)=zero
          if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
          if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
          if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
          write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),             &
     &zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
        endif
        if(kzz.eq.11) then
          !Very similar to block "multini"
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one
          do 50 k=1,nmz
            izu=izu+1
            aai(i,k)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a         !hr08
            izu=izu+1
            bbi(i,k)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a         !hr08
   50     r0a=r0a*r0
          izu=izu+2*mmul-2*nmz
        endif
   60 continue
      dp10=dp1
      dp1=zero
      if(ichrom.gt.1) then
        itiono=ition
        ition=0
        call chromda
        ition=itiono
      endif
      dp1=dp10
      if(idp.ne.1.or.iation.ne.1) iclo6=0
      if(iclo6.eq.1.or.iclo6.eq.2) then
+ca clor6
        do 70 i=1,6
          do 70 j=1,6
            tas(i,j)=tasm(i,j)
   70   continue
      else
        ncorruo=ncorru
        ncorru=1
        call clorb(zero)
        call betalf(zero,qw)
        call phasad(zero,qwc)
        call clorb(dp1)
        call betalf(dp1,qw)
        call phasad(dp1,qwc)
        ncorru=ncorruo
        dps(1)=dp1
        if(nvar2.le.5) then
          itiono=ition
          ition=0
        endif
+if debug
!       write(*,*) '3rd call qmodda multipole???'
+ei
        call qmodda(2,qwc)
+if debug 
!     call dumpbin('aqmodda',2,3)
!     call abend('after  qmodda 2 3                                 ')
+ei
        if(nvar2.le.5) ition=itiono
        if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)
        if(ilin.ge.2) then
          nlinoo=nlin
          nlin=nlino
          iqmodc=2
          call mydaini(1,2,5,2,5,1)
          ilinc=1
          call mydaini(2,2,5,2,5,1)
          nlin=nlinoo
        endif
        do 80 i=1,4
          do 80 j=1,4
   80   tas(i,j)=tasm(i,j)
      endif
  550 continue
      tas16=tas(1,6)*c1m3
      tas26=tas(2,6)*c1m3
      tas36=tas(3,6)*c1m3
      tas46=tas(4,6)*c1m3
      tas56=tas(5,6)*c1m3
      tas61=tas(6,1)*c1e3
      tas62=tas(6,2)*c1e3
      tas63=tas(6,3)*c1e3
      tas64=tas(6,4)*c1e3
      tas65=tas(6,5)*c1e3
      bet0(1)=tas(1,1)**2+tas(1,2)**2                                    !hr08
      bet0x2 =tas(1,3)**2+tas(1,4)**2                                    !hr08
      bet0x3 =tas(1,5)**2+tas16**2                                       !hr08
      gam0x1 =tas(2,1)**2+tas(2,2)**2                                    !hr08
      gam0x2 =tas(2,3)**2+tas(2,4)**2                                    !hr08
      gam0x3 =tas(2,5)**2+tas26**2                                       !hr08
      alf0(1)=-1d0*(tas(1,1)*tas(2,1)+tas(1,2)*tas(2,2))                 !hr08
      alf0x2 =-1d0*(tas(1,3)*tas(2,3)+tas(1,4)*tas(2,4))                 !hr08
      alf0x3 =-1d0*(tas(1,5)*tas(2,5)+tas16*tas26)                       !hr08
      bet0(2)=tas(3,3)**2+tas(3,4)**2                                    !hr08
      bet0z2 =tas(3,1)**2+tas(3,2)**2                                    !hr08
      bet0z3 =tas(3,5)**2+tas36**2                                       !hr08
      gam0z1 =tas(4,3)**2+tas(4,4)**2                                    !hr08
      gam0z2 =tas(4,1)**2+tas(4,2)**2                                    !hr08
      gam0z3 =tas(4,5)**2+tas46**2                                       !hr08
      alf0(2)=-1d0*(tas(3,3)*tas(4,3)+tas(3,4)*tas(4,4))                 !hr08
      alf0z2 =-1d0*(tas(3,1)*tas(4,1)+tas(3,2)*tas(4,2))                 !hr08
      alf0z3 =-1d0*(tas(3,5)*tas(4,5)+tas36*tas46)                       !hr08
      bet0s1 =tas(5,5)**2+tas56**2                                       !hr08
      bet0s2 =tas(5,1)**2+tas(5,2)**2                                    !hr08
      bet0s3 =tas(5,3)**2+tas(5,4)**2                                    !hr08
      gam0s1 =tas65**2+tas(6,6)**2                                       !hr08
      gam0s2 =tas61**2+tas62**2                                          !hr08
      gam0s3 =tas63**2+tas64**2                                          !hr08
      alf0s1 =-1d0*(tas(5,5)*tas65+tas56*tas(6,6))                       !hr08
      alf0s2 =-1d0*(tas(5,1)*tas61+tas(5,2)*tas62)                       !hr08
      alf0s3 =-1d0*(tas(5,3)*tas63+tas(5,4)*tas64)                       !hr08
      if(ierro.eq.0) goto 90
      write(lout,10200) dp1
      goto 160
   90 write(lout,10040)
      phag=(phas*180d0)/pi                                               !hr08
      if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))             &
     &write(lout,10140)                                                 &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
      if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
        if(iclo6.eq.0) then
          write(lout,10120) phag,
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
        else
          write(lout,10130) phag,
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
        endif
      endif
      if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)                &
     &write(lout,10160) phag,                                           &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
      if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
        if(iclo6.eq.0) then
          write(lout,10180)
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
        else
          write(lout,10190)
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
        endif
      endif
      write(lout,10050) dp1
      call anfb(tas)
      if(iclo6.eq.2) then
        x(1,1) = x(1,1) + clo6(1)
        x(1,2) = x(1,2) + clo6(2)
        y(1,1) = y(1,1) + clop6(1)
        y(1,2) = y(1,2) + clop6(2)
        sigm(1) = sigm(1) + clo6(3)
        dps(1) = dps(1) + clop6(3)
        x(2,1) = x(2,1) + clo6(1)
        x(2,2) = x(2,2) + clo6(2)
        y(2,1) = y(2,1) + clop6(1)
        y(2,2) = y(2,2) + clop6(2)
        sigm(2) = sigm(2) + clo6(3)
        dps(2) = dps(2) + clop6(3)
      endif
      do 100 l=1,2
        epsa(l)=amp(l)**2/bet0(l)                                        !hr08
        eps(l)=epsa(l)*1d6
        x(1,l)=x(1,l)+(clo(l)*dble(idz(l)))*dble(1-idfor)                !hr08
        y(1,l)=y(1,l)+(clop(l)*dble(idz(l)))*dble(1-idfor)               !hr08
  100 continue
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      if(iclo6.eq.0) then
        write(lout,10080) clo(1),clop(1),clo(2),clop(2),idz(1),idz(2),
     &iver, idfor,iclo6,ition
      else
        write(lout,10090) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),
     &clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
      endif
      if(idfor.eq.1.and.iclo6.ne.2) goto 110
      ejf(1)=e0f*(one+dps(1))
      ejf(2)=e0f*(one+dps(2))
      ej(1)=sqrt(ejf(1)**2+pma**2)                                       !hr08
      ej(2)=sqrt(ejf(2)**2+pma**2)                                       !hr08
      goto 120
  110 ejf(1)=sqrt(ej(1)**2-pma**2)                                       !hr08
      ejf(2)=sqrt(ej(2)**2-pma**2)                                       !hr08
  120 write(lout,10060) x(1,1),y(1,1),x(1,2),y(1,2),sigm(1),dps(1), x
     &(2,1),y(2,1),x(2,2),y(2,2),sigm(2),dps(2),e0,ej(1),ej(2)
      write(lout,10010) amp,epsa
      write(lout,10170)
      if(e0.gt.pieni) then
+ca rvet2
+if rvet
        if(ithick.eq.1) call envars(1,dps(1),rv,rvet)
+ei
+if .not.rvet
        if(ithick.eq.1) call envars(1,dps(1),rv)
+ei
      else
        call prror(79)
      endif
      if(numl.eq.0.or.numlr.ne.0) then
        write(lout,10070)
        goto 160
      endif
      if(nsix.eq.1.and.nvar2.eq.6) then
        nsix=2
        nvar=nvar-1
        nvar2=5
      endif
      ndim=nvar2/2
      call mydaini(3,nord,nvar,ndim,nvar2,nord1)
      if(inorm.eq.1) call daliesix
      if(icorr.eq.1) then
        if(nctype.eq.0) call coruord
        if(nctype.eq.1) call coruglo
      endif
      if(nsix.eq.2) then
        call umschr(19,18)
        nvar2=6
        nvar=nvar+1
        call mydaini(3,nord,nvar,ndim,nvar2,nord1)
      endif
  160 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
+if .not.tilt
10000 format(/t10,'SIXTRACK DA VERSION ',A8,                            &
     &'  --  (last change: ',A10,')'//)
+ei
+if tilt
10000 format(/t10,'SIXTRACK DA VERSION ',A8,' (with tilt)',             &
     &'  --  (last change: ',A10,')'//)
+ei
10010 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y =  ',f15.3, '  PI*MRAD*MM'&
     &)
10020 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10030 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10040 format(/131('-'))
10050 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t10,               &
     &'================================')
10060 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10070 format(/5x,'NON SENSICAL INPUT: NUML = 0 OR NUMLR NOT 0')
10080 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10090 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10120 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9,f15.9/)
10025 format(/t10,'Run started from binary dump file # 32')
10130 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10140 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10150 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10160 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10170 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10180 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10190 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  Y  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/              &
     &t10,'  S  ',f14.10,2(1x,g14.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/t60,f15.9,1x,f15.10,f15.9/)
10200 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,                &
     &'RELATIVE MOMENTUM DEVIATION')
      end
+dk comnul
      subroutine comnul
!-----------------------------------------------------------------------
!  SUBROUTINE TO SET THE ALL COMMON VARIABLES TO ZERO
!-----------------------------------------------------------------------
+if datamods
      use bigmats
+ei
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,i1,i2,i3,i4,j
+ca parpro
+ca parnum
+ca commonex
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commd1da
+ca commonc
+ca commonxz
+ca commonmn

+if bnlelens
+ca rhicelens
+ei

+ca dbdcum

+ca comgetfields !Contains parameters used in comdump and fma

+ca fma

+ca dbdump
+if cr
+ca dbdumpcr
+ei

+ca stringzerotrim
+ca comdynk

+if cr
+ca comdynkcr
+ei

+ca elensparam
+ca wireparam

+ca zipf

+if collimat
+ca collpara
+ca database
+ca dbcommon
+ei
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
!
+if bnlelens
!GRDRHIC
!GRD-042008
! Set all new variables to 0 or ZERO
! Note we do not initialise the checkpoint cr* variables
! nor the my* variables as they should all be read in!
! double precision
      do i=1,nblz
        tbetax(i)=zero
        tbetay(i)=zero
        talphax(i)=zero
        talphay(i)=zero
        torbx(i)=zero
        torbxp(i)=zero
        torby(i)=zero
        torbyp(i)=zero
        tdispx(i)=zero
        tdispy(i)=zero
        sampl(i)=zero
      enddo
! double precision
      totals=zero
      limit_twojx=zero
      limit_twojy=zero
      limit_twojr=zero
      twojx=zero
      twojy=zero
      twojr=zero
      sumtwojx=zero
      sumtwojy=zero
      sumsquarex=zero
      sumsquarey=zero
! integers
      n_cut=0
      n_nocut=0
      samplenumber=0
      mynp=0
      do j=1,npart
        namepart(j)=0
      enddo
!GRDRHIC
!GRD-042008
+ei
      ncorru=0
      ncorrep=0
      iexact=0
      ithick=0
      ierro=0
      il=0
      iclo6=0
      iclo6r=0
      mper=0
      mblo=0
      mbloz=0
      kanf=0
      iu=0
      itra=0
      napx=0
      numl=0
      numlr=0
      ird=0
      imc=0
      niu(1)=0
      niu(2)=0
      idp=0
      irew=0
      iorg=0
      itco=0
      itcro=0
      itqv=0
      ichrom=0
      iqmod=0
      iqmod6=0
      ilin=0
      iqmodc=0
      ichromc=0
      ilinc=0
      ntco=0
      nt=0
      iprint=0
      iclo=0
      icoe=0
      ise=0
      mesa=0
      mp=0
      m21=0
      m22=0
      m23=0
      ise1=0
      ise2=0
      ise3=0
      isub=0
      nta=0
      nte=0
      ipt=0
      irmod2=0
      nre=0
      nur=0
      nch=0
      nqc=0
      npp=0
      ipos=0
      iconv=0
      imad=0
      nstart=0
      nstop=0
      iskip=1
      iav=0
      iwg=0
      ivox=0
      ivoz=0
      ires=0
      ifh=0
      idis=0
      icow=0
      istw=0
      iffw=0
      idial=0
      nord=0
      nvar=0
      nvar2=0
      ndimf=0
      nordf=0
      nvarf=0
      nord1=1
      nsix=0
      nvar2=0
      ncor=0
      idptr=0
      nbeam=0
      ibb6d=0
      ibeco=1
      ibtyp=0
      lhc=1
      ibbc=0
      iver=0
      ibidu=0
!-----------------------------------------------------------------------
      inorm=0
      imod1=0
      imod2=0
!-----------------------------------------------------------------------
      icorr=0
      nctype=0
      namp=0
      nmom=0
      nmom1=0
      nmom2=0
      weig1=zero
      weig2=zero
      dpmax=zero
!--DA-------------------------------------------------------------------
      dpda_da=0
      dpda1_da=0
      sigmda_da=0
      ej1_da=0
      ejf1_da=0
      rv_da=0
!-----------------------------------------------------------------------
      pi=zero
      pi2=zero
      pisqrt=zero
      rad=zero
      chi0=zero
      chid=zero
      dp1=zero
      idfor=0
      rat=zero
      qs=zero
      e0=zero
      crad=zero
      dppoff=zero
      tlen=zero
      pma=zero
      phas0=zero
      phas=zero
      ition=0
      dpscor=one
      sigcor=one
      benki=zero
      dma=zero
      dmap=zero
      dkq=zero
      dqq=zero
      de0=zero
      ded=zero
      dsi=zero
      dech=zero
      dsm0=zero
      amp0=zero
      qxt=zero
      qzt=zero
      eui=zero
      euii=zero
      tam1=zero
      tam2=zero
      totl=zero
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      dres=zero
      dfft=zero
      preda=zero
      partnum=zero
      emitx=zero
      emity=zero
      emitz=zero
      gammar=one
      sigz=zero
      sige=zero
      damp=zero
      ampt=zero
!-----------------------------------------------------------------------
      tlim=0.
      time0=0.
      time1=0.
!-----------------------------------------------------------------------
      do 10 i=1,2
        nde(i)=0
        is(i)=0
        idz(i)=0
        amp(i)=zero
        bet0(i)=zero
        alf0(i)=zero
        clo(i)=zero
        clop(i)=zero
        aper(i)=c1e3
        di0(i)=zero
        dip0(i)=zero
        cro(i)=zero
        sigma0(i)=zero
        qwsk(i)=zero
        betx(i)=zero
        betz(i)=zero
        alfx(i)=zero
        alfz(i)=zero
   10 continue
      do 20 i=1,3
        iq(i)=0
        hsy(i)=zero
        qw0(i)=zero
        clo6(i)=zero
        clop6(i)=zero
        clon(i)=zero
        wxys(i)=zero
        do i1=1,3
          corr(i,i1)=zero
        enddo
   20 continue
      corr(1,1)=zero
      corr(1,2)=zero
      chromc(1)=9.999999d23
      chromc(2)=9.999999d23
      do 30 i=1,4
        nwr(i)=0
   30 continue
      do 40 i=1,5
        ipr(i)=0
        nrr(i)=0
        nu(i)=0
        toptit(i)=' '
   40 continue
      do 50 i=1,6
        nskew(i)=0
   50 continue
      do 60 i=1,10
        dtr(i)=zero
        coel(i)=' '
   60 continue
      do 70 i=1,12
        ire(i)=0
   70 continue
      do 80 i=1,nper
        msym(i)=0
   80 continue
      do 90 i=1,6
        do 90 j=1,6
          ta(i,j)=zero
   90 continue
      do 100 i=1,2
        do 100 j=1,6
          exz(i,j)=zero
  100 continue
      do 110 i1=1,9
        do 110 i2=1,18
          do 110 i3=1,10
            do 110 i4=1,5
              rtc(i1,i2,i3,i4)=zero
              rts(i1,i2,i3,i4)=zero
  110 continue
!--NUMBER OF PARTICLES--------------------------------------------------
      do i=1,npart
        do i1=1,6
          do i2=1,6
            tasau(i,i1,i2)=zero
          enddo
        enddo
      enddo
!--NUMBER OF ELEMENTS---------------------------------------------------
      do 150 i=1,nele
        kz(i)=0
        kp(i)=0
        irm(i)=0
        imtr(i)=0
        nmu(i)=0
        kpa(i)=0
        isea(i)=0
        ncororb(i)=0
        iratioe(i)=0
        itionc(i)=0
        dki(i,1)=zero
        dki(i,2)=zero
        dki(i,3)=zero
        ed(i)=zero
        el(i)=zero
        ek(i)=zero
        sm(i)=zero
        xpl(i)=zero
        xrms(i)=zero
        zpl(i)=zero
        zrms(i)=zero
        benkc(i)=zero
        r00(i)=zero

        apx(i)=c1e3
        apz(i)=c1e3
        ape(1,i)=c1e6
        ape(2,i)=c1e6
        ape(3,i)=c1e12

        ratioe(i)=one
        hsyc(i)=zero
        phasc(i)=zero
        ptnfac(i)=zero
        acdipph(i)=zero
        crabph(i)=zero
        crabph2(i)=zero
        crabph3(i)=zero
        crabph4(i)=zero
        bez(i)=' '
        bezl(i)=' '
        do 120 i3=1,2
          do 120 i4=1,6
            a(i,i3,i4)=zero
+if .not.vvector
            do 120 i1=1,2
+ei
+if vvector
              do 120 i1=1,npart
+ei
+if .not.datamods
                al(i4,i3,i1,i)=zero
                as(i4,i3,i1,i)=zero
+ei
+if .not.vvector
                at(i4,i3,i1,i)=zero
                a2(i4,i3,i1,i)=zero
+ei
  120   continue
        do 130 i1=1,mmul
          bk0(i,i1)=zero
          ak0(i,i1)=zero
          bka(i,i1)=zero
          aka(i,i1)=zero
  130   continue
        do 140 i1=1,3
          bezr(i1,i)=' '
  140   continue
        do i1=1,18
          parbe(i,i1)=zero
        enddo
  150 continue
!--NUMBER OF BLOCKS-----------------------------------------------------
      do 180 i=1,nblo
        mel(i)=0
        mstr(i)=0
        elbe(i)=zero
        bezb(i)=' '
        do 160 i1=1,2
          do 160 i2=1,6
            bl1(i,i1,i2)=zero
            bl2(i,i1,i2)=zero
  160   continue
        do 170 j=1,nelb
          mtyp(i,j)=0
  170   continue
  180 continue
!--# OF STRUCTURE ELEMENTS----------------------------------------------
      do 190 i=1,nblz
        ic(i)=0
        mzu(i)=0
        icext(i)=0
+if time
        icext35(i)=0
+ei
        icextal(i)=0
        extalign(i,1)=zero
        extalign(i,2)=zero
        extalign(i,3)=zero
        sigmoff(i)=zero
        tiltc(i)=one
        tilts(i)=zero
!--Beam-Beam------------------------------------------------------------
        imbb(i)=0               !Mapping from a STRUCTURE ELEMENT (here: index i)
                                ! to the beam-beam tables (arrays with size nbb)
!--Other stuff (not beam-beam)...
        do 190 j=1,40
          exterr(i,j)=zero
+if time
          exterr35(i,j)=zero
+ei
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
        smizf(i)=zero
        do i1=1,mmul
          aai(i,i1)=zero
          bbi(i,i1)=zero
        enddo
        do i3=1,mmul
          do i2=1,nmac
            aaiv(i3,i2,i)=zero
            bbiv(i3,i2,i)=zero
          enddo
        enddo
  190 continue
!-- BEAM-EXP------------------------------------------------------------
      beam_expflag = 0

!-- RANDOM NUMBERS-------------------------------------------------------
      do 200 i=1,nzfz
        zfz(i)=zero
+if time
        zfz35(i)=zero
        tcnst35(i)=zero
+ei
  200 continue
!--# OF TRAJECTORIES----------------------------------------------------
      do 220 i=1,mpa
        rvf(i)=one
        sigm(i)=zero
        dps(i)=zero
        ej(i)=zero
        ejf(i)=zero
        do 210 i1=1,2
          x(i,i1)=zero
          y(i,i1)=zero
  210   continue
  220 continue
!--COMBINATION OF ELEMENTS----------------------------------------------
      do 240 i1=1,20
        icomb0(i1)=0
        do 230 i=1,ncom
          icomb(i,i1)=0
          ratio(i,i1)=zero
  230   continue
  240 continue
!--PAW------------------------------------------------------------------
      do 250 i=1,nplo
        hmal(i)=0.0
  250 continue
!--TROMBONES------------------------------------------------------------
      do i=1,ntr
        do i1=1,6
          cotr(i,i1)=zero
          do i2=1,6
            rrtr(i,i1,i2)=zero
          enddo
        enddo
      enddo
!--Beam-Beam------------------------------------------------------------
      do i=1,nbb
        do j=1,2
          sigman(j,i)=zero
          sigman2(j,i)=zero
          sigmanq(j,i)=zero
        enddo
        do j=1,6
          clobeam(j,i)=zero
          beamoff(j,i)=zero
        enddo
        do j=1,12
          bbcu(i,j)=zero
        enddo
        bbcu(i,11)=one
      enddo
!--DA-------------------------------------------------------------------
      do i1=1,2
        xx_da(i1)=0
        yy_da(i1)=0
        do i2=1,6
          alda_da(i1,i2)=0
          asda_da(i1,i2)=0
          aldaq_da(i1,i2)=0
          asdaq_da(i1,i2)=0
        enddo
      enddo
      do i=1,mcor
        smida_da(i)=0
      enddo

!--CADCUM---------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise common
!     always in main code
      do i=0,nblz+1
         dcum(i)=zero
      enddo

!--DUMP BEAM POPULATION-------------------------------------------------
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K.Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     initialise common
!     always in main code
      ldumphighprec = .false.
      ldumpfront    = .false.
      do i1=1,nblz
        do i2=1,6
          dump_clo(i1,i2)=0
          do i3=1,6
            dump_tas(i1,i2,i3)=0
          enddo
        enddo
      enddo
      do i=0,nele
        ldump(i)    = .false.
        ndumpt(i)   = 0
        dumpfirst(i) = 0
        dumplast(i)  = 0
        dumpunit(i) = 0
        dumpfmt(i)  = 0
        do j=1,getfields_l_max_string
           dump_fname(i)(j:j) = char(0)
        enddo
+if cr
        dumpfilepos(i) = -1
+ei
      enddo
!--FMA ANALYSIS---------------------------------------------------------
!     M. Fitterer, FNAL
!     last modified: 2016
      fma_flag = .false.
      fma_numfiles = 0
      do i=1,fma_max
        fma_nturn(i) = 0
        fma_norm_flag(i) = 1 !initialize to 1 as default is with normalisation
        do j=1,getfields_l_max_string
          fma_fname(i)(j:j) = char(0)
          fma_method(i)(j:j) = char(0)
        enddo
      enddo
!combine multiple elments in one loope
!1) --ELEN - ELECTRON LENS---------------------------------------------------------
!2) --WIRE - WIRE ELEMENT---------------------------------------------------------
!     M. Fitterer (FNAL), A. Patapenka (NIU)
!     last modified: 22-12-2016
! 1) single elements
      do i=1,nele
!     elensparam - used for tracking (parameters of single element)
        elens_type(i)          = 0
        elens_theta_max(i)     = 0
        elens_r2(i)            = 0
        elens_r2ovr1(i)        = 0
        elens_offset_x(i)      = 0
        elens_offset_y(i)      = 0
        elens_bend_entrance(i) = 0
        elens_bend_exit(i)     = 0
!     wireparam - used for tracking (parameters of single element)
        wire_flagco(i)  = 0
        wire_current(i) = 0
        wire_lint(i)    = 0
        wire_lphys(i)   = 0
        wire_dispx(i)   = 0
        wire_dispy(i)   = 0
        wire_tiltx(i)   = 0
        wire_tilty(i)   = 0
      enddo
! 2) loop over structure elements
      do i=1,nblz
        wire_num(i)=0
      enddo
! 3) loop over number of wires
      do i=1,wire_max
        do j=1,6
          wire_clo(j,i)=zero
        enddo
      enddo
!--DYNAMIC KICKS--------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     initialise common
!     always in main code
!     - general-purpose variables
      ldynk = .false.
      ldynkdebug = .false.
      ldynkfiledisable = .false.
      
      nfuncs_dynk = 0
      niexpr_dynk = 0
      nfexpr_dynk = 0
      ncexpr_dynk = 0

      do i=1,maxfuncs_dynk
         funcs_dynk(i,1)= 0 !FUN name ( index in cexpr_dynk; 0 is invalid )
         funcs_dynk(i,2)=-1 !FUN type (-1 is invalid)
         funcs_dynk(i,3)= 0
         funcs_dynk(i,4)= 0
         funcs_dynk(i,5)= 0
      enddo
      
      do i=1,maxdata_dynk
         iexpr_dynk(i) = 0
         fexpr_dynk(i) = 0.0
         do j=1,maxstrlen_dynk
            cexpr_dynk(i)(j:j) = char(0)
         enddo
      enddo
      
      nsets_dynk = 0

      do i=1, maxsets_dynk
         sets_dynk(i,1) = 0 !FUN idx ( index in funcs_dynk; 0 is invalid )
         sets_dynk(i,2) = 0
         sets_dynk(i,3) = 0
         sets_dynk(i,4) = 0
         
         do j=1, maxstrlen_dynk
            csets_dynk(i,1)(j:j) = char(0)
            csets_dynk(i,2)(j:j) = char(0)
            csets_unique_dynk(i,1)(j:j) = char(0)
            csets_unique_dynk(i,2)(j:j) = char(0)
         enddo
         fsets_origvalue_dynk(i) = 0.0
      enddo
      
      do i=1,nele
         dynk_izuIndex(i) = 0
         dynk_elemdata(i,1) = 0
         dynk_elemdata(i,2) = 0
         dynk_elemdata(i,3) = 0
      end do
+if cr
      dynkfilepos = -1 ! This line counter becomes >= 0 once the file is opened.
+ei
!--ZIPF----------------------------------------------------------------
      zipf_numfiles = 0
      
      do j=1, stringzerotrim_maxlen
         zipf_outfile(j:j)=char(0)
      enddo
      
      do i=1, zipf_maxfiles
         do j=1, stringzerotrim_maxlen
            zipf_filenames(i)(j:j)=char(0)
         enddo
      enddo
      
!--COLLIMATION----------------------------------------------------------
+if collimat
      do_coll = .false.
      
      ! From common /grd/
      emitnx0_dist = 0.0
      emitny0_dist = 0.0
      emitnx0_collgap = 0.0
      emitny0_collgap = 0.0
      ! From common /ralph/
      myemitx0_dist = 0.0
      myemity0_dist = 0.0
      myemitx0_collgap = 0.0
      myemity0_collgap = 0.0
+ei
!
!-----------------------------------------------------------------------
      return
      end
+dk umschr
      subroutine umschr(iu1,iu2)
!-----------------------------------------------------------------------
!           UMSCHR    DIFFERENTIAL ALGEBRA 5 -> 6
!                          AUGUST 1994
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ii,iio,io,ioo,iplus,iu1,iu2,j,jj,nno
      double precision c,c1
      character*80 aaa
      character*18 a18
      character*58 a58
      dimension jj(100)
      save
!-----------------------------------------------------------------------
      do i=1,100
        jj(i)=0
      enddo
      do 40 j=1,6
        iplus=0
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A18,I4,A58)') a18,nno,a58
        write(iu2,'(A18,I4,A58)') a18,nno,a58
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
!
        if(nno.eq.1) then
          do 10 i=1,5
            read(iu1,'(6X,2X,G20.14,I5)') c,ii
            write(iu2,'(6X,2X,G20.14,I5)') c,ii
   10     continue
          if (j.eq.5) then
            write(iu2,'(6X,2X,G20.14,I5)') 1d0,5
          else
            write(iu2,'(6X,2X,G20.14,I5)') 0d0,5
          endif
          read(iu1,'(6X,2X,G20.14,I5)') c,ii
          write(iu2,'(6X,2X,G20.14,I5)') c,ii+1
          read(iu1,'(6X,2X,G20.14,I5)') c,ii
          if(ii.ne.0) write(lout,*) ' ERROR IN UMSCHR'
        else
   20     read(iu1,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii,c,io,(jj(i),i  &
     &=1,5)
          if(ii.eq.0) then
            if(j.eq.5.and.ioo.lt.2) then
              write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') iio+1,1d0,1, &
     &0,0,0,0,1,0
              write(iu2,*) 1d0
            endif
            goto 30
          endif
          ioo=io
          iio=ii
          read(iu1,*) c1
          if(j.eq.5.and.(io.eq.2.or.jj(5).eq.1).and.iplus.eq.0) then
            iplus=1
            write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii,1d0,io,0,0, &
     &0,0,1,0
            write(iu2,*) 1d0
          endif
          write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii+iplus,c,io,(jj&
     &(i),i=1,4),0,jj(5)
          write(iu2,*) c1
          goto 20
        endif
   30   write(iu2,*)
   40 continue
      rewind iu1
      rewind iu2
      return
      end
+dk daliesix
      subroutine daliesix
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,mf1,mf2,mf3,mf4,mf5,mfile,nd2,ndim,ndpt,nis,no,nv,damap,&
     &a1,a1i,a2,a2i,f,fc,fs,rot,xy,h,hc,hs,h4,df,bb1,bb2,haux
      real tlim,time0,time1,time
      double precision angle,coe,rad,x2pi
+ca parpro
+ca parnum
+ca commondl
+ca commonas
      dimension damap(6),a1(6),a1i(6),a2(6),a2i(6)
      dimension rot(6),xy(6),df(6)
      dimension angle(3),rad(3)
      save
!-----------------------------------------------------------------------
      tlim=1e7
      call timest(tlim)
      time0=0.
      call timex(time0)
!--Initialization
+if crlibm
      x2pi=atan_rn(one)*8d0
+ei
+if .not.crlibm
      x2pi=atan(one)*8d0
+ei
      coe=(-1d0*two)/x2pi                                                !hr08
      no=nordf
      if(nord1.gt.no) nord1=no
      ndim=nvar2/2
      if(nvarf/2.lt.ndim) ndim=nvarf/2
      if(ndim.eq.0) call prror(94)
      nv=nvarf
      nd2=2*ndim
      ndpt=idptr
      nis=0
      mfile=18
      mf1=21
      mf2=22
      mf3=23
      mf4=24
      mf5=25
      call idprset(-102)
      call lieinit(no,nv,ndim,ndpt,0,nis)
      call etall(damap,nd2)
      call etall(xy,nd2)
      call etall(bb1,1)
      call etall(bb2,1)
      call etall(haux,1)
      call etallnom(a1,nd2,'A1        ')
      call etallnom(a1i,nd2,'A1I       ')
      call etallnom(a2,nd2,'A2        ')
      call etallnom(a2i,nd2,'A2I       ')
      call etallnom(f,1,'F         ')
      call etallnom(fc,1,'FC        ')
      call etallnom(fs,1,'FS        ')
      call etallnom(rot,nd2,'ROT       ')
      call etallnom(h,1,'H         ')
      call etallnom(h4,1,'H4        ')
      call etallnom(hc,1,'HC        ')
      call etallnom(hs,1,'HS        ')
      call etallnom(df,nd2,'DF        ')
      rewind mfile
!Eric
      rewind 111
      rewind mf1
      rewind mf2
      rewind mf3
      rewind mf4
      rewind mf5
      call daread(damap,nd2,mfile,0.d0)
!--Normal Form Analysis
      call mapnorm(damap,f,a2,a1,xy,h,nord1)
      call dainv(a1,nv,a1i,nv)
      call dainv(a2,nv,a2i,nv)
      call ctor(f,fc,fs)
      call gettura(angle,rad)
      call taked(xy,1,rot)
      call take(h,2,haux)
      call dasub(h,haux,h4)
      call ctor(h,hc,hs)
      call dhdj(h,df)
!--Printing
      call daprid(a1i,1,nd2,mf1)
      call daprid(a2i,1,nd2,mf1)
      call dapri(f,mf1)
      call daprid(rot,1,nd2,mf1)
      call dapri(h4,mf1)
      call dapri(f,mf1)
      call daprid(a2,1,nd2,mf1)
      call daprid(a1,1,nd2,mf1)
      call dapri(h,mf2)
      call dapri(hc,mf2)
      call dapri(hs,mf2)
      call dapri(fc,mf2)
      call dapri(fs,mf2)
      call daprimax(hc,mf3)
      call daprid(df,ndim+1,nd2,mf4)
      call daprid(df,1,ndim,mf5)
      write(lout,10060)
      if(imod1.eq.0) then
        write(lout,10020) nordf
      else
        write(lout,10010) nordf
      endif
      write(lout,10025) nord1
      if(imod2.eq.0) then
        write(lout,10040) nvarf
      else
        write(lout,10030) nvarf
      endif
      write(lout,10050)
      angle(3)=angle(3)*(-one)
      write(lout,*) (angle(i),i=1,ndim)
!--Clean-Up
      call dadal(damap,nd2)
      call dadal(a1,nd2)
      call dadal(a1i,nd2)
      call dadal(a2,nd2)
      call dadal(a2i,nd2)
      call dadal(f,1)
      call dadal(fc,1)
      call dadal(fs,1)
      call dadal(rot,nd2)
      call dadal(xy,nd2)
      call dadal(h,1)
      call dadal(h4,1)
      call dadal(hc,1)
      call dadal(hs,1)
      call dadal(df,nd2)
      call dadal(bb1,1)
      call dadal(bb2,1)
      call dadal(haux,1)
      time1=0.
      call timex(time1)
      time = time1-time0
      write(lout,10000) no,time
      return
!-----------------------------------------------------------------------
10000 format(/10x,'DA-CALCULATION OF ORDER : ',i7,' TAKES ', f12.3,     &
     &' SECONDS OF CPU TIME'//131('-')//)
10010 format(t10,'THE ORDER IS GREATER THAN THE ONE SPECIFIED IN THE'/  &
     &t10,'DIFFERENTIAL ALGEBRA BLOCK.'// t10,'NEW ORDER---> ',i3)
10020 format(t10,'ORDER FOR THE NORMAL FORM CALCULATIONS---> ',i3/)
10025 format(/t10,'CLOSED ORBIT ORDER OF THE NORMAL FORM ---> ',i3/)
10030 format(t10,'THE NUMBER OF VARIABLES IS GREATER THAN THE ONE ',    &
     &'SPECIFIED IN THE'/ t10,'DIFFERENTIAL ALGEBRA BLOCK.'// t10,      &
     &'NEW NUMBER OF VARIABLES---> ',i3/)
10040 format(t10,'NUMBER OF VARIABLES FOR THE NORMAL FORM ' ,           &
     &'CALCULATIONS---> ',i3//)
10050 format(t10,'LINEAR TUNES USED IN THE NORMAL FORM CALCULATIONS:'//)
10060 format(//131('-')//t10,20('O')/t10,2('O'),16x,2('O')/t10,         &
     &'OO  NORMAL FORMS  OO', /t10,2('O'),16x,2('O')/t10,20('O')//130(  &
     &'-')//)
      end
+dk distance
      subroutine distance(x,clo,di0,t,dam)
!-----------------------------------------------------------------------
!  CALCULATION OF DISTANCE IN PHASE SPACE FOR POST-PROCESSING
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ii,iq,j,jq
      double precision clo,cx,dam,di0,phi,pi,sx,t,x,x1
+ca parpro
+ca parnum
+ca commonds
      dimension x(2,6),x1(2,6),clo(6),di0(4),t(6,6),phi(3)
      save
!-----------------------------------------------------------------------
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      if(icode.ge.4.and.its6d.eq.0) then
        do 10 i=1,2
          do 10 j=1,4
            x(i,j)=x(i,j)-di0(j)*x(i,6)
   10   continue
      endif
      do 60 i=1,2
        do 20 j=1,6
          x(i,j)=x(i,j)-clo(j)
   20   continue
        if(its6d.eq.1) then
          x(i,2)=x(i,2)/((one+x(i,6))+clo(6))                            !hr06
          x(i,4)=x(i,4)/((one+x(i,6))+clo(6))                            !hr06
        endif
        do 40 iq=1,6
          x1(i,iq)=zero
          do 30 jq=1,6
            x1(i,iq)=x1(i,iq)+t(jq,iq)*x(i,jq)
   30     continue
   40   continue
        do 50 j=1,6
          x(i,j)=x1(i,j)
   50   continue
   60 continue
      do 70 i=1,2
        x(i,5)=x(i,5)*sigcor
        x(i,6)=x(i,6)*dpscor
   70 continue
      do 80 i=1,3
        ii=2*i
        sx=x(2,ii-1)*x(1,ii)-x(1,ii-1)*x(2,ii)
        cx=x(1,ii-1)*x(2,ii-1)+x(1,ii)*x(2,ii)
        if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
+if crlibm
          phi(i)=atan2_rn(sx,cx)
+ei
+if .not.crlibm
          phi(i)=atan2(sx,cx)
+ei
        else
          phi(i)=zero
        endif
   80 continue
      dam=sqrt((phi(1)**2+phi(2)**2+phi(3)**2)/dble(idam))/pi            !hr06
!-----------------------------------------------------------------------
      return
      end
+dk anfb
      subroutine anfb(tas)
!-----------------------------------------------------------------------
!  CALCULATION OF INITIAL COORDINATES
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ii,jj,l,ll
      double precision bet0s1,bet0x2,bet0z2,chi,co,dchi,dpsic,dsign,si, &
     &tas,tas56,x1,x11,x13,x2
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension tas(6,6),x1(6),x2(6)
      save
!-----------------------------------------------------------------------
      write(lout,10030)
      if(itra.eq.0) goto 60
      tas56=tas(5,6)*c1m3
      bet0x2=tas(1,3)**2+tas(1,4)**2                                     !hr08
      bet0z2=tas(3,1)**2+tas(3,2)**2                                     !hr08
      bet0s1=tas(5,5)**2+tas56**2                                        !hr08
      dsign=one
      if(tas(3,3).lt.-1d0*pieni) rat=-1d0*rat                            !hr08
      if(rat.lt.-1d0*pieni) dsign=-1d0*one
      x11=amp(1)/(sqrt(bet0(1))+sqrt(abs(rat)*bet0x2))
      x13=(x11*dsign)*sqrt(abs(rat))                                     !hr08
      amp(2)=(dsign*dble(1-iver))*                                      &!hr08
     &(abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt(bet0(2)))                     !hr08
      x1(5)=zero
      if(iclo6.eq.1.or.iclo6.eq.2) then
        x1(6)=(dp1-clop6(3))*sqrt(bet0s1)
      else
        x1(6)=dp1*sqrt(bet0s1)
      endif
      chi=chi0*rad
      dchi=chid*rad
      do 50 i=1,itra
+if crlibm
        si=sin_rn(chi)
+ei
+if .not.crlibm
        si=sin(chi)
+ei
+if crlibm
        co=cos_rn(chi)
+ei
+if .not.crlibm
        co=cos(chi)
+ei
        x1(1)=x11*co
        x1(2)=x11*si
        x1(3)=x13*co
        x1(4)=x13*si
        do 20 ii=1,6
          x2(ii)=zero
          do 10 jj=1,6
            x2(ii)=x2(ii)+tas(ii,jj)*x1(jj)
   10     continue
   20   continue
        if(iclo6.eq.1.or.iclo6.eq.2) then
          x2(2)=x2(2)/((one+x2(6))+clop6(3))                             !hr08
          x2(4)=x2(4)/((one+x2(6))+clop6(3))                             !hr08
        endif
        if(abs(bet0s1).le.pieni) x2(6)=dp1
        if(iver.eq.1) then
          x2(3)=zero
          x2(4)=zero
        endif
        do 30 l=1,2
          ll=(l-1)*2
          x(i,l)=x2(1+ll)+exz(i,1+ll)
          y(i,l)=x2(2+ll)+exz(i,2+ll)
   30   continue
        sigm(i)=x2(5)+exz(i,5)
        dps(i)=x2(6)
        dpsic=dps(i)+clop6(3)
        if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
          do 40 l=1,2
            x(i,l)=x(i,l)+di0(l)*dpsic
            y(i,l)=y(i,l)+dip0(l)*dpsic
   40     continue
        endif
        chi=chi+dchi
   50 continue
      write(lout,10000) itra,amp,chi0,chid
      write(lout,10010) x(1,1),y(1,1),x(1,2),y(1,2),sigm(1),dps(1),     &
     &x(2,1),
     &y(2,1),x(2,2),y(2,2),sigm(2),dps(2)
      return
   60 itra=2
      do 80 i=1,itra
        sigm(i)=exz(i,5)
        dps(i)=exz(i,6)
        do 70 l=1,2
          ll=(l-1)*2
          x(i,l)=exz(i,1+ll)
          y(i,l)=exz(i,2+ll)
   70   continue
   80 continue
      write(lout,10020)
      write(lout,10010) x(1,1),y(1,1),x(1,2),y(1,2),sigm(1),dps(1),     &
     &x(2,1),
     &y(2,1),x(2,2),y(2,2),sigm(2),dps(2)
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY ANFB ----/ITRA/',i3,' /AMP/ ',f8.3,2x,f8.3, &
     &' /CHI0,CHID/  ',f6.1,2x,f6.1)
10010 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10020 format(t5,'---- ENTRY ANFB ----/COORDINATE-INPUT')
10030 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
      end
+dk betalf
      subroutine betalf(dpp,qw)
!-----------------------------------------------------------------------
!  CALCULATION OF : OPT. PARAMETERS AT THE STARTING POSITION:
!                   BETA-, ALFA-FUNCTIONS, Q-VALUES
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,j
      double precision am,det,detb,detc,dpp,egwg1,egwg2,f0,f1,f2,fak1,  &
     &fak2,qw,rca1,rca2,rclam1,rclam2,rcw1(4),rcw2(4),rn1,rn2,spa,spd,  &
     &sqrn,yca1,yca2,yclam1,yclam2,ycw1(4),ycw2(4)
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension am(4,4)
      dimension qw(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ierro=0
      call matrix(dpp,am)
!--CALCULATION OF EIGENVALUES
   10 spa=am(1,1)+am(2,2)
      spd=am(3,3)+am(4,4)
      det=(am(1,3)+am(4,2))*(am(2,4)+am(3,1))                           &
     &-(am(1,4)-am(3,2))*(am(2,3)-am(4,1))
      f0=spa-spd
      f1=spa+spd
      f2=f0**2+four*det                                                  !hr06
      if(f2 .lt. zero) goto 160
      f2=sqrt(f2)
      if(f0.lt.0d0) goto 30                                              !hr06
      if(f0.ge.0d0) goto 20                                              !hr06
   20 egwg1=(f1+f2)*half
      egwg2=(f1-f2)*half
      goto 40
   30 egwg1=(f1-f2)*half
      egwg2=(f1+f2)*half
   40 continue
      f1=egwg1**2-four                                                   !hr06
      f2=egwg2**2-four                                                   !hr06
      rca1=f1
      yca1=zero
      rca2=f2
      yca2=zero
      if (rca1.ge.0) then
        rca1=sqrt(rca1)
      else
        yca1=sqrt(-1d0*rca1)                                             !hr06
        rca1=zero
      endif
      if (rca2.ge.0) then
        rca2=sqrt(rca2)
      else
        yca2=sqrt(-1d0*rca2)                                             !hr06
        rca2=zero
      endif
      rclam1=(egwg1+rca1)*half
      yclam1=yca1*half
      rclam2=(egwg2+rca2)*half
      yclam2=yca2*half
      if(egwg1**2 .ge. four) goto 160                                    !hr06
      if(egwg2**2 .ge. four) goto 160                                    !hr06
   50 continue
      detb=am(1,3)*am(2,4)-am(1,4)*am(2,3)
      detc=am(3,1)*am(4,2)-am(3,2)*am(4,1)
      fak1=spd-egwg1
      if(abs(fak1).gt.pieni) then
        rcw1(1)=am(1,2)-(am(1,3)*am(3,2)+am(1,4)*am(4,2))/fak1           !hr06
        ycw1(1)=zero
        rcw1(2)=((am(1,3)*am(3,1)+am(1,4)*am(4,1))+detb)/fak1-(am(1,1)  &!hr06
     &-rclam1)                                                           !hr06
        ycw1(2)=yclam1
      rcw1(3)=-1d0*((am(3,1)+am(2,4))*rcw1(1)+(am(3,2)-am(1,4))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(3)=-1d0*((am(3,1)+am(2,4))*ycw1(1)+(am(3,2)-am(1,4))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      rcw1(4)=-1d0*((am(4,1)-am(2,3))*rcw1(1)+(am(4,2)+am(1,3))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(4)=-1d0*((am(4,1)-am(2,3))*ycw1(1)+(am(4,2)+am(1,3))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      else
        rcw1(1)=am(1,2)
        ycw1(1)=zero
        rcw1(2)=rclam1-am(1,1)                                           !hr06
        ycw1(2)=yclam1
        rcw1(3)=zero
        ycw1(3)=zero
        rcw1(4)=zero
        ycw1(4)=zero
      endif
      fak2=spa-egwg2
      if(abs(fak2).gt.pieni) then
        rcw2(3)=am(3,4)-(am(3,1)*am(1,4)+am(3,2)*am(2,4))/fak2           !hr06
        ycw2(3)=zero
        rcw2(4)=((am(3,1)*am(1,3)+am(3,2)*am(2,3))+detc)/fak2-(am(3,3)  &!hr06
     &-rclam2)                                                           !hr06
        ycw2(4)=yclam2
      rcw2(1)=-1d0*((am(1,3)+am(4,2))*rcw2(3)+(am(1,4)-am(3,2))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(1)=-1d0*((am(1,3)+am(4,2))*ycw2(3)+(am(1,4)-am(3,2))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      rcw2(2)=-1d0*((am(2,3)-am(4,1))*rcw2(3)+(am(2,4)+am(3,1))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(2)=-1d0*((am(2,3)-am(4,1))*ycw2(3)+(am(2,4)+am(3,1))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      else
        rcw2(3)=am(3,4)
        ycw2(3)=zero
        rcw2(4)=rclam2-am(3,3)                                           !hr06
        ycw2(4)=yclam2
        rcw2(1)=zero
        ycw2(1)=zero
        rcw2(2)=zero
        ycw2(2)=zero
      endif
!--LEAVING COMPLEX NUMBERS
      do 60 i=1,4
        ta(i,1)=rcw1(i)
        ta(i,3)=rcw2(i)
        ta(i,2)=ycw1(i)
        ta(i,4)=ycw2(i)
   60 continue
!--NORMALISATION OF EIGENVALUES
      rn1=((ta(1,1)*ta(2,2)-ta(2,1)*ta(1,2))                            &!hr06
     &+ta(3,1)*ta(4,2))-ta(4,1)*ta(3,2)                                  !hr06
      if(rn1.lt.0d0) goto 70                                             !hr06
      if(rn1.eq.0d0) goto 160                                            !hr06
      if(rn1.gt.0d0) goto 90                                             !hr06
   70 yclam1=-1d0*yclam1                                                 !hr06
      do 80 i=1,4
   80 ta(i,2)=-1d0*ta(i,2)                                               !hr06
   90 sqrn=sqrt(abs(rn1))
      do 100 i=1,4
        ta(i,1)=ta(i,1)/sqrn
  100 ta(i,2)=ta(i,2)/sqrn
      rn2=((ta(1,3)*ta(2,4)-ta(2,3)*ta(1,4))                            &!hr06
     &+ta(3,3)*ta(4,4))-ta(4,3)*ta(3,4)                                  !hr06
      if(rn2.lt.0d0) goto 110                                            !hr06
      if(rn2.eq.0d0) goto 160                                            !hr06
      if(rn2.gt.0d0) goto 130                                            !hr06
  110 yclam2=-1d0*yclam2                                                 !hr06
      do 120 i=1,4
  120 ta(i,4)=-1d0*ta(i,4)                                               !hr06
  130 sqrn=sqrt(abs(rn2))
      do 140 i=1,4
        ta(i,3)=ta(i,3)/sqrn
  140 ta(i,4)=ta(i,4)/sqrn
+if crlibm
      qw(1)= atan_rn(yclam1/(one+rclam1))/pi
+ei
+if .not.crlibm
      qw(1)= atan(yclam1/(one+rclam1))/pi
+ei
+if crlibm
      qw(2)= atan_rn(yclam2/(one+rclam2))/pi
+ei
+if .not.crlibm
      qw(2)= atan(yclam2/(one+rclam2))/pi
+ei
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      betx(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
      alfx(1)=-1d0*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
      betx(2)=ta(1,3)**2+ta(1,4)**2                                      !hr06
      alfx(2)=-1d0*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
      betz(1)=ta(3,1)**2+ta(3,2)**2                                      !hr06
      alfz(1)=-1d0*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
      betz(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
      alfz(2)=-1d0*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
      bet0(1)=betx(1)
      alf0(1)=alfx(1)
      bet0(2)=betz(2)
      alf0(2)=alfz(2)
      if(ta(1,1).lt.-pieni) then
        do 150 i=1,4
          do 150 j=1,4
            ta(i,j)=-1d0*ta(i,j)
  150   continue
      endif
      return
!-----------------------------------------------------------------------
  160 ierro=1
      return
      end
+dk block
      subroutine block
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,j,jm,k,l,m,n
      double precision g,h
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension h(nblo,2,6),g(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 60 k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)
        do 10 l=1,2
          do 10 m=1,6
            h(1,l,m)=a(i,l,m)
   10   g(1,l,m)=a(n,l,m)
        if(jm.eq.1) goto 40
        do 30 j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do 20 l=1,2
            h(j,l,1)=h(j-1,l,1)*a(i,l,1)+h(j-1,l,3)*a(i,l,2)
            h(j,l,2)=h(j-1,l,2)*a(i,l,1)+h(j-1,l,4)*a(i,l,2)
            h(j,l,3)=h(j-1,l,1)*a(i,l,3)+h(j-1,l,3)*a(i,l,4)
            h(j,l,4)=h(j-1,l,2)*a(i,l,3)+h(j-1,l,4)*a(i,l,4)
            g(j,l,1)=g(j-1,l,1)*a(n,l,1)+g(j-1,l,3)*a(n,l,2)
            g(j,l,2)=g(j-1,l,2)*a(n,l,1)+g(j-1,l,4)*a(n,l,2)
            g(j,l,3)=g(j-1,l,1)*a(n,l,3)+g(j-1,l,3)*a(n,l,4)
            g(j,l,4)=g(j-1,l,2)*a(n,l,3)+g(j-1,l,4)*a(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*a(i,l,1)+h(j-1,l,6)*a(i,l,2))+a(i,l,5)  !hr06
            h(j,l,6)=(h(j-1,l,5)*a(i,l,3)+h(j-1,l,6)*a(i,l,4))+a(i,l,6)  !hr06
            g(j,l,5)=(g(j-1,l,5)*a(n,l,1)+g(j-1,l,6)*a(n,l,2))+a(n,l,5)  !hr06
            g(j,l,6)=(g(j-1,l,5)*a(n,l,3)+g(j-1,l,6)*a(n,l,4))+a(n,l,6)  !hr06
   20     continue
   30   continue
   40   do 50 l=1,2
          do 50 m=1,6
            bl1(k,l,m)=h(jm,l,m)
   50   bl2(k,l,m)=g(jm,l,m)
   60 continue
      return
      end
+dk blockdis
      subroutine blockdis(aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX, USED FOR DISPERSION
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,j,jm,k,l,m,n
      double precision aeg,bl1eg,bl2eg,g,h
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension h(nblo,2,6),g(nblo,2,6)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 60 k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)
        do 10 l=1,2
          do 10 m=1,6
            h(1,l,m)=aeg(i,l,m)
   10   g(1,l,m)=aeg(n,l,m)
        if(jm.eq.1) goto 40
        do 30 j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do 20 l=1,2
            h(j,l,1)=h(j-1,l,1)*aeg(i,l,1)+h(j-1,l,3)*aeg(i,l,2)
            h(j,l,2)=h(j-1,l,2)*aeg(i,l,1)+h(j-1,l,4)*aeg(i,l,2)
            h(j,l,3)=h(j-1,l,1)*aeg(i,l,3)+h(j-1,l,3)*aeg(i,l,4)
            h(j,l,4)=h(j-1,l,2)*aeg(i,l,3)+h(j-1,l,4)*aeg(i,l,4)
            g(j,l,1)=g(j-1,l,1)*aeg(n,l,1)+g(j-1,l,3)*aeg(n,l,2)
            g(j,l,2)=g(j-1,l,2)*aeg(n,l,1)+g(j-1,l,4)*aeg(n,l,2)
            g(j,l,3)=g(j-1,l,1)*aeg(n,l,3)+g(j-1,l,3)*aeg(n,l,4)
            g(j,l,4)=g(j-1,l,2)*aeg(n,l,3)+g(j-1,l,4)*aeg(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*aeg(i,l,1)+h(j-1,l,6)*aeg(i,l,2))+aeg  &!hr06
     &(i,l,5)                                                            !hr06
            h(j,l,6)=(h(j-1,l,5)*aeg(i,l,3)+h(j-1,l,6)*aeg(i,l,4))+aeg  &!hr06
     &(i,l,6)                                                            !hr06
            g(j,l,5)=(g(j-1,l,5)*aeg(n,l,1)+g(j-1,l,6)*aeg(n,l,2))+aeg  &!hr06
     &(n,l,5)                                                            !hr06
            g(j,l,6)=(g(j-1,l,5)*aeg(n,l,3)+g(j-1,l,6)*aeg(n,l,4))+aeg  &!hr06
     &(n,l,6)                                                            !hr06
   20     continue
   30   continue
   40   do 50 l=1,2
          do 50 m=1,6
            bl1eg(k,l,m)=h(jm,l,m)
   50   bl2eg(k,l,m)=g(jm,l,m)
   60 continue
      return
      end
+dk chroma
      subroutine chroma
!-----------------------------------------------------------------------
!  CALCULATION OF CHROMATICITY FROM 5 ENERGIE-VALUES
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ii,isl,j,jj,l,n
      double precision cor,coro,cro0,de2,det,dm,dpp,dsm,ox,oz,qwc,sens, &
     &sm0,su2,suxy,suzy,xi,zi
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commonc
      dimension dsm(2,4),sens(2,4),xi(2),zi(2),dm(2),sm0(2)
      dimension qwc(3),cro0(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      cor=0d0
      coro=1d38
      do 10 i=1,2
        do 10 j=1,4
          dsm(i,j)=zero
          sens(i,j)=zero
   10 continue
      do 20 i=1,2
        xi(i)=zero
        zi(i)=zero
        dm(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        cro0(i)=zero
   20 continue
      qwc(3)=zero
      write(lout,10010)
      dsm(1,2)=dsm0
      dsm(2,3)=dsm0
      de2=de0*half
      do 90 jj=1,itcro
        do 80 ii=1,4
          su2=zero
          suxy=zero
          suzy=zero
          do 30 l=1,2
            isl=is(l)
            if(kz(isl).ne.3) call prror(11)
            ed(isl)=ed(isl)+dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   30     continue
          do 40 n=1,5
            dpp=de2*dble(3-n)                                            !hr06
            call clorb(dpp)
            if(ierro.gt.0) call prror(12)
            call phasad(dpp,qwc)
            if(ierro.gt.0) call prror(13)
            ox=qwc(1)
            oz=qwc(2)
            su2=su2+dpp**2                                               !hr06
            suxy=suxy+ox*dpp
            suzy=suzy+oz*dpp
   40     continue
          do 50 l=1,2
            isl=is(l)
            ed(isl)=ed(isl)-dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   50     continue
          sens(1,ii)=suxy/su2
          sens(2,ii)=suzy/su2
          if(ii.ne.3) goto 80
!--COMPENSATION OF CHROMATICITY
          do 60 l=1,2
            cro0(l)=sens(l,1)-cro(l)
            xi(l)=(sens(1,l+1)-sens(1,1))/dsm0
   60     zi(l)=(sens(2,l+1)-sens(2,1))/dsm0
          cor=sqrt(cro0(1)**2+cro0(2)**2)                                !hr06
          if(jj.eq.1.or.cor.lt.coro) then
            coro=cor
            det=xi(1)*zi(2)-zi(1)*xi(2)
            dm(1)=(cro0(2)*xi(2)-cro0(1)*zi(2))/det                      !hr06
            dm(2)=(cro0(1)*zi(1)-cro0(2)*xi(1))/det                      !hr06
            do 70 l=1,2
              sm0(l)=ed(is(l))
              isl=is(l)
              ed(isl)=ed(isl)+dm(l)
              if(kp(isl).eq.5) call combel(isl)
 70         continue
          else
            write(lout,10035)
            return
          endif
   80   continue
        write(lout,10020) sens(1,1),sens(1,4),sens(2,1),sens(2,4)
        chromc(1)=sens(1,4)*c1m3
        chromc(2)=sens(2,4)*c1m3
        write(lout,10030) sm0(1),ed(is(1)),bez(is(1)), sm0(2),ed(is(2)),&
     &bez(is(2))
        write(lout,10040) xi,zi
        write(lout,10010)
        if(abs(sens(1,4)-cro(1)).lt.dech.and.abs(sens(2,4)-cro(2))      &
     &.lt.dech) return
   90 continue
      write(lout,10000) itcro
!-----------------------------------------------------------------------
      return
10000 format(/131('-')//t10,'CHROMATICITY CORRECTION'/t10,              &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(/131('-')//t10,'DATA BLOCK CHROMATICITY CORRECTION'/t10,   &
     &'CHROMATICITIES         BEFORE           AFTER CORRECTION'/t10,   &
     &'HORIZONTAL       ',d16.10,7x,d16.10/ t10,'VERTICAL         ',d16.&
     &10,7x,d16.10/)
10040 format(t10,'SEXTUPOLE SENSITIVITIES    XI/M1 XI/M2 YI/M1 YI/M2  ',&
     &4d15.8)
10030 format(t10,'SEXTUP.STRENGTHS ',g16.10,7x,g16.10,'   INDEX   ',a16/&
     &t10,'                 ',g16.10,7x,g16.10,'           ',a16)
10035 format(/t5,'---- NO Improvement in last Step ----'/)
      end
      subroutine chromda
!-----------------------------------------------------------------------
!  CHROMATICITY CORRECTION VIA DA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer icht,iq1,iq2,ix,ncorr,ncorruo,nd,nd2
      double precision cor,coro,dps0,dq1,dq2,edcor1,edcor2,qw,qwc
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commonxz
+ca commonc
+ca commondl
      dimension qw(2),qwc(3)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      write(lout,10000)
      nd=2
      nd2=4
      dps(1)=dp1+dppoff
      ncorruo=ncorru
      ncorru=1
      call clorb(dp1)
      call betalf(dp1,qw)
      call phasad(dp1,qwc)
      if(nbeam.ge.1) then
+ca beamcou
+if debug
!     call dumpbin('abeamcou2',3,33)
!     call abend('after beam coupling                               ')
+ei
      endif
      ncorru=ncorruo
      iq1=is(1)
      iq2=is(2)
      edcor(1)=ed(iq1)
      edcor(2)=ed(iq2)
      edcor1=edcor(1)
      edcor2=edcor(2)
      coro=1d38
      cor=0
      ncorr=0
      do ncorr=1,itcro+1
        ichromc=2
        call mydaini(1,1,nd2,nd,nd2,1)
        ichromc=1
        call mydaini(2,4,7,2,5,1)
        dq1=corr(1,1)-cro(1)*c1m3
        dq2=corr(1,2)-cro(2)*c1m3
        if(ncorr.eq.1) cor=c1e3*sqrt(dq1**2+dq2**2)                      !hr06
        if(cor.gt.dech) then
          cor=c1e3*sqrt(dq1**2+dq2**2)                                   !hr06
          if(ncorr.eq.1.or.cor.lt.coro) then
            coro=cor
            ed(iq1)=(ed(iq1)-corr(2,1)*dq1)-corr(2,2)*dq2                !hr06
            ed(iq2)=(ed(iq2)-corr(3,1)*dq1)-corr(3,2)*dq2                !hr06
            do icht=1,iu
              ix=ic(icht)
              if(ix.gt.nblo) then
                ix=ix-nblo
                if(ix.eq.iq1.or.iratioe(ix).eq.iq1) then
                  smi(icht)=ed(iq1)*ratioe(ix)+smizf(icht)
                else if(ix.eq.iq2.or.iratioe(ix).eq.iq2) then
                  smi(icht)=ed(iq2)*ratioe(ix)+smizf(icht)
                endif
              endif
            enddo
            edcor(1)=ed(iq1)
            edcor(2)=ed(iq2)
            if(ncorr.eq.1) then
              write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            else
              write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            endif
          else
            write(lout,10040) ncorr-1
            goto 1
          endif
        else
          write(lout,10050) ncorr-1
          goto 1
        endif
      enddo
 1    continue
      chromc(1)=corr(1,1)
      chromc(2)=corr(1,2)
      if(ncorr.eq.itcro+1) write(lout,10060) itcro
      if(ncorr.eq.1) then
        write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),                 &
     &corr(1,2)*c1e3,ncorr-1,cor
      else
        write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),corr(1,2)*c1e3,  &
     &ncorr-1,cor
      endif
      write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),bez(iq2)
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING DA CHROMATICITY CORRECTION'/)
10010 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        BEFORE CORRECTION'/ t10,   &
     &'HORIZONTAL'     ,15x,G20.14,1x,G20.14/ t10,                      &
     &'VERTICAL'       ,17x,G20.14,1x,G20.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10020 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        AFTER CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G20.14,1x,G20.14/ t10,                      &
     &'VERTICAL'       ,17x,G20.14,1x,G20.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10030 format(t10,'SEXTUPOLE STRENGTH',5x,g16.10,2x,g16.10,'   TYP     ',&
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
10040 format(/t5,'---- NO IMPROVEMENT OF DA CHROMATICITY CORRECTION ',  &
     &'IN ITERATION: ',i4/)
10050 format(t5/t10,'DA CHROMATICITY CORRECTION SUCCESSFUL IN ',        &
     &'ITERATION: ',i4/)
10060 format(/t10,'DA CHROMATICITY CORRECTION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
      end
+dk clorb
      subroutine clorb(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT   'CLO(2),CLOP(2)'
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ierr,ii,l,ll
      double precision am,cor,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,  &
     &dy,x0,x1,y0,y1
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save ! Saving DPP?
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=1e6
        dy(l)=1e6
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) return
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &goto 50
        do 20 l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
   20   y0(l)=y(1,l)
        call matrix(dpp,am)
        if(ierro.ne.0) return
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=(two-am(ll-1,ll-1))-am(ll,ll)                              !hr06
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
      if(ncorru.ne.1) write(lout,10000) itco
   50 cor=c1e3*sqrt(dcx**2+dcz**2)                                       !hr06
      if(iout.eq.1.and.ncorru.ne.1) then
        write(lout,10010) dpp,clo(1),clop(1),clo(2),clop(2),ii,cor
+if debug
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('clo(1)',clo(1),0,0,0,0)
!     call warr('clop(1)',clop(1),0,0,0,0)
!     call warr('clo(2)',clo(2),0,0,0,0)
!     call warr('clop(2)',clop(2),0,0,0,0)
!     call warr('ii',0d0,ii,0,0,0)
!     call warr('cor',cor,0,0,0,0)
+ei
      endif
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(t5,'---- ENTRY CLORB ----/DPP=',f8.5,' /CLOX/', 2f10.5,    &
     &' /CLOY/',2f10.5,' /ITERAT.=',i3,'/ ACCURACY=',d13.6)
      end
+dk clor6
      subroutine clorda(nn,idummy,am)
!-----------------------------------------------------------------------
!  CALCULATION OF THE SIX-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,i4,icheck,ii,j,j4,k,l,ll,nd2,nn
      double precision am,cloc,cor,coro,dc,dd,dlo,xx
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commondl
      integer idummy(nn)
      character*6 chp(3),chd(3)
      dimension xx(6),dlo(6),cloc(6),dd(6),dc(6),am(nn,nn)
      integer nerror
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      nd2=2*ndimf
      write(lout,10010) nd2
      do l=1,nd2
        xx(l)=zero
        cloc(l)=zero
        dd(l)=zero
        dc(l)=zero
        dlo(l)=zero
        do i=1,nd2
          am(l,i)=zero
        enddo
      enddo
      chp(1)=' CLOX '
      chp(2)=' CLOY '
      chp(3)=' CLOS '
      chd(1)='  D-X '
      chd(2)='  D-Y '
      chd(3)='  D-S '
      cor=zero
      coro=1d38
      ii=0
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          cloc(ll-1)=clo6(l)
          cloc(ll)=clop6(l)
        enddo
        cloc(5)=clo6(3)
        cloc(6)=clop6(3)
        if(abs(dppoff).gt.pieni) cloc(6)=dppoff
      else
        do l=1,ndimf
          ll=2*l
          cloc(ll-1)=clo(l)
          cloc(ll)=clop(l)
        enddo
        do l=ndimf+1,3
          ll=2*l
          cloc(ll-1)=zero
          cloc(ll)=zero
        enddo
        cloc(6)=dps(1)
      endif
      do 80 ii=1,itco
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
+if debug
!       write(*,*) 'Calling UMLAUDA from clorda'
!       call warr('cloc5',cloc(5),0,0,0,0)
!       call warr('cloc6',cloc(6),0,0,0,0)
+ei
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
+if debug
!       call warr('ambef',am(i4,j4),i4,j4,0,0)
+ei
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
+if debug
!       do i4=1,nd2
!         do j4=1,nd2
!     call warr('amaft',am(i4,j4),i4,j4,0,0)
!         enddo
!       enddo
+ei
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dd(l)=cloc(l)-xx(l)
          dc(l)=abs(dd(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
+if debug
!       call warr('ddl',dd(l),l,1,0,0)
!       call warr('dcl',dc(l),l,1,0,0)
+ei
        enddo
        icheck=0
        do l=1,ndimf
          ll=2*l
          if(dc(ll-1).gt.dma) icheck=1
          if(dc(ll).gt.dmap) icheck=1
        enddo
        if(icheck.eq.0) goto 90
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
+if debug
!     call warr('corl ll',cor,l,ll,1,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,1,0)
+ei
          cor=cor+dc(ll-1)**2                                            !hr06
+if debug
!         call warr('acor',cor,l,ll,1,0)
+ei
        enddo
        cor=sqrt(cor)
+if debug
!       call warr('vital',0d0,ii,0,0,0)
!       call warr('corlll',cor,l,ll,1,0)
!       call warr('coro',coro,l,ll,1,0)
+ei
        if(ii.eq.1.or.cor.lt.coro) then
+if debug
!       call warr('cor',cor,2,0,0,0)
!       call warr('coro',coro,2,0,0,0)
+ei
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          if(ii.ne.itco) then
            write(lout,10030)
            do l=1,ndimf
              ll=2*l
              write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
            enddo
            write(lout,10080) ii,cor
          endif
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
 80   continue
      write(lout,10000) itco
      ii=itco
 90   continue
      if(ii.ne.itco) then
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
+if debug
!     call warr('corl ll',cor,l,ll,2,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,2,0)
+ei
          cor=cor+dc(ll-1)**2                                            !hr06
+if debug
!         call warr('acor',cor,l,ll,2,0)
+ei
        enddo
        cor=sqrt(cor)
+if debug
!       call warr('cor',cor,3,0,0,0)
!       call warr('coro',coro,3,0,0,0)
+ei
        if(cor.lt.coro) then
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          write(lout,10030)
          do l=1,ndimf
            ll=2*l
            write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
          enddo
          write(lout,10080) ii,cor
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dc(l)=abs(cloc(l)-xx(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
        enddo
      endif
      write(lout,10050) nd2,ii
      cor=zero
      do l=1,ndimf
        ll=2*l
        write(lout,10070) chp(l),cloc(ll-1),cloc(ll),
     &chd(l),dc(ll-1),dc(ll)
        cor=cor+dc(ll-1)**2                                              !hr06
      enddo
      cor=sqrt(cor)
      write(lout,10080) ii,cor
 91   continue
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          clo6(l)=cloc(ll-1)
          clop6(l)=cloc(ll)
        enddo
        clo6(3)=cloc(5)
        clop6(3)=cloc(6)
      else
        do l=1,ndimf
          ll=2*l
          clo(l)=cloc(ll-1)
          clop(l)=cloc(ll)
        enddo
      endif
+if debug
!     call warr('end clorda',cloc(1),1,0,0,0)
!     call warr('end cloc(2)',cloc(2),2,0,0,0)
!     call warr('end cloc(3)',cloc(3),3,0,0,0)
!     call warr('end cloc(4)',cloc(4),4,0,0,0)
!     call warr('end cloc(5)',cloc(5),5,0,0,0)
!     call warr('end cloc(6)',cloc(6),6,0,0,0)
!     call warr('clo(1)',clo(1),1,0,0,0)
!     call warr('clo(2)',clo(2),2,0,0,0)
!     call warr('clop(1)',clop(1),1,0,0,0)
!     call warr('clop(2)',clop(2),2,0,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
+ei
!-----------------------------------------------------------------------
      return
10000 format(t10,'DA CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-')/t10,'ENTERING ',i1,                              &
     &'-D DA CLOSED ORBIT CALCULATION'/)
10020 format(5x,'---- closed orbit before correction----')
10030 format(5x,'---- after DA correction----')
10040 format(/5x,'NO IMPROVEMENT OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10050 format(t5,'SUCCESSFULL END OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10060 format(5x,a6,1p,2(1x,g16.9))
10070 format(5x,a6,1p,2(1x,g16.9)/5x,a6,1p,2(1x,g16.9))
10080 format(5x,' ITERAT.=',i3,' ACCURACY=',d13.6/)
      end
+dk mydaini
      subroutine mydaini(ncase,nnord,nnvar,nndim,nnvar2,nnord1)
!-----------------------------------------------------------------------
!  CALCULATION OF THE 4-DIMENSIONAL CLOSED ORBIT INCLUDING DELTA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer idummy,ncase,ndimfo,ndpt,nis,nndim,                       &
     &nnord,nnord1,nnvar,nnvar2,nord1o,nordo,nvar2o,nvaro
      double precision am
+ca parpro
+ca commondl
+ca commonas
+ca commonc
      dimension am(6,6),idummy(6)
      save
!-----------------------------------------------------------------------
      if(nndim.lt.2.or.nndim.gt.3) call prror(95)
!--------------------
      nordo=nord
      nvaro=nvar
      ndimfo=ndimf
      nvar2o=nvar2
      nord1o=nord1
!--------------------
      nord=nnord
      nvar=nnvar
      ndimf=nndim
      nvar2=nnvar2
      nord1=nnord1
!--------------------
      ndpt=0
      nis=0
!--------------------
      call daeps(preda)
      call idprset(-102)
      call lieinit(nord,nvar,ndimf,ndpt,0,nis)
+if debug
!     call dumpbin('alieinit',1,11)
!     call abend('alieinit in mydaini                               ')
+ei
      write(lout,10000) nord,nvar,ndimf
      call daall(iscrda,100,'$$IS      ',nord,nvar)
!--closed orbit
+if debug
!     write(*,*) 'ncase=',ncase,' if 1 call clorda'
+ei
      if(ncase.eq.1) call clorda(2*ndimf,idummy,am)
+if debug
!     call dumpbin('aclorda',1,11)
!     call abend('aclorda                                           ')
+ei
!--tune variation
+if debug
!     write(*,*) 'ncase=',ncase,' if 2 call umlauda'
+ei
      if(ncase.eq.2) call umlauda
+if debug
!     if(ncase.eq.2) then
!     call dumpbin('aumlauda',7,77)
!     call abend('aumlauda                                          ')
!     endif
+ei
      iqmodc=0
      ichromc=0
      ilinc=0
      call dadal(iscrda,100)
!--------------------
      nord=nordo
      nvar=nvaro
      nvar2=nvar2o
      ndimf=ndimfo
      nord1=nord1o
!-----------------------------------------------------------------------
10000 format(/131('-')/10x,'DA INITIALIZATION: ORDER = ',i2,            &
     &', # of VARIABLES = ',i2,', DIMENSION = ',i2/)
      return
      end
+dk mydainf
      subroutine mydaini(ncase,nnord,nnvar,nndim,nnvar2,nnord1)
!-----------------------------------------------------------------------
!  CALCULATION OF THE 4-DIMENSIONAL CLOSED ORBIT INCLUDING DELTA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer idummy,ncase,ndimfo,ndpt,nis,nndim,                       &
     &nnord,nnord1,nnvar,nnvar2,nord1o,nordo,nvar2o,nvaro
      double precision am
+ca parpro
+ca commondl
+ca commonas
+ca commonc
      dimension am(6,6),idummy(6)
      save
!-----------------------------------------------------------------------
      if(nndim.lt.2.or.nndim.gt.3) call prror(95)
!--------------------
      nordo=nord
      nvaro=nvar
      ndimfo=ndimf
      nvar2o=nvar2
      nord1o=nord1
!--------------------
      nord=nnord
      nvar=nnvar
      ndimf=nndim
      nvar2=nnvar2
      nord1=nnord1
!--------------------
      ndpt=0
      nis=0
!--------------------
      call daeps(preda)
      call idprset(-102)
      call lieinit(nord,nvar,ndimf,ndpt,0,nis)
      write(lout,10000) nord,nvar,nndim
      call daall(iscrda,100,'$$IS      ',nord,nvar)
!--closed orbit
      if(ncase.eq.1) call clorda(2*ndimf,idummy,am)
!--tune variation
      if(ncase.eq.2) call umlauda
      rewind 18
!Eric
        rewind 111
!--main map calculation
      if(ncase.eq.3) call runda
!--%*6 map calculation
      if(ncase.eq.4) call runcav
      iqmodc=0
      ichromc=0
      ilinc=0
      call dadal(iscrda,100)
!--------------------
      nord=nordo
      nvar=nvaro
      nvar2=nvar2o
      ndimf=ndimfo
      nord1=nord1o
!-----------------------------------------------------------------------
10000 format(/131('-')/10x,'DA INITIALIZATION: ORDER = ',i2,            &
     &', # of VARIABLES = ',i2,', DIMENSION = ',i2/)
      return
      end
+dk clorb2
      subroutine clorb2(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT - NO WRITEOUT
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ierr,ii,l,ll
      double precision am,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,dy,x0,&
     &x1,y0,y1
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=1d6                                                        !hr06
        dy(l)=1d6                                                        !hr06
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) call prror(36)
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &return
        do 20 l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
   20   y0(l)=y(1,l)
        call matrix(dpp,am)
        if(ierro.ne.0) call prror(36)
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=two-am(ll-1,ll-1)-am(ll,ll)
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
!-----------------------------------------------------------------------
      return
      end
+dk combel
      subroutine combel(iql)
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ico,ico0,iql,j,m
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 20 j=1,icoe
        ico0=icomb0(j)
        if(iql.ne.ico0) goto 20
        do 10 m=1,20
          ico=icomb(j,m)
          if(ico.eq.0) goto 10
          if(kz(ico0).ne.kz(ico)) call prror(14)
          if(abs(el(ico0)).gt.pieni) then
            if(abs(el(ico)).gt.pieni) then
              ek(ico)=ek(ico0)*ratio(j,m)
            else
              ed(ico)=ek(ico0)*ratio(j,m)
            endif
          endif
          if(abs(el(ico0)).le.pieni) then
            if(abs(el(ico)).le.pieni) then
              ed(ico)=ed(ico0)*ratio(j,m)
            else
              ek(ico)=ed(ico0)*ratio(j,m)
            endif
          endif
   10   continue
   20 continue
!-----------------------------------------------------------------------
      return
      end
+dk envar
      subroutine envar(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ih,kz1,l,ll
      double precision afok,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1, &
     &hm,hp,hs,rho,rhoi,si,wf
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 200 i=1,il
        do ll=1,6
          do l=1,2
            a(i,l,ll)=zero
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 200
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          a(i,l,1)=one
          a(i,l,2)=el(i)
          a(i,l,3)=zero
   20   a(i,l,4)=one
        goto 200
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        a(i,ih,1)=one
        a(i,ih,2)=rho*si
        a(i,ih,3)=zero
        a(i,ih,4)=one
        a(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                             !hr06
+if crlibm
        a(i,ih,6)=((-1d0*two)*tan_rn(fok*half))/dpsq                     !hr06
+ei
+if .not.crlibm
        a(i,ih,6)=((-1d0*two)*tan(fok*half))/dpsq                        !hr06
+ei
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
+if crlibm
        g=tan_rn(fok*half)/rho
+ei
+if .not.crlibm
        g=tan(fok*half)/rho
+ei
        gl=el(i)*g
        a(i,ih,1)=one-gl
        a(i,ih,2)=el(i)
        a(i,ih,3)=(-1d0*g)*(two-gl)                                      !hr06
        a(i,ih,4)=a(i,ih,1)
        goto 200
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        a(i,ih,1)=co
        a(i,ih,2)=rho*si
        a(i,ih,3)=(-1d0*si)/rho                                          !hr06
        a(i,ih,4)=co
        a(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                             !hr06
        a(i,ih,6)=(-1d0*si)/dpsq                                         !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        a(i,ih,1)=one
        a(i,ih,2)=el(i)
        a(i,ih,3)=zero
        a(i,ih,4)=one
        goto 200
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(abs(fok))
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
+if crlibm
        a(i,ih,1)=cos_rn(fi)
+ei
+if .not.crlibm
        a(i,ih,1)=cos(fi)
+ei
+if crlibm
        hi1=sin_rn(fi)
+ei
+if .not.crlibm
        hi1=sin(fi)
+ei
        a(i,ih,2)=hi1/hi
        a(i,ih,3)=(-1d0*hi1)*hi                                          !hr06
        a(i,ih,4)=a(i,ih,1)
        if(ih.eq.2) goto 200
!--DEFOCUSSING
  110   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=hs/hi
        a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
        if(ih.eq.1) goto 100
        goto 200
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
        fok=fokq/dpd-wf**2                                               !hr06
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        a(i,ih,1)=co
        a(i,ih,2)=si/hi
        a(i,ih,3)=(-1d0*si)*hi                                           !hr06
        a(i,ih,4)=co
        a(i,ih,5)=(((-1d0*wf)/afok)*(one-co))/dpsq                       !hr06
        a(i,ih,6)=(((-1d0*wf)/hi)*si)/dpsq                               !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=el(i)
        if(abs(hi).le.pieni) goto 150
        a(i,ih,2)=hs/hi
  150   a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
        goto 200
!--DEFOCUSSING
  160   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        a(i,ih,1)=hc
        a(i,ih,2)=hs/hi
        a(i,ih,3)=hs*hi
        a(i,ih,4)=hc
        a(i,ih,5)= ((wf/afok)*(one-hc))/dpsq                             !hr06
        a(i,ih,6)=(((-1d0*wf)/hi)*hs)/dpsq                               !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        a(i,ih,1)=co
        a(i,ih,2)=si/hi
        a(i,ih,3)=(-1d0*si)*hi                                           !hr06
        a(i,ih,4)=co
        goto 200
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
        fokq=-1d0*ek(i)                                                  !hr06
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
+if crlibm
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr06
+ei
+if .not.crlibm
        fok=rhoi*tan((el(i)*rhoi)*half)                                  !hr06
+ei
        a(i,1,1)=one
        a(i,1,2)=zero
        a(i,1,3)=fok
        a(i,1,4)=one
        a(i,2,1)=one
        a(i,2,2)=zero
        a(i,2,3)=-1d0*fok                                                !hr06
        a(i,2,4)=one
        goto 200
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190   sm(i)=ed(i)
  200 continue
      call block
      return
      end
+dk envardis
      subroutine envardis(dpp,aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ih,kz1,l,ll
      double precision aeg,afok,bl1eg,bl2eg,co,dpd,dpp,dpsq,fi,fok,fokq,&
     &g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 190 i=1,il
        do ll=1,6
          do l=1,2
            aeg(i,l,ll)=zero
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 190
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do 20 l=1,2
          aeg(i,l,1)=one
          aeg(i,l,2)=el(i)
          aeg(i,l,3)=zero
   20   aeg(i,l,4)=one
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        aeg(i,ih,1)=one
        aeg(i,ih,2)=rho*si
        aeg(i,ih,3)=zero
        aeg(i,ih,4)=one
        aeg(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                           !hr06
+if crlibm
        aeg(i,ih,6)=((-1d0*two)*tan_rn(fok*half))/dpsq                   !hr06
+ei
+if .not.crlibm
        aeg(i,ih,6)=((-1d0*two)*tan(fok*half))/dpsq                      !hr06
+ei
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
+if crlibm
        g=tan_rn(fok*half)/rho
+ei
+if .not.crlibm
        g=tan(fok*half)/rho
+ei
        gl=el(i)*g
        aeg(i,ih,1)=one-gl
        aeg(i,ih,2)=el(i)
        aeg(i,ih,3)=(-1d0*g)*(two-gl)                                    !hr06
        aeg(i,ih,4)=aeg(i,ih,1)
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=el(i)*ed(i)/dpsq
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
+if crlibm
        si=sin_rn(fok)
+ei
+if .not.crlibm
        si=sin(fok)
+ei
+if crlibm
        co=cos_rn(fok)
+ei
+if .not.crlibm
        co=cos(fok)
+ei
        aeg(i,ih,1)=co
        aeg(i,ih,2)=rho*si
        aeg(i,ih,3)=(-1d0*si)/rho                                        !hr06
        aeg(i,ih,4)=co
        aeg(i,ih,5)=((-1d0*rho)*(one-co))/dpsq                           !hr06
        aeg(i,ih,6)=(-1d0*si)/dpsq                                       !hr06
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        aeg(i,ih,1)=one
        aeg(i,ih,2)=el(i)
        aeg(i,ih,3)=zero
        aeg(i,ih,4)=one
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(abs(fok))
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
+if crlibm
        aeg(i,ih,1)=cos_rn(fi)
+ei
+if .not.crlibm
        aeg(i,ih,1)=cos(fi)
+ei
+if crlibm
        hi1=sin_rn(fi)
+ei
+if .not.crlibm
        hi1=sin(fi)
+ei
        aeg(i,ih,2)=hi1/hi
        aeg(i,ih,3)=(-1d0*hi1)*hi                                        !hr06
        aeg(i,ih,4)=aeg(i,ih,1)
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  110   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=hs/hi
        aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
        if(ih.eq.1) goto 100
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
        fok=fokq/dpd-wf**2                                               !hr06
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        aeg(i,ih,1)=co
        aeg(i,ih,2)=si/hi
        aeg(i,ih,3)=(-1d0*si)*hi                                         !hr06
        aeg(i,ih,4)=co
        aeg(i,ih,5)=(((-1d0*wf)/afok)*(one-co))/dpsq                     !hr06
        aeg(i,ih,6)=(((-1d0*wf)/hi)*si)/dpsq                             !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=el(i)
        if(abs(hi).le.pieni) goto 150
        aeg(i,ih,2)=hs/hi
  150   aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
+if crlibm
        hp=exp_rn(fi)
+ei
+if .not.crlibm
        hp=exp(fi)
+ei
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        aeg(i,ih,1)=hc
        aeg(i,ih,2)=hs/hi
        aeg(i,ih,3)=hs*hi
        aeg(i,ih,4)=hc
        aeg(i,ih,5)= ((wf/afok)*(one-hc))/dpsq                           !hr06
        aeg(i,ih,6)=(((-1d0*wf)/hi)*hs)/dpsq                             !hr06
        ih=ih+1
        if(ih.gt.2) ih=1
        hi=sqrt(abs(ek(i)/dpd))
        fi=hi*el(i)
+if crlibm
        si=sin_rn(fi)
+ei
+if .not.crlibm
        si=sin(fi)
+ei
+if crlibm
        co=cos_rn(fi)
+ei
+if .not.crlibm
        co=cos(fi)
+ei
        aeg(i,ih,1)=co
        aeg(i,ih,2)=si/hi
        aeg(i,ih,3)=(-1d0*si)*hi                                         !hr06
        aeg(i,ih,4)=co
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
        fokq=-1d0*ek(i)                                                  !hr06
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
+if crlibm
        fok=rhoi*tan_rn((el(i)*rhoi)*half)                               !hr06
+ei
+if .not.crlibm
        fok=rhoi*tan((el(i)*rhoi)*half)                                  !hr06
+ei
        aeg(i,1,1)=one
        aeg(i,1,2)=zero
        aeg(i,1,3)=fok
        aeg(i,1,4)=one
        aeg(i,2,1)=one
        aeg(i,2,2)=zero
        aeg(i,2,3)=-1d0*fok
        aeg(i,2,4)=one
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
      call blockdis(aeg,bl1eg,bl2eg)
      return
      end
+dk error
      subroutine prror(ier)
!-----------------------------------------------------------------------
!  ERROR OUTPUT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ier
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      write(lout,10000)
      goto(10  ,20  ,30  ,40  ,50  ,60  ,70  ,80  ,90  ,100 , !1-10  
     &     110 ,120 ,130 ,140 ,150 ,160 ,170 ,180 ,190 ,200 , !11-20 
     &     210 ,220 ,230 ,240 ,250 ,260 ,270 ,280 ,290 ,300 , !21-30 
     &     310 ,320 ,330 ,340 ,350 ,360 ,370 ,380 ,390 ,400 , !31-40 
     &     410 ,420 ,430 ,440 ,450 ,460 ,470 ,480 ,490 ,500 , !41-50 
     &     510 ,520 ,530 ,540 ,550 ,560 ,570 ,580 ,590 ,600 , !51-60 
     &     610 ,620 ,630 ,640 ,650 ,660 ,670 ,680 ,690 ,700 , !61-70 
     &     710 ,720 ,730 ,740 ,750 ,760 ,770 ,780 ,790 ,800 , !71-80 
     &     810 ,820 ,830 ,840 ,850 ,860 ,870 ,880 ,890 ,900 , !81-90 
     &     910 ,920 ,930 ,940 ,950 ,960 ,970 ,980 ,990 ,1000, !91-100
     &     1010,1020,1030,1040,1050),ier
      goto 1870
   10 write(lout,10010)
      goto 1870
   20 write(lout,10020) nele
      goto 1870
   30 write(lout,10030)
      goto 1870
   40 write(lout,10040)
      goto 1870
   50 write(lout,10050)
      goto 1870
   60 write(lout,10060)
      goto 1870
   70 write(lout,10070)
      goto 1870
   80 write(lout,10080)
      goto 1870
   90 write(lout,10090)
      goto 1870
  100 write(lout,10100)
      goto 1870
  110 write(lout,10110)
      goto 1870
  120 write(lout,10120)
      goto 1870
  130 write(lout,10130)
      goto 1870
  140 write(lout,10140)
      goto 1870
  150 write(lout,10150)
      goto 1870
  160 write(lout,10160) nele
      goto 1870
  170 write(lout,10170) nper
      goto 1870
  180 write(lout,10180) nblo
      goto 1870
  190 write(lout,10190) erbez
      goto 1870
  200 write(lout,10200) erbez
      goto 1870
  210 write(lout,10210)
      goto 1870
  220 write(lout,10220)
      goto 1870
  230 write(lout,10230)
      goto 1870
  240 write(lout,10240)
      goto 1870
  250 write(lout,10250)
      goto 1870
  260 write(lout,10260) nelb
      goto 1870
  270 write(lout,10270)
      goto 1870
  280 write(lout,10280)
      goto 1870
  290 write(lout,10290)
      goto 1870
  300 write(lout,10300) nran
      goto 1870
  310 write(lout,10310)
      goto 1870
  320 write(lout,10320)
      goto 1870
  330 write(lout,10330)
      goto 1870
  340 write(lout,10340) mran
      goto 1870
  350 write(lout,10350)
      goto 1870
  360 write(lout,10360)
      goto 1870
  370 write(lout,10370)
      goto 1870
  380 write(lout,10380)
      goto 1870
  390 write(lout,10390)
      goto 1870
  400 write(lout,10400)
      goto 1870
  410 write(lout,10410)
      goto 1870
  420 write(lout,10420)
      goto 1870
  430 write(lout,10430) nzfz
      goto 1870
  440 write(lout,10440)
      goto 1870
  450 write(lout,10450)
      goto 1870
  460 write(lout,10460) nrco
      goto 1870
  470 write(lout,10470)
      goto 1870
  480 write(lout,10480)
      goto 1870
  490 write(lout,10490)
      goto 1870
  500 write(lout,10500)
      goto 1870
  510 write(lout,10510)
      goto 1870
  520 write(lout,10520) nema
      goto 1870
  530 write(lout,10530)
      goto 1870
  540 write(lout,10540) npart
      goto 1870
  550 write(lout,10550) nmac
      goto 1870
  560 write(lout,10560) ierro
      goto 1870
  570 write(lout,10570) ierro
      goto 1870
  580 write(lout,10580) ierro
      goto 1870
  590 write(lout,10590) ierro
      goto 1870
  600 write(lout,10600) ierro
      goto 1870
  610 write(lout,10610) ierro
      goto 1870
  620 write(lout,10620)
      goto 1870
  630 write(lout,10630)
      goto 1870
  640 write(lout,10640)
      goto 1870
  650 write(lout,10650) mcor
      goto 1870
  660 write(lout,10660)
      goto 1870
  670 write(lout,10670)
      goto 1870
  680 write(lout,10680)
      goto 1870
  690 write(lout,10690)
      goto 1870
  700 write(lout,10700)
      goto 1870
  710 write(lout,10710)
      goto 1870
  720 write(lout,10720)
      goto 1870
  730 write(lout,10730)
      goto 1870
  740 write(lout,10740)
      goto 1870
  750 write(lout,10750)
      goto 1870
  760 write(lout,10760)
      goto 1870
  770 write(lout,10770)
      goto 1870
  780 write(lout,10780)
      goto 1870
  790 write(lout,10790)
      goto 1870
  800 write(lout,10800)
      goto 1870
  810 write(lout,10810)
      goto 1870
  820 write(lout,10820)
      goto 1870
  830 write(lout,10830)
      goto 1870
  840 write(lout,10840)
      goto 1870
  850 write(lout,10850) mmul
      goto 1870
  860 write(lout,10860)
      goto 1870
  870 write(lout,10870)
      goto 1870
  880 write(lout,10880)
      goto 1870
  890 write(lout,10890)
      goto 1870
  900 write(lout,10900)
      goto 1870
  910 write(lout,10910)
      goto 1870
  920 write(lout,10920)
      goto 1870
  930 write(lout,10930)
      goto 1870
  940 write(lout,10940)
      goto 1870
  950 write(lout,10950)
      goto 1870
  960 write(lout,10960)
      goto 1870
  970 write(lout,10970)
      goto 1870
  980 write(lout,10980)
      goto 1870
  990 write(lout,10990)
      goto 1870
 1000 write(lout,11000) ntr
      goto 1870
 1010 write(lout,11010)
      goto 1870
 1020 write(lout,11020) nbb
      goto 1870
 1030 write(lout,11030)
      goto 1870
 1040 write(lout,11040)
      goto 1870
 1050 write(lout,11050) mmul

 1870 continue
!-----------------------------------------------------------------------
      call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10,  &
     &'RUN TERMINATED ABNORMALLY !!!'//)
10010 format(t10,'WRONG MODE DEFINITION')
10020 format(t10,'NOT MORE THAN: ',i4,' POSITIONS FOR RESONANCE-COMPEN',&
     &'SATION ALLOWED')
10030 format(t10,'ELEMENT FOR RESONANCE-COMPENSATION IS NOT IN THE ELE',&
     &'MENTLIST')
10040 format(t10,'UNSTABLE CLOSED ORBIT DURING INITIAL DISPERSION' ,    &
     &' CALCULATION'/ t10,                                              &
     &'INSTABILITY OCCURED FOR SMALL RELATIVE ENERGY DEVIATION')
10050 format(t10,'UNSTABLE CLOSED ORBIT FOR ZERO ENERGY DEVIATION')
10060 format(t10,'UNSTABLE CLOSED ORBIT DURING DISPERSION CALCULATION' ,&
     &' AFTER ORBIT SCALING'/ t10,                                      &
     &'INSTABILITY OCCURED FOR SMALL RELATIVE ENERGY DEVIATION')
10070 format(t10,'UNSTABLE CLOSED ORBIT AFTER ORBIT SCALING')
10080 format(t10,'ELEMENTS SPECIFIED FOR TUNE VARIATION ARE NOT' ,      &
     &' QUADRUPOLES')
10090 format(t10,'UNSTABLE CLOSED ORBIT DURING TUNE VARIATION')
10100 format(t10,'NO OPTICAL SOLUTION DURING TUNE VARIATION')
10110 format(t10,'ELEMENTS SPECIFIED FOR CHROMATICITY CORRECTION ARE' , &
     &' NOT SEXTUPOLES')
10120 format(t10,'UNSTABLE CLOSED ORBIT DURING CHROMATICITY CORRECTION')
10130 format(t10,'NO OPTICAL SOLUTION DURING CHROMATICITY CORRECTION')
10140 format(t10,'ELEMENTS OF DIFFERENT TYPES ARE COMBINED IN DATA' ,   &
     &' BLOCK COMBINATION OF ELEMENTS')
10150 format(t10,'UNKNOWN BLOCK SPECIFICATION')
10160 format(t10,'NO. OF SINGLE ELEMENTS EXCEEDS THE MAXIMUM ALLOWED' , &
     &' VALUE: ',i4)
10170 format(t10,'NO. OF SUPERPERIODS LARGER THAN : ',i4)
10180 format(t10,'NO. OF DIFFERENT BLOCKS EXCEEDS THE MAXIMUM ALLOWED' ,&
     &' VALUE: ',i5)
10190 format(t10,'UNKNOWN SINGLE ELEMENT : ',a16,                       &
     &' IN THE BLOCK DEFINITION')
10200 format(t10,'UNKNOWN BLOCK NAME OR INSERTION NAME : ',a16,' IN THE'&
     &,' STRUCTURE INPUT')
10210 format(t10,'MAXIMUM NUMBER OF STRUCTURE ELEMENTS SURPASSED')
10220 format(t10,'NO SOLUTION FOR ORBIT SCALING - POSSIBLE REASONS:'/   &
     &t10,'--> DIPOLE STRENGTHS OF NON-CORRECTOR ELEMENTS TO HIGH'/ t10,&
     &'--> NONLINEARITIES TOO STRONG, TRY TO INCREASE INITIAL'/ t10,    &
     &'    CORRECTOR STRENGTHS'/ t10,                                   &
     &'--> USE ALL DIPOLE ELEMENTS FOR SCALING'/)
10230 format(t10,'NO OPTICAL SOLUTION')
10240 format(t10,'NO SOLUTION FOR DISPERSION')
10250 format(t10,'--> PLEASE INCLUDE LENGTH OF MACHINE IN THE' ,        &
     &' <SYNCHROTRON>-BLOCK')
10260 format(t10,'ONE BLOCK CAN NOT HAVE MORE THAN ',i4,' ELEMENTS')
10270 format(t10,'KINETIC ENERGY OF THE PARTICLE IS LESS OR EQUAL ZERO')
10280 format(t10,'EITHER YOUR RF-FREQENCY IS SHIFTED BY 180 DEGREES'/ , &
     &t10,'THEN CHANGE THE SIGN OF <ITION> IN THE ',                    &
     &'<SYNCHROTRON>-INPUTBLOCK',/t10,'OR YOUR ALFA-P IS WRONGLY ',     &
     &'INTRODUCED IN THE SAME INPUTBLOCK')
10290 format(t10,'MULTIPOLECOEFFITIONS CANNOT BE SET EQUAL')
10300 format(t10,'THE RANDOM NUMBER: ',i6,' FOR THE INITIAL',           &
     &' STRUCTURE IS TOO SMALL')
10310 format(t10,'ELEMENTS THAT NEED RANDOM NUMBERS HAVE A KZ > 0')
10320 format(t10,'THERE ARE NOT ENOUGH RANDOM NUMBERS FOR THE INSERTED',&
     &' ELEMENTS')
10330 format(t10,'TO USE THE SAME RANDOMNUMBERS FOR 2 ELEMENTS, THE',   &
     &' INSERTED ELEMENT MUST NOT NEED MORE OF SUCH NUMBERS THAN THE',  &
     &' REFERENCE ELEMENT')
10340 format(t10,'NOT MORE THAN',i4,' OF EACH TYP OF INSERTED ELEMENTS',&
     &' CAN BE USED')
10350 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN QMOD')
10360 format(t10,'NO CONVERGENCE IN RMOD')
10370 format(t10,'CHOSEN ORDERS OF RESONANCES CAN NOT BE CALCULATED')
10380 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN RMOD')
10390 format(t10,'WITH THE SPECIFIED ELEMENTS THE RESONANCE CANNOT BE', &
     &' COMPENSATED - RESONANCEORDER AND ELEMENTTYP # MUST BE THE SAME')
10400 format(t10,'NOT MORE THAN 2 PARTICLES CAN BE TRACKED')
10410 format(t10,'GEOMETRY AND STRENGTH FILE (UNIT 2) IS EMPTY OR ' ,   &
     &' DISTROYED')
10420 format(t10,'TRACKING PARAMETER FILE (UNIT 3) IS EMPTY OR ' ,      &
     &' NONEXISTING')
10430 format(t10,'NOT MORE THAN ',i4,' RANDOM NUMBERS CAN BE USED')
10440 format(t10,'FOR THE INPUTBLOCK - ORBIT CORRECTION - ONLY CORRE',  &
     &'CTORS WITH THE KEYWORDS ( HCOR= ; VCOR= )'/t10,                  &
     &'AND MONITORS WITH THE', ' KEYWORDS ( HMON= ; VMON= ) ARE ALLOWED'&
     &)
10450 format(t10,'FOR THE INPUTBLOCK - LINEAR OPTICS - ONLY',           &
     &' THE KEYWORD ( ELEMENT ) AND ( BLOCK ) ARE ALLOWED')
10460 format(t10,'ORDER OF COMPENSATION CAN NOT BE LARGER THAN : ',i4)
10470 format(t10,'ONLY UP TO 3 RESONANCES CAN BE COMPENSATED')
10480 format(t10,'RESONANCE TYPE IS OUT OF THE RANGE OF THE RESONANCE', &
     &' ORDER')
10490 format(t10,'ONLY UP TO 3 SUBRESONANCES CAN BE COMPENSATED')
10500 format(t10,'THE MULTIPOLE ORDER FOR THE SUBRESONANCE COMPENSATION'&
     &,' SHOULD NOT EXCEED THE VALUE 9')
10510 format(t10,'PROBLEMS WITH FILE 3 WITH DYNAMIC KICKS')
10520 format(t10,'MAXIMUM ORDER OF THE ONE TURN MAP IS ',i4, /,         &
     &' NEMA HAS TO BE LARGER THAN NORD')
10530 format(t10,'# OF VARIABLES -NV- OF THE ONE TURN MAP IS NOT',      &
     &' IN THE ALLOWED RANGE [2 <= NV <= 5]')
10540 format(t10,'MAXIMUM NUMBER OF PARTICLES FOR VECTORIZATION', ' IS '&
     &,i7)
10550 format(t10,'MAXIMUM NUMBER OF DIFFERENT SEEDS FOR VECTORIZATION', &
     &' IS ',i4)
10560 format(t10,'PROBLEMS WITH FILE 13 WITH INITIAL COORDINATES ',     &
     &' - ERROR CODE : ',i10)
10570 format(t10,'PROBLEMS WITH FILE 2 WITH ACCELERATOR STRUCTURE ',    &
     &' - ERROR CODE : ',i10)
10580 format(t10,'PROBLEMS WITH FILE 3 WITH TRACKING PARAMETERS ',      &
     &' - ERROR CODE : ',i10)
10590 format(t10,'PROBLEMS WITH FILE 11 FOR CRAY INPUT ',               &
     &' - ERROR CODE : ',i10)
10600 format(t10,'PROBLEMS WITH FILE 99 FOR BINARY OUTPUT ',            &
     &' - ERROR CODE : ',i10)
10610 format(t10,'PROBLEMS WITH FILE 12 FOR END COORDINATES',           &
     &' - ERROR CODE : ',i10)
10620 format(t10,'ELEMENTS SPECIFIED FOR DECOUPLING ARE NOT' ,          &
     &' SKEW QUADRUPOLES')
10630 format(t10,'THERE ARE THE APPROPRIATE ELEMENTS FOR' ,             &
     &' THE DECOUPLING OR SIMULTANEOUS TUNE ADJUSTMENT')
10640 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN DECOUP')
10650 format(t10,'MAXIMUM NUMBER OF EXTRA PARAMETERS IS : ',i4)
10660 format(t10,'EXTRA PARAMETERS FOR THE MAP DOES NOT EXIST')
10670 format(t10,'ONLY SINGLE KICK ELEMENTS ALLOWED FOR MAP CALCULATION'&
     &)
10680 format(t10,'THE ORDER OF THE NORMAL FORM IS TOO HIGH. CHECK THE' ,&
     &' DIFFERENTIAL ALGEBRA PARAMETERS')
10690 format(t10,'TOO MANY VARIABLES SPECIFIED. CHECK THE DIFFERENTIAL' &
     &,' ALGEBRA PARAMETERS')
10700 format(t10,'NO CORRECTORS SPECIFIED')
10710 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE ZERO!')
10720 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE DIFFERENT FROM',&
     &' ZERO!')
10730 format(t10,'AMPLITUDE ORDER OUTSIDE RANGE [0,2]')
10740 format(t10,'MOMENTUM ORDER OUTSIDE RANGE [0,3] (ONE EXCLUDED!)')
10750 format(t10,'MINIMUM ORDER OUTSIDE RANGE [2,3]')
10760 format(t10,'MINIMUM ORDER GREATER THAN MAXIMUM!')
10770 format(t10,'MAXIMUM ORDER OUTSIDE RANGE [2,3]')
10780 format(t10,'NORMAL FORMS ANALYSIS IMPOSSIBLE',/ ,t10,             &
     &'THE TRANSFER MAP DOES NOT EXIST!')
10790 format(t10,'ZERO OR NEGATIVE ENERGY DOES NOT MAKE MUCH SENSE')
10800 format(t10,'PROBLEM READING EXTERNAL MULTIPOLE ERRORS')
10810 format(t10,'TOO MANY ELEMENTS FOR LINEAR OPTICS WRITE-OUT')
10820 format(t10,'FOR CLOSED ORBIT CORRECTORS ONLY DIPOLES OF LEGTH',   &
     &' ZERO OR MULTIPOLE LENSES ALLOWED')
10830 format(t10,'AN ELEMENT FOR CLOSED ORBIT CORRECTION CAN BE ONLY',  &
     &' EITHER A HORIZONTAL MONITOR',/,t10, 'OR A VERTICAL MONITOR OR', &
     &' A HORIZONTAL CORRECTOR OR A VERTICAL CORRECTOR')
10840 format(t10,'NUMBER OF ORBIT CORRECTORS IS ZERO')
10850 format(t10,'THE ORDER OF MULTIPOLES MMUL: ',i4,' HAS TO BE LARGER'&
     &,' THAN 10 BUT SMALLER THAN 20')
10860 format(t10,'PROBLEM READING EXTERNAL MISALIGNMENTS')
10870 format(t10,'PROBLEM READING FROM FILE 30 (SINGLE KICKS AND ',     &
     &'MISALIGNMENTS')
10880 format(t10,'BEAM_BEAM: EITHER NORMALIZED EMITTANCES OR THE ',     &
     &'RESULTING SIGMA VALUES EQUAL TO ZERO')
10890 format(t10,'BEAM_BEAM: AT EACH INTERACTION POINT THE BEAM ',      &
     &'MUST BE EITHER ROUND OR ELLIPTICAL FOR ALL PARTICLES')
10900 format(t10,'QUADRUPOLES ARE NOT SUITED TO ADJUST THE TUNES')
10910 format(t10,'ORDER AND NUMBER OF VARIABLES HAVE TO BE LARGER ',    &
     &'THAN ZERO TO CALCULATE A DIFFERENTIAL ALGEBRA MAP')
10920 format(t10,'YOU CANNOT COMBINE AN ELEMENT WITH ITSELF')
10930 format(t10,'INVERTED LINEAR BLOCKS NOT ALLOWED')
10940 format(t10,'  NUMBER OF NORMAL FORM VARIABLES HAVE TO BE: ',      &
     &'2, 4, 5, 6 + PARAMETERS')
10950 format(t10,'  DA CORRECTIONS IMPLEMENTED FOR 4-D AND 6-D ONLY ')
10960 format(t10,'SEXTUPOLES ARE NOT SUITED TO ADJUST THE CHROMATICITY')
10970 format(t10,'UNSTABLE CLOSED ORBIT IN DA CALCULATION')
10980 format(t10,'TROMBONE ELEMENT NOT IN LIST OF SINGLE ELEMENTS')
10990 format(t10,'INCOMPLETE PARAMETERS FOR TROMBONE ELEMENT')
11000 format(t10,'MAXIMUM NUMBER OF TROMBONES EXCEEDED : NTR = ',i4)
11010 format(t10,'AMPLITUDES EXCEED THE MAXIMUM VALUES IN UMLAUF')
11020 format(t10,'MAXIMUM ELEMENT NUMBER FOR BEAM_BEAM WITH COUPLING ', &
     &'EXCEEDED:  NBB = ',i4)
11030 format(t10,'6D BEAM-BEAM WITH TILT NOT POSSIBLE')
11040 format(t10,'SINGLE ELEMENT NAME LONGER THAN 16 CHARACTERS')
11050 format(t10,'THE INPUT ORDER OF MULTIPOLES IS LARGER THAN THE ',   &
     &'MAXIMUM ALLOWED ORDER MMUL: ',i4)
      end
+dk dynkancil

      subroutine dynk_parseFUN( getfields_fields,
     &                          getfields_lfields,getfields_nfields )
!
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 30-10-2014
!     parse FUN lines in the fort.3 input file, 
!     store it in COMMON block dynkComExpr.
!-----------------------------------------------------------------------
!     
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
+ca comgetfields
+ca crcoall

      intent(in) getfields_fields, getfields_lfields, getfields_nfields
      
      ! Temp variables
      integer ii, stat, t
      double precision x,y,z,u,           ! FILE, FILELIN, FIR/IIR
     &                 x1,x2,y1,y2,deriv, ! LINSEG, QUADSEG,
     &                 tinj,Iinj,Inom,A,D,R,te,                 !PELP (input)
     &                 derivI_te,I_te,bexp,aexp, t1,I1, td,tnom !PELP (calc)
      
      logical isFIR ! FIR/IIR
      
      ! define function return type
      integer dynk_findFUNindex
      
      logical lopen

+if crlibm
      integer nchars
      parameter (nchars=160) !Same as in daten
      character*(nchars) ch
      
      character filefields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
      integer filefields_nfields
      integer filefields_lfields( getfields_n_max_fields )
      logical filefields_lerr
      
      double precision round_near
      integer errno
+ei

+if fio
! Do not support FIO, it is not supported by any compilers.
      write (lout,*) "FIO not supported in DYNK!"
      call prror(-1)
+ei
      
      if (nfuncs_dynk+1 .gt. maxfuncs_dynk) then
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "Maximum number of FUN exceeded, please" //
     &        "parameter maxfuncs_dynk."
         write (lout,*) "Current value of maxfuncs_dynk:",maxfuncs_dynk
         call prror(51)
      endif
      
      if (getfields_lfields(2).gt.maxstrlen_dynk-1) then
         write(lout,*) "ERROR in DYNK block parsing (fort.3):"
         write(lout,*) "Max length of a FUN name is", maxstrlen_dynk-1
         write(lout,*) "Offending FUN: '"//
     &        getfields_fields(2)(1:getfields_lfields(2))//"'"
         write(lout,*) "length:", getfields_lfields(2)
         call prror(51)
      endif
      
      ! ! ! ! ! ! ! ! ! ! ! ! ! !
      ! Which type of function? !
      ! ! ! ! ! ! ! ! ! ! ! ! ! !

      !!! System functions: #0-19 !!!
      select case ( getfields_fields(3)(1:getfields_lfields(3)) )
      case ("GET")
         ! GET: Store the value of an element/value

         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname GET elementName attribute" )
         call dynk_checkspace(0,1,3)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 0           !TYPE (GET)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3

         !Sanity checks
         if (getfields_lfields(4) .gt. 16 .or.   ! length of BEZ elements
     &       getfields_lfields(4) .gt. maxstrlen_dynk-1 ) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN GET got an element name with     "
            write (lout,*) "length =", getfields_lfields(4), "> 16"
            write (lout,*) "or > ",maxstrlen_dynk-1
            write (lout,*) "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (lout,*) "*************************************"
            call prror(51)
         end if
         if (getfields_lfields(5) .gt. maxstrlen_dynk-1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN GET got an attribute name with   "
            write (lout,*) "length =", getfields_lfields(5)
            write (lout,*) "> ",maxstrlen_dynk-1
            write (lout,*) "The name was: '",getfields_fields(5)
     &                                    (1:getfields_lfields(5)),"'"
            write (lout,*) "*************************************"
            call prror(51)
         endif

         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !ELEMENT_NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         cexpr_dynk(ncexpr_dynk+2)(1:getfields_lfields(5)) = !ATTRIBUTE_NAME
     &        getfields_fields(5)(1:getfields_lfields(5))
         ncexpr_dynk = ncexpr_dynk+2
         
         fexpr_dynk(nfexpr_dynk) = -1.0 !Initialize a place in the array to store the value

      case ("FILE")
         ! FILE: Load the contents from a file
         ! File format: two ASCII columns of numbers,
         ! first  column = turn number (all turns should be there, starting from 1)
         ! second column = value (as a double)

         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname FILE filename" )
         call dynk_checkspace(0,0,2)
         
         ! Set pointers to start of funs data blocks (nfexpr_dynk handled when reading data)
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 1             !TYPE (FILE)
         funcs_dynk(nfuncs_dynk,3) = ncexpr_dynk+1 !Filename (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk+1 !Data     (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1            !Below: Length of file

         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN FILE got a filename name with   "
            write (lout,*) "length =", getfields_lfields(4)
            write (lout,*) "> ",maxstrlen_dynk-1
            write (lout,*) "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (lout,*) "*************************************"
            call prror(51)
         endif

         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !FILE NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         ncexpr_dynk = ncexpr_dynk+1
         
         !Open the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(lout,*)"DYNK> **** ERROR in dynk_parseFUN():FILE ****"
            write(lout,*)"DYNK> unit 664 for file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //
     &           "' was already taken"
            call prror(-1)
         end if
         
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(lout,*) "DYNK> dynk_parseFUN():FILE"
            write(lout,*) "DYNK> Error opening file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
            call prror(51)
         endif

         ii = 0 !Number of data lines read
         do
+if .not.crlibm
            read(664,*, iostat=stat) t,y
            if (stat .ne. 0) exit !EOF
+ei
+if crlibm
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) exit !EOF
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILE"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> Error in getfields_split"
               call prror(-1)
            end if

            if ( filefields_nfields  .ne. 2 ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILE"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
               call prror(-1)
            end if

            read(filefields_fields(1)(1:filefields_lfields(1)),*) t
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)
+ei
!            write(*,*) "DBGDBG: t,y = ",t,y

            ii = ii+1
            if (t .ne. ii) then
               write(lout,*) "DYNK> dynk_parseFUN():FILE"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> Missing turn number", ii,
     &              ", got turn", t
               call prror(51)
            endif
            if (nfexpr_dynk+1 .gt. maxdata_dynk) then
               write(lout,*) "DYNK> dynk_parseFUN():FILE"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> Ran out of memory in fexpr_dynk ",
     &              "in turn", t
               write(lout,*) "DYNK> Please increase maxdata_dynk."
               call prror(51)
            endif
            
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = y
         enddo
         funcs_dynk(nfuncs_dynk,5) = ii
         
         close(664)

      case ("FILELIN")
         ! FILELIN: Load the contents from a file, linearly interpolate
         ! File format: two ASCII columns of numbers,
         ! first  column = turn number (as a double)
         ! second column = value (as a double)

         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname FILELIN filename" )
         call dynk_checkspace(0,0,2)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 2             !TYPE (FILELIN)
         funcs_dynk(nfuncs_dynk,3) = ncexpr_dynk+1 !Filename (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk+1 !Data     (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1            !Below: Length of file (number of x,y sets)
         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN FILELIN got a filename name with   "
            write (lout,*) "length =", getfields_lfields(4)
            write (lout,*) "> ",maxstrlen_dynk-1
            write (lout,*) "The name was: '",getfields_fields(4)
     &                                    (1:getfields_lfields(4)),"'"
            write (lout,*) "*************************************"
            call prror(51)
         endif
         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !FILE NAME
     &        getfields_fields(4)(1:getfields_lfields(4))
         ncexpr_dynk = ncexpr_dynk+1
         
         !Open the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(lout,*)
     &           "DYNK> **** ERROR in dynk_parseFUN():FILELIN ****"
            write(lout,*)"DYNK> unit 664 for file '"//
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //
     &           "' was already taken"
            call prror(-1)
         end if
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat,status='OLD')
         if (stat .ne. 0) then
            write(lout,*) "DYNK> dynk_parseFUN():FILELIN"
            write(lout,*) "DYNK> Error opening file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //  "'"
            call prror(51)
         endif
         ! Find the size of the file
         ii = 0 !Number of data lines read
         do
+if .not.crlibm
            read(664,*, iostat=stat) x,y
            if (stat .ne. 0) exit !EOF
+ei
+if crlibm
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) exit !EOF
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILELIN"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //"'"
               write(lout,*) "DYNK> Error in getfields_split"
               call prror(-1)
            end if
            
            if ( filefields_nfields  .ne. 2 ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILELIN"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
               call prror(-1)
            end if

            x = round_near(errno, filefields_lfields(1)+1,
     &           filefields_fields(1) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,1,x)
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
            
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)(1:filefields_lfields(1))
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)(1:filefields_lfields(2))
+ei
!            write(*,*) "DBGDBG: x,y = ",x,y
            
            if (ii.gt.0 .and. x.le. x2) then !Insane: Decreasing x
               write (lout,*) "DYNK> dynk_parseFUN():FILELIN"
               write (lout,*) "DYNK> Error while reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write (lout,*) "DYNK> x values must "//
     &              "be in increasing order"
               call prror(-1)
            endif
            x2 = x
            
            ii = ii+1
         enddo
         t = ii
         rewind(664)
         
         if (nfexpr_dynk+2*t .gt. maxdata_dynk) then
            write (lout,*) "DYNK> dynk_parseFUN():FILELIN"
            write (lout,*) "DYNK> Error reading file '"//
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
            write (lout,*) "DYNK> Not enough space in fexpr_dynk,"//
     &           " need", 2*t
            write (lout,*) "DYNK> Please increase maxdata_dynk"
            call prror(51)
         endif

         !Read the file
         ii = 0
         do
+if .not.crlibm
            read(664,*, iostat=stat) x,y
            if (stat .ne. 0) then !EOF
               if (ii .ne. t) then
                  write (lout,*)"DYNK> dynk_parseFUN():FILELIN"
                  write (lout,*)"DYNK> Unexpected when reading file '"//
     &                trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
                  write (lout,*)"DYNK> ii=",ii,"t=",t
                  call prror(51)
               endif
               exit
            endif
+ei
+if crlibm
            read(664,'(a)', iostat=stat) ch
            if (stat .ne. 0) then !EOF
               if (ii .ne. t) then
                  write (lout,*)"DYNK> dynk_parseFUN():FILELIN"
                  write (lout,*)"DYNK> Unexpected when reading file '"//
     &                trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
                  write (lout,*) "DYNK> ii=",ii,"t=",t
                  call prror(51)
               endif
               exit
            endif
            
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            if ( filefields_lerr ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILELIN"
               write(lout,*) "DYNK> Error reading file '"//
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
               write(lout,*) "DYNK> Error in getfields_split"
               call prror(-1)
            end if
            
            if ( filefields_nfields  .ne. 2 ) then
               write(lout,*) "DYNK> dynk_parseFUN():FILELIN"
               write(lout,*) "DYNK> Error reading file '"//
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
               write(lout,*) "DYNK> expected 2 fields, got",
     &              filefields_nfields, "ch =",ch
              call prror(-1)
            end if

            x = round_near(errno, filefields_lfields(1)+1,
     &           filefields_fields(1) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,1,x)
            y = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,y)
!            write(*,*) "DBGDBG: ch=",ch
!            write(*,*) "DBGDBG: filefields_fields(1)=",
!     &           filefields_fields(1)
!            write(*,*) "DBGDBG: filefields_fields(2)=",
!     &           filefields_fields(2)
+ei
!            write(*,*) "DBGDBG: x,y = ",x,y

            !Current line number
            ii = ii+1
            
            fexpr_dynk(nfexpr_dynk + ii    ) = x
            fexpr_dynk(nfexpr_dynk + ii + t) = y
         enddo
         
         nfexpr_dynk = nfexpr_dynk + 2*t
         funcs_dynk(nfuncs_dynk,5) = t
         close(664)
         
      case ("PIPE")
         ! PIPE: Use a pair of UNIX FIFOs.
         ! Another program is expected to hook onto the other end of the pipe,
         ! and will recieve a message when SixTrack's dynk_computeFUN() is called.
         ! That program should then send a value back (in ASCII), which will be the new setting.
         
         call dynk_checkargs(getfields_nfields,7,
     &        "FUN funname PIPE inPipeName outPipeName ID fileUnit" )
         call dynk_checkspace(1,0,4)
         
+if cr
         write(lout,*) "DYNK FUN PIPE not supported in CR version"
         write(lout,*) "Sorry :("
         call prror(-1)
+ei
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 3             !TYPE (PIPE)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk   !UnitNR (set below)
         funcs_dynk(nfuncs_dynk,4) = -1            !Not used
         funcs_dynk(nfuncs_dynk,5) = -1            !Not used
         
         !Sanity checks
         if (getfields_lfields(4) .gt. maxstrlen_dynk-1 .or.
     &       getfields_lfields(5) .gt. maxstrlen_dynk-1 .or.
     &       getfields_lfields(6) .gt. maxstrlen_dynk-1      ) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN PIPE got one or more strings which "
            write (lout,*) "was too long (>",maxstrlen_dynk-1,")"
            write (lout,*) "Strings: '",
     &           getfields_fields(4)(1:getfields_lfields(4)),"' and '",
     &           getfields_fields(5)(1:getfields_lfields(5)),"' and '",
     &           getfields_fields(6)(1:getfields_lfields(6)),"'."
            write (lout,*) "lengths =",
     &           getfields_lfields(4),", ",
     &           getfields_lfields(5)," and ",
     &           getfields_lfields(6)
            write (lout,*) "*************************************"
            call prror(51)
         endif

         ! Store data
         cexpr_dynk(ncexpr_dynk  )(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         cexpr_dynk(ncexpr_dynk+1)(1:getfields_lfields(4)) = !inPipe
     &        getfields_fields(4)(1:getfields_lfields(4))
         cexpr_dynk(ncexpr_dynk+2)(1:getfields_lfields(5)) = !outPipe
     &        getfields_fields(5)(1:getfields_lfields(5))
         cexpr_dynk(ncexpr_dynk+3)(1:getfields_lfields(6)) = !ID
     &        getfields_fields(6)(1:getfields_lfields(6))
         ncexpr_dynk = ncexpr_dynk+3
         
         read(getfields_fields(7)(1:getfields_lfields(7)),*) !fileUnit
     &        iexpr_dynk(niexpr_dynk)
         
         ! Look if the fileUnit or filenames are used in a different FUN PIPE
         t=0 !Used to hold the index of the other pipe; t=0 if no older pipe -> open files.
         do ii=1,nfuncs_dynk-1
            if (funcs_dynk(ii,2) .eq. 3) then !It's a PIPE
               !Does any of the settings match?
               if ( iexpr_dynk(funcs_dynk(ii,3)).eq.      !Unit number
     &              iexpr_dynk(niexpr_dynk)           .or.
     &              cexpr_dynk(funcs_dynk(ii,1)+1).eq.    !InPipe filename
     &              cexpr_dynk(ncexpr_dynk-2)         .or.
     &              cexpr_dynk(funcs_dynk(ii,1)+2).eq.    !OutPipe filename
     &              cexpr_dynk(ncexpr_dynk-1)         ) then
                  !Does *all* of the settings match?
                  if ( iexpr_dynk(funcs_dynk(ii,3)).eq.   !Unit number
     &                 iexpr_dynk(niexpr_dynk)           .and.
     &                 cexpr_dynk(funcs_dynk(ii,1)+1).eq. !InPipe filename
     &                 cexpr_dynk(ncexpr_dynk-2)         .and.
     &                 cexpr_dynk(funcs_dynk(ii,1)+2).eq. !OutPipe filename
     &                 cexpr_dynk(ncexpr_dynk-1)         ) then
                     t=ii
                     write(lout,*) "DYNK> "//
     &                    "PIPE FUN '" //
     & trim(stringzerotrim(cexpr_dynk(funcs_dynk(nfuncs_dynk,1)))) //
     & "' using same settings as previously defined FUN '"   //
     & trim(stringzerotrim(cexpr_dynk(funcs_dynk(ii,1)))) //
     & "' -> reusing files !"
                     if (cexpr_dynk(funcs_dynk(ii,1)+3).eq. !ID
     &                   cexpr_dynk(ncexpr_dynk)           ) then
                        write(lout,*) "DYNK> "//
     &               "ERROR: IDs must be different when sharing PIPEs."
                        call prror(-1)
                     endif
                     exit !break loop
                  else !Partial match
      ! Nested too deep, sorry about crappy alignment...
      write(lout,*) "DYNK> *** Error in dynk_parseFUN():PIPE ***"
      write(lout,*) "DYNK> Partial match of inPipe/outPipe/unit number"
      write(lout,*) "DYNK> between PIPE FUN '"               //
     &     trim(stringzerotrim(cexpr_dynk(funcs_dynk(nfuncs_dynk,1))))//
     &     "' and '" //
     &     trim(stringzerotrim(cexpr_dynk(funcs_dynk(ii,1)))) // "'"
                     call prror(-1)
                  endif
               endif
            endif
         end do

         if (t.eq.0) then !Must open a new set of files
         ! Open the inPipe
         inquire( unit=iexpr_dynk(niexpr_dynk), opened=lopen )
         if (lopen) then
            write(lout,*)"DYNK> **** ERROR in dynk_parseFUN():PIPE ****"
            write(lout,*)"DYNK> unit",iexpr_dynk(niexpr_dynk),
     &           "for file '"//
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-2)))
     &           //"' was already taken"

            call prror(-1)
         end if
         
         write(lout,*) "DYNK> Opening input pipe '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-2)))//"' for FUN '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-3)))//"', ID='"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk)))//"'"

         open(unit=iexpr_dynk(niexpr_dynk),
     &        file=cexpr_dynk(ncexpr_dynk-2),action='read',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(lout,*) "DYNK> dynk_parseFUN():PIPE"
            write(lout,*) "DYNK> Error opening file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-2))) //
     &           "' stat=",stat
            call prror(51)
         endif

         ! Open the outPipe
         write(lout,*) "DYNK> Opening output pipe '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-1)))//"' for FUN '"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk-3)))//"', ID='"//
     &trim(stringzerotrim(
     &cexpr_dynk(ncexpr_dynk)))//"'"

         inquire( unit=iexpr_dynk(niexpr_dynk)+1, opened=lopen )
         if (lopen) then
            write(lout,*)"DYNK> **** ERROR in dynk_parseFUN():PIPE ****"
            write(lout,*)"DYNK> unit",iexpr_dynk(niexpr_dynk)+1,
     &           "for file '"//
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-1)))
     &           //"' was already taken"

            call prror(-1)
         end if
         
         open(unit=iexpr_dynk(niexpr_dynk)+1,
     &        file=cexpr_dynk(ncexpr_dynk-1),action='write',
     &        iostat=stat,status="OLD")
         if (stat .ne. 0) then
            write(lout,*) "DYNK> dynk_parseFUN():PIPE"
            write(lout,*) "DYNK> Error opening file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-1))) //
     &           "' stat=",stat
            call prror(51)
         endif
         write(iexpr_dynk(niexpr_dynk)+1,'(a)')
     &        "DYNKPIPE !******************!" !Once per file
         endif !End "if (t.eq.0)"/must open new files
         write(iexpr_dynk(niexpr_dynk)+1,'(a)') !Once per ID
     &        "INIT ID="//
     &        trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))
     &        //" for FUN="//
     &        trim(stringzerotrim(cexpr_dynk(ncexpr_dynk-3)))
         
         
      case ("RANDG")
         ! RANDG: Gausian random number with mu, sigma, and optional cutoff
         
         call dynk_checkargs(getfields_nfields,8,
     &        "FUN funname RANDG seed1 seed2 mu sigma cut" )
         call dynk_checkspace(5,2,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 6           !TYPE (RANDG)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk !seed1(initial), seed2(initial), mcut, seed1(current), seed2(current) (in iexpr_dynk)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk !mu, sigma (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk) ! seed1 (initial)
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        iexpr_dynk(niexpr_dynk+1) ! seed2 (initial)
+if .not.crlibm
         read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &        fexpr_dynk(nfexpr_dynk) ! mu
         read(getfields_fields(7)(1:getfields_lfields(7)),*)
     &        fexpr_dynk(nfexpr_dynk+1) ! sigma
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! mu
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk)  )

         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! sigma
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7,
     &                       fexpr_dynk(nfexpr_dynk+1) )
+ei
         read(getfields_fields(8)(1:getfields_lfields(8)),*)
     &        iexpr_dynk(niexpr_dynk+2) ! mcut

         iexpr_dynk(niexpr_dynk+3) = 0 ! seed1 (current)
         iexpr_dynk(niexpr_dynk+4) = 0 ! seed2 (current)

         niexpr_dynk = niexpr_dynk+4
         nfexpr_dynk = nfexpr_dynk+1

         if (iexpr_dynk(funcs_dynk(nfuncs_dynk,3)+2) .lt. 0) then
            !mcut < 0
            write (lout,*) "DYNK> dynk_parseFUN():RANDG"
            write (lout,*) "DYNK> ERROR in DYNK block parsing (fort.3)"
            write (lout,*) "DYNK> mcut must be >= 0"
            call prror(51)
         endif
         
      case ("RANDU")
         ! RANDU: Uniform random number
         
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname RANDU seed1 seed2" )
         call dynk_checkspace(4,0,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 7           !TYPE (RANDU)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk !seed1(initial), seed2(initial), seed1(current), seed2(current)
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk) ! seed1 (initial)
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        iexpr_dynk(niexpr_dynk+1) ! seed2 (initial)

         iexpr_dynk(niexpr_dynk+2) = 0 ! seed1 (current)
         iexpr_dynk(niexpr_dynk+3) = 0 ! seed2 (current)

         niexpr_dynk = niexpr_dynk+3

      case("RANDON")
         ! RANDON: Turn by turn ON for one turn with the probability P, else OFF
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname RANDON seed1 seed2 P" )
         call dynk_checkspace(4,1,1)
	          
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         niexpr_dynk = niexpr_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1

         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 8           !TYPE (RANDON)
         funcs_dynk(nfuncs_dynk,3) = niexpr_dynk !seed1(initial), seed2(initial), seed1(current), seed2(current)
         funcs_dynk(nfuncs_dynk,4) = nfexpr_dynk !P (in fexpr_dynk)
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG2 (unused)
         
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk)   ! seed1 (initial)
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        iexpr_dynk(niexpr_dynk+1) ! seed2 (initial)
         read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &        fexpr_dynk(nfexpr_dynk)   ! P

         iexpr_dynk(niexpr_dynk+2) = 0 ! seed1 (current)
         iexpr_dynk(niexpr_dynk+3) = 0 ! seed2 (current)

         niexpr_dynk = niexpr_dynk+3         
         
      case("FIR","IIR")
         ! FIR: Finite Impulse Response filter
         ! y[n] = \sum_{i=0}^N b_i*x[n-i]
         ! where N is the order of the filter, x[] is the results from
         ! previous calls to the input function, and b_i is a set of coefficients.
         ! The coefficients are loaded from an ASCII file, formatted with three columns,
         ! the first one being the index 0...N, the second being the coefficients b_0...b_N,
         ! and the third one being the initial values of x[n]..x[n-N].
         ! When running, the values x[n]...x[n-N] are the N last results from calling baseFUN.
         ! Note that this means that at the first call, x[n-0] is pushed into x[n-1] etc.,
         ! and x[n-N] is deleted; i.e. the initial x[n-N] is never used.
         !
         ! Format in fexpr_dynk:
         ! b_0 <- funcs_dynk(<this>,3)
         ! x[n]
         ! x_init[n] (holds the x[n]s from the input file, used to reset the FIR at the first turn)
         ! b_1
         ! x[n-1]
         ! x_init[n-1]
         ! (etc., repeat funcs_dynk(<this>,4)+1 times)
         !
         ! IIR: Infinite Impulse Response filter
         ! y[n] = \sum_{i=0}^N b_i*x[n-i] \sum_{i=1}^M a_i*y[i-n]
         ! where N=M. This is the same as FIR, except that it also uses
         ! previous values of it's own output.
         ! The input file is also identical, except adding two extra columns:
         ! One for the coefficients a_0...a_N, and one for the
         ! initial values of y[n]...y[n-N]. For both these columns,
         ! the first row (a_0 and y[n]) are ignored.
         ! For the first of these columns, the first value (a_0) is ignored and never used,
         ! while y[n-0] is pushed into y[n-1] at the first evaluation,
         ! such that the initial x[n-N] is never used (just like for x[n-N]).
         ! 
         ! Format in fexpr_dynk:
         ! b_0 <- funcs_dynk(<this>,3)
         ! x[n]
         ! x_init[n]
         ! a_0  (a_0 is never used)
         ! y[n] (zeroed for computation, used to hold previously returned value)
         ! y_init[n] (holds the y[n]s from the input file, used to reset the FIR at the first turn)
         ! b_1
         ! x[n-1]
         ! x_init[n-1]
         ! a_1
         ! y[n-1]
         ! y_init[n-1]
         ! (etc., repeat funcs_dynk(<this>,4) times)


         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname {FIR|IIR} N filename baseFUN")
         select case( getfields_fields(3)(1:getfields_lfields(3)) )
         case("FIR")
            isFIR = .true.
         case("IIR")
            isFIR = .false.
         case default
            write (lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
            write (lout,*) "DYNK> non-recognized type in inner switch?"
            write (lout,*) "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(-1)
         end select
         
         read(getfields_fields(4)(1:getfields_lfields(4)),*) t ! N
         if (isFIR) then
            call dynk_checkspace(0,3*(t+1),2)
         else
            call dynk_checkspace(0,6*(t+1),2)
         endif
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk   !NAME (in cexpr_dynk)
         if (isFIR) then
            funcs_dynk(nfuncs_dynk,2) = 10 !TYPE (FIR)
         else
            funcs_dynk(nfuncs_dynk,2) = 11 !TYPE (IIR)
         endif
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk+1 !ARG1 (start of float storage)
         funcs_dynk(nfuncs_dynk,4) = t             !ARG2 (filter order N)
         funcs_dynk(nfuncs_dynk,5) =               !ARG3 (filtered function)
     &        dynk_findFUNindex( getfields_fields(6)
     &                           (1:getfields_lfields(6)), 1)
         !Store metadata
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        iexpr_dynk(niexpr_dynk) ! N
         
         ! Sanity check
         if (funcs_dynk(nfuncs_dynk,5).eq.-1) then
            call dynk_dumpdata
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FIR/IIR function wanting function '",
     &            getfields_fields(6)(1:getfields_lfields(6)), "'"
            write (lout,*) "This FUN is unknown!"
            write (lout,*) "*************************************"
            call prror(51)
         endif
        if (getfields_lfields(5) .gt. maxstrlen_dynk-1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN FIR/IIR got a filename name with "
            write (lout,*) "length =", getfields_lfields(5)
            write (lout,*) "> ",maxstrlen_dynk-1
            write (lout,*) "The name was: '",getfields_fields(5)
     &                                    (1:getfields_lfields(5)),"'"
            write (lout,*) "*************************************"
            call prror(51)
         endif
         if ( iexpr_dynk(niexpr_dynk) .le. 0 ) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "FUN FIR/IIR got N <= 0, this is not valid"
            write (lout,*) "*************************************"
            call prror(51)
         endif
         
         !More metadata
         ncexpr_dynk = ncexpr_dynk+1
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(5)) = !FILE NAME
     &        getfields_fields(5)(1:getfields_lfields(5))
         
         !Read the file
         inquire( unit=664, opened=lopen )
         if (lopen) then
            write(lout,*)
     &           "DYNK> **** ERROR in dynk_parseFUN():FIR/IIR ****"
            write(lout,*)"DYNK> unit 664 for file '"//
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //
     &           "' was already taken"
            call prror(-1)
         end if
         open(unit=664,file=cexpr_dynk(ncexpr_dynk),action='read',
     &        iostat=stat, status="OLD")
         if (stat .ne. 0) then
            write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
            write(lout,*) "DYNK> Error opening file '" //
     &           trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
            call prror(51)
         endif
         
         do ii=0, funcs_dynk(nfuncs_dynk,4) 
            !Reading the FIR/IIR file without CRLIBM
+if .not.crlibm
            if (isFIR) then
               read(664,*,iostat=stat) t, x, y
            else
               read(664,*,iostat=stat) t, x, y, z, u
            endif
            if (stat.ne.0) then
               write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
               write(lout,*) "DYNK> Error reading file '" //
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) // "'"
               write(lout,*) "DYNK> File ended unexpectedly at ii =",ii
               call prror(-1)
            endif
+ei ! END + if .not.crlibm

            !Reading the FIR/IIR file with CRLIBM
+if crlibm
            read(664,'(a)', iostat=stat) ch
            if (stat.ne.0) then
               write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
               write(lout,*) "DYNK> Error reading file '"//
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
               write(lout,*) "DYNK> File ended unexpectedly at ii =",ii
               call prror(-1)
            endif
            
            call getfields_split(ch,
     &           filefields_fields, filefields_lfields,
     &           filefields_nfields, filefields_lerr )
            
            !Sanity checks
            if ( filefields_lerr ) then
               write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
               write(lout,*) "DYNK> Error reading file '",
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
               write(lout,*) "DYNK> Error in getfields_split()"
               call prror(-1)
            end if
            if ( (      isFIR .and.filefields_nfields .ne. 3) .or.
     &           ((.not.isFIR).and.filefields_nfields .ne. 5)     ) then
               write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
               write(lout,*) "DYNK> Error reading file '"//
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk))) //
     &              "', line =", ii
               write(lout,*) "DYNK> Expected 3[5] fields ",
     &              "(idx, fac, init, selfFac, selfInit), ",
     &              "got ",filefields_nfields
               call prror(-1)
            endif
            
            !Read the data into t,x,y(,z,u):
            read(filefields_fields(1)(1:filefields_lfields(1)),*) t
            
            x = round_near(errno, filefields_lfields(2)+1,
     &           filefields_fields(2) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,2,x)
            
            y = round_near(errno, filefields_lfields(3)+1,
     &           filefields_fields(3) )
            if (errno.ne.0)
     &           call rounderr(errno,filefields_fields,3,y)
            
            if (.not.isFIR) then
               z = round_near(errno, filefields_lfields(4)+1,
     &              filefields_fields(4) )
               if (errno.ne.0)
     &              call rounderr(errno,filefields_fields,4,z)
               
               u = round_near(errno, filefields_lfields(5)+1,
     &              filefields_fields(5) )
               if (errno.ne.0)
     &              call rounderr(errno,filefields_fields,5,u)
            endif
            
+ei ! END +if crlibm

            ! More sanity checks
            if (t .ne. ii) then
               write(lout,*) "DYNK> dynk_parseFUN():FIR/IIR"
               write(lout,*) "DYNK> Error reading file '"//
     &              trim(stringzerotrim(cexpr_dynk(ncexpr_dynk)))//"'"
               write(lout,*) "DYNK> Got line t =",t, ", expected ", ii
               call prror(-1)
            endif
            !Save data to arrays
            !Store coefficients (x) and initial/earlier values (y) in interlaced order
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = x      ! b_i
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = 0.0    ! x[n-1], will be initialized in dynk_apply()
            nfexpr_dynk = nfexpr_dynk+1
            fexpr_dynk(nfexpr_dynk) = y      ! x_init[n-i]
            if (.not.isFIR) then
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = z   ! a_i
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = 0.0 ! y[n-i], will be initialized in dynk_apply()
               nfexpr_dynk = nfexpr_dynk+1
               fexpr_dynk(nfexpr_dynk) = u   ! y_init[n-i]
            endif
         enddo
         close(664)

      !!! Operators: #20-39 !!!
      case("ADD","SUB","MUL","DIV","POW")
         ! Two-argument operators  y = OP(f1, f2)

         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname {ADD|SUB|MUL|DIV|POW} funname1 funname2")
         call dynk_checkspace(0,0,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case (getfields_fields(3)(1:getfields_lfields(3)))
         case ("ADD")
            funcs_dynk(nfuncs_dynk,2) = 20 !TYPE (ADD)
         case ("SUB")
            funcs_dynk(nfuncs_dynk,2) = 21 !TYPE (SUB)
         case ("MUL")
            funcs_dynk(nfuncs_dynk,2) = 22 !TYPE (MUL)
         case ("DIV")
            funcs_dynk(nfuncs_dynk,2) = 23 !TYPE (DIV)
         case ("POW")
            funcs_dynk(nfuncs_dynk,2) = 24 !TYPE (POW)
         case default
            write (lout,*) "DYNK> dynk_parseFUN() : 2-arg function"
            write (lout,*) "DYNK> non-recognized type in inner switch"
            write (lout,*) "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) = 
     &        dynk_findFUNindex( getfields_fields(4)
     &                           (1:getfields_lfields(4)), 1) !Index to f1
         funcs_dynk(nfuncs_dynk,4) = 
     &        dynk_findFUNindex( getfields_fields(5)
     &                           (1:getfields_lfields(5)), 1) !Index to f2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         ! Sanity check (string lengths are done inside dynk_findFUNindex)
         if (funcs_dynk(nfuncs_dynk,3) .eq. -1 .or. 
     &       funcs_dynk(nfuncs_dynk,4) .eq. -1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "TWO ARG OPERATOR wanting functions '",
     &           getfields_fields(4)(1:getfields_lfields(4)), "' and '", 
     &           getfields_fields(5)(1:getfields_lfields(5)), "'"
            write (lout,*) "Calculated indices:",
     &           funcs_dynk(nfuncs_dynk,3), funcs_dynk(nfuncs_dynk,4)
            write (lout,*) "One or both of these are not known (-1)."
            write (lout,*) "*************************************"
            call dynk_dumpdata
            call prror(51)
         end if

      case ("MINUS","SQRT","SIN","COS","LOG","LOG10","EXP")
         ! One-argument operators  y = OP(f1)

         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname {MINUS|SQRT|SIN|COS|LOG|LOG10|EXP} funname")
         call dynk_checkspace(0,0,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case ( getfields_fields(3)(1:getfields_lfields(3)) )
         case ("MINUS")
            funcs_dynk(nfuncs_dynk,2) = 30 !TYPE (MINUS)
         case ("SQRT")
            funcs_dynk(nfuncs_dynk,2) = 31 !TYPE (SQRT)
         case ("SIN")
            funcs_dynk(nfuncs_dynk,2) = 32 !TYPE (SIN)
         case ("COS")
            funcs_dynk(nfuncs_dynk,2) = 33 !TYPE (COS)
         case ("LOG")
            funcs_dynk(nfuncs_dynk,2) = 34 !TYPE (LOG)
         case ("LOG10")
            funcs_dynk(nfuncs_dynk,2) = 35 !TYPE (LOG10)
         case ("EXP")
            funcs_dynk(nfuncs_dynk,2) = 36 !TYPE (EXP)
         case default
            write (lout,*) "DYNK> dynk_parseFUN() : 1-arg function"
            write (lout,*) "DYNK> non-recognized type in inner switch?"
            write (lout,*) "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) = 
     &        dynk_findFUNindex(getfields_fields(4)
     &        (1:getfields_lfields(4)), 1)       !Index to f1
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         ! Sanity check (string lengths are done inside dynk_findFUNindex)
         if (funcs_dynk(nfuncs_dynk,3) .eq. -1) then
            write (lout,*) "*************************************"
            write (lout,*) "ERROR in DYNK block parsing (fort.3):"
            write (lout,*) "SINGLE OPERATOR FUNC wanting function '",
     &           getfields_fields(4)(1:getfields_lfields(4)), "'"
            write (lout,*) "Calculated index:",
     &           funcs_dynk(nfuncs_dynk,3)
            write (lout,*) "One or both of these are not known (-1)."
            write (lout,*) "*************************************"
            call dynk_dumpdata
            call prror(51)
         end if

      !!! Polynomial & Elliptical functions: # 40-59 !!!
      case("CONST")   
         ! CONST: Just a constant value
         
         call dynk_checkargs(getfields_nfields,4,
     &        "FUN funname CONST value" )
         call dynk_checkspace(0,1,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 40          !TYPE (CONST)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        fexpr_dynk(nfexpr_dynk) ! value
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! value
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)  )
+ei

      case ("TURN")
         ! TURN: Just the current turn number
         
         call dynk_checkargs(getfields_nfields,3,
     &        "FUN funname TURN" )
         call dynk_checkspace(0,0,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 41          !TYPE (TURN)
         funcs_dynk(nfuncs_dynk,3) = -1          !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

      case ("LIN")
         ! LIN: Linear ramp y = dy/dt*T+b
         
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname LIN dy/dt b" )
         call dynk_checkspace(0,2,1)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 42          !TYPE (LIN)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        fexpr_dynk(nfexpr_dynk) ! dy/dt
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        fexpr_dynk(nfexpr_dynk+1) ! b
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! dy/dt
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! b
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1) )
+ei
         nfexpr_dynk = nfexpr_dynk + 1

      case ("LINSEG")
         ! LINSEG: Linear ramp between points (x1,y1) and (x2,y2)
         
         call dynk_checkargs(getfields_nfields,7,
     &        "FUN funname LINSEG x1 x2 y1 y2" )
         call dynk_checkspace(0,4,1)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 43          !TYPE (LINSEG)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        fexpr_dynk(nfexpr_dynk)   ! x1
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        fexpr_dynk(nfexpr_dynk+1) ! x2
         read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &        fexpr_dynk(nfexpr_dynk+2) ! y1
         read(getfields_fields(7)(1:getfields_lfields(7)),*)
     &        fexpr_dynk(nfexpr_dynk+3) ! y2
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! x1
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! x2
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! y1
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
         fexpr_dynk(nfexpr_dynk+3) = round_near(errno, ! y2
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7,
     &                       fexpr_dynk(nfexpr_dynk+3)   )
+ei
         nfexpr_dynk = nfexpr_dynk + 3
         
         if (fexpr_dynk(nfexpr_dynk-3).eq.fexpr_dynk(nfexpr_dynk-2))then
            write (lout,*) "ERROR in DYNK block parsing (fort.3)"
            write (lout,*) "LINSEG: x1 and x2 must be different."
            call prror(51)
         endif
         
      case ("QUAD")
         ! QUAD: Quadratic ramp y = a*T^2 + b*T + c
         
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname QUAD a b c" )
         call dynk_checkspace(0,3,1)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 44          !TYPE (QUAD)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        fexpr_dynk(nfexpr_dynk)   ! a
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        fexpr_dynk(nfexpr_dynk+1) ! b
         read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &        fexpr_dynk(nfexpr_dynk+2) ! c
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! a
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! b
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! c
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
+ei
         nfexpr_dynk = nfexpr_dynk + 2

      case ("QUADSEG")
         ! QUADSEG: Quadratic ramp y = a*T^2 + b*T + c,
         ! input as start point (x1,y1), end point (x2,y2), derivative at at x1
         
         call dynk_checkargs(getfields_nfields,8,
     &        "FUN funname QUADSEG x1 x2 y1 y2 deriv" )
         call dynk_checkspace(0,8,1)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 45          !TYPE (QUADSEG)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*) x1
         read(getfields_fields(5)(1:getfields_lfields(5)),*) x2
         read(getfields_fields(6)(1:getfields_lfields(6)),*) y1
         read(getfields_fields(7)(1:getfields_lfields(7)),*) y2
         read(getfields_fields(8)(1:getfields_lfields(8)),*) deriv
+ei
+if crlibm
         x1 = round_near(errno, ! x1
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4, x1 )
         x2 = round_near(errno, ! x2
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5, x2 )
         y1 = round_near(errno, ! y1
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6, y1 )
         y2 = round_near(errno, ! y2
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7, y2 )
         deriv = round_near(errno, ! deriv
     &        getfields_lfields(8)+1, getfields_fields(8) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,8, deriv )
+ei
         if (x1 .eq. x2) then
            write (lout,*) "ERROR in DYNK block parsing (fort.3)"
            write (lout,*) "QUADSEG: x1 and x2 must be different."
            call prror(51)
         endif
         
         ! Compute a:
         fexpr_dynk(nfexpr_dynk) = deriv/(x1-x2)
     &        + (y2-y1)/((x1-x2)**2)
         ! Compute b:
         fexpr_dynk(nfexpr_dynk+1) = (y2-y1)/(x2-x1)
     &        - (x1+x2)*fexpr_dynk(nfexpr_dynk)
         ! Compute c:
         fexpr_dynk(nfexpr_dynk+2) = y1 + (
     &        - x1**2 * fexpr_dynk(nfexpr_dynk)
     &        - x1    * fexpr_dynk(nfexpr_dynk+1) )
         
         ! Store input data:
         fexpr_dynk(nfexpr_dynk+3) = x1
         fexpr_dynk(nfexpr_dynk+4) = x2
         fexpr_dynk(nfexpr_dynk+5) = y1
         fexpr_dynk(nfexpr_dynk+6) = y2
         fexpr_dynk(nfexpr_dynk+7) = deriv

         nfexpr_dynk = nfexpr_dynk + 7
         
      !!! Trancedental functions: #60-79 !!!
      case ("SINF","COSF","COSF_RIPP")
         ! SINF     : Sin functions y = A*sin(omega*T+phi)
         ! COSF     : Cos functions y = A*cos(omega*T+phi)
         ! COSF_RIPP: Cos functions y = A*cos(2*pi*(T-1)/period+phi)
         
         call dynk_checkargs(getfields_nfields,6,
     &        "FUN funname {SINF|COSF|COSF_RIPP} "//
     &        "amplitude {omega|period} phase" )
         call dynk_checkspace(0,3,1)

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         select case (getfields_fields(3)(1:getfields_lfields(3)))
         case("SINF")
            funcs_dynk(nfuncs_dynk,2) = 60       !TYPE (SINF)
         case("COSF")
            funcs_dynk(nfuncs_dynk,2) = 61       !TYPE (COSF)
         case ("COSF_RIPP")
            funcs_dynk(nfuncs_dynk,2) = 62       !TYPE (COSF_RIPP)
         case default
            write (lout,*) "DYNK> dynk_parseFUN() : SINF/COSF"
            write (lout,*) "DYNK> non-recognized type in inner switch"
            write (lout,*) "DYNK> Got: '" //
     &           getfields_fields(3)(1:getfields_lfields(3)) // "'"
            call prror(51)
         end select
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         
+if .not.crlibm
         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        fexpr_dynk(nfexpr_dynk) !A
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        fexpr_dynk(nfexpr_dynk+1) !omega
         read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &        fexpr_dynk(nfexpr_dynk+2) !phi
+ei
+if crlibm
         fexpr_dynk(nfexpr_dynk) = round_near(errno, ! A
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4,
     &                       fexpr_dynk(nfexpr_dynk)   )
         fexpr_dynk(nfexpr_dynk+1) = round_near(errno, ! omega
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5,
     &                       fexpr_dynk(nfexpr_dynk+1)   )
         fexpr_dynk(nfexpr_dynk+2) = round_near(errno, ! phi
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6,
     &                       fexpr_dynk(nfexpr_dynk+2)   )
+ei
         nfexpr_dynk = nfexpr_dynk + 2

      case ("PELP")
         ! PELP: Parabolic/exponential/linear/parabolic
         ! From "Field Computation for Accelerator Magnets:
         ! Analytical and Numerical Methods for Electromagnetic Design and Optimization"
         ! By Dr.-Ing. Stephan Russenschuck
         ! Appendix C: "Ramping the LHC Dipoles"
         
         call dynk_checkargs(getfields_nfields,10,
     &        "FUN funname PELP tinj Iinj Inom A D R te" )
         call dynk_checkspace(0,13,1) !!...

         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         nfexpr_dynk = nfexpr_dynk+1
         ncexpr_dynk = ncexpr_dynk+1
         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 80          !TYPE (PELP)
         funcs_dynk(nfuncs_dynk,3) = nfexpr_dynk !ARG1
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))
         
         !Read and calculate parameters
+if .not.crlibm
         read(getfields_fields(4) (1:getfields_lfields( 4)),*) tinj
         read(getfields_fields(5) (1:getfields_lfields( 5)),*) Iinj
         read(getfields_fields(6) (1:getfields_lfields( 6)),*) Inom
         read(getfields_fields(7) (1:getfields_lfields( 7)),*) A
         read(getfields_fields(8) (1:getfields_lfields( 8)),*) D
         read(getfields_fields(9) (1:getfields_lfields( 9)),*) R
         read(getfields_fields(10)(1:getfields_lfields(10)),*) te
+ei
+if crlibm
         tinj = round_near(errno,    ! tinj
     &        getfields_lfields(4)+1, getfields_fields(4) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,4, tinj )
         Iinj = round_near(errno,    ! Iinj
     &        getfields_lfields(5)+1, getfields_fields(5) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,5, Iinj )
         Inom = round_near(errno,    ! Inom
     &        getfields_lfields(6)+1, getfields_fields(6) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,6, Inom )
         A = round_near(errno,       ! A
     &        getfields_lfields(7)+1, getfields_fields(7) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,7, A )
         D = round_near(errno,       ! D
     &        getfields_lfields(8)+1, getfields_fields(8) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,8, D )
         R = round_near(errno,       ! R
     &        getfields_lfields(9)+1, getfields_fields(9) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,9, R )
         te = round_near(errno,      ! te
     &        getfields_lfields(10)+1, getfields_fields(10) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,10, te )
+ei
         derivI_te = A*(te-tinj)                 ! nostore
         I_te      = (A/2.0)*(te-tinj)**2 + Iinj ! nostore
         bexp      = derivI_te/I_te
         aexp      = exp(-bexp*te)*I_te
         t1        = log(R/(aexp*bexp))/bexp
         I1        = aexp*exp(bexp*t1)
         td        = (Inom-I1)/R + (t1 - R/(2*D))
         tnom      = td + R/D
         
         if (ldynkdebug) then
         write (lout,*) "DYNKDEBUG> *** PELP SETTINGS: ***"
         write (lout,*) "DYNKDEBUG> tinj =", tinj
         write (lout,*) "DYNKDEBUG> Iinj =", Iinj
         write (lout,*) "DYNKDEBUG> Inom =", Inom
         write (lout,*) "DYNKDEBUG> A    =", A
         write (lout,*) "DYNKDEBUG> D    =", D
         write (lout,*) "DYNKDEBUG> R    =", R
         write (lout,*) "DYNKDEBUG> te   =", te
         write (lout,*) "DYNKDEBUG> "
         write (lout,*) "DYNKDEBUG> derivI_te =", derivI_te
         write (lout,*) "DYNKDEBUG> I_te      =", I_te
         write (lout,*) "DYNKDEBUG> bexp      =", bexp
         write (lout,*) "DYNKDEBUG> aexp      =", aexp
         write (lout,*) "DYNKDEBUG> t1        =", t1
         write (lout,*) "DYNKDEBUG> I1        =", I1
         write (lout,*) "DYNKDEBUG> td        =", td
         write (lout,*) "DYNKDEBUG> tnom      =", tnom
         write (lout,*) "DYNKDEBUG> **********************"
         
         endif
         
         if (.not. (tinj .lt. te .and.
     &                te .lt. t1 .and.
     &                t1 .lt. td .and.
     &                td .lt. tnom ) ) then
            WRITE(lout,*) "DYNK> ********************************"
            WRITE(lout,*) "DYNK> ERROR***************************"
            write(lout,*) "DYNK> PELP: Order of times not correct"
            WRITE(lout,*) "DYNK> ********************************"
            call prror(51)
         endif
         
         !Store: Times
         fexpr_dynk(nfexpr_dynk)    = tinj
         fexpr_dynk(nfexpr_dynk+ 1) = te
         fexpr_dynk(nfexpr_dynk+ 2) = t1
         fexpr_dynk(nfexpr_dynk+ 3) = td
         fexpr_dynk(nfexpr_dynk+ 4) = tnom
         !Store: Parameters / section1 (parabola)
         fexpr_dynk(nfexpr_dynk+ 5) = Iinj
         fexpr_dynk(nfexpr_dynk+ 6) = A
         !Store: Parameters / section2 (exponential)
         fexpr_dynk(nfexpr_dynk+ 7) = aexp
         fexpr_dynk(nfexpr_dynk+ 8) = bexp
         !Store: Parameters / section3 (linear)
         fexpr_dynk(nfexpr_dynk+ 9) = I1
         fexpr_dynk(nfexpr_dynk+10) = R
         !Store: Parameters / section4 (parabola)
         fexpr_dynk(nfexpr_dynk+11) = D
         fexpr_dynk(nfexpr_dynk+12) = Inom
         
         nfexpr_dynk = nfexpr_dynk + 12

      case("ONOFF")
         ! ONOFF: On for p1 turns, then off for the rest of the period p2
         call dynk_checkargs(getfields_nfields,5,
     &        "FUN funname ONOFF p1 p2" )
         call dynk_checkspace(0,0,1)
         
         ! Set pointers to start of funs data blocks
         nfuncs_dynk = nfuncs_dynk+1
         ncexpr_dynk = ncexpr_dynk+1

         ! Store pointers
         funcs_dynk(nfuncs_dynk,1) = ncexpr_dynk !NAME (in cexpr_dynk)
         funcs_dynk(nfuncs_dynk,2) = 81          !TYPE (ONOFF)
         funcs_dynk(nfuncs_dynk,3) = -1          !ARG1 (p1)
         funcs_dynk(nfuncs_dynk,4) = -1          !ARG2 (p2)
         funcs_dynk(nfuncs_dynk,5) = -1          !ARG3 (unused)
         
         ! Store data
         cexpr_dynk(ncexpr_dynk)(1:getfields_lfields(2)) = !NAME
     &        getfields_fields(2)(1:getfields_lfields(2))

         read(getfields_fields(4)(1:getfields_lfields(4)),*)
     &        funcs_dynk(nfuncs_dynk,3) ! p1
         read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &        funcs_dynk(nfuncs_dynk,4) ! p2

         !Check for bad input
         if ( funcs_dynk(nfuncs_dynk,3) .lt. 0 .or.                    ! p1 <  1 ?
     &        funcs_dynk(nfuncs_dynk,4) .le. 1 .or.                    ! p2 <= 1 ?
     &        funcs_dynk(nfuncs_dynk,4) .lt. funcs_dynk(nfuncs_dynk,3) ! p2 < p1 ?
     &        ) then
            write(lout,*)
     &      "DYNK> Error in ONOFF: Expected p1 >= 0, p2 > 1, p1 <= p2"
            call prror(-1)
         end if

      case default
         ! UNKNOWN function
         write (lout,*) "*************************************"
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "Unkown function to dynk_parseFUN()   "
         write (lout,*) "Got fields:"
         do ii=1,getfields_nfields
            write (lout,*) "Field(",ii,") ='",
     &           getfields_fields(ii)(1:getfields_lfields(ii)),"'"
         enddo
         write (lout,*) "*************************************"

         call dynk_dumpdata
         call prror(51)
      end select

      end subroutine

      subroutine dynk_checkargs(nfields,nfields_expected,funsyntax)
      implicit none
+ca crcoall
      integer nfields, nfields_expected
      character(*) funsyntax
      intent(in) nfields, nfields_expected, funsyntax
      
      if (nfields .ne. nfields_expected) then
         write (lout,*) "ERROR in DYNK block parsing (fort.3)"
         write (lout,*) "The function expected",nfields_expected,
     &               "arguments, got",nfields
         write (lout,*) "Expected syntax:"
         write (lout,*) funsyntax(:)
         call prror(51)
      endif
      end subroutine

      subroutine dynk_checkspace(iblocks,fblocks,cblocks)
      implicit none
      integer iblocks,fblocks,cblocks
      intent(in) iblocks,fblocks,cblocks
+ca parpro
+ca stringzerotrim
+ca comdynk      

+ca crcoall

      if ( (niexpr_dynk+iblocks .gt. maxdata_dynk) .or.
     &     (nfexpr_dynk+fblocks .gt. maxdata_dynk) .or.
     &     (ncexpr_dynk+cblocks .gt. maxdata_dynk) ) then
         
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "Max number of maxdata_dynk to be exceeded"
         write (lout,*) "niexpr_dynk:", niexpr_dynk
         write (lout,*) "nfexpr_dynk:", nfexpr_dynk
         write (lout,*) "ncexpr_dynk:", ncexpr_dynk
         
         call prror(51)
      endif
      end subroutine
      
      subroutine dynk_parseSET(getfields_fields,
     &     getfields_lfields,getfields_nfields)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 15-10-2014
!     parse SET lines in the fort.3 input file, 
!     store it in COMMON block dynkComExpr.
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
+ca comgetfields

+ca crcoall

      integer ii
      
      integer dynk_findFUNindex

      if (nsets_dynk+1 .gt. maxsets_dynk) then
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "Maximum number of SET exceeded, ",
     &               "please increase parameter maxsets_dynk."
         write (lout,*) "Current value of maxsets_dynk:", maxsets_dynk
         call prror(51)
      endif

      if (getfields_nfields .ne. 7) then
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "Expected 6 fields on line while parsing SET."
         write (lout,*) "Correct syntax:"
         write (lout,*) "SET element_name attribute_name function_name",
     &                  " startTurn endTurn turnShift"
         write (lout,*) "got field:"
         do ii=1,getfields_nfields
            write (lout,*) "Field(",ii,") ='",
     &           getfields_fields(ii)(1:getfields_lfields(ii)),"'"
         enddo
         call prror(51)
      endif

      nsets_dynk = nsets_dynk + 1

      sets_dynk(nsets_dynk,1) =
     &     dynk_findFUNindex( getfields_fields(4)
     &     (1:getfields_lfields(4)), 1 ) ! function_name -> function index
      read(getfields_fields(5)(1:getfields_lfields(5)),*)
     &     sets_dynk(nsets_dynk,2) ! startTurn
      read(getfields_fields(6)(1:getfields_lfields(6)),*)
     &     sets_dynk(nsets_dynk,3) ! endTurn
      read(getfields_fields(7)(1:getfields_lfields(7)),*)
     &     sets_dynk(nsets_dynk,4) ! turnShift
      
      !Sanity check on string lengths
      if (getfields_lfields(2).gt.16 .or.
     &    getfields_lfields(2).gt.maxstrlen_dynk-1) then
         write (lout,*) "*************************************"
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "SET got an element name with length =",
     &        getfields_lfields(2), "> 16 or > maxstrlen_dynk-1."
         write (lout,*) "The name was: '",
     &        getfields_fields(2)(1:getfields_lfields(2)),"'"
         write (lout,*) "*************************************"
         call prror(51)
      endif
      
      if (getfields_lfields(3).gt.maxstrlen_dynk-1) then
         write(lout,*) "ERROR in DYNK block parsing (fort.3) (SET):"
         write(lout,*) "The attribute name '"//
     &        getfields_fields(2)(1:getfields_lfields(2))//"'"
         write(lout,*) "is too long! Max length is",
     &        maxstrlen_dynk-1
         call prror(51)         
      endif
      
      !OK -- save them!
      csets_dynk(nsets_dynk,1)(1:getfields_lfields(2)) =
     &     getfields_fields(2)(1:getfields_lfields(2)) ! element_name
      csets_dynk(nsets_dynk,2)(1:getfields_lfields(3)) =
     &     getfields_fields(3)(1:getfields_lfields(3)) ! attribute_name
      
      ! Sanity check
      if (sets_dynk(nsets_dynk,1).eq.-1) then
         write (lout,*) "*************************************"
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "SET wanting function '",
     &        getfields_fields(4)(1:getfields_lfields(4)), "'"
         write (lout,*) "Calculated index:", sets_dynk(nsets_dynk,1)
         write (lout,*) "This function is not known."
         write (lout,*) "*************************************"
         call prror(51)
      endif
      
      if (  (sets_dynk(nsets_dynk,3) .ne. -1) .and. !Not the special case
     &      (sets_dynk(nsets_dynk,2) .gt. sets_dynk(nsets_dynk,3)) )then
         write (lout,*) "*************************************"
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "SET got first turn num > last turn num"
         write (lout,*) "first=",sets_dynk(nsets_dynk,2)
         write (lout,*) "last =",sets_dynk(nsets_dynk,3)
         write (lout,*) "SET #", nsets_dynk
         write (lout,*) "*************************************"
         call prror(51)
      end if
      
      if ( (sets_dynk(nsets_dynk,2) .le. 0 ) .or.
     &     (sets_dynk(nsets_dynk,3) .lt. -1) .or. 
     &     (sets_dynk(nsets_dynk,3) .eq. 0 )     ) then
         write (lout,*) "*************************************"
         write (lout,*) "ERROR in DYNK block parsing (fort.3):"
         write (lout,*) "SET got turn number <= 0 "
         write (lout,*) "(not last = -1 meaning infinity)"
         write (lout,*) "first=",sets_dynk(nsets_dynk,2)
         write (lout,*) "last =",sets_dynk(nsets_dynk,3)
         write (lout,*) "SET #", nsets_dynk
         write (lout,*) "*************************************"
         call prror(51)
      end if

      end subroutine

      integer function dynk_findFUNindex(funName_input, startfrom)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-07-2015
!     Find and return the index in the ifuncs array to the
!      function with name funName, which should be zero-padded.
!     Return -1 if nothing was found.
!
!     Note: It is expected that the length of funName_input is
!      equal or less than maxstrlen_dynk, and if it equal,
!      that it is a zero-terminated string.
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
+ca crcoall
      character(*) funName_input
      character(maxstrlen_dynk) funName
      integer startfrom
      intent(in) funName_input, startfrom


      integer ii

C      write(*,*)"DBGDBG input: '"//funName_input//"'",len(funName_input)      

      if (len(funName_input).gt.maxstrlen_dynk) then
         write (lout,*) "ERROR in dynk_findFUNindex"
         write (lout,*) "len(funName_input) = ",len(funName_input),
     &        ".gt. maxstrlen_dynk-1 = ", maxstrlen_dynk-1
         call prror(-1)
      endif
      ! If the length is exactly maxstrlen_dynk, it should be zero-terminated.
      if (( len(funName_input).eq.maxstrlen_dynk ) .and.
     &    ( funName_input(len(funName_input):len(funName_input))
     &     .ne.char(0)) ) then
         write (lout,*) "ERROR in dynk_findFUNindex"
         write (lout,*) "Expected funName_input[-1]=NULL"
         call prror(-1)
      endif
      
      do ii=1,len(funName_input)
C         write(*,*) "DBGDBG a:", ii
         funName(ii:ii) = funName_input(ii:ii)
      enddo
      funName(1:len(funName_input)) = funName_input
      do ii=len(funName_input)+1,maxstrlen_dynk
C         write(*,*) "DBGDBG b:", ii
         funName(ii:ii) = char(0)
      enddo
C      write(*,*) "DBGDBG c:", funName, len(funName)

      dynk_findFUNindex = -1

      do ii=startfrom, nfuncs_dynk
         if (cexpr_dynk(funcs_dynk(ii,1)).eq.funName) then
            dynk_findFUNindex = ii
            exit ! break loop
         endif
      end do
      
      end function

      integer function dynk_findSETindex
     &     (element_name, att_name, startfrom)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 23-10-2014
!     Find and return the index in the sets array to the set which
!     matches element_name and att_name, which should be zero-padded.
!     Return -1 if nothing was found.
!
!     Note: It is expected that the length of element_name and att_name
!      is exactly maxstrlen_dynk .
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
      character(maxstrlen_dynk) element_name, att_name
      integer startfrom
      intent(in) element_name, att_name, startfrom
      
      integer ii
      
      dynk_findSETindex = -1
      
      do ii=startfrom, nsets_dynk
         if ( csets_dynk(ii,1) .eq. element_name .and.
     &        csets_dynk(ii,2) .eq. att_name ) then
            dynk_findSETindex = ii
            exit                ! break loop
         endif
      enddo
      
      end function
      
      subroutine dynk_inputsanitycheck
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-10-2014
!     Check that DYNK block input in fort.3 was sane
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
+ca crcoall
      ! functions
      integer dynk_findFUNindex , dynk_findSETindex

      integer ii, jj
      integer biggestTurn ! Used as a replacement for ending turn -1 (infinity)
      logical sane
      sane = .true.
      
      ! Check that there are no doubly-defined function names
      do ii=1, nfuncs_dynk-1
         jj = dynk_findFUNindex(cexpr_dynk(funcs_dynk(ii,1)),ii+1)
         if ( jj.ne. -1) then
            sane = .false.
            write (lout,*)
     &           "DYNK> Insane: function ", 
     &           ii, "has the same name as", jj
         end if
      end do
      
      ! Check that no SETS work on same elem/att at same time
      biggestTurn = 1
      do ii=1, nsets_dynk
         if (sets_dynk(ii,3) .gt. biggestTurn) then
            biggestTurn = sets_dynk(ii,3)
         endif
      end do
      biggestTurn = biggestTurn+1 !Make sure it is unique
      if (biggestTurn .le. 0) then
         !In case of integer overflow
         write(lout,*)
     &        "FATAL ERROR: Integer overflow in dynk_inputsanitycheck!"
         call prror(-1)
      endif
      !Do the search!
      do ii=1, nsets_dynk-1
         if (sets_dynk(ii,3).eq.-1) sets_dynk(ii,3) = biggestTurn
!         write(*,*) "DBG: ii=",ii,
!     &           csets_dynk(ii,1)," ", csets_dynk(ii,2)
!         write(*,*)"DBG:", sets_dynk(ii,2),sets_dynk(ii,3)

         jj = ii
         do while (.true.)
            !Only check SETs affecting the same elem/att
            jj = dynk_findSETindex(csets_dynk(ii,1),
     &                             csets_dynk(ii,2),jj+1)

!            write(*,*)" DBG: jj=",jj, 
!     &           csets_dynk(jj,1)," ", csets_dynk(jj,2)

            if (jj .eq. -1) exit ! next outer loop

            if (sets_dynk(jj,3).eq.-1) sets_dynk(jj,3) = biggestTurn

!            write(*,*)" DBG:", sets_dynk(jj,2),sets_dynk(jj,3)

            if ( sets_dynk(jj,2) .le. sets_dynk(ii,2) .and.
     &           sets_dynk(jj,3) .ge. sets_dynk(ii,2) ) then
               sane = .false.
               write (lout,"(A,I4,A,I8,A,I4,A,I8,A,I4,A,I8,A,I4)")
     &              " DYNK> Insane: Lower edge of SET #", jj,
     &        " =", sets_dynk(jj,2)," <= lower edge of SET #",ii,
     &        " =", sets_dynk(ii,2),"; and also higer edge of SET #",jj,
     &        " =", sets_dynk(jj,3)," >= lower edge of SET #", ii

            else if (sets_dynk(jj,3) .ge. sets_dynk(ii,3) .and.
     &               sets_dynk(jj,2) .le. sets_dynk(ii,3) ) then
               sane = .false.
               write(lout, "(A,I4,A,I8,A,I4,A,I8,A,I4,A,I8,A,I4)")
     &              " DYNK> Insane: Upper edge of SET #", jj,
     &        " =", sets_dynk(jj,3)," >= upper edge of SET #",ii,
     &        " =", sets_dynk(ii,3),"; and also lower edge of SET #",jj,
     &        " =", sets_dynk(jj,2)," <= upper edge of SET #", ii
      
            else if (sets_dynk(jj,2) .ge. sets_dynk(ii,2) .and.
     &               sets_dynk(jj,3) .le. sets_dynk(ii,3) ) then
               ! (other way round gets caugth by the first "if")
               sane = .false.
               write(lout, "(A,I4,A,I8,A,I8,A,A,I4,A,I8,A,I8,A)")
     &              " DYNK> Insane: SET #", jj,
     &        " = (", sets_dynk(jj,2),", ", sets_dynk(jj,3), ")",
     &        " is inside SET #", ii, " = (", 
     &                sets_dynk(ii,2),", ", sets_dynk(ii,3), ")"
            endif
            if (sets_dynk(jj,3).eq.biggestTurn) sets_dynk(jj,3) = -1
         enddo
         if (sets_dynk(ii,3).eq.biggestTurn) sets_dynk(ii,3) = -1
      enddo

      if (.not. sane) then
         write (lout,*) "****************************************"
         write (lout,*) "*******DYNK input was insane************"
         write (lout,*) "****************************************"
         call dynk_dumpdata
         call prror(-11)
      else if (sane .and. ldynkdebug) then
         write (lout,*)
     &        "DYNK> DYNK input was sane"
      end if
      end subroutine

      subroutine dynk_dumpdata
!----------------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 14-10-2014
!     Dump arrays with DYNK FUN and SET data to the std. output for debugging
!----------------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
+ca crcoall

      integer ii
      write(lout,*)
     &     "**************** DYNK parser knows: ****************"

      write (lout,*) "OPTIONS:"
      write (lout,*) " ldynk            =", ldynk
      write (lout,*) " ldynkdebug       =", ldynkdebug
      write (lout,*) " ldynkfiledisable =", ldynkfiledisable

      write (lout,*) "FUN:"
      write (lout,*) "ifuncs: (",nfuncs_dynk,")"
      do ii=1,nfuncs_dynk
         write (lout,*) 
     &        ii, ":", funcs_dynk(ii,:)
      end do
      write (lout,*) "iexpr_dynk: (",niexpr_dynk,")"
      do ii=1,niexpr_dynk
         write (lout,*)
     &     ii, ":", iexpr_dynk(ii)
      end do
      write (lout,*) "fexpr_dynk: (",nfexpr_dynk,")"
      do ii=1,nfexpr_dynk
         write (lout, '(1x,I8,1x,A,1x,E16.9)')
     &   ii, ":", fexpr_dynk(ii)
      end do
      write (lout,*) "cexpr_dynk: (",ncexpr_dynk,")"
      do ii=1,ncexpr_dynk
         write(lout,*)
     &   ii, ":", "'"//trim(stringzerotrim(cexpr_dynk(ii)))//"'"
      end do

      write (lout,*) "SET:"      
      write (lout,*) "sets(,:) csets(,1) csets(,2): (",
     &     nsets_dynk,")"
      do ii=1,nsets_dynk
         write (lout,*)
     &        ii, ":", sets_dynk(ii,:),
     &        "'"//trim(stringzerotrim(csets_dynk(ii,1)))//
     &  "' ", "'"//trim(stringzerotrim(csets_dynk(ii,2)))//"'"
      end do
      write (lout,*) "csets_unique_dynk: (",nsets_unique_dynk,")"
      do ii=1,nsets_unique_dynk
         write(lout, '(1x,I8,1x,A,1x,E16.9)')
     &       ii, ": '"//
     &       trim(stringzerotrim(csets_unique_dynk(ii,1)))//"' '"//
     &       trim(stringzerotrim(csets_unique_dynk(ii,2)))//"' = ",
     &        fsets_origvalue_dynk(ii)
      end do

      write (lout,*) "*************************************************"
      
      end subroutine
      
      subroutine dynk_pretrack
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 21-10-2014
!     
!     Save original values for GET functions and sanity check
!     that elements/attributes for SET actually exist.
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca common
+ca stringzerotrim
+ca comdynk
+ca crcoall
+ca commondl

      !Functions
      double precision dynk_getvalue
      integer dynk_findSETindex

      !Temp variables
      integer ii,jj
      character(maxstrlen_dynk) element_name_s, att_name_s
      logical found, badelem
      integer ix
      if (ldynkdebug) then
         write(lout,*)
     &    "DYNKDEBUG> In dynk_pretrack()"
      end if
      
      ! Find which elem/attr combos are affected by SET
      nsets_unique_dynk = 0 !Assuming this is only run once
      do ii=1,nsets_dynk
         if ( dynk_findSETindex(
     &        csets_dynk(ii,1),csets_dynk(ii,2), ii+1 ) .eq. -1 ) then
            ! Last SET which has this attribute, store it
            nsets_unique_dynk = nsets_unique_dynk+1

            csets_unique_dynk(nsets_unique_dynk,1) = csets_dynk(ii,1)
            csets_unique_dynk(nsets_unique_dynk,2) = csets_dynk(ii,2)
            
            ! Sanity check: Does the element actually exist?
            element_name_s =
     &           trim(stringzerotrim(
     &           csets_unique_dynk(nsets_unique_dynk,1) ))
            att_name_s     =
     &           trim(stringzerotrim(
     &           csets_unique_dynk(nsets_unique_dynk,2) ))
            found = .false.

            ! Special case: the element name GLOBAL-VARS (not a real element)
            ! can be used to redefine a global variable by some function.
            if (element_name_s .eq. "GLOBAL-VARS") then
               found=.true.
               badelem = .false.
               
               if (att_name_s .eq. "E0") then
                  if (idp.eq.0 .or. ition.eq.0) then ! 4d tracking..
                     write(lout,*) "DYNK> Insane - attribute '",
     &                  att_name_s, "' is not valid for 'GLOBAL-VARS' ",
     &                  "when doing 4d tracking"
                     call prror(-1)
                  endif
               else
                  badelem=.true.
               endif

               if (badelem) then
                  write(lout,*) "DYNK> Insane - attribute '",
     &                att_name_s, "' is not valid for 'GLOBAL-VARS'"
                  call prror(-1)
               endif
            endif
            
            do jj=1,il
               if ( bez(jj).eq. element_name_s) then
                  
                  found = .true.
                  
                  ! Check that the element type and attribute is supported
                  ! Check that the element can be used now
                  badelem = .false.
                  if (abs(kz(jj)).ge.1 .and. abs(kz(jj)).le.10) then !thin kicks
                     if (att_name_s .ne. "average_ms") then
                        badelem = .true.
                     endif
                  elseif (abs(kz(jj)).eq.12) then !cavity
                     if (.not. (att_name_s.eq."voltage"  .or.
     &                    att_name_s.eq."harmonic"       .or.
     &                    att_name_s.eq."lag_angle"          )) then
                        badelem = .true.
                     endif
                     if (kp(jj).ne.6) then
                        write(lout,*) "DYNK> Insane - want to modify ",

     &                      "DISABLED RF cavity named '",element_name_s,
     &                      ". Please make sure that the voltage and ",
     &                      "harmonic number in the SINGLE ELEMENTS ",
     &                      "block is not 0!"
                        call prror(-1)
                     endif
                     if (nvar .eq. 5) then
                        write(lout,*) "DYNK> Insane - want to modify ",
     &                       "RF cavity named '", element_name_s, "', ",
     &                       "but nvars=5 (from DIFF block)."
                     endif

                  elseif (abs(kz(jj)).eq.23 .or.   ! crab
     &                    abs(kz(jj)).eq.26 .or.   ! cc multipole,  order 2
     &                    abs(kz(jj)).eq.27 .or.   ! cc multipole,  order 3
     &                    abs(kz(jj)).eq.28 ) then ! cc muiltipole, order 4
                     if (.not. (att_name_s.eq."voltage"   .or.
     &                          att_name_s.eq."frequency" .or.
     &                          att_name_s.eq."phase"         )) then
                        badelem = .true.
                     endif
                  endif

                  ! Special case:
                  ! Should the error only occur if we actually have a GLOBAL-VARS element?
                  if (bez(jj) .eq. "GLOBAL-VARS") then
                     write(lout,*) "DYNK> Insane - element found '",
     &                    "GLOBAL-VARS' is not a valid element name, ",
     &                    "it is reserved"
                     call prror(-1) 
                  endif
                  
                  if (badelem) then
                     write(lout,*) "DYNK> Insane - attribute '",
     &                    att_name_s, "' is not valid for element '",
     &                    element_name_s, "' which is of type",kz(jj)
                     call prror(-1) 
                  endif
                  
               endif
            enddo
            if (.not. found) then
               write (lout,*) "DYNK> Insane: Element '", element_name_s,
     &                        "' was not found"
               call prror(-1)
            endif

            ! Store original value of data point
            fsets_origvalue_dynk(nsets_unique_dynk) =
     &           dynk_getvalue(csets_dynk(ii,1),csets_dynk(ii,2))
         endif
      enddo

      ! Save original values for GET functions
      do ii=1,nfuncs_dynk
         if (funcs_dynk(ii,2) .eq. 0) then !GET
            fexpr_dynk(funcs_dynk(ii,3)) =
     &           dynk_getvalue( cexpr_dynk(funcs_dynk(ii,1)+1),
     &                          cexpr_dynk(funcs_dynk(ii,1)+2) )
         endif
      enddo

      if (ldynkdebug) call dynk_dumpdata
      
      end subroutine
      

+dk dynktrack
      subroutine dynk_apply(turn)
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak & A. Santamaria, BE-ABP/HSS
!     last modified: 30-10-2014
!     actually apply dynamic kicks
!     always in main code
!
!     For each element (group) flagged with SET(R), compute the new value
!     using dynk_computeFUN() at the given (shifted) turn number
!     using the specified FUN function. The values are stored 
!     in the element using dynk_setvalue().
!     
!     Also resets the values at the beginning of each pass through the
!     turn loop (for COLLIMATION).
!
!     Also writes the file "dynksets.dat", only on the first turn.
!-----------------------------------------------------------------------
      implicit none

+ca crcoall
+ca parpro
+ca parnum
+ca common
+ca commonmn
+ca commontr
+ca stringzerotrim
+ca comdynk
+if cr
+ca comdynkcr
+ei

+if collimat
+ca collpara
+ca dbcommon
+ei

!     interface variables
      integer turn  ! current turn number
      intent(in) turn

!     temporary variables
      integer ii, jj, shiftedTurn
      logical lopen
!     functions
      double precision dynk_computeFUN
      integer dynk_findSETindex
      
      double precision dynk_getvalue, getvaldata, newValue
      
      character(maxstrlen_dynk) whichFUN(maxsets_dynk) !Which function was used to set a given elem/attr?
      integer whichSET(maxsets_dynk) !Which SET was used for a given elem/attr?

      if ( ldynkdebug ) then
         write (lout,*)
     &   'DYNKDEBUG> In dynk_apply(), turn = ',
+if collimat
     & turn, "samplenumber =", samplenumber
+ei
+if .not.collimat
     & turn
+ei
      end if
      
      !Initialize variables (every call)
      do jj=1, nsets_unique_dynk
         whichSET(jj) = -1
         do ii=1,maxstrlen_dynk
            whichFUN(jj)(ii:ii) = char(0)
         enddo
      enddo

      !First-turn initialization, including some parts which are specific for collimat.
      if (turn .eq. 1) then
         ! Reset RNGs and filters 
         do ii=1, nfuncs_dynk
            if (funcs_dynk(ii,2) .eq. 6) then !RANDG
               if (ldynkdebug) then
                  write (lout,*) 
     &               "DYNKDEBUG> Resetting RANDG for FUN named '",
     & trim(stringzerotrim( cexpr_dynk(funcs_dynk(ii,1)) )), "'"
               endif

               iexpr_dynk(funcs_dynk(ii,3)+3) =
     &              iexpr_dynk(funcs_dynk(ii,3) )
               iexpr_dynk(funcs_dynk(ii,3)+4) =
     &              iexpr_dynk(funcs_dynk(ii,3)+1)
               
            else if (funcs_dynk(ii,2) .eq. 7) then !RANDU
               if (ldynkdebug) then
                  write (lout,*) 
     &               "DYNKDEBUG> Resetting RANDU for FUN named '",
     & trim(stringzerotrim( cexpr_dynk(funcs_dynk(ii,1)) )), "'"
               endif

               iexpr_dynk(funcs_dynk(ii,3)+2) =
     &              iexpr_dynk(funcs_dynk(ii,3) )
               iexpr_dynk(funcs_dynk(ii,3)+3) =
     &              iexpr_dynk(funcs_dynk(ii,3)+1)

            else if (funcs_dynk(ii,2) .eq. 8) then !RANDON
               if (ldynkdebug) then
                  write (lout,*) 
     &               "DYNKDEBUG> Resetting RANDON for FUN named '",
     & trim(stringzerotrim( cexpr_dynk(funcs_dynk(ii,1)) )), "'"
               endif

               iexpr_dynk(funcs_dynk(ii,3)+2) =
     &              iexpr_dynk(funcs_dynk(ii,3) )
               iexpr_dynk(funcs_dynk(ii,3)+3) =
     &              iexpr_dynk(funcs_dynk(ii,3)+1)

            else if (funcs_dynk(ii,2) .eq. 10) then !FIR
               if (ldynkdebug) then
                  write (lout,*)
     &               "DYNKDEBUG> Resetting FIR named '",
     & trim(stringzerotrim( cexpr_dynk(funcs_dynk(ii,1)) )), "'"
               endif
               do jj=0, funcs_dynk(ii,4)
                  fexpr_dynk(funcs_dynk(ii,3)+jj*3+1) =
     &                 fexpr_dynk(funcs_dynk(ii,3)+jj*3+2)
               enddo
            else if (funcs_dynk(ii,2) .eq. 11) then !IIR
               if (ldynkdebug) then
                  write (lout,*)
     &               "DYNKDEBUG> Resetting IIR named '",
     & trim(stringzerotrim( cexpr_dynk(funcs_dynk(ii,1)) )), "'"
               endif
               do jj=0, funcs_dynk(ii,4)
                  fexpr_dynk(funcs_dynk(ii,3)+jj*6+1) =
     &                 fexpr_dynk(funcs_dynk(ii,3)+jj*6+2)
                  fexpr_dynk(funcs_dynk(ii,3)+jj*6+4) =
     &                 fexpr_dynk(funcs_dynk(ii,3)+jj*6+5)
               enddo
            endif
            
         enddo

         !Open dynksets.dat
+if collimat
         if (samplenumber.eq.1) then
+ei
+if cr
         ! Could have loaded a CR just before tracking starts;
         ! In this case, the dynksets is already open and positioned,
         ! so don't try to open the file again.
         if (dynkfilepos .eq.-1) then
+ei
            inquire( unit=665, opened=lopen )
            if (lopen) then
               write(lout,*) "DYNK> **** ERROR in dynk_apply() ****"
               write(lout,*) "DYNK> unit 665 for dynksets.dat"//
     &                       " was already taken"
              call prror(-1)
            end if
            open(unit=665, file="dynksets.dat",
     &           status="replace",action="write") 

            if (ldynkfiledisable) then
               write (665,*) "### DYNK file output was disabled ",
     &                       "with flag NOFILE in fort.3 ###"
            else 
               write(665,*)
     &              "# turn element attribute SETidx funname value"
            endif
+if cr
            !Note: To be able to reposition, each line should be shorter than 255 chars
            dynkfilepos = 1
            
            ! Flush the unit
            endfile (665,iostat=ierro)
            backspace (665,iostat=ierro)
+ei
+if collimat
         endif
+ei
+if cr
         endif
+ei
 
+if collimat
         ! Reset values to original settings in turn 1 
         if (samplenumber.gt.1) then
            if (ldynkdebug) then
               write (lout,*) "DYNKDEBUG> New collimat sample, ",
     &            "samplenumber = ", samplenumber,
     &                     "resetting the SET'ed values."
            endif
            do ii=1, nsets_unique_dynk
               newValue = fsets_origvalue_dynk(ii)
               if (ldynkdebug) then
                  write (lout,*) "DYNKDEBUG> Resetting: '",
     &         trim(stringzerotrim(csets_unique_dynk(ii,1))),
     &         "':'",trim(stringzerotrim(csets_unique_dynk(ii,2))),
     &         "', newValue=", newValue
               endif

               call dynk_setvalue(csets_unique_dynk(ii,1),
     &                            csets_unique_dynk(ii,2),
     &                            newValue )
            enddo
         endif
+ei
      endif
      
      !Apply the sets
      do ii=1,nsets_dynk
         ! Sanity check already confirms that only a single SET
         ! is active on a given element:attribute on a given turn.
         
         !Active in this turn?
         if (turn .ge. sets_dynk(ii,2) .and.
     &       ( turn .le. sets_dynk(ii,3) .or. 
     &         sets_dynk(ii,3) .eq. -1       ) ) then
            
            !Shifting
            shiftedTurn = turn + sets_dynk(ii,4)
            
            !Set the value
            newValue = dynk_computeFUN(sets_dynk(ii,1),shiftedTurn)
            if (ldynkdebug) then
               write (lout, '(1x,A,I5,A,I8,A,E16.9)')
     &              "DYNKDEBUG> Applying set #", ii, " on '"//
     &           trim(stringzerotrim(csets_dynk(ii,1)))//
     &           "':'"// trim(stringzerotrim(csets_dynk(ii,2)))//
     &           "', shiftedTurn=",shiftedTurn,", value=",newValue
            endif
            call dynk_setvalue(csets_dynk(ii,1),
     &                         csets_dynk(ii,2),
     &                         newValue)
     &           
            
            if (ldynkdebug) then
               getvaldata = dynk_getvalue( csets_dynk(ii,1), 
     &                                     csets_dynk(ii,2) )
               write (lout, '(1x,A,E16.9)')
     &              "DYNKDEBUG> Read back value = ", getvaldata

               if (getvaldata .ne. newValue) then
                  write(lout,*)
     &            "DYNKDEBUG> WARNING Read back value differs from set!"
               end if
            endif
            
            !For the output file: Which function was used?
            do jj=1, nsets_unique_dynk
               if (csets_dynk(ii,1) .eq. csets_unique_dynk(jj,1) .and.
     &             csets_dynk(ii,2) .eq. csets_unique_dynk(jj,2) ) then
                  whichSET(jj)=ii
                  whichFUN(jj)=cexpr_dynk(funcs_dynk(sets_dynk(ii,1),1))
               endif
            enddo
         end if
      end do
      
      !Write output file
+if collimat
      if (samplenumber.eq.1 .and..not.ldynkfiledisable) then
+ei
+if .not.collimat
      if (.not.ldynkfiledisable) then
+ei
         do jj=1,nsets_unique_dynk
            getvaldata =  dynk_getvalue( csets_unique_dynk(jj,1),
     &                                   csets_unique_dynk(jj,2) )
            
            if (whichSET(jj) .eq. -1) then
               whichFUN(jj) = "N/A"
            endif
            
            write(665,'(I12,1x,A,1x,A,1x,I4,1x,A,E16.9)')
     &           turn, 
     &           stringzerotrim(csets_unique_dynk(jj,1)),
     &           stringzerotrim(csets_unique_dynk(jj,2)),
     &           whichSET(jj),
     &           stringzerotrim(whichFUN(jj)),
     &           getvaldata
         enddo
         
+if cr
         !Note: To be able to reposition, each line should be shorter than 255 chars
         dynkfilepos = dynkfilepos+nsets_unique_dynk
+ei
         !Flush the unit
         endfile (665,iostat=ierro)
         backspace (665,iostat=ierro)

      endif

      end subroutine
!
      
      recursive double precision function 
     &     dynk_computeFUN( funNum, turn ) result(retval)
!-----------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 17-10-2014
!     Compute the value of a given DYNK function (funNum) for the given turn
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca stringzerotrim
+ca comdynk
      integer funNum, turn
      intent (in) funNum, turn
      
      !Functions to call
      double precision dynk_lininterp
+if crlibm
      double precision round_near
+ei

+if crlibm
+ca crlibco
+ei
+ca crcoall
      
      ! Temporaries for FILELIN
      integer filelin_start, filelin_xypoints
      
      ! Temporaries for random generator functions
      integer tmpseed1, tmpseed2
      double precision ranecu_rvec(1)
      
      ! General temporaries
      integer foff !base offset into fexpr array
      integer ii,jj!Loop variable

+if crlibm
      !String handling tempraries for PIPE, preformatting for round_near
      integer errno !for round_near
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
+ca comgetfields
+ei

      ! Other stuff
+ca parnum
      double precision pi
      !This is how it is done in the rest of the code...
+if crlibm
      pi = 4d0*atan_rn(1d0)
+ei
+if .not.crlibm
      pi = 4d0*atan(1d0)
+ei
      
      if (funNum .lt. 1 .or. funNum .gt. nfuncs_dynk) then
         write(lout,*) "DYNK> **** ERROR in dynk_computeFUN() ****"
         write(lout,*) "DYNK> funNum =", funNum
         write(lout,*) "DYNK> Invalid funNum, nfuncs_dynk=", nfuncs_dynk
         call dynk_dumpdata
         call prror(-1)
      endif
      
      select case ( funcs_dynk(funNum,2) )                              ! WHICH FUNCTION TYPE?
      case (0)                                                          ! GET
         retval = fexpr_dynk(funcs_dynk(funNum,3))
      case (1)                                                          ! FILE
         if (turn .gt. funcs_dynk(funNum,5) ) then
            write(lout,*)"DYNK> ****ERROR in dynk_computeFUN():FILE****"
            write(lout,*)"DYNK> funNum =", funNum, "turn=", turn
            write(lout,*)"DYNK> Turn > length of file = ", 
     &           funcs_dynk(funNum,5)
            call dynk_dumpdata
            call prror(-1)
         elseif (turn .lt. 1) then
            write(lout,*)"DYNK> ****ERROR in dynk_computeFUN():FILE****"
            write(lout,*)"DYNK> funNum =", funNum, "turn=", turn
            write(lout,*)"DYNK> Turn < 1, check your turn-shift!"
            call dynk_dumpdata
            call prror(-1)
         endif

         retval = fexpr_dynk(funcs_dynk(funNum,4)+turn-1)
      case(2)                                                           ! FILELIN
         filelin_start    = funcs_dynk(funNum,4)
         filelin_xypoints = funcs_dynk(funNum,5)
         !Pass the correct array views/sections to dynk_lininterp
         retval = dynk_lininterp( dble(turn),
     &       fexpr_dynk(filelin_start:filelin_start+filelin_xypoints-1),
     &       fexpr_dynk(filelin_start +  filelin_xypoints:
     &                  filelin_start +2*filelin_xypoints-1),
     &        filelin_xypoints )
      case(3)                                                           ! PIPE
         write(iexpr_dynk(funcs_dynk(funNum,3))+1,"(a,i7)") 
     &        "GET ID="//
     &        trim(stringzerotrim(
     &        cexpr_dynk(funcs_dynk(funNum,1)+3)
     &        ))//" TURN=",turn
+if .not.crlibm
         read(iexpr_dynk(funcs_dynk(funNum,3)),*) retval
+ei
+if crlibm
         read(iexpr_dynk(funcs_dynk(funNum,3)),"(a)") ch
         call getfields_split( ch, getfields_fields, getfields_lfields,
     &                             getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) then
            write(lout,*)"DYNK> ****ERROR in dynk_computeFUN():PIPE****"
            write(lout,*)"DYNK> getfields_lerr=", getfields_lerr
            call prror(-1)
         endif
         if (getfields_nfields .ne. 1) then
            write(lout,*)"DYNK> ****ERROR in dynk_computeFUN():PIPE****"
            write(lout,*)"DYNK> getfields_nfields=", getfields_nfields
            write(lout,*)"DYNK> Expected a single number."
            call prror(-1)
         endif
         retval = round_near(errno,
     &        getfields_lfields(1)+1, getfields_fields(1) )
         if (errno.ne.0)
     &        call rounderr( errno,getfields_fields,1,retval )
+ei
         
      case (6)                                                          ! RANDG
         ! Save old seeds and load our current seeds
         call recuut(tmpseed1,tmpseed2)
         call recuin(iexpr_dynk(funcs_dynk(funNum,3)+3),
     &               iexpr_dynk(funcs_dynk(funNum,3)+4) )
         ! Run generator for 1 value with current mcut
         call ranecu( ranecu_rvec, 1,
     &                iexpr_dynk(funcs_dynk(funNum,3)+2) )
         ! Save our current seeds and load old seeds
         call recuut(iexpr_dynk(funcs_dynk(funNum,3)+3),
     &               iexpr_dynk(funcs_dynk(funNum,3)+4) )
         call recuin(tmpseed1,tmpseed2)
         ! Change to mu, sigma
         retval = fexpr_dynk(funcs_dynk(funNum,4))
     &          + fexpr_dynk(funcs_dynk(funNum,4)+1)*ranecu_rvec(1)

      case (7)                                                          ! RANDU
         ! Save old seeds and load our current seeds
         call recuut(tmpseed1,tmpseed2)
         call recuin(iexpr_dynk(funcs_dynk(funNum,3)+2),
     &               iexpr_dynk(funcs_dynk(funNum,3)+3) )
         ! Run generator for 1 value with mcut=-1
         call ranecu( ranecu_rvec, 1, -1 )
         ! Save our current seeds and load old seeds
         call recuut(iexpr_dynk(funcs_dynk(funNum,3)+2),
     &               iexpr_dynk(funcs_dynk(funNum,3)+3) )
         call recuin(tmpseed1,tmpseed2)
         retval = ranecu_rvec(1)

      case (8)                                                         ! RANDON
        ! Save old seeds and load our current seeds
         call recuut(tmpseed1,tmpseed2)
         call recuin(iexpr_dynk(funcs_dynk(funNum,3)+2),
     &               iexpr_dynk(funcs_dynk(funNum,3)+3) )
         ! Run generator for 1 value with mcut=-1
         call ranecu( ranecu_rvec, 1, -1 )
         ! Save our current seeds and load old seeds
         call recuut(iexpr_dynk(funcs_dynk(funNum,3)+2),
     &               iexpr_dynk(funcs_dynk(funNum,3)+3) )
         call recuin(tmpseed1,tmpseed2)
	! routine for switching element (orginially the electron lens) ON or OFF
        ! when random value is less than P, set ON, else OFF 
         if (ranecu_rvec(1) .lt. fexpr_dynk(funcs_dynk(funNum,4))) then 
            retval = 1.0
         else 
            retval = 0.0
         endif

      case(10)                                                          ! FIR
         foff = funcs_dynk(funNum,3)
         !Shift storage 1 back
         do ii=funcs_dynk(funNum,4)-1,0,-1
            jj = ii*3
            fexpr_dynk(foff+jj+4) = fexpr_dynk(foff+jj+1)
         enddo
         !Evaluate the next input function
         fexpr_dynk(foff+1) = dynk_computeFUN(funcs_dynk(funNum,5),turn)
         !Compute the filtered value
         retval = 0.0
         do ii=0,funcs_dynk(funNum,4)
            jj = ii*3
            retval = retval + 
     &           fexpr_dynk(foff+jj)*fexpr_dynk(foff+jj+1)
         enddo
      case(11)                                                          ! IIR
         foff = funcs_dynk(funNum,3)
         !Shift storage 1 back
         do ii=funcs_dynk(funNum,4)-1,0,-1
            jj = ii*6
            fexpr_dynk(foff+jj+7) = fexpr_dynk(foff+jj+1)
            fexpr_dynk(foff+jj+10) = fexpr_dynk(foff+jj+4)
         enddo
         !Evaluate the next input function
         fexpr_dynk(foff+1) = dynk_computeFUN(funcs_dynk(funNum,5),turn)
         fexpr_dynk(foff+4) = 0.0
         !Compute the filtered value
         retval = 0.0
         do ii=0,funcs_dynk(funNum,4)
            jj = ii*6
            retval = retval +
     &           fexpr_dynk(foff+jj  ) * fexpr_dynk(foff+jj+1) +
     &           fexpr_dynk(foff+jj+3) * fexpr_dynk(foff+jj+4)
         enddo
         !To be shifted at the next evaluation
         fexpr_dynk(foff+4) = retval
         
      case (20)                                                         ! ADD
         retval = dynk_computeFUN(funcs_dynk(funNum,3),turn)
     &          + dynk_computeFUN(funcs_dynk(funNum,4),turn)
      case (21)                                                         ! SUB
         retval = dynk_computeFUN(funcs_dynk(funNum,3),turn)
     &          - dynk_computeFUN(funcs_dynk(funNum,4),turn)
      case (22)                                                         ! MUL
         retval = dynk_computeFUN(funcs_dynk(funNum,3),turn)
     &          * dynk_computeFUN(funcs_dynk(funNum,4),turn)
      case (23)                                                         ! DIV
         retval = dynk_computeFUN(funcs_dynk(funNum,3),turn)
     &          / dynk_computeFUN(funcs_dynk(funNum,4),turn)
      case (24)                                                         ! POW
         retval = dynk_computeFUN(funcs_dynk(funNum,3),turn)
     &         ** dynk_computeFUN(funcs_dynk(funNum,4),turn)
         
      case (30)                                                         ! MINUS
         retval = (-1)*dynk_computeFUN(funcs_dynk(funNum,3),turn)
      case (31)                                                         ! SQRT
C+if crlibm
C      retval = sqrt_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
C+ei
C+if .not.crlibm      
      retval = sqrt(dynk_computeFUN(funcs_dynk(funNum,3),turn))
C+ei
      case (32)                                                         ! SIN
+if crlibm
         retval = sin_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
+if .not.crlibm
         retval = sin(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
      case (33)                                                         ! COS
+if crlibm
         retval = cos_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
+if .not.crlibm
         retval = cos(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
      case (34)                                                         ! LOG
+if crlibm
         retval = log_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
+if .not.crlibm
         retval = log(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
      case (35)                                                         ! LOG10
+if crlibm
         retval = log10_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
+if .not.crlibm
         retval = log10(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
      case (36)                                                         ! EXP
+if crlibm
         retval = exp_rn(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
+if .not.crlibm
         retval = exp(dynk_computeFUN(funcs_dynk(funNum,3),turn))
+ei
      
      case (40)                                                         ! CONST
         retval = fexpr_dynk(funcs_dynk(funNum,3))
      case (41)                                                         ! TURN
         retval = turn
      case (42)                                                         ! LIN
         retval = turn*fexpr_dynk(funcs_dynk(funNum,3)) + 
     &                 fexpr_dynk(funcs_dynk(funNum,3)+1)
      case (43)                                                         ! LINSEG
         filelin_start    = funcs_dynk(funNum,3)
         filelin_xypoints = 2
         !Pass the correct array views/sections to dynk_lininterp
         retval = dynk_lininterp( dble(turn),
     &       fexpr_dynk(filelin_start:filelin_start+1),
     &       fexpr_dynk(filelin_start+2:filelin_xypoints+3),
     &       filelin_xypoints )
      case (44,45)                                                      ! QUAD/QUADSEG
         retval = (turn**2)*fexpr_dynk(funcs_dynk(funNum,3))   + (
     &                 turn*fexpr_dynk(funcs_dynk(funNum,3)+1) +
     &                      fexpr_dynk(funcs_dynk(funNum,3)+2) )

      case (60)                                                         ! SINF
+if crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     &     * SIN_RN( fexpr_dynk(funcs_dynk(funNum,3)+1) * turn 
     &             + fexpr_dynk(funcs_dynk(funNum,3)+2) )

+ei
+if .not.crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     &     * SIN( fexpr_dynk(funcs_dynk(funNum,3)+1) * turn 
     &          + fexpr_dynk(funcs_dynk(funNum,3)+2) )
+ei
      case (61)                                                         ! COSF
+if crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     &     * COS_RN( fexpr_dynk(funcs_dynk(funNum,3)+1) * turn 
     &             + fexpr_dynk(funcs_dynk(funNum,3)+2) )

+ei
+if .not.crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     &     * COS( fexpr_dynk(funcs_dynk(funNum,3)+1) * turn 
     &          + fexpr_dynk(funcs_dynk(funNum,3)+2) )
+ei
      case (62)                                                         ! COSF_RIPP
+if crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     & *COS_RN( (two*pi)*dble(turn-1)/fexpr_dynk(funcs_dynk(funNum,3)+1)
     &             + fexpr_dynk(funcs_dynk(funNum,3)+2) )
+ei
+if .not.crlibm
      retval = fexpr_dynk(funcs_dynk(funNum,3))
     & *COS   ( (two*pi)*dble(turn-1)/fexpr_dynk(funcs_dynk(funNum,3)+1)
     &             + fexpr_dynk(funcs_dynk(funNum,3)+2) )
+ei
      
      case (80)                                                         ! PELP
         foff = funcs_dynk(funNum,3)
         if (turn .le. fexpr_dynk(foff)) then ! <= tinj
            ! Constant Iinj
            retval = fexpr_dynk(foff+5)
         elseif (turn .le. fexpr_dynk(foff+1)) then ! <= te
            ! Parabola (accelerate)
            retval = ( fexpr_dynk(foff+6) *
     &                 (turn-fexpr_dynk(foff))**2 ) / 2.0
     &             + fexpr_dynk(foff+5)
         elseif (turn .le. fexpr_dynk(foff+2)) then ! <= t1
            ! Exponential
            retval = fexpr_dynk(foff+7) *
     &          exp( fexpr_dynk(foff+8)*turn )
         elseif (turn .le. fexpr_dynk(foff+3)) then ! <= td
            ! Linear (max ramp rate)
            retval = fexpr_dynk(foff+10) *
     &               (turn-fexpr_dynk(foff+2))
     &             + fexpr_dynk(foff+9)
         elseif (turn .le. fexpr_dynk(foff+4)) then ! <= tnom
            ! Parabola (decelerate)
            retval =  - ( (fexpr_dynk(foff+11) *
     &                    (fexpr_dynk(foff+4)-turn)**2) ) / 2.0
     &                + fexpr_dynk(foff+12)
         else ! > tnom
            ! Constant Inom
            retval = fexpr_dynk(foff+12)
         endif

      case (81)                                                         ! ONOFF
         ii=mod(turn-1,funcs_dynk(funNum,4))
         if (ii .lt. funcs_dynk(funNum,3)) then
            retval = 1.0
         else
            retval = 0.0
         endif
         
      case default
         write(lout,*) "DYNK> **** ERROR in dynk_computeFUN(): ****"
         write(lout,*) "DYNK> funNum =", funNum, "turn=", turn
         write(lout,*) "DYNK> Unknown function type ",
     &        funcs_dynk(funNum,2)
         call dynk_dumpdata
         call prror(-1)
      end select

      end function
      
      subroutine dynk_setvalue(element_name, att_name, newValue)
!-----------------------------------------------------------------------
!     A.Santamaria & K.Sjobak, BE-ABP/HSS
!     last modified: 31-10-2014
!     Set the value of the element's attribute
!-----------------------------------------------------------------------
      implicit none

+ca parpro
+ca parnum
+ca common
+ca commonmn
+ca commonm1
+ca commontr
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca crcoall

      character(maxstrlen_dynk) element_name, att_name
      double precision newValue
      intent (in) element_name, att_name, newValue
      !Functions
      ! temp variables
      integer el_type, ii, j
      character(maxstrlen_dynk) element_name_stripped
      character(maxstrlen_dynk) att_name_stripped
      ! For sanity check
      logical ldoubleElement
      ldoubleElement = .false.
      
      element_name_stripped = trim(stringzerotrim(element_name))
      att_name_stripped = trim(stringzerotrim(att_name))

      if ( ldynkdebug ) then
         write (lout, '(1x,A,E16.9)')
     &        "DYNKDEBUG> In dynk_setvalue(), element_name = '"//
     &        trim(element_name_stripped)//"', att_name = '"//
     &        trim(att_name_stripped)//"', newValue =", newValue
      endif
      
C     Here comes the logic for setting the value of the attribute for all instances of the element...

      ! Special non-physical elements
      if (element_name_stripped .eq. "GLOBAL-VARS") then
         if (att_name_stripped .eq. "E0" ) then
            ! Modify the reference particle
            e0 = newValue
            e0f = sqrt(e0**2 - pma**2)
            gammar = pma/e0
            ! Modify the Energy
            do j = 1, napx
              dpsv(j) = (ejfv(j) - e0f)/e0f
              dpsv1(j) = (dpsv(j)*c1e3)/(one + dpsv(j))
              dpd(j) = one + dpsv(j)
              dpsq(j) = sqrt(dpd(j))
              oidpsv(j) = one/(one + dpsv(j))
              rvv(j) = (ejv(j)*e0f)/(e0*ejfv(j))
            enddo
         endif
         ldoubleElement = .true.
      endif
      
      ! Normal SINGLE ELEMENTs
      do ii=1,il
         ! TODO: Here one could find the right ii in dynk_pretrack,
         ! and then avoid this loop / string-comparison
         if (element_name_stripped.eq.bez(ii)) then ! name found
            el_type=kz(ii)      ! type found
            
            if (ldoubleElement) then ! Sanity check
               write(lout,*)
     &            "DYNK> ERROR: two elements with the same BEZ?"
               call prror(-1)
            end if
            ldoubleElement = .true.
          
            if ((abs(el_type).eq.1).or. ! horizontal bending kick
     &          (abs(el_type).eq.2).or. ! quadrupole kick
     &          (abs(el_type).eq.3).or. ! sextupole kick
     &          (abs(el_type).eq.4).or. ! octupole kick
     &          (abs(el_type).eq.5).or. ! decapole kick
     &          (abs(el_type).eq.6).or. ! dodecapole kick
     &          (abs(el_type).eq.7).or. ! 14th pole kick
     &          (abs(el_type).eq.8).or. ! 16th pole kick
     &          (abs(el_type).eq.9).or. ! 18th pole kick
     &          (abs(el_type).eq.10)) then ! 20th pole kick
               
               if (att_name_stripped.eq."average_ms") then !
                  ed(ii) = newValue
               else
                  goto 100 !ERROR
               endif
               call initialize_element(ii, .false.)
               
          !Not yet supported
c$$$            elseif (abs(el_type).eq.11) then !MULTIPOLES
c$$$               if (att_name_stripped.eq."bending_str") then
c$$$                  ed(ii) = newValue
c$$$               else
c$$$                  goto 100 !ERROR
c$$$               endif
c$$$               call initialize_element(ii, .false.)


          elseif (abs(el_type).eq.12) then ! cavities 
            if (att_name_stripped.eq."voltage") then ! [MV]
               ed(ii) = newValue
            elseif (att_name_stripped.eq."harmonic") then !
               ek(ii) = newValue
               el(ii) = dynk_elemdata(ii,3) !Need to reset el before calling initialize_element()
               call initialize_element(ii, .false.)
            elseif (att_name_stripped.eq."lag_angle") then ! [deg]
               el(ii) = newValue
               ! Note: el is set to 0 in initialize_element and in daten.
               !  Calling initialize element on a cavity without setting el
               !  will set phasc = 0!
               call initialize_element(ii, .false.)
            else
               goto 100 !ERROR
            endif
            
          !Not yet supported
c$$$          elseif (abs(el_type).eq.16) then ! AC dipole 
c$$$            if (att_name_stripped.eq."amplitude") then ! [T.m]
c$$$               ed(ii) = dynk_computeFUN(funNum,turn)
c$$$            elseif (att_name_stripped.eq."frequency") then ! [2pi]
c$$$               ek(ii) = dynk_computeFUN(funNum,turn)
c$$$            elseif (att_name_stripped.eq."phase") then ! [rad]
c$$$               el(ii) = dynk_computeFUN(funNum,turn)
c$$$            else
c$$$               goto 100 !ERROR
c$$$            endif

          !Not yet supported
c$$$          elseif (abs(el_type).eq.20) then ! beam-beam separation
c$$$            if (att_name_stripped.eq."horizontal") then ! [mm]
c$$$               ed(ii) = dynk_computeFUN(funNum,turn)
c$$$            elseif (att_name_stripped.eq."vertical") then ! [mm]
c$$$               ek(ii) = dynk_computeFUN(funNum,turn)
c$$$            elseif (att_name_stripped.eq."strength") then ! [m]
c$$$               el(ii) = dynk_computeFUN(funNum,turn)
c$$$            else
c$$$               goto 100 !ERROR
c$$$            endif
            
            elseif ((abs(el_type).eq.23).or.    ! crab cavity
     &              (abs(el_type).eq.26).or.    ! cc mult. kick order 2
     &              (abs(el_type).eq.27).or.    ! cc mult. kick order 3
     &              (abs(el_type).eq.28)) then  ! cc mult. kick order 4
               if (att_name_stripped.eq."voltage") then ![MV]
                  ed(ii) = newValue
               elseif (att_name_stripped.eq."frequency") then ![MHz]
                  ek(ii) = newValue
               elseif (att_name_stripped.eq."phase") then ![rad]
                  el(ii) = newValue ! Note: el is set to 0 in initialize_element and in daten.
                                    ! Calling initialize element on a crab without setting el
                                    ! will set crabph = 0!
                  call initialize_element(ii, .false.)
               else
                  goto 100 !ERROR
               endif
               
            elseif (el_type.eq.29) then          ! Electron lens
               if (att_name_stripped.eq."thetamax") then ![mrad]
                  elens_theta_max(ii) = newValue
               else
                  goto 100 !ERROR
               endif
               
            else
               WRITE (lout,*) "DYNK> *** ERROR in dynk_setvalue() ***"
               write (lout,*) "DYNK> Unsupported element type", el_type
               write (lout,*) "DYNK> element name = '",
     &              element_name_stripped,"'"
               call prror(-1)
            endif
         endif
      enddo
      
      !Sanity check
      if (.not.ldoubleElement) then
         goto 101
      endif

      return
      
      !Error handlers
 100  continue
      WRITE (lout,*)"DYNK> *** ERROR in dynk_setvalue() ***"
      WRITE (lout,*)"DYNK> Attribute'", att_name_stripped,
     &     "' does not exist for type =", el_type
      call prror(-1)

 101  continue
      WRITE (lout,*)"DYNK> *** ERROR in dynk_setvalue() ***"
      WRITE (lout,*)"DYNK> The element named '",element_name_stripped,
     &     "' was not found."
      call prror(-1)
      
      end subroutine

      double precision function dynk_getvalue (element_name, att_name)
!-----------------------------------------------------------------------
!     A.Santamaria & K. Sjobak, BE-ABP/HSS
!     last modified: 2101-2015
!
!     Returns the original value currently set by an element.
!     
!     Note: Expects that arguments element_name and att_name are
!     zero-terminated strings of length maxstrlen_dynk!
!-----------------------------------------------------------------------
      implicit none
+ca parpro
+ca parnum
+ca common
+ca commonmn
+ca commontr
+ca stringzerotrim
+ca comdynk
+ca elensparam
+ca crcoall

      character(maxstrlen_dynk) element_name, att_name
      intent(in) element_name, att_name
      
      integer el_type, ii
      character(maxstrlen_dynk) element_name_s, att_name_s
      
      logical ldoubleElement
      ldoubleElement = .false.  ! For sanity check
      
      element_name_s = trim(stringzerotrim(element_name))
      att_name_s = trim(stringzerotrim(att_name))
      
      if (ldynkdebug) then
         write(lout,*)
     &   "DYNKDEBUG> In dynk_getvalue(), element_name = '"//
     &    trim(element_name_s)//"', att_name = '"//trim(att_name_s)//"'"
      end if

      ! Special non-physical elements
      if (element_name_s .eq. "GLOBAL-VARS") then
         if (att_name_s .eq. "E0" ) then
            ! Return the energy
            dynk_getvalue = e0
         endif
         ldoubleElement = .true.
      endif
      
      ! Normal SINGLE ELEMENTs
      do ii=1,il
         ! TODO: Here one could find the right ii in dynk_pretrack,
         ! and then avoid this loop / string-comparison
         if (element_name_s.eq.bez(ii)) then ! name found
            el_type=kz(ii)
            if (ldoubleElement) then
               write (lout,*)
     &              "DYNK> ERROR: two elements with the same BEZ"
               call prror(-1)
            end if
            ldoubleElement = .true.
            
            ! Nonlinear elements
            if ((abs(el_type).eq.1).or.
     &          (abs(el_type).eq.2).or.
     &          (abs(el_type).eq.3).or.
     &          (abs(el_type).eq.4).or.
     &          (abs(el_type).eq.5).or.
     &          (abs(el_type).eq.6).or.
     &          (abs(el_type).eq.7).or.
     &          (abs(el_type).eq.8).or.
     &          (abs(el_type).eq.9).or.
     &          (abs(el_type).eq.10)) then
               if (att_name_s.eq."average_ms") then
                  dynk_getvalue = ed(ii)
               else
                  goto 100 !ERROR
               endif
               
c$$$            !Multipoles (Not yet supported)
c$$$            elseif (abs(el_type).eq.11) then
c$$$               if (att_name_s.eq."bending_str") then 
c$$$                  dynk_getvalue = dynk_elemdata(ii,2)
c$$$               elseif (att_name_s.eq."radius") then
c$$$                  dynk_getvalue = dynk_elemdata(ii,3)
c$$$               else
c$$$                  goto 100 !ERROR
c$$$               endif
               

            elseif (abs(el_type).eq.12) then ! cavities
               if     (att_name_s.eq."voltage"  ) then ! MV
                  dynk_getvalue = ed(ii)
               elseif (att_name_s.eq."harmonic" ) then ! harmonic number
                  dynk_getvalue = ek(ii)
               elseif (att_name_s.eq."lag_angle") then ! [deg]
                  dynk_getvalue = dynk_elemdata(ii,3)
               else
                  goto 100 !ERROR
               endif
             
            !Not yet supported
c$$$            elseif (abs(el_type).eq.16) then ! AC dipole 
c$$$               if (att_name_s.eq."amplitude") then ! [T.m]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = ed(ii)                
c$$$               elseif (att_name_s.eq."frequency") then !  [2pi]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = ek(ii)                
c$$$               elseif (att_name_s.eq."phase") then !  [rad]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = el(ii)      
c$$$               else
c$$$                  goto 100 !ERROR
c$$$               endif
               
            !Not yet supported
c$$$            elseif (abs(el_type).eq.20) then ! beam-beam separation
c$$$               if (att_name_s.eq."horizontal") then ! [mm]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = ed(ii)                
c$$$               elseif (att_name_s.eq."vertical") then ! [mm]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = ek(ii)                
c$$$               elseif (att_name_s.eq."strength") then ! [m]
c$$$                  nretdata = nretdata+1
c$$$                  retdata(nretdata) = el(ii)       
c$$$               else
c$$$                  goto 100 !ERROR
c$$$               endif
               
            elseif ((abs(el_type).eq.23).or. ! crab cavity
     &              (abs(el_type).eq.26).or. ! cc mult. kick order 2
     &              (abs(el_type).eq.27).or. ! cc mult. kick order 3
     &              (abs(el_type).eq.28)) then ! cc mult. kick order 4
               if (att_name_s.eq."voltage") then ![MV]
                  dynk_getvalue = ed(ii)
               elseif (att_name_s.eq."frequency") then ![MHz]
                  dynk_getvalue = ek(ii)
               elseif (att_name_s.eq."phase") then ![rad]
                  if (abs(el_type).eq.23) then
                     dynk_getvalue = crabph(ii)
                  elseif (abs(el_type).eq.26) then
                     dynk_getvalue = crabph2(ii)
                  elseif (abs(el_type).eq.27) then
                     dynk_getvalue = crabph3(ii)
                  elseif (abs(el_type).eq.28) then
                     dynk_getvalue = crabph4(ii)
                  endif
               else
                  goto 100 !ERROR
               endif
               
            elseif (el_type.eq.29) then     ! Electron lens
               if(att_name_s.eq."thetamax") then ! [mrad]
                  dynk_getvalue = elens_theta_max(ii)
               else
                  goto 100 !ERROR
               endif
               
            endif !el_type
         endif !bez
      enddo
      
      if (ldynkdebug) then
         write(lout,*)
     &   "DYNKDEBUG> In dynk_getvalue(), returning =", dynk_getvalue
      end if

      return
      
      !Error handlers
 100  continue
      write(lout,*) "DYNK> *** ERROR in dynk_getvalue() ***"
      write(lout,*) "DYNK> Unknown attribute '", trim(att_name_s),"'",
     &     " for type",el_type," name '", trim(bez(ii)), "'"

      call prror(-1)
  
      end function
      
      double precision function dynk_lininterp(x,xvals,yvals,datalen)
      implicit none
!-----------------------------------------------------------------------
!
!     A.Mereghetti, for the FLUKA Team and K.Sjobak for BE-ABP/HSS
!     last modified: 29-10-2014
!     
!     Define a linear function with a set of x,y-coordinates xvals, yvals
!     Return this function evaluated at the point x.
!     The length of the arrays xvals and yvals should be given in datalen.
!
!     xvals should be in increasing order, if not then program is aborted.
!     If x < min(xvals) or x>max(xvals), program is aborted.
!     If datalen <= 0, program is aborted. 
!     
!-----------------------------------------------------------------------

+ca crcoall

      double precision x, xvals(*),yvals(*)
      integer datalen
      intent(in) x,xvals,yvals,datalen
      
      integer ii
      double precision dydx, y0
      
      !Sanity checks
      if (datalen .le. 0) then
         write(lout,*) "DYNK> **** ERROR in dynk_lininterp() ****"
         write(lout,*) "DYNK> datalen was 0!"

         call prror(-1)
      endif
      if ( x .lt. xvals(1) .or. x .gt. xvals(datalen) ) then
         write(lout,*) "DYNK> **** ERROR in dynk_lininterp() ****"
         write(lout,*) "x =",x, "outside range", xvals(1),xvals(datalen)
         call prror(-1)
      endif

      !Find the right indexes i1 and i2
      ! Special case: first value at first point
      if (x .eq. xvals(1)) then
         dynk_lininterp = yvals(1)
         return
      endif
      
      do ii=1, datalen-1
         if (xvals(ii) .ge. xvals(ii+1)) then
            write (lout,*) "DYNK> **** ERROR in dynk_lininterp() ****"
            write (lout,*) "DYNK> xvals should be in increasing order"
            write (lout,*) "DYNK> xvals =", xvals(:datalen)
            call prror(-1)
         endif
         
         if (x .le. xvals(ii+1)) then
            ! we're in the right interval
            dydx = (yvals(ii+1)-yvals(ii)) / (xvals(ii+1)-xvals(ii))
            y0   = yvals(ii) - dydx*xvals(ii)
            dynk_lininterp = dydx*x + y0
            return
         endif
      enddo
      
      !We didn't return yet: Something wrong
      write (lout,*) "DYNK> ****ERROR in dynk_lininterp() ****"
      write (lout,*) "DYNK> Reached the end of the function"
      write (lout,*) "DYNK> This should not happen, "//
     &               "please contact developers"
      call prror(-1)

      end function

      logical function dynk_isused(i)
!
!-----------------------------------------------------------------------
!     K. Sjobak, ABP-HSS, 23-01-2015
!     Indicates whether a structure element is in use by DYNK
!-----------------------------------------------------------------------
      
      implicit none

+ca parpro
+ca common
+ca stringzerotrim
+ca comdynk
+ca crcoall

      integer, intent(in) :: i
      integer ix,k
      character(maxstrlen_dynk) element_name_stripped

      !Sanity check
      if (i .gt. iu .or. i .le. 0) then
         write (lout,*)
     &        "Error in dynk_isused(): i=",i,"out of range"
         call prror(-1)
      endif
      ix = ic(i)-nblo
      if (i .le. 0) then
         write (lout,*)
     &        "Error in dynk_isused(): ix-nblo=",ix,"is a block?"
         call prror(-1)
      endif
      
      do k=1,nsets_dynk
         element_name_stripped =
     &        trim(stringzerotrim(csets_dynk(k,1)))
         if (bez(ix) .eq. element_name_stripped) then
            dynk_isused = .true.
            if (ldynkdebug)
     &         write(lout,*)
     &         "DYNKDEBUG> dynk_isused = TRUE, bez='"//bez(ix)//
     &         "', element_name_stripped='"//element_name_stripped//"'"
            return
         endif
      end do
      
      if (ldynkdebug) then
         write(lout,*)
     &      "DYNKDEBUG> dynk_isused = FALSE, bez='"//bez(ix)//"'"
      endif

      dynk_isused = .false.
      return
      
      end function

+dk cadcum
      subroutine cadcum
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 13-06-2014
!     calculate dcum, as done in linopt and when parsing BLOCs (daten):
!         lengths of thick lens elements are taken on the curvilinear
!         reference system; thus, no difference between the length
!         of SBENDs and the one of RBENDs, as they are both the ARC one;
!     for future needs:
!                ds=two/ed(ix)*asin(el(ix)*ed(ix)/two)
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none

+ca parpro
+ca parnum
+ca common
+ca dbdcum
+ca crcoall
      save

!     temporary variables
      double precision tmpdcum, ds
      integer ientry, jentry, kentry, ix

      write(lout,*)''
      write(lout,10010)
      write(lout,*)''
      write(lout,*)' CALL TO CADCUM'
      write(lout,*)''

!     initialise cumulative length
      tmpdcum=zero

!     loop all over the entries in the accelerator structure
      do ientry=1,iu
        ix=ic(ientry)
        if(ix.gt.nblo) then
!         SINGLE ELEMENT
          ix=ix-nblo
          if ( el(ix).gt.zero ) tmpdcum=tmpdcum+el(ix)
        else
!         BLOC: iterate over elements
          do jentry=1,mel(ix)
            kentry=mtyp(ix,jentry)
            if( el(kentry).gt.zero ) tmpdcum=tmpdcum+el(kentry)
          enddo
        endif
!       assign value of dcum
        dcum(ientry)=tmpdcum
!     go to next entry in the acclerator structure
      enddo

!     assign the last value to the closing MARKER:
      dcum(iu+1)=tmpdcum

      if ( print_dcum ) then
!       a useful printout
        write(lout,10030)'ientry','ix','name            ','dcum [m]'
        write(lout,10020) 0,-1,'START           ',dcum(0)
        do ientry=1,iu
          ix=ic(ientry)
          if(ix.gt.nblo) then
!            SINGLE ELEMENT
             ix=ix-nblo
             write(lout,10020) ientry,ix,bez(ix),dcum(ientry)
          else
!            BLOC
             write(lout,10020) ientry,ix,bezb(ix),dcum(ientry)
          endif
        enddo
        write(lout,10020) iu+1,-1,'END            ',dcum(iu+1)
        write(lout,*)     ''
      endif

!     au revoir:
      return

10010 format(132('-'))
10020 format(2(1x,i6),1x,a16,1x,f12.5)
10030 format(2(1x,a6),1x,a16,1x,a12)
      end subroutine
!
+dk linopt
      subroutine linopt(dpp)
!-----------------------------------------------------------------------
!  LINEAR PARAMETERS AT THE POSITION OF EVERY ELEMENT OR BLOCK
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,iiii,im,ium,ix,izu,j,jj,jk,jm,k,kpz,kzz,l,l1,ll,
     &nmz,nr,dj
      double precision aa,aeg,alfa,bb,benkr,beta,bexi,bezii,bl1eg,bl2eg,&
     &ci,cikve,clo0,clop0,cr,crkve,crkveuk,di00,dip00,dphi,dpp,dpp1,    &
     &dppi,dpr,dyy1,dyy2,ekk,etl,phi,phibf,pie,puf,qu,qv,qw,qwc,r0,r0a, &
     &t,xl,xs,zl,zs,quz,qvz
+if tilt
      double precision dyy11,qu1,tiltck,tiltsk
+ei
      character*16 idum
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
!
+if collimat
+ca collpara
+ca dblinopt
+ei
!
      dimension t(6,4)
      dimension beta(2),alfa(2),phibf(2),phi(2)
      dimension clo0(2),clop0(2),di00(2),dip00(2),qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(6)
      dimension cr(mmul),ci(mmul)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      data dpr/6*0d0/
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      nhmoni=0
      nvmoni=0
      nhcorr=0
      nvcorr=0
      ium=6
      pie=two*pi
      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10000)
      endif
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phibf(i)=zero
        phi(i)=zero
        clo0(i)=zero
        clop0(i)=zero
        di00(i)=zero
        dip00(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      qwc(3)=zero
      do 40 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   40 continue
      etl=zero
      dpr(1)=dpp*c1e3
      dpr(6)=one
      dpp1=dpp+ded
      call clorb(dpp1)
      do 50 l=1,2
        clo0(l)=clo(l)
   50 clop0(l)=clop(l)
      call clorb(dpp)
      do 60 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
        t(6,ll-1)=di0(l)
   60 t(6,ll)=dip0(l)
      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10050) (di0(l),dip0(l),l=1,2)
      endif
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      if(ierro.ne.0) call prror(22+ierro)
      if(ncorru.eq.0) write(lout,10040) dpp,qwc(1),qwc(2)
      call envar(dpp)
      if(ithick.eq.1) call envardis(dpp1,aeg,bl1eg,bl2eg)
!--STARTVALUES OF THE TRAJECTORIES
      do 70 l=1,2
        ll=2*l
        t(1,ll-1)=clo(l)
   70 t(1,ll)=clop(l)
      do 80 i=1,4
        do 80 j=1,4
          t(i+1,j)=ta(j,i)
   80 t(i+1,j)=ta(j,i)
      if(ncorru.eq.0) then
        write(lout,10010)
        if(iprint.eq.1) write(lout,10030)
        write(lout,10020)
        write(lout,10010)
      endif

!--START OF THE MACHINE
      idum='START'
      nr=0
+if .not.collimat.and..not.bnlelens
      call writelin(nr,idum,etl,phi,t,1,.false.)
+ei
+if collimat.or.bnlelens
      call writelin(nr,idum,etl,phi,t,1,.false.,0)
+ei
      if(ntco.ne.0) then
        if(mod(nr,ntco).eq.0) call cpltwis(idum,t,etl,phi)
      endif


!--STRUCTURE ELEMENT LOOP
      if(nt.le.0.or.nt.gt.iu) nt=iu
      izu=0
      do 500 k=1,nt
        ix=ic(k)
        if(ix.gt.nblo) goto 220 !Not a BLOCK
        if(ithick.eq.1.and.iprint.eq.1) goto 160

        jj=0 !initial idx
        dj=1 !step
        
        if (ix.le.0) then
           ix=-1*ix             !hr13
           jj=mel(ix)+1         !initial idx
           dj=-1                !step
        endif
        jm=mel(ix)
!-- Loop over elements inside the block
        do 150 j=1,jm
          jj=jj+dj       ! Subelement index of current sub=element
          jk=mtyp(ix,jj) ! Single-element index of the current sub-element
+if .not.bnlelens
          if(ithick.eq.1.and.kz(jk).ne.0) goto 120
+ei
+if bnlelens
!GRDRHIC
          if(ithick.eq.1.and.kz(jk).ne.0) then
             call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
             goto 120
          endif
!GRDRHIC
+ei

          if(ithick.eq.0.and.kz(jk).ne.0) then
            etl=etl+el(jk)
            
c$$$            nr=nr+1
c$$$+if .not.collimat.and..not.bnlelens
c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
c$$$+ei
c$$$+if collimat.or.bnlelens
c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
c$$$+ei
c$$$            if(ntco.ne.0) then
c$$$              if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl,phi)
c$$$            endif
            
            write(lout,*) "ERROR in LINOPT:"
            write(lout,*) "In block ", bezb(ix),
     &           "found a thick non-drift element",
     &           bez(jk), "while ithick=1. This should not be possible!"
            call prror(-1)
            goto 500
          endif

!--IN BLOCK: PURE DRIFTLENGTH (above: If ITHICK=1 and kz!=0, goto 120->MAGNETELEMENT)
          etl=etl+el(jk)
          do 100 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=pi2
            endif
            do 100 i=1,ium
  100     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 110 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=pi2-phibf(l)
            endif
            if((-1d0*dphi).gt.pieni) dphi=dphi+pi                        !hr06
  110     phi(l)=phi(l)+dphi/pie

          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
          
          goto 150

!--IN BLOCK: MAGNETELEMENT
  120     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=zero
            endif
            puf=t(6,ll-1)
         t(6,ll-1)=(((((aeg(jk,l,1)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,2)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,5)*dpp1*c1e3)- a(jk,l,1)*t          &!hr06
     &(1,ll-1))-a(jk,l,2)*t(1,ll))- a(jk,l,5)*dpr(1))/ded                !hr06
           t(6,ll)=(((((aeg(jk,l,3)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,4)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,6)*dpp1*c1e3)- a(jk,l,3)*t          &!hr06
     &(1,ll-1))-a(jk,l,4)*t(1,ll))- a(jk,l,6)*dpr(1))/ded                !hr06
            do i=1,ium-1
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=-1d0*phibf(l)                                         !hr06
            endif
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
          
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
          
  150   continue !End of loop over elements inside block

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif

        goto 500

!--BETACALCULATION FOR SERIES OF BLOCKS (ix.ge.nblo.and.ithick.eq.1.and.iprint.eq.1)
  160   continue !if ithick=1 and iprint=1:
        if(ix.le.0) goto 190
!--REGULAR RUN THROUGH BLOCKS
        etl=etl+elbe(ix)
        do 170 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
            phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
            phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
          else
            phibf(l)=zero
          endif
          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl1eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,5)*dpp1*c1e3)- bl1(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,2)*t(1,ll))- bl1(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl1eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,6)*dpp1*c1e3)- bl1(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,4)*t(1,ll))- bl1(ix,l,6)*dpr(1))/ded            !hr06
          do 170 i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl1(ix,l,1)*puf+bl1(ix,l,2)*t(i,ll))+dpr(i)*bl1  &!hr06
     &(ix,l,5)                                                           !hr06
  170   t(i,ll)=(bl1(ix,l,3)*puf+bl1(ix,l,4)*t(i,ll))+dpr(i)*bl1(ix,l,6) !hr06

        do 180 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
            dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
            dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
          else
            dphi=-1d0*phibf(l)                                           !hr06
          endif
          if(-1d0*dphi.gt.pieni) dphi=dphi+pi                            !hr06
  180   phi(l)=phi(l)+dphi/pie

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
        
        goto 500

!--REVERSE RUN THROUGH BLOCKS (ix.le.0)
  190   ix=-ix
        etl=etl+elbe(ix)
        do 200 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
            phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
            phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
          else
            phibf(l)=zero
          endif
          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl2eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,5)*dpp1*c1e3)- bl2(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,2)*t(1,ll))- bl2(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl2eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,6)*dpp1*c1e3)- bl2(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,4)*t(1,ll))- bl2(ix,l,6)*dpr(1))/ded            !hr06
          do 200 i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl2(ix,l,1)*puf+bl2(ix,l,2)*t(i,ll))+dpr(i)*bl2  &!hr06
     &(ix,l,5)                                                           !hr06
  200   t(i,ll)=(bl2(ix,l,3)*puf+bl2(ix,l,4)*t(i,ll))+dpr(i)*bl2(ix,l,6) !hr06

        do 210 l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
            dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
            dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
          else
            dphi=-phibf(l)
          endif
          if(-1d0*dphi.gt.pieni) dphi=dphi+pi                            !hr06
  210   phi(l)=phi(l)+dphi/pie

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
        
        goto 500

!--NOT A BLOCK / Nonlinear insertion
  220   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        kzz=kz(ix)

 ! Cavity
+if .not.collimat.and..not.bnlelens
        if(kpz.eq.6) then
+ei
+if collimat.or.bnlelens
        if(abs(kzz).eq.12) then
+ei
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif

          goto 500
        endif
        
        !Beam Beam element .and. fort.3 has BB block
        if(kzz.eq.20.and.nbeam.ge.1) then
          nbeam=k
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          goto 500

        endif

+ca trom01 !if kzz==22, starts a do over l; Update t matrix
+ca trom03
+ca trom06 !endif, ends the do over l; increase nr, writelin and cpltwis

+if collimat.or.bnlelens

        ! Marker, beam-beam, phase-trombone, crab cavity (incl. multipole), or wire
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22
     &     .or.abs(kzz).eq.23.or.abs(kzz).eq.26
     &     .or.abs(kzz).eq.27.or.abs(kzz).eq.28
     &     .or.abs(kzz).eq.15) then
          
          nr=nr+1
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          goto 500
        endif
+ei
+if .not.collimat.and..not.bnlelens
        ! Marker, beam-beam or phase-trombone -> next element
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 500
        ! Wire -> next element
        if(abs(kzz).eq.15) goto 500
        ! RF CC Multipoles -> next element
        if (abs(kzz).eq.23.or.abs(kzz).eq.26.or.
     &      abs(kzz).eq.27.or.abs(kzz).eq.28) goto 500
+ei
      
        ! Update the matrix etc. for supported blocks
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 370 !Skew
        goto(230, 240, 250, 260, 270, 280, 290, 300, 310, 320, !1-10
     &       330, 500, 500, 500, 500, 500, 500, 500, 500, 500, !11-20
     &       500, 500, 500, 325, 326, 500, 500, 500),kzz       !21-28

        ! Un-recognized element (incl. cav with kp.ne.6 for non-collimat/bnlelens)
        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        goto 500

!--HORIZONTAL DIPOLE
  230   ekk=ekk*c1e3
+ca kickl01h
+ca kickq01h
        goto 480
!--NORMAL QUADRUPOLE
  240   continue
+ca kicklxxh
+ca kickq02h
        goto 480
!--NORMAL SEXTUPOLE
  250   ekk=ekk*c1m3
+ca kickq03h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL OCTUPOLE
  260   ekk=ekk*c1m6
+ca kicksho
+ca kickq04h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL DECAPOLE
  270   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL DODECAPOLE
  280   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL 14-POLE
  290   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL 16-POLE
  300   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL 18-POLE
  310   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09h
+ca kicksho
+ca kicklxxh
        goto 480
!--NORMAL 20-POLE
  320   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10h
+ca kicksho
+ca kicklxxh
        goto 480
!--DIPEDGE ELEMENT
 325    continue
+ca kickldpe
+ca kickqdpe
        goto 480
!--solenoid
 326    continue
+ca kicklso1
+ca kickqso1
        goto 480
!--Multipole block
  330   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
+ca multl08
            do 340 i=2,ium
+ca multl02
  340       continue
          else
+ca multl03
+ca multl09
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
+ca multl10
            do 350 i=2,ium
+ca multl05
  350       continue
          else
+ca multl06
+ca multl11
          endif
        endif
        if(abs(r0).le.pieni) goto 500
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif

          goto 500
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 360 l=1,nmz
+ca multl07a
  360   continue
        if(nmz.ge.2) then
+ca multl07b
          do 365 l=3,nmz
+ca multl07c
  365     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        goto 480


!--SKEW ELEMENTS
  370   kzz=-kzz
        goto(380,390,400,410,420,430,440,450,460,470),kzz
        
        ! Unrecognized element in the above GOTO (incl. kzz=-12,kp.ne.6 for non-collimat/bnlelens)
        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        goto 500

!--VERTICAL DIPOLE
  380   ekk=ekk*c1e3
+ca kickl01v
+ca kickq01v
        goto 480
!--SKEW QUADRUPOLE
  390   continue
+ca kicklxxv
+ca kickq02v
        goto 480
!--SKEW SEXTUPOLE
  400   ekk=ekk*c1m3
+ca kickq03v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW OCTUPOLE
  410   ekk=ekk*c1m6
+ca kicksho
+ca kickq04v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW DECAPOLE
  420   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW DODECAPOLE
  430   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW 14-POLE
  440   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW 16-POLE
  450   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW 18-POLE
  460   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09v
+ca kicksho
+ca kicklxxv
        goto 480
!--SKEW 20-POLE
  470   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10v
+ca kicksho
+ca kicklxxv

!After processing an element: go here!
  480   continue
        t(6,2)=t(6,2)-dyy1/(one+dpp)
        t(6,4)=t(6,4)-dyy2/(one+dpp)
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        if(ncorru.eq.0) then
          if(kz(ix).eq.11) then
            if(abs(aa(2)).gt.pieni.and.nmz.gt.1) write(34,10070) etl,   &
     &bez(ix),-2,aa(2),bexi,bezii,phi
            do iiii=3,nmz
              if(abs(bb(iiii)).gt.pieni) write(34,10070) etl,bez(ix),   &
     &iiii,bb(iiii),bexi,bezii,phi
              if(abs(aa(iiii)).gt.pieni) write(34,10070) etl,bez(ix),   &
     &-iiii,aa(iiii),bexi,bezii,phi
            enddo
          elseif(abs(ekk).gt.pieni.and.abs(kz(ix)).ge.3) then
            write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
          elseif(abs(ekk).gt.pieni.and.kz(ix).eq.-2) then
            write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
          endif
        endif
        
        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        
  500 continue ! END LOOP OVER ELEMENTS
      
      call clorb(ded)
      do 510 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  510 continue
      call clorb(zero)
      do 520 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  520 continue
      iiii=100
      idum='END'
      bexi=t(2,1)**2+t(3,1)**2                                           !hr06
      bezii=t(4,3)**2+t(5,3)**2                                          !hr06
      if(ncorru.eq.0) write(34,10070) etl,idum,iiii,zero,bexi,bezii,phi
      if(ncorru.eq.0)                                                   &
     &write(lout,10060)
!-----------------------------------------------------------------------
      return
10000 format(t5 ,'---- ENTRY LINOPT ----')
10010 format(132('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
10040 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7/)
10050 format(t8,'  PLANE          DISP(MM)                 DISP(MRAD)'/ &
     &t6,'      X  ',2(f20.12,6x)/t10,'  Y  ',2(f20.12,6x)/)
10060 format(//131('-')//)
10070 format(1x,1pg21.14,1x,a,1x,i4,5(1x,1pg21.14))
      end
+if collimat.or.bnlelens
      subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC,ielem)
+ei
+if .not.collimat.and..not.bnlelens
      subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC)
+ei
!-----------------------------------------------------------------------
!  WRITE OUT LINEAR OPTICS PARAMETERS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,iwrite,ixwl,l,ll,nr
      double precision al1,al2,b1,b2,c,cp,d,dp,g1,g2,p1,t,tl
      character*16 typ
      ! isBLOC.eq.TRUE if ixwl currently refers to a BLOC index, FALSE if it is a SINGLE ELEMENT index
      logical isBLOC
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension p1(2),t(6,4),b1(2),b2(2),al1(2),al2(2),g1(2),g2(2)
      dimension d(2),dp(2),c(2),cp(2)
+if collimat
+ca collpara
+ca dblinopt
      integer ielem
+ei
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        do 20 l=1,2
          ll=2*l
          b1(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                            !hr06
          b2(l)=t(6-ll,ll-1)**2+t(7-ll,ll-1)**2                          !hr06
          al1(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))      !hr06
          al2(l)=-1d0*(t(6-ll,ll-1)*t(6-ll,ll)+t(7-ll,ll-1)*t(7-ll,ll))  !hr06
          g1(l)=t(ll,ll)**2+t(ll+1,ll)**2                                !hr06
          g2(l)=t(6-ll,ll)**2+t(7-ll,ll)**2                              !hr06
          d(l)=t(6,ll-1)*c1m3
          dp(l)=t(6,ll)*c1m3
          c(l)=t(1,ll-1)
          cp(l)=t(1,ll)
   20   continue

+if collimat.or.bnlelens
+if .not.collimat.and.bnlelens
        if (lhc.eq.9) then
+ei
          tbetax(max(ielem,1))  = b1(1)
          tbetay(max(ielem,1))  = b1(2)
          talphax(max(ielem,1)) = al1(1)
          talphay(max(ielem,1)) = al1(2)
          torbx(max(ielem,1))   = c(1)
          torbxp(max(ielem,1))  = cp(1)
          torby(max(ielem,1))   = c(2)
          torbyp(max(ielem,1))  = cp(2)
          tdispx(max(ielem,1))  = d(1)
          tdispy(max(ielem,1))  = d(2)
+if .not.collimat.and.bnlelens
        endif
+ei
+ei

      if(ncorru.eq.0) then
          write(lout,10000) nr,typ(:8),tl,p1(1),b1(1),al1(1),g1(1),d(1),&
     &dp(1),c(1),cp(1)
          write(lout,10010) b2(1),al2(1),g2(1)
          write(lout,10030) typ(9:16)
          write(lout,10020) p1(2),b1(2),al1(2),g1(2),d(2),dp(2),        &
     &c(2),cp(2)
          write(lout,10010) b2(2),al2(2),g2(2)
          write(lout,10040)
        else
           if(.not.isBLOC) then
              if(kp(ixwl).eq.3) then
                 nhmoni=nhmoni+1
                 betam(nhmoni,1)=b1(1)
                 pam(nhmoni,1)=(p1(1)*2d0)*pi
                 bclorb(nhmoni,1)=c(1)
              else if(kp(ixwl).eq.4) then
                 nhcorr=nhcorr+1
                 betac(nhcorr,1)=b1(1)
                 pac(nhcorr,1)=(p1(1)*2d0)*pi
              else if(kp(ixwl).eq.-3) then
                 nvmoni=nvmoni+1
                 betam(nvmoni,2)=b1(2)
                 pam(nvmoni,2)=(p1(2)*2d0)*pi
                 bclorb(nvmoni,2)=c(2)
              else if(kp(ixwl).eq.-4) then
                 nvcorr=nvcorr+1
                 betac(nvcorr,2)=b1(2)
                 pac(nvcorr,2)=(p1(2)*2d0)*pi
              endif
           endif
        endif
      endif
!-----------------------------------------------------------------------
      return
10010 format('|',6x,'|',8x,'|',12x,'|',1x,'|',12x,'|',f12.6,'|', f13.7, &
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10020 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f12.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format(132('-'))
10000 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f12.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10030 format('|',6x,'|',a8,'|',12x,'|',102('-'))
      end
      subroutine cpltwis(typ,t,etl,phi)
!-----------------------------------------------------------------------
!  CALCULATES COUPLED TWISS PARAMETERS AROUND THE RING AND ALSO THE
!  ANGLE OF THE MAJOR AXIS OF A ELLIPSE IN THE X-Y PROJECTION WITH
!  THE X-AXIS. THE 4-D ELLIPSOID IS GIVEN BY THE BOUNDARY OF A
!  DISTRIBUTION OF PARTICLES WITH MAXIMUM EMITANCE OF MODE I AND II,
!  EUI AND EUII RESPECTIVELY.
!  BINARY PRINT ON FILE 11 OF 22 VALUES :
!  POSITION [M],
!  BET(1-4), ALF(1-4), GAM(1-4), COOR-PHI(1-4), COOR-PRIME-PHI(1-4),
!  COUUANGL
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,iwrite
      double precision alxi,alxii,alzi,alzii,bexi,bexii,bezi,bezii,     &
     &couuang,etl,gaxi,gaxii,gazi,gazii,phi,phxi,phxii,phxpi,phxpii,    &
     &phzi,phzii,phzpi,phzpii,t
      character*16 typ
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension t(6,4),phi(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bexii=t(4,1)**2+t(5,1)**2                                        !hr06
        bezi=t(2,3)**2+t(3,3)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        alxi=-1d0*(t(2,1)*t(2,2)+t(3,1)*t(3,2))                          !hr06
        alxii=-1d0*(t(4,1)*t(4,2)+t(5,1)*t(5,2))                         !hr06
        alzi=-1d0*(t(2,3)*t(2,4)+t(3,3)*t(3,4))                          !hr06
        alzii=-1d0*(t(4,3)*t(4,4)+t(5,3)*t(5,4))                         !hr06
        gaxi=t(2,2)**2+t(3,2)**2                                         !hr06
        gaxii=t(4,2)**2+t(5,2)**2                                        !hr06
        gazi=t(2,4)**2+t(3,4)**2                                         !hr06
        gazii=t(4,4)**2+t(5,4)**2                                        !hr06
+if crlibm
        if(abs(t(2,1)).gt.pieni) phxi=atan2_rn(t(3,1),t(2,1))
+ei
+if .not.crlibm
        if(abs(t(2,1)).gt.pieni) phxi=atan2(t(3,1),t(2,1))
+ei
+if crlibm
        if(abs(t(4,1)).gt.pieni) phxii=atan2_rn(t(5,1),t(4,1))
+ei
+if .not.crlibm
        if(abs(t(4,1)).gt.pieni) phxii=atan2(t(5,1),t(4,1))
+ei
+if crlibm
        if(abs(t(2,3)).gt.pieni) phzi=atan2_rn(t(3,3),t(2,3))
+ei
+if .not.crlibm
        if(abs(t(2,3)).gt.pieni) phzi=atan2(t(3,3),t(2,3))
+ei
+if crlibm
        if(abs(t(4,3)).gt.pieni) phzii=atan2_rn(t(5,3),t(4,3))
+ei
+if .not.crlibm
        if(abs(t(4,3)).gt.pieni) phzii=atan2(t(5,3),t(4,3))
+ei
+if crlibm
        if(abs(t(2,2)).gt.pieni) phxpi=atan2_rn(t(3,2),t(2,2))
+ei
+if .not.crlibm
        if(abs(t(2,2)).gt.pieni) phxpi=atan2(t(3,2),t(2,2))
+ei
+if crlibm
        if(abs(t(4,2)).gt.pieni) phxpii=atan2_rn(t(5,2),t(4,2))
+ei
+if .not.crlibm
        if(abs(t(4,2)).gt.pieni) phxpii=atan2(t(5,2),t(4,2))
+ei
+if crlibm
        if(abs(t(2,4)).gt.pieni) phzpi=atan2_rn(t(3,4),t(2,4))
+ei
+if .not.crlibm
        if(abs(t(2,4)).gt.pieni) phzpi=atan2(t(3,4),t(2,4))
+ei
+if crlibm
        if(abs(t(4,4)).gt.pieni) phzpii=atan2_rn(t(5,4),t(4,4))
+ei
+if .not.crlibm
        if(abs(t(4,4)).gt.pieni) phzpii=atan2(t(5,4),t(4,4))
+ei
        if(abs(t(2,1)).le.pieni) phxi=pi*half
        if(abs(t(4,1)).le.pieni) then
          if(bexii.gt.pieni) phxii=pi*half
          if(bexii.le.pieni) phxii=zero
        endif
        if(abs(t(2,3)).le.pieni) then
          if(bezi.gt.pieni) phzi=pi*half
          if(bezi.le.pieni) phzi=zero
        endif
        if(abs(t(4,3)).le.pieni) phzii=pi*half
        if(abs(t(2,2)).le.pieni) phxpi=pi*half
        if(abs(t(4,2)).le.pieni) then
          if(gaxii.gt.pieni) phxpii=pi*half
          if(gaxii.le.pieni) phxpii=zero
        endif
        if(abs(t(2,4)).le.pieni) then
          if(gazi.gt.pieni) phzpi=pi*half
          if(gazi.le.pieni) phzpi=zero
        endif
        if(abs(t(4,4)).le.pieni) phzpii=pi*half
        if(abs(eui*(bexi-bezi)+euii*(bexii-bezii)).gt.pieni) then
+if crlibm
          couuang=half*atan_rn((two*((eui*sqrt(bexi*bezi))*             &!hr06
     &cos_rn(phxi-phzi)+                                                &!hr06
     &(euii*sqrt(bexii*bezii))*cos_rn(phxii-phzii)))/ (eui*(bexi-bezi)  &!hr06
     &+euii*(bexii-bezii)))                                              !hr06
+ei
+if .not.crlibm
          couuang=half*atan((two*((eui*sqrt(bexi*bezi))*cos(phxi-phzi)+ &!hr06
     &(euii*sqrt(bexii*bezii))*cos(phxii-phzii)))/ (eui*(bexi-bezi)     &!hr06
     &+euii*(bexii-bezii)))                                              !hr06
+ei
!if crlibm
!ei
!if .not.crlibm
!ei
        else
          couuang=zero
        endif
        write(11,*) typ,etl,phi,bexi,bexii,bezi,bezii, alxi,alxii,alzi, &
     &alzii, gaxi,gaxii,gazi,gazii,phxi,phxii,phzi,phzii, phxpi,        &
     &phxpii,phzpi,phzpii,couuang,t(6,1),t(6,2),t(6,3),t(6,4),t(1,1),   &
     &t(1,2),t(1,3),t(1,4)

      endif
      return
      end
+dk loesd
      subroutine loesd (rmat, vec,dimakt,dimtot,kod)
!-----------------------------------------------------------------------
!  SOLUTION OF A SYSTEM OF LINEAR EQUATIONS
!  VEC1 = VEC2 * RMAT , WITH VEC2 AS RESULT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ik,indi,j,jk,jy,k,kk,kod,l,n,n1,dimtot,dimakt
      double precision emax,eps,r,rmat,vec
+ca parpro
+ca parnum
      dimension rmat(dimtot,dimakt),vec(dimakt)
      data eps /1d-20/
      save
!-----------------------------------------------------------------------
      kod=1
      do 50 j=1,dimakt
        emax=zero
        do 10 ik=j,dimakt
          if(abs(emax).gt.abs(rmat(j,ik)) .or.emax.ne.emax) goto 10
          emax=rmat(j,ik)
          indi=ik
   10   continue
        if(abs(emax).lt.eps) then
          write(lout,*) '  ****   ERROR IN LOESD   **** '
          return
        endif
   20   do 30 l=j,dimakt
          r=rmat(l,j)
          rmat(l,j)=rmat(l,indi)
          rmat(l,indi)=r
          rmat(l,j)=rmat(l,j)/emax
   30   continue
        r=vec(indi)
        vec(indi)=vec(j)
        vec(j)=r/emax
        if(j.eq.dimakt) goto 60
        jy=j+1
        do 50 jk=jy,dimakt
          r=rmat(j,jk)
          do 40 kk=jy,dimakt
            rmat(kk,jk)= rmat(kk,jk)-r*rmat(kk,j)
   40     continue
          vec(jk)=vec(jk)-vec(j)*r
   50 continue
   60 n=dimakt
      n1=dimakt-1
      do 70 j=1,n1
        do 70 k=1,j
          vec(n-j)=vec(n-j)-rmat(n-k+1,n-j)*vec(n-k+1)
   70 continue
      kod = 0
      return
      end
+dk matrix
      subroutine matrix(dpp,am)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ierr,l
      double precision am,dpp
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=2,5
        do 10 l=1,2
          x(i,l)=zero
   10 y(i,l)=zero
      x(2,1)=one
      y(3,1)=one
      x(4,2)=one
      y(5,2)=one
      do 20 l=1,2
        x(1,l)=clo(l)
   20 y(1,l)=clop(l)
      call umlauf(dpp,5,ierr)
      ierro=ierr
      do 30 i=1,4
        am(1,i)=x(i+1,1)
        am(2,i)=y(i+1,1)
        am(3,i)=x(i+1,2)
   30 am(4,i)=y(i+1,2)
!-----------------------------------------------------------------------
      return
      end
+dk orbit
      subroutine corrorb
!-----------------------------------------------------------------------
!  CORRECTION OF CLOSED ORBIT FIRST (MOST EFFECTIV CORRECTOR STRATEGY
!  USING MICADO), THEN
!  SCALING OF DIPOLE-ERRORS FOR RMS-VALUES OF THE CLOSED ORBIT
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,icflag,ihflag,ii,ij,im,iprinto,ivflag,j,k,kpz,kzz,l,    &
     &nlino,ntcoo,nto,nx
+ca parpro
      real ar(nmon1,ncor1)
      real b(nmon1),orbr(nmon1),xinc(ncor1)
      real rmsx,ptpx,rmsz,ptpz,rzero,rzero1
      double precision clo0,clop0,hfac,qwc1,vfac
      character*16 bezlo(nele)
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension clo0(2),clop0(2)
      dimension qwc1(3),nx(ncor1)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      rzero=0.0
      rzero1=0.0
      do 10 l=1,2
        clo0(l)=zero
        clop0(l)=zero
        di0(l)=zero
   10 dip0(l)=zero
      call clorb(ded)
      if(ierro.gt.0) call prror(4)
      do 20 l=1,2
        clo0(l)=clo(l)
   20 clop0(l)=clop(l)
      call clorb(zero)
      if(ierro.gt.0) call prror(5)
      do 30 l=1,2
        di0(l)=(clo0(l)-clo(l))/ded
   30 dip0(l)=(clop0(l)-clop(l))/ded
      do 40 l=1,ncor1
        xinc(l)=0.0
   40 nx(l)=0
      if(iclo.eq.0) return
!-- ORBIT CORRECTION
      ihflag=0
      ivflag=0
      icflag=0

      write(lout,*)
      write(lout,10000)
      if(ncorru.eq.0) then
        call prror(84)
      else
        if(ncorrep.le.0) then
          write(lout,10010) ncorru,sigma0(1),sigma0(2)
        else
          write(lout,10020) ncorru,ncorrep
        endif
      endif
      write(lout,*)

!-- SAVE OLD 'LINOPT' SETTINGS
      iprinto=iprint
      nto=nt
      ntcoo=ntco
      do 50 i=1,nlin
        bezlo(i)=bezl(i)
   50 continue
      nlino=nlin
!-- PUT MONITORS AND CORRECTORS INTO LINOPT SETTINGS
!-- GET TWISS PARAMETERS AND DISTORTED ORBIT BACK
      iprint=0
      ntco=0
      nlin=0
      do 60 i=1,il
        if(kp(i).eq.3.or.kp(i).eq.4.or. kp(i).eq.-3.or.kp(i).eq.-4) bezl&
     &(i)=bez(i)
        nlin=nlin+1
   60 continue
      call linopt(zero)
      call phasad(zero,qwc1)

!-- CHECK SOME CONDITIONS
      write(lout,10100) nhmoni,nhcorr,nvmoni,nvcorr
      if(nhmoni.gt.nmon1) then
        write(lout,10070) nhmoni,nmon1
        return
      endif
      if(nvmoni.gt.nmon1) then
        write(lout,10070) nvmoni,nmon1
        return
      endif
      if(nhcorr.gt.ncor1) then
        write(lout,10080) nhcorr,ncor1
        return
      endif
      if(nvcorr.gt.ncor1) then
        write(lout,10080) nvcorr,ncor1
        return
      endif
      if(nhmoni.lt.nhcorr.or.nvmoni.lt.nvcorr) write(lout,10090)

      write(lout,*)
      call orbinit
!-- CORRECT BOTH PLANES
      if(ncorrep.eq.0) then
        icflag=1
        ncorrep=itco
      endif
      do 110 ii=1,ncorrep
!-- HORIZONTAL PLANE FIRST
        do 70 i=1,nhmoni
          b(i)=real(bclorb(i,1))
          do 70 j=1,nhcorr
+if crlibm
      ar(i,j)=real(((sqrt(betam(i,1)*betac(j,1))*cos_rn(abs(pam(i,1)-pac&!hr06
     &(j,1))-qwc1(1)*pi))*c1e3)/(2d0*sin_rn(qwc1(1)*pi)))                !hr06
+ei
+if .not.crlibm
      ar(i,j)=real(((sqrt(betam(i,1)*betac(j,1))*cos(abs(pam(i,1)- pac  &!hr06
     &(j,1))-qwc1(1)*pi))*c1e3)/(2d0*sin(qwc1(1)*pi)))                   !hr06
+ei
   70   continue
        call calrms(b,nhmoni,rmsx,ptpx)
!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nhmoni,nhcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

!-- VERTICAL PLANE HERE
        do 80 i=1,nvmoni
          b(i)=real(bclorb(i,2))                                         !hr06
          do 80 j=1,nvcorr
+if crlibm
      ar(i,j)=real(((sqrt(betam(i,2)*betac(j,2))*cos_rn(abs(pam(i,2)-pac&!hr06
     &(j,2))-qwc1(2)*pi))*c1e3)/(2d0*sin_rn(qwc1(2)*pi)))                !hr06
+ei
+if .not.crlibm
      ar(i,j)=real(((sqrt(betam(i,2)*betac(j,2))*cos(abs(pam(i,2)-pac   &!hr06
     &(j,2))-qwc1(2)*pi))*c1e3)/(2*sin(qwc1(2)*pi)))                     !hr06
+ei
   80   continue
        call calrms(b,nvmoni,rmsz,ptpz)
        write(lout,10030) ii-1,rmsx,rmsz
        write(lout,10040) ii-1,ptpx,ptpz
        if(icflag.eq.1.and.sigma0(1).gt.rmsx.and.ihflag.eq.0) then
          write(lout,10110)
          ihflag=1
        endif
        if(icflag.eq.1.and.sigma0(2).gt.rmsz.and.ivflag.eq.0) then
          write(lout,10120)
          ivflag=1
        endif

        if(ihflag.eq.0) then
          write(lout,*)
          do 90 ij=1,ncorru/10
            write(lout,10050) (nx(10*(ij-1)+k), k=1,10)
   90     continue
          if(mod(ncorru,10).gt.0) then
            write(lout,10050) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,1)
        endif
!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nvmoni,nvcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

        if(ivflag.eq.0) then
          write(lout,*)
          do 100 ij=1,ncorru/10
            write(lout,10060) (nx(10*(ij-1)+k), k=1,10)
  100     continue
          if(mod(ncorru,10).gt.0) then
            write(lout,10060) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,2)
        endif

        if(ihflag.eq.1.and.ivflag.eq.1) goto 140
        call linopt(zero)
        call phasad(zero,qwc1)
  110 continue

!-- GET LAST VALUES AFTER CORRECTION
      do 120 i=1,nhmoni
        b(i)=real(bclorb(i,1))                                           !hr06
  120 continue
      call calrms(b,nhmoni,rmsx,ptpx)
      do 130 i=1,nvmoni
        b(i)=real(bclorb(i,2))                                           !hr06
  130 continue
      call calrms(b,nvmoni,rmsz,ptpz)
      write(lout,10030) ncorrep,rmsx,rmsz
      write(lout,10040) ncorrep,ptpx,ptpz
      write(lout,*)

  140 continue
      if((ii-1).eq.itco) write(lout,10130) itco

!-- SCALE TO DESIRED RMS VALUE IF IT IS GREATER THAN ZERO
      if(sigma0(1).gt.pieni.or.sigma0(2).gt.pieni) then
        do 180 ii=1,itco
          write(lout,10140)
          hfac=sigma0(1)/dble(rmsx)                                      !hr06
          vfac=sigma0(2)/dble(rmsz)                                      !hr06
          do 150 i=1,il
            kzz=kz(i)
            kpz=kp(i)
            if(kzz.eq.1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*hfac
              ek(i)=ek(i)*hfac
            endif
            if(kzz.eq.-1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*vfac
              ek(i)=ek(i)*vfac
            endif
            if(kzz.eq.11) then
              im=irm(i)
              ak0(im,1)=ak0(im,1)*vfac
              aka(im,1)=aka(im,1)*vfac
              bk0(im,1)=bk0(im,1)*hfac
              bka(im,1)=bka(im,1)*hfac
            endif
  150     continue
          call linopt(zero)
          do 160 i=1,nhmoni
            b(i)=real(bclorb(i,1))                                       !hr06
  160     continue
          call calrms(b,nhmoni,rmsx,ptpx)
          do 170 i=1,nvmoni
            b(i)=real(bclorb(i,2))                                       !hr06
  170     continue
          call calrms(b,nvmoni,rmsz,ptpz)
          write(lout,10150) ii,rmsx,rmsz
          write(lout,10160) ii,ptpx,ptpz
          write(lout,*)
          if(abs(dble(rmsx)-sigma0(1)).lt.dsi.and.                      &!hr06
     &       abs(dble(rmsz)-sigma0(2)).lt.dsi)                          &!hr06
     &goto 190
  180   continue
      endif
      if((ii-1).eq.itco) write(lout,10130) itco
  190 continue

!-- WRITE OUT ADJUSTED CLOSED ORBIT
      do 200 i=1,nhmoni
        write(28,*) i,bclorb(i,1)
  200 continue
      do 210 i=1,nhmoni
        write(29,*) i,bclorb(i,2)
  210 continue

!-- CHANGE BACK TO OLD 'LINOPT' SETTINGS
      iprint=iprinto
      nt=nto
      ntco=ntcoo
      nlin=nlino
      do 220 i=1,nlin
        bezl(i)=bezlo(i)
  220 continue
      ncorru=0
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ORBIT CORRECTION WITH MOST EFFCTIVE CORRECTOR ',  &
     &'STRATEGY ----')
10010 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS UNTIL',/, &
     &t5,'       HOR. RMS SMALLER THAN ',f6.3,' MM',/, t5,              &
     &'       VER. RMS SMALLER THAN ',f6.3,' MM')
10020 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS AND ',i4, &
     &' ITERATIONS.')
10030 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-RMS: ',f6.3, &
     &' VER.-RMS: ',f6.3)
10040 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-PTP: ',f6.3, &
     &' VER.-PTP: ',f6.3)
10050 format(t5,'     HORIZONTAL CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10060 format(t5,'     VERTICAL   CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10070 format(/,t5,'ERROR: NUMBER OF MONITORS TOO BIG.',/                &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10080 format(/,t5,'ERROR: NUMBER OF CORRECTORS TOO BIG.',/              &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10090 format(/,t5,'WARNING: NUMBER OF MONITORS IS SMALLER THAN NUMBER', &
     &' OF CORRECTORS.',/ '    NUMERICAL PROBLEMS MIGHT BE ENCOUNTERED.'&
     &)
10100 format(/,t5,'NUMBER OF HOR. MONITORS: ',i4,                       &
     &'  NUMBER OF HOR. CORRECTORS: ',i4,/, t5,                         &
     &'NUMBER OF VER. MONITORS: ',i4, '  NUMBER OF VER. CORRECTORS: ',  &
     &i4)
10110 format(t10,'HORIZONTAL RMS GOAL REACHED')
10120 format(t10,'VERTICAL RMS GOAL REACHED')
10130 format(t10,'MAXIMUM NUMBER OF ITERATIONS ACHIVED: ',i4,/ ,t10,    &
     &'INCREASE ITCO TO INCREASE THE NUMBER OF ' ,                      &
     &'CLOSED ORBIT ITERATIONS',/)
10140 format(t5,'---- ORBIT SCALING USING ALL POSSIBLE ELEMENTS ')
10150 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-RMS: ',f6.3,    &
     &' VER.-RMS: ',f6.3)
10160 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-PTP: ',f6.3,    &
     &' VER.-PTP: ',f6.3)
      end
      subroutine putorb(xinc,nx,npflag)
!-----------------------------------------------------------------------
!  PUT ORBIT CHANGES FROM MICADO TO THE GIVEN ORBIT CORRECTORS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,im,ix,izu,j,k,kcorr,kcorru,kpz,kzz,nmz,npflag,nx
+ca parpro
      real xinc(ncor1)
      double precision ckicknew,ckickold,r0,r0a
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension nx(ncor1)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      kcorru=0
      kcorr=0
      izu=0

      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(kzz.eq.15) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if(kpz.eq.4.and.kzz.eq.1.and.npflag.eq.1.or.                    &
     &kpz.eq.-4.and.kzz.eq.-1.and.npflag.eq.2) then
          kcorr=kcorr+1
          do 10 j=1,ncorru
            if(nx(j).eq.kcorr) then
              kcorru=kcorru+1
              ckickold=sm(ix)+zfz(izu)*ek(ix)
              zfz(izu)=zfz(izu)+dble(xinc(j))/ek(ix)                     !hr06
              ckicknew=sm(ix)+zfz(izu)*ek(ix)
              write(lout,10000) kcorru,kcorr,bez(ix), ckickold*c1e3,    &
     &ckicknew*c1e3
            endif
   10     continue
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one
          do 50 k=1,nmz
            izu=izu+1
            if(kpz.eq.-4.and.npflag.eq.2.and.k.eq.1) then
              kcorr=kcorr+1
              do 30, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k))/r0a
           zfz(izu)=zfz(izu)+(c1e3* (dble(xinc(j))/(r0a*ed(ix))-ak0     &!hr06
     &(im,k)))/aka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   30         continue
            endif
            izu=izu+1
            if(kpz.eq.4.and.npflag.eq.1.and.k.eq.1) then
              kcorr=kcorr+1
              do 40, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
           zfz(izu)=zfz(izu)+(c1e3* (dble(xinc(j))/(r0a*ed(ix))-bk0     &!hr06
     &(im,k)))/bka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   40         continue
            endif
   50     continue
          izu=izu+2*mmul-2*nmz
        endif
   60 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,i4,i4,' ',a16,'  OLD: ',d13.7,' MRAD   NEW: ' ,d13.7,   &
     &' MRAD')
      end
      subroutine orbinit
!-----------------------------------------------------------------------
!  INITIALIZES THE RANDOM NUMBER OF NOT SET CORRCTORS
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,im,ix,izu,kpz,kzz,nmz
      double precision r0
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      izu=0
      do 10 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 10
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 10
        if(kzz.eq.15) goto 10
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if((kpz.eq.4.and.kzz.eq.1).or.(kpz.eq.-4.and.kzz.eq.-1)) then
          zfz(izu)=zero
          ek(ix)=one
          ncororb(ix)=1
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 10
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 10
          endif
          im=irm(ix)

          izu=izu+1
          if(kpz.eq.-4) then
            zfz(izu)=zero
            aka(im,1)=one
          endif
          izu=izu+1
          if(kpz.eq.4) then
            zfz(izu)=zero
            bka(im,1)=one
          endif
          izu=izu+2*mmul-2
        endif
   10 continue
      return
      end
      subroutine htls(a,b,m,n,x,ipiv,r,iter,rms,ptp)
!*********************************************************************
!     Subroutine HTLS to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     DIMENSION OF ARRAY RHO SHOULD BE 3*NCOR1                       *
!     M    - NUMBER OF AVAILABLE MONITORS                            *
!     N    - NUMBERR OF AVAILABLE INDEPENDENT CORRECTORS             *
!     ITER - NUMBER OF CORRECTORS TO BE USED                         *
!     RMS  - RMS VALUE TO CORRECT FOR                                *
!     PTP  - PEAK TO PEAK VALUE TO CORRECT FOR                       *
!*********************************************************************
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,iii,ij1,ip,ipiv,iter,j,j1,k,k2,k3,ki,kk,kpiv,m,n,ncor1, &
     &nmon1
      real a,b,piv,pivt,ptop,r,rho,rmss,x,xiter,xptp,xrms
      real rms,ptp
      real g,h,sig,beta
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),x(ncor1),ipiv(ncor1),r(nmon1)
      dimension rho(3*ncor1),xiter(ncor1),xrms(ncor1),xptp(ncor1)
      dimension rmss(ncor1),ptop(ncor1)
      save
!-----------------------------------------------------------------------

! --- calcul du premier pivot

!============================
      beta=0.0

      do 10 ij1=1,500
   10 rho(ij1)=0.0

      k2=n + 1
      piv=0.0d0

      do 40 k=1,n
        ipiv(k)=k
        h=0.0                                                            !hr06
        g=0.0                                                            !hr06
        do 20 i=1,m
          h=h+a(i,k)*a(i,k)
          g=g+a(i,k)*b(i)
   20   continue
        rho(k)=h
        rho(k2) = g
        pivt = g**2/h                                                    !hr06
        if(pivt-piv.le.0) goto 40
        if(pivt-piv.gt.0) goto 30
   30   piv = pivt
        kpiv=k
   40 k2 = k2 + 1

! --- boucle pour chaque iteration

      do 150 k=1,iter
        if(kpiv.eq.k)goto 60

! --- on echange les K et KPIV si KPIV plus grand que K
        h=rho(k)
        rho(k)=rho(kpiv)
        rho(kpiv)=h
        k2=n+k
        k3=n+kpiv
        g = rho(k2)
        rho(k2) = rho(k3)
        rho(k3) = g
        do 50 i=1,m
          h=a(i,k)
          a(i,k)=a(i,kpiv)
          a(i,kpiv)=h
   50   continue

! --- calcul de beta,sigma et uk dans htul
   60   continue
        call htul(a,m,n,k,sig,beta)

! --- on garde SIGMA dans RHO(N+K)
        j=n+k
        rho(j)=-1.0*sig                                                  !hr06
        ip=ipiv(kpiv)
        ipiv(kpiv)=ipiv(k)
        ipiv(k)=ip
        if(k.eq.n) goto 70

! --- transformation de A dans HTAL
        call htal(a,m,n,k,beta)

! --- transformation de B dans HTBL
   70   continue
        call htbl(a,b,m,n,k,beta)

! --- recherche du pivot (K+1)
!=============================

        rho(k)=sqrt(piv)
        if(k.eq.n) goto 90
        piv=0.0                                                          !hr06
        kpiv = k + 1
        j1 = kpiv
        k2=n + j1
        do 80 j=j1,n
          h=rho(j)-(a(k,j))*(a(k,j))

          if(h.lt.0.0000001) then
            write(lout,*)
            write(lout,*) 'CORRECTION PROCESS ABORTED.'
            write(lout,*) 'DIVISION BY ZERO EXPECTED.'
            write(lout,*) 'PROBABLY TWO CORRECTORS TOO CLOSE.'
            write(lout,10000) ' SUSPECTED CORRECTOR: ',j
            call closeUnits
+if cr
      call abend('777                                               ')
+ei
+if .not.cr
            stop 777
+ei
          endif

          rho(j)=h
          g=rho(k2)-(a(k,j))*(b(k))
          rho(k2) = g
          pivt = g**2/h                                                  !hr06
          if(pivt.lt.piv)goto 80
          kpiv=j
          piv=pivt
   80   k2 = k2 + 1

! --- calcul des X
   90   x(k)=b(k)/rho(n+k)
        if(k.eq.1)goto 120
        do 110 i=2,k
          kk=k-i+1
          x(kk)=b(kk)
          ki=kk+1
          do 100 j=ki,k
  100     x(kk)=x(kk)-a(kk,j)*x(j)
          x(kk)=x(kk)/rho(n+kk)
  110   continue
  120   continue

! --- save residual orbit and inverse sign of corrections (convention!)
        do 130 iii= 1,m
  130   r(iii) = b(iii)
        do 140 iii= 1,k
  140   x(iii) =-1.0*x(iii)                                              !hr06

! --- calcul du vecteur residuel dans HTRL
!=========================================

!     transform orbit R back to "normal space"
        call htrl(a,r,m,n,k,rho)
        call calrms(r,m,rmss(k),ptop(k))
        xiter(k+1) = k
        xrms(k+1) = rmss(k)
        xptp(k+1) = ptop(k)

        if(ptop(k).le.ptp)goto 160
        if(rmss(k).le.rms)goto 160
  150 continue
      return

! --- correction is already good enough:
!=======================================

  160 ptp=ptop(k)
      rms=rmss(k)
10000 format(a,i4)
      end
      subroutine htal(a,m,n,k,beta)
!*********************************************************************
!     Subroutine HTAL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of matrix A
!*********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer j,k,k1,m,n,nc,ncor1,nmon1
      real a,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------

      nc=n-k

      do 20 j=1,nc
        h=0.0                                                            !hr06

        do 10 k1=k,m
   10   h=h+a(k1,k)*a(k1,k+j)

        h=beta*h
        do 20 k1=k,m
   20 a(k1,k+j)=a(k1,k+j)-a(k1,k)*h

      end
      subroutine htbl(a,b,m,n,k,beta)
!*********************************************************************
!     Subroutine HTBL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of vector B
!*********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer k,k1,m,n,ncor1,nmon1
      real a,b,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1)
      save
!-----------------------------------------------------------------------

      h=0.0                                                              !hr06

      do 10 k1=k,m
   10 h=h+a(k1,k)*b(k1)

      h=beta*h

      do 20 k1=k,m
   20 b(k1)=b(k1)-a(k1,k)*h

      end
      subroutine htrl(a,b,m,n,k,rho)
!*********************************************************************
!     Subroutine HTRL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate residual orbit vector
!*********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,k,kk,kl,kn,lv,m,n,ncor1,nmon1
      real a,b,beta,rho
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),rho(3*ncor1)
      save
!-----------------------------------------------------------------------

      do 10 i= 1,k,1
        b(i)= 0.0                                                        !hr06
   10 continue

      do 20 kk=1,k
        lv=m-k+kk
        kn=n+k-kk+1
        kl=k-kk+1

        beta=-1.0/(rho(kn)*a(kl,kl))                                     !hr06
        call htbl(a,b,m,n,kl,beta)
   20 continue

      end
      subroutine htul(a,m,n,k,sig,beta)
!*********************************************************************
!     Subroutine HTUL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate vector U
!*********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,k,m,n,ncor1,nmon1
      real a,beta,h,sig
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------
      sig=0.0                                                            !hr06

      do 10 i=k,m
        sig=sig+a(i,k)* a(i,k)
   10 continue

      sig=sqrt(sig)
!     on choisit le signe correct pour SIG:
      h=a(k,k)
      if(h.lt.0.0)sig=-1.0*sig                                           !hr06
      beta=h + sig
      a(k,k)=beta
      beta=1.0/(sig*beta)                                                !hr06
      end
      subroutine calrms(r,m,rms,ptp)
!*********************************************************************
!     Subroutine CALRMS to calculate rms                             *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculates rms and p.to.p value of R(1) .... R(M)
!*********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,imax,imin,m,maxmin
      real ave,ptp,r,rms,xave,xrms
      dimension r(m)
      save
!-----------------------------------------------------------------------
      xave = 0.0
      xrms = 0.0

      do 10 i=1,m
        xave = xave + r(i)
        xrms = xrms + r(i)**2                                            !hr06
   10 continue

      ave = xave / real(m)
      rms = xrms / real(m)

      imax=maxmin(r(1),m,1)
      imin=maxmin(r(1),m,0)
      ptp=r(imax)-r(imin)
      rms=sqrt(rms)
      return
      end
      function maxmin (a,n,m)
!-----------------------------------------------------------------------
!     if M=0, MAXMIN=lowest index of minimum element in A
!     if M=1, MAXMIN=lowest index of maximun element in A
!     if N<1, MAXMIN=1
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,m,maxmin,n
      real a,curent
      dimension a(n)
      save
!-----------------------------------------------------------------------
      maxmin=1
      if (n.lt.1) return
      curent=a(1)
      do 10 i=2,n
        if ((m.eq.0).and.(a(i).ge.curent)) goto 10
        if ((m.eq.1).and.(a(i).le.curent)) goto 10
        curent=a(i)
        maxmin=i
   10 continue
      return
      end
+dk ord
      subroutine ord
!-----------------------------------------------------------------------
!  ORGANISATION OF BLOCKS, NONLINEAR ELEMENTS AND RANDOM NUMBERS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,icext1,icextal1,ihi,ii,ilf,ilfr,inz,iran,ix,izu,j,jra,  &
     &jra3,kanf1,kpz,kzz,kzz1,kzz2,nra1
      double precision extalig1,exterr1
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension ilf(nblz),ilfr(nblz),jra(nele,5),iran(nele),inz(nele)
      dimension exterr1(nblz,40),extalig1(nblz,3),icext1(nblz),         &
     &icextal1(nblz)
+if time
      double precision exterr2,tcnst2
      dimension exterr2(nblz,40),tcnst2(nblz)
+ei
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=1,nblz
        ilf(i)=0
        ilfr(i)=0
   10 continue
      do 20 i=1,nele
        iran(i)=0
        inz(i)=0
        do 20 j=1,5
          jra(i,j)=0
   20 continue
      if(mper.eq.1) goto 40
      do 30 i=2,mper
        do 30 j=1,mbloz
          ii=(i-1)*mbloz+j
          ihi=j
          if(msym(i).lt.0) ihi=mbloz-j+1
          ic(ii)=msym(i)*ic(ihi)
   30 if(ic(ii).lt.-nblo) ic(ii)=-ic(ii)
!--ORGANISATION OF RANDOM NUMBERS
   40 iu=mper*mbloz
      if(niu(1).lt.0) niu(1)=iabs(niu(1))
      if(niu(2).lt.0) niu(2)=iabs(niu(2))
      if(niu(1).eq.0) niu(1)=1
      if(niu(2).eq.0) niu(2)=iu
      if(niu(1).gt.iu) niu(1)=1
      if(niu(2).gt.iu) niu(2)=iu
      izu=0
      nra1=nran
      iorg=iorg-1
      if(iorg.ge.0) then
        if(iorg.eq.0) then !iorg == 0
          do 50 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 50
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 50
            if(kzz.eq.15) goto 50
            mzu(i)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
            if(izu.gt.nzfz) then
              write(lout,*) "ERROR in ORD: nzfz was too small"
              call prror(-1)
            endif
   50     continue
        else ! iorg.gt.0
          do 70 i=1,iorg
            do 60 j=1,il
              if(bez(j).eq.bezr(1,i)) then
                jra(i,1)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)
     &               call prror(31)
                jra(i,2)=kz(j)
              endif
              if(bez(j).eq.bezr(2,i)) then
                jra(i,3)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)
     &               call prror(31)
                jra(i,4)=kz(j)
              endif
   60       continue
            kzz1=jra(i,2)
            kzz2=jra(i,4)
            if(kzz1.ne.0.and.kzz2.eq.0) then
              jra(i,5)=nra1
              nra1=nra1+mran*3
              if(kzz1.eq.11.and.abs(ek(jra(i,1))).gt.pieni)
     &             nra1=nra1+mran*2*mmul
              if(nra1.gt.nzfz) call prror(32)
            endif
            if(kzz1.eq.11.and.(kzz2.ne.11.and.kzz2.ne.0)) call prror(33)
   70     continue
          do 110 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 110
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 110
            if(kzz.eq.15) goto 110
            do 80 j=1,iorg
              if(bez(ix).eq.bezr(1,j)) goto 90
   80       continue
            goto 100
   90       jra3=jra(j,3)
            if(jra3.ne.0) then
              mzu(i)=iran(jra3)
              iran(ix)=mzu(i)
            else
              inz(j)=inz(j)+1
              if(inz(j).gt.mran) call prror(34)
              mzu(i)=jra(j,5)
              iran(ix)=mzu(i)
              jra(j,5)=jra(j,5)+3
              if(jra(j,2).eq.11) jra(j,5)=jra(j,5)+2*mmul
            endif
            goto 110
  100       mzu(i)=izu
            iran(ix)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
  110     continue
        endif
      else !iorg < 0 (in case of no ORGA block in fort.3)
        do 115 i=1,iu
          ix=ic(i)
          if(ix.le.nblo) goto 115
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 115
          if(kzz.eq.15) goto 115
          izu=izu+3
          if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
          if(izu.gt.nran) call prror(30)
          if(izu.gt.nzfz) then
            write(lout,*) "ERROR in ORD: nzfz was too small"
            call prror(-1)
          endif
  115   continue
      endif
      
      ! "GO" was not the first structure element -> Reshuffle the structure
      if(kanf.ne.1) then
        !--Re-saving of the starting point (UMSPEICHERUNG AUF DEN STARTPUNKT)
        kanf1=kanf-1
        do 130 i=1,kanf1
          if(iorg.ge.0) ilfr(i)=mzu(i)
          ilf(i)=ic(i)
          icext1(i)=icext(i)
          icextal1(i)=icextal(i)
          extalig1(i,1)=extalign(i,1)
          extalig1(i,2)=extalign(i,2)
          extalig1(i,3)=extalign(i,3)
          do 120 ii=1,40
            exterr1(i,ii)=exterr(i,ii)
+if time
            exterr2(i,ii)=exterr35(i,ii)
+ei
  120     continue
+if time
          tcnst2(i)=tcnst35(i)
+ei
  130   continue
        do 150 i=kanf,iu
          if(iorg.ge.0) mzu(i-kanf1)=mzu(i)
          ic(i-kanf1)=ic(i)
          icext(i-kanf1)=icext(i)
          icextal(i-kanf1)=icextal(i)
          extalign(i-kanf1,1)=extalign(i,1)
          extalign(i-kanf1,2)=extalign(i,2)
          extalign(i-kanf1,3)=extalign(i,3)
          do 140 ii=1,40
            exterr(i-kanf1,ii)=exterr(i,ii)
+if time
            exterr35(i-kanf1,ii)=exterr35(i,ii)
+ei
  140     continue
+if time
          tcnst35(i-kanf1)=tcnst2(i)
+ei
  150   continue
        do 170 i=1,kanf1
          if(iorg.ge.0) mzu(iu-kanf1+i)=ilfr(i)
          ic(iu-kanf1+i)=ilf(i)
          icext(iu-kanf1+i)=icext1(i)
          icextal(iu-kanf1+i)=icextal1(i)
          extalign(iu-kanf1+i,1)=extalig1(i,1)
          extalign(iu-kanf1+i,2)=extalig1(i,2)
          extalign(iu-kanf1+i,3)=extalig1(i,3)
          do 160 ii=1,40
            exterr(iu-kanf1+i,ii)=exterr1(i,ii)
+if time
            exterr35(iu-kanf1+i,ii)=exterr2(i,ii)
+ei
  160     continue
+if time
          tcnst35(iu-kanf1+i)=tcnst35(i)
+ei
  170   continue
      endif
      
      izu=0
      do 190 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 190
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 190
        if(kzz.eq.15) goto 190
        if(icextal(i).ne.0) then
          izu=izu+2
          xrms(ix)=one
          zrms(ix)=one
          zfz(izu)=extalign(i,1)
          izu=izu+1
          zfz(izu)=extalign(i,2)
+if crlibm
          tiltc(i)=cos_rn(extalign(i,3)*c1m3)
+ei
+if .not.crlibm
          tiltc(i)=cos(extalign(i,3)*c1m3)
+ei
+if crlibm
          tilts(i)=sin_rn(extalign(i,3)*c1m3)
+ei
+if .not.crlibm
          tilts(i)=sin(extalign(i,3)*c1m3)
+ei
        else
          izu=izu+3
        endif
        if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.icext(i).ne.0) then
          do 180 j=1,mmul
            izu=izu+1
            zfz(izu)=exterr(i,20+j)
+if time
            zfz35(izu)=exterr35(i,20+j)
+ei
            izu=izu+1
            zfz(izu)=exterr(i,j)
+if time
            zfz35(izu)=exterr35(i,j)
+ei
  180     continue
        else if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.                 &
     &icext(i).eq.0) then
          izu=izu+2*mmul
        endif
  190 continue
      return
      end
+dk phasad
      subroutine phasad(dpp,qwc)
!-----------------------------------------------------------------------
!  ADDITIONAL ADJUSTMENT OF THE X-PHASEADVANCE BETWEEN 2 POSITIONS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ikpv,im,ium,ix,izu,j,jj,jk,jm,k,kpv,kpz,kzz,l,l1,ll,nmz,&
     &dj
      double precision aa,alfa,bb,benkr,beta,ci,cikve,cr,crkve,crkveuk, &
     &dphi,dpp,dppi,dpr,dyy1,dyy2,ekk,phi,phibf,pie,puf,qu,qv,qw,qwc,   &
     &qxsa,qxse,r0,r0a,t,xl,xs,zl,zs,quz,qvz
+if tilt
      double precision dyy11,qu1,tiltck,tiltsk
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
!GRD
      qxsa = zero
      qxse = zero
!GRD
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      qwc(3)=zero
      do 40 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   40 continue
      pie=two*pi
      ikpv=0
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aenvarqmod',88,R88
!     call abend('aenvarqmod                                        ')
+ei
!--STARTVALUES OF THE TRAJECTORIES
      do 50 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
   50 t(1,ll)=clop(l)
      do 60 i=1,4
        do 60 j=1,4
          t(i+1,j)=ta(j,i)
   60 t(i+1,j)=ta(j,i)
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 450 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 140
        jj=0
        dj=1
        if(ix.gt.0) goto 70
        ix=-ix
        jj=mel(ix)+1
        dj=-1
   70   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 130 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 100
          if(ithick.eq.0.and.kz(jk).ne.0) goto 450
!--PURE DRIFTLENGTH
          do 80 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=pi2
            endif
            do 80 i=1,ium
   80     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 90 l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=pi2-phibf(l)
            endif
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr06
   90     phi(l)=phi(l)+dphi/pie
          goto 130
!--MAGNETELEMENT
  100     continue
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=-1d0*phibf(l)                                         !hr06
            endif
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
  130   continue
        goto 450
!--NL-INSERTION
  140   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 450
        kzz=kz(ix)
        kpv=kpa(ix)
        if(kpv.ne.1) goto 150
        qxsa=phi(1)
  150   if(kpv.ne.2.or.ikpv.eq.1) goto 160
        qxse=phi(1)
        ikpv=1
  160   continue
+ca trom01
+ca trom02
+ca trom03
+ca trom04
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 450
        if(kzz.eq.15) goto 450
! JBG RF CC Multipoles to 450
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 450
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 310
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('kzz',0d0,kzz,0,0,0)
!     call dumpbin('bkzz      ',77 777)
!     call abend('bkzz                                              ')
+ei
        goto(170,180,190,200,210,220,230,240,250,260,270,450,450,450,   &
     &      450,450,450,450,450,450,450,450,450,265,266,450,450,450),kzz
        goto 450
!--HORIZONTAL DIPOLE
  170   ekk=ekk*c1e3
+ca kickl01h
+ca kickq01h
        goto 420
!--NORMAL QUADRUPOLE
  180   continue
+ca kicklxxh
+ca kickq02h
        goto 420
!--NORMAL SEXTUPOLE
  190   ekk=ekk*c1m3
+ca kickq03h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL OCTUPOLE
  200   ekk=ekk*c1m6
+ca kicksho
+ca kickq04h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL DECAPOLE
  210   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL DODECAPOLE
  220   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 14-POLE
  230   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 16-POLE
  240   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 18-POLE
  250   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 20-POLE
  260   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10h
+ca kicksho
+ca kicklxxh
        goto 420
!--DIPEDGE ELEMENT
  265   continue    
+ca kickldpe
+ca kickqdpe
        goto 420
!--solenoid
  266   continue    
+ca kicklso1
+ca kickqso1
        goto 420
  270   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 280 i=2,ium
+ca multl02
  280       continue
          else
+ca multl03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 290 i=2,ium
+ca multl05
  290       continue
          else
+ca multl06
          endif
        endif
        if(abs(r0).le.pieni) goto 450
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 450
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 300 l=1,nmz
+ca multl07a
  300   continue
        if(nmz.ge.2) then
+ca multl07b
          do 305 l=3,nmz
+ca multl07c
  305     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        goto 420
!--SKEW ELEMENTS
  310   kzz=-kzz
        goto(320,330,340,350,360,370,380,390,400,410),kzz
        goto 450
!--VERTICAL DIPOLE
  320   ekk=ekk*c1e3
+ca kickl01v
+ca kickq01v
        goto 420
!--SKEW QUADRUPOLE
  330   continue
+ca kicklxxv
+ca kickq02v
        goto 420
!--SKEW SEXTUPOLE
  340   ekk=ekk*c1m3
+ca kickq03v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW OCTUPOLE
  350   ekk=ekk*c1m6
+ca kicksho
+ca kickq04v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW DECAPOLE
  360   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW DODECAPOLE
  370   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 14-POLE
  380   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 16-POLE
  390   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 18-POLE
  400   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 20-POLE
  410   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10v
+ca kicksho
+ca kicklxxv
  420   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 430 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  430   continue
        do 440 l=1,2
          ll=2*l
  440   alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))       !hr06
  450 continue
      qwc(1)=phi(1)
      qwc(2)=phi(2)
      if(qxse.ge.qxsa) then
        qwc(3)=qxse-qxsa
      else
        qwc(3)=(phi(1)+qxse)-qxsa                                        !hr06
      endif
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aphasad',97,997)
!     call abend('aphasad                                           ')
+ei
!-----------------------------------------------------------------------
      return
      end
+dk qmod
      subroutine qmod0
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES PLUS AN ADDITIONAL ADJUSTMENT OF A
!  X-PHASEADVANCE BETWEEN 2 POSITIONS IN THE MACHINE
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ierr,ii,iq1,iq2,iq3,iql,j,l,n,nite
      double precision a11,a12,a13,a21,a22,a23,a31,a32,a33,aa,aa1,bb,   &
     &dpp,dq1,dq2,dq3,qwc,qx,qz,sens,sm0,sqx,sqxh,sqz
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension sens(3,5),aa(3,3),bb(3),qx(3),qz(3),sm0(3),qwc(3)
      dimension aa1(2,2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=1,3
        bb(i)=zero
        qx(i)=zero
        qz(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        do 10 j=1,3
          aa(i,j)=zero
   10 continue
      do 20 i=1,3
        do 20 j=1,5
          sens(i,j)=zero
   20 continue
      do 30 i=1,2
        do 30 j=1,2
          aa1(i,j)=zero
   30 continue
      write(lout,10010)
      sqx=zero
      sqz=zero
      sqxh=zero
      dpp=zero
      iq1=iq(1)
      iq2=iq(2)
      if(kz(iq1).ne.2.or.kz(iq2).ne.2) call prror(8)
      if (abs(el(iq1)).le.pieni.or.abs(el(iq2)).le.pieni) then
        sm0(1)=ed(iq1)
        sm0(2)=ed(iq2)
      else
        sm0(1)=ek(iq1)
        sm0(2)=ek(iq2)
      endif
      if(kp(iq1).eq.5) call combel(iq1)
      if(kp(iq2).eq.5) call combel(iq2)
      sens(1,1)=qw0(1)
      sens(2,1)=qw0(2)
      if(abs(qw0(3)).gt.pieni) then
        iq3=iq(3)
        if(kz(iq3).ne.2) call prror(8)
        if (abs(el(iq3)).le.pieni) then
          sm0(3)=ed(iq3)
        else
          sm0(3)=ek(iq3)
        endif
        if(kp(iq3).eq.5) call combel(iq3)
        nite=3
      else
        nite=2
      endif
      call clorb(dpp)
      if(ierro.gt.0) call prror(9)
      call phasad(dpp,qwc)
      sens(1,5)=qwc(1)
      sens(2,5)=qwc(2)
      if(nite.eq.3) then
        sens(3,1)=qw0(3)
        sens(3,5)=qwc(3)
        write(lout,10100)
        write(lout,10120) qwc,qw0
      else
        write(lout,10110)
        write(lout,10130) qwc(1),qwc(2),qw0(1),qw0(2)
      endif
      do 60 ii=1,itqv
        do 40 n=1,nite
          iql=iq(n)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)+dkq
          else
            ek(iql)=ek(iql)+dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
          call clorb(dpp)
          if(ierro.gt.0) call prror(9)
          call phasad(dpp,qwc)
          sens(1,n+1)=qwc(1)
          sens(2,n+1)=qwc(2)
          if(nite.eq.3) then
            sens(3,n+1)=qwc(3)
            write(lout,10140) ii,n,qwc
          else
            write(lout,10150) ii,n,qwc(1),qwc(2)
          endif
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-dkq
          else
            ek(iql)=ek(iql)-dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
   40   continue
!--Q-VALUE ADJUSTMENT
        aa1(1,1)=(sens(1,2)-sens(1,5))/dkq
        aa1(1,2)=(sens(2,2)-sens(2,5))/dkq
        aa1(2,1)=(sens(1,3)-sens(1,5))/dkq
        aa1(2,2)=(sens(2,3)-sens(2,5))/dkq
        a11=aa1(1,1)
        a12=aa1(1,2)
        a21=aa1(2,1)
        a22=aa1(2,2)
        bb(1)=sens(1,5)-sens(1,1)
        bb(2)=sens(2,5)-sens(2,1)
        sqx=sqx+abs(bb(1))
        sqz=sqz+abs(bb(2))
        if(nite.eq.3) then
          aa(1,1)=a11
          aa(1,2)=a12
          aa(1,3)=(sens(3,2)-sens(3,5))/dkq
          aa(2,1)=a21
          aa(2,2)=a22
          aa(2,3)=(sens(3,3)-sens(3,5))/dkq
          aa(3,1)=(sens(1,4)-sens(1,5))/dkq
          aa(3,2)=(sens(2,4)-sens(2,5))/dkq
          aa(3,3)=(sens(3,4)-sens(3,5))/dkq
          a13=aa(1,3)
          a23=aa(2,3)
          a31=aa(3,1)
          a32=aa(3,2)
          a33=aa(3,3)
          bb(3)=sens(3,5)-sens(3,1)
          sqxh=sqxh+abs(bb(3))
          call loesd(aa,bb,nite,nite,ierr)
        else
          call loesd(aa1,bb,nite,nite,ierr)
        endif
        if(ierr.eq.1) call prror(35)
        do 50 l=1,nite
          iql=iq(l)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-bb(l)
          else
            ek(iql)=ek(iql)-bb(l)
          endif
          if(kp(iql).eq.5) call combel(iql)
   50   continue
        call clorb(dpp)
        if(ierro.gt.0) call prror(9)
        call phasad(dpp,qwc)
        sens(1,5)=qwc(1)
        sens(2,5)=qwc(2)
        if(nite.eq.3) then
          sens(3,5)=qwc(3)
          write(lout,10020) qw0(1),qwc(1),qw0(2),qwc(2),qw0(3),qwc(3)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10040) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2),sm0(3),ed(iq3),bez(iq3)
          else
            write(lout,10040) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2),sm0(3),ek(iq3),bez(iq3)
          endif
          write(lout,10080) sqx,sqz,sqxh
          write(lout,10060) a11,a12,a13,a21,a22,a23,a31,a32,a33
        else
          write(lout,10030) qw0(1),qwc(1),qw0(2),qwc(2)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10050) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2)
          else
            write(lout,10050) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2)
          endif
          write(lout,10090) sqx,sqz
          write(lout,10070) a11,a12,a21,a22
        endif
        if (abs(el(iq(1))).le.pieni) then
          sm0(1)=ed(iq(1))
          sm0(2)=ed(iq(2))
        else
          sm0(1)=ek(iq(1))
          sm0(2)=ek(iq(2))
        endif
        dq1=abs(qwc(1)-qw0(1))
        dq2=abs(qwc(2)-qw0(2))
        if(nite.eq.3) then
          if (abs(el(iq(3))).le.pieni) then
            sm0(3)=ed(iq(3))
          else
            sm0(3)=ek(iq(3))
          endif
          dq3=abs(qwc(3)-qw0(3))
          if(dq1.lt.dqq.and.dq2.lt.dqq.and.dq3.lt.dqq) return
        else
          if(dq1.lt.dqq.and.dq2.lt.dqq) return
        endif
   60 continue
      write(lout,10000) itqv
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'TUNE ADJUSTMENT'/ t10,                             &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.     AFTER CORRECTION'/ t10,       &
     &'HORIZONTAL'     ,17x,g16.10,2x,g16.10/ t10,                      &
     &'VERTICAL'       ,19x,g16.10,2x,g16.10/ t10,                      &
     &'PART-HORIZONTAL',12x,g16.10,2x,g16.10/)
10030 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.      AFTER CORRECTION'/ t10,      &
     &'HORIZONTAL'     ,17x,g16.10,2x,g16.10/ t10,                      &
     &'VERTICAL'       ,19x,g16.10,2x,g16.10/)
10060 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY',14x,   &
     &'D-QXH'/29x,'QF   ',d15.8,3x,d15.8,3x,d15.8/29x,                  &
     &'QD   ',d15.8,3x,d15.8,3x,d15.8/29x,                              &
     &'QF2  ',d15.8,3x,d15.8,3x,d15.8//131('-')//)
10070 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY', /29x, &
     &'QF   ',d15.8,3x,d15.8/29x,'QD   ',d15.8,3x,d15.8 //131('-')//)
10080 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7,  &
     &'   QXH =',f10.7)
10090 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7)
10100 format(t5,'---- QMOD FOR SPLIT-Q-VALUES ENTRY ---- ',             &
     &'(ZERO MOMENTUM-DEVIATION)')
10110 format(t5,'---- QMOD ENTRY ---- (ZERO MOMENTUM-DEVIATION)')
10120 format(t10,'START-QX-QY-QXH',3f12.7,' END-QX-QY-QXH',3f12.7)
10130 format(t10,'START-QX-QY',2f12.7,' END-QX-QY',2f12.7)
10140 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY-QXH',3f12.7)
10150 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY',2f12.7)
10040 format(t10,'QUADRU.STRENGTHS',7x,g16.10,2x,g16.10,'   TYP     ',  &
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
10050 format(t10,'QUADRU.STRENGTHS',7x,g16.10,2x,g16.10,'   TYP     ',  &
     &a16/t10,                  23x,g16.10,2x,g16.10,'           ',     &
     &a16)
      end
      subroutine qmodda(mm,qwc)
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES VIA DA
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,intwq,ix,mm,ncorr,ncorruo,ncrr,nd,nd2,ndh
      double precision cor,coro,dq1,dq2,dps0,edcor1,edcor2,qwc
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commonxz
+ca commonc
+ca commondl
      dimension intwq(3),qwc(3)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+if debug
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
+ei
      ncorruo=ncorru
      ncorru=1
      nd2=2*mm
      ndh=nd2+2
      intwq(1)=int(qwc(1))
      intwq(2)=int(qwc(2))
      intwq(3)=0
+if debug
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!sqmodda
!     write(*,*) 'qmodda called!'
!     call dumpbin('sqmodda',80,800)
!     call abend('sqmodda                                           ')
!     write(*,*) 'mm=',mm
+ei
      dq1=zero
      dq2=zero
      if(iqmod6.eq.1) then
        if(el(iq(1)).le.pieni) then
          edcor(1)=ed(iq(1))
        else
          edcor(1)=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          edcor(2)=ed(iq(2))
        else
          edcor(2)=ek(iq(2))
        endif
        edcor1=edcor(1)
        edcor2=edcor(2)
+if debug
!       call warr('edcor1',edcor1,1,0,0,0)
!       call warr('edcor2',edcor2,2,0,0,0)
+ei
        cor=0d0
        coro=1d38
      endif
      do ncorr=1,itqv+1
        if(nbeam.ge.1) then
          nd=mm
+ca beamcou
        endif
        if(iqmod6.eq.1) write(lout,10080) nd2
        if(iqmod6.ne.1) write(lout,10090) nd2
        if(mm.eq.2) then
          write(lout,10010) clo(1),clop(1)
          write(lout,10010) clo(2),clop(2)
        elseif(mm.eq.3) then
          write(lout,10010) clo6(1),clop6(1)
          write(lout,10010) clo6(2),clop6(2)
          write(lout,10010) clo6(3),clop6(3)
        endif
        iqmodc=2
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('bdaini',96,996)
!     call abend('before daini                                      ')
+ei
        call mydaini(1,1,nd2,mm,nd2,1)
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('adaini',96,996)
!     call abend('after  daini                                      ')
+ei
        if(iqmod6.eq.1) then
          write(lout,10000) nd2
          iqmodc=1
          call mydaini(2,3,ndh,mm,nd2,1)
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',99,999)
!     call abend('after  daini                                      ')
+ei
          do i=1,mm
            qwc(i)=dble(intwq(i))+corr(1,i)                              !hr06
          enddo
          dq1=qwc(1)-qw0(1)
          dq2=qwc(2)-qw0(2)
          if(ncorr.eq.1) cor=sqrt(dq1**2+dq2**2)                         !hr06
          if(abs(dq1).gt.dqq.or.abs(dq2).gt.dqq) then
            cor=sqrt(dq1**2+dq2**2)                                      !hr06
            if(ncorr.eq.1.or.cor.lt.coro) then
              coro=cor
              if(el(iq(1)).le.pieni) then
                ed(iq(1))=(ed(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              else
                ek(iq(1))=(ek(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              endif
              if(el(iq(2)).le.pieni) then
                ed(iq(2))=(ed(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              else
                ek(iq(2))=(ek(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) then
                  ix=ix-nblo
                  if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                    smi(ncrr)=ed(iq(1))*ratioe(ix)+smizf(ncrr)
                  else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                    smi(ncrr)=ed(iq(2))*ratioe(ix)+smizf(ncrr)
                  endif
                endif
              enddo
              if(el(iq(1)).le.pieni) then
                edcor(1)=ed(iq(1))
              else
                edcor(1)=ek(iq(1))
              endif
              if(el(iq(2)).le.pieni) then
                edcor(2)=ed(iq(2))
              else
                edcor(2)=ek(iq(2))
              endif
              if(ncorr.eq.1) then
                write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              else
                write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              endif
              if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              else
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              endif
            else
              write(lout,10050) nd2,ncorr-1
              goto 1
            endif
          else
            write(lout,10060) nd2,ncorr-1
            goto 1
          endif
        else
          iqmodc=3
          call mydaini(2,2,nd2,mm,nd2,1)
          do i=1,mm
            qwc(i)=dble(intwq(i))+wxys(i)                                !hr06
          enddo
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',98,998)
!     call abend('after  daini 98                                   ')
+ei
          goto 1
        endif
      enddo
 1    continue
      if(iqmod6.eq.1) then
        do ncrr=1,iu
          ix=ic(ncrr)
          if(ix.le.nblo) then
            if(iratioe(ix).eq.iq(1)) ek(ix)=ek(iq(1))*ratioe(ix)
            if(iratioe(ix).eq.iq(2)) ek(ix)=ek(iq(2))*ratioe(ix)
          endif
        enddo
        iqmodc=3
        call mydaini(2,2,nd2,mm,nd2,1)
        do i=1,mm
          qwc(i)=dble(intwq(i))+wxys(i)                                  !hr06
        enddo
        if(ncorr.eq.itqv+1) write(lout,10070) nd2,itqv
        if(ncorr.eq.1) then
          write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        else
          write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        endif
        if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        else
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        endif
      endif
      ncorru=ncorruo
+if debug
!     call dumpbin('end qmodda',7,999)
!     call abend('end qmodda 7 999                                  ')
+ei
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING ',i1,'D DA TUNE-VARIATION')
10010 format(1x,f47.33/1x,f47.33)
10020 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       BEFORE CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G20.14,G20.14/ t10,                         &
     &'VERTICAL'       ,17x,G20.14,G20.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10030 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       AFTER CORRECTION'/ t10,     &
     &'HORIZONTAL'     ,15x,G20.14,G20.14/ t10,                         &
     &'VERTICAL'       ,17x,G20.14,G20.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g16.10/)
10040 format(t10,'QUADRUPOLE STRENGTH',6x,g16.10,4x,g16.10,'   TYP     '&
     &,a16/t10,                  25x,g16.10,4x,g16.10,'           ',    &
     &a16)
10050 format(/t5,'---- NO IMPROVEMENT OF ',i1,'D DA TUNE-VARIATION ',   &
     &'IN ITERATION: ',i4/)
10060 format(/t10,i1,'D DA TUNE-VARIATION SUCCESSFUL IN ITERATION: ',   &
     &i4/)
10070 format(/t10,i1,'D DA TUNE-VARIATION'/ t10,                        &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10080 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA')
10090 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA (NO ',    &
     &'TUNE ADJUSTEMENT)')
      end
+dk umlauf
      subroutine umlauf(dpp,ium,ierr)
!-----------------------------------------------------------------------
!     ONE TURN-TRANSFORMATION (INCLUDING QUADRUPOLE CONTRIBUTIONS)
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ierr,im,ium,ix,izu,j,k,kpz,kx,kzz,l,ll,l1,nmz
      double precision aa,bb,benkr,ci,cikve,cr,crkve,crkveuk,dpp,dpr,   &
     &dyy1,dyy2,ekk,puf,qu,qv,quz,qvz,r0,r0a,xl,xs,zl,zs
+if tilt
      double precision dyy11,qu1,tiltck,tiltsk
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   10 continue
      do 20 i=1,5
        dpr(i)=zero
   20 continue
      ierr=0
      dpr(1)=dpp*c1e3
      izu=0
      do 350 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 60
        if(ix.le.0) goto 40
        do 30 j=1,ium
          do 30 kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
             x(j,kx)=(bl1(ix,kx,1)*puf+bl1(ix,kx,2)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,5)                                                          !hr06
             y(j,kx)=(bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl1(ix,kx,2)*y(j,kx)
            endif
   30   continue
        goto 350
   40   ix=-ix
        do 50 j=1,ium
          do 50 kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
             x(j,kx)=(bl2(ix,kx,1)*puf+bl2(ix,kx,2)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,5)                                                          !hr06
             y(j,kx)=(bl2(ix,kx,3)*puf+bl2(ix,kx,4)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl2(ix,kx,2)*y(j,kx)
            endif
   50   continue
        goto 350
   60   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 350
        kzz=kz(ix)
        if(abs(x(1,1)).lt.aper(1).and.abs(x(1,2)).lt.aper(2)) goto 70
        ierr=1
        call prror(101)
        return
 70     continue
+ca trom10
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 350
        if(kzz.eq.15) goto 350
! JBG RF CC Multipoles to 350
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 350
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignu
        if(kzz.lt.0) goto 220
        goto(80,90,100,110,120,130,140,150,160,170,180,350,350,350,     &
     &       350,350,350,350,350,350,350,350,350,175,176,350,350,350),  &
     &kzz
        goto 350
!--HORIZONTAL DIPOLE
   80   ekk=ekk*c1e3
+ca kicku01h
        goto 350
!--NORMAL QUADRUPOLE
   90   continue
+ca kickuxxh
        if(ium.eq.1) goto 350
+ca kickq02h
        goto 330
!--NORMAL SEXTUPOLE
  100   ekk=ekk*c1m3
        if(ium.ne.1) then
+ca kickq03h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL OCTUPOLE
  110   ekk=ekk*c1m6
+ca kicksho
        if(ium.ne.1) then
+ca kickq04h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DECAPOLE
  120   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq05h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DODECAPOLE
  130   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq06h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 14-POLE
  140   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq07h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 16-POLE
  150   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq08h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 18-POLE
  160   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq09h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 20-POLE
  170   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq10h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--DIPEDGE ELEMENT
  175   continue
+ca kickudpe
        if(ium.eq.1) goto 350
+ca kickqdpe
         goto 330
!--solenoid
  176   continue
+ca kickuso1
        if(ium.eq.1) goto 350
+ca kickqso1
         goto 330
  180   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multu01
            do 190 j=2,ium
+ca multu02
  190       continue
          else
+ca multu03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multu04
            do 200 j=2,ium
+ca multu05
  200       continue
          else
+ca multu06
          endif
        endif
        if(abs(r0).le.pieni) goto 350
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 350
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 210 l=1,nmz
+ca multl07a
  210   continue
        if(nmz.ge.2) then
+ca multl07b
          do 215 l=3,nmz
+ca multl07c
  215     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
        if(ium.eq.1) goto 350
        goto 330
!--SKEW ELEMENTS
  220   kzz=-kzz
        goto(230,240,250,260,270,280,290,300,310,320),kzz
        goto 350
!--VERTICAL DIPOLE
  230   ekk=ekk*c1e3
+ca kicku01v
        goto 350
!--SKEW QUADRUPOLE
  240   continue
+ca kickuxxv
        if(ium.eq.1) goto 350
+ca kickq02v
        goto 330
!--SKEW SEXTUPOLE
  250   ekk=ekk*c1m3
        if(ium.ne.1) then
+ca kickq03v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW OCTUPOLE
  260   ekk=ekk*c1m6
+ca kicksho
        if(ium.ne.1) then
+ca kickq04v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DECAPOLE
  270   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq05v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DODECAPOLE
  280   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq06v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 14-POLE
  290   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq07v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 16-POLE
  300   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq08v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 18-POLE
  310   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq09v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 20-POLE
  320   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq10v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
  330   continue
        do 340 j=2,ium
          if(kzz.eq.24) then
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
            y(j,2)=(y(j,2)-x(j,2)*quz)-qvz*x(j,1)                        !hr06
          elseif(kzz.eq.25) then
            crkve=y(j,1)-(x(j,1)*qu)*qv                                  !hr06
            cikve=y(j,2)-(x(j,2)*qu)*qv                                  !hr06
+if crlibm
            y(j,1)=crkve*cos_rn(qv)+cikve*sin_rn(qv)                     !hr09
            y(j,2)=cikve*cos_rn(qv)-crkve*sin_rn(qv)                     !hr09
            crkve=x(j,1)*cos_rn(qv)+x(j,2)*sin_rn(qv)                    !hr09
            cikve=x(j,2)*cos_rn(qv)-x(j,1)*sin_rn(qv)                    !hr09
+ei
+if .not.crlibm
            y(j,1)=crkve*cos(qv)+cikve*sin(qv) 
            y(j,2)=cikve*cos(qv)-crkve*sin(qv)                           !hr06
            crkve=x(j,1)*cos(qv)+x(j,2)*sin(qv) 
            cikve=x(j,2)*cos(qv)-x(j,1)*sin(qv)                          !hr06
+ei
            x(j,1)=crkve 
            x(j,2)=cikve 
          else
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
            y(j,2)=(y(j,2)-x(j,2)*qu)-qv*x(j,1)                          !hr06
          endif
  340   continue
  350 continue
!-----------------------------------------------------------------------
      return
      end
+dk resex
      subroutine resex(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR RMOD
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,i1,i2,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jl,jm,k,k1,kpz,    &
     &kzz,l,l1,l2,ll,lmin,m2,m4,m6,min,mm,mpe,mx,n,n2,n2e,nf1,nf3,nf4,  &
     &nkk,nmz,nn1,nn2,nnf,np,np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,   &
     &chy,ci,cikve,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dphi,dpp,  &
     &dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,phy,pie, &
     &puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,    &
     &vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
+if tilt
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension qw(2)
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18),min(5)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue
      do 40 i=1,10
        nnf(i)=0
        do 40 j=1,18
          ip(i,j)=0
          re(i,j)=zero
   40 continue
      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue
      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
              min(l)=0
   70       continue
   80     continue
   90   continue
  100 continue
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
      do 110 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
  110 t(1,ll)=clop(l)
      do 120 i=1,4
        do 120 j=1,4
          t(i+1,j)=ta(j,i)
  120 t(i+1,j)=ta(j,i)
!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 770 k=1,iu
        do 130 k1=1,10
          ab1(k1)=zero
  130   ab2(k1)=zero
        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 770
!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do 150 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=pi2
            endif
            do 150 i=1,ium
  150     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 160 l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=pi2-phibf(l)
            endif
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi
  160     phi(l)=phi(l)+dphi
          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=-1d0*phibf(l)
            endif
            if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 770
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 770
        kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 770
        if(kzz.eq.15) goto 770
! JBG RF CC Multipoles to 770
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 770
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 770
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 370
        goto(220,230,240,250,260,270,280,290,300,310,320,480,480,480,   &
     &      480,480,480,480,480,480,480,480,480,315,316,480,480,480),kzz
        goto 770
!--HORIZONTAL DIPOLE
  220   ekk=ekk*c1e3
+ca kicka01h
        goto 480
!--NORMAL QUADRUPOLE
  230   continue
+ca kicka02h
        goto 480
!--NORMAL SEXTUPOLE
  240   ekk=ekk*c1m3
+ca kicka03h
        goto 480
!--NORMAL OCTUPOLE
  250   ekk=ekk*c1m6
+ca kicka04h
        goto 480
!--NORMAL DECAPOLE
  260   ekk=ekk*c1m9
+ca kicka05h
        goto 480
!--NORMAL DODECAPOLE
  270   ekk=ekk*c1m12
+ca kicka06h
        goto 480
!--NORMAL 14-POLE
  280   ekk=ekk*c1m15
+ca kicka07h
        goto 480
!--NORMAL 16-POLE
  290   ekk=ekk*c1m18
+ca kicka08h
        goto 480
!--NORMAL 18-POLE
  300   ekk=ekk*c1m21
+ca kicka09h
        goto 480
!--NORMAL 20-POLE
  310   ekk=ekk*c1m24
+ca kicka10h
        goto 480
!--DIPEDGE ELEMENT
  315   continue
+ca kickadpe
        goto 480
!--solenoid
  316   continue
+ca kickaso1
        goto 480
  320   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 330 i=2,ium
+ca multl02
  330       continue
          else
+ca multl03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 340 i=2,ium
+ca multl05
  340       continue
          else
+ca multl06
          endif
        endif
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 770
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 770
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2
        do 350 l=lmin,mmul
          cr(l)=zero
  350   ci(l)=zero
        do 360 l=1,nmz
+ca multl13
  360   continue
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        goto 480
!--SKEW ELEMENTS
  370   kzz=-kzz
        goto(380,390,400,410,420,430,440,450,460,470),kzz
        goto 770
!--VERTICAL DIPOLE
  380   ekk=ekk*c1e3
+ca kicka01v
        goto 480
!--SKEW QUADRUPOLE
  390   continue
+ca kicka02v
        goto 480
!--SKEW SEXTUPOLE
  400   ekk=ekk*c1m3
+ca kicka03v
        goto 480
!--SKEW OCTUPOLE
  410   ekk=ekk*c1m6
+ca kicka04v
        goto 480
!--SKEW DECAPOLE
  420   ekk=ekk*c1m9
+ca kicka05v
        goto 480
!--SKEW DODECAPOLE
  430   ekk=ekk*c1m12
+ca kicka06v
        goto 480
!--SKEW 14-POLE
  440   ekk=ekk*c1m15
+ca kicka07v
        goto 480
!--SKEW 16-POLE
  450   ekk=ekk*c1m18
+ca kicka08v
        goto 480
!--SKEW 18-POLE
  460   ekk=ekk*c1m21
+ca kicka09v
        goto 480
!--SKEW 20-POLE
  470   ekk=ekk*c1m24
+ca kicka10v
  480   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
        do 500 l=1,2
          ll=2*l
          alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
  500   continue
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 770
        if(mpe.lt.nta) goto 770
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 520
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx  &
     &.eq.5.or.mx.eq.6.or.mx.eq.7) goto 520
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do 510 l=2,nmz
          l1=l-1
  510   ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
  520   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 540
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 670
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 540
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 530 l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  530   l2=l2*l/l1
  540   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 560
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 670
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 560
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 550 l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550   l2=l2*l/l1
  560   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 580
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 670
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 580
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 570 l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  570   l2=l2*l/l1
  580   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 600
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 670
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 590 l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  590   l2=l2*l/l1
  600   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 620
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 670
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 620
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 610 l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  610   l2=l2*l/l1
  620   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 640
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 670
        if(mx.eq.6.or.mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 630 l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  630   l2=l2*l/l1
  640   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 670
        if(mx.eq.7) goto 660
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do 650 l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  650   l2=l2*l/l1
  660   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  670   do 700 np=1,mpe
          n2e=2*np
          do 690 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=dble(nn1)*qxt+dble(n2)*qzt                               !hr06
            ipt=0
            do 680 ii=1,nre
  680       if(n2.eq.nrr(ii)) ipt=ipr(ii)
            ip(np,nv)=int(re1+half)+ipt
            if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-dble(ip(np,nv))                                !hr06
            res=re(np,nv)/radi
+if crlibm
           chy(np,nv)=cos_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
+ei
+if .not.crlibm
           chy(np,nv)=cos((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl)    !hr06
+ei
+if crlibm
           shy(np,nv)=sin_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
+ei
+if .not.crlibm
            shy(np,nv)=sin((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl)   !hr06
+ei
  690     continue
  700   continue
        do 760 np=nta,mpe
          np2=np
          nkk=0
  710     nkk=nkk+1
          n2e=2*np2
          do 750 i=1,nkk
            do 740 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=dble(nn2)*half                                         !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 720
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 730
  720         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  730         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  740       continue
  750     continue
          np2=np2-2
          if(np2.ge.1) goto 710
  760   continue
  770 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 810 np=nta,nte
        vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                            !hr06
        np2=np
        nkk=0
  780   nkk=nkk+1
        n2e=2*np2
        do 800 i=1,nkk
          do 790 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
      vdt2=(vdt1*e(nv1,nv2))/dble(((nnf(nf1)*nnf(i))*nnf(nf3))*nnf(nf4)) !hr06
            vdt3=dble(nn2)*ea+dble(nn1)*eb                               !hr06
            if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb          !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  790     continue
  800   continue
        np2=np2-2
        if(np2.ge.1) goto 780
  810 continue
      if(nur.eq.0) goto 840
      do 830 j=1,nur
        jk=j*2
        do 820 i=1,nur
          jl=nu(i)-npp-jk
          if(jl.eq.0) min(j)=1
  820   if(jl.eq.0) goto 830
  830 continue
  840 m2=npp+2
      m4=npp+4
      m6=npp+6
      do 850 i=1,nre
        i2=2*i
        i1=i2-1
        n=nrr(i)+npp
        dtr(i1)=rtc(npp,n,npp,1)+(min(1)*(rtc(npp,n,m2,2)-              &!hr06
     &rtc(npp,n,m2,1))+min(2)*((rtc(npp,n,m4,1)-rtc(npp,n,m4,2))+rtc    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rtc(npp,n,m6,2)-rtc(npp,n,m6,1))-rtc     &!hr06
     &(npp,n,m6,3))+ rtc(npp,n,m6,4))                                    !hr06
        dtr(i2)=rts(npp,n,npp,1)+(min(1)*(rts(npp,n,m2,2)-              &!hr06
     &rts(npp,n,m2,1))+min(2)*((rts(npp,n,m4,1)-rts(npp,n,m4,2))+rts    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rts(npp,n,m6,2)-rts(npp,n,m6,1))-rts     &!hr06
     &(npp,n,m6,3))+rts(npp,n,m6,4))                                     !hr06
  850 continue
      return
      end
+dk rmod
      subroutine rmod(dppr)
!-----------------------------------------------------------------------
!  CALCULATION OF THE STRENGTH OF CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,i1,i2,ierr,irr,j,j1,j2,j3,j4,jj1,jj2,jjr,k,n,no,ntao,   &
     &nteo
      double precision aa,bb,d1,de2,dpp,dppr,dsm,ox,oz,qwc,se11,se12,   &
     &se2,sen,sen15,sen16,sen17,sen18,sn,ss
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension aa(10,10),bb(10),dsm(10),sn(10),sen(10),ss(10)
      dimension qwc(3),d1(10),irr(12)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=npp
      nte=npp
      dpp=dppr
      do 10 i=1,10
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero
        do 10 j=1,10
          aa(i,j)=zero
   10 continue
      do 20 i=1,12
        irr(i)=0
   20 continue
      do 30 i=1,3
        qwc(i)=zero
   30 continue
      k=1
      jj1=0
      jj2=0
      jjr=2*nre
      de2=de0*half
      if(nre.eq.0) goto 50
      write(lout,10000)
      write(lout,10010) npp,totl,qxt,qzt,tam1
      call resex(dpp)
      do 40 i=1,nre
        i2=2*i
        i1=i2-1
        irr(i1)=ire(i1)
        irr(i2)=ire(i2)
        sn(i1)=ed(irr(i1))
        sn(i2)=ed(irr(i2))
        dsm(i1)=dsm0
        dsm(i2)=dsm0
        write(lout,10020) i,nrr(i),ipr(i)
        sen(i1)=dtr(i1)
        bb(i1)=sen(i1)
        sen(i2)=dtr(i2)
        bb(i2)=sen(i2)
        ss(i1)=sen(i1)
        ss(i2)=sen(i2)
   40 continue
      j2=jjr
   50 if(nur.eq.0) goto 70
      write(lout,10030) nur
      do 60 i=1,nur
        write(lout,10040) nu(i),i
   60 continue
   70 if(nch.eq.0) goto 90
      write(lout,10050)
      j1=j2+1
      j2=j2+2
      irr(j1)=ire(7)
      irr(j2)=ire(8)
      sn(j1)=ed(irr(j1))
      sn(j2)=ed(irr(j2))
      dsm(j1)=dsm0
      dsm(j2)=dsm0
      se2=zero
      se11=zero
      se12=zero
      do 80 n=1,5
        dpp=de2*dble(3-n)                                                !hr06
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ox=qwc(1)
        oz=qwc(2)
        se2=se2+dpp*dpp
        se11=se11+ox*dpp
        se12=se12+oz*dpp
   80 continue
      sen(j1)=se11/se2
      sen(j2)=se12/se2
      bb(j1)=sen(j1)
      bb(j2)=sen(j2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
   90 if(nqc.eq.0) goto 100
      write(lout,10060)
      j1=j2+1
      j2=j2+2
      jj1=j1
      jj2=j2
      irr(j1)=ire(9)
      irr(j2)=ire(10)
      if (abs(el(irr(j1))).le.pieni.or.abs(el(irr(j2))).le.pieni) then
        sn(j1)=ed(irr(j1))
        sn(j2)=ed(irr(j2))
      else
        sn(j1)=ek(irr(j1))
        sn(j2)=ek(irr(j2))
      endif
      dsm(j1)=dkq
      dsm(j2)=dkq
      dpp=zero
      call clorb2(dpp)
      call phasad(dpp,qwc)
      sen(j1)=qwc(1)
      sen(j2)=qwc(2)
      bb(j1)=sen(j1)-qw0(1)
      bb(j2)=sen(j2)-qw0(2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
  100 do 330 no=1,itcro
        do 160 i=1,j2
          if(i.ne.jj1.and.i.ne.jj2) ed(irr(i))=ed(irr(i))+dsm(i)
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))+dsm(i)
            else
              ek(irr(i))=ek(irr(i))+dsm(i)
            endif
          endif
          if(kp(irr(i)).eq.5) call combel(irr(i))
          if(nre.eq.0) goto 120
          call resex(dpp)
          do 110 j=1,jjr
            aa(i,j)=(dtr(j)-ss(j))/dsm(i)
  110     continue
  120     if(nch.eq.0) goto 140
          j3=jjr+1
          j4=jjr+2
          se2=zero
          se11=zero
          se12=zero
          do 130 n=1,5
            dpp=de2*dble(3-n)                                            !hr06
            call clorb2(dpp)
            call phasad(dpp,qwc)
            ox=qwc(1)
            oz=qwc(2)
            se2=se2+dpp*dpp
            se11=se11+ox*dpp
            se12=se12+oz*dpp
  130     continue
          sen15=se11/se2
          sen16=se12/se2
          aa(i,j3)=(sen15-ss(j3))/dsm(i)
          aa(i,j4)=(sen16-ss(j4))/dsm(i)
  140     if(nqc.eq.0) goto 150
          dpp=zero
          call clorb2(dpp)
          call phasad(dpp,qwc)
          sen17=qwc(1)
          sen18=qwc(2)
          aa(i,j1)=(sen17-ss(j1))/dsm(i)
          aa(i,j2)=(sen18-ss(j2))/dsm(i)
  150     continue
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-dsm(i)
            else
              ek(irr(i))=ek(irr(i))-dsm(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-dsm(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  160   continue
        call loesd(aa,bb,j2,10,ierr)
        if(ierr.eq.1) call prror(38)
        do 170 i=1,j2
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-bb(i)
            else
              ek(irr(i))=ek(irr(i))-bb(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-bb(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  170   continue
        if(nre.eq.0) goto 190
        call resex(dpp)
        do 180 i=1,jjr
          ss(i)=dtr(i)
  180   d1(i)=abs(ss(i))
  190   if(nch.eq.0) goto 210
        se2=zero
        se11=zero
        se12=zero
        do 200 n=1,5
          dpp=de2*dble(3-n)                                              !hr06
          call clorb2(dpp)
          call phasad(dpp,qwc)
          ox=qwc(1)
          oz=qwc(2)
          se2=se2+dpp*dpp
          se11=se11+ox*dpp
          se12=se12+oz*dpp
  200   continue
        ss(j3)=se11/se2
        ss(j4)=se12/se2
        d1(j3)=abs(ss(j3))
        d1(j4)=abs(ss(j4))
  210   if(nqc.eq.0) goto 220
        dpp=zero
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ss(j1)=qwc(1)
        ss(j2)=qwc(2)
        d1(j1)=abs(qwc(1)-qw0(1))
        d1(j2)=abs(qwc(2)-qw0(2))
  220   write(lout,10070)
        if(nre.eq.0) goto 270
        write(lout,10080) no,nrr(1),sen(1),ss(1),sen(2),ss(2)
        if(nre.eq.1) goto 240
        do 230 i=2,nre
          i2=2*i
          i1=i2-1
  230   write(lout,10090) nrr(i),sen(i1),ss(i1),sen(i2),ss(i2)
  240   write(lout,10100)
        write(lout,10110)bez(irr(1)),sn(1),ed(irr(1)),bez(irr(2)),sn(2),&
     &ed(irr(2))
        if(nre.eq.1) goto 260
        do 250 i=2,nre
          i2=2*i
          i1=i2-1
  250   write(lout,10110)bez(irr(i1)),sn(i1),ed(irr(i1)),bez(irr(i2)),sn&
     &(i2), ed(irr(i2))
  260   write(lout,10070)
  270   if(nch.eq.0) goto 280
        write(lout,10120) sen(j3),ss(j3),sen(j4),ss(j4)
        write(lout,10110)bez(irr(j3)),sn(j3),ed(irr(j3)),bez(irr(j4)),sn&
     &(j4), ed(irr(j4))
        write(lout,10070)
  280   if(nqc.eq.0) goto 290
        write(lout,10130) qw0(1),qwc(1),qw0(2),qwc(2)
        if (abs(el(irr(j1))).le.pieni) then
          write(lout,10140) sn(j1),ed(irr(j1)),irr(j1),sn(j2),          &
     &ed(irr(j2)),                                                      &
     &irr(j2)
        else
          write(lout,10140) sn(j1),ek(irr(j1)),irr(j1),sn(j2),          &
     &ek(irr(j2)),                                                      &
     &irr(j2)
        endif
  290   do 300 i=1,j2
  300   if(d1(i).gt.dsi) goto 310
        nta=ntao
        nte=nteo
        return
  310   do 320 i=1,j2
  320   bb(i)=ss(i)
        if(nqc.eq.1) bb(j1)=bb(j1)-qw0(1)
        if(nqc.eq.1) bb(j2)=bb(j2)-qw0(2)
  330 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY RMOD ----')
10010 format(/10x,'N=',i1,' IS THE ORDER OF RESONACE, THAT WILL BE',    &
     &' COMPENSATED'// 10x,'L=',f15.6,'; QX=',f10.5,'; QY=',f10.5,      &
     &'; AMAX=',f10.5)
10020 format(/10x,i1,' RESONANCE; NY=',i2,';CHANGE OF P=',i2)
10030 format(/10x,'NUMBER OF SUBRESONANCES THAT ARE CONSIDERED IS ',i2)
10040 format(/10x,'NU=',i2,' IS THE ',i1,' SUBRESONANCE-MULTIPOLE-ORDER'&
     &,i2)
10050 format(/10x,'CHROMATICITY IS COMPENSATED')
10060 format(/10x,'Q-VALUES ARE ADJUSTED')
10070 format(131('-'))
10080 format(/10x,'RESONANCE-CORRECTION     ITERATION #',i2// 15x,      &
     &'DRIVING-TERM',13x,'BEFORE         AFTER     COMPENSATION'// 10x, &
     &'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,'SIN-COMPONENT  ',2g15.5/&
     &)
10090 format(10x,'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,              &
     &'SIN-COMPONENT  ',2g15.5/)
10100 format(10x,'  ELEMENT NAME'/)
10130 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10140 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10120 format(10x,'CHROMATICITY-CORRECTION'/ 15x,'CHROMATICITY',13x,     &
     &'BEFORE         AFTER     COMPENSATION'// 19x,'HORIZONTAL   ',2g15&
     &.5/ 19x,'VERTICAL     ',2g15.5/ 10x,'   SEXTUPOLE'/)
10110 format(14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,g16.10)
      end
+dk search
      subroutine search(dpp)
!-----------------------------------------------------------------------
!  FINDING THE BEST POSITIONS FOR CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,id,n21,n22,n23,ntao,nteo
      double precision b,c,c1,c2,c3,d,dpp,e,f,g,s1,s2,s3
      character*16 ref
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=mp
      nte=mp
      ref='REFERENCE       '
      id=0
      write(lout,10010)
      write(lout,10000)
      write(lout,10010)
      write(lout,10020) mp
      write(lout,10010)
      write(lout,10030) m21,ise1,m22,ise2,m23,ise3
      write(lout,10010)
      write(lout,10040)
      write(lout,10010)
      n21=m21+mp
      n22=m22+mp
      n23=m23+mp
      ipt=ise1
      call subsea(dpp)
      c1=rtc(mp,n21,mp,1)
      s1=rts(mp,n21,mp,1)
      ipt=ise2
      call subsea(dpp)
      c2=rtc(mp,n22,mp,1)
      s2=rts(mp,n22,mp,1)
      ipt=ise3
      call subsea(dpp)
      c3=rtc(mp,n23,mp,1)
      s3=rts(mp,n23,mp,1)
      write(lout,10050) ref,id,c1,s1,c2,s2,c3,s3
      do 10 i=1,mesa
        ed(isea(i))=ed(isea(i))+dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
        ipt=ise1
        call subsea(dpp)
        b=rtc(mp,n21,mp,1)-c1
        c=rts(mp,n21,mp,1)-s1
        ipt=ise2
        call subsea(dpp)
        d=rtc(mp,n22,mp,1)-c2
        e=rts(mp,n22,mp,1)-s2
        ipt=ise3
        call subsea(dpp)
        f=rtc(mp,n23,mp,1)-c3
        g=rts(mp,n23,mp,1)-s3
        write(lout,10050) bez(isea(i)),i,b,c,d,e,f,g
        ed(isea(i))=ed(isea(i))-dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
   10 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY SEARCH ----')
10010 format(1x ,131('-'))
10020 format(10x,///'RESONANCES OF ORDER',i4,'  ARE CONSIDERED'//)
10030 format(24x ,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|',6x,'NY =',i4,    &
     &';D-P= ',i4,7x,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|')
10040 format(1x,'ELEMENT          | POS |',6x,'COS',13x,'SIN',6x,'|',   &
     &6x,'COS',13x,'SIN',6x,'|', 6x,'COS',13x,'SIN',6x,'|')
10050 format(1x,a16,1x,'|',i3,'  |',g15.5,'|',g15.5,'|',g15.5,'|',      &
     &g15.5,'|',g15.5,'|',g15.5,'|')
      end
+dk subre
      subroutine subre(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF RESONANCE- AND SUBRESONANCE-DRIVINGTERMS
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ii,ik,im,ip,ipc,ipcc,ipl,ium,iv,ix,izu,j,jj,jk,jm,k,    &
     &k1,kpz,kzz,l,l1,l2,ll,lmin,min1,min2,mis,mm,mpe,mx,n2,n22,n2e,nf1,&
     &nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,nph,nr,ns,ntx,nv,nv1,nv11,nv2, &
     &nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,cc,&
     &chy,ci,cikve,clo0,clop0,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,&
     &dfac,dphi,dpp,dpp1,dppi,dpr,dt,dtu,dtup,dyy1,dyy2,e,ea,eb,ekk,    &
     &ekko,ep,etl,gerad,gtu1,gtu2,phi,phibf,phy,pie,puf,qu,qv,qw,qwc,r0,&
     &r0a,radi,rc,re,re1,res,rn2,rs,sb1,sb2,sdel,sdel2,sea,seb,shy,ss,t,&
     &vdt1,vdt2,vdt3,vdt4,xl,xs,zl,zs,quz,qvz
+if tilt
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltck6,tiltck8,tiltck10,tiltckuk,tiltsk,tiltsk1,tiltsk2, &
     &tiltsk3,tiltsk4,tiltsk5,tiltsk6,tiltsk8,tiltsk10
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension t(6,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension clo0(2),clop0(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),qwc(3),dpr(6)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension dfac(10),dtu(2,5),dtup(2,5,0:4,0:4)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
      ipl=1
      gtu1=zero
      gtu2=zero
      dfac(1)=one
      dfac(2)=one
      dfac(3)=two
      dfac(4)=6d0                                                        !hr13
      dfac(5)=24d0                                                       !hr13
      dfac(6)=120d0                                                      !hr13
      dfac(7)=720d0                                                      !hr13
      dfac(8)=5040d0                                                     !hr13
      dfac(9)=40320d0                                                    !hr13
      dfac(10)=362880d0                                                  !hr13
      if(ipt.eq.1) ipl=3
      do 940 ipcc=1,ipl
        ipc=ipcc-ipl+1
        if(ipt.eq.0) ipc=0
        btc=zero
        bts=zero
        phy=zero
        dt=zero
        del=zero
        ns=0
        ik=0
        do 10 i=1,ium
          dpr(i)=zero
   10   continue
        do 20 i=1,ium
          do 20 j=1,4
            t(i,j)=zero
   20   continue
        do 30 i=1,2
          beta(i)=zero
          alfa(i)=zero
          phi(i)=zero
          phibf(i)=zero
          qw(i)=zero
          qwc(i)=zero
          clo0(i)=zero
          clop0(i)=zero
          ep(i)=zero
   30   continue
        qwc(3)=zero
        do 40 i=1,10
          nnf(i)=0
          do 40 j=1,18
            re(i,j)=zero
            ip(i,j)=0
   40   continue
        do 50 i=1,mmul
          aa(i)=zero
          bb(i)=zero
          cr(i)=zero
          ci(i)=zero
   50   continue
        do 60 i=1,2
          do 60 j=1,5
            dtu(i,j)=zero
   60   continue
        do 70 i=1,5
          do 70 j=0,4
            do 70 k=0,4
              dtup(1,i,j,k)=zero
              dtup(2,i,j,k)=zero
   70   continue
        do 120 i=1,9
          nz2(i)=0
          do 110 j=1,18
            chy(i,j)=zero
            shy(i,j)=zero
            do 100 k=1,10
              do 80 ii=1,10
                e(k,ii)=zero
                b(k,ii)=zero
   80         continue
              do 90 l=1,5
                rtc(i,j,k,l)=zero
                rts(i,j,k,l)=zero
   90         continue
  100       continue
  110     continue
  120   continue
        write(lout,10030)
        write(lout,10020)
        pie=two*pi
        etl=zero
        radi=totl/pie
        nr=0
        dpr(1)=dpp*c1e3
        dpr(6)=c1e3
        dpp1=dpp+ded
        call clorb(dpp1)
        do 130 l=1,2
          clo0(l)=clo(l)
  130   clop0(l)=clop(l)
        call clorb(dpp)
        do 140 l=1,2
          di0(l)=(clo0(l)-clo(l))/ded
  140   dip0(l)=(clop0(l)-clop(l))/ded
        write(lout,10030)
        write(lout,10120) (di0(l),dip0(l),l=1,2)
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        if(ierro.ne.0) call prror(22+ierro)
        write(lout,10070) dpp,qwc(1),qwc(2)
        call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
        do 150 l=1,2
          ll=2*l
          alfa(l)=alf0(l)
          beta(l)=bet0(l)
          t(1,ll-1)=clo(l)
          t(1,ll)=clop(l)
          clo0(l)=clo(l)
  150   clop0(l)=clop(l)
        do 160 i=1,4
          do 160 j=1,4
            t(i+1,j)=ta(j,i)
  160   t(i+1,j)=ta(j,i)
        write(lout,10030)
        write(lout,10040)
        write(lout,10030)
        write(lout,10010) nr,'START   ',zero,zero,(beta(l),alfa(l),     &
     &phi(l),                                                           &
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
!--EP=EMITTANCE IN PI*MM*MRAD
        ep(1)=tam1**2/beta(1)                                            !hr06
        ep(2)=tam2**2/beta(2)                                            !hr06
        write(lout,10050) tam1,ep(1),tam2,ep(2)
        write(lout,10030)
!--SINGLE TURN BLOCKLOOP
        izu=0
        do 790 k=1,iu
          do 170 k1=1,10
            ab1(k1)=zero
  170     ab2(k1)=zero
          ix=ic(k)
          if(ix.gt.nblo) goto 250
          jj=0
          dj=1
          if(ix.gt.0) goto 180
          ix=-1*ix
          jj=mel(ix)+1
          dj=-1
  180     jm=mel(ix)
!--SINGLE TURN BLOCKLOOP
          do 240 j=1,jm
            jj=jj+dj
            jk=mtyp(ix,jj)
            if(ithick.eq.1.and.kz(jk).ne.0) goto 210
            if(ithick.eq.0.and.kz(jk).ne.0) goto 790
!--PURE DRIFTLENGTH
            etl=etl+el(jk)
            do 190 l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
                phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
              else
                phibf(l)=pi2
              endif
              do 190 i=1,ium
  190       t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            do 200 l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
                dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
              else
                dphi=pi2-phibf(l)
              endif
              if(-1d0*dphi.gt.pieni) dphi=dphi+pi                        !hr06
  200       phi(l)=phi(l)+dphi/pie
            nr=nr+1
            goto 240
!--MAGNETELEMENT
  210       continue
            if(kz(jk).ne.8) etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
                phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
              else
                phibf(l)=zero
              endif
              do i=1,ium
                puf=t(i,ll-1)
                t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a    &!hr06
     &(jk,l,5)
              t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6) !hr06
              enddo
            enddo
            do l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
                dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
                dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
              else
                dphi=-phibf(l)
              endif
              if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
              phi(l)=phi(l)+dphi/pie
            enddo
            nr=nr+1
  240     continue
          goto 790
!--NL-INSERTION
  250     ix=ix-nblo
          qu=zero
          qv=zero
          kpz=kp(ix)
          if(kpz.eq.6) goto 790
          kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
          clo0(1)=t(1,1)
          clop0(1)=t(1,2)
          clo0(2)=t(2,3)
          clop0(2)=t(2,4)
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 790
          if(kzz.eq.15) goto 790
! JBG RF CC Multipoles to 790
          if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 790
          if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 790
          dyy1=zero
          dyy2=zero
          if(iorg.lt.0) mzu(k)=izu
          izu=mzu(k)+1
          ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
          izu=izu+1
          xs=xpl(ix)+zfz(izu)*xrms(ix)
          izu=izu+1
          zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
          if(kzz.lt.0) goto 400
          goto(260,270,280,290,300,310,320,330,340,350,360,790,790,790, &
     &      790,790,790,790,790,790,790,790,790,355,356,790,790,790),kzz
          goto 790
!--HORIZONTAL DIPOLE
  260     ekk=ekk*c1e3
+ca kicka01h
          goto 510
!--NORMAL QUADRUPOLE
  270     continue
+ca kicka02h
          goto 510
!--NORMAL SEXTUPOLE
  280     ekk=ekk*c1m3
+ca kicka03h
          goto 510
!--NORMAL OCTUPOLE
  290     ekk=ekk*c1m6
+ca kicka04h
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DECAPOLE
  300     ekk=ekk*c1m9
+ca kicka05h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DODECAPOLE
  310     ekk=ekk*c1m12
+ca kicka06h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 14-POLE
  320     ekk=ekk*c1m15
+ca kicka07h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 16-POLE
  330     ekk=ekk*c1m18
+ca kicka08h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 18-POLE
  340     ekk=ekk*c1m21
+ca kicka09h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 20-POLE
  350     ekk=ekk*c1m24
+ca kicka10h
+ca kispa10h
          goto 510
!--DIPEDGE ELEMENT
  355     continue
+ca kickadpe
          goto 510
!--solenoid
  356     continue
+ca kickaso1
          goto 510
  360     r0=ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 363 i=2,ium
+ca multl02
  363       continue
            else
+ca multl03
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 366 i=2,ium
+ca multl05
  366       continue
            else
+ca multl06
            endif
          endif
          mpe=9
          mx=0
          if(abs(r0).le.pieni) goto 790
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 790
          endif
          im=irm(ix)
          r0a=one
          benkr=ed(ix)/(one+dpp)
          cr(1)=one
          cr(2)=xl
          ci(2)=zl
          cxzyr=xl
          cxzyi=zl
          cxzr=cxzyr
          cxzi=cxzyi
          dyy1=zero
          dyy2=zero
          qu=zero
          qv=zero
          lmin=3
          if(nmz.eq.1) lmin=2
          do 370 l=lmin,mmul
            aa(l)=zero
            bb(l)=zero
            cr(l)=zero
  370     ci(l)=zero
          do 380 l=1,nmz
+ca multl13
  380     continue
+if tilt
+ca multl07e
+ei
          izu=izu+2*mmul-2*nmz
          do 390 iv=2,5
+ca multl12
  390     continue
          goto 510
!--SKEW ELEMENTS
  400     kzz=-kzz
          goto(410,420,430,440,450,460,470,480,490,500),kzz
          goto 790
!--VERTICAL DIPOLE
  410     ekk=ekk*c1e3
+ca kicka01v
          goto 510
!--SKEW QUADRUPOLE
  420     continue
+ca kicka02v
          goto 510
!--SKEW SEXTUPOLE
  430     ekk=ekk*c1m3
+ca kicka03v
          goto 510
!--SKEW OCTUPOLE
  440     ekk=ekk*c1m6
+ca kicka04v
          goto 510
!--SKEW DECAPOLE
  450     ekk=ekk*c1m9
+ca kicka05v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW DODECAPOLE
  460     ekk=ekk*c1m12
+ca kicka06v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 14-POLE
  470     ekk=ekk*c1m15
+ca kicka07v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 16-POLE
  480     ekk=ekk*c1m18
+ca kicka08v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 18-POLE
  490     ekk=ekk*c1m21
+ca kicka09v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 20-POLE
  500     ekk=ekk*c1m24
+ca kicka10v
+ca kispa10v
  510     continue
          t(1,2)=t(1,2)+dyy1
          t(1,4)=t(1,4)+dyy2
          do 520 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  520     continue
          do 530 l=1,2
            ll=2*l
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
  530     clop0(l)=t(1,ll)
          if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 790
          if(mpe.lt.nta) goto 790
          if(mpe.gt.nte) mpe=nte
          if(nta.gt.2) goto 550
          if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.  &
     &mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 550
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          do 540 l=2,nmz
            l1=l-1
  540     ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550     b1=beta(1)
          b2=beta(2)
          sb1=sqrt(b1)
          sb2=sqrt(b2)
          b(3,1)=b1
          b(1,3)=b2
          b(2,2)=sb1*sb2
          if(nta.gt.3) goto 570
          if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 700
          if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx &
     &.eq.6.or.mx.eq.7) goto 570
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 560 l=3,nmz
            l1=l-2
            ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  560     l2=l2*l/l1
  570     b(4,1)=b1*sb1
          b(1,4)=b2*sb2
          b(3,2)=b1*sb2
          b(2,3)=b2*sb1
          if(nta.gt.4) goto 590
          if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 700
          if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx &
     &.eq.7) goto 590
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 580 l=4,nmz
            l1=l-3
            ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  580     l2=l2*l/l1
  590     b(5,1)=b1**2                                                   !hr06
          b(1,5)=b2**2                                                   !hr06
          b(4,2)=b(3,2)*sb1
          b(2,4)=b(2,3)*sb2
          b(3,3)=b1*b2
          if(nta.gt.5) goto 610
          if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 700
          if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)      &
     &goto 610
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 600 l=5,nmz
            l1=l-4
            ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  600     l2=l2*l/l1
  610     b(6,1)=b(5,1)*sb1
          b(1,6)=b(1,5)*sb2
          b(5,2)=b(4,2)*sb1
          b(2,5)=b(2,4)*sb2
          b(4,3)=b(4,2)*sb2
          b(3,4)=b(2,4)*sb1
          if(nta.gt.6) goto 630
          if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 700
          if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 630
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 620 l=6,nmz
            l1=l-5
            ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  620     l2=l2*l/l1
  630     b(7,1)=b(6,1)*sb1
          b(1,7)=b(1,6)*sb2
          b(6,2)=b(5,2)*sb1
          b(2,6)=b(2,5)*sb2
          b(5,3)=b(5,2)*sb2
          b(3,5)=b(2,5)*sb1
          b(4,4)=b(3,4)*sb1
          if(nta.gt.7) goto 650
          if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 700
          if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 650
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 640 l=7,nmz
            l1=l-6
            ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  640     l2=l2*l/l1
  650     b(8,1)=b(7,1)*sb1
          b(1,8)=b(1,7)*sb2
          b(7,2)=b(7,1)*sb2
          b(2,7)=b(1,7)*sb1
          b(6,3)=b(5,3)*sb1
          b(3,6)=b(3,5)*sb2
          b(5,4)=b(4,4)*sb1
          b(4,5)=b(4,4)*sb2
          if(nta.gt.8) goto 670
          if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 700
          if(mx.eq.6.or.mx.eq.7) goto 670
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do 660 l=8,nmz
            l1=l-7
            ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  660     l2=l2*l/l1
  670     b(9,1)=b(8,1)*sb1
          b(1,9)=b(1,8)*sb2
          b(8,2)=b(8,1)*sb2
          b(2,8)=b(1,8)*sb1
          b(7,3)=b(7,2)*sb2
          b(3,7)=b(2,7)*sb1
          b(6,4)=b(6,3)*sb2
          b(4,6)=b(3,6)*sb1
          b(5,5)=b(4,5)*sb1
          if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 700
          if(mx.eq.7) goto 690
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
          l2=1
          do 680 l=9,nmz
            l1=l-8
            ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
  680     l2=l2*l/l1
  690     b(10,1)=b(9,1)*sb1
          b(1,10)=b(1,9)*sb2
          b(9,2)=b(9,1)*sb2
          b(2,9)=b(1,9)*sb1
          b(8,3)=b(8,2)*sb2
          b(3,8)=b(2,8)*sb1
          b(4,7)=b(3,7)*sb1
          b(7,4)=b(7,3)*sb2
          b(5,6)=b(4,6)*sb1
          b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  700     do 720 np=1,mpe
            n2e=2*np
            do 710 nv=1,n2e
              n2=nv-np
              nn2=abs(n2)
              nn1=np-nn2
              re1=dble(nn1)*qxt+dble(n2)*qzt                             !hr06
              ip(np,nv)=int(re1+half)+ipc
              if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipc
!--RE=DISTANCE FROM THE RESONANCE
              re(np,nv)=re1-dble(ip(np,nv))
              res=re(np,nv)/radi
+if crlibm
          chy(np,nv)=cos_rn((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))- &!hr06
     &res*etl)                                                           !hr06
+ei
+if .not.crlibm
          chy(np,nv)=cos((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))-    &!hr06
     &res*etl)                                                           !hr06
+ei
+if crlibm
          shy(np,nv)=sin_rn((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))- &!hr06
     &res*etl)                                                           !hr06
+ei
+if .not.crlibm
          shy(np,nv)=sin((dble(nn1)*pie*phi(1)+dble(n2)*pie*phi(2))-    &!hr06
     &res*etl)                                                           !hr06
+ei
  710       continue
  720     continue
          do 780 np=nta,mpe
            np2=np
            nkk=0
  730       nkk=nkk+1
            n2e=2*np2
            do 770 i=1,nkk
              do 760 nv=1,n2e
                nn2=abs(nv-np2)
                nv1=np2-nn2+(i-1)*2+1
                nv2=np-nv1+2
                rn2=dble(nn2)*half                                       !hr06
!--EVENESS OF N2
                mm=0
                gerad=rn2-aint(rn2)
                if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
                if (mm.eq.0) goto 740
                btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
                goto 750
  740           btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
  750           rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
                rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  760         continue
  770       continue
            np2=np2-2
            if(np2.ge.1) goto 730
  780     continue
          nr=nr+1
  790   continue
        nnf(1)=1
        nnf(2)=1
        nnf(3)=2
        nz2(2)=2
        sea=sqrt(ep(1))
        seb=sqrt(ep(2))
        ea=ep(1)
        eb=ep(2)
        e(3,1)=one/eb
        e(1,3)=one/ea
        e(2,2)=(one/seb)/sea                                             !hr06
        nnf(4)=6
        nz2(3)=4
        e(4,1)=sea/eb
        e(1,4)=seb/ea
        e(3,2)=one/seb
        e(2,3)=one/sea
        nnf(5)=24
        nz2(4)=8
        e(5,1)=ea/eb
        e(1,5)=eb/ea
        e(4,2)=sea/seb
        e(2,4)=seb/sea
        e(3,3)=one
        nnf(6)=120
        nz2(5)=16
        e(6,1)=e(5,1)*sea
        e(1,6)=e(1,5)*seb
        e(5,2)=ea/seb
        e(2,5)=eb/sea
        e(4,3)=sea
        e(3,4)=seb
        nnf(7)=720
        nz2(6)=32
        e(7,1)=e(6,1)*sea
        e(1,7)=e(1,6)*seb
        e(6,2)=e(5,2)*sea
        e(2,6)=e(2,5)*seb
        e(5,3)=ea
        e(3,5)=eb
        e(4,4)=sea*seb
        nnf(8)=5040
        nz2(7)=64
        e(8,1)=e(7,1)*sea
        e(1,8)=e(1,7)*seb
        e(7,2)=e(6,2)*sea
        e(2,7)=e(2,6)*seb
        e(6,3)=ea*sea
        e(3,6)=eb*seb
        e(5,4)=ea*seb
        e(4,5)=sea*eb
        nnf(9)=40320
        nz2(8)=128
        e(9,1)=e(8,1)*sea
        e(1,9)=e(1,8)*seb
        e(8,2)=e(7,2)*sea
        e(2,8)=e(2,7)*seb
        e(7,3)=ea**2                                                     !hr06
        e(3,7)=eb**2                                                     !hr06
        e(6,4)=e(5,4)*sea
        e(4,6)=e(4,5)*seb
        e(5,5)=ea*eb
        nnf(10)=362880
        nz2(9)=256
        e(10,1)=e(9,1)*sea
        e(1,10)=e(1,9)*seb
        e(9,2)=e(8,2)*sea
        e(2,9)=e(2,8)*seb
        e(8,3)=e(7,3)*sea
        e(3,8)=e(3,7)*seb
        e(7,4)=e(6,4)*sea
        e(4,7)=e(4,6)*seb
        e(6,5)=e(5,5)*sea
        e(5,6)=e(5,5)*seb
        write(lout,10000)
        write(lout,10030)
        write(lout,10010)nr,'END     ',etl,zero,(beta(l),alfa(l),phi(l),&
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
        write(lout,10030)
        write(lout,10110) etl,qwc(1),qwc(2)
        write(lout,10030)
        do 800 iv=2,5
          gtu1=gtu1+dtu(1,iv)
          gtu2=gtu2+dtu(2,iv)
  800   continue
        write(lout,10150) dtu(1,2),dtu(1,3),dtu(1,4),dtu(1,5),gtu1, dtu &
     &(2,2),dtu(2,3),dtu(2,4),dtu(2,5),gtu2
        do 810 i=1,2
          do 810 j=1,5
            do 810 l=0,4
              do 810 k=0,4
                if(i.eq.2.and.j.eq.1.and.k.eq.1.and.l.eq.1) write       &
     &(lout,10160)
                if(abs(dtup(i,j,k,l)).gt.pieni) write(lout,             &
     &'(10X,G16.10,3X,I2,2X,I2)') dtup(i,j,k,l),k,l
  810   continue
        write(lout,10060)
        write(lout,10030)
        do 880 np=nta,nte
          write(lout,10080) np
          write(lout,10030)
          vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                          !hr06
          np2=np
          nkk=0
          write(lout,10090) np
          goto 830
  820     write(lout,10100) np,np2
  830     nkk=nkk+1
          n2e=2*np2
          do 850 i=1,nkk
            do 840 nv=1,n2e
              n2=nv-np2
              nn2=abs(n2)
              nn1=np2-nn2
              nv1=(nn1+(i-1)*2)+1                                        !hr06
              nv2=(np-nv1)+2                                             !hr06
              nv11=nv1-1
              nv21=nv2-1
              nf1=nn1+i
              nf3=nkk-i+1
              nf4=nf3+nn2
          vdt2=vdt1*e(nv1,nv2)/dble(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4))   !hr06
              vdt3=dble(nn2)*ea+dble(nn1)*eb                             !hr06
              vdt4=vdt3
              if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb        !hr06
              rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
              rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  840       continue
  850     continue
          do 870 nv=1,n2e
            mis=1
            rc=zero
            rs=zero
            do 860 i=1,nkk
              rc=rc+dble(mis)*rtc(np2,nv,np,i)                           !hr06
              rs=rs+dble(mis)*rts(np2,nv,np,i)                           !hr06
              mis=-mis
  860       continue
            sdel2=sqrt(rc**2+rs**2)                                      !hr06
            n22=nv-np2
            write(lout,10140) n22,ip(np2,nv),ipc,rc,rs,re(np2,nv),sdel2
  870     continue
          np2=np2-2
          if(np2.ge.1) goto 820
  880   continue
        ntx=nte-2
        write(lout,10130)
        do 930 np=1,nte
          write(lout,10090) np
          n2e=2*np
          do 920 nv=1,n2e
            n2=nv-np
            nkk=2
            nph=np+2
            min1=-1
  890       min2=min1
            do 900 i=1,nkk
             rtc(np,nv,np,1)=rtc(np,nv,np,1)+dble(min2)*rtc(np,nv,nph,i) !hr06
             rts(np,nv,np,1)=rts(np,nv,np,1)+dble(min2)*rts(np,nv,nph,i) !hr06
              min2=-min2
  900       continue
            nph=nph+2
            if(nph.gt.nte) goto 910
            nkk=nkk+1
            min1=-min1
            goto 890
  910       cc=rtc(np,nv,np,1)
            ss=rts(np,nv,np,1)
            sdel=sqrt(cc**2+ss**2)                                       !hr06
            write(lout,10140) n2,ip(np,nv),ipc,cc,ss,re(np,nv),sdel
  920     continue
  930   continue
  940 continue
      call clorb(ded)
      do 950 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  950 continue
      call clorb(zero)
      do 960 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  960 continue
!-----------------------------------------------------------------------
      return
10000 format(1x,i4,27x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x, &
     &f6.3,1x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x,f6.3)
10020 format(t5,'---- ENTRY SUBRES ----')
10030 format(131('-'))
10040 format('  NR  TYP      L-TOTAL  LENGTH   BETAH  ALFAH  ',         &
     &' PHIH   DISH  DISPH   CLOH  CLOPH',                              &
     &'   BETAV  ALFAV   PHIV   DISV  DISPV   CLOV  CLOPV'/ 1x,         &
     &'                 (M)      (M)     (M)           ',               &
     &'(QE)   (M)   (RAD)   (MM) (MRAD)',                               &
     &'    (M)           (QE)   (M)   (RAD)   (MM) (MRAD)')
10050 format(//7x,'INIT. X-AMPLITUDE=',g15.8,'X-EMITTANCE=',g15.8,/40x, &
     &/7x,'INIT. Y-AMPLITUDE=',g15.8,'Y-EMITTANCE=',g15.8,              &
     &'UNITS ARE (PI X MM X MRAD)'//)
10060 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x)
10070 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7)
10080 format(/10x,'RESONANCE EXCITING MULTIPOLE-ORDER = ',i2)
10090 format(//20x,'RESONANCE-ORDER =',i2/20x,100('-')/ 20x,'| NY |',   &
     &'   P  | D-P |',2x,'DRIVING-COS ',3x,'|', 2x,'DRIVING-SIN ',3x,'|'&
     &, 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10100 format(//20x,'RESONANCE-ORDER =',i2,5x,'SUBRESONANCE-ORDER = ',i2,&
     &/20x,100('-')/ 20x,'| NY |','   P  | D-P |',2x,'DRIVING-COS ',3x, &
     &'|', 2x,'DRIVING-SIN ',3x,'|', 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10110 format(/10x,'PRECISE LENGTH OF THE MACHINE : ',f43.33/ /10x,      &
     &'   PRECISE HORIZONTAL Q-VALUE : ',f43.33/ /10x,                  &
     &'     PRECISE VERTICAL Q-VALUE : ',f43.33/)
10120 format(t8,'  PLANE     DISP(MM)     DISP(MRAD)   '/ t6,'      X  '&
     &,2(f12.3,3x)/t10,'  Y  ',2(f12.3,3x)/)
10130 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x,    &
     &'!!!! ALL SUBRESONANCES ARE INCLUDED !!!! ')
10140 format(20x,'| ',i2,' | ',i4,' | ',i3,' |', g16.8,' |',g16.8,' |', &
     &g16.8,' |',g16.8,' |')
10150 format(/10x,'NONLINEAR DETUNING  '// 10x,'CHANGE IN QX'/ 10x,     &
     &' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ 10x,' 8. ORDER ',f15&
     &.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  ',f15.12/ 10x,       &
     &'CHANGE IN QY'/ 10x,' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ &
     &10x,' 8. ORDER ',f15.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  '&
     &,f15.12// 10x,'DETUNING ORDER BY ORDER'// 10x,                    &
     &'Qx - COEFFICIENT   Ex  EY'/ 10x,'-------------------------')
10160 format(/ 10x,'Qy - COEFFICIENT   Ex  Ey'/ 10x,                    &
     &'-------------------------')
10010 format(1x,i4,1x,a8,1x,f8.2,1x,f7.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.&
     &2,1x,f6.3,1x,f6.2,1x,f6.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6. &
     &3,1x,f6.2,1x,f6.3)
      end
      subroutine detune(iv,ekk,ep,beta,dtu,dtup,dfac)
!-----------------------------------------------------------------------
!  USED FOR SUBRE - CALCULATES DETUNING
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer iv,iv2,iv3,iv4,iv5,iv6
      double precision beta,dfac,dtu,dtu1,dtu2,dtup,ekk,ep,pi,vor,vtu1, &
     &vtu2
+ca parpro
+ca parnum
      dimension dfac(10),dtu(2,5),ep(2),beta(2),dtup(2,5,0:4,0:4)
      save
!-----------------------------------------------------------------------
      if(iv.lt.2) then
        write(lout,*)
        write(lout,*) '       ***** ERROR IN DETUNE *****'
        write(lout,*)
        write(lout,*) '       IV LESS THAN 2, NO DETUNING POSSIBLE'
        write(lout,*)
        return
      endif
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      iv2=2*iv
      iv3=iv+1
!      vtu1=(((-1d0*ekk)*(half**iv2))*dfac(iv2))/pi                       !hr06
+if crlibm
      vtu1=(((-1d0*ekk)*exp_rn(dble(iv2)*log_rn(half)))*dfac(iv2))/pi    !hr13 
+ei
+if .not.crlibm
      vtu1=(((-1d0*ekk)*exp(dble(iv2)*log(half)))*dfac(iv2))/pi          !hr13
+ei
      dtu1=zero
      dtu2=zero
      do 10 iv4=1,iv3
        iv5=iv4-1
        iv6=iv-iv5
        vor=one
        if(mod(iv6,2).ne.0) vor=-1d0*one                                 !hr06
!        vtu2=vor/(dfac(iv5+1)**2)/(dfac(iv6+1)**2)*(beta(1)**iv5)* (beta&
!     &(2)**iv6)
+if crlibm
        vtu2=(((vor/(dfac(iv5+1)**2))/(dfac(iv6+1)**2))*                &!hr13
     &exp_rn(dble(iv5)*log_rn(beta(1))))*                               &!hr13
     &exp_rn(dble(iv6)*log_rn(beta(2)))                                  !hr13
+ei
+if .not.crlibm
        vtu2=(((vor/(dfac(iv5+1)**2))/(dfac(iv6+1)**2))*                &!hr13
     &exp(dble(iv5)*log(beta(1))))*exp(dble(iv6)*log(beta(2)))           !hr13
+ei
        if(iv5.ne.0) then
!          dtu1=dtu1+((vtu2*dble(iv5))*(ep(1)**(iv5-1)))*(ep(2)**iv6)     !hr06
+if crlibm
         dtu1=dtu1+((vtu2*dble(iv5))*exp_rn(dble(iv5-1)*log_rn(ep(1))))*&!hr13
     &         exp_rn(dble(iv6)*log_rn(ep(2)))                           !hr13
+ei
+if .not.crlibm
          dtu1=dtu1+((vtu2*dble(iv5))*exp(dble(iv5-1)*log(ep(1))))*     &!hr13
     &         exp(dble(iv6)*log(ep(2)))                                 !hr13
+ei
         dtup(1,iv,iv5-1,iv6)=dtup(1,iv,iv5-1,iv6)+(vtu2*dble(iv5))*vtu1 !hr06
        endif
        if(iv6.ne.0) then
!          dtu2=dtu2+((vtu2*dble(iv6))*(ep(1)**iv5))*(ep(2)**(iv6-1))     !hr06
+if crlibm
          dtu2=dtu2+((vtu2*dble(iv6))*exp_rn(dble(iv5)*log_rn(ep(1))))* &!hr13
     &                exp_rn(dble(iv6-1)*log_rn(ep(2)))                  !hr13
+ei
+if .not.crlibm
          dtu2=dtu2+((vtu2*dble(iv6))*exp(dble(iv5)*log(ep(1))))*       &!hr13
     &                exp(dble(iv6-1)*log(ep(2)))                        !hr13
+ei
         dtup(2,iv,iv5,iv6-1)=dtup(2,iv,iv5,iv6-1)+(vtu2*dble(iv6))*vtu1 !hr06
        endif
   10 continue
      dtu(1,iv)=dtu(1,iv)+vtu1*dtu1
      dtu(2,iv)=dtu(2,iv)+vtu1*dtu2
      return
      end
+dk subsea
      subroutine subsea(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR SEARCH
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jm,k,k1,kpz,kzz,l,l1,    &
     &l2,ll,lmin,mm,mpe,mx,n2,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,   &
     &np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
      double precision aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,   &
     &chy,ci,cikve,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dphi,dpp,  &
     &dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,phy,pie, &
     &puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,    &
     &vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
+if tilt
      double precision dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
+ei
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do 20 i=1,ium
        do 20 j=1,4
          t(i,j)=zero
   20 continue
      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue
      do 40 i=1,10
        nnf(i)=0
        do 40 j=1,18
          ip(i,j)=0
          re(i,j)=zero
   40 continue
      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue
      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
   70       continue
   80     continue
   90   continue
  100 continue
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb2(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
!--STARTVALUES OF THE TRAJECTORIES
      do 110 l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
  110 t(1,ll)=clop(l)
      do 120 i=1,4
        do 120 j=1,4
          t(i+1,j)=ta(j,i)
  120 t(i+1,j)=ta(j,i)
!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06
!--SINGLE TURN BLOCKLOOP
      izu=0
      do 740 k=1,iu
        do 130 k1=1,10
          ab1(k1)=zero
  130   ab2(k1)=zero
        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 740
!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do 150 l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=pi2
            endif
            do 150 i=1,ium
  150     t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
          do 160 l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=pi2-phibf(l)
            endif
            if(-1d0*dphi.gt.pieni) dphi=dphi+pi                          !hr06
  160     phi(l)=phi(l)+dphi
          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              phibf(l)=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))
+ei
+if .not.crlibm
              phibf(l)=atan(t(ll+1,ll-1)/t(ll,ll-1))
+ei
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
+if crlibm
              dphi=atan_rn(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
+if .not.crlibm
              dphi=atan(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
+ei
            else
              dphi=-phibf(l)
            endif
            if(kz(jk).ne.8.and.-1d0*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 740
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 740
        kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 740
        if(kzz.eq.15) goto 740
! JBG RF CC Multipoles to 740
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 740
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 740 
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 350
        goto(220,230,240,250,260,270,280,290,300,310,320,740,740,740,   &
     &      740,740,740,740,740,740,740,740,740,315,316,740,740,740),kzz
        goto 740
!--HORIZONTAL DIPOLE
  220   ekk=ekk*c1e3
+ca kicka01h
        goto 460
!--NORMAL QUADRUPOLE
  230   continue
+ca kicka02h
        goto 460
!--NORMAL SEXTUPOLE
  240   ekk=ekk*c1m3
+ca kicka03h
        goto 460
!--NORMAL OCTUPOLE
  250   ekk=ekk*c1m6
+ca kicka04h
        goto 460
!--NORMAL DECAPOLE
  260   ekk=ekk*c1m9
+ca kicka05h
        goto 460
!--NORMAL DODECAPOLE
  270   ekk=ekk*c1m12
+ca kicka06h
        goto 460
!--NORMAL 14-POLE
  280   ekk=ekk*c1m15
+ca kicka07h
        goto 460
!--NORMAL 16-POLE
  290   ekk=ekk*c1m18
+ca kicka08h
        goto 460
!--NORMAL 18-POLE
  300   ekk=ekk*c1m21
+ca kicka09h
        goto 460
!--NORMAL 20-POLE
  310   ekk=ekk*c1m24
+ca kicka10h
        goto 460
!--DIPEDGE ELEMENT
  315   continue  
+ca kickadpe
        goto 460
!--solenoid
  316   continue  
+ca kickaso1
        goto 460
  320   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 323 i=2,ium
+ca multl02
  323       continue
          else
+ca multl03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 326 i=2,ium
+ca multl05
  326       continue
          else
+ca multl06
          endif
        endif
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 740
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 740
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2
        do 330 l=lmin,mmul
          cr(l)=zero
  330   ci(l)=zero
        do 340 l=1,nmz
+ca multl13
  340   continue
+if tilt
+ca multl07e
+ei
        izu=(izu+2*mmul)-2*nmz                                           !hr06
        goto 460
!--SKEW ELEMENTS
  350   kzz=-kzz
        goto(360,370,380,390,400,410,420,430,440,450),kzz
        goto 740
!--VERTICAL DIPOLE
  360   ekk=ekk*c1e3
+ca kicka01v
        goto 460
!--SKEW QUADRUPOLE
  370   continue
+ca kicka02v
        goto 460
!--SKEW SEXTUPOLE
  380   ekk=ekk*c1m3
+ca kicka03v
        goto 460
!--SKEW OCTUPOLE
  390   ekk=ekk*c1m6
+ca kicka04v
        goto 460
!--SKEW DECAPOLE
  400   ekk=ekk*c1m9
+ca kicka05v
        goto 460
!--SKEW DODECAPOLE
  410   ekk=ekk*c1m12
+ca kicka06v
        goto 460
!--SKEW 14-POLE
  420   ekk=ekk*c1m15
+ca kicka07v
        goto 460
!--SKEW 16-POLE
  430   ekk=ekk*c1m18
+ca kicka08v
        goto 460
!--SKEW 18-POLE
  440   ekk=ekk*c1m21
+ca kicka09v
        goto 460
!--SKEW 20-POLE
  450   ekk=ekk*c1m24
+ca kicka10v
  460   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 470 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  470   continue
        do 480 l=1,2
          ll=2*l
          alfa(l)=-1d0*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
  480   continue
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 740
        if(mpe.lt.nta) goto 740
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 500
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx  &
     &.eq.5.or.mx.eq.6.or.mx.eq.7) goto 500
!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do 490 l=2,nmz
          l1=l-1
  490   ab2(2)=ab2(2)+dble(l1)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
  500   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 520
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 650
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 520
!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 510 l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  510   l2=l2*l/l1
  520   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 540
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 650
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 540
!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 530 l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  530   l2=l2*l/l1
  540   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 560
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 650
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 560
!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 550 l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  550   l2=l2*l/l1
  560   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 580
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 650
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580
!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 570 l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  570   l2=l2*l/l1
  580   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 600
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 650
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600
!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 590 l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  590   l2=l2*l/l1
  600   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 620
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 650
        if(mx.eq.6.or.mx.eq.7) goto 620
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do 610 l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  610   l2=l2*l/l1
  620   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 650
        if(mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do 630 l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+dble(l2)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+dble(l2)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
  630   l2=l2*l/l1
  640   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  650   do 670 np=1,mpe
          n2e=2*np
          do 660 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=dble(nn1)*qxt+dble(n2)*qzt                               !hr06
            ip(np,nv)=int(re1+half)+ipt
            if(-1d0*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt      !hr06
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-dble(ip(np,nv))                                !hr06
            res=re(np,nv)/radi
+if crlibm
           chy(np,nv)=cos_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
+ei
+if .not.crlibm
           chy(np,nv)=cos((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl)    !hr06
+ei
+if crlibm
           shy(np,nv)=sin_rn((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl) !hr06
+ei
+if .not.crlibm
           shy(np,nv)=sin((dble(nn1)*phi(1)+dble(n2)*phi(2))-res*etl)    !hr06
+ei
  660     continue
  670   continue
        do 730 np=nta,mpe
          np2=np
          nkk=0
  680     nkk=nkk+1
          n2e=2*np2
          do 720 i=1,nkk
            do 710 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=dble(nn2)*half                                         !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 690
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 700
  690         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  700         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  710       continue
  720     continue
          np2=np2-2
          if(np2.ge.1) goto 680
  730   continue
  740 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 780 np=nta,nte
        vdt1=dble(nnf(np))/(dble(nz2(np))*pi)                            !hr06
        np2=np
        nkk=0
  750   nkk=nkk+1
        n2e=2*np2
        do 770 i=1,nkk
          do 760 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
            vdt2=vdt1*e(nv1,nv2)/dble(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4)) !hr06
            vdt3=dble(nn2)*ea+dble(nn1)*eb                               !hr06
            if(n2.ge.0) vdt3=dble(n2*nv21)*ea+dble(nn1*nv11)*eb          !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  760     continue
  770   continue
        np2=np2-2
        if(np2.ge.1) goto 750
  780 continue
      return
      end
+dk decoup
      subroutine decoup
!-----------------------------------------------------------------------
!  DECOUPLING USING MATRIX ELEMENTS
!
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ierr,j,no
      double precision aa,bb,d1,dpp,dsm,qw,qwc,sen,sn,ss
+ca parpro
+ca parnum
+ca common
+ca commons
+ca commont1
      dimension aa(6,6),bb(6),dsm(6),sn(6),sen(6),ss(6)
      dimension qwc(3),qw(2),d1(6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=1,6
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero
        do 10 j=1,6
          aa(i,j)=zero
   10 continue
      do 20 i=1,3
        qwc(i)=zero
   20 continue
      dpp=zero
      write(lout,10000)
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      sen(1)=ta(3,1)
      sen(2)=ta(3,2)
      sen(3)=ta(4,1)
      sen(4)=ta(4,2)
      if(iskew.eq.1) then
        sen(5)=qwc(1)
        sen(6)=qwc(2)
      endif
      do 30 i=1,6
        if(iskew.eq.2.and.i.gt.4) goto 30
        if(i.le.4) then
          sn(i)=ed(nskew(i))
          dsm(i)=dsm0
          bb(i)=sen(i)
        else
          if (abs(el(nskew(i))).le.pieni) then
            sn(i)=ed(nskew(i))
          else
            sn(i)=ek(nskew(i))
          endif
          dsm(i)=dkq
          bb(i)=sen(i)-qwsk(i-4)
        endif
        ss(i)=sen(i)
   30 continue
      do 100 no=1,itcro
        do 40 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 40
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))+dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))+dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))+dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
          call betalf(dpp,qw)
          call phasad(dpp,qwc)
          aa(i,1)=(ta(3,1)-ss(1))/dsm(i)
          aa(i,2)=(ta(3,2)-ss(2))/dsm(i)
          aa(i,3)=(ta(4,1)-ss(3))/dsm(i)
          aa(i,4)=(ta(4,2)-ss(4))/dsm(i)
          if(iskew.eq.1) then
            aa(i,5)=(qwc(1)-ss(5))/dsm(i)
            aa(i,6)=(qwc(2)-ss(6))/dsm(i)
          endif
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))-dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   40   continue
        if(iskew.eq.1) then
          call loesd(aa,bb,6,6,ierr)
        else if(iskew.eq.2) then
          call loesd(aa,bb,4,4,ierr)
        endif
        if(ierr.eq.1) call prror(64)
        do 50 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 50
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-bb(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-bb(i)
            else
              ek(nskew(i))=ek(nskew(i))-bb(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   50   continue
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        ss(1)=ta(3,1)
        ss(2)=ta(3,2)
        ss(3)=ta(4,1)
        ss(4)=ta(4,2)
        if(iskew.eq.1) then
          ss(5)=qwc(1)
          ss(6)=qwc(2)
        endif
        write(lout,10010)
        write(lout,10020) no,sen(1),ss(1),sen(2),ss(2),sen(3),ss(3), sen&
     &(4),ss(4)
        write(lout,10030) bez(nskew(1)),sn(1),ed(nskew(1)),             &
     &bez(nskew(2)),sn                                                  &
     &(2),ed(nskew(2)),bez(nskew(3)),sn(3),ed(nskew(3)), bez            &
     &(nskew(4)),sn(4),ed(nskew(4))
        if(iskew.eq.1) then
          write(lout,10010)
          write(lout,10040) qwsk(1),qwc(1),qwsk(2),qwc(2)
          if (abs(el(nskew(5))).le.pieni) then
            write(lout,10060) sn(5),ed(nskew(5)),nskew(5),sn(6),ed      &
     &(nskew(6)), nskew(6)
          else
            write(lout,10060) sn(5),ek(nskew(5)),nskew(5),sn(6),ek      &
     &(nskew(6)), nskew(6)
          endif
        else if(iskew.eq.2) then
          write(lout,10010)
          write(lout,10050) qwc(1),qwc(2)
        endif
        do 60 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 60
          if(i.le.4) then
            d1(i)=abs(ss(i))
          else
            d1(i)=abs(ss(i)-qwsk(i-4))
          endif
   60   continue
        do 70 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 70
          if(d1(i).gt.dsi) goto 80
   70   continue
        return
   80   do 90 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 90
          if(i.le.4) then
            bb(i)=ss(i)
          else
            bb(i)=ss(i)-qwsk(i-4)
          endif
   90   continue
  100 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY DECOUP ----')
10010 format(131('-'))
10020 format(/10x,'DECOUPLING ROUTINE  ITERATION #',i2// 30x,           &
     &'BEFORE         AFTER     DECOUPLING'// 17x,'   M(3,1)      ',2g15&
     &.5/ 17x,'   M(3,2)      ',2g15.5/ 17x,'   M(4,1)      ',2g15.5/ 17&
     &x,'   M(4,2)      ',2g15.5// 5x,'SKEW QUDRUPOLE STRENGTHS')
10040 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10050 format(10x,'CURRENT TUNE' / 10x,'Q-VALUE'/ 10x,'HORIZONTAL     ', &
     &g15.7/ 10x,'VERTICAL       ',g15.7/)
10060 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10030 format(14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,          &
     &g16.10/14x,a16,2x,g16.10,1x,g16.10/14x,a16,2x,g16.10,1x,g16.10)
      end
+dk postpr
+if .not.stf
+if .not.cr
      subroutine postpr(nfile)
+ei
+if cr
      subroutine postpr(nfile,nnuml)
+ei
+ei
+if stf
+if .not.cr
      subroutine postpr(posi)
+ei
+if cr
      subroutine postpr(posi,nnuml)
+ei
+ei
!-----------------------------------------------------------------------
!  POST PROCESSING
!
!  NFILE   :  FILE UNIT (non-STF) -- always fixed to 90 for STF version.
!  POSI    :  PARTICLE NUMBER
!             (the first particle in pair if ntwin=2, i.e. it is a  pair).
!  NNUML   :  ??
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
+ca parpro
+ca parnum
+ca common1
+if vvector
+ca common2
+ei
+ca commonds
+ca commonc
+ca commphin
+if cr
+ca crco
+ei
+ca commonxz
      integer i,i1,i11,i2,i3,ia,ia0,iaa,iab,iap6,iapx,iapz,ich,idnt,    &
     &ierro,idummy,if1,if2,ife,ife2,ifipa,ifp,ii,ilapa,ilyap,im1,im1s,  &
     &invx,invz,iq,iskc,itopa,iturn,ivo6,iwar6,iwarx,iwarz,j,jm1,jm1s,  &
     &jq,k,k1,nerror,nfft,nfile,nivh,nlost,ntwin,nuex,nuez,nuix,nuiz,   &
     &numl
+if stf
      integer posi,posi1, ia_stf,ifipa_stf,ilapa_stf
      double precision b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf,
     &c1_stf,d1_stf,e1_stf,f1_stf,g1_stf,h1_stf,p1_stf
+ei
      real tim1,tim2,fxs,fzs
      double precision const,dle,slope,tle,varlea,wgh
      double precision alf0,alf04,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,   &
     &alf0z3,ampx0,ampz0,angi,angii,angiii,ared,ares,armin,armin0,b,b0, &
     &bet0,bet04,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,biav,bold,c, &
     &c0,c1,c6,clo,cloau,clop,cx,cz,d,d0,d1,dani,dared,dares,di0,di0au, &
     &di11,dife,dip0,dizu0,dle1,dle1c,dmmac,dnms,dnumlr,dp1,dph6,dphx,  &
     &dphz,dpx,dpxp,dpz,dpzp,dummy,e,e0,e1,emag,emat,emax,emaz,emi,emig,&
     &emii,emiii,emit,emix,emiz,emt,emta,emts,emx,emx0,emxa,emxs,emz,   &
     &emz0,emza,emzs,evt,evt1,evtm,evtma,evtmi,evx,evx1,evx2,evxm,evxma,&
     &evxmi,evz,evz1,evz2,evzm,evzma,evzmi,f,f0,f1,ffx,ffz,finv,g,g0,g1,&
     &gam0s1,gam0s2,gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,h, &
     &h0,h1,p,p1,pcha,phase,pieni2,pinx,pinz,pixr,pizr,pmax,pmin,prec,  &
     &qs0,qwc,ratemx,ratemz,rbeta,s6,sdp6,sdpx,sdpz,sevt,sevx,sevz,     &
     &slopem,sumda,sx,sz,t,ta,ta16,ta26,ta36,ta46,ta56,ta61,ta62,ta63,  &
     &ta64,ta65,tasum,tidnt,tle1,tlo,tph6,tphx,tphz,tpi,txyz,txyz2,x,   &
     &xing,xinv,xp,xp0,xxaux,xxmax,xxmin,xxi,xxr,xyzv,xyzv2,zing,zinv,  &
     &zp,zp0,zzaux,zzmax,zzmin,zzi,zzr
      character*80 title(20),chxtit(20),chytit(20)
      character*8 cdate,ctime,progrm
      character*11 hvs
      character*8192 ch
+if crlibm
      character*25 ch1
      integer errno,l1,l2
      integer dtostr
+ei
      dimension tle(nlya),dle(nlya)
      dimension wgh(nlya),biav(nlya),slope(nlya),varlea(nlya)
      dimension xinv(ninv),invx(ninv),zinv(ninv),invz(ninv)
      dimension xxr(npos),xxi(npos),zzr(npos),zzi(npos),fxs(npos),      &
     &fzs(npos)
      dimension bet0(3),alf0(3),t(6,6)
      dimension bet04(2),alf04(2)
      dimension pmin(30),pmax(30)
      dimension idummy(6)
      dimension sumda(60)
      dimension x(2,6),cloau(6),di0au(4)
      dimension qwc(3),clo(3),clop(3),di0(2),dip0(2)
      dimension ta(6,6),txyz(6),txyz2(6),xyzv(6),xyzv2(6),rbeta(6)
+if cr
      integer nnuml
+ei
+ca version
      save
!----------------------------------------------------------------------
!--TIME START
      pieni2=1d-8
      tlim=1e7
      call timest(tlim)
      tim1=0.
      call timex(tim1)
      do 10 i=1,npos
        do 10 j=1,3
          phase(j,i)=zero
   10 continue
      do 20 i=1,2
        bet04(i)=zero
        alf04(i)=zero
        di0(i)=zero
        dip0(i)=zero
        di0au(i)=zero
        di0au(i+2)=zero
   20 continue
      do 30 i=1,3
        bet0(i)=zero
        alf0(i)=zero
        qwc(i)=zero
        clo(i)=zero
        clop(i)=zero
   30 continue
      do 40 i=1,ninv
        invx(i)=0
        invz(i)=0
        xinv(i)=zero
        zinv(i)=zero
        dani(i)=zero
   40 continue
      dani(ninv+1)=zero
      do 50 i=1,npos
        xxr(i)=zero
        xxi(i)=zero
        zzr(i)=zero
        zzi(i)=zero
        fxs(i)=0.0
        fzs(i)=0.0
   50 continue
      do 60 i=1,6
        txyz(i)=zero
        txyz2(i)=zero
        xyzv(i)=zero
        xyzv2(i)=zero
        rbeta(i)=zero
        cloau(i)=zero
        x(1,i)=zero
        x(2,i)=zero
   60 continue
      do 70 i=1,6
        do 70 j=1,6
          t(i,j)=zero
          ta(i,j)=zero
   70 continue
      do 80 i=1,30
        pmax(i)=zero
        pmin(i)=zero
   80 continue
      do 90 i=1,20
        title(i)=' '
        chxtit(i)=' '
        chytit(i)=' '
   90 continue
      do 100 i=1,nlya
        tle(i)=zero
        dle(i)=zero
        slope(i)=zero
        varlea(i)=zero
        wgh(i)=zero
        biav(i)=zero
  100 continue
      do 110 i=1,60
        sumda(i)=zero
  110 continue
      itot=0
      ttot=0
      do i=1,8
        if (version(i:i).ne.' ') then
          if (version(i:i).ne.'.') then
            itot=itot*10+ichar(version(i:i))-ichar('0')
          else
            ttot=ttot*10**2+itot
            itot=0
          endif
        endif
      enddo
      ttot=ttot*10**2+itot
      sumda(52)=dble(ttot)                                               !hr06
! and put CPU time for Massimo
! so even if we go to 550 we now get the stats
      sumda(60)=dble(trtime)
      b0=zero
      nlost=0
      ntwin=1
      nfft=1
      do 120 j=1,npos
        if(nfft.gt.npos/2) goto 130
        nfft=nfft*2
  120 continue
  130 continue
+if stf
      nfile=90
+ei
!----------------------------------------------------------------------
!--READING HEADER
!----------------------------------------------------------------------
      rewind nfile
      ia=0
+if .not.stf
      read(nfile,end=510,iostat=ierro) sixtit,commen,cdate,ctime,       &
     &progrm,ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1), &
     &clop(1),clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0 &
     &(2),dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), &
     &ta(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2), &
     &ta(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4), &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta(5,6), &
     &ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6), dmmac,dnms,dizu0,&
     &dnumlr,sigcor,dpscor
      if(ierro.gt.0) then
        write(lout,10320) nfile
+if cr
        goto 551
+ei
+if .not.cr
        goto 550
+ei
      endif
+if .not.cr
      sumda(1)=numl
+ei
+if cr
      sumda(1)=nnuml
+ei
      idam=1
      if(icode.eq.1.or.icode.eq.2.or.icode.eq.4) idam=1
      if(icode.eq.3.or.icode.eq.5.or.icode.eq.6) idam=2
      if(icode.eq.7) idam=3
      if(ilapa.ne.ifipa) ntwin=2
      if(imad.eq.1.and.progrm.eq.'MAD') then
        imad=0
        rewind nfile
        call join
        read(nfile,end=520,iostat=ierro) sixtit,commen,cdate,ctime,     &
     &progrm,ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo     &
     &(1),clop(1),clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0     &
     &(2),dip0(2),dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta       &
     &(1,5),ta(1,6), ta(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6),   &
     &ta(3,1),ta(3,2),ta(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta       &
     &(4,2),ta(4,3),ta(4,4),ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),   &
     &ta(5,4),ta(5,5),ta(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta       &
     &(6,5),ta(6,6), dmmac,dnms,dizu0,dnumlr,sigcor,dpscor
        ta(1,6)=ta(1,6)*c1e3
        ta(2,6)=ta(2,6)*c1e3
        ta(3,6)=ta(3,6)*c1e3
        ta(4,6)=ta(4,6)*c1e3
        ta(5,6)=ta(5,6)*c1e3
        ta(6,1)=ta(6,1)*c1m3
        ta(6,2)=ta(6,2)*c1m3
        ta(6,3)=ta(6,3)*c1m3
        ta(6,4)=ta(6,4)*c1m3
        ta(6,5)=ta(6,5)*c1m3
        if(ierro.gt.0) then
          write(lout,10320) nfile
+if cr
          goto 551
+ei
+if .not.cr
          goto 550
+ei
        endif
      endif
+ei ! END +if .not.stf
+if stf
      !Read header lines until a match is found
 555  read(nfile,end=510,iostat=ierro) sixtit,commen,cdate,ctime,       &
     &progrm,ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1), &
     &clop(1),clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0 &
     &(2),dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), &
     &ta(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2), &
     &ta(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4), &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta(5,6), &
     &ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6), dmmac,dnms,dizu0,&
     &dnumlr,sigcor,dpscor
      if(ifipa.ne.posi) then !IFIPA=first particle, POSI=requested particle
	goto 555             !Get the next header...
      endif
      ! TODO: Protect against no valid headers found,
      ! i.e. posi > itopa.
      if(ierro.gt.0) then
        write(lout,10320) nfile
+if cr
        goto 551
+ei
+if .not.cr
        goto 550
+ei
      endif
+if .not.cr
      sumda(1)=numl
+ei
+if cr
      sumda(1)=nnuml
+ei
      idam=1
      if(icode.eq.1.or.icode.eq.2.or.icode.eq.4) idam=1
      if(icode.eq.3.or.icode.eq.5.or.icode.eq.6) idam=2
      if(icode.eq.7) idam=3
      if(ilapa.ne.ifipa) then !Is first particle != Last particle?
	ntwin=2               !(ntwin=1 is the default in postpr)
!--   binrecs is indexed as 1,2,3,... (=i.e.(91-nfile) in the non-STF version,
!--   while posi values are called as 1,3,5, so using posi1 for crbinrecs index later
      endif
      posi1 = (posi+1)/2 !For both ntwin=1 and 2
+ei ! END +if stf

+if .not.stf
!--PREVENT FAULTY POST-PROCESSING
      read(nfile,end=530,iostat=ierro) iaa
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
      read(nfile,end=535,iostat=ierro) iab
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
+ei !END +if .not.stf
+if stf
!--PREVENT FAULTY POST-PROCESSING
      !--bypass headers
      rewind nfile
      do i=1,itopa,2
         read(nfile)
      enddo
       !--read first track data for particle at posi
      do !Loop safe, will anyway end EOF is reached.
         read(nfile,end=530,iostat=ierro) iaa, j
         if (j.eq.posi) exit
      enddo
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
      !--bypass records till 2nd run of same particle is reached
      do
         read(nfile,end=535,iostat=ierro) iab, j
         if (j.eq.posi) exit
      enddo
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
+ei !END +if stf
 600  if((((numl+1)/iskip)/(iab-iaa))/iav.gt.nlya) nstop=iav*nlya        !hr06

      rewind nfile

!-- Bypassing header to read tracking data later
+if .not.stf
      read(nfile)
+ei
+if stf
      do i=1,itopa,2
         read(nfile) !One header per particle pair.
      enddo
+ei !END +if stf
      sumda(5)=ta(1,1)**2+ta(1,2)**2                                     !hr06
      sumda(6)=ta(3,3)**2+ta(3,4)**2                                     !hr06
      if(iconv.eq.1) then
        cma1=one
        cma2=one
        clo(1)=zero
        clo(2)=zero
        clo(3)=zero
        clop(1)=zero
        clop(2)=zero
        clop(3)=zero
        di0(1)=zero
        di0(2)=zero
        dip0(1)=zero
        dip0(2)=zero
        do 140 i=1,6
          do 140 j=1,6
            if(i.ne.j) then
              ta(i,j)=zero
            else
              ta(i,j)=one
            endif
  140   continue
      endif
      cloau(1)= clo(1)
      cloau(2)=clop(1)
      cloau(3)= clo(2)
      cloau(4)=clop(2)
      cloau(5)= clo(3)
      cloau(6)=clop(3)
      di0au(1)= di0(1)
      di0au(2)=dip0(1)
      di0au(3)= di0(2)
      di0au(4)=dip0(2)
      sigcor=cma2
      dpscor=cma1
      sumda(53)= clo(1)
      sumda(54)=clop(1)
      sumda(55)= clo(2)
      sumda(56)=clop(2)
      sumda(57)= clo(3)
      sumda(58)=clop(3)
      if(ifipa.eq.ilapa.and.ndafi.gt.itopa) ndafi=itopa
      if(ilapa-ifipa.eq.1.and.ndafi.gt.itopa/2) ndafi=itopa/2
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      ta16=ta(1,6)*c1m3
      ta26=ta(2,6)*c1m3
      ta36=ta(3,6)*c1m3
      ta46=ta(4,6)*c1m3
      ta56=ta(5,6)*c1m3
      ta61=ta(6,1)*c1e3
      ta62=ta(6,2)*c1e3
      ta63=ta(6,3)*c1e3
      ta64=ta(6,4)*c1e3
      ta65=ta(6,5)*c1e3
      bet0(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
      bet0x2 =ta(1,3)**2+ta(1,4)**2                                      !hr06
      bet0x3 =ta(1,5)**2+ta16**2                                         !hr06
      gam0x1 =ta(2,1)**2+ta(2,2)**2                                      !hr06
      gam0x2 =ta(2,3)**2+ta(2,4)**2                                      !hr06
      gam0x3 =ta(2,5)**2+ta26**2                                         !hr06
      alf0(1)=-1d0*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
      alf0x2 =-1d0*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
      alf0x3 =-1d0*(ta(1,5)*ta(2,5)+ta16*ta26)                           !hr06
      bet0(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
      bet0z2 =ta(3,1)**2+ta(3,2)**2                                      !hr06
      bet0z3 =ta(3,5)**2+ta36**2                                         !hr06
      gam0z1 =ta(4,3)**2+ta(4,4)**2                                      !hr06
      gam0z2 =ta(4,1)**2+ta(4,2)**2                                      !hr06
      gam0z3 =ta(4,5)**2+ta46**2                                         !hr06
      alf0(2)=-1d0*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
      alf0z2 =-1d0*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
      alf0z3 =-1d0*(ta(3,5)*ta(4,5)+ta36*ta46)                           !hr06
      bet0(3)=ta(5,5)**2+ta56**2                                         !hr06
      bet0s2 =ta(5,1)**2+ta(5,2)**2                                      !hr06
      bet0s3 =ta(5,3)**2+ta(5,4)**2                                      !hr06
      gam0s1 =ta65**2+ta(6,6)**2                                         !hr06
      gam0s2 =ta61**2+ta62**2                                            !hr06
      gam0s3 =ta63**2+ta64**2                                            !hr06
      alf0(3)=-1d0*(ta(5,5)*ta65+ta56*ta(6,6))                           !hr06
      alf0s2 =-1d0*(ta(5,1)*ta61+ta(5,2)*ta62)                           !hr06
      alf0s3 =-1d0*(ta(5,3)*ta63+ta(5,4)*ta64)                           !hr06
      bet04(1)=bet0(1)
      bet04(2)=bet0(2)
      alf04(1)=alf0(1)
      alf04(2)=alf0(2)
      if(bet0(1).le.pieni.or.bet0(2).le.pieni) then
        write(lout,*) 'WARNING: BETA VALUES ARE ZERO'
        bet0(1)=zero
        bet0(2)=zero
      endif
      do 135 i=1,3
	ii=2*i
        rbeta(ii-1)=sqrt(bet0(i))
        rbeta(ii)=rbeta(ii-1)
        if(abs(rbeta(ii-1)).lt.pieni) rbeta(ii-1)=one
        if(abs(rbeta(ii)).lt.pieni) rbeta(ii)=one
  135 continue
!----------------------------------------------------------------------
!--SETTING UP OF THE PARAMETERS
!----------------------------------------------------------------------
!--HPLOT TITLES
      if(icode.eq.1) hvs(1:11)='Hor        '
      if(icode.eq.2) hvs(1:11)='    Ver    '
      if(icode.eq.3) hvs(1:11)='Hor Ver    '
      if(icode.eq.4) hvs(1:11)='        Syn'
      if(icode.eq.5) hvs(1:11)='Hor     Syn'
      if(icode.eq.6) hvs(1:11)='    Ver Syn'
      if(icode.eq.7) hvs(1:11)='Hor Ver Syn'
      toptit(2)(1:13)='Particle no. '
      write(toptit(2)(14:16),'(I3)') ifipa !WARNING: Does not work for > 999 particles
      toptit(2)(17:30)=', Phase Space '
      write(toptit(2)(31:41),'(A11)') hvs
      toptit(2)(42:50)=', Dp/p = '
      toptit(2)(61:80)=' '
      toptit(3)(1:5)='Ax = '
      toptit(3)(16:22)=', Ay = '
      toptit(3)(33:80)=' '
      toptit(4)(1:5)='Qx = '
      write(toptit(4)(6:15),10010) qwc(1)
      toptit(4)(16:22)=', Qy = '
      write(toptit(4)(23:32),10010) qwc(2)
      toptit(4)(33:39)=', Qs = '
      write(toptit(4)(39:48),10010) qwc(3)
      toptit(4)(49:80)=' '
      title(1)='Normalized Distance of Phase Space D as a Function '    &
     &//'of Turn Number N'
      title(2)='Normalized Horizontal Phase Space Projection'
      title(3)='Normalized Vertical Phase Space Projection'
      title(4)='Physical Phase Space Projection'
      title(5)='Synchrotron Phase Space Projection'
      title(6)='Synchrotron versus Horizontal Phase Space '             &
     &//'Projection'
      title(7)='Synchrotron versus Vertical Phase Space '               &
     &//'Projection'
      title(8)='Energy E as a Function of Turn Number N'
      title(9)='Stroboscoped Normalized Horizontal Phase Space '        &
     &//'Projection'
      title(10)='Stroboscoped Normalized Vertical Phase Space '         &
     &//'Projection'
      title(11)='FFT Analysis of the X Coordinate'
      title(12)='FFT Analysis of the Y Coordinate'
      chxtit(1)='N'
      chytit(1)='D (PI rad)'
      chxtit(2)='X (mm)'
      chytit(2)='Normalized Slope of X (mm)'
      chxtit(3)='Y (mm)'
      chytit(3)='Normalized Slope of Y (MM)'
      chxtit(4)='X (mm)'
      chytit(4)='Y (mm)'
      chxtit(5)='Sigma (mm)'
      chytit(5)='Relative Momentum Deviation'
      chxtit(6)='X (mm)'
      chytit(6)='Relative Momentum Deviation'
      chxtit(7)='Y (mm)'
      chytit(7)='Relative Momentum Deviation'
      chxtit(8)='N'
      chytit(8)='E (MeV)'
      chxtit(9)='X (mm)'
      chytit(9)='Normalized Slope of X (mm)'
      chxtit(10)='Y (mm)'
      chytit(10)='Normalized Slope of Y (mm)'
      chxtit(11)='Horizontal Tune Qx'
      chytit(11)='Normalized FFT Signal'
      chxtit(12)='Vertical Tune Qy'
      chytit(12)='Normalized FFT Signal'
      if(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0) then
        call hplsiz(15.,15.,' ')
        call hplset('VSIZ',.24)
        call hplset('ASIZ',.19)
        call hplset('XLAB',1.5)
        call hplset('YLAB',1.0)
        call hplset('GSIZ',.19)
      endif
      if(iav.lt.1) iav=1
      if(nprint.eq.1) then
        write(lout,10040) sixtit,commen
        write(lout,10050) progrm,ifipa,itopa,hvs,numl,                  &
     &bet0(1),bet0x2,bet0x3,                                            &
     &bet0(2),bet0z2,bet0z3,bet0(3),bet0s2,bet0s3,                      &
     &alf0(1),alf0x2,alf0x3
        write(lout,10060) alf0(2),alf0z2,alf0z3,alf0(3),alf0s2,alf0s3,  &
     &gam0x1,gam0x2,gam0x3,                                             &
     &gam0z1,gam0z2,gam0z3,gam0s1,gam0s2,gam0s3,                        &
     &clo(1),clo(2),clo(3),clop(1),clop(2),clop(3),                     &
     &di0(1),di0(2),dip0(1),dip0(2),qwc(1),qwc(2),qwc(3)
        write(lout,10070) iav,nstart,nstop,dphix,dphiz,iwg, qx0,qz0
        write(lout,10080) ivox,ivoz,ires,dres,ifh,dfft
        write(lout,10090) idis,icow,istw,iffw
        write(lout,10100) iskip,iconv,imad,cma1,cma2,nprint,ndafi
      endif ! END if(nprint.eq.1)
      
!--INITIALISATION
+if crlibm
      tpi=8d0*atan_rn(one)                                               !hr06
+ei
+if .not.crlibm
      tpi=8d0*atan(one)                                                  !hr06
+ei
      prec=c1m1
      i1=0
      i11=1
      tlo=zero
      i2=0
      ifp=0
      iwarx=0
      iwarz=0
      iwar6=0
      iapx=0
      iapz=0
      iap6=0
      ivo6=1
      qs0=zero
      armin0=1d9                                                         !hr06
      armin=armin0
      nivh=ninv/2
      finv=tpi/dble(ninv)                                                !hr06
      dani(1)=zero
      dani(ninv+1)=tpi
      do 150 i=1,ninv-1
  150 dani(i+1)=dble(i)*finv                                             !hr06
      dle1=zero
      bold=zero
      dle1c=zero
      const=zero
      dphx=zero
      dphz=zero
      dph6=zero
      tphx=zero
      tphz=zero
      tph6=zero
      sdpx=zero
      sdpz=zero
      sdp6=zero
      evx=zero
      evz=zero
      evx2=zero
      evz2=zero
      evt=zero
      sevx=zero
      sevz=zero
      sevt=zero
      emax=zero
      emix=zero
      emaz=zero
      emiz=zero
      emag=zero
      emig=zero
      emxa=zero
      emza=zero
      emta=zero
      emxs=zero
      emzs=zero
      emts=zero
      nuex=0
      nuez=0
      nuix=0
      nuiz=0
      xing=zero
      zing=zero
      pinx=zero
      pinz=zero
      pixr=zero
      pizr=zero
!--INVERTING THE MATRIX OF THE GENERATING VECTORS
!     ta = matrix of eigenvectors already normalized, rotated and ordered, units mm,mrad,mm,mrad,mm,1
!     t  = inverse(ta), units mm,mrad,mm,mrad,mm,1
      do 160 i=1,6
        do 160 j=1,6
  160 t(i,j)=ta(j,i)
      if(abs(t(1,1)).le.pieni.and.abs(t(2,2)).le.pieni) then
        t(1,1)=one
        t(2,2)=one
      endif
      if(abs(t(3,3)).le.pieni.and.abs(t(4,4)).le.pieni) then
        t(3,3)=one
        t(4,4)=one
      endif
      if(abs(t(5,5)).le.pieni.and.abs(t(6,6)).le.pieni) then
        t(5,5)=one
        t(6,6)=one
      endif
      tasum=zero
      its6d=0
      do 170 i=1,6
        tasum=(tasum+abs(t(i,5)))+abs(t(i,6))                            !hr06
  170 continue
      do 180 i=1,4
        tasum=(tasum+abs(t(5,i)))+abs(t(6,i))                            !hr06
  180 continue
      tasum=tasum-two
      if(abs(tasum).ge.pieni) its6d=1
      call dinv(6,t,6,idummy,nerror)
      if(nerror.eq.-1) then  !TODO: Using the file number makes no sense in STF case (seen in multiple places)
        write(lout,10290) nfile
        goto 550
      endif
!----------------------------------------------------------------------
!--FIND MINIMUM VALUE OF THE DISTANCE IN PHASESPACE
!----------------------------------------------------------------------
  190 ifipa=0
+if .not.stf
      if(ntwin.eq.1) read(nfile,end=200,iostat=ierro)
     &     ia,ifipa,b,c,d,e,f,g,h,p
      if(ntwin.eq.2) read(nfile,end=200,iostat=ierro)
     &     ia,ifipa,b,c,d,e,f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
+ei
+if stf
!STF case: read tracking data until one reaches right particle.
      if(ntwin.eq.1) read(nfile,end=200,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf
      if(ntwin.eq.2) read(nfile,end=200,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf,
     &ilapa_stf,b_stf,c1_stf,d1_stf,e1_stf,f1_stf,g1_stf,h1_stf,p1_stf
      if(ifipa_stf.ne.posi) then
	goto 190
      endif
!     Found right particle; load data in memory (otherwise it's corrupted when EOF is reached)
      ia=ia_stf
      ifipa=ifipa_stf
      b=b_stf
      c=c_stf
      d=d_stf
      e=e_stf
      f=f_stf
      g=g_stf
      h=h_stf
      p=p_stf
      if(ntwin.eq.2) then
         ilapa=ilapa_stf
         c1=c1_stf
         d1=d1_stf
         e1=e1_stf
         f1=f1_stf
         g1=g1_stf
         h1=h1_stf
         p1=p1_stf
      endif
+ei
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
      if(ifipa.lt.1) goto 190
      if((ia-nstart).lt.0) goto 190                                      !hr06
      if(progrm.eq.'MAD') then
+if .not.stf
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        h=h*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          h1=h1*c1e3
          p1=p1*c1e3
        endif
+ei
+if stf
        write(lout,*) "ERROR in postpr: program=MAD not valid for STF."
        call prror(-1)
+ei
      endif ! END if(program.eq.'MAD')

      if(ntwin.eq.2) then
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 200                   !hr06
      if(b.lt.b0.or.abs(b0).le.pieni) b0=b
      goto 190
  200 if(ia.le.0) goto 530
      
      rewind nfile
      
!----------------------------------------------------------------------
!--GET FIRST DATA POINT AS A REFERENCE
!----------------------------------------------------------------------
! Skip the header(s)
+if .not.stf
      read(nfile,iostat=ierro)
+ei
+if stf
      do i=1,itopa,2
         read(nfile,iostat=ierro)
      enddo
+ei
      if(ierro.gt.0) then
        write(lout,10320) nfile
+if cr
        goto 551
+ei
+if .not.cr
        goto 550
+ei
      endif

+if cr
!--   Initiate count of binary records
+if .not.stf
      crbinrecs(91-nfile)=1
+ei
+if stf
      crbinrecs(posi1)=1
+ei
+ei ! END +if cr

 210  ifipa=0
+if .not.stf
      if(ntwin.eq.1) read(nfile,end=530,iostat=ierro)
     &     ia,ifipa,b,c,d,e,f,g,h,p
      if(ntwin.eq.2) read(nfile,end=530,iostat=ierro)
     &     ia,ifipa,b,c,d,e,f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
+ei
+if stf
!     STF case: read tracking data until one reaches right particle.
      if(ntwin.eq.1) read(nfile,end=530,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf
      if(ntwin.eq.2) read(nfile,end=530,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf,
     &ilapa_stf,b_stf,c1_stf,d1_stf,e1_stf,f1_stf,g1_stf,h1_stf,p1_stf
      if(ifipa_stf.ne.posi) then
         goto 210
      endif
!     Found right particle; load data in memory (otherwise it's corrupted when EOF is reached)
      ia=ia_stf
      ifipa=ifipa_stf
      b=b_stf
      c=c_stf
      d=d_stf
      e=e_stf
      f=f_stf
      g=g_stf
      h=h_stf
      p=p_stf
      if(ntwin.eq.2) then
         ilapa=ilapa_stf
         c1=c1_stf
         d1=d1_stf
         e1=e1_stf
         f1=f1_stf
         g1=g1_stf
         h1=h1_stf
         p1=p1_stf
      endif
+ei
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
+if cr
!     Count one more binary record
+if .not.stf
      crbinrecs(91-nfile)=crbinrecs(91-nfile)+1
+ei
+if stf
      crbinrecs(posi1)=crbinrecs(posi1)+1
+ei
+ei
      if(ifipa.lt.1) goto 210
      if((ia-nstart).lt.0) goto 210
      if(progrm.eq.'MAD') then
+if .not.stf
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        g=g*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          g1=g1*c1e3
          p1=p1*c1e3
        endif
+ei
+if stf
        write(lout,*) "ERROR in postpr: program=MAD not valid for STF."
        call prror(-1)
+ei
      endif
      
      dp1=h
      write(toptit(2)(51:60),10000) dp1-clop(3)
      if(nprint.eq.1.and.ia.eq.0) then
        write(lout,*) 'INITIAL COORDINATES'
        write(lout,*) '       X = ',c
        write(lout,*) '      XP = ',d
        write(lout,*) '       Z = ',e
        write(lout,*) '      ZP = ',f
        write(lout,*) '   SIGMA = ',g
        write(lout,*) '    DP/P = ',h
        write(lout,*) '  ENERGY = ',p
      endif
      
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 540
      ia=ia-nstart
!--LYAPUNOV
      if(ntwin.eq.2) then
!     first particle
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
!     twin particle
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
!--KEEP THE FIRST TURN NUMBER : IA0
      ia0=ia
      xxr(1)=c
      xxi(1)=zero
      zzr(1)=e
      zzi(1)=zero
      c=c-clo(1)
      d=d-clop(1)
      e=e-clo(2)
      f=f-clop(2)
      g=g-clo(3)
      h=h-clop(3)
      c1=c1-clo(1)
      d1=d1-clop(1)
      e1=e1-clo(2)
      f1=f1-clop(2)
      g1=g1-clo(3)
      h1=h1-clop(3)
      if(icode.ge.4) then
        c=c-di0(1)*h
        d=d-dip0(1)*h
        e=e-di0(2)*h
        f=f-dip0(2)*h
        c1=c1-di0(1)*h
        d1=d1-dip0(1)*h
        e1=e1-di0(2)*h
        f1=f1-dip0(2)*h
      endif
!     calculation first particle
!--EMITTANCES
      xp0=bet0(1)*d+alf0(1)*c
      zp0=bet0(2)*f+alf0(2)*e
      emx=(c**2+xp0**2)/bet0(1)                                          !hr06
      emz=(e**2+zp0**2)/bet0(2)                                          !hr06
      if(icode.ge.4.and.its6d.ne.0) then
        c=c+di0(1)*h
        d=d+dip0(1)*h
        e=e+di0(2)*h
        f=f+dip0(2)*h
        c1=c1+di0(1)*h
        d1=d1+dip0(1)*h
        e1=e1+di0(2)*h
        f1=f1+dip0(2)*h
      endif
      emt=emx+emz
      emax=emx
      emix=emx
      emxa=emx
      emaz=emz
      emiz=emz
      emza=emz
      emat=emt
      emit=emt
      emta=emt
      emx0=emx
      emz0=emz
!--COURANT SYNDER
      xyzv(1)=c
      xyzv(2)=d
      xyzv(3)=e
      xyzv(4)=f
      xyzv(5)=g
      xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
        xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                          !hr06
        xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                          !hr06
      endif
      do 220 iq=1,6
        txyz(iq)=zero
        do 220 jq=1,6
          txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  220 continue
!--INITIAL COORDINATES
      if(nprint.eq.1.and.ia.eq.0) then
        write(lout,*) 'DISTANCE = ',b
      endif
!--EMITTANCES WITH LINEAR COUPLING
      evx=txyz(1)**2+txyz(2)**2                                          !hr06
      evz=txyz(3)**2+txyz(4)**2                                          !hr06
!     calculation second particle
      xyzv2(1)=c1
      xyzv2(2)=d1
      xyzv2(3)=e1
      xyzv2(4)=f1
      xyzv2(5)=g1
      xyzv2(6)=h1
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
        xyzv2(2)=xyzv2(2)*((one+xyzv2(6))+clop(3))                       !hr06
        xyzv2(4)=xyzv2(4)*((one+xyzv2(6))+clop(3))                       !hr06
      endif
      do 225 iq=1,6
        txyz2(iq)=zero
        do 225 jq=1,6
          txyz2(iq)=txyz2(iq)+t(jq,iq)*xyzv2(jq)
  225 continue
      evx2=txyz2(1)**2+txyz2(2)**2                                       !hr06
      evz2=txyz2(3)**2+txyz2(4)**2                                       !hr06
      write(toptit(3)(6:15),10010) sqrt(evx*bet0(1))+sqrt(evz*bet0x2)
      write(toptit(3)(23:32),10010) sqrt(evz*bet0(2))+sqrt(evx*bet0z2)
      if(its6d.eq.1) then
        emiii=txyz(5)**2*cma2**2+txyz(6)**2*cma1**2
      else
        emiii=zero
      endif
!--COURANT SYNDER CONT.
      do 230 iq=1,6
        txyz(iq)=txyz(iq)*rbeta(iq)
  230 continue
      c0=txyz(1)
      d0=txyz(2)
      e0=txyz(3)
      f0=txyz(4)
      g0=txyz(5)*cma2
      h0=txyz(6)*cma1
!--MIN MAX VALUES
      pmin(2)=b
      pmax(2)=b
      pmin(3)=c0
      pmax(3)=c0
      pmin(4)=d0
      pmax(4)=d0
      pmin(5)=e0
      pmax(5)=e0
      pmin(6)=f0
      pmax(6)=f0
      pmin(9)=g0
      pmax(9)=g0
      pmin(10)=h0
      pmax(10)=h0
      pmin(16)=p
      pmax(16)=p
!--EMITTANCES WITH LINEAR COUPLING CONT.
      emi=evx
      emii=evz
      angi=zero
      angii=zero
      angiii=zero
      if(abs(txyz(1)).gt.pieni.or.abs(txyz(2)).gt.pieni)                &
+if crlibm
     &angi=atan2_rn(txyz(2),txyz(1))
+ei
+if .not.crlibm
     &angi=atan2(txyz(2),txyz(1))
+ei
      if(abs(txyz(3)).gt.pieni.or.abs(txyz(4)).gt.pieni)                &
+if crlibm
     &angii=atan2_rn(txyz(4),txyz(3))
+ei
+if .not.crlibm
     &angii=atan2(txyz(4),txyz(3))
+ei
      if(abs(txyz(5)).gt.pieni.or.abs(txyz(6)).gt.pieni)                &
+if crlibm
     &angiii=atan2_rn(txyz(6)*cma1,txyz(5)*cma2)
+ei
+if .not.crlibm
     &angiii=atan2(txyz(6)*cma1,txyz(5)*cma2)
+ei
      evt=evx+evz
      evxma=evx
      evzma=evz
      evtma=evt
      evxmi=evx
      evzmi=evz
      evtmi=evt
!--COORDINATE-ANGLE CONVERSION
      call caconv(dpx,d0,c0)
      call caconv(dpz,f0,e0)
      dpxp=tpi+dpx
      dpzp=tpi+dpz
!--INVARIANTS
      call cinvar(dpx,dphix,dpz,dpzp,nuex,emz,zinv,invz)
      call cinvar(dpz,dphiz,dpx,dpxp,nuez,emx,xinv,invx)
!----------------------------------------------------------------------
!--GET DATA POINTS
!----------------------------------------------------------------------
      iskc=0
  240 ifipa=0
+if .not.stf
      if(ntwin.eq.1) read(nfile,end=270,iostat=ierro)
     &ia,ifipa,b,c,d,e,f,g,h,p
      if(ntwin.eq.2) read(nfile,end=270,iostat=ierro)
     &ia,ifipa,b,c,d,e,f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
+ei
+if stf
!     STF case: read tracking data until one reaches right particle.
      if(ntwin.eq.1) read(nfile,end=270,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf
      if(ntwin.eq.2) read(nfile,end=270,iostat=ierro)
     & ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf,
     &ilapa_stf,b_stf,c1_stf,d1_stf,e1_stf,f1_stf,g1_stf,h1_stf,p1_stf
      if(ifipa_stf.ne.posi) then
         goto 240
      endif
!     Found right particle; load data in memory (otherwise it's corrupted when EOF is reached)
      ia=ia_stf
      ifipa=ifipa_stf
      b=b_stf
      c=c_stf
      d=d_stf
      e=e_stf
      f=f_stf
      g=g_stf
      h=h_stf
      p=p_stf
      if(ntwin.eq.2) then
         ilapa=ilapa_stf
         c1=c1_stf
         d1=d1_stf
         e1=e1_stf
         f1=f1_stf
         g1=g1_stf
         h1=h1_stf
         p1=p1_stf
      endif
+ei
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
+if cr
+if .not.stf
!--Increment crbinrecs by 1
      crbinrecs(91-nfile)=crbinrecs(91-nfile)+1
+ei
+if stf
      crbinrecs(posi1)=crbinrecs(posi1)+1
+ei
+ei
      if(ifipa.lt.1) goto 240
      if(progrm.eq.'MAD') then
+if .not.stf
        c=c*c1e3
        d=d*c1e3
        e=e*c1e3
        f=f*c1e3
        g=g*c1e3
        p=p*c1e3
        if(ntwin.eq.2) then
          c1=c1*c1e3
          d1=d1*c1e3
          e1=e1*c1e3
          f1=f1*c1e3
          g1=g1*c1e3
          p1=p1*c1e3
        endif
+ei
+if stf
        write(lout,*) "ERROR in postpr: program=MAD not valid for STF."
        call prror(-1)
+ei
      endif
!--LYAPUNOV
      if(ntwin.eq.2) then
        x(1,1)=c
        x(1,2)=d
        x(1,3)=e
        x(1,4)=f
        x(1,5)=g
        x(1,6)=h
        x(2,1)=c1
        x(2,2)=d1
        x(2,3)=e1
        x(2,4)=f1
        x(2,5)=g1
        x(2,6)=h1
        call distance(x,cloau,di0au,t,b)
      endif
      iskc=iskc+1
      if(mod(iskc,iskip).ne.0) goto 240
      if(nstop.gt.nstart.and.(ia-nstop).gt.0) goto 270
      i1=i1+1
      i11=i1+1
      if(i2.ge.nlya.and.i11.gt.nfft.and.iapx.gt.npos.and.iapz.gt.npos)  &
     &goto 270
      if(i11.le.nfft) then
        xxr(i11)=c
        xxi(i11)=zero
      endif
      if(i11.le.nfft) then
        zzr(i11)=e
        zzi(i11)=zero
      endif
      c=c-clo(1)
      d=d-clop(1)
      e=e-clo(2)
      f=f-clop(2)
      g=g-clo(3)
      h=h-clop(3)
      if(icode.ge.4) then
        c=c-di0(1)*h
        d=d-dip0(1)*h
        e=e-di0(2)*h
        f=f-dip0(2)*h
      endif
!--EMITTANCES
      xp=bet0(1)*d+alf0(1)*c
      zp=bet0(2)*f+alf0(2)*e
      emx=(c**2+xp**2)/bet0(1)                                           !hr06
      emz=(e**2+zp**2)/bet0(2)                                           !hr06
      if(icode.ge.4.and.its6d.ne.0) then
        c=c+di0(1)*h
        d=d+dip0(1)*h
        e=e+di0(2)*h
        f=f+dip0(2)*h
      endif
      emt=emx+emz
      emxa=emxa+emx
      emza=emza+emz
      emta=emta+emt
      emax=max(emx,emax)
      emix=min(emx,emix)
      emaz=max(emz,emaz)
      emiz=min(emz,emiz)
      emat=max(emt,emat)
      emit=min(emt,emit)
!--COURANT SYNDER
      xyzv(1)=c
      xyzv(2)=d
      xyzv(3)=e
      xyzv(4)=f
      xyzv(5)=g
      xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
      if(its6d.eq.1) then
        xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                          !hr06
        xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                          !hr06
      endif
      do 250 iq=1,6
        txyz(iq)=zero
        do 250 jq=1,6
          txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  250 continue
!--EMITTANCES WITH LINEAR COUPLING
      evx1=txyz(1)**2+txyz(2)**2                                         !hr06
      evz1=txyz(3)**2+txyz(4)**2                                         !hr06
!--COURANT SYNDER CONT.
      do 260 iq=1,6
        txyz(iq)=txyz(iq)*rbeta(iq)
  260 continue
      c=txyz(1)
      d=txyz(2)
      e=txyz(3)
      f=txyz(4)
      g=txyz(5)*cma2
      h=txyz(6)*cma1
!--MIN MAX VALUES
      pmin(2)= min(pmin(2) ,b)
      pmax(2)= max(pmax(2) ,b)
      pmin(3)= min(pmin(3) ,c)
      pmax(3)= max(pmax(3) ,c)
      pmin(4)= min(pmin(4) ,d)
      pmax(4)= max(pmax(4) ,d)
      pmin(5)= min(pmin(5) ,e)
      pmax(5)= max(pmax(5) ,e)
      pmin(6)= min(pmin(6) ,f)
      pmax(6)= max(pmax(6) ,f)
      pmin(9)= min(pmin(9) ,g)
      pmax(9)= max(pmax(9) ,g)
      pmin(10)=min(pmin(10),h)
      pmax(10)=max(pmax(10),h)
      pmin(16)=min(pmin(16),p)
      pmax(16)=max(pmax(16),p)
!--ADDING (LOG OF) THE DISTANCES OF PHASE SPACE
      ia=ia-nstart
!--GET DIFFERENCE IN THE NUMBER OF TURNS PER DATA ENTRY : IDNT
      if(i1.eq.1) idnt=ia-ia0
      bold=bold+b
      b=b-b0
      dle1c=zero
+if crlibm
      if(b.gt.zero) dle1c=log_rn(b)
+ei
+if .not.crlibm
      if(b.gt.zero) dle1c=log(b)
+ei
+if crlibm
      if(b.lt.zero) dle1c=-1d0*log_rn(-1d0*b)                            !hr06
+ei
+if .not.crlibm
      if(b.lt.zero) dle1c=-1d0*log(-1d0*b)                               !hr06
+ei
      dle1=dle1+dle1c
!--EMITTANCES WITH LINEAR COUPLING CONT.
      evt1=evx1+evz1
      evxma=max(evx1,evxma)
      evzma=max(evz1,evzma)
      evtma=max(evt1,evtma)
      evxmi=min(evx1,evxmi)
      evzmi=min(evz1,evzmi)
      evtmi=min(evt1,evtmi)
      evx=evx+evx1
      evz=evz+evz1
      evt=evt+evt1
!--ADDING OF THE PHASE ADVANCES
      sx=c*d0-c0*d
      cx=c0*c+d*d0
      if(iapx.le.npos)                                                  &
     &call cphase(1,dphx,sx,cx,qx0,ivox,iwarx,iapx)
      sz=e*f0-e0*f
      cz=e0*e+f*f0
      if(iapz.le.npos)                                                  &
     &call cphase(2,dphz,sz,cz,qz0,ivoz,iwarz,iapz)
      s6=g*h0-g0*h
      c6=h0*h+g*g0
      if(iap6.le.npos)                                                  &
     &call cphase(3,dph6,s6,c6,qs0,ivo6,iwar6,iap6)
!--AVERAGING AFTER IAV TURNS
      if(mod(i1,iav).eq.0) then
        if(i2.ge.nlya) goto 240
        i2=i2+1
        dle(i2)=dle1/dble(iav)                                           !hr06
        if(ia.gt.0) then
+if crlibm
!ERIC bug fixed...........
!eric     tle1=real(log_rn(dble(ia)))
!bugfix   tle1=log_rn(dble(ia))                                          !hr06
          tle1=log_rn(dble(ia))                                          !hr06
+ei
+if .not.crlibm
!eric     tle1=log(real(ia))
!bugfix   tle1=log(dble(ia))                                             !hr06
          tle1=log(dble(ia))                                             !hr06
+ei
          if(i2.gt.1) then
            biav(i2-1)=bold/dble(iav)                                    !hr06
+if debug
!           call warr('biav',biav(i2-1),i2,0,0,0)
+ei
            if(i2.eq.2) biav(1)=biav(1)*half
+if debug
!           call warr('biavhalf',biav(1),1,0,0,1)
+ei
            bold=zero
            tle(i2)=(tle1+tlo)*half
+if debug
!           call warr('tle1)',tle1,0,0,0,0)
!           call warr('tlo',tlo,0,0,0,0)
!           call warr('tle(i2)',tle(i2),i2,0,0,0)
+ei
            if(abs(tle1-tlo).gt.pieni) then
              wgh(i2)=one/(tle1-tlo)
+if debug
!           call warr('wgh(i2)',wgh(i2),i2,0,0,0)
+ei
            else
              write(lout,10310) nfile
              wgh(i2)=zero
            endif
          else
            tle(i2)=tle1*half
            wgh(i2)=one/(tle1)
+if debug
!           call warr('tle(i2)',tle(i2),i2,0,0,1)
!           call warr('wgh(i2)',wgh(i2),i2,0,0,1)
+ei
          endif
        else
          tle(i2)=zero
          wgh(i2)=zero
+if debug
!           call warr('tle(i2)',tle(i2),i2,0,0,2)
!           call warr('wgh(i2)',wgh(i2),i2,0,0,2)
+ei
        endif
        tlo=tle1
        dle1=zero
+if debug
!           call warr('tlo',tlo,0,0,0,0)
!           call warr('dle1',dle1,0,0,0,0)
+ei
      endif
!--COORDINATE-ANGLE CONVERSION
      call caconv(dpx,d,c)
      call caconv(dpz,f,e)
      dpxp=tpi+dpx
      dpzp=tpi+dpz
!--INVARIANTS
      call cinvar(dpx,dphix,dpz,dpzp,nuex,emz,zinv,invz)
      call cinvar(dpz,dphiz,dpx,dpxp,nuez,emx,xinv,invx)
!--RESET OF COORDINATES
      c0=c
      d0=d
      e0=e
      f0=f
      g0=g
      h0=h
      goto 240
  270 if(i2.lt.1) i2=1

+if cr
!--Now check that we have correct number of binrecs
!--We can do this only if we know binrecs (NOT post-processing only)
      if (binrec.ne.0) then
+if .not.stf
        if (binrecs(91-nfile).ne.crbinrecs(91-nfile)) then
          write(lout,*)                                                 &
     &'SIXTRACR POSTPR *** ERROR *** Wrong number of binary records'
          write(lout,*)                                                 &
     &'Unit No ',nfile,' binrec/binrecs/crbinrecs ',                    &
     &binrec,binrecs(91-nfile),crbinrecs(91-nfile)
          write(93,*)                                                   &
     &'SIXTRACR POSTPR *** ERROR *** Wrong number of binary records'
          write(93,*)                                                   &
     &'Unit No ',nfile,' binrec/binrecs/crbinrecs ',                    &
     &binrec,binrecs(91-nfile),crbinrecs(91-nfile)
+ei
+if stf
        if (binrecs(posi1).ne.crbinrecs(posi1)) then
          write(lout,*)                                                 &
     &'SIXTRACR POSTPR *** ERROR *** Wrong number of binary records'
          write(lout,*)                                                 &
     &'Particle No ',posi1,' binrec/binrecs/crbinrecs ',                &
     &binrec,binrecs(posi1),crbinrecs(posi1)
          write(93,*)                                                   &
     &'SIXTRACR POSTPR *** ERROR *** Wrong number of binary records'
          write(93,*)                                                   &
     &'Particle No ',posi,' binrec/binrecs/crbinrecs ',                 &
     &binrec,binrecs(posi1),crbinrecs(posi1)
+ei
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          goto 551
        endif
      endif
+ei ! END +if cr

!----------------------------------------------------------------------
!--ANALYSING DATA
!----------------------------------------------------------------------
!--FIT OF DISTANCE IN PHASESPACE + MEAN PHASEADVANCE
+if debug
!     call warr('lfitw1',tle,0,0,0,1)
!     call warr('lfitw2',dle,0,0,0,2)
!     call warr('lfitw3',wgh,0,0,0,3)
+ei
      do 280 i=2,i2
        if(iwg.eq.1) call lfitwd(tle,dle,wgh,i,1,slope(i-1),const,varlea&
     &(i-1))
        if(iwg.eq.0) call lfitd(tle,dle,i,1,slope(i-1),const,varlea     &
     &(i-1))
+if debug
!     if(iwg.eq.1) then
!     call warr('lfitwtle',tle(i),i,0,0,1)
!     call warr('lfitwdle',dle(i),i,0,0,2)
!     call warr('lfitwwgh',wgh(i),i,0,0,3)
!     call warr('lfitwslo',slope(i-1),i,0,0,4)
!     call warr('lfitwcon',const,i,0,0,5)
!     call warr('lfitwvar',varlea(i-1),i,0,0,6)
!     endif
!     if (iwg.eq.0) then
!     call warr('lfit',tle(i),i,0,0,1)
!     call warr('lfit',dle(i),i,0,0,2)
!     call warr('lfit',slope(i-1),i,0,0,4)
!     call warr('lfit',const,i,0,0,5)
!     call warr('lfit',varlea(i-1),i,0,0,6)
!     endif
+ei
  280 continue
      if(iapx.eq.0) then
        write(lout,*) 'WARNING: IAPX IS ZERO'
        iapx=1
      endif
      if(iapz.eq.0) then
        write(lout,*) 'WARNING: IAPZ IS ZERO'
        iapz=1
      endif
      tphx=dphx/dble(iapx)                                               !hr06
      tphz=dphz/dble(iapz)                                               !hr06
      if(iap6.gt.0) tph6=dph6/dble(iap6)                                 !hr06
!--STANDARD DEVIATION OF PHASEADVANCES
      do 290 i=1,iapx
  290 sdpx=sdpx+(phase(1,i)-tphx)**2                                     !hr06
      do 300 i=1,iapz
  300 sdpz=sdpz+(phase(2,i)-tphz)**2                                     !hr06
      do 310 i=1,iap6
  310 sdp6=sdp6+(phase(3,i)-tph6)**2                                     !hr06
      sdpx=sqrt(sdpx)/dble(iapx)                                         !hr06
      sdpz=sqrt(sdpz)/dble(iapz)                                         !hr06
      if(iap6.gt.0) sdp6=sqrt(sdp6)/dble(iap6)                           !hr06
!--AVERAGED EMITTANCES
      di11=i11
      if(i11.eq.0) then
        write(lout,*) '** ERROR ** - I11 IS ZERO'
        goto 550
      endif
      emxa=emxa/di11
      emza=emza/di11
      emta=emta/di11
      evxm=evx/di11
      evzm=evz/di11
      evtm=evt/di11

!--SMEAR CALCULATION AND 4D-SMEAR
      rewind nfile
      !Skip headers
+if .not.stf
      read(nfile,iostat=ierro)
+ei
+if stf
      do i=1,itopa,2
         read(nfile,iostat=ierro)
      enddo
+ei
      if(ierro.gt.0) then
        write(lout,10320) nfile
        goto 550
      endif
      iskc=-1
      do 340 i=1,i11*iskip+nstart
        ifipa=0
        ! Read 1st particle only
+if .not.stf
 315    read(nfile,end=350,iostat=ierro) ia,ifipa,b,c,d,e,f,g,h,p
+ei
+if stf
!     STF case: read tracking data until one reaches right particle.
 315  read(nfile,end=350,iostat=ierro)
     &ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf
        if(ifipa_stf.ne.posi) then
	  goto 315
	endif
!     Found right particle; load data in memory (otherwise it's corrupted when EOF is reached)
        ia=ia_stf
        ifipa=ifipa_stf
        b=b_stf
        c=c_stf
        d=d_stf
        e=e_stf
        f=f_stf
        g=g_stf
        h=h_stf
        p=p_stf
+ei
        if(ierro.gt.0) then
          write(lout,10320) nfile
          goto 550
        endif
        if(ifipa.lt.1) goto 340
        if(progrm.eq.'MAD') then
+if .not.stf
          c=c*c1e3
          d=d*c1e3
          e=e*c1e3
          f=f*c1e3
          g=g*c1e3
          p=p*c1e3
+ei
+if stf
          write(lout,*)
     &         "ERROR in postpr: program=MAD not valid for STF."
          call prror(-1)
+ei
        endif !END if(program.eq.'MAD')

        iskc=iskc+1
        if(mod(iskc,iskip).ne.0) goto 340
        if((ia-nstart).lt.0) goto 340
        c=c-clo(1)
        d=d-clop(1)
        e=e-clo(2)
        f=f-clop(2)
        g=g-clo(3)
        h=h-clop(3)
        if(icode.ge.4) then
          c=c-di0(1)*h
          d=d-dip0(1)*h
          e=e-di0(2)*h
          f=f-dip0(2)*h
        endif
!--MEAN EMITTANCES
        xp=bet0(1)*d+alf0(1)*c
        zp=bet0(2)*f+alf0(2)*e
        emx=(c**2+xp**2)/bet0(1)                                         !hr06
        emz=(e**2+zp**2)/bet0(2)                                         !hr06
        if(icode.ge.4.and.its6d.ne.0) then
          c=c+di0(1)*h
          d=d+dip0(1)*h
          e=e+di0(2)*h
          f=f+dip0(2)*h
        endif
        emt=emx+emz
        emxs=emxs+(emx-emxa)**2                                          !hr06
        emzs=emzs+(emz-emza)**2                                          !hr06
        emts=emts+(emt-emta)**2                                          !hr06
!--COURANT SYNDER
        xyzv(1)=c
        xyzv(2)=d
        xyzv(3)=e
        xyzv(4)=f
        xyzv(5)=g
        xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
        if(its6d.eq.1) then
          xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                        !hr06
          xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                        !hr06
        endif
! normalisation with t-matrix = inverse matrix of eigenvectors
        do 320 iq=1,6
          txyz(iq)=zero
          do 320 jq=1,6
            txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  320   continue
!--MEAN EMITTANCES WITH LINEAR COUPLING
        evx=txyz(1)**2+txyz(2)**2                                        !hr06
        evz=txyz(3)**2+txyz(4)**2                                        !hr06
!--COURANT SYNDER CONT.
        do 330 iq=1,6
          txyz(iq)=txyz(iq)*rbeta(iq)
  330   continue
        c=txyz(1)
        d=txyz(2)
        e=txyz(3)
        f=txyz(4)
        g=txyz(5)
        h=txyz(6)
!--MEAN EMITTANCES WITH LINEAR COUPLING CONT.
        evt=evx+evz
        sevx=sevx+(evx-evxm)**2                                          !hr06
        sevz=sevz+(evz-evzm)**2                                          !hr06
        sevt=sevt+(evt-evtm)**2                                          !hr06
  340 continue
  350 continue
!--SMEAR IN %
      call sinpro(emxa,di11,emxs,emax,emix)
      call sinpro(emza,di11,emzs,emaz,emiz)
      call sinpro(emta,di11,emts,emat,emit)
      call sinpro(evxm,di11,sevx,evxma,evxmi)
      call sinpro(evzm,di11,sevz,evzma,evzmi)
      call sinpro(evtm,di11,sevt,evtma,evtmi)
!----------------------------------------------------------------------
!--PRINTING
!----------------------------------------------------------------------
      if(nstop.lt.ia.and.(ia.lt.numl.or.ia.lt.nint(dnumlr))) nlost=1
+if vvector
      if(nnumxv(ifipa).eq.0.and.nnumxv(ilapa).eq.0) then
        sumda(22)=dble(ia)                                               !hr06
        sumda(23)=dble(ia)                                               !hr06
      else
        sumda(22)=dble(nnumxv(ifipa))                                    !hr06
        sumda(23)=dble(nnumxv(ilapa))                                    !hr06
      endif
+ei
+if .not.vvector
      sumda(22)=dble(ia)                                                 !hr06
      sumda(23)=dble(ia)                                                 !hr06
+ei
+if cr
! TRY a FIX for nnuml
! should be redumdant now
!     if (nnuml.ne.numl) then
!       if (nint(sumda(22)).eq.numl) sumda(22)=dble(nnuml)
!       if (nint(sumda(23)).eq.numl) sumda(23)=dble(nnuml)
!     endif
+ei
      sumda(2)=dble(nlost)
      sumda(9)=dp1-clop(3)
!--GET DIFFERENCE IN THE NUMBER OF TURNS PER DATA ENTRY : TIDNT
!--NOW CONSIDERING ONLY TURNS LARGER THAN NSTART
      tidnt=dble(((ia-nstart)+idnt)/i11)                                 !hr06
      if(i2.ge.2) then
        if(nprint.eq.1) write(lout,10110)
        ilyap=0
        slopem=zero
        do 360 i=1,i2-1
          iturn=nint(dble((i+1)*iav)*tidnt)                              !hr06
          if(nprint.eq.1) write(lout,10120) iturn,biav(i),slope(i),     &
     &varlea(i)
          if(biav(i).gt.0.1d0) ilyap=1
          slopem=max(slopem,slope(i))
  360   continue
        if(nprint.eq.1) write(lout,10130)
        sumda(10)=biav(i2-1)
        if(ilyap.eq.0) then
         sumda(11)=slope(i2-1)                                           !hr06
        else
         sumda(11)=slopem
        endif
      endif
!--CALCULATION OF AVERAGED PHASEADVANCES
      tph6=abs(tph6)
      if(nprint.eq.1) write(lout,10140)tphx,sdpx,tphz,sdpz,tph6,sdp6,qwc&
     &(1),tphx-qwc(1) ,qwc(2),tphz-qwc(2),qwc(3),tph6-qwc(3),dres,ires
      sumda(3)=qwc(1)
      sumda(4)=qwc(2)
      if(abs(tphx).gt.pieni) then
        sumda(12)=tphx-qwc(1)
      else
        sumda(12)=zero
      endif
      sumda(13)=sdpx
      if(abs(tphz).gt.pieni) then
        sumda(14)=tphz-qwc(2)
      else
        sumda(14)=zero
      endif
      sumda(15)=sdpz
      sumda(25)=tph6
!--DISTANCE OF Q-VALUES (AVERAGED PHASEADVANCE) TO RESONANCES
      do 370 i=1,21
        do 370 j=1,21
          im1=i-1
          jm1=j-1
          if(im1.eq.0.and.jm1.eq.0) goto 370
          if(im1+jm1.gt.ires) goto 370
          ares=dble(im1)*tphx+dble(jm1)*tphz                             !hr06
          dares=anint(ares)
          ares=ares-dares
          if(abs(ares).lt.armin) then
            armin=abs(ares)
            im1s=im1
            jm1s=jm1
          endif
          ared=dble(im1)*tphx-dble(jm1)*tphz                             !hr06
          dared=anint(ared)
          ared=ared-dared
          if(abs(ared).lt.armin) then
            armin=abs(ared)
            im1s=im1
            jm1s=-jm1
          endif
          if(abs(ares).lt.dres.and.nprint.eq.1) write(lout,10170) im1,  &
     &jm1,                                                              &
     &dares,ares
          if(abs(ared).lt.dres.and.jm1.ne.0.and.im1.ne.0.and.nprint.eq. &
     &1) write(lout,10170) im1,-jm1,dared,ared
  370 continue
      if(armin.lt.armin0) then
        sumda(16)=dble(im1s)                                             !hr06
        sumda(17)=dble(jm1s)                                             !hr06
        sumda(18)=sumda(16)+abs(sumda(17))
      endif
      if(iwarx.eq.1.and.nprint.eq.1) write(lout,10150)
      if(iwarz.eq.1.and.nprint.eq.1) write(lout,10160)
!--Q-VALUES BY AN FFT-ROUTINE
  380 ifp=ifp+1
      ife=2**ifp
      if(ife.le.i11.and.ife.le.nfft) then
        goto 380
      else
        ifp=ifp-1
        ife=ife/2
      endif
      if(ife.eq.0) then
        write(lout,*) '** ERROR ** - IFE IS ZERO'
        goto 550
      endif
      dife=ife
      if(ifp.gt.1) then
        if(nprint.eq.1) write(lout,10180) ife,dfft*100
        call fft(xxr,xxi,ifp,ife)
        call fft(zzr,zzi,ifp,ife)
        xxmax=zero
        zzmax=zero
        xxmin=one
        zzmin=one
        if(ifh.eq.0) then
          if1=1
          if2=ife
          ife2=ife
          pmin(21)=qx0
          pmax(21)=qx0+one
          pmin(23)=qz0
          pmax(23)=qz0+one
        else if(ifh.eq.1) then
          if1=1
          if2=ife/2
          ife2=ife/2
          pmin(21)=qx0
          pmax(21)=qx0+half
          pmin(23)=qz0
          pmax(23)=qz0+half
        else
          if1=ife/2+1
          if2=ife
          ife2=ife/2
          pmin(21)=qx0+half
          pmax(21)=qx0+one
          pmin(23)=qz0+half
          pmax(23)=qz0+one
        endif
        do 390 i=if1,if2
          xxmax=max(xxmax,sqrt(xxr(i)**2+xxi(i)**2))
          zzmax=max(zzmax,sqrt(zzr(i)**2+zzi(i)**2))
          xxmin=min(xxmin,sqrt(xxr(i)**2+xxi(i)**2))
          zzmin=min(zzmin,sqrt(zzr(i)**2+zzi(i)**2))
  390   continue
        if(abs(xxmax).gt.pieni) xxmin=xxmin/xxmax
        if(abs(zzmax).gt.pieni) zzmin=zzmin/zzmax
        if(xxmax.le.pieni) then
          write(lout,*) 'WARNING: XXMAX IS SET TO : ',pieni
          xxmax=pieni
        endif
        if(zzmax.le.pieni) then
          write(lout,*) 'WARNING: ZZMAX IS SET TO : ',pieni
          zzmax=pieni
        endif
        do 400 i=if1,if2
          xxaux=sqrt(xxr(i)**2+xxi(i)**2)
          zzaux=sqrt(zzr(i)**2+zzi(i)**2)
          if(abs(xxaux-xxmax).le.pieni) ffx=(dble(i-1)/dife)+qx0         !hr06
          if(abs(zzaux-zzmax).le.pieni) ffz=(dble(i-1)/dife)+qz0         !hr06
          xxaux=xxaux/xxmax
          zzaux=zzaux/zzmax
          if(xxaux.gt.dfft.and.nprint.eq.1) write(lout,10190)           &!hr06
     &dble(i-1)/dife+qx0,xxaux*100d0                                     !hr06
      if(zzaux.gt.dfft.and.nprint.eq.1) write(lout,10200) dble(i-1)/dife&!hr06
     &+qz0,zzaux*100d0                                                   !hr06
  400   continue
        if(nprint.eq.1) write(lout,10210) ffx,ffz,qwc(1),ffx-qwc(1),    &
     &qwc(2),                                                           &
     &ffz-qwc(2),dres,ires
!--DISTANCE OF Q-VALUES (FFT) TO RESONANCES
        do 410 i=1,21
          do 410 j=1,21
            im1=i-1
            jm1=j-1
            if(im1.eq.0.and.jm1.eq.0) goto 410
            if(im1+jm1.gt.ires) goto 410
            ares=dble(im1)*ffx+dble(jm1)*ffz                             !hr06
            dares=anint(ares)
            ares=ares-dares
            ared=dble(im1)*ffx-dble(jm1)*ffz                             !hr06
            dared=anint(ared)
            ared=ared-dared
            if(abs(ares).lt.dres.and.nprint.eq.1) write(lout,10170) im1,&
     &jm1,dares,ares
            if(abs(ared).lt.dres.and.jm1.ne.0.and.im1.ne.0.and.nprint.eq&
     &.1) write(lout,10170) im1,-jm1,dared,ared
  410   continue
      endif
!--PRINT 4-D INVARIANTS WITH LINEAR COUPLING
      if(nprint.eq.1) write(lout,10270) emi,emii,emiii,angi,angii,      &
     &angiii,                                                           &
     &evxm,sevx,evxma,evxmi,evzm,sevz,evzma,evzmi,evtm,sevt,evtma,evtmi
!--PRINT EMITTANCES AND SMEAR
      ampx0=sqrt(bet0(1)*emx0)
      ampz0=sqrt(bet0(2)*emz0)
      if(nprint.eq.1) write(lout,10220) emx0,ampx0,emz0,ampz0,emxa,emxs,&
     &emax,emix,emza, emzs,emaz,emiz,emta,emts,emat,emit
      sumda(46)=emi
      sumda(47)=emii
      sumda(48)=bet0x2
      sumda(49)=bet0z2
      sumda(7)=sqrt(bet0(1)*emi)+sqrt(bet0x2*emii)
      sumda(8)=sqrt(bet0(2)*emii)+sqrt(bet0z2*emi)
      sumda(26)=sqrt(bet0(1)*evx2)+sqrt(bet0x2*evz2)
      sumda(27)=sqrt(bet0(2)*evz2)+sqrt(bet0z2*evx2)
      sumda(19)=sevx
      sumda(20)=sevz
      sumda(21)=sevt
!     sumda(59)=dmmac
!     sumda(60)=dnms
      sumda(59)=dnms
! This place 60 now used for CPU time seconds
! But it is set earlier in case particles are lost very early
      sumda(24)=dizu0
      emax=(emax/100d0)*emxa+emxa                                        !hr06
      emix=(emix/100d0)*emxa+emxa                                        !hr06
      emaz=(emaz/100d0)*emza+emza                                        !hr06
      emiz=(emiz/100d0)*emza+emza                                        !hr06
      sumda(28)=sqrt(bet0(1)*abs(emix))
      sumda(29)=sqrt(bet0(1)*emxa)
      sumda(30)=sqrt(bet0(1)*emax)
      sumda(31)=sqrt(bet0(2)*abs(emiz))
      sumda(32)=sqrt(bet0(2)*emza)
      sumda(33)=sqrt(bet0(2)*emaz)
      evxma=(evxma/100d0)*evxm+evxm                                      !hr06
      evxmi=(evxmi/100d0)*evxm+evxm                                      !hr06
      evzma=(evzma/100d0)*evzm+evzm                                      !hr06
      evzmi=(evzmi/100d0)*evzm+evzm                                      !hr06
      sumda(34)=sqrt(bet0(1)*abs(evxmi))
      sumda(35)=sqrt(bet0(1)*evxm)
      sumda(36)=sqrt(bet0(1)*evxma)
      sumda(37)=sqrt(bet0(2)*abs(evzmi))
      sumda(38)=sqrt(bet0(2)*evzm)
      sumda(39)=sqrt(bet0(2)*evzma)
      evtma=(evtma/100d0)*evtm+evtm                                      !hr06
      evtmi=(evtmi/100d0)*evtm+evtm                                      !hr06
      if(abs(evxm+evzm).gt.pieni) then
        ratemx=evxm/(evxm+evzm)
        ratemz=evzm/(evxm+evzm)
      else
        ratemx=zero
        ratemz=zero
      endif
      sumda(40)=sqrt((bet0(1)*abs(evtmi))*ratemx)                        !hr06
      sumda(41)=sqrt((bet0(1)*evtm)*ratemx)                              !hr06
      sumda(42)=sqrt((bet0(1)*evtma)*ratemx)                             !hr06
      sumda(43)=sqrt((bet0(2)*abs(evtmi))*ratemz)                        !hr06
      sumda(44)=sqrt((bet0(2)*evtm)*ratemz)                              !hr06
      sumda(45)=sqrt((bet0(2)*evtma)*ratemz)                             !hr06
!--PUT IN THE CHROMATICITY
      sumda(50)=chromc(1)*c1e3
      sumda(51)=chromc(2)*c1e3
!--WRITE DATA FOR THE SUMMARY OF THE POSTPROCESSING ON FILE # 10
+if debug
!     do i=1,60
!       call warr('sumda(i)',sumda(i),i,0,0,0)
!     enddo
+ei
! We should really write fort.10 in BINARY!
      write(110,iostat=ierro) (sumda(i),i=1,60)
+if debug
+if .not.nagfor
      write(210,'(60Z21)') (sumda(i),i=1,60)
+ei
+ei
+if .not.crlibm
      write(ch,*,iostat=ierro) (sumda(i),i=1,60)
      do ich=8192,1,-1
        if(ch(ich:ich).ne.' ') goto 700
      enddo
 700  write(10,'(a)',iostat=ierro) ch(:ich)
+ei
+if crlibm
! Now use my new dtostr for portability
      l1=1
      do i=1,60
! We return the length of the string (always 24)
        errno=dtostr(sumda(i),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
      enddo        
      write(10,'(a)',iostat=ierro) ch(1:l1-1)
+ei
      if(ierro.ne.0) then
        write(lout,*)
        write(lout,*)'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110' 
        write(lout,*) 'ERROR CODE : ',ierro
        write(lout,*)
      endif
!--CALCULATION THE INVARIANCES OF THE 4D TRANSVERSAL MOTION
      do 420 i=1,ninv
        if(invx(i).gt.0) then
          nuix=nuix+1
          xing=xing+xinv(i)/dble(invx(i))                                !hr06
        endif
        if(invz(i).gt.0) then
          nuiz=nuiz+1
          zing=zing+zinv(i)/dble(invz(i))                                !hr06
        endif
  420 continue
      pinx=dble(nuix)                                                    !hr06
      pinz=dble(nuiz)                                                    !hr06
      if(nuix.ne.0) then
        pixr=dble(nuez)/dble(nuix)
        xing=xing/dble(nuix)                                             !hr06
      endif
      if(nuiz.ne.0) then
        pizr=dble(nuex)/dble(nuiz)
        zing=zing/dble(nuiz)                                             !hr06
      endif
      pinx=(pinx/dble(ninv))*100d0                                       !hr06
      pinz=(pinz/dble(ninv))*100d0                                       !hr06
      if(nprint.eq.1) write(lout,10230)
      if(nuez.lt.ninv.and.nprint.eq.1) write(lout,10240) nuez,ninv
      if(nuex.lt.ninv.and.nprint.eq.1) write(lout,10250) nuex,ninv
      if(nprint.eq.1) write(lout,10260) nuez,nuix,nuex,nuiz, ninv,pinx, &
     &pixr,pinz,pizr,xing,zing
!----------------------------------------------------------------------
!--PLOTTING
!----------------------------------------------------------------------
      pmin(1)=zero
      pmax(1)=dble(ia)                                                   !hr06
      pmin(7)=pmin(3)
      pmax(7)=pmax(3)
      pmin(8)=pmin(5)
      pmax(8)=pmax(5)
      pmin(11)=pmin(3)
      pmax(11)=pmax(3)
      pmin(12)=pmin(10)
      pmax(12)=pmax(10)
      pmin(13)=pmin(5)
      pmax(13)=pmax(5)
      pmin(14)=pmin(10)
      pmax(14)=pmax(10)
      pmax(15)=dble(ia)                                                  !hr06
      pmin(17)=pmin(3)
      pmax(17)=pmax(3)
      pmin(18)=pmin(4)
      pmax(18)=pmax(4)
      pmin(19)=pmin(5)
      pmax(19)=pmax(5)
      pmin(20)=pmin(6)
      pmax(20)=pmax(6)
      pmin(22)=zero
      pmin(24)=zero
      pmax(22)=one
      pmax(24)=one
      do 500 i=1,12
        i2=2*i
        i1=i2-1
        if(pmin(i1).gt.pmax(i1)) pmin(i1)=pmax(i1)
        if(pmin(i2).gt.pmax(i2)) pmin(i2)=pmax(i2)
        if((abs(pmin(i1)-pmax(i1)).le.pieni2) .or.(abs(pmin(i2)-pmax(i2)&
     &).le.pieni2)) then
          goto 500
        endif
        do 430 i3=i1,i2
          pcha=(pmax(i3)-pmin(i3))*prec
          pmin(i3)=pmin(i3)-pcha
          pmax(i3)=pmax(i3)+pcha
  430   continue
        if(iffw.eq.2) then
          pmin(22)=xxmin/(1d0+abs(prec))
          pmin(24)=zzmin/(1d0+abs(prec))
        endif
        if((i.eq.1.and.idis.eq.1).or. (i.gt.1.and.i.le.8.and.icow.eq.1) &
     &.or. ((i.eq.9.or.i.eq.10).and.istw.eq.1).and. (pmin(i1).ne.pmax   &
     &(i1).and.pmin(i2).ne.pmax(i2))) then
!--HBOOK FRAME
          call htitle(title(i))
          call hbook2(i,' ',2,real(pmin(i1)),real(pmax(i1)), 2,real     &
     &(pmin(i2)),real(pmax(i2)),0.)
          call hplot(i,' ',' ',0)
          call hplax(chxtit(i),chytit(i))
          call hplsof(4.,14.75,toptit(1),.15,0.,99.,-1)
          call hplsof(4.,14.50,toptit(2),.15,0.,99.,-1)
          call hplsof(4.,14.25,toptit(3),.15,0.,99.,-1)
          call hplsof(4.,14.00,toptit(4),.15,0.,99.,-1)
          call iselnt(10)

          rewind nfile
          !Skip headers
+if stf
          do j=1,itopa,2
+ei
          read(nfile,iostat=ierro)
+if stf
          enddo
+ei
          if(ierro.gt.0) then
            write(lout,10320) nfile
+if cr
            goto 551
+ei
+if .not.cr
            goto 550
+ei
          endif
          iskc=-1
          do 460 j=1,i11*iskip+nstart
 435        ifipa=0
+if .not.stf
            if(ntwin.eq.1) read(nfile,end=470,iostat=ierro)
     &           ia,ifipa,b,c,d,e,f,g,h,p
            if(ntwin.eq.2) read(nfile,end=470,iostat=ierro)
     &           ia,ifipa,b,c,d,e,f,g,h,p, ilapa,b,c1,d1,e1,f1,g1,h1,p1
+ei
+if stf
!     STF case: read tracking data until one reaches right particle.
            if(ntwin.eq.1) read(nfile,end=470,iostat=ierro)
     &ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf
            if(ntwin.eq.2) read(nfile,end=470,iostat=ierro)
     &ia_stf,ifipa_stf,b_stf,c_stf,d_stf,e_stf,f_stf,g_stf,h_stf,p_stf,
     &ilapa_stf,b_stf,c1_stf,d1_stf,e1_stf,f1_stf,g1_stf,h1_stf,p1_stf
	    if(ifipa_stf.ne.posi) then
	      goto 435
	    endif
!     Found right particle; load data in memory (otherwise it's corrupted when EOF is reached)
      ia=ia_stf
      ifipa=ifipa_stf
      b=b_stf
      c=c_stf
      d=d_stf
      e=e_stf
      f=f_stf
      g=g_stf
      h=h_stf
      p=p_stf
      if(ntwin.eq.2) then
         ilapa=ilapa_stf
         c1=c1_stf
         d1=d1_stf
         e1=e1_stf
         f1=f1_stf
         g1=g1_stf
         h1=h1_stf
         p1=p1_stf
      endif
+ei
            if(ierro.gt.0) then
              write(lout,10320) nfile
              goto 550
            endif
            if(ifipa.lt.1) goto 460
            iskc=iskc+1
            if(mod(iskc,iskip).ne.0) goto 460
            if((ia-nstart).lt.0) goto 460
            if(progrm.eq.'MAD') then !NON-STF only
+if .not.stf
              c=c*c1e3
              d=d*c1e3
              e=e*c1e3
              f=f*c1e3
              g=g*c1e3
              p=p*c1e3
              if(ntwin.eq.2) then
                c1=c1*c1e3
                d1=d1*c1e3
                e1=e1*c1e3
                f1=f1*c1e3
                g1=g1*c1e3
                p1=p1*c1e3
              endif
+ei
+if stf
        write(lout,*) "ERROR in postpr: program=MAD not valid for STF."
        call prror(-1)
+ei

            endif
!--LYAPUNOV
            if(ntwin.eq.2) then
              x(1,1)=c
              x(1,2)=d
              x(1,3)=e
              x(1,4)=f
              x(1,5)=g
              x(1,6)=h
              x(2,1)=c1
              x(2,2)=d1
              x(2,3)=e1
              x(2,4)=f1
              x(2,5)=g1
              x(2,6)=h1
              call distance(x,cloau,di0au,t,b)
            endif
            if(icode.ge.4.and.its6d.eq.0) then
              c=c-di0(1)*h
              d=d-dip0(1)*h
              e=e-di0(2)*h
              f=f-dip0(2)*h
            endif
            c=c-clo(1)
            d=d-clop(1)
            e=e-clo(2)
            f=f-clop(2)
            g=g-clo(3)
            h=h-clop(3)
            xyzv(1)=c
            xyzv(2)=d
            xyzv(3)=e
            xyzv(4)=f
            xyzv(5)=g
            xyzv(6)=h
!--CONVERT TO CANONICAL VARIABLES
            if(its6d.eq.1) then
              xyzv(2)=xyzv(2)*((one+xyzv(6))+clop(3))                    !hr06
              xyzv(4)=xyzv(4)*((one+xyzv(6))+clop(3))                    !hr06
            endif
            do 440 iq=1,6
              txyz(iq)=zero
              do 440 jq=1,6
                txyz(iq)=txyz(iq)+t(jq,iq)*xyzv(jq)
  440       continue
            do 450 iq=1,6
              txyz(iq)=txyz(iq)*rbeta(iq)
  450       continue
            c=txyz(1)
            d=txyz(2)
            e=txyz(3)
            f=txyz(4)
            g=txyz(5)*cma2
            h=txyz(6)*cma1
            if(idis.eq.1.and.i.eq.1) call ipm(1,real(ia),real(b))
            if(icow.eq.1.and.i.le.8) then
              if(i.eq.2) call ipm(1,real(c),real(d))
              if(i.eq.3) call ipm(1,real(e),real(f))
              if(i.eq.4) call ipm(1,real(c),real(e))
              if(i.eq.5) call ipm(1,real(g),real(h))
              if(i.eq.6) call ipm(1,real(c),real(h))
              if(i.eq.7) call ipm(1,real(e),real(h))
              if(i.eq.8) call ipm(1,real(ia),real(p))
            endif
            if(istw.eq.1.and.(i.eq.9.or.i.eq.10)) then
              if(i.eq.9) then
                call caconv(dpz,f,e)
                if(abs(dpz).lt.dphiz) call ipm(1,real(c),real(d))
              endif
              if(i.eq.10) then
                call caconv(dpx,d,c)
                if(abs(dpx).lt.dphix) call ipm(1,real(e),real(f))
              endif
            endif
  460     continue
  470     continue
        else if((iffw.eq.1.or.iffw.eq.2).and.(i.eq.11.or.i.eq.12)) then
!--HBOOK FRAME
          call htitle(title(i))
          call hbook2(i,' ',2,real(pmin(i1)),real(pmax(i1)), 2,real     &
     &(pmin(i2)),real(pmax(i2)),0.)
          if(iffw.eq.2) call hplopt('LOGY',1)
          call hplot(i,' ',' ',0)
          call hplax(chxtit(i),chytit(i))
          call hplsof(4.,14.75,toptit(1),.15,0.,99.,-1)
          call hplsof(4.,14.50,toptit(2),.15,0.,99.,-1)
          call hplsof(4.,14.25,toptit(3),.15,0.,99.,-1)
          call hplsof(4.,14.00,toptit(4),.15,0.,99.,-1)
          call iselnt(10)
          if(i.eq.11) then
            do 480 k=if1,if2
              k1=k-if1+1
              xxaux=sqrt(xxr(k)**2+xxi(k)**2)
              xxaux=xxaux/xxmax
              fxs(k1)=real(dble(k-1)/dife+qx0)                           !hr06
              if(iffw.eq.2) then
                if(abs(xxaux).lt.pieni) then
                  write(lout,*) '* * * ERROR * * *'
                  write(lout,*)                                         &
     &'Apparently horizontal FFT data are corrupted'
                  xxaux=one
                endif
+if crlibm
                fzs(k1)=real(log10_rn(xxaux))
+ei
+if .not.crlibm
                fzs(k1)=real(log10(xxaux))
+ei
              else
                fzs(k1)=real(xxaux)
              endif
              if(nprint.eq.1) then
                write(14,10030,iostat=ierro) fxs(k1),fzs(k1)
                if(ierro.ne.0) then
                  write(lout,*)
                  write(lout,*)                                         &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : ',14
                  write(lout,*) 'ERROR CODE : ',ierro
                  write(lout,*)
                endif
              endif
  480       continue
            call ipl(ife2,fxs,fzs)
          else if(i.eq.12) then
            do 490 k=if1,if2
              k1=k-if1+1
              zzaux=sqrt(zzr(k)**2+zzi(k)**2)
              zzaux=zzaux/zzmax
              fxs(k1)=real(dble(k-1)/dife+qz0)                           !hr06
              if(iffw.eq.2) then
                if(abs(zzaux).lt.pieni) then
                  write(lout,*) '* * * ERROR * * *'
                  write(lout,*)                                         &
     &'Apparently vertical FFT data are corrupted'
                  zzaux=one
                endif
+if crlibm
                fzs(k1)=real(log10_rn(zzaux))
+ei
+if .not.crlibm
                fzs(k1)=real(log10(zzaux))                               !hr06
+ei
              else
                fzs(k1)=real(zzaux)
              endif
              if(nprint.eq.1) then
                write(15,10030,iostat=ierro) fxs(k1),fzs(k1)
                if(ierro.ne.0) then
                  write(lout,*)
                  write(lout,*)                                         &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : ',14
                  write(lout,*) 'ERROR CODE : ',ierro
                  write(lout,*)
                endif
              endif
  490       continue
            call ipl(ife2,fxs,fzs)
          endif
        endif
        if(iffw.eq.2) call hplopt('LINY',1)
  500 continue
      if(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)              &
     &call hdelet(0)
      goto 560
  510 continue
      write(lout,10300) nfile,'HEADER CORRUPTED'
      goto 550
  520 continue
      write(lout,10300) nfile,'HEADER OF MADFILE CORRUPTED'
      goto 550
  530 continue
      write(lout,10300) nfile,'NO DATA'
      goto 550
  535 continue
      write(lout,10300) nfile,'ONLY START VALUES'
      goto 550
  540 continue
      write(lout,10300) nfile,'WRONG RANGE OF DATA FOR PROCESSING'
      goto 550
+if cr
  551 write(93,*)'SIXTRACR POSTPR  *** ERROR *** (see fort.6)'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
! Now we let abend handle the fort.10......
! It will write 0d0 plus CPU time and turn number
! But we empty it as before (if we crash in abend???)
      rewind 10
      endfile (10,iostat=ierro)
      close(10)
      call abend('SIXTRACR POSTPR  *** ERROR ***                    ')
+ei

 550  continue
!--WRITE DATA FOR THE SUMMARY OF THE POSTPROCESSING ON FILE # 10
!-- Will almost all be zeros but we now have napxto and ttime
+if debug
!     do i=1,60
!       call warr('sumda(i)',sumda(i),i,0,0,0)
!     enddo
+ei
! We should really write fort.10 in BINARY!
      write(110,iostat=ierro) (sumda(i),i=1,60)
+if debug
+if .not.nagfor
      write(210,'(60Z21)') (sumda(i),i=1,60)
+ei
+ei
+if .not.crlibm
      write(ch,*,iostat=ierro) (sumda(i),i=1,60)
      do ich=8192,1,-1
        if(ch(ich:ich).ne.' ') goto 707
      enddo
 707  write(10,'(a)',iostat=ierro) ch(:ich)
+ei
+if crlibm
! Now use my new dtostr for portability
      l1=1
      do i=1,60
! We return the length of the string (always 24)
        errno=dtostr(sumda(i),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
      enddo        
      write(10,'(a)',iostat=ierro) ch(1:l1-1)
+ei
      if(ierro.ne.0) then
        write(lout,*)
        write(lout,*)'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110' 
        write(lout,*) 'ERROR CODE : ',ierro
        write(lout,*)
      endif
!--REWIND USED FILES
  560 rewind nfile
      rewind 14
      rewind 15
!--TIME COUNT
      tim2=0.
      call timex(tim2)
      if(nprint.eq.1) write(lout,10280) tim2-tim1
!----------------------------------------------------------------------
      return
      
10000 format(d10.4)
10010 format(f10.6)
10020 format(a80)
10030 format(2f10.6)
10040 format( //131('-')//10x,'OOOOOOOOOOOOOOOOOOOOOO' /10x,            &
     &'OO                  OO' /10x,'OO  POSTPROCESSING  OO' /10x,      &
     &'OO                  OO' /10x,'OOOOOOOOOOOOOOOOOOOOOO'// /10x,    &
     &'TITLE AND COMMENT :'//a80//a80// )
10050 format(10x,'THE FOLLOWING PARAMETERS ARE USED:'//                 &
     &10x,'PROGRAM NAME',t102,a8/                                       &
     &10x,'PARTICLE NUMBER',t102,i7/                                    &
     &10x,'TOTAL NUMBER OF PARTICLES',t102,i7/                          &
     &10x,'PHASE SPACE',t102,a11/                                       &
     &10x,'MAXIMUM NUMBER OF TURNS',t102,i8/                            &
     &10x,'HORIZONTAL BETA',t102,f16.10/                                &
     &10x,'HORIZONTAL BETA-II',t102,f16.10/                             &
     &10x,'HORIZONTAL BETA-III',t102,f16.10/                            &
     &10x,'VERTICAL BETA',t102,f16.10/                                  &
     &10x,'VERTICAL BETA-II',t102,f16.10/                               &
     &10x,'VERTICAL BETA-III',t102,f16.10/                              &
     &10x,'LONGITUDINAL BETA',t98,f20.10/                               &
     &10x,'LONGITUDINAL BETA-II',t102,f16.10/                           &
     &10x,'LONGITUDINAL BETA-III',t102,f16.10/                          &
     &10x,'HORIZONTAL ALFA',t102,f16.10/                                &
     &10x,'HORIZONTAL ALFA-II',t102,f16.10/                             &
     &10x,'HORIZONTAL ALFA-III',t102,f16.10)
10060 format(                                                           &
     &10x,'VERTICAL ALFA',t102,f16.10/                                  &
     &10x,'VERTICAL ALFA-II',t102,f16.10/                               &
     &10x,'VERTICAL ALFA-III',t102,f16.10/                              &
     &10x,'LONGITUDINAL ALFA',t102,f16.10/                              &
     &10x,'LONGITUDINAL ALFA-II',t102,f16.10/                           &
     &10x,'LONGITUDINAL ALFA-III',t102,f16.10/                          &
     &10x,'HORIZONTAL GAMMA',t102,f16.10/                               &
     &10x,'HORIZONTAL GAMMA-II',t102,f16.10/                            &
     &10x,'HORIZONTAL GAMMA-III',t102,f16.10/                           &
     &10x,'VERTICAL GAMMA',t102,f16.10/                                 &
     &10x,'VERTICAL GAMMA-II',t102,f16.10/                              &
     &10x,'VERTICAL GAMMA-III',t102,f16.10/                             &
     &10x,'LONGITUDINAL GAMMA',t102,f16.10/                             &
     &10x,'LONGITUDINAL GAMMA-II',t102,f16.10/                          &
     &10x,'LONGITUDINAL GAMMA-III',t102,f16.10/                         &
     &10x,'HORIZONTAL CLOSED ORBIT',t102,d16.10/                        &
     &10x,'VERTICAL CLOSED ORBIT',t102,d16.10/                          &
     &10x,'LONGITUDINAL CLOSED ORBIT',t102,d16.10/                      &
     &10x,'SLOPE OF HORIZONTAL CLOSED ORBIT',t102,d16.10/               &
     &10x,'SLOPE OF VERTICAL CLOSED ORBIT',t102,d16.10/                 &
     &10x,'SLOPE OF LONGITUDINAL CLOSED ORBIT',t102,d16.10/             &
     &10x,'HORIZONTAL DISPERSION',t102,f16.10/                          &
     &10x,'VERTICAL DISPERSION',t102,f16.10/                            &
     &10x,'SLOPE OF HORIZONTAL DISPERSION',t102,f16.10/                 &
     &10x,'SLOPE OF VERTICAL DISPERSION',t102,f16.10/                   &
     &10x,'LINEAR HORIZONTAL TUNE',t102,f16.10/                         &
     &10x,'LINEAR VERTICAL TUNE',t102,f16.10/                           &
     &10x,'LINEAR LONGITUDINAL TUNE',t102,f16.10)
10070 format( 10x,'DATA IS AVERAGED IN SAMPLES OF IAV TURNS',t96,       &
     &'IAV =    ',i7 /10x,'START TURN NUMBER FOR THE ANALYSIS ',t93,    &
     &'NSTART =  ',i9 /10x,'THE ANALYSIS STOPS AFTER TURN NUMBER ',t94, &
     &'NSTOP =  ',i9, /10x,                                             &
     &'HORIZONTAL ANGLE-INTERVAL FOR STROBOSCOPING THE VERTICAL',       &
     &' PHASESPACE PROJECTION',t94,'DPHIX = ',d16.10 /10x,              &
     &'VERTICAL ANGLE-INTERVAL FOR STROBOSCOPING THE HORIZONTAL',       &
     &' PHASESPACE PROJECTION',t94,'DPHIY = ',d16.10 /10x,              &
     &'SWITCH FOR THE WEIGHTING OF THE LINEAR FIT FOR THE ' ,           &
     &'DISTANCE IN PHASESPACE ',t96,'IWG = ',i4 /10x,                   &
     &'INTEGER PART FOR THE HORIZONTAL TUNE ',t96,'QX0 = ' ,f16.10 /10x,&
     &'INTEGER PART FOR THE VERTICAL TUNE ',t96,'QY0 = ' ,f16.10 )
10080 format( 10x,'SWITCH FOR THE QX-VALUE CLOSE TO AN HALF-INTEGER' ,  &
     &' ( INT => 1 ; HALF-INT => 0 )',t95,'IVOX = ',i4 /10x,            &
     &'SWITCH FOR THE QY-VALUE CLOSE TO AN HALF-INTEGER' ,              &
     &' ( INT => 1 ; HALF-INT => 0 )',t95,'IVOY = ',i4 /10x,            &
     &'Q-VALUES ARE CHECKED FOR RESONANCES UP TO ORDER',t95, 'IRES = ', &
     &i4 /10x,'A RESONANCE IS CONSIDERED TO BE STRONG WHEN THE Q-VALUES'&
     &, ' ARE CLOSER TO IT THAN',t95,'DRES = ',d16.10 /10x,             &
     &'SWITCH FOR FFT-RANGE ( IFH=0 => 0-1 ; IFH=1 => 0-.5 ' ,          &
     &'; IFH=2 => .5-1 )',t96,'IFH = ',i4 /10x,                         &
     &'Q-PEAKS OF THE FFT ARE CONSIDERED IF THEY ARE LARGER THAN' ,t95, &
     &'DFFT = ',d16.10 )
10090 format( 10x,                                                      &
     &'SWITCH FOR PRINTING THE DISTANCE IN PHASE SPACE' ,t95,'IDIS = ', &
     &i4 /10x,'SWITCH FOR PRINTING THE COORDINATES',t95,'ICOW = ',i4 /10&
     &x,'SWITCH FOR PRINTING THE STROBOSCOPED PHASESPACES',t95,         &
     &'ISTW = ',i4 /10x,'SWITCH FOR PRINTING THE FFT-SIGNALS',t95,      &
     &'IFFW = ',i4 ,i4 )
10100 format( 10x,'EVERY ISKIP VALUE IS USED FOR THE ANALYSIS' ,t94,    &
     &'ISKIP = ',i4 /10x,                                               &
     &'SWITCH OF COURANT SYNDER TRANSFORMATION (ICONV = 1 => OFF)' ,t93,&
     &' ICONV = ',i4 /10x,                                              &
     &'SWITCH FOR READING MAD DATA ( IMAD = 1 => MAD-DATA ' ,           &
     &'WITH LYAPUNOV ANALYSIS )',t95,'IMAD = ',i4 /10x,                 &
     &'SCALING OF MOMENTUM', ' WITH LYAPUNOV ANALYSIS',t95,'CMA1 = ',f16&
     &.10 /10x,'SCALING OF PATH-LENGTH', ' WITH LYAPUNOV ANALYSIS',t95, &
     &'CMA2 = ',f16.10 /10x,                                            &
     &'SWITCH FOR PRINTING OF THE POSTPROCESSING OUTPUT' ,              &
     &' NPRINT = ( 0 => OFF ; 1 => ON) ',t93,'NPRINT = ',i4 /10x,       &
     &'NUMBER OF BINARY FILES TO BE PROCESSED', ' ( 90 - [90-NDAFI+1] )'&
     &,t94,'NDAFI = ',i4 //)
10110 format(/10x,'ANALYSING THE INCREASE OF THE DISTANCE IN PHASE-' ,  &
     &'SPACE'/10x,53('-')/ //12x,'TURNS',10x,'DISTANCE',13x,            &
     &'SLOPE          RESIDUAL' /10x,63('-'))
10120 format(10x,i7,6x,d16.10,2(2x,f15.10))
10130 format(10x,63('-')//)
10140 format(//10x,'AVERAGED PHASE-ADVANCE' /10x,22('-')/ /10x,         &
     &'X-PHASE :  ',f14.10,'   +/_ ',f14.10 /10x,'Y-PHASE :  ',f14.10,  &
     &'   +/_ ',f14.10/ /10x,'S-PHASE :  ',f14.10,'   +/_ ',f14.10/ /10 &
     &x,'START-QX : ',f14.10,'   CHANGE IN X : ',d16.10 /10x,           &
     &'START-QY : ',f14.10,'   CHANGE IN Y : ',d16.10 /10x,'START-QS : '&
     &,f14.10,'   CHANGE IN S : ',d16.10// /10x,                        &
     &'THE AVERAGED PHASE-ADVANCES ARE CLOSER THEN ',d10.4,' TO ' ,     &
     &'THE FOLLOWING RESONANCES UP TO ',i3,' ORDER'/10x,98('-')/ /10x,  &
     &'NX * QX   +   NY * QY   -      P      =      DELTA'/10x, 52('-'))
10150 format(/10x,'WARNING ! X-PHASE MIGHT NOT BE PRECISE'/)
10160 format(/10x,'WARNING ! Y-PHASE MIGHT NOT BE PRECISE'//)
10170 format(12x,i2,11x,i3,7x,f8.1,9x,d10.4)
10180 format(//10x,'Q-VALUES FROM FFT-ROUTINE' /10x,25('-')/ /10x,      &
     &'THE ANALYSIS WAS DONE WITH ',i7,' ENTRIES.'/ /10x,               &
     &'THE FOLLOWING Q-PEAKS ARE LARGER THEN ',f8.4,' PERCENT.'/ /10x,  &
     &'PLANE          Q-VALUE            SIZE [%]'/10x,43('-'))
10190 format(12x,'X',7x,f14.10,5x,f14.10)
10200 format(12x,'Y',7x,f14.10,5x,f14.10)
10210 format(//10x,'MAXIMUM PEAK'/ /10x,'HORIZONTAL PLANE :  ',f14.10   &
     &/10x,'VERTICAL PLANE   :  ',f14.10/ /10x,'START-QX : ',f14.10,    &
     &'   CHANGE IN X : ',d16.10 /10x,'START-QY : ',f14.10,             &
     &'   CHANGE IN Y : ',d16.10// /10x,                                &
     &'THE MAXIMUM Q-PEAKS ARE CLOSER THEN ',d10.4,' TO ' ,             &
     &'THE FOLLOWING RESONANCES UP TO ',i3,' ORDER'/10x,96('-')/ /10x,  &
     &'NX * QX   +   NY * QY   -      P      =      DELTA'/10x, 52('-'))
10220 format(////10x,'CALCULATION OF THE AVERAGED EMITTANCES' /10x,38(  &
     &'-')// 24x,'START-EMITTANCE           START-AMPLITUDE'// 10x,     &
     &'HORIZONTAL   ',f16.10,9x,f16.10/ 10x,'VERTICAL     ',f16.10,9x,  &
     &f16.10// 14x,'PLANE',10x,'EMITTANCE',16x,'SMEAR',12x,'MAXIMUM',11 &
     &x, 'MINIMUM'/28x,'[PI*MM*MRAD]',15x,'[%]',15x,'[%]',15x, '[%]'/10 &
     &x,86('-')/ 10x,'HORIZONTAL',6x,f16.10,3(6x,f12.6)/ 10x,'VERTICAL',&
     &8x,f16.10,3(6x,f12.6)/ 10x,'SUM',13x,f16.10,3(6x,f12.6)/10x,86('-'&
     &)//)
10230 format(//10x,'INVARIANTS OF THE 4-DIMENSIONAL PHASE-SPACE' /10x,43&
     &('-')//)
10240 format(/10x,'WARNING ! CALCULATION OF THE HORIZONTAL INVARIANT' , &
     &' MIGHT NOT BE PRECISE'/10x,'ONLY ',i5,' ENTRIES COMPARED TO ' ,  &
     &i5,' ANGLE-INTERVALS !'/10x,'INCREASE THE VERTICAL ANGLE-INT' ,   &
     &'ERVAL <DPHIY>'/)
10250 format(/10x,'WARNING ! CALCULATION OF THE VERTICAL INVARIANT' ,   &
     &' MIGHT NOT BE PRECISE'/10x,'ONLY ',i5,' ENTRIES COMPARED TO ' ,  &
     &i5,' ANGLE-INTERVALS !'/10x,'INCREASE THE HORIZONTAL ANGLE-INT' , &
     &'ERVAL <DPHIX>'/)
10260 format(/10x,'THERE ARE ',i5,' ENTRIES FOR THE CALCULATION OF' ,   &
     &' THE HORIZONTAL INVARIANT GROUPED IN ',i5,' ANGLE-INTERVALS' /10 &
     &x,'--------- ',i5,' ENTRIES ----------------------' ,             &
     &'---- VERTICAL   -------------------- ',i5,' ANGLE-INTERVALS' //10&
     &x,'IF THE MOTION IS CLOSE TO FIXPOINTS THE NUMBER OF THOSE' ,     &
     &' ANGLE-INTERVALS WILL BE ONLY A SMALL FRACTION'/10x,             &
     &'OF THE TOTAL NUMBER OF ',i5,' INTERVALS.'/ /25x,                 &
     &'PERCENTAGE OF OCCUPIED INTERVALS     NUMBER OF ENTRIES ' ,       &
     &'PER OCCUPIED INTERVAL' /10x,'HORIZONTAL',16x,f10.6,30x,f12.6 /10 &
     &x,'VERTICAL  ',16x,f10.6,30x,f12.6/ //10x,                        &
     &'THE CALCULATED INVARIANTS ARE IN UNITS OF [PI*MM*MRAD]'/ /10x,   &
     &'HORIZONTAL',10x,f16.10 /10x,'VERTICAL  ',10x,f16.10//)
10270 format(////10x,'LINEARLY DECOUPLED INVARIANTS' /10x,35('-')/ 10x, &
     &'INITIAL EMITTANCE MODE I   :',f16.10/ 10x,                       &
     &'INITIAL EMITTANCE MODE II  :',f16.10/ 10x,                       &
     &'INITIAL EMITTANCE MODE III :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE I   :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE II  :',f16.10/ 10x,                       &
     &'INITIAL ANGLE     MODE III :',f16.10/ /10x,35('-')// 14x,'PLANE',&
     &10x,'EMITTANCE',14x,'4D-SMEAR',11x,'MAXIMUM',11x, 'MINIMUM'/28x,  &
     &'[PI*MM*MRAD]',15x,'[%]',15x,'[%]',15x, '[%]'/10x,86('-')/ 10x,   &
     &'HORIZONTAL',6x,f16.10,3(6x,f12.6)/ 10x,'VERTICAL',8x,f16.10,3    &
     &(6x,f12.6)/ 10x,'SUM',13x,f16.10,3(6x,f12.6)/10x,86('-')//)
10280 format(/10x,'Postprocessing took ',f12.3,' second(s)',            &
     &' of Execution Time'//131('-')//)
10290 format(//10x,'** ERROR ** ----- TRANSFORMATION MATRIX SINGULAR ' ,&
     &'(FILE : ',i2,') -----'//)
10300 format(//10x,'** ERROR ** ----- FILE :',i2,' WITH TRACKING ' ,    &
     &'DATA EMPTY OR CORRUPTED-----'/10x,'PROBLEM : ',a80//)
10310 format(//10x,'** ERROR ** ----- WEIGHTING OF DISTANCE IN PHASE' , &
     &' SPACE (FILE : ',i2,') NOT POSSIBLE-----'//)
10320 format(//10x,'** ERROR ** ----- INPUT DATA CORRUPTED' ,' (FILE : '&
     &,i2,') -----'//)
      end

      subroutine fma_error(ierro,str,subroutine_name)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: error messages for fma analysis                             *
!-----------------------------------------------------------------------*
      implicit none
+ca crcoall
      integer,       intent(in)  :: ierro
      character (*), intent (in) :: subroutine_name
      character (*), intent (in) :: str             !error message
      if(ierro.ne.0) then
        write(lout,*) 'ERROR in ',subroutine_name,': ',
     & str,', iostat=',ierro
        call prror(-1)
      endif
      end subroutine
      
      subroutine fma_norm_phase_space_matrix(fma_tas_inv,fma_tas)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: invert the matrix of eigenvecors tas                        *
!           (code copied from postpr only that ta is here fma_tas)      *
!           x(normalized)=fma_tas^-1 x=fma_tas_inv x                    *
!           note: inversion method copied from subroutine postpr        *
!-----------------------------------------------------------------------*
      implicit none
+ca parnum   !numbers (zero,one,two etc.)
+ca commonta
      integer :: i,j            !iterators
      double precision, dimension(6,6), intent(inout) :: fma_tas !tas = normalisation matrix
      double precision, dimension(6,6), intent(out) :: fma_tas_inv !inverse of tas
      integer ierro                   !error messages
!     dummy variables
      double precision, dimension(6,6) :: tdummy !dummy variable for transposing the matrix
      integer, dimension(6) :: idummy !for matrix inversion
!     units: [mm,mrad,mm,mrad,mm,1]
!     invert matrix
!     - set values close to 1 equal to 1
      do 160 i=1,6
        do 160 j=1,6
  160 fma_tas_inv(i,j)=fma_tas(j,i)
      if(abs(fma_tas_inv(1,1)).le.pieni.and.abs(fma_tas_inv(2,2)).le.   &
     &pieni) then
        fma_tas_inv(1,1)=one
        fma_tas_inv(2,2)=one
      endif
      if(abs(fma_tas_inv(3,3)).le.pieni.and.abs(fma_tas_inv(4,4)).le.   &
     &pieni) then
        fma_tas_inv(3,3)=one
        fma_tas_inv(4,4)=one
      endif
      if(abs(fma_tas_inv(5,5)).le.pieni.and.abs(fma_tas_inv(6,6)).le.   &
     &pieni) then
        fma_tas_inv(5,5)=one
        fma_tas_inv(6,6)=one
      endif
!     - invert: dinv returns the transposed matrix
      call dinv(6,fma_tas_inv,6,idummy,ierro)
      call fma_error(ierro,'matrix inversion failed!',                  &
     &'fma_norm_phase_space_matrix')
!     - transpose fma_tas_inv
      tdummy=fma_tas_inv
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j)=tdummy(j,i)
        enddo
      enddo
      end subroutine fma_norm_phase_space_matrix
      
      subroutine fma_postpr
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: return files used for fma analysis                          *
!           -> calculate particle amplitudes and tunes using the        *
!              normalized coordinates for input files                   *
!              fma_fname(fma_numfiles)                                  *
!  output format: q1,q2,q3,eps1_min,eps2_min,eps3_min,eps1_max,         *
!                 eps2_max,eps3_max,eps1_avg, eps2_avg,eps3_avg,        *
!                 eps1_0,eps2_0,eps3_0,phi1_0,phi2_0,phi3_0             *
!-----------------------------------------------------------------------*
      implicit none
+ca stringzerotrim
+ca comgetfields
+ca parpro
+ca dbdump
+ca dbdumpcr
+ca fma
+ca commonta !normalisation matrix tasm -> remove later
+ca common   !napx = number of particles 
+ca parnum   !numbers (zero,one,two etc.)
+ca commonc
+if crlibm
+ca crlibco
+ei
+ca crcoall
      integer :: i,j,k,l,m,n                    ! for do loops
      integer :: num_modes                      ! 3 for 6D tracking, 2 for 4D tracking.
      integer :: fma_npart,fma_tfirst,fma_tlast ! local variables to check input files
      logical :: lopen                          ! flag to check if file is already open
      logical :: lexist                         ! flag to check if file fma_fname exists
      logical :: lread                          ! flag for file reading
      character(len=getfields_l_max_string) :: ch,ch1
      character filefields_fields
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
      integer filefields_nfields
      integer filefields_lfields( getfields_n_max_fields )
      logical filefields_lerr
      double precision round_near

      integer, dimension(:,:),allocatable :: turn ! npart = max. number of particles
      double precision, dimension(6,6) :: fma_tas ! dump_tas in units [mm,mrad,mm,mrad,mm,1]
      double precision, dimension(6,6) :: fma_tas_inv ! normalisation matrix = inverse of fma_tas (same units) -> x_normalized=fma_tas_inv*x
      double precision, dimension(:,:,:),allocatable ::
     &xyzv,nxyzv ! phase space (x,x',y,y',z,dE/E) [mm,mrad,mm,mrad,mm,1.e-3], normalized phase space variables [sqrt(m) 1.e-3]
      double precision, dimension(:,:,:),allocatable ::
     &epsnxyzv ! normalized emittances
      double precision :: tunelask,tuneffti,tunefft,tuneapa,tunefit,    &
     &tunenewt,tuneabt2,tuneabt,tunenewt1
!     dummy variables for readin + normalisation + loops
      integer :: id,kt,counter
      double precision :: pos
      double precision, dimension(6) :: xyzvdummy,nxyzvdummy !phase space variables x,x',y,y',sig,delta
      double precision, dimension(3) :: q123 !tune q1,q2,q3
      double precision, dimension(3) :: eps123_0,eps123_min,eps123_max, &
     &eps123_avg !initial,minimum,maximum,average emittance
      double precision, dimension(3) :: phi123_0  !initial phase

+if fio
! Do not support FIO, it is not supported by any compilers.
      write (lout,*) "FIO not supported in FMA!"
      call prror(-1)
+ei

!     initialize variables
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j) = 0
        enddo
      enddo

      allocate(turn(napx,fma_nturn_max),
     &         xyzv(napx,fma_nturn_max,6),
     &        nxyzv(napx,fma_nturn_max,6),
     &     epsnxyzv(napx,fma_nturn_max,3),
     &     STAT=i)
      if (i.ne.0) then
         write(lout,*) "Error in fma_postpr: Cannot ALLOCATE"//
     &        " arrays 'turn,xyzv,nxyzv,epsnxyzv' of size "//
     &        " proportional to napx*fma_nturn_max."
         call prror(-1)
      endif
      
!     fma_six = data file for storing the results of the FMA analysis
      inquire(unit=2001001,opened=lopen)
      if(lopen) then
         write(lout,*) "ERROR in FMA: Tried to open unit 2001001",
     &        "for file 'fma_sixtrack', but it was already taken?"
         call prror(-1)
      endif
      open(2001001,file='fma_sixtrack',status='replace',iostat=ierro,   &
     &action='write',form='formatted')
      call fma_error(ierro,'cannot open file fma_sixtrack for writing!',&
     &'fma_postpr')

      if (idp.eq.0 .or. ition.eq.0) then
         num_modes = 2          !4D tracking
         write(lout,*)
     &        "'ERROR: FMA analysis currently only implemented "//
     &        "for thin 6D tracking and 6D optics!'"
         call prror(-1)
         ! Note: It is possible that it works for 4D and thick tracking also,
         ! as long as you have calculated 6D optics; however it has not been checked.
         ! If you want to try, comment out the "call prror",
         ! and if you were not eaten by a grue then please let us know...
      else
         num_modes = 3          !6D tracking
      endif
      
!     write the header
      write(2001001,'(a)') '# eps1*,eps2*,eps3* all in 1.e-6*m, '//
     &'phi* [rad]'
      write(2001001,'(a)') '# inputfile method id q1 q2 q3 eps1_min '//
     &'eps2_min eps3_min eps1_max eps2_max eps3_max eps1_avg eps2_avg'//
     &' eps3_avg eps1_0 eps2_0 eps3_0 phi1_0 phi2_0 phi3_0'

!      start FMA analysis: loop over all files, calculate tunes, write output file
      do i=1,fma_numfiles
        lexist=.false.
        do j=1,nele !START: loop over dump files
          if(trim(stringzerotrim(fma_fname(i))).eq.
     &trim(stringzerotrim(dump_fname(j)))) then 
            lexist=.true.     !set lexist = true if the file fma_fname(j) exists
            write(lout,*) 'start FMA analysis using file ',             &
     &trim(stringzerotrim(fma_fname(i))),': number of particles=',napx, &
     &', first turn=',dumpfirst(j),', last turn=',dumplast(j)

!    check the format, if dumpfmt != 2 abort
            if(dumpfmt(j).ne.2) then
              call fma_error(-1,'input file has wrong format! Choose for&
     &mat=2 in DUMP block.','fma_postpr')
            endif
!    open dump file for reading, resume to original position before exiting the subroutine
            inquire(unit=dumpunit(j),opened=lopen)
            if(lopen) then
              close(dumpunit(j))
            else ! file has to be open if nothing went wrong
              call fma_error(-1,'file '//trim(stringzero                &
     &trim(dump_fname(j)))//' has to be open','fma_postpr')
            endif
            open(dumpunit(j),file=dump_fname(j),status='old',
     &iostat=ierro,action='read')
            call fma_error(ierro,'cannot open file '//trim(stringzero   &
     &trim(dump_fname(j))),'fma_postpr')

!    now we can start reading in the file
!    - skip header
            counter=1
            do
              read(dumpunit(j),'(A)',iostat=ierro) ch
              call fma_error(ierro,'while reading file ' //             &
     &dump_fname(j),'fma_postpr')
              ch1=adjustl(trim(ch))
              if(ch1(1:1).ne.'#')  exit
              if(counter>500) then
                call fma_error(ierro,'Something is wrong with your '//  &
     &'inputfile '//trim(stringzerotrim(dump_fname(j)))//'! We found '//&
     &'more than 500 header lines','fma_postpr')
              endif
              counter=counter+1
            enddo
            backspace(dumpunit(j),iostat=ierro)
!   read in particle amplitudes
            if (dumplast(j) .eq. -1) then
               fma_nturn(i) = numl-dumpfirst(j)+1        !Tricky if the particle is lost...
            else
               fma_nturn(i) = dumplast(j)-dumpfirst(j)+1 !number of turns used for FFT
            endif
            if(fma_nturn(i).gt.fma_nturn_max) then
              write(lout,*) 'ERROR in fma_postpr: only ',               &
     &fma_nturn_max,' turns allowed for fma and ',fma_nturn(i),' used!'
              write(lout,*) '->reset fma_nturn_max > ', fma_nturn_max
              call prror(-1)
            endif

!    - now we have done all checks, we only need the normalisation matrix
!         units: dump_tas [mm,mrad,mm,mrad,1.e-3]
!                fma_tas  [mm,mrad,mm,mrad,1]
!      note: closed orbit dump_clo already converted in linopt part
            do m=1,6
              do n=1,6
                fma_tas(m,n)=dump_tas(j,m,n)
              enddo
            enddo
            do m=1,5
              fma_tas(m,6)=fma_tas(m,6)*1.e3
              fma_tas(6,m)=fma_tas(6,m)*1.e-3
            enddo
            call fma_norm_phase_space_matrix(fma_tas_inv, 
     &                                       fma_tas(1:6,1:6) )

!     dump normalized particle amplitudes for debugging (200101+i*10)
            inquire(unit=200101+i*10,opened=lopen)
            if(lopen) then
               write(lout,*) "ERROR in FMA: Tried to open unit",
     &            200101+i*10, "for file 'NORM_"//dump_fname(j)//
     &            "', but it was already taken?!?"
               call prror(-1)
            endif
           
            open(200101+i*10,file='NORM_'//dump_fname(j),
     &           status='replace',iostat=ierro,action='write') ! nx,nx',ny,ny'
!    - write closed orbit in header of file with normalized phase space coordinates (200101+i*10)
!      units: x,xp,y,yp,sig,dp/p = [mm,mrad,mm,mrad,1] (note: units are already changed in linopt part)
            write(200101+i*10,'(a,1x,6(1X,1PE16.9))') '# closorb',
     &           dump_clo(j,1),dump_clo(j,2),dump_clo(j,3),
     &           dump_clo(j,4),dump_clo(j,5),dump_clo(j,6)
!    - write tas-matrix and its inverse in header of file with normalized phase space coordinates (200101+i*10)
!      units: x,px,y,py,sig,dp/p [mm,mrad,mm,mrad,1]
            write(200101+i*10,'(a)') '# tamatrix'
            do m=1,6
              do n=1,6
                write(200101+i*10,'(a,1x,1PE16.9)') '# ',
     &                fma_tas(m,n)
            enddo
            enddo
            write(200101+i*10,'(a)') '# inv(tamatrix)'
            do m=1,6
              do n=1,6
                write(200101+i*10,'(a,1x,1PE16.9)') '# ',
     &                fma_tas_inv(m,n)
              enddo
            enddo
            write(200101+i*10,'(a)') '# id turn pos[m] nx[1.e-3'//
     &' sqrt(m)] npx[1.e-3 sqrt(m)] ny[1.e-3 sqrt(m)] npy[1.e-3'//
     &' sqrt(m)] nsig[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] kt'
!    - read in particle amplitudes a(part,turn), x,xp,y,yp,sigma,dE/E [mm,mrad,mm,mrad,mm,1]
            do k=1,fma_nturn(i) !loop over turns
              do l=1,napx !loop over particles
+if .not.crlibm
                read(dumpunit(j),*,iostat=ierro) id,turn(l,k),pos,      &
     &xyzvdummy(1),xyzvdummy(2),xyzvdummy(3),xyzvdummy(4),xyzvdummy(5),
     &xyzvdummy(6),kt
                if(ierro.gt.0) call fma_error(ierro,'while reading '    &
     &//' particles from file ' // dump_fname(j),'fma_postpr') !read error
+ei
+if crlibm
                read(dumpunit(j),'(a)', iostat=ierro) ch
                if(ierro.gt.0) call fma_error(ierro,'while reading '    &
     &//' particles from file' // dump_fname(j) // '. Check that tracked
     & turns is larger than number of turns used for FFT!','fma_postpr')!read error
                call getfields_split(ch,filefields_fields,
     &filefields_lfields,filefields_nfields, filefields_lerr)
                if( filefields_lerr ) call fma_error(-1,'while reading '&
     &//' particles from file ' // dump_fname(j) // 'in function getfiel&
     &ds_split','fma_postpr') !error in getfields_split while reading
!    check if number of fields is correct
                if( filefields_nfields  .ne. 10 ) then 
                  write(lout,*) 'ERROR in fma_postpr while reading parti&
     &cles from file ',trim(stringzerotrim(dump_fname(j))),'. 10 fields &
     &expected from getfields_split, got ',filefields_nfields, ' and ch &
     &=',ch
                  call prror(-1)
                endif
                read(filefields_fields(1)(1:filefields_lfields(1)),*) id
                read(filefields_fields(2)(1:filefields_lfields(2)),*) 
     &turn(l,k)
                pos = round_near(ierro, filefields_lfields(3)+1,
     &filefields_fields(3) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,3,pos)
                xyzvdummy(1) = round_near(ierro, filefields_lfields(4)+1
     &,filefields_fields(4) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,4,xyzvdummy(1))
                xyzvdummy(2) = round_near(ierro, filefields_lfields(5)+1
     &,filefields_fields(5) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,5,xyzvdummy(2))
                xyzvdummy(3) = round_near(ierro, filefields_lfields(6)+1
     &,filefields_fields(6) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,6,xyzvdummy(3))
                xyzvdummy(4) = round_near(ierro, filefields_lfields(7)+1
     &,filefields_fields(7) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,7,xyzvdummy(4))
                xyzvdummy(5) = round_near(ierro, filefields_lfields(8)+1
     &,filefields_fields(8) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,8,xyzvdummy(5))
                xyzvdummy(6) = round_near(ierro, filefields_lfields(9)+1
     &,filefields_fields(9) )
                if (ierro.ne.0)
     &            call rounderr(ierro,filefields_fields,9,xyzvdummy(6))
                read(filefields_fields(10)(1:filefields_lfields(10)),*) 
     &kt
+ei !end crlibm
!    - remove closed orbit -> check units used in dump_clo (is x' or px used?)
                do m=1,6
                  xyzvdummy(m)=xyzvdummy(m)-dump_clo(j,m)
                enddo
!    - for FMA in physical coordinates, convert units to [mm,mrad,mm,mrad,mm,1.e-3]
                do m=1,6
                  if(m.eq.6) then
                    xyzv(l,k,m)=xyzvdummy(m)*c1e3
                  else 
                    xyzv(l,k,m)=xyzvdummy(m)
                  endif
                enddo
!    - convert to canonical variables
                xyzvdummy(2)=xyzvdummy(2)*((one+xyzvdummy(6))+
     &dump_clo(j,6)) 
                xyzvdummy(4)=xyzvdummy(4)*((one+xyzvdummy(6))+
     &dump_clo(j,6))
!    - normalize nxyz=fma_tas_inv*xyz
                do m=1,6
                  nxyzvdummy(m)=zero
                  do n=1,6
                    nxyzvdummy(m)=nxyzvdummy(m)+fma_tas_inv(m,n)*       &
     &xyzvdummy(n)
                  enddo
!      a) convert nxyzv(6) to 1.e-3 sqrt(m)
!         unit: nx,npx,ny,npy,nsig,ndelta all in [1.e-3 sqrt(m)]
                  if(m.eq.6) then
                    nxyzv(l,k,m)=nxyzvdummy(m)*c1e3
                  else 
                    nxyzv(l,k,m)=nxyzvdummy(m)
                  endif
!      b) calculate emittance of mode 1,2,3
                  if(mod(m,2).eq.0) then
                    epsnxyzv(l,k,m/2)=nxyzvdummy((m-1))**2+             &
     &nxyzvdummy(m)**2
                  endif
                enddo
                write(200101+i*10,1986) id,turn(l,k),pos,               &
     &nxyzv(l,k,1),nxyzv(l,k,2),nxyzv(l,k,3),nxyzv(l,k,4),nxyzv(l,k,5), &
     &nxyzv(l,k,6),kt! write normalized particle amplitudes
              enddo
            enddo
!     calculate tunes of particles using the methods in plato_seq.f
!     for fma_norm_flag = 0 use physical coordinates x,x',y,y',sig,dp/p
!         fma_norm_flag > 0 use normalized coordinates
            do l=1,napx ! loop over particles
              do m=1,num_modes ! loop over modes (hor.,vert.,long.)
                 select case( trim(stringzerotrim(fma_method(i))) )
                 case('TUNELASK')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunelask(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunelask(nxyzv(l,1:fma_nturn(i),2*(m-1)+1), 
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEFFTI')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneffti(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneffti(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEFFT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunefft(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunefft(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEAPA')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneapa(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneapa(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEFIT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunefit(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunefit(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                  
                 case('TUNENEWT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunenewt(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunenewt(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEABT2')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneabt2(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneabt2(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNEABT')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tuneabt(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tuneabt(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case('TUNENEWT1')
                 if(fma_norm_flag(i) .eq. 0) then
                    q123(m)=tunenewt1(xyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   xyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 else
                    q123(m)=tunenewt1(nxyzv(l,1:fma_nturn(i),2*(m-1)+1),
     &                   nxyzv(l,1:fma_nturn(i),2*m),fma_nturn(i))
                 endif
                 
                 case default
                    call fma_error(-1,'FMA method '//
     &                   trim(stringzerotrim(fma_method(i)))//
     &                   ' not known! Note method name must be in'//
     &                   ' capital letters!','fma_postpr')
                 end select
                 
                if(m.eq.3) q123(m)=one-q123(m)                          ! mode 3 rotates anticlockwise, mode 1 and 2 rotate clockwise -> synchroton tune is negative, but define it as convention positive
                eps123_0(m)=epsnxyzv(l,1,m)                             ! initial amplitude 
+if crlibm
                phi123_0(m)=atan_rn(nxyzv(l,1,2*m)/nxyzv(l,1,2*(m-1)+1))! inital phase
+ei
+if .not.crlibm
                phi123_0(m)=atan(nxyzv(l,1,2*m)/nxyzv(l,1,2*(m-1)+1))   ! inital phase
+ei
                eps123_min(m)=minval(epsnxyzv(l,1:fma_nturn(i),m))      ! minimum emittance
                eps123_max(m)=maxval(epsnxyzv(l,1:fma_nturn(i),m))      ! maximum emittance
                eps123_avg(m)=sum(epsnxyzv(l,1:fma_nturn(i),m))/        &
     &fma_nturn(i) ! average emittance
              enddo
              if ( num_modes .eq. 2 ) then
                 q123(3)=0.0
                 phi123_0(3)=0.0
                 eps123_min(3)=0.0
                 eps123_max(3)=0.0
                 eps123_avg(3)=0.0
              endif
              write(2001001,1988) trim(stringzerotrim(fma_fname(i))),   &
     &trim(stringzerotrim(fma_method(i))),l,q123(1),q123(2),q123(3),    &
     &eps123_min(1),eps123_min(2),eps123_min(3),eps123_max(1),          &
     &eps123_max(2),eps123_max(3),eps123_avg(1),eps123_avg(2),          &
     &eps123_avg(3),eps123_0(1),eps123_0(2),eps123_0(3),                &
     &phi123_0(1),phi123_0(2),phi123_0(3)
            enddo
            close(200101+i*10)! filename NORM_* (normalized particle amplitudes)
            close(dumpunit(j))
!    resume initial position of dumpfile = end of file
            open(dumpunit(j),file=dump_fname(j), status='old',          &
     &form='formatted',action='readwrite',position='append',            &
     &iostat=ierro)
            call fma_error(ierro,'while resuming file '//dump_fname(j), &
     &'fma_postpr')
          endif !END: if fma_fname(i) matches dump_fname(j)
!    if file has been already found, jump to next file fma_fname(i)
          if( lexist ) then
            exit
          endif 
        enddo !END: loop over dump files
        if(.not. lexist) then !if no dumpfile has been found, raise error and abort
          call fma_error(-1,'dump file '//trim(stringzero               &
     &trim(fma_fname(i)))//' does not exist! Please check that filenames&
     & in FMA block agree with the ones in the DUMP block!'             &
     &,'fma_postpr')
        endif
      enddo !END: loop over fma files
      close(2001001) !filename: fma_sixtrack

      deallocate(turn, xyzv, nxyzv, epsnxyzv)
      
 1986 format (2(1x,I8),1X,F12.5,6(1X,1PE16.9),1X,I8)   !fmt 2 / not hiprec as in dump subroutine
 1988 format (2(1x,A20),1x,I8,18(1X,1PE16.9))          !fmt for fma output file
      end subroutine fma_postpr
      
      subroutine zipf
!-----------------------------------------------------------------------*
!     ZIPF                                                              *
!     COMPRESS SELECTED OUTPUT FILES INTO .ZIP FILE                     *
!     AT THE END OF THE SIMULATION                                      *
!     K.SJOBAK, 7/02/2016                                               *
!-----------------------------------------------------------------------*
      implicit none
+ca stringzerotrim
+ca zipf
+ca crcoall

      write(lout,'(a,a,a)')
     &     "ZIPF: Compressing file '",
     &     trim(stringzerotrim(zipf_outfile)),"'..."

+if libarchive !If not, the zipf subroutine shall just be a stub.
      call f_write_archive(zipf_outfile,zipf_filenames,zipf_numfiles)
+ei

      write(lout,'(a)') "Done!"

      end subroutine
      
      subroutine fft(ar,ai,m,n)
!---------------------------------------------------------------------
!      A(N) IS A COMPLEX ARRAY. THE INPUT IS A(N)=(X(N),0.0), WHERE
!      X(N) IS THE SEQUENCE TO FOURIER ANALYSE.
!      N=2**M.
!      THIS ROUTINE ONLY WORKS FOR N EQUAL TO A POWER OF TWO.
!      AFTER RETURN A(N)=(..,..) CONTAINS THE COEFFICIENTS OF THE FFT.
!      TO COMPUTE POWER SPECTRA DO   ...=ABS(A(N))
!
!      WRITTEN BY : RUI DILAO
!
!---------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ip,j,k,l,le,le1,m,n,nm1,nv2
      double precision ar,ai,pi,tr,ti,ui,ur,uur,wr,wi
+ca parnum
      dimension ar(n),ai(n)
      save
!-----------------------------------------------------------------------
      n=2**m
      nv2=n/2
      nm1=n-1
      j=1
      do 30 i=1,nm1
        if(i.gt.j)goto 10
        tr=ar(j)
        ti=ai(j)
        ar(j)=ar(i)
        ai(j)=ai(i)
        ar(i)=tr
        ai(i)=ti
   10   k=nv2
   20   if(k.ge.j)goto 30
        j=j-k
        k=k/2
        goto 20
   30 j=j+k
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      do 50 l=1,m
        le=2**l
        le1=le/2
        ur=one
        ui=zero
+if crlibm
        wr=cos_rn(pi/dble(le1))                                          !hr06
+ei
+if .not.crlibm
        wr=cos(pi/dble(le1))                                             !hr06
+ei
+if crlibm
        wi=-1d0*sin_rn(pi/dble(le1))                                     !hr06
+ei
+if .not.crlibm
        wi=-1d0*sin(pi/dble(le1))                                        !hr06
+ei
        do 50 j=1,le1
          do 40 i=j,n,le
            ip=i+le1
            tr=ar(ip)*ur-ai(ip)*ui
            ti=ar(ip)*ui+ai(ip)*ur
            ar(ip)=ar(i)-tr
            ai(ip)=ai(i)-ti
            ar(i)=ar(i)+tr
            ai(i)=ai(i)+ti
   40     continue
        uur=ur*wr-ui*wi
        ui=ur*wi+ui*wr
        ur=uur
   50 continue
      do 60 i=1,n
        ar(i)=(ar(i)/dble(n))*2                                          !hr06
        ai(i)=(ai(i)/dble(n))*2                                          !hr06
   60 continue
      return
      end
      subroutine caconv(a,b,c)
      implicit none
+if crlibm
+ca crlibco
+ei
+ca parnum
      double precision a,b,c
      save
!---------------------------------------------------------------------
      if(abs(b).gt.pieni.or.abs(c).gt.pieni) then
+if crlibm
        a=atan2_rn(b,c)
+ei
+if .not.crlibm
        a=atan2(b,c)
+ei
      else
        a=zero
      endif
      return
      end
      subroutine cphase(k,a,b,c,d,i,j,ie)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ie,j,k
      double precision a,b,c,d,f,phase,tpi,dani
+ca parpro
+ca parnum
+ca commphin
      save
!---------------------------------------------------------------------
+if crlibm
      tpi=8d0*atan_rn(one)                                               !hr06
+ei
+if .not.crlibm
      tpi=8d0*atan(one)                                                  !hr06
+ei
      if(abs(b).gt.pieni.or.abs(c).gt.pieni) then
+if crlibm
        f=atan2_rn(b,c)
+ei
+if .not.crlibm
        f=atan2(b,c)
+ei
        ie=ie+1
        phase(k,ie)=f/tpi+d
        if(i.ne.1.and.-f.gt.pieni) phase(k,ie)=phase(k,ie)+one
        a=a+phase(k,ie)
      else
        j=1
      endif
      return
      end
      subroutine cinvar(a,b,c,d,j,e,xinv,invx)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,invx,j
      double precision a,b,c,d,phase,dani,e,xinv
+ca parpro
+ca parnum
+ca commphin
      dimension xinv(ninv),invx(ninv)
      save
!---------------------------------------------------------------------
      if(abs(a).le.b) then
        do 10 i=1,ninv
          if((c.ge.zero.and.c.ge.dani(i).and.c.lt.dani(i+1)).or. (c.lt. &
     &zero.and.d.ge.dani(i).and.d.lt.dani(i+1))) then
            j=j+1
            if(abs(xinv(i)).le.pieni) then
              xinv(i)=e
              invx(i)=1
            else
              xinv(i)=xinv(i)+e
              invx(i)=invx(i)+1
            endif
          endif
   10   continue
      endif
      return
      end
      subroutine sinpro(a,b,c,d,e)
      implicit none
+if crlibm
+ca crlibco
+ei
      double precision a,b,c,d,e
+ca parnum
      save
!---------------------------------------------------------------------
      if(abs(a).gt.pieni) then
        if(c.gt.pieni.and.b.gt.pieni) then
          c=(sqrt(c/b)/a)*100d0                                          !hr06
        else
          c=zero
        endif
        d=((d-a)/a)*100d0                                                !hr06
        e=((e-a)/a)*100d0                                                !hr06
      else
        c=zero
        d=zero
        e=zero
      endif
      return
      end
+dk join
      subroutine join
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ia,idummy,ierro,ifipa,ihalf,ilapa,ipa,ipa1,itopa,numl
      double precision alf0,bet0,clo,clop,dam,di0,dip0,dps,dummy,e0,pi, &
     &qwc,sigm,ta,x,y
      character*80 sixtit,commen
      character*8 cdate,ctime,progrm
+ca parpro
+ca parnum
+ca commonds
      dimension bet0(2),alf0(2),ta(6,6)
      dimension qwc(3),clo(3),clop(3)
      dimension x(mpa,2),y(mpa,2),sigm(mpa),dps(mpa)
      dimension di0(2),dip0(2)
      save
!-----------------------------------------------------------------------
+if crlibm
      pi=four*atan_rn(one)
+ei
+if .not.crlibm
      pi=four*atan(one)
+ei
      sigcor=one
      dpscor=one
      read(90,end=60,iostat=ierro) sixtit,commen,cdate,ctime, progrm,   &
     &ifipa,ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),&
     &clo(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),     &
     &dummy,dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta  &
     &(2,1),ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),ta &
     &(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta(5,6), ta&
     &(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6)
      if(ierro.gt.0) then
        write(lout,10010) 90,ierro
        goto 70
      endif
!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      bet0(1)=ta(1,1)*ta(1,1)+ta(1,2)*ta(1,2)
      alf0(1)=-(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))
      bet0(2)=ta(3,3)*ta(3,3)+ta(3,4)*ta(3,4)
      alf0(2)=-(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))
      rewind 90
      ihalf=itopa/2
      if(icode.eq.1.or.icode.eq.2.or.icode.eq.4) idam=1
      if(icode.eq.3.or.icode.eq.5.or.icode.eq.6) idam=2
      if(icode.eq.7) idam=3
      do 50 i=1,ihalf
        read(91-i,end=50,iostat=ierro)
        if(ierro.gt.0) then
          write(lout,10010) 91-i,ierro
          goto 50
        endif
        read(91-i-ihalf,end=50,iostat=ierro)
        if(ierro.gt.0) then
          write(lout,10010) 91-i-ihalf,ierro
          goto 50
        endif
   10   read(91-i,end=20,iostat=ierro) ia,ipa,dummy, x(1,1),y(1,1),x    &
     &(1,2),y(1,2),sigm(1),dps(1),e0
        if(ierro.gt.0) then
          write(lout,10010) 91-i,ierro
          goto 20
        endif
        x(1,1)=x(1,1)*c1e3
        y(1,1)=y(1,1)*c1e3
        x(1,2)=x(1,2)*c1e3
        y(1,2)=y(1,2)*c1e3
        sigm(1)=sigm(1)*c1e3
        e0=e0*c1e3
        read(91-i-ihalf,end=20,iostat=ierro) idummy,idummy,dummy, x     &
     &(2,1),y(2,1),x(2,2),y(2,2),sigm(2),dps(2)
        if(ierro.gt.0) then
          write(lout,10010) 91-i-ihalf,ierro
          goto 20
        endif
        x(2,1)=x(2,1)*c1e3
        y(2,1)=y(2,1)*c1e3
        x(2,2)=x(2,2)*c1e3
        y(2,2)=y(2,2)*c1e3
        sigm(2)=sigm(2)*c1e3
        write(90,iostat=ierro) ia,ipa,dummy, x(1,1),y(1,1),x(1,2),y     &
     &(1,2),sigm(1),dps(1),e0, ipa+1,dam,x(2,1),y(2,1),x(2,2),y(2,2),   &
     &sigm(2),dps(2),e0
        if(ierro.ne.0) then
          write(lout,10010) 90,ierro
          goto 20
        endif
        goto 10
   20   rewind 91-i
        rewind 91-i-ihalf
        write(91-i-ihalf,iostat=ierro)
        if(ierro.ne.0) then
          write(lout,10010) 91-i-ihalf,ierro
        endif
        rewind 90
        read(91-i,iostat=ierro) sixtit,commen,cdate,ctime, progrm,ifipa,&
     &ilapa,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),clo   &
     &(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),dummy,  &
     &dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta(2,1),  &
     &ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta       &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),   &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta       &
     &(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6)
        if(ierro.gt.0) then
          write(lout,10010) 91-i,ierro
          goto 40
        endif
        rewind 91-i
        progrm='MADTOSIX'
        write(91-i,iostat=ierro) sixtit,commen,cdate,ctime, progrm,2*i  &
     &-1,2*i,itopa,icode,numl,qwc(1),qwc(2),qwc(3), clo(1),clop(1),clo  &
     &(2),clop(2),clo(3),clop(3), di0(1),dip0(1),di0(2),dip0(2),dummy,  &
     &dummy, ta(1,1),ta(1,2),ta(1,3),ta(1,4),ta(1,5),ta(1,6), ta(2,1),  &
     &ta(2,2),ta(2,3),ta(2,4),ta(2,5),ta(2,6), ta(3,1),ta(3,2),ta       &
     &(3,3),ta(3,4),ta(3,5),ta(3,6), ta(4,1),ta(4,2),ta(4,3),ta(4,4),   &
     &ta(4,5),ta(4,6), ta(5,1),ta(5,2),ta(5,3),ta(5,4),ta(5,5),ta       &
     &(5,6), ta(6,1),ta(6,2),ta(6,3),ta(6,4),ta(6,5),ta(6,6), zero,     &
     &zero,zero,zero,sigcor,dpscor, zero,zero,zero,zero, zero,zero,     &
     &zero,zero,zero,zero,zero,zero,zero,zero, zero,zero,zero,zero,     &
     &zero,zero,zero,zero,zero,zero, zero,zero,zero,zero,zero,zero,     &
     &zero,zero,zero,zero, zero,zero,zero,zero,zero,zero,zero,zero,     &
     &zero,zero
        if(ierro.ne.0) then
          write(lout,10010) 91-i,ierro
          goto 40
        endif
   30   read(90,end=40,iostat=ierro) ia,ipa,dam, x(1,1),y(1,1),x(1,2),y &
     &(1,2),sigm(1),dps(1),e0, ipa1,dam,x(2,1),y(2,1),x(2,2),y(2,2),    &
     &sigm(2),dps(2),e0
        if(ierro.gt.0) then
          write(lout,10010) 90,ierro
          goto 40
        endif
        write(91-i,iostat=ierro) ia,ipa,dam, x(1,1),y(1,1),x(1,2),y     &
     &(1,2),sigm(1),dps(1),e0, ipa1,dam,x(2,1),y(2,1),x(2,2),y(2,2),    &
     &sigm(2),dps(2),e0
        if(ierro.ne.0) then
          write(lout,10010) 91-i,ierro
          goto 40
        endif
        goto 30
   40   rewind 90
        rewind 91-i
   50 continue
      goto 70
   60 continue
      write(lout,10000) 90
   70 continue
!-----------------------------------------------------------------------
      return
10000 format(//10x,'** ERROR IN JOIN** ----- INPUT DATA EMPTY' ,        &
     &' (FILE : ',i2,') -----'//)
10010 format(//10x,'** ERROR IN JOIN** ----- PROBLEMS WITH DATA ' ,     &
     &'FILE : ',i2,' ----- ERROR CODE : ',i10//)
      end
+dk sumpos
      subroutine sumpos
!-----------------------------------------------------------------------
!  SUBROUTINE TO SUMMARIZE THE RESULTS OF THE POSTPROCESSING
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,ierro,j
      double precision d,dlost
      character*4 ch
+ca parnum
+ca parpro
      dimension d(60)
+if crlibm
!     integer nchars
!     parameter (nchars=160)
      character*(1601) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=60)
      character*(maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      double precision fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      rewind 10
      do 10 i=1,1000
        ch=' '
+if .not.crlibm
        read(10,*,end=20,iostat=ierro) (d(j),j=1,60)
+ei
+if crlibm
        read(10,'(A1600)',end=20,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
!       write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
!       write (*,*) ':'//fields(1)//':'
!       write (*,*) ':'//fields(2)//':'
!       write (*,*) ':'//fields(3)//':'
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
+ei
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
        if(i.eq.1) write(lout,10000)
        if(abs(d(2)).gt.pieni) ch='LOST'
        if(d(22).ge.d(23)) then
          dlost=d(23)
        else
          dlost=d(22)
        endif
        write(lout,10010) nint(dlost),d(3),d(5),d(7),d(9),d(10),d(11),  &
     &d(12),nint(d(16)),nint(d(18)),d(19),d(21),ch,d(4),d(6),d(8),      &
     &d(13),nint(d(17)),d(20),d(25),d(14),d(15)
   10 continue
   20 rewind 10
+if crlibm
      lineno=0
+ei
      write(lout,10020)
      do 30 i=1,1000
+if .not.crlibm
        read(10,*,end=40,iostat=ierro) (d(j),j=1,60)
+ei
+if crlibm
        read(10,'(A1600)',end=40,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
+ei
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
! Now we are using 60 for CPU in seconds
! But note that dnms is now found in word 59.
! and we always print the maximum DMMAC as NMAC
! or zero which should really be OK I think.
! N.B. If particle is lost nms is 0, so we set mmac to zero too 
      d(60)=dble(nmac)
      if (nint(d(59)).eq.0) d(60)=zero
      write(lout,10030) i,nint(d(59)),nint(d(60)),                      &
     &nint(d(59))*nint(d(24))
   30 continue
   40 continue
      write(lout,10040)
!-----------------------------------------------------------------------
      return
10000 format(/131('-')/t10,'SUMMARY OF THE POSTPROCESSING' //t1,125(    &
     &'-'), /t1,'|',8x,'|',11x,'|',11x,'|',12x,'|',10x,                 &
     &'|NORMALIZED| SLOPE  |',13x,'|',10x,'|',21x,'|', /t1,             &
     &'|  TURN  |   LINEAR  |   BETA-   | AMPLITUDES | MOMENTUM |',     &
     &'PHASESPACE| OF THE |  NONLINEAR  |  NEAREST |',7x,'SMEAR OF',6x, &
     &'|', /t1,                                                         &
     &'| NUMBER |   TUNES   | FUNCTIONS |            | DEVIATION|',     &
     &' DISTANCE |DISTANCE|  DETUNING   | RESONANCE|    THE EMITTANCES' &
     &,3x,'|',/t1,125('-'), /t1,                                        &
     &'|        |           |     [M]   |     [MM]   |          |',     &
     &'          |        |             |     |ORD.|',                  &
     &'    [%]  |      [%]  |'/t1,125('-'))
10010 format(t1,'|',i8,'|X ',f9.5,'|X ',f9.4,'|X ',f10.6,'|',d10.4, '|',&
     &d10.4,'|',f8.4,'|X ',d11.5,'|X ',i3,'| ',i2,' |X ', f7.3,'|X+Y ', &
     &f7.3,'|' /t1,'|  ',a4,'  |Y ',f9.5,'|Y ',f9.4,'|Y ',f10.6,'|',10x,&
     &'|',10x,'|',8x,'|+/- ',d9.3,'|Y ',i3,'|    |Y ', f7.3,'|    ',7x, &
     &'|' /t1,'|',8x,'|QS ',f8.6,'|  ',9x,'|  ',10x,'|',10x, '|',10x,'|'&
     &,8x,'|Y ',d11.5,'|  ',3x,'|    |  ', 7x,'|    ',7x,'|' /t1,'|',8x,&
     &'|  ',9x,'|  ',9x,'|  ',10x,'|',10x, '|',10x,'|',8x,'|+/- ',d9.3, &
     &'|  ',3x,'|    |  ', 7x,'|    ',7x,'|'/t1,125('-'))
10020 format(/131('-')/t10,'RANDOM SETS USED' //                        &
     &'  CASE  |  # OF RANDOM SET  |  MAX. POSSIBLE SETS   |    ',      &
     &' SEED'/65('-'))
10030 format(3x,i2,13x,i2,19x,i2,13x,i8)
10040 format(65('-')//131('-'))
      end
      
+dk beam6d
      subroutine beamint(np,track,param,sigzs,bcu,ibb,ne,ibtyp,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer ibb,ibbc,ibtyp,ne,np,nsli
      double precision alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,tphi,track,star,phi2,cphi2,sphi2,tphi2
+ca parpro
+ca parnum
      dimension track(6,npart)
      dimension param(nele,18),bcu(nbb,12)
      dimension star(3,mbea)
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/dble(nsli)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         alpha=param(ne,3)
         phi=param(ne,1)
         nsli=param(ne,2)
         !sepax=param(ne,4)     !Not actually used anywhere?
         !sepay=param(ne,5)     !Not actually used anywhere?
         f=param(ne,4)/dble(nsli)
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beamint"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif

+if crlibm
      sphi=sin_rn(phi)
      sphi2=sin_rn(phi2)
+ei
+if .not.crlibm
      sphi=sin(phi)
      sphi2=sin(phi2)
+ei
+if crlibm
      cphi=cos_rn(phi)
      cphi2=cos_rn(phi2)
+ei
+if .not.crlibm
      cphi=cos(phi)
      cphi2=cos(phi2)
+ei
+if crlibm
      tphi=tan_rn(phi)
      tphi2=tan_rn(phi2)
+ei
+if .not.crlibm
      tphi=tan(phi)
      tphi2=tan(phi2)
+ei
+if crlibm
      salpha=sin_rn(alpha)
+ei
+if .not.crlibm
      salpha=sin(alpha)
+ei
+if crlibm
      calpha=cos_rn(alpha)
+ei
+if .not.crlibm
      calpha=cos(alpha)
+ei
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boost(np,sphi,cphi,tphi,salpha,calpha,track)
      call sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
      call boosti(np,sphi,cphi,tphi,salpha,calpha,track)
      return
      end
      subroutine boost(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOST Boost Operation ********************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,np
      double precision calpha,cphi,h,h1x,h1y,h1z,hd1,salpha,sphi,tphi,  &
     &track,x1,y1
+ca parpro
+ca parnum
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h=(track(6,i)+one)-sqrt(((one+track(6,i))**2-                   &!hr06
     &track(2,i)**2)-track(4,i)**2)                                      !hr06
        track(6,i)=((track(6,i)-(calpha*tphi)*track(2,i))               &!hr06
     &-(track(4,i)*salpha)*tphi)+h*tphi**2                               !hr06
        track(2,i)=(track(2,i)-(tphi*h)*calpha)/cphi                     !hr06
        track(4,i)=(track(4,i)-(tphi*h)*salpha)/cphi                     !hr06
        hd1=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/hd1
        h1y=track(4,i)/hd1
        h1z=one-(one+track(6,i))/hd1
        x1=((calpha*tphi)*track(5,i)+(one+(calpha*sphi)*h1x)*track(1,i))&!hr06
     &+((track(3,i)*salpha)*sphi)*h1x                                    !hr06
        y1=((salpha*tphi)*track(5,i)+(one+(salpha*sphi)*h1y)*track(3,i))&!hr06
     &+((track(1,i)*calpha)*sphi)*h1y                                    !hr06
        track(5,i)=track(5,i)/cphi+h1z*((sphi*calpha)*track(1,i)        &!hr06
     &+(sphi*salpha)*track(3,i))                                         !hr06
        track(1,i)=x1
        track(3,i)=y1
 1000 continue
      return
      end
      subroutine sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!**SBC ***Synchro-Beam for headon collision**********************
!  call BBF  (table) disabled
!****************************************************************
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,ibb,ibbc,ibbc1,ibtyp,jsli,np,nsli
      double precision bbf0,bbfx,bbfy,bbgx,bbgy,bcu,costh,costhp,cphi,  &
     &dum,f,s,sepx,sepx0,sepy,sepy0,sfac,sinth,sinthp,sp,star,sx,       &
     &sy,track,cphi2
+ca parpro
+ca parnum
      dimension track(6,npart),bcu(nbb,12)
      dimension star(3,mbea),dum(13)
      save
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
        do 1000 i=1,np
          s=(track(5,i)-star(3,jsli))*half
          !write(*,*)'JBG - cphi2',cphi2
          sp=s/cphi2 
          dum(1)=(bcu(ibb,1)+(two*bcu(ibb,4))*sp)+bcu(ibb,6)*sp**2       !hr06
          dum(2)=(bcu(ibb,2)+(two*bcu(ibb,9))*sp)+bcu(ibb,10)*sp**2      !hr06
          dum(3)=(bcu(ibb,3)+(bcu(ibb,5)+bcu(ibb,7))*sp)+               &!hr06
     &bcu(ibb,8)*sp**2                                                   !hr06
          dum(4)=dum(1)-dum(2)
          dum(5)=dum(4)**2+four*dum(3)**2                                !hr06
          if(ibbc.eq.1.and.(abs(dum(4)).gt.pieni.and.                   &
     &abs(dum(5)).gt.pieni)) then
            ibbc1=1
            dum(5)=sqrt(dum(5))
         else
            ibbc1=0
          endif
        !JBG New set of canonical set of variables at the Col point (CP)
          sepx0=(track(1,i)+track(2,i)*s)-star(1,jsli)                   !hr06
          sepy0=(track(3,i)+track(4,i)*s)-star(2,jsli)                   !hr06
          if(ibbc1.eq.1) then
            sfac=one
            if(dum(4).lt.zero) sfac=-1d0*one                             !hr06
            dum(6)=(sfac*dum(4))/dum(5)                                  !hr06
            dum(7)=dum(1)+dum(2)
            costh=half*(one+dum(6))
            if(abs(costh).gt.pieni) then
              costh=sqrt(costh)
            else
              costh=zero
            endif
            sinth=half*(one-dum(6))
            if(abs(sinth).gt.pieni) then
              sinth=(-1d0*sfac)*sqrt(sinth)                              !hr06
            else
              sinth=zero
            endif
            if(dum(3).lt.zero) sinth=-1d0*sinth                          !hr06
            sy=sfac*dum(5)
            sx=(dum(7)+sy)*half
            sy=(dum(7)-sy)*half
            sepx=sepx0*costh+sepy0*sinth
            sepy=sepy0*costh-sepx0*sinth                                 !hr06
          else
            sx=dum(1)
            sy=dum(2)
            sepx=sepx0
            sepy=sepy0
          endif
          if(sx.gt.sy) then
            call bbf(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy,ibtyp)
          else
            call bbf(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx,ibtyp)
          endif
          bbfx=f*bbfx
          bbfy=f*bbfy
          bbgx=f*bbgx
          bbgy=f*bbgy
          if(ibbc1.eq.1) then
            dum(8)=two*((bcu(ibb,4)-bcu(ibb,9))+                        &!hr06
     &(bcu(ibb,6)-bcu(ibb,10))*sp)                                       !hr06
            dum(9)=(bcu(ibb,5)+bcu(ibb,7))+(two*bcu(ibb,8))*sp           !hr06
            dum(10)=(((dum(4)*dum(8)+(four*dum(3))*dum(9))/             &!hr06
     &dum(5))/dum(5))/dum(5)                                             !hr06
            dum(11)=sfac*(dum(8)/dum(5)-dum(4)*dum(10))
            dum(12)=(bcu(ibb,4)+bcu(ibb,9))+(bcu(ibb,6)+bcu(ibb,10))*sp  !hr06
      dum(13)=(sfac*((dum(4)*dum(8))*half+(two*dum(3))*dum(9)))/dum(5)   !hr06
            if(abs(costh).gt.pieni) then
              costhp=(dum(11)/four)/costh                                !hr06
            else
              costhp=zero
            endif
            if(abs(sinth).gt.pieni) then
              sinthp=((-1d0*dum(11))/four)/sinth                         !hr06
            else
              sinthp=zero
            endif
            track(6,i)=track(6,i)-                                      &!hr06
     &((((bbfx*(costhp*sepx0+sinthp*sepy0)+                             &!hr06
     &bbfy*(costhp*sepy0-sinthp*sepx0))+                                &!hr06
     &bbgx*(dum(12)+dum(13)))+bbgy*(dum(12)-dum(13)))/                  &!hr06
     &cphi)*half                                                         !hr06
            bbf0=bbfx
            bbfx=bbf0*costh-bbfy*sinth
            bbfy=bbf0*sinth+bbfy*costh
          else
            track(6,i)=track(6,i)-                                      &
     &(bbgx*(bcu(ibb,4)+bcu(ibb,6)*sp)+                                 &
     &bbgy*(bcu(ibb,9)+bcu(ibb,10)*sp))/cphi
          endif
          track(6,i)=track(6,i)-(bbfx*(track(2,i)-bbfx*half)+           &
     &bbfy*(track(4,i)-bbfy*half))*half
          track(1,i)=track(1,i)+s*bbfx
          track(2,i)=track(2,i)-bbfx
          track(3,i)=track(3,i)+s*bbfy
          track(4,i)=track(4,i)-bbfy
 1000   continue
 2000 continue
      return
      end
      subroutine boosti(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOSTI **************inverse boost *****************
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,np
      double precision calpha,cphi,det,h1,h1d,h1x,h1y,h1z,salpha,sphi,  &
     &tphi,track,x1,y1,z1
+ca parpro
+ca parnum
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h1d=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/h1d
        h1y=track(4,i)/h1d
        h1z=one-(one+track(6,i))/h1d
        h1=((track(6,i)+one)-sqrt(((one+track(6,i))**2-                 &!hr06
     &track(2,i)**2)-track(4,i)**2))*cphi**2                             !hr06
        det=one/cphi+tphi*((h1x*calpha+h1y*salpha)-h1z*sphi)             !hr06
        x1= (track(1,i)*(one/cphi+(salpha*(h1y-(h1z*salpha)*sphi))*tphi)&!hr06
     &+((track(3,i)*salpha)*tphi)*((h1z*calpha)*sphi-h1x))              &!hr06
     &-(track(5,i)*((calpha+((h1y*calpha)*salpha)*sphi)                 &!hr06
     &-(h1x*salpha**2)*sphi))*tphi                                       !hr06
        y1= (((track(1,i)*calpha)*tphi)*((h1z*salpha)*sphi-h1y)         &!hr06
     &+track(3,i)*(one/cphi+(calpha*(h1x-(h1z*calpha)*sphi))*tphi))     &!hr06
     &-(track(5,i)*(salpha-(h1y*calpha**2)*sphi                         &!hr06
     &+((h1x*calpha)*salpha)*sphi))*tphi                                 !hr06
        z1= (track(5,i)*((one+(h1x*calpha)*sphi)+(h1y*salpha)*sphi)     &!hr06
     &-((track(1,i)*h1z)*calpha)*sphi)-((track(3,i)*h1z)*salpha)*sphi    !hr06
        track(1,i)=x1/det
        track(3,i)=y1/det
        track(5,i)=z1/det
        track(6,i)=(track(6,i)+(calpha*sphi)*track(2,i))                &!hr06
     &+(salpha*sphi)*track(4,i)                                          !hr06
        track(2,i)=(track(2,i)*cphi+(calpha*tphi)*h1)                    !hr06
        track(4,i)=(track(4,i)*cphi+(salpha*tphi)*h1)                    !hr06
 1000 continue
      return
      end
      subroutine bbf(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy,ibtyp)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**BBF   without using table ******************************************
! gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      implicit none
+if crlibm
+ca crlibco
+ei
      integer ibtyp
      double precision arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,     &
     &comfac,comfac2,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,sigyy, &
     &sqrpi2,wx1,wx2,wy1,wy2,x,xxyy
+ca parpro
+ca parnum
      data sqrpi2/3.544907701811032d0/
      save
!-----------------------------------------------------------------------
      if(sigxx.eq.sigyy) then
        x=sepx**2+sepy**2
        xxyy=sigxx+sigyy
        const=0.0d0
        if(abs(xxyy).gt.pieni) const=x/xxyy
+if crlibm
        expfac=exp_rn(-1d0*const)                                        !hr06
+ei
+if .not.crlibm
        expfac=exp(-1d0*const)                                           !hr06
+ei
        bbfx=0.0d0
        bbfy=0.0d0
        bbgx=0.0d0
        bbgy=0.0d0
        if(abs(x).gt.pieni) then
          bbfx=((2.0d0*sepx)*(1d0-expfac))/x                             !hr06
          bbfy=((2.0d0*sepy)*(1d0-expfac))/x                             !hr06
          comfac=sepy*bbfy-sepx*bbfx                                     !hr06
          comfac2=(abs(sigxx)+abs(sigyy))**2
          bbgx=(comfac+(((4d0*sepx**2)*const)/x)*expfac)/(2d0*x)         !hr06
          bbgy=((((4d0*sepy**2)*const)/x)*expfac-comfac)/(2d0*x)         !hr06
        endif
      else
        x=sepx**2/sigxx+sepy**2/sigyy
        fac2=2.d0*abs(sigxx-sigyy)
        fac=sqrt(fac2)
        const=sqrpi2/fac
        sigxy=sqrt(sigxx/sigyy)
        arg1x=abs(sepx/fac)
        arg1y=abs(sepy/fac)
        if(ibtyp.eq.0) call errf(arg1x,arg1y,wy1,wx1)
        if(ibtyp.eq.1) call wzsub(arg1x,arg1y,wy1,wx1)
        if(x.lt.100.d0) then
+if crlibm
          expfac=exp_rn(-0.5d0*x)                                        !hr06
+ei
+if .not.crlibm
          expfac=exp(-0.5d0*x)                                           !hr06
+ei
          arg2x=arg1x/sigxy
          arg2y=arg1y*sigxy
          if(ibtyp.eq.0) call errf(arg2x,arg2y,wy2,wx2)
          if(ibtyp.eq.1) call wzsub(arg2x,arg2y,wy2,wx2)
          bbfx=const*(wx1-expfac*wx2)
          bbfy=const*(wy1-expfac*wy2)
          if(sepx.lt.0) bbfx=-1d0*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-1d0*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-1d0*(comfac+2d0*(expfac/sigxy -1d0)))/fac2              !hr06
          bbgy= (comfac+2d0*(expfac*sigxy -1d0))/fac2                    !hr06
        else
          bbfx=const*wx1
          bbfy=const*wy1
          if(sepx.lt.0) bbfx=-1d0*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-1d0*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-1d0*(comfac-2d0))/fac2                                  !hr06
          bbgy= -1d0*bbgx                                                !hr06
        endif
      endif
      return
      end
      subroutine stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!*******STSLD*********************************************************
!   makes longitudinal position of the strong slice for all slices
!*********************************************************************
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,nsli
      double precision bord,bord1,border,calpha,cphi,cphi2,gauinv,pi,   &
     &salpha,sigz,sigzs,sphi,sphi2,star,yy
+ca parpro
+ca parnum
      dimension star(3,mbea)
!-----------------------------------------------------------------------
      data border /8d0/
      save
!-----------------------------------------------------------------------
+if crlibm
      pi=4d0*atan_rn(1d0)
+ei
+if .not.crlibm
      pi=4d0*atan(1d0)
+ei
      sigz=sigzs/cphi2
! DEFINE `STARRED' COORDINATES
!  BORD is longitudinal border star(3,mbea) is the barycenter of region
!  divided two borders.
      bord=+border
      do 101 i=nsli,1,-1
        yy=(1d0/dble(nsli))*dble(i-1)                                    !hr06
        if(i.ne.1) bord1=gauinv(yy)                                      !hr06
        if(i.eq.1) bord1=-1d0*border                                     !hr06
+if crlibm
        star(3,i)=(((exp_rn((-1d0*bord**2)*half)-                       &!hr06
     &exp_rn((-1d0*bord1**2)*half))/sqrt(2d0*pi))*dble(nsli))*sigz       !hr06
+ei
+if .not.crlibm
       star(3,i)=(((exp((-1d0*bord**2)*half)-exp((-1d0*bord1**2)*half))/&!hr06
     &sqrt(2d0*pi))*dble(nsli))*sigz                                     !hr06
+ei
        bord=bord1
        !JBG When doing slicing phi=0 for crab crossing
        ! star(1,i)=0.
        ! star(2,i)=0. 
        !JBG When doing slicing phi2 different tiltings of the strong beam
        star(1,i)=(star(3,i)*sphi2)*calpha
        star(2,i)=(star(3,i)*sphi2)*salpha  
        !star(1,i)=(star(3,i)*sphi)*calpha                                !hr06
        !star(2,i)=(star(3,i)*sphi)*salpha                                !hr06
 101  continue
      return
      end
      function gauinv(p0)
!GAUINV***********************************************
!  INVERSE OF (INTEGRATED) NORMAL DISTRIBUTION FUNCTION
!              1         X= Y
!     P(Y)=-----------* INTEGRAL EXP(-X**2/2) DX
!          SQRT(2*PI)    X= -INF
!     IF P(Y)=P0, THEN GAUINV(P0)=Y.
!        0 < P0 < 1 ,   -INF < Y < +INF
!  IF THIS ROUTINE IS USED TO CONVERT UNIFORM RANDOM NUMBERS TO
!  GAUSSIAN, MAXIMUM RELATIVE ERROR IN THE DISTRIBUTION FUNCTION
!  DP/DX=EXP(-X**2/2)/SQRT(2*PI) IS LESS THAN 0.640E-3 EVERYWHERE
!  IN THE RANGE  2**(-31) < P0 < 1-2**31.  (MINIMAX APPROXIMATION)
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      double precision a0,a1,a2,a3,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d0,d1, &
     &d2,d3,d4,e0,e1,e2,e3,e4,f0,f1,f2,gauinv,p,p0,p1,p2,pp1,q,qq2,qq3, &
     &qq4,qq5,t
!-----------------------------------------------------------------------
      data pp1/0.334624883253d0/, qq2/0.090230446775d0/,                &
     &qq3/0.049905685242d0/, qq4/0.027852994157d0/,                     &
     &qq5/0.015645650215d0/
      data a3/ 4.5585614d+01/, a2/ 2.1635544d+00/, a1/ 2.7724523d+00/,  &
     &a0/ 2.5050240d+00/,                                               &
     &b4/ 4.0314354d+02/, b3/-2.7713713d+02/, b2/ 7.9731883d+01/,       &
     &b1/-1.4946512d+01/, b0/ 2.2157257d+00/,                           &
     &c4/ 4.1394487d+03/, c3/-1.5585873d+03/, c2/ 2.4648581d+02/,       &
     &c1/-2.4719139d+01/, c0/ 2.4335936d+00/,                           &
     &d4/ 4.0895693d+04/, d3/-8.5400893d+03/, d2/ 7.4942805d+02/,       &
     &d1/-4.1028898d+01/, d0/ 2.6346872d+00/,                           &
     &e4/ 3.9399134d+05/, e3/-4.6004775d+04/, e2/ 2.2566998d+03/,       &
     &e1/-6.8317697d+01/, e0/ 2.8224654d+00/
      data f0/-8.1807613d-02/, f1/-2.8358733d+00/, f2/ 1.4902469d+00/
      save
!-----------------------------------------------------------------------
      p=p0-0.5d0
      p1=abs(p)
      if(p1.ge.pp1) goto 120
      p2=p**2
      gauinv=(((a3*p2+a2)*p2+a1)*p2+a0)*p
      return
 120  q=0.5d0-p1
      if(q.le.qq2) goto 140
      gauinv=(((b4*q+b3)*q+b2)*q+b1)*q+b0
      goto 200
 140  if(q.le.qq3) goto 150
      gauinv=(((c4*q+c3)*q+c2)*q+c1)*q+c0
      goto 200
 150  if(q.le.qq4) goto 160
      gauinv=(((d4*q+d3)*q+d2)*q+d1)*q+d0
      goto 200
 160  if(q.le.qq5) goto 170
      gauinv=(((e4*q+e3)*q+e2)*q+e1)*q+e0
      goto 200
 170  if(q.le.0d0) goto 900
+if crlibm
      t=sqrt(-2d0*log_rn(q))
+ei
+if .not.crlibm
      t=sqrt(-2d0*log(q))
+ei
      gauinv=(t+f0)+f1/(f2+t)                                            !hr06
 200  if(p.lt.0d0) gauinv=-1d0*gauinv                                    !hr06
      return
 900  write(lout,910) p0
 910  format(' (FUNC.GAUINV) INVALID INPUT ARGUMENT ',1pd20.13)
      call closeUnits
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
      end
+dk myrinv
      subroutine kerset(ercode,lgfile,limitm,limitr)
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer i,kounte,l,lgfile,limitm,limitr,log,logf
      parameter(kounte = 27)
      character*6         ercode,   code(kounte)
      logical             mflag,    rflag
      integer             kntm(kounte),       kntr(kounte)
!-----------------------------------------------------------------------
      data      logf      /  0  /
      data      code(1), kntm(1), kntr(1)  / 'C204.1', 255, 255 /
      data      code(2), kntm(2), kntr(2)  / 'C204.2', 255, 255 /
      data      code(3), kntm(3), kntr(3)  / 'C204.3', 255, 255 /
      data      code(4), kntm(4), kntr(4)  / 'C205.1', 255, 255 /
      data      code(5), kntm(5), kntr(5)  / 'C205.2', 255, 255 /
      data      code(6), kntm(6), kntr(6)  / 'C305.1', 255, 255 /
      data      code(7), kntm(7), kntr(7)  / 'C308.1', 255, 255 /
      data      code(8), kntm(8), kntr(8)  / 'C312.1', 255, 255 /
      data      code(9), kntm(9), kntr(9)  / 'C313.1', 255, 255 /
      data      code(10),kntm(10),kntr(10) / 'C336.1', 255, 255 /
      data      code(11),kntm(11),kntr(11) / 'C337.1', 255, 255 /
      data      code(12),kntm(12),kntr(12) / 'C341.1', 255, 255 /
      data      code(13),kntm(13),kntr(13) / 'D103.1', 255, 255 /
      data      code(14),kntm(14),kntr(14) / 'D106.1', 255, 255 /
      data      code(15),kntm(15),kntr(15) / 'D209.1', 255, 255 /
      data      code(16),kntm(16),kntr(16) / 'D509.1', 255, 255 /
      data      code(17),kntm(17),kntr(17) / 'E100.1', 255, 255 /
      data      code(18),kntm(18),kntr(18) / 'E104.1', 255, 255 /
      data      code(19),kntm(19),kntr(19) / 'E105.1', 255, 255 /
      data      code(20),kntm(20),kntr(20) / 'E208.1', 255, 255 /
      data      code(21),kntm(21),kntr(21) / 'E208.2', 255, 255 /
      data      code(22),kntm(22),kntr(22) / 'F010.1', 255,   0 /
      data      code(23),kntm(23),kntr(23) / 'F011.1', 255,   0 /
      data      code(24),kntm(24),kntr(24) / 'F012.1', 255,   0 /
      data      code(25),kntm(25),kntr(25) / 'F406.1', 255,   0 /
      data      code(26),kntm(26),kntr(26) / 'G100.1', 255, 255 /
      data      code(27),kntm(27),kntr(27) / 'G100.2', 255, 255 /
      save
!-----------------------------------------------------------------------
      logf  =  lgfile
         l  =  0
      if(ercode .ne. ' ')  then
         do 10  l = 1, 6
            if(ercode(1:l) .eq. ercode)  goto 12
  10        continue
  12     continue
      endif
      do 14     i  =  1, kounte
         if(l .eq. 0)  goto 13
         if(code(i)(1:l) .ne. ercode(1:l))  goto 14
  13     if(limitm.ge.0) kntm(i)  =  limitm
         if(limitr.ge.0) kntr(i)  =  limitr
  14     continue
      return
      entry kermtr(ercode,log,mflag,rflag)
      log  =  logf
      do 20     i  =  1, kounte
         if(ercode .eq. code(i))  goto 21
  20     continue
      write(lout,1000)  ercode
      call abend('KERNLIB Library Error                             ')
      return
  21  rflag  =  kntr(i) .ge. 1
      if(rflag  .and.  (kntr(i) .lt. 255))  kntr(i)  =  kntr(i) - 1
      mflag  =  kntm(i) .ge. 1
      if(mflag  .and.  (kntm(i) .lt. 255))  kntm(i)  =  kntm(i) - 1
      if(.not. rflag)  then
         if(logf .lt. 1)  then
            write(lout,1001)  code(i)
         else
            write(logf,1001)  code(i)
         endif
      endif
      if(mflag .and. rflag)  then
         if(logf .lt. 1)  then
            write(lout,1002)  code(i)
         else
            write(logf,1002)  code(i)
         endif
      endif
      return
1000  format(' KERNLIB LIBRARY ERROR. ' /                               &
     &' ERROR CODE ',a6,' NOT RECOGNIZED BY KERMTR',                    &
     &' ERROR MONITOR. RUN ABORTED.')
1001  format(/' ***** RUN TERMINATED BY CERN LIBRARY ERROR ',           &
     &'CONDITION ',a6)
1002  format(/' ***** CERN LIBRARY ERROR CONDITION ',a6)
      end
      subroutine rinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR REQINV.)
!
!     CALLS ... RFACT, RFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer idim,ifail,ir,jfail,k,kprnt,n
      real t1,t2,t3,a,det,temp,s,c11,c12,c13,c21,c22,c23,c31,c32,c33
      character*6 name
      dimension ir(n),a(idim,n)
      data name/'RINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      t1=abs(a(1,1))
      t2=abs(a(2,1))
      t3=abs(a(3,1))
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.0.) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.0.) goto 8
      s=1e0/det                                                          !hr07
      c11   =s*a(2,2)
      a(1,2)=(-1e0*s)*a(1,2)                                             !hr07
      a(2,1)=(-1e0*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.0.) goto 8
      a(1,1)=1e0/a(1,1)                                                  !hr07
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call rfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call rfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end
      subroutine dinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR DEQINV.)
!
!     CALLS ... DFACT, DFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      implicit none
+if crlibm
+ca crlibco
+ei
      integer idim,ifail,jfail,k,kprnt,n
      integer ir
      real t1,t2,t3
      double precision a,det,temp,s,c11,c12,c13,c21,c22,c23,c31,c32,c33
      character*6 name
      dimension ir(n),a(idim,n)
      data name/'DINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      t1=abs(real(a(1,1)))                                               !hr07
      t2=abs(real(a(2,1)))                                               !hr07
      t3=abs(real(a(3,1)))                                               !hr07
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.0d0) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.0d0) goto 8
      s=1d0/det
      c11   =s*a(2,2)
      a(1,2)=(-1d0*s)*a(1,2)                                             !hr07
      a(2,1)=(-1d0*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.0d0) goto 8
      a(1,1)=1d0/a(1,1)
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call dfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call dfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end
      subroutine f010pr(name,n,idim,k,kprnt)
!     ******************************************************************
!
!     PRINT ROUTINE FOR PARAMETER ERRORS IN MATRIX SUBROUTINES $EQINV,
!     $EQN, $INV (WHERE $ IS A LETTER SPECIFYING THE ARITHMETIC TYPE).
!
!     NAME         (CHARACTER*6) NAME OF THE CALLING ROUTINE.
!
!     N,IDIM,K     PARAMETERS OF THE CALLING ROUTINE (WITH K=0 IF K IS
!                  NOT TO BE PRINTED).
!
!     KPRNT        PRINT FLAG FOR K (K IS NOT PRINTED IF KPRNT=0).
!
!     ******************************************************************
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer idim,k,kprnt,lgfile,n
      character*6 name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      call kermtr('F010.1',lgfile,mflag,rflag)
      if(mflag) then
         if(lgfile.eq.0)  then
            if(kprnt.eq.0) write(lout,2000) name,n,idim
            if(kprnt.ne.0) write(lout,2001) name,n,idim,k
         else
            if(kprnt.eq.0) write(lgfile,2000) name,n,idim
            if(kprnt.ne.0) write(lgfile,2001) name,n,idim,k
         endif
      endif
      if(.not. rflag)                                                   &
     &call abend('KERNLIB F010PR: '//name//                             &
     &'                            ')
      return
!
 2000 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim).',                                  &
     &6x,'n =', i4, 6x,'idim =', i4,'.')
 2001 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim or k.lt.1).',                        &
     &6x,'n =', i4, 6x,'idim =', i4, 6x,'k =', i4,'.')
      end
      subroutine rfact(n,a,idim,ir,ifail,det,jfail)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ifail,imposs,ipairf,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch
      real a,det,g1,g2,one,p,pivotf,q,sizef,t,tf,x,y,zero
      double precision s11,s12,dotf
      character*6 hname
      dimension ir(*),a(idim,*)
!      data      g1, g2              /  1.e-37,  1.e37  /
      data      g1, g2              /  1.0e-37,  1.0e37  /               !hr07
      data      hname               /  ' RFACT'  /
      data      zero, one           /  0., 1.  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s11)  =  dble(x)*dble(y) + s11
      ipairf(j,k)  =  j*2**12 + k
      pivotf(x)    =  abs(x)
      sizef(x)     =  abs(x)
      if(idim .ge. n  .and.  n .gt. 0)  goto 110
         call tmprnt(hname,n,idim,0)
         return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q  =  pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. 0.)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
            s11  =  -1d0*dble(a(j,k))                                    !hr07
            s12  =  -1d0*dble(a(k,j+1))                                  !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
 142        a(j,k)    =  real((-1d0*s11) * dble(a(j,j)))                 !hr07
            a(k,j+1)  =  real(-1d0*dotf(a(j,j+1),a(k,j),s12))            !hr07
 143        continue
 144     continue
 150  if(mod(nxch,2) .ne. 0)  det  =  -1e0*det
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return
      end
      subroutine dfact(n,a,idim,ir,ifail,det,jfail)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ifail,imposs,ipairf,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch
      real g1,g2,p,pivotf,q,sizef,t
      double precision a,det,dotf,zero,one,s11,s12,x,y,tf
      character*6         hname
      dimension ir(*),a(idim,*)
!      data      g1, g2              /  1.e-37,  1.e37  /
      data      g1, g2              /  1.0e-37,  1.0e37  /               !hr07
      data      hname               /  ' DFACT'  /
      data      zero, one           /  0.d0, 1.d0  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------
      ipairf(j,k)  =  j*2**12 + k
      pivotf(x)    =  abs(real(x))                                       !hr07
      sizef(x)     =  abs(real(x))                                       !hr07
      dotf(x,y,s11)  =  x * y + s11
      if(idim .ge. n  .and.  n .gt. 0)  goto 110
      call tmprnt(hname,n,idim,0)
      return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q  =  pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. 0.)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
            s11  =  -1d0*a(j,k)                                          !hr07
            s12  =  -1d0*a(k,j+1)                                        !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
 142        a(j,k)    =  (-1d0*s11) * a(j,j)                             !hr07
            a(k,j+1)  =  -1d0*dotf(a(j,j+1),a(k,j),s12)                  !hr07
 143        continue
 144     continue
 150  if(mod(nxch,2) .ne. 0)  det  =  -1d0*det                           !hr07
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return
      end
      subroutine rfeqn(n,a,idim,ir,k,b)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      real a,b,te,x,y
      double precision dotf,s21,s22
      character*6 hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' RFEQN'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s21)  =  dble(x)*dble(y) + s21
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
            s21  =  -1d0* dble(b(i,l))                                   !hr07
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
            b(i,l)  =  real((-1d0*dble(a(i,i)))*s21)                     !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
            s22  =  -1d0*dble(b(nmi,l))                                  !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
            b(nmi,l)  =  real(-1d0*s22)
 242        continue
 243     continue
 299  continue
      return
      end
      subroutine dfeqn(n,a,idim,ir,k,b)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      double precision a,b,x,y,te
      double precision dotf,s21,s22
      character*6 hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' DFEQN'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s21)  =  x*y + s21
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
            s21  =  - b(i,l)
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
            b(i,l)  =  (-1d0*a(i,i))*s21                                 !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
            s22  =  -1d0*b(nmi,l)                                        !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
            b(nmi,l)  =  -1d0*s22                                        !hr07
 242        continue
 243     continue
 299  continue
      return
      end
      subroutine rfinv(n,a,idim,ir)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      real a,ti,x,y
      double precision dotf,s31,s32,s33,s34,zero
      character*6 hname
      dimension ir(*),a(idim,*)
      data      zero      /  0.d0  /
      data      hname               /  ' RFINV'  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s31)  =  dble(x)*dble(y) + s31
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
      a(2,1)  =  real((-1d0*dble(a(2,2))) * dotf(a(1,1),a(2,1),zero))     !hr07
      a(1,2)  =  -1e0*a(1,2)                                             !hr07
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
            s32  =  dble(a(j,i))                                         !hr07
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
      a(i,j)  =  real((-1d0*dble(a(i,i))) * dotf(a(i-1,j),a(i,i-1),s31)) !hr07
            a(j,i)  =  real(-1d0*s32)                                    !hr07
 312        continue
      a(i,i-1)=real((-1d0*dble(a(i,i)))*dotf(a(i-1,i-1),a(i,i-1),zero))  !hr07
         a(i-1,i)  =  -1e0*a(i-1,i)                                      !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
            s33  =  dble(a(i,j))                                         !hr07
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
            a(i,i+j)  =  real(s34)                                       !hr07
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341  k  =  1, n
            ti      =  a(k,i)
            a(k,i)  =  a(k,j)
            a(k,j)  =  ti
 341        continue
 342     continue
      return
      end
      subroutine dfinv(n,a,idim,ir)
      implicit none
+if crlibm
+ca crlibco
+ei
      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      double precision a,dotf,s31,s32,s33,s34,ti,x,y,zero
      character*6 hname
      dimension ir(*),a(idim,*)
      data      hname               /  ' DFINV'  /
      data      zero      /  0.d0  /
      save
!-----------------------------------------------------------------------
      dotf(x,y,s31)  =  x*y + s31
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
      a(2,1)  =  (-1d0*a(2,2)) * dotf(a(1,1),a(2,1),zero)                !hr07
      a(1,2)  =  -1d0*a(1,2)
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
            s32  =  a(j,i)
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
            a(i,j)  =  (-1d0*a(i,i)) * dotf(a(i-1,j),a(i,i-1),s31)       !hr07
            a(j,i)  =  -1d0*s32                                          !hr07
 312        continue
         a(i,i-1)  =  (-1d0*a(i,i)) * dotf(a(i-1,i-1),a(i,i-1),zero)     !hr07
         a(i-1,i)  =  -1d0*a(i-1,i)                                      !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
            s33  =  a(i,j)
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
            a(i,i+j)  =  s34
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341  k  =  1, n
            ti      =  a(k,i)
            a(k,i)  =  a(k,j)
            a(k,j)  =  ti
 341        continue
 342     continue
      return
      end
      subroutine tmprnt(name,n,idim,k)
      implicit none
+ca crcoall
+if crlibm
+ca crlibco
+ei
      integer idim,k,lgfile,n
      character*6 name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      if(name(2:2) .eq. 'S') then
         call kermtr('F012.1',lgfile,mflag,rflag)
      else
         call kermtr('F011.1',lgfile,mflag,rflag)
      endif
      if(mflag) then
         if(lgfile .eq. 0) then
            if(name(3:6) .eq. 'FEQN') then
               write(lout,1002) name, n, idim, k
            else
               write(lout,1001) name, n, idim
            endif
         else
            if(name(3:6) .eq. 'FEQN') then
               write(lgfile,1002) name, n, idim, k
            else
               write(lgfile,1001) name, n, idim
            endif
         endif
      endif
      if(.not. rflag)                                                   &
     &call abend('KERNLIB TMPRNT: '//name//                             &
     &'                            ')
      return
1001  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n).',                                    &
     &5x,'n =', i4, 5x,'idim =', i4,'.')
1002  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n or k.lt.1).',                          &
     &5x,'n =', i4, 5x,'idim =', i4, 5x,'k =', i4,'.')
      end
      subroutine lfitd(x,y,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO FIT A STRAIGHT LINE    Y=A*X+B    TO L POINTS WITH ERROR E
!     SEE MENZEL , FORMULAS OF PHYSICS P.116
!     POINTS WITH Y=0 ARE IGNOERD IF KEY=0
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      implicit none
+if crlibm
+ca crlibco
+ei
      integer j,key,l
      double precision a,b,count,e,scartx,scarty
      double precision sumx,sumxx,sumxy,sumy,sumyy,x,xmed,y,ymed
      dimension x(l),y(l)                                                !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l-2.lt.0) goto 25
      if(l-2.ge.0) goto 1
    1 count=0.0
      sumx=0.0
      sumy=0.0
      sumxy=0.0
      sumxx=0.0
      sumyy=0.0
      do 10 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 10
      sumx=sumx+x(j)
      sumy=sumy+y(j)
      count=count+1.0
   10 continue
      if(count.le.1.) goto 25
      ymed=sumy/count
      xmed=sumx/count
      do 20 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 20
      scartx=x(j)-xmed
      scarty=y(j)-ymed
      sumxy=sumxy+scartx   *scarty
      sumxx=sumxx+scartx   *scartx
      sumyy=sumyy+scarty   *scarty
   20 continue
!
!     FIT PARAMETERS
      if(sumxx.eq.0.) goto 25
      a=sumxy/sumxx
      b=ymed-a*xmed
      if(count.lt.3.) goto 101
      e=(sumyy-sumxy*a          )/(count-2.0)
      goto 100
!
!     ISUFFICIENT POINTS
   25 a=0.0
      b=0.0
  101 e=0.0
  100 return
      end
      subroutine lfitwd(x,y,w,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO PERFORM A WEIGHTED STRAIGHT LINE FIT
!
!     FOR FORMULAE USED SEE MENZEL, FORMULAS OF PHYSICS P.116
!
!     FIT IS OF Y=AX+B , WITH S**2 ESTIMATOR E. WEIGHTS ARE IN W.
!     IF KEY=0, POINTS WITH Y=0 ARE IGNORED
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      implicit none
+if crlibm
+ca crlibco
+ei
      integer icnt,j,key,l
      double precision a,b,e,x,y,w
      double precision w2,w2x,w2x2,w2xy,w2y,w2y2,ww,wwf,wwfi
      dimension x(l),y(l),w(l)                                           !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l.le.1) goto 1
      w2=0.
      w2x=0.
      w2y=0.
      w2xy=0.
      w2x2=0.
      w2y2=0.
      icnt=0
      do 2 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 2
      ww=w(j)**2                                                         !hr07
      w2=ww+w2
      wwf=ww*x(j)
      w2x=wwf+w2x
      w2x2=wwf*x(j)+w2x2
      w2xy=wwf*y(j)+w2xy
      wwfi=ww*y(j)
      w2y=wwfi+w2y
      w2y2=wwfi*y(j)+w2y2
      icnt=icnt+1
    2 continue
!
!     FIT PARAMETERS
      a=(w2xy-(w2x*w2y)/w2)/(w2x2-w2x**2/w2)
      b=(w2y-a*w2x)/w2
      if(icnt.le.2) goto 3
!Eric
      e=((w2y2-w2y**2/w2)-(w2xy-(w2x*w2y)/w2)**2/(w2x2-w2x**2/w2))/     &!hr07
     &dble(icnt-2)
      goto 4
!
!     ISUFFICIENT POINTS
    1 a=0.
      b=0.
    3 e=0.
    4 return
      end
+dk nwrtbnl
!GRDRHIC
!GRD-042008
      subroutine bnlrdis(ngrd)
!
!     SR, 09-08-2005
!     Format for the input file:
!               x, y   -> [ m ]
!               xp, yp -> [ rad ]
!               s      -> [ mm ]
!               DE     -> [ MeV ]
!
      implicit none
+ca parpro
!ERIC
+ca common
+ca crco
+ca crcoall
+ca rhicelens
      integer ngrd
!
!++ Vectors of coordinates
!
      integer i,j
+if crlibm
      integer nchars
      parameter (nchars=160)
      character*(nchars) ch
      character*(nchars+nchars) ch1
      integer errno,l1,l2
      integer dtostr
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character*(maxf) fields(nofields)
!     integer errno,nfields,nunit,nf
      integer nfields,nunit,nf
      double precision fround
+ei
      save
      write(lout,*) "Reading input bunch from beambeamdist.dat"
      mynp=0
!ERIC napx00???
      do j=1,napx
! Now read data using crlibm stuff.
+if fio
+if crlibm
        call enable_xp()
+ei
        read(54,*,end=10,err=20,round='nearest')                        &
     & myx(j),myxp(j),myy(j),myyp(j),mys(j),myp(j)
+if crlibm
        call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(54,*,end=10,err=20) myx(j),myxp(j),myy(j),myyp(j),mys(j),myp(j)
+ei
+if crlibm
        read (54,'(A)',end=10) ch 
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,54,j,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          myx(j)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myxp(j)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myy(j)=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myyp(j)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          mys(j)=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myp(j)=fround(errno,fields,6)
          nf=nf-1
        endif
+ei
+ei
      enddo
      mynp=1
 10   continue
      if(mynp.eq.0) then
        write(lout,*)
        write(lout,*) '!!!!! WARNING !!!!!'
        write(lout,*)'beambeamdist.dat is either missing or too small'
        write(lout,*)
+if cr
        call abend('bnlelens input file error                         ')
+ei      
+if .not.cr
        stop
+ei
      else
        write(lout,*) "Number of samples in the bunch = ",mynp
      endif
!ERIC napx00???
      do j=1,napx
+if crlibm
! Now use my new dtostr for portability
        l1=1
+if boinc
        ch(l1:l1+10)='checkdist '
        l1=l1+10
+ei
! We return the length of the string (always 24)
        errno=dtostr(myx(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myxp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myy(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myyp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(mys(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
+ei
+if .not.boinc
+if crlibm
        write(97,'(a)') ch(1:l1-1)
+ei
+if .not.crlibm
        write(97,'(e15.8,4(1x,e15.8),1x,f15.8)')                        &
     &myx(j),myxp(j),myy(j), myyp(j),mys(j),myp(j)
+ei
        endfile (97,iostat=ierro)
        backspace (97,iostat=ierro)
+ei
+if boinc
        if (.not.restart) then
+if crlibm
          write(10,'(a)') ch(1:l1-1)
+ei
+if .not.crlibm
          write(10,'(a10,e15.8,4(1x,e15.8),1x,f15.8)')                  &
     &'checkdist ',                                                     &
     &myx(j),myxp(j),myy(j), myyp(j),mys(j),myp(j)
+ei
          endfile (10,iostat=ierro)
          backspace (10,iostat=ierro)
          bnlrec=bnlrec+1
        endif
+ei
      enddo
      return
 20   continue
      call abend('I/O Error on Unit 54                              ')
      end
!GRD-042008
!GRDRHIC
+dk checkpt
      subroutine crcheck
!     Thus subroutine checks if the C/R files fort.95 and fort.96 exists,
!     and if so tries to load them into the cr* variables.
!     This routine also repositions the output files for
!     fort.90..91-napx/2 or STF, DUMP, and DYNK (dynksets.dat).
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crstart.
+if datamods
      use bigmats
+ei
!      use, intrinsic :: iso_fortran_env, only : output_unit
      implicit none
+ca crcoall
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc
+if bnlelens
+ca rhicelens
+ei
+ca crco
+ca stringzerotrim
+ca comdynk
+ca comdynkcr
+ca comgetfields
+ca dbdump
+ca dbdumpcr
+ca version
      integer i,j,k,l,m,ia
      integer lstring,hbuff,tbuff,myia,mybinrecs,binrecs94
      dimension hbuff(253),tbuff(35)
      logical lopen

      !For skipping through binary DUMP files (format 3)
      integer tmp_ID, tmp_nturn, tmp_ktrack
      double precision tmp_dcum, tmp_x,tmp_xp,
     &     tmp_y,tmp_yp,tmp_sigma,tmp_dEE

+if boinc
      character*256 filename
+ei
      save
      restart=.false.
      read95=.false.
      read96=.false.
!     Some log entries to fort.93
      write(93,*)                                                       &
     &'SIXTRACR CRCHECK CALLED lout=',lout,'restart',restart,           &
     &'rerun',rerun,'checkp',checkp
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
!--   We are not checkpoint/restart or we have no restart files
      if (.not.checkp) goto 605
      if (.not.fort95.and..not.fort96) goto 605
!--   If we do we must have a fort.6 as they were created by CRPOINT
! NOT TRUE anymore??? We might be NOT rerun but using a Sixin.zip
+if .not.boinc
      if (.not.rerun) then
        write(lout,*)                                                   &
     &'SIXTRACR CRCHECK *** ERROR *** ',                                &
     &'Found fort.95/fort.96 but NO fort.6'
      call abend('SIXTRACR CRCHECK failure                          ')
      endif
+ei
!--   Check at least one restart file is readable
       write(93,*)                                                      &
     &'SIXTRACR CRCHECK checking fort.95/96'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      if (fort95) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 1 VERSION'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        
        rewind 95
        
        read(95,err=100,end=100)
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.95 was written by "//
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."

           endfile(93,iostat=ierro)
           backspace(93,iostat=ierro)

           goto 100
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 2'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        
        read(95,err=100,end=100)                                        &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 3'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        read(95,err=100,end=100)                                        &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 4 BNL'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        read(95,err=100,end=100)                                        &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
     &(crnamepart(j),j=1,crnapxo)
      endif
!GRDRHIC
!GRD-042008
+ei

      write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 5 DUMP'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      read(95,err=100,end=100)
     &     (dumpfilepos_cr(j),j=0,nele)

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 6 DYNK'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         read(95,err=100,end=100)
     &        dynkfilepos_cr,
     &        niexpr_dynk_cr,
     &        nfexpr_dynk_cr,
     &        ncexpr_dynk_cr,
     &        (iexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (fexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (cexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (fsets_dynk_cr(j),j=1,maxsets_dynk)

c$$$         write (93,*) "Contents: (nsets_unique_dynk=",
c$$$     &        nsets_unique_dynk,")"
c$$$         do j=1,nsets_unique_dynk
c$$$            write(93,*) csets_unique_dynk(j,1),csets_unique_dynk(j,2),
c$$$     &                  fsets_dynk_cr(j)
c$$$         enddo
c$$$         write(93,*) "DONE"
c$$$         endfile (93,iostat=ierro)
c$$$         backspace (93,iostat=ierro)
      endif

!ERIC new extended checkpoint for synuthck
      if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.95
! We will re-read them in crstart to be sure they are restored correctly
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 7 extended vars fort.95',      &
     &' crnapxo=',crnapxo
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          read(95,end=100,err=100,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (95,iostat=ierro)
          write(93,*) 'CRCHECK read fort.95 EXTENDED OK'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK leaving fort.95 for CRSTART EXTENDED'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        endif
        read95=.true.
        goto 103
      endif
  100 if (.not.read95) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 95'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
      endif
      if (fort96) then
        write(93,*) 'CRCHECK trying fort.96 instead'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        
        rewind 96

        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 1 VERSION'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)

        read(96,err=101,end=101)
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.96 was written by "//
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."
           
           endfile(93,iostat=ierro)
           backspace(93,iostat=ierro)
           
           goto 101
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 2'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        read(96,err=101,end=101,iostat=ierro)                           &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 3'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
      read(96,err=101,end=101,iostat=ierro)                             &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 4 BNL'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        read(96,err=101,end=101)                                        &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
     &(crnamepart(j),j=1,crnapxo)
      endif
!GRDRHIC
!GRD-042008
+ei

      write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 5 DUMP'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      read(96,err=100,end=100)
     &     (dumpfilepos_cr(j),j=0,nele)

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 6 DYNK'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         read(96,err=101,end=101)
     &        dynkfilepos_cr,
     &        niexpr_dynk_cr,
     &        nfexpr_dynk_cr,
     &        ncexpr_dynk_cr,
     &        (iexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (fexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (cexpr_dynk_cr(j),j=1,maxdata_dynk),
     &        (fsets_dynk_cr(j),j=1,maxsets_dynk)

c$$$         write (93,*) "Contents: (nsets_unique_dynk=",
c$$$     &        nsets_unique_dynk,")"
c$$$         do j=1,nsets_unique_dynk
c$$$            write(93,*) csets_unique_dynk(j,1),csets_unique_dynk(j,2),
c$$$     &                  fsets_dynk_cr(j)
c$$$         enddo
c$$$         write(93,*) "DONE"
c$$$         endfile (93,iostat=ierro)
c$$$         backspace (93,iostat=ierro)
      endif


!ERIC new extended checkpoint for synuthck
        if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.96
! We will re-read them in crstart to be sure they are correct
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 6 extended vars fort.96,',     &
     &' crnapxo=',crnapxo
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          write(93,*) 'CRCHECK verifying extended vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          read(96,end=101,err=101,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (96,iostat=ierro)
          write(93,*) 'SIXTRACR CRCHECK read fort.96 EXTENDED OK'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK, leaving fort.96 for CRSTART EXTENDED'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        endif
        read96=.true.
        goto 103
      endif
  101 if (.not.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 96'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
      endif
  103 continue
      
+if debug
+if bnlelens
!     write(99,*) 'crcheck ',
!    &crbnlrec,                                                         &
!    &crbllrec,                                                         &
!    &crn_cut,                                                          &
!    &crn_nocut,                                                        &
!    &crsumsquarex,                                                     &
!    &crsumsquarey,                                                     &
!    &crsumtwojx,                                                       &
!    &crsumtwojy,                                                       &
!    &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
!    &crtotals,                                                         &
!    &(crnamepart(j),j=1,crnapxo)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
+ei
!--   If we have successfully read either fort.95 or fort.96
!--   we need to handle lost particles and ntwin .ne. 2
!--   Otherwise we just continue with checkpointing as requested
      if (read95.or.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK read95',read95,'read96',read96,                 &
     &'crnapxo',crnapxo,'crbinrec',crbinrec,'napx',napx,                &
     &'sixrecs',sixrecs,'crsixrecs',crsixrecs,'crbnlrec',crbnlrec,      &
     &'crbllrec',crbllrec
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK crbinrecs ',                                    &
     &(crbinrecs(j),j=1,(crnapxo+1)/2)
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
!--   First we position fort.6 to last checkpoint
  603   read(6,'(a1024)',end=604,err=106,iostat=ierro) arecord
        sixrecs=sixrecs+1
        if (sixrecs.lt.crsixrecs) goto 603
        endfile (6,iostat=ierro)
  604   backspace (6,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK found fort.6 sixrecs=',sixrecs
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
!--   Now re-position beambeam-output.dat and lostID.dat
!--   or only fort.10 if boinc
+if .not.boinc
  610     read(52,'(a1024)',end=608,err=108,iostat=ierro) arecord
          bnlrec=bnlrec+1
          if (bnlrec.lt.crbnlrec) goto 610
          endfile (52,iostat=ierro)
  608     backspace (52,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.52 bnlrec=',bnlrec
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
  611     read(53,'(a1024)',end=609,err=109,iostat=ierro) arecord
          bllrec=bllrec+1
          if (bllrec.lt.crbllrec) goto 611
          endfile (53,iostat=ierro)
  609     backspace (53,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.53 bllrec=',bllrec
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+ei
+if boinc
  610     read(10,'(a1024)',end=608,err=108,iostat=ierro) arecord
          bnlrec=bnlrec+1
          if (bnlrec.lt.crbnlrec) goto 610
          endfile (10,iostat=ierro)
  608     backspace (10,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.10 bnlrec=',bnlrec
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+ei
        endif
!GRDRHIC
!GRD-042008
+ei
!--   We may be re-running with a DIFFERENT number of turns (numl)
! Eric fix this later by reading numl for fort.90
        if (numl.ne.crnuml) then
          if (numl.lt.crnumlcr) then
            write(lout,*)                                               &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            write(93,*)                                                 &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK numl .lt. crnumlcr               ')
          endif
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-sets numl in binary file headers from ',     &
     &crnuml,' to ',numl
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)

!--   Reposition binary files fort.90 etc. / singletrackfile.dat
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.ne.9) then
!GRDRHIC
!GRD-042008
+ei
          ! fort.94 = temp file where the data from fort.90 etc. is copied to and then back
+if boinc
          call boincrf('fort.94',filename)
          open(94,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
          open(94,file='fort.94',form='unformatted',status='unknown')
+ei
+if .not.stf
          do 13 ia=1,crnapxo/2,1
            ! First, copy crbinrecs(ia) records of data from fort.91-ia to fort.94
            mybinrecs=0
            binrecs94=0
            myia=91-ia
            !Copy header
            read(91-ia,err=105,end=105,iostat=ierro) hbuff
            mybinrecs=mybinrecs+1
            hbuff(51)=numl ! Reset the number of turns (not very elegant)
            write(94,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data
            do 14 j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(91-ia,err=105,end=105,iostat=ierro)                &
     &(tbuff(k),k=1,17)
                write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(91-ia,err=105,end=105,iostat=ierro) tbuff
                write(94,err=105,iostat=ierro) tbuff
              endif
              mybinrecs=mybinrecs+1
 14         continue
            
            ! Second, copy crbinrecs(ia) records of data from fort.94 to fort.91-ia
            rewind 94
            rewind 91-ia
            !Copy header
            read(94,err=105,end=105,iostat=ierro) hbuff
            binrecs94=binrecs94+1
            write(91-ia,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data
            do 15 j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(94,err=105,end=105,iostat=ierro)                   &
     &(tbuff(k),k=1,17)
                write(91-ia,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(94,err=105,end=105,iostat=ierro) tbuff
                write(91-ia,err=105,iostat=ierro) tbuff
              endif
              binrecs94=binrecs94+1
   15       continue
   17       endfile (91-ia,iostat=ierro)
            backspace (91-ia,iostat=ierro)
            rewind 94
   13     continue ! END "do 13 ia=1,crnapxo/2,1"
+ei ! END +if .not.stf
+if stf
          ! First, copy crbinrecs(ia)*(crnapx/2) records of data from singletrackfile.dat to fort.94
          mybinrecs=0
          !Copy headers
          do ia=1,crnapxo/2,1
             read(90,err=105,end=105,iostat=ierro) hbuff
             mybinrecs=mybinrecs+1
             hbuff(51)=numl ! Reset the number of turns (not very elegant)
             write(94,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(90,err=105,end=105,iostat=ierro)
     &                  (tbuff(k),k=1,17)
                   write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(90,err=105,end=105,iostat=ierro) tbuff
                   write(94,err=105,iostat=ierro) tbuff
                endif
                mybinrecs=mybinrecs+1
             end do
          end do
          
          ! Second, copy crbinrecs(ia)*(crnapx/2) records of data from fort.94 to singletrackfile.dat
          rewind 94
          rewind 90
          binrecs94=0
          ! Copy header
          do ia=1,crnapxo/2,1
             read(94,err=105,end=105,iostat=ierro) hbuff
             binrecs94=binrecs94+1
             write(90,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(94,err=105,end=105,iostat=ierro)
     &                  (tbuff(k),k=1,17)
                   write(90,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(94,err=105,end=105,iostat=ierro) tbuff
                   write(90,err=105,iostat=ierro) tbuff
                endif
                binrecs94=binrecs94+1
             enddo
          end do
          endfile   (90,iostat=ierro)
          backspace (90,iostat=ierro)
+ei ! END +if stf
          close(94)
+if bnlelens
!GRDRHIC
!GRD-042008
          endif ! END "if (lhc.ne.9) then"
!GRDRHIC
!GRD-042008
+ei
        else !ELSE for "if(nnuml.ne.crnuml) then" -> here we treat nnuml.eq.crnuml, i.e. the number of turns have not been changed
!--  Now with the new array crbinrecs we can ignore files which are
!--  basically finished because a particle has been lost.......
!--  Just check crbinrecs against crbinrec
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.ne.9) then
!GRDRHIC
!GRD-042008
+ei
+if .not.stf
          ! Binary files have been rewritten; now re-position
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-positioning binary files'
          do 10 ia=1,crnapxo/2,1
            myia=91-ia
            if (crbinrecs(ia).ge.crbinrec) then
              mybinrecs=0
              read(91-ia,err=102,end=102,iostat=ierro) hbuff
              do 11 j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                  read(91-ia,err=102,end=102,iostat=ierro)              &
     &(tbuff(k),k=1,17)
                else
                  read(91-ia,err=102,end=102,iostat=ierro) tbuff
                endif
              mybinrecs=mybinrecs+1
   11         continue
              endfile (91-ia,iostat=ierro)
              backspace (91-ia,iostat=ierro)
             else ! Number of ecords written to this file < general number of records written
                  ! => Particle has been lost before last CP, no need to reposition.
              write(93,*)                                               &
     &'SIXTRACR CRCHECK ignoring IA ',ia,' Unit ',myia
            endif
   10     continue
+ei ! END +if .not.stf
+if stf
      mybinrecs=0
      ! Reposition headers
      do ia=1,crnapxo/2,1
         read(90,err=102,end=102,iostat=ierro) hbuff
         mybinrecs=mybinrecs+1
      end do
      !Reposition track records
      do ia=1,crnapxo/2,1
         do j=2,crbinrecs(ia)
            if(ntwin.ne.2) then !ntwin=1
               read(90,err=102,end=102,iostat=ierro)
     &              (tbuff(k),k=1,17)
            else                !ntwin=2
               read(90,err=102,end=102,iostat=ierro) tbuff
            endif
            mybinrecs=mybinrecs+1
         end do
      enddo
+ei ! END +if stf
      endif ! END "if (numl.ne.crnuml) then" and END else
+if bnlelens
!GRDRHIC
!GRD-042008
          endif
        if (lhc.eq.9) then
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK skipping binary files for bnlelens'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        endif
!GRDRHIC
!GRD-042008
+ei
      
      !reposition dynksets.dat
      if (ldynk .and.(.not.ldynkfiledisable) ) then
         write(93,*)
     &"SIXTRACR CRCHECK REPOSITIONING dynksets.dat"
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         
         inquire( unit=665, opened=lopen )
         if (lopen) then
            write(93,*)
     &"SIXTRACR CRCHECK FAILED while repositioning dynksets.dat"
            write(93,*)
     &"Unit 665 already in use!"
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)

            call abend
     &('SIXTRACR CRCHECK failure positioning dynksets.dat ')
         end if

         open(unit=665,file='dynksets.dat',status="old",
     &        action="readwrite", err=110)
         dynkfilepos = 0 ! Start counting lines at 0, not -1
         
 701     read(665,'(a1024)',end=110,err=110,iostat=ierro) arecord
         dynkfilepos=dynkfilepos+1
         if (dynkfilepos.lt.dynkfilepos_cr) goto 701

         endfile (665,iostat=ierro)
!         backspace (665,iostat=ierro)
         close(665)
         open(unit=665, file="dynksets.dat", status="old",
     &        position='append', action="write")
         
         write(93,*)                                                     &
     &'SIXTRACR CRCHECK sucessfully repositioned dynksets.dat, '//
     &'dynkfilepos=',dynkfilepos
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
      endif
      
      !Reposition files for DUMP
      write(93,*) "SIXTRACR CRCHECK REPOSITIONING DUMP files"
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do i=0, il
         if (ldump(i)) then
            write(93,*) "SIXTRACR CRCHECK REPOSITIONING DUMP file"
            if (i .ne. 0) then
               write(93,*) "element=",bez(i), "unit=",dumpunit(i),
     &              " filename=",dump_fname(i), "format=",dumpfmt(i)
            else
               write(93,*) "element=","ALL" , "unit=",dumpunit(i),
     &              " filename=",dump_fname(i), "format=",dumpfmt(i)
            endif
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            
            inquire( unit=dumpunit(i), opened=lopen )
            if (dumpfmt(i) .ne. 3 ) then ! ASCII
               if ( .not. lopen ) then
                  open(dumpunit(i),file=dump_fname(i), status='old',
     &                 form='formatted',action='readwrite')
               endif

               dumpfilepos(i) = 0
 702           read(dumpunit(i),'(a1024)',end=111,err=111,iostat=ierro)
     &              arecord
               dumpfilepos(i) = dumpfilepos(i) + 1
               if (dumpfilepos(i).lt.dumpfilepos_cr(i)) goto 702

            else                         ! BINARY (format = 3)
               if ( .not. lopen ) then
                  open(dumpunit(i),file=dump_fname(i),status='old',
     &                 form='unformatted',action='readwrite')
               endif
               dumpfilepos(i) = 0
 703           read(dumpunit(i),end=111,err=111,iostat=ierro)
     &              tmp_ID,tmp_nturn,tmp_dcum,
     &              tmp_x,tmp_xp,tmp_y,tmp_yp,tmp_sigma,tmp_dEE,
     &              tmp_ktrack
               dumpfilepos(i) = dumpfilepos(i) + 1
               if (dumpfilepos(i).lt.dumpfilepos_cr(i)) goto 703
            endif

         endif
      end do
      !Crop DUMP files (if used by multiple DUMPs,
      ! the actual position is the sum of the dumpfileposes
      do i=0, il
         if (ldump(i)) then
            endfile (dumpunit(i),iostat=ierro)
C            backspace (dumpunit(i),iostat=ierro)
            ! Change from 'readwrite' to 'write'
            close(dumpunit(i))
            if (dumpfmt(i).ne.3) then ! ASCII
               open(dumpunit(i),file=dump_fname(i), status='old',
     &             position='append', form='formatted',action='write')
            else                      ! Binary (format = 3)
               open(dumpunit(i),file=dump_fname(i), status='old',
     &             position='append', form='unformatted',action='write')
            endif
         endif
      end do
      
!--     Set up flag for tracking routines to call CRSTART
        restart=.true.
        write(lout,'(a80)')                                                   &
     &runtim
        endfile (lout,iostat=ierro)
        backspace (lout,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK restart=TRUE',' crnumlcr=',crnumlcr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        return
      endif
      goto 605
!--   Just abort if we cannot re-position/copy the binary files,
+if .not.stf
  102 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING fort.',      &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      call abend('SIXTRACR CRCHECK failure positioning binary files ')
+ei
+if stf
  102 write(lout,*)
      write(lout,*)
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING ',
     &'singletrackfile.dat for ia=',ia,' IOSTAT=',ierro
      write(lout,*)
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      call abend('SIXTRACR CRCHECK failure positioning binary files ')
+ei
+if .not.stf
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING fort.',         &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      call abend('SIXTRACR CRCHECK failure copying binary files     ')
+ei ! END +if .not.stf
+if stf
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING particle pair', &
     &ia,' IOSTAT=',ierro, ' from/to singletrackfile.dat'
      write(lout,*)                                                     &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      call abend('SIXTRACR CRCHECK failure copying binary files     ')
+ei ! END +if stf
!--  We are not checkpointing or we have no checkpoints
!--  or we have no readable checkpoint
!--  If not checkpointing we can just give up on lout and use
!--  fort.6. We don't need to count records at all
  605 write(93,*)                                                       &
     &'SIXTRACR CRCHECK no restart possible checkp=',checkp
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      if (.not.checkp) then
        if (rerun) then
!--   we nevertheless have an existing fort.6
!--   we will just overwrite it for now and delete
!--   92 to avoid abend copying it again
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK overwriting fort.6'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
        endif
!--   and just use fort.6 from now on
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK giving up on LOUT'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
!--   Copy the lout to fort.6 (the file, not output_unit)
!     It seems that FORTRAN will open the file automatically?
!     There are no open(unit=6) etc. calls anywhere...
        rewind lout
    3   read(lout,'(a1024)',end=1,err=107,iostat=ierro) arecord
        lstring=1024
        do i=1024,2,-1
          lstring=i
          if (arecord(i:i).ne.' ')goto 2
          lstring=lstring-1
        enddo
    2   write(6,'(a)') arecord(1:lstring)
        goto 3
    1   endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        lout=6
      endif
      return
 106  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.6, iostat=',ierro
      write(93,*)                                                       &
     &'sixrecs=',sixrecs,' crsixrecs=',crsixrecs
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning fort.6       ')
 107  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.92, iostat=',ierro
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning fort.92      ')
+if bnlelens
!GRDRHIC
!GRD-042008
 108  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.52, iostat=',ierro
      write(93,*)                                                       &
     &'bnlrec=',bnlrec,' crbnlrec=',crbnlrec
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning fort.52      ')
 109  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.53, iostat=',ierro
      write(93,*)                                                       &
     &'bllrec=',bllrec,' crbllrec=',crbllrec
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning fort.53      ')
!GRDRHIC
!GRD-042008
+ei
 110  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR ***'//
     &' reading dynksets.dat, iostat=',ierro
      write(93,*)                                                       &
     &'dynkfilepos=',dynkfilepos,' dynkfilepos_cr=',dynkfilepos_cr
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning dynksets.dat ')

 111  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR ***'//
     &' reading DUMP file#', dumpunit(i),' iostat=',ierro
      write(93,*)                                                       &
     &'dumpfilepos=',dumpfilepos(i),' dumpfilepos_cr=',dumpfilepos_cr(i)
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CRCHECK failure positioning DUMP file    ')


      end

      subroutine crpoint
!     This subroutine writes the checkpoint data to fort.95/96,
!     and copies the new output from the temporary (lout/fort.92) output file into fort.6.
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutine crcheck and crstart.
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei
      implicit none
+ca crcoall
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc
+ca stringzerotrim
+ca comdynk
+ca comdynkcr
      double precision dynk_getvalue
+ca dbdumpcr
+if bnlelens
+ca rhicelens
+ei
+ca version
+ca crco
      integer i,j,l,k,m
      integer lstring,osixrecs,ncalls
+if boinc
      character*256 filename
+ei
      data ncalls /0/
      save
!     call system('echo "CPSTART `date`" >> crtimes')
+if .not.debug
      if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED numlmax=',numlmax,' numlcp=',numlcp
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED lout=',lout,' numx=',numx,'numl',numl
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED binrec/sixrec ',binrec,sixrecs
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      ncalls=ncalls+1
      if (restart) then
        restart=.false.
        return
      endif
!--   We need to copy fort.92 (lout) to fort.6 (sixrecs)
!--   (if it exists and we are not already using fort.6)
+if debug
                   !call system('../crpoint >> crlog')
+ei
      osixrecs=sixrecs
      rewind lout
    3 read(lout,'(a1024)',end=1,err=101,iostat=ierro) arecord
      lstring=1024
      do i=1024,2,-1
        lstring=i
        if (arecord(i:i).ne.' ') goto 2
        lstring=lstring-1
      enddo
    2 write(6,'(a)',err=102,iostat=ierro) arecord(1:lstring)
      sixrecs=sixrecs+1
      goto 3
    1 if (sixrecs.ne.osixrecs) then
        endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
+if debug
                   !call system('../crpoint >> crlog')
+ei
+if boinc
        call boincrf('fort.92',filename)
        open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
        open(lout,file='fort.92',form='formatted',status='unknown')
+ei
+if .not.debug
        if (ncalls.le.5.or.numx.ge.numl) then
+ei
          write(93,*)                                                   &
     &'SIXTRACR CRPOINT copied lout=',lout,'sixrecs=',sixrecs
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      else
        rewind lout
      endif
      call timex(time3)
! Hope this is correct
! Maybe not!!!! this should be accumulative over multiple C/Rs
      time3=(time3-time1)+crtime3
      crnumlcr=numx+1

      if (ldynk) then ! Store current settings of elements affected by DYNK
+if .not.debug
         if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT filling fsets_dynk_cr'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
         endif
+ei
         do j=1,nsets_unique_dynk
            fsets_dynk_cr(j) =
     &           dynk_getvalue(csets_unique_dynk(j,1),
     &                         csets_unique_dynk(j,2))
         end do

c$$$         write (93,*) "Contents: (nsets_unique_dynk=",
c$$$     &        nsets_unique_dynk,")"
c$$$         do j=1,nsets_unique_dynk
c$$$            write(93,*) csets_unique_dynk(j,1),csets_unique_dynk(j,2),
c$$$     &                  fsets_dynk_cr(j)
c$$$         enddo
c$$$         write(93,*) "DONE"
c$$$         endfile (93,iostat=ierro)
c$$$         backspace (93,iostat=ierro)
      end if

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
        write(93,*) 'SIXTRACR CRPOINT writing fort.95'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      rewind 95
      write(95,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(95,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(95,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (95,iostat=ierro)
      backspace (95,iostat=ierro)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing BNL vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        write(95,err=100,iostat=ierro)                                  &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napxo)
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif
!GRDRHIC
!GRD-042008
+ei

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.95'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      write(95,err=100,iostat=ierro)                                    &
     &     (dumpfilepos(j),j=0,nele)
      
      if (ldynk) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        !TODO: One could probably be more efficient when saving
        write(95,err=100,iostat=ierro)                                  &
     &dynkfilepos,
     &niexpr_dynk,
     &nfexpr_dynk,
     &ncexpr_dynk,
     &(iexpr_dynk(j),j=1,maxdata_dynk),
     &(fexpr_dynk(j),j=1,maxdata_dynk),
     &(cexpr_dynk(j),j=1,maxdata_dynk),
     &(fsets_dynk_cr(j),j=1,maxsets_dynk)
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif

      if (sythckcr) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
!ERIC new extended checkpoint for synuthck
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
+if .not.datamods
        write(95,err=100,iostat=ierro)                                  &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
        if(ithick.eq.1) then
+if .not.debug
          if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//
     & ' for DATAMODS to fort.95'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
          endif
+ei
          write(95,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile (95,iostat=ierro)
          backspace (95,iostat=ierro)
        endif
        
        write(95,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif

+if bnlelens
+if debug
!     if (numx.ge.990) then
!     write(99,*) 'Checkpointed bnl numx ',numx
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napxo)
!     write(99,*) 'crpoint xv,yv j=1 ',xv(1,1),xv(2,1),yv(1,1),yv(2,1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
!--   and finally a second checkpoint copy, or maybe not!
!--   Well, a second copy is indeed required as shown by testing
+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
        write(93,*) 'SIXTRACR CRPOINT writing fort.96'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      rewind 96
      write(96,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(96,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(96,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing Record 3 BNL fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        write(96,err=100,iostat=ierro)                                  &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napxo)
        endfile (96,iostat=ierro)
        backspace (96,iostat=ierro)
      endif
!GRDRHIC
!GRD-042008
+ei

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.96'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      write(96,err=100,iostat=ierro)                                    &
     &     (dumpfilepos(j),j=0,nele)

      if (ldynk) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        !TODO: One could probably be more efficient when saving
        write(96,err=100,iostat=ierro)                                  &
     &dynkfilepos,
     &niexpr_dynk,
     &nfexpr_dynk,
     &ncexpr_dynk,
     &(iexpr_dynk(j),j=1,maxdata_dynk),
     &(fexpr_dynk(j),j=1,maxdata_dynk),
     &(cexpr_dynk(j),j=1,maxdata_dynk),
     &(fsets_dynk_cr(j),j=1,maxsets_dynk)
        endfile (96,iostat=ierro)
        backspace (96,iostat=ierro)
      endif

      if (sythckcr) then
!ERIC new extended checkpoint for synuthck
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
+if .not.datamods
        write(96,err=100,iostat=ierro)                                  &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
        if (ithick.eq.1) then
+if .not.debug
          if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//
     & ' for DATAMODS to fort.96'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
          endif
+ei
          write(96,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile   (96,iostat=ierro)
          backspace (96,iostat=ierro)
        endif
        
        write(96,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
      endif
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)
+if debug
                   !call system('../crpoint >> crlog')
+ei
+if debug
!ERIC
!     call dump('1st Checkpoint',numx,i)
!     call abend('SIXTRACR CHECKPOINT written                       ')
+ei
!     call system('echo "CPEND   `date`" >> crtimes')
  104 return
  100 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing checkpt file,iostat=',    &
     &ierro
      goto 103
  101 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** reading lout fort.92,iostat=',    &
     &ierro
      goto 103
  102 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing fort.6,iostat=',          &
     &ierro
  103 endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      call abend('SIXTRACR CHECKPOINT I/O Error                     ')
      end
      subroutine crstart
!     If we are restarting (restart is TRUE), this routine is called
!     in the beginning of the tracking loops.
!     It is used to copy the cr* variables to the normal variables,
!     e.g. crnapx -> napx etc.
!
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crcheck.
+if datamods
      use bigmats
+ei
      implicit none
+ca crcoall
+ca parpro
+ca parnum
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc
+if bnlelens
+ca rhicelens
+ei
+ca crco
+ca stringzerotrim
+ca comdynk
+ca comdynkcr
      double precision dynk_newValue

      integer j,l,k,m,i
      character*256 filename
      save
      write(93,*)                                                       &
     &'SIXTRACR CRSTART called crnumlcr',crnumlcr
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      numlcr=crnumlcr
!--   We do NOT reset numl so that a run can be extended for
!--   for more turns from the last checkpoint
!--   but we need to worry about numxv, nnumxv
      binrec=crbinrec
      bnlrec=crbnlrec
      bllrec=crbllrec
      sythckcr=crsythck
! the crtime3 is required (crtime0/1 removed)
      napxo=crnapxo
      napx=crnapx
      e0=cre0
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      write(93,*) 'CRSTART doing binrecs'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,(napxo+1)/2
        binrecs(j)=crbinrecs(j)
      enddo
      write(93,*) 'CRSTART doing normal NPART vars'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,napxo
        numxv(j)=crnumxv(j)
        nnumxv(j)=crnnumxv(j)
        nlostp(j)=crnlostp(j)
        pstop(j)=crpstop(j)
        xv(1,j)=crxv(1,j)
        yv(1,j)=cryv(1,j)
        xv(2,j)=crxv(2,j)
        yv(2,j)=cryv(2,j)
        sigmv(j)=crsigmv(j)
        dpsv(j)=crdpsv(j)
        dpsv1(j)=crdpsv1(j)
! TEMPORARY? fix for crabamp/multipole problem
!       oidpsv(j)=croidpsv(j)
        oidpsv(j)=one/(one+dpsv(j))
        ejv(j)=crejv(j)
        ejfv(j)=crejfv(j)
        rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        aperv(j,1)=craperv(j,1)
        aperv(j,2)=craperv(j,2)
        xvl(1,j)=crxvl(1,j)
        xvl(2,j)=crxvl(2,j)
        yvl(1,j)=cryvl(1,j)
        yvl(2,j)=cryvl(2,j)
        dpsvl(j)=crdpsvl(j)
        ejvl(j)=crejvl(j)
        sigmvl(j)=crsigmvl(j)
        if (.not.pstop(j)) then
          numxv(j)=numl
          nnumxv(j)=numl
        endif
+if bnlelens
!GRDRHIC
!GRD-042008
        namepart(j)=crnamepart(j)
!GRDRHIC
!GRD-042008
+ei
      enddo
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'CRSTART doing BNL vars'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        n_cut=crn_cut
        n_nocut=crn_nocut
        sumsquarex=crsumsquarex
        sumsquarey=crsumsquarey
        sumtwojx=crsumtwojx
        sumtwojy=crsumtwojy
        limit_twojx=crlimit_twojx
        limit_twojy=crlimit_twojy
        limit_twojr=crlimit_twojr
        totals=crtotals
      endif
!GRDRHIC
!GRD-042008
+ei
+if debug
+if bnlelens
!     write(99,*) 'CRSTART bnl numlcr ',numlcr
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napxo)
!     write(99,*) 'crstart xv,yv j=1 ',xv(1,1),xv(2,1),yv(1,1),yv(2,1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
+ei
!ERIC new extended checkpoint for synuthck
      
      if (ldynk) then
         !LOAD DYNK DATA from temp arrays (loaded from file in crcheck)
         niexpr_dynk = niexpr_dynk_cr
         nfexpr_dynk = nfexpr_dynk_cr
         ncexpr_dynk = ncexpr_dynk_cr
         do j=1,maxdata_dynk
            iexpr_dynk(j) = iexpr_dynk_cr(j)
            fexpr_dynk(j) = fexpr_dynk_cr(j)
            cexpr_dynk(j) = cexpr_dynk_cr(j)
         enddo

c$$$         write (93,*) "Contents: (nsets_unique_dynk=",
c$$$     &        nsets_unique_dynk,")"
c$$$         do j=1,nsets_unique_dynk
c$$$            write(93,*) csets_unique_dynk(j,1),csets_unique_dynk(j,2),
c$$$     &                  fsets_dynk_cr(j)
c$$$         enddo
c$$$         write(93,*) "DONE"
c$$$         endfile (93,iostat=ierro)
c$$$         backspace (93,iostat=ierro)
         
         ! Load current settings from fsets_dynk_cr into the elements affected by DYNK.
         do j=1,nsets_unique_dynk
            !It is OK to write to lout from here
            call dynk_setvalue( csets_unique_dynk(j,1),
     &                          csets_unique_dynk(j,2),
     &                          fsets_dynk_cr(j)        )
         enddo
      endif

      if (crsythck) then
!ERICVARS now read the extended vars from fort.95/96.
        if (cril.ne.il) then
          write(lout,*)                                                 &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          write(93,*)                                                   &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
      call abend('SIXTRACR CRSTART Problem wih cril/il extended C/R ')
        endif
!ERICVARS now read the extended vars from fort.95/96.
+if debug
! Commented out code for multiple records
!       write(93,*) 'CRSTART DEBUG DUMP'
!       call dump('Before xcrstart',0,0)
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       write(93,*) 'CRSTART reading EXTENDED vars'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       if (read95) then
!         i=1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(aek(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(afok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as4(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as6(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(co(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpd(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpsq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fokqv(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(g(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(gl(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hm(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hp(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hs(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rho(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(si(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(siq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm12(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm2(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm23(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wf(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfa(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfhi(j),j=1,napxo)
!         go to 102
!       endif
+ei
        if (read95) then
+if .not.datamods
          read(95,end=100,err=100,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if .not.datamods
          if (ithick.eq.1) then
            read(95,end=100,err=100,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          
          read(95,end=100,err=100,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
          write(93,*) 'CRSTART read fort.95 EXTENDED OK'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          go to 102
        endif
        if (read96) then
+if .not.datamods
          read(96,end=101,err=101,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
          if (ithick.eq.1) then
            read(96,end=101,err=101,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          read(96,end=101,err=101,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
      write(93,*) 'CRSTART read fort.96 EXTENDED OK'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
          go to 102
        endif
  100   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 95 (extended)',  &
     &' iostat=',ierro
+if debug
! Multiple record debug code commented out
!       write(93,*) 'CRSTART This was the ith READ, I=',i
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
        go to 103
  101   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 96 (extended)',  &
     &' iostat=',ierro
  103   endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
      call abend('SIXTRACR CRSTART Problem with extended checkpoint ')
      endif
  102 write(93,*)                                                       &
     &'SIXTRACR CRSTART six/crsix/bin recs',sixrecs,crsixrecs,binrec
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+if debug
                   !call system('../crstart >> crlog')
+ei
!--   Just throw away our fort.92 stuff.
      rewind lout
      endfile (lout,iostat=ierro)
      close(lout)
+if debug
                   !call system('../crstart >> crlog')
+ei
+if boinc
      call boincrf('fort.92',filename)
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
! but also add the rerun message
      write(lout,'(a80)')                                                     &
     &runtim
      runtim(1:20)='SIXTRACR restarted: '
      write(lout,'(a80)')                                                     &
     &runtim
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
+if debug
                   !call system('../crstart >> crlog')
+ei
      return
  606 backspace (6,iostat=ierro)
      write(lout,*)                                                     &
     &' SIXTRACR CRSTART Problem re-positioning fort.6: sixrecs',       &
     &sixrecs,'crsixrecs',crsixrecs
      call abend('SIXTRACR CRSTART Problem fort.6                   ')
      end
+dk aux
!      logical function isnan(arg1,arg2)
      logical function myisnan(arg1,arg2)
      implicit none
+if crlibm
+ca crlibco
+ei
      double precision arg1,arg2
!      isnan=.false.
!      if(arg1.ne.arg2) isnan=.true.
      myisnan=.false.
      if(arg1.ne.arg2) myisnan=.true.
      end
      subroutine datime(nd,nt)
      implicit none
! Fill common slate for usage by hmachi call as per z007 writeup.        !hr08
      common /slate/ isl(40)                                             !hr08

      integer isl                                                        !hr08
!
!-    call datime (nd,nt)   returns integer date   nd = yymmdd
!-                                  integer time   nt =   hhmm
!     integer nd,nt,mm(3),nn(3)
!     call idate (mm(1),mm(2),mm(3))
!     call itime (nn)
      character*8 date
      character*10 time
      character*5 zone
      integer values(8),mm(3),nd,nt
      save
      call date_and_time(date,time,zone,values)
      mm(3)=mod(values(1),100)
!     mm(3) = mod (mm(3),100)
      mm(2)=values(3)
      mm(1)=values(2)
      isl(1)= mm(3)                                                      !hr08
      isl(2)= mm(2)                                                      !hr08
      isl(3)= mm(1)                                                      !hr08
      isl(4)= values(5)                                                  !hr08
      isl(5)= values(6)                                                  !hr08
      isl(6)= 0                                                          !hr08
      nd = (mm(3)*100+mm(1))*100 + mm(2)
!     nt =            nn(1) *100 + nn(2)
      nt=values(5)*100+values(6)
      return
      end
      subroutine timest(r1)
      implicit none
+ca commtim
      logical start
      data start /.false./
      save
      if (.not.start) then
        start=.true.
        call cpu_time(timestart)
      endif
      return
      end
      subroutine timex(r1)
      implicit none
+ca commtim
      save
      call timest(0.0)
      call cpu_time(timenow)
      r1=timenow-timestart
      return
      end
      subroutine abend(cstring)
      implicit none
+ca parpro
+ca parnum
+ca common
+ca crcoall
+ca commonxz
+ca crco
+ca version
      integer i,lstring,j
      character*(*) cstring
      character*256 filename
      double precision sumda(60)
      logical fopen
      character*8192 ch
      character*25 ch1
      integer errno,l1,l2
      integer dtostr
      integer ich
      save
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND called and closing files'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
! Calling close to be very safe.......96 calls to abend
! Easier than adding the call on every abend
      call closeUnits
! If fort.10 is inexistent (physics error or some other problem)
! we try and write a 0d0 file with a turn number and CPU time
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND checking fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if nagfor
+if boinc
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',err=11,   &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',err=11,  &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei

+if .not.nagfor
+if boinc
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',err=11,   &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown',err=11)
+ei
+ei
+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',err=11,  &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown',err=11)
+ei
+ei
+ei

! Now we try and read fort.10 i.e. is it empty?
      read(10,'(a1024)',end=11,err=11,iostat=ierro) arecord
! Seems to be OK
      goto 12    
 11   continue
! Now we try and write a fort.10
! We put some CPU for Igor, a version, and turn number 0
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND writing a fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
!     the version
      itot=0
      ttot=0
      do i=1,8
        if (version(i:i).ne.' ') then
          if (version(i:i).ne.'.') then
            itot=itot*10+ichar(version(i:i))-ichar('0')
          else
            ttot=ttot*10**2+itot
            itot=0
          endif
        endif
      enddo
      ttot=ttot*10**2+itot
      do i=1,60
        sumda(i)=0d0
      enddo
      sumda(52)=dble(ttot)
!     the CPU
      call timex(time1)
      trtime=time1-time0
+if cr
      trtime=trtime+crtime3  
+ei
      sumda(60)=dble(trtime)
! Note it COULD happen that napxo is 0 for a very very early error
! and even napx!!!
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      write(93,*)                                                       &
     &'SIXTRACR STOP/ABEND writing fort.10, lines',napxo,'/',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      if (napxo.eq.0) napxo=napx
      do j=1,napxo
+if .not.crlibm
        write(ch,*,iostat=ierro) (sumda(i),i=1,60)
        do ich=8192,1,-1
          if(ch(ich:ich).ne.' ') goto 707
        enddo
 707    write(10,'(a)',iostat=ierro) ch(:ich)
+ei
+if crlibm
! Now use my new dtostr for portability
        l1=1
        do i=1,60
! We return the length of the string (always 24)
          errno=dtostr(sumda(i),ch1)
          ch(l1:l1+errno)=' '//ch1(1:errno)
          l1=l1+errno+1
        enddo        
        write(10,'(a)',iostat=ierro) ch(1:l1-1)
+ei
        if(ierro.ne.0) then
          write(lout,*)
          write(lout,*)                                                 &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE 10 or 110' 
          write(lout,*) 'ERROR CODE : ',ierro
          write(lout,*)
        endif
      enddo
 12   continue
      close (10,iostat=ierro)
+if cr
+if debug
                   !call system('../crend   >> crlog')
+ei
      close(91,err=4)
    4 continue
      close(94,err=5)
    5 continue
      close(95,err=6)
    6 continue
      close(96,err=7)
    7 continue
      if (lout.eq.92) then
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND copying fort.92'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        rewind 92
    3   read(92,'(a1024)',end=1,err=8,iostat=ierro) arecord
        lstring=1024
        do i=1024,2,-1
          lstring=i
          if (arecord(i:i).ne.' ')goto 2
          lstring=lstring-1
        enddo
    2   write(6,'(a)',iostat=ierro) arecord(1:lstring)
        goto 3
      endif
    1 write(6,*,iostat=ierro)                                                        &
     &'SIXTRACR stop '//cstring
      close(6,iostat=ierro)
!     and get rid of fort.92 (DON'T zip it to save some bytes)
      rewind 92
      endfile (92,iostat=ierro)
      close(92)
      write(93,*)                                                       &
     &'SIXTRACR stop '//cstring
      write(93,*)
+if debug
                   !call system('../crend   >> crlog')
+ei
+if boinc
!+if debug
      do i=2,120
        inquire(i,opened=fopen)
        write(93,*) 'UNIT ',i,' opened ',fopen
      enddo 
!+ei
!     call boinc_zipitall()
!     call boinc_finish_graphics()
      call boinc_finish(0)
+ei
      stop
    8 write(93,*)                                                       &
     &'SIXTRACR CR ABEND *** ERROR *** reading fort.92, iostat=',ierro
      close(93)
      write(6,*)                                                        &
     &'SIXTRACR CR ABEND *** ERROR *** reading fort.92, iostat=',ierro
+if debug
                   !call system('../crend   >> crlog')
+ei
+if boinc
      do i=2,120
        inquire(i,opened=fopen)
        write(6,*) 'UNIT ',i,' opened ',fopen
      enddo 
      close(6,err=31)
 31   continue
!     call boinc_zipitall()
!     call boinc_finish_graphics()
      call boinc_finish(0)
+ei
      stop
+ei
+if .not.cr
      !This one should probably remain as write(*,*) or use output_unit
      write(*,*)                                                        &
     &'SIXTRACK STOP/ABEND '//cstring
+if debug
                   !call system('../crend   >> crlog')
+ei
      stop
+ei
      end
+dk plotdumy
      subroutine hbook2(i1,c1,i2,r1,r2,i3,r3,r4,r5)
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2,i3
      real r1,r2,r3,r4,r5
      character c1
      save
      return
      end
      subroutine hdelet(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end
      subroutine hlimit(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end
      subroutine hplax(c1,c2)
      implicit none
      integer lout
      common /crflags/lout
      character c1,c2
      save
      return
      end
      subroutine hplcap(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end
      subroutine hplend()
      implicit none
      integer lout
      common /crflags/lout
      save
      return
      end
      subroutine hplint(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end
      subroutine hplopt(c1,i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      character c1
      save
      return
      end
      subroutine hplot(i1,c1,c2,i2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2
      character c1,c2
      save
      return
      end
      subroutine hplset(c1,r1)
      implicit none
      integer lout
      common /crflags/lout
      real r1
      character c1
      save
      return
      end
      subroutine hplsiz(r1,r2,c1)
      implicit none
      integer lout
      common /crflags/lout
      real r1,r2
      character c1
      save
      return
      end
      subroutine hplsof(r1,r2,c1,r3,r4,r5,i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1,r2,r3,r4,r5
      character c1
      save
      return
      end
      subroutine htitle(c1)
      implicit none
      integer lout
      common /crflags/lout
      character c1
      save
      return
      end
      subroutine ipl(i1,r1,r2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1(*),r2(*)
      save
      return
      end
      subroutine ipm(i1,r1,r2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1,r2
      save
      return
      end
      subroutine iselnt(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end
      subroutine igmeta(i1,i2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2
      save
      return
      end
+dk nagdumy
      subroutine e04ucf(n,nclin,ncnln,lda,ldcj,ldr,a,bl,bu,
     +confun,objfun,iter,ierroe,c,cjac,clamda,
     +objf,objgrd,r,x,iwork,liwork,work,lwork,
     +iuser,user,ifail)
      implicit none
      integer n,nclin,ncnln,lda,ldcj,ldr,iter,ierroe,
     +istate(n+nclin+ncnln),liwork,iwork(liwork),lwork,
     +iuser(*),ifail
      real a(lda,*),bl(n+nclin+ncnln),bu(n+nclin+ncnln),
     +c(*),cjac(ldcj,*),clamda(n+nclin+ncnln),objf,
     +objgrd(n),r(ldr,n),x(n),work(lwork),user(*)
      external confun,objfun
      save
      return
      end
      subroutine e04uef(c1)
      implicit none
      character c1
      save
      return
      end
      subroutine e04udm(c1)
      implicit none
      character c1
      save
      return
      end
      subroutine x04abf(n1,n2)
      implicit none
      integer n1,n2
      save
      return
      end
+dk dumps
+if debug
!DUMPS
      subroutine warr(vname,value,i,j,k,l)
      implicit none
      character*(*) vname
      double precision value
      integer i,j,k,l
      integer ierro
      character*(16) myname
      myname=vname
      write(100) myname,value,i,j,k,l
      endfile (100,iostat=ierro)
      backspace (100,iostat=ierro)
      return
      end
      subroutine dumpbl1(dumpname,n,i)
      implicit none
+ca parpro
+ca common
      integer n,i
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,100) 'bl1 ',bl1
      write(99,100) 'bl2 ',bl2
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
 100  format (a10,(Z20))
      end
      subroutine dumpzfz(dumpname,n,i)
      implicit none
+ca parpro
+ca common
      integer n,i
      integer j
      character*(*) dumpname
      character*10 mydump,myzfz
      save
      mydump=dumpname
      myzfz='zfz'
      write(101) mydump,n,i
      write(101) myzfz
      do j=1,nzfz
        write(101) zfz(j) 
      enddo
      endfile (101,iostat=ierro)
      backspace (101,iostat=ierro)
      end
      subroutine dumpxy(dumpname,n,i,k)
      implicit none
+ca parpro
+ca common
+ca commonmn
+ca commontr
      integer n,i,j,k
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*)                                                       &
     &(xv(1,j),j=1,k),                                                  &
     &(xv(2,j),j=1,k),                                                  &
     &(yv(1,j),j=1,k),                                                  &
     &(yv(2,j),j=1,k),                                                  &
     &(sigmv(j),j=1,k),                                                 &
     &(ejv(j),j=1,k),                                                   &
     &(ejfv(j),j=1,k),                                                  &
     &(rvv(j),j=1,k),                                                   &
     &(dpsv(j),j=1,k),                                                  &
     &(dpsv1(j),j=1,k),                                                 &
     &(oidpsv(j),j=1,k)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
+if bnlelens
!GRDRHIC
!GRD-042008
      subroutine dumpbnl(dumpname,n,i)
      implicit none
+ca parpro
+if bnlelens
+ca rhicelens
+ei
      integer n,i,j
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*)                                                       &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napx)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
!GRDRHIC
!GRD-042008
+ei
      subroutine dumpsynu(dumpname,n,i)
      implicit none
+ca parpro
+ca common
+ca commons
+ca commonmn
      integer n,i,j,l,m,k
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*) (aek(j),j=1,napxo)
      write(99,*) (afok(j),j=1,napxo)
      write(99,*) (as3(j),j=1,napxo)
      write(99,*) (as4(j),j=1,napxo)
      write(99,*) (as6(j),j=1,napxo)
      write(99,*) (co(j),j=1,napxo)
      write(99,*) (dpd(j),j=1,napxo)
      write(99,*) (dpsq(j),j=1,napxo)
      write(99,*) (fi(j),j=1,napxo)
      write(99,*) (fok(j),j=1,napxo)
      write(99,*) (fok1(j),j=1,napxo)
      write(99,*) (fokqv(j),j=1,napxo)
      write(99,*) (g(j),j=1,napxo)
      write(99,*) (gl(j),j=1,napxo)
      write(99,*) (hc(j),j=1,napxo)
      write(99,*) (hi(j),j=1,napxo)
      write(99,*) (hi1(j),j=1,napxo)
      write(99,*) (hm(j),j=1,napxo)
      write(99,*) (hp(j),j=1,napxo)
      write(99,*) (hs(j),j=1,napxo)
      write(99,*) (rho(j),j=1,napxo)
      write(99,*) (rhoc(j),j=1,napxo)
      write(99,*) (rhoi(j),j=1,napxo)
      write(99,*) (si(j),j=1,napxo)
      write(99,*) (siq(j),j=1,napxo)
      write(99,*) (sm1(j),j=1,napxo)
      write(99,*) (sm12(j),j=1,napxo)
      write(99,*) (sm2(j),j=1,napxo)
      write(99,*) (sm23(j),j=1,napxo)
      write(99,*) (sm3(j),j=1,napxo)
      write(99,*) (wf(j),j=1,napxo)
      write(99,*) (wfa(j),j=1,napxo)
      write(99,*) (wfhi(j),j=1,napxo)
      write(99,*)                                                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
      write(99,*)                                                       &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
      subroutine dump(dumpname,n,i)
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
!     my cr variables
      write(99,*) 'time0 ',time0
      write(99,*) 'time1 ',time1
      write(99,*) 'sixrecs ',sixrecs
      write(99,*) 'binrec ',binrec
      write(99,*) 'binrecs ',binrecs
      write(99,*) 'numlcr ',numlcr
      write(99,*) 'rerun ',rerun
      write(99,*) 'restart ',restart
      write(99,*) 'checkp ',checkp
      write(99,*) 'fort95 ',fort95
      write(99,*) 'fort96 ',fort96
      write(99,*) 'arecord ',arecord
      write(99,*) 'stxt ',stxt
      write(99,*) 'runtim ',runtim
!     mycrio variables
      write(99,*) 'crnumlcr',crnumlcr
      write(99,*) 'crnuml',crnuml
      write(99,*) 'crsixrecs',crsixrecs
      write(99,*) 'crbinrec',crbinrec
      write(99,*) 'crbinrecs',crbinrecs
      write(99,*) 'crsythck',crsythck
      write(99,*) 'crtime3',crtime3
      write(99,*) 'crnapxo',crnapxo
      write(99,*) 'crnapx',crnapx
      write(99,*) 'cre0',cre0
      write(99,*) 'crnumxv(npart)',crnumxv
      write(99,*) 'crnnumxv(npart)',crnnumxv
      write(99,*) 'crnlostp(npart)',crnlostp
      write(99,*) 'crpstop(npart)',crpstop
      write(99,*) 'crxv',crxv
      write(99,*) 'cryv',cryv
      write(99,*) 'crsigmv',crsigmv
      write(99,*) 'crdpsv',crdpsv
      write(99,*) 'crdpsv1',crdpsv1
      write(99,*) 'crejv',crejv
      write(99,*) 'crejfv',crejfv
!     some tracking stuff
      write(99,*) 'nwri',nwri
      write(99,*) 'ktrack',ktrack
      write(99,*) 'strack',strack
      write(99,*) 'strackc',strackc
      write(99,*) 'stracks',stracks
      write(99,*) 'dpsv1',dpsv1
!
      write(99,*) 'ierro ',ierro
      write(99,*) 'erbez ',erbez
      write(99,*) 'pi ',pi
      write(99,*) 'pi2 ',pi2
      write(99,*) 'pisqrt ',pisqrt
      write(99,*) 'rad ',rad
      write(99,*) 'il ',il
      write(99,*) 'mper ',mper
      write(99,*) 'mblo ',mblo
      write(99,*) 'mbloz ',mbloz
      write(99,*) 'msym ',msym
      write(99,*) 'kanf ',kanf
      write(99,*) 'iu ',iu
      write(99,*) 'ic ',ic
      write(99,*) 'ed ',ed
      write(99,*) 'el ',el
      write(99,*) 'ek ',ek
      write(99,*) 'sm ',sm
      write(99,*) 'kz ',kz
      write(99,*) 'kp ',kp
      write(99,*) 'xpl ',xpl
      write(99,*) 'xrms ',xrms
      write(99,*) 'zpl ',zpl
      write(99,*) 'zrms ',zrms
      write(99,*) 'mel ',mel
      write(99,*) 'mtyp ',mtyp
      write(99,*) 'mstr ',mstr
      write(99,*) 'a ',a
      write(99,*) 'bl1 ',bl1
      write(99,*) 'bl2 ',bl2
      write(99,*) 'rvf ',rvf
      write(99,*) 'idfor ',idfor
      write(99,*) 'napx ',napx
      write(99,*) 'napxo ',napxo
      write(99,*) 'numlr ',numlr
      write(99,*) 'nde ',nde
      write(99,*) 'nwr ',nwr
      write(99,*) 'ird ',ird
      write(99,*) 'imc ',imc
      write(99,*) 'irew ',irew
      write(99,*) 'ntwin ',ntwin
      write(99,*) 'iclo6 ',iclo6
      write(99,*) 'iclo6r ',iclo6r
      write(99,*) 'iver ',iver
      write(99,*) 'ibidu ',ibidu
      write(99,*) 'qs ',qs
      write(99,*) 'e0 ',e0
      write(99,*) 'pma ',pma
      write(99,*) 'ej ',ej
      write(99,*) 'ejf ',ejf
      write(99,*) 'phas0 ',phas0
      write(99,*) 'phas ',phas
      write(99,*) 'hsy ',hsy
      write(99,*) 'crad ',crad
      write(99,*) 'hsyc ',hsyc
      write(99,*) 'phasc ',phasc
      write(99,*) 'dppoff ',dppoff
      write(99,*) 'sigmoff ',sigmoff
      write(99,*) 'tlen ',tlen
      write(99,*) 'iicav ',iicav
      write(99,*) 'itionc ',itionc
      write(99,*) 'ition ',ition
      write(99,*) 'idp ',idp
      write(99,*) 'ncy ',ncy
      write(99,*) 'ixcav ',ixcav
      write(99,*) 'dpscor ',dpscor
      write(99,*) 'sigcor ',sigcor
      write(99,*) 'icode ',icode
      write(99,*) 'idam ',idam
      write(99,*) 'its6d ',its6d
      write(99,*) 'bk0 ',bk0
      write(99,*) 'ak0 ',ak0
      write(99,*) 'bka ',bka
      write(99,*) 'aka ',aka
      write(99,*) 'benki ',benki
      write(99,*) 'benkc ',benkc
      write(99,*) 'r00 ',r00
      write(99,*) 'irm ',irm
      write(99,*) 'nmu ',nmu
      write(99,*) 'zfz ',zfz
      write(99,*) 'iorg ',iorg
      write(99,*) 'mzu ',mzu
      write(99,*) 'bezr ',bezr
      write(99,*) 'izu0 ',izu0
      write(99,*) 'mmac ',mmac
      write(99,*) 'mcut ',mcut
      write(99,*) 'exterr ',exterr
      write(99,*) 'extalign ',extalign
      write(99,*) 'tiltc ',tiltc
      write(99,*) 'tilts ',tilts
      write(99,*) 'mout2 ',mout2
      write(99,*) 'icext ',icext
      write(99,*) 'icextal ',icextal
      write(99,*) 'aper ',aper
      write(99,*) 'di0 ',di0
      write(99,*) 'dip0 ',dip0
      write(99,*) 'ta ',ta
      write(99,*) 'dma ',dma
      write(99,*) 'dmap ',dmap
      write(99,*) 'dkq ',dkq
      write(99,*) 'dqq ',dqq
      write(99,*) 'de0 ',de0
      write(99,*) 'ded ',ded
      write(99,*) 'dsi ',dsi
      write(99,*) 'dech ',dech
      write(99,*) 'dsm0 ',dsm0
      write(99,*) 'itco ',itco
      write(99,*) 'itcro ',itcro
      write(99,*) 'itqv ',itqv
      write(99,*) 'iout ',iout
      write(99,*) 'qw0 ',qw0
      write(99,*) 'iq ',iq
      write(99,*) 'iqmod ',iqmod
      write(99,*) 'kpa ',kpa
      write(99,*) 'iqmod6 ',iqmod6
      write(99,*) 'bez ',bez
      write(99,*) 'elbe ',elbe
      write(99,*) 'bezb ',bezb
      write(99,*) 'ilin ',ilin
      write(99,*) 'nt ',nt
      write(99,*) 'iprint ',iprint
      write(99,*) 'ntco ',ntco
      write(99,*) 'eui ',eui
      write(99,*) 'euii ',euii
      write(99,*) 'nlin ',nlin
      write(99,*) 'bezl ',bezl
      write(99,*) 'betam ',betam
      write(99,*) 'pam ',pam
      write(99,*) 'betac ',betac
      write(99,*) 'pac ',pac
      write(99,*) 'bclorb ',bclorb
      write(99,*) 'nhmoni ',nhmoni
      write(99,*) 'nhcorr ',nhcorr
      write(99,*) 'nvmoni ',nvmoni
      write(99,*) 'nvcorr ',nvcorr
      write(99,*) 'ncororb ',ncororb
      write(99,*) 'apx ',apx
      write(99,*) 'apz ',apz
      write(99,*) 'sigma0 ',sigma0
      write(99,*) 'iclo ',iclo
      write(99,*) 'ncorru ',ncorru
      write(99,*) 'ncorrep ',ncorrep
      write(99,*) 'icomb0 ',icomb0
      write(99,*) 'icomb ',icomb
      write(99,*) 'ratio ',ratio
      write(99,*) 'ratioe ',ratioe
      write(99,*) 'iratioe ',iratioe
      write(99,*) 'icoe ',icoe
      write(99,*) 'ise ',ise
      write(99,*) 'mesa ',mesa
      write(99,*) 'mp ',mp
      write(99,*) 'm21 ',m21
      write(99,*) 'm22 ',m22
      write(99,*) 'm23 ',m23
      write(99,*) 'ise1 ',ise1
      write(99,*) 'ise2 ',ise2
      write(99,*) 'ise3 ',ise3
      write(99,*) 'isea ',isea
      write(99,*) 'qxt ',qxt
      write(99,*) 'qzt ',qzt
      write(99,*) 'tam1 ',tam1
      write(99,*) 'tam2 ',tam2
      write(99,*) 'isub ',isub
      write(99,*) 'nta ',nta
      write(99,*) 'nte ',nte
      write(99,*) 'ipt ',ipt
      write(99,*) 'totl ',totl
      write(99,*) 'rtc ',rtc
      write(99,*) 'rts ',rts
      write(99,*) 'ire ',ire
      write(99,*) 'ipr ',ipr
      write(99,*) 'irmod2 ',irmod2
      write(99,*) 'dtr ',dtr
      write(99,*) 'nre ',nre
      write(99,*) 'nur ',nur
      write(99,*) 'nch ',nch
      write(99,*) 'nqc ',nqc
      write(99,*) 'npp ',npp
      write(99,*) 'nrr ',nrr
      write(99,*) 'nu ',nu
      write(99,*) 'dphix ',dphix
      write(99,*) 'dphiz ',dphiz
      write(99,*) 'qx0 ',qx0
      write(99,*) 'qz0 ',qz0
      write(99,*) 'dres ',dres
      write(99,*) 'dfft ',dfft
      write(99,*) 'cma1 ',cma1
      write(99,*) 'cma2 ',cma2
      write(99,*) 'nstart ',nstart
      write(99,*) 'nstop ',nstop
      write(99,*) 'iskip ',iskip
      write(99,*) 'iconv ',iconv
      write(99,*) 'imad ',imad
      write(99,*) 'ipos ',ipos
      write(99,*) 'iav ',iav
      write(99,*) 'iwg ',iwg
      write(99,*) 'ivox ',ivox
      write(99,*) 'ivoz ',ivoz
      write(99,*) 'ires ',ires
      write(99,*) 'ifh ',ifh
      write(99,*) 'toptit ',toptit
      write(99,*) 'kwtype ',kwtype
      write(99,*) 'itf ',itf
      write(99,*) 'icr ',icr
      write(99,*) 'idis ',idis
      write(99,*) 'icow ',icow
      write(99,*) 'istw ',istw
      write(99,*) 'iffw ',iffw
      write(99,*) 'nprint ',nprint
      write(99,*) 'ndafi ',ndafi
      write(99,*) 'qwsk ',qwsk
      write(99,*) 'betx ',betx
      write(99,*) 'betz ',betz
      write(99,*) 'alfx ',alfx
      write(99,*) 'alfz ',alfz
      write(99,*) 'iskew ',iskew
      write(99,*) 'nskew ',nskew
      write(99,*) 'hmal ',hmal
      write(99,*) 'sixtit ',sixtit
      write(99,*) 'commen ',commen
      write(99,*) 'ithick ',ithick
      write(99,*) 'clo6 ',clo6
      write(99,*) 'clop6 ',clop6
      write(99,*) 'dki ',dki
      write(99,*) 'sigman ',sigman
      write(99,*) 'sigman2 ',sigman2
      write(99,*) 'sigmanq ',sigmanq
      write(99,*) 'clobeam ',clobeam
      write(99,*) 'beamoff ',beamoff
      write(99,*) 'parbe ',parbe
      write(99,*) 'track6d ',track6d
      write(99,*) 'ptnfac ',ptnfac
      write(99,*) 'sigz ',sigz
      write(99,*) 'sige ',sige
      write(99,*) 'partnum ',partnum
      write(99,*) 'parbe14 ',parbe14
      write(99,*) 'emitx ',emitx
      write(99,*) 'emity ',emity
      write(99,*) 'emitz ',emitz
      write(99,*) 'gammar ',gammar
      write(99,*) 'nbeam ',nbeam
      write(99,*) 'ibbc ',ibbc
      write(99,*) 'ibeco ',ibeco
      write(99,*) 'ibtyp ',ibtyp
      write(99,*) 'lhc ',lhc
      write(99,*) 'cotr ',cotr
      write(99,*) 'rrtr ',rrtr
      write(99,*) 'imtr ',imtr
      write(99,*) 'bbcu ',bbcu
      write(99,*) 'ibb6d ',ibb6d
      write(99,*) 'imbb ',imbb
      write(99,*) 'as ',as
      write(99,*) 'al ',al
      write(99,*) 'sigm ',sigm
      write(99,*) 'dps ',dps
      write(99,*) 'idz ',idz
      write(99,*) 'dp1 ',dp1
      write(99,*) 'itra ',itra
      write(99,*) 'x ',x
      write(99,*) 'y ',y
      write(99,*) 'bet0 ',bet0
      write(99,*) 'alf0 ',alf0
      write(99,*) 'clo ',clo
      write(99,*) 'clop ',clop
      write(99,*) 'cro ',cro
      write(99,*) 'is ',is
      write(99,*) 'ichrom ',ichrom
      write(99,*) 'nnumxv ',nnumxv
      write(99,*) 'xsi ',xsi
      write(99,*) 'zsi ',zsi
      write(99,*) 'smi ',smi
      write(99,*) 'aai ',aai
      write(99,*) 'bbi ',bbi
      write(99,*) 'ampt ',ampt
      write(99,*) 'tlim ',tlim
      write(99,*) 'tasm ',tasm
      write(99,*) 'preda ',preda
      write(99,*) 'idial ',idial
      write(99,*) 'nord ',nord
      write(99,*) 'nvar ',nvar
      write(99,*) 'nvar2 ',nvar2
      write(99,*) 'nsix ',nsix
      write(99,*) 'ncor ',ncor
      write(99,*) 'ipar ',ipar
      write(99,*) 'nordf ',nordf
      write(99,*) 'nvarf ',nvarf
      write(99,*) 'nord1 ',nord1
      write(99,*) 'ndimf ',ndimf
      write(99,*) 'idptr ',idptr
      write(99,*) 'inorm ',inorm
      write(99,*) 'imod1 ',imod1
      write(99,*) 'imod2 ',imod2
      write(99,*) 'icorr ',icorr
      write(99,*) 'nctype ',nctype
      write(99,*) 'namp ',namp
      write(99,*) 'nmom ',nmom
      write(99,*) 'nmom1 ',nmom1
      write(99,*) 'nmom2 ',nmom2
      write(99,*) 'weig1 ',weig1
      write(99,*) 'weig2 ',weig2
      write(99,*) 'dpmax ',dpmax
      write(99,*) 'coel ',coel
      write(99,*) 'ekv ',ekv
      write(99,*) 'fokqv ',fokqv
      write(99,*) 'aaiv ',aaiv
      write(99,*) 'bbiv ',bbiv
      write(99,*) 'smiv ',smiv
      write(99,*) 'zsiv ',zsiv
      write(99,*) 'xsiv ',xsiv
      write(99,*) 'xsv ',xsv
      write(99,*) 'zsv ',zsv
      write(99,*) 'qw ',qw
      write(99,*) 'qwc ',qwc
      write(99,*) 'clo0 ',clo0
      write(99,*) 'clop0 ',clop0
      write(99,*) 'eps ',eps
      write(99,*) 'epsa ',epsa
      write(99,*) 'ekk ',ekk
      write(99,*) 'cr ',cr
      write(99,*) 'ci ',ci
      write(99,*) 'xv ',xv
      write(99,*) 'yv ',yv
      write(99,*) 'dam ',dam
      write(99,*) 'ekkv ',ekkv
      write(99,*) 'sigmv ',sigmv
      write(99,*) 'dpsv ',dpsv
      write(99,*) 'dp0v ',dp0v
      write(99,*) 'sigmv6 ',sigmv6
      write(99,*) 'dpsv6 ',dpsv6
      write(99,*) 'ejv ',ejv
      write(99,*) 'ejfv ',ejfv
      write(99,*) 'xlv ',xlv
      write(99,*) 'zlv ',zlv
      write(99,*) 'pstop ',pstop
      write(99,*) 'rvv ',rvv
      write(99,*) 'ejf0v ',ejf0v
      write(99,*) 'numxv ',numxv
      write(99,*) 'nms ',nms
      write(99,*) 'nlostp ',nlostp
      write(99,*) 'dpd ',dpd
      write(99,*) 'dpsq ',dpsq
      write(99,*) 'fok ',fok
      write(99,*) 'rho ',rho
      write(99,*) 'fok1 ',fok1
      write(99,*) 'si ',si
      write(99,*) 'co ',co
      write(99,*) 'g ',g
      write(99,*) 'gl ',gl
      write(99,*) 'sm1 ',sm1
      write(99,*) 'sm2 ',sm2
      write(99,*) 'sm3 ',sm3
      write(99,*) 'sm12 ',sm12
      write(99,*) 'as3 ',as3
      write(99,*) 'as4 ',as4
      write(99,*) 'as6 ',as6
      write(99,*) 'sm23 ',sm23
      write(99,*) 'rhoc ',rhoc
      write(99,*) 'siq ',siq
      write(99,*) 'aek ',aek
      write(99,*) 'afok ',afok
      write(99,*) 'hp ',hp
      write(99,*) 'hm ',hm
      write(99,*) 'hc ',hc
      write(99,*) 'hs ',hs
      write(99,*) 'wf ',wf
      write(99,*) 'wfa ',wfa
      write(99,*) 'wfhi ',wfhi
      write(99,*) 'rhoi ',rhoi
      write(99,*) 'hi ',hi
      write(99,*) 'fi ',fi
      write(99,*) 'hi1 ',hi1
      write(99,*) 'xvl ',xvl
      write(99,*) 'yvl ',yvl
      write(99,*) 'ejvl ',ejvl
      write(99,*) 'dpsvl ',dpsvl
      write(99,*) 'oidpsv ',oidpsv
      write(99,*) 'sigmvl ',sigmvl
      write(99,*) 'iv ',iv
      write(99,*) 'aperv ',aperv
      write(99,*) 'ixv ',ixv
      write(99,*) 'clov ',clov
      write(99,*) 'clopv ',clopv
      write(99,*) 'alf0v ',alf0v
      write(99,*) 'bet0v ',bet0v
      write(99,*) 'ampv ',ampv
      write(99,*) 'clo6v ',clo6v
      write(99,*) 'clop6v ',clop6v
      write(99,*) 'hv ',hv
      write(99,*) 'bl1v ',bl1v
      write(99,*) 'tas ',tas
      write(99,*) 'qwcs ',qwcs
      write(99,*) 'di0xs ',di0xs
      write(99,*) 'di0zs ',di0zs
      write(99,*) 'dip0xs ',dip0xs
      write(99,*) 'dip0zs ',dip0zs
      write(99,*) 'xau ',xau
      write(99,*) 'cloau ',cloau
      write(99,*) 'di0au ',di0au
      write(99,*) 'tau ',tau
      write(99,*) 'tasau ',tasau
      write(99,*) 'wx ',wx
      write(99,*) 'x1 ',x1
      write(99,*) 'x2 ',x2
      write(99,*) 'fake ',fake
      
      write(99,*) 'e0f ',e0f
      write(99,*) 'numx ',numx
      write(99,*) 'cotr ',cotr
      write(99,*) 'rrtr ',rrtr
      write(99,*) 'imtr ',imtr
!     these other values???
      write(99,*) 'numl ',numl
      write(99,*) 'niu ',niu
      write(99,*) 'amp0 ',amp0
      write(99,*) 'amp ',amp
      write(99,*) 'damp ',damp
      write(99,*) 'chi0 ',chi0
      write(99,*) 'chid ',chid
      write(99,*) 'rat ',rat
      write(99,*) 'exz ',exz
      write(99,*) 'time0 ',time0
      write(99,*) 'time1 ',time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
      subroutine dumpbin(dumpname,n,i)
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character*(*) dumpname
      character*10 mydump
      save
      mydump=dumpname
      write(99) mydump
      write(99) n
      write(99) i
!     my cr variables
      write(99) time0
      write(99) time1
      write(99) sixrecs
      write(99) binrec
      write(99) binrecs
      write(99) numlcr
      write(99) rerun
      write(99) restart
      write(99) checkp
      write(99) fort95
      write(99) fort96
      write(99) arecord
      write(99) stxt
      write(99) runtim
!     mycrio variables
      write(99) crnumlcr
      write(99) crnuml
      write(99) crsixrecs
      write(99) crbinrec
      write(99) crbinrecs
      write(99) crsythck
      write(99) crtime3
      write(99) crnapxo
      write(99) crnapx
      write(99) cre0
      write(99) crnumxv
      write(99) crnnumxv
      write(99) crnlostp
      write(99) crpstop
      write(99) crxv
      write(99) cryv
      write(99) crsigmv
      write(99) crdpsv
      write(99) crdpsv1
      write(99) crejv
      write(99) crejfv
!     some tracking stuff
      write(99) nwri
      write(99) ktrack
      write(99) strack
      write(99) strackc
      write(99) stracks
      write(99) dpsv1
!
      write(99) ierro
      write(99) erbez
      write(99) pi
      write(99) pi2
      write(99) pisqrt
      write(99) rad
      write(99) il
      write(99) mper
      write(99) mblo
      write(99) mbloz
      write(99) msym
      write(99) kanf
      write(99) iu
      write(99) ic
      write(99) ed
      write(99) el
      write(99) ek
      write(99) sm
      write(99) kz
      write(99) kp
      write(99) xpl
      write(99) xrms
      write(99) zpl
      write(99) zrms
      write(99) mel
      write(99) mtyp
      write(99) mstr
      write(99) a
      write(99) bl1
      write(99) bl2
      write(99) rvf
      write(99) idfor
      write(99) napx
      write(99) napxo
      write(99) numlr
      write(99) nde
      write(99) nwr
      write(99) ird
      write(99) imc
      write(99) irew
      write(99) ntwin
      write(99) iclo6
      write(99) iclo6r
      write(99) iver
      write(99) ibidu
      write(99) qs
      write(99) e0
      write(99) pma
      write(99) ej
      write(99) ejf
      write(99) phas0
      write(99) phas
      write(99) hsy
      write(99) crad
      write(99) hsyc
      write(99) phasc
      write(99) dppoff
      write(99) sigmoff
      write(99) tlen
      write(99) iicav
      write(99) itionc
      write(99) ition
      write(99) idp
      write(99) ncy
      write(99) ixcav
      write(99) dpscor
      write(99) sigcor
      write(99) icode
      write(99) idam
      write(99) its6d
      write(99) bk0
      write(99) ak0
      write(99) bka
      write(99) aka
      write(99) benki
      write(99) benkc
      write(99) r00
      write(99) irm
      write(99) nmu
      write(99) zfz
      write(99) iorg
      write(99) mzu
      write(99) bezr
      write(99) izu0
      write(99) mmac
      write(99) mcut
      write(99) exterr
      write(99) extalign
      write(99) tiltc
      write(99) tilts
      write(99) mout2
      write(99) icext
      write(99) icextal
      write(99) aper
      write(99) di0
      write(99) dip0
      write(99) ta
      write(99) dma
      write(99) dmap
      write(99) dkq
      write(99) dqq
      write(99) de0
      write(99) ded
      write(99) dsi
      write(99) dech
      write(99) dsm0
      write(99) itco
      write(99) itcro
      write(99) itqv
      write(99) iout
      write(99) qw0
      write(99) iq
      write(99) iqmod
      write(99) kpa
      write(99) iqmod6
      write(99) bez
      write(99) elbe
      write(99) bezb
      write(99) ilin
      write(99) nt
      write(99) iprint
      write(99) ntco
      write(99) eui
      write(99) euii
      write(99) nlin
      write(99) bezl
      write(99) betam
      write(99) pam
      write(99) betac
      write(99) pac
      write(99) bclorb
      write(99) nhmoni
      write(99) nhcorr
      write(99) nvmoni
      write(99) nvcorr
      write(99) ncororb
      write(99) apx
      write(99) apz
      write(99) sigma0
      write(99) iclo
      write(99) ncorru
      write(99) ncorrep
      write(99) icomb0
      write(99) icomb
      write(99) ratio
      write(99) ratioe
      write(99) iratioe
      write(99) icoe
      write(99) ise
      write(99) mesa
      write(99) mp
      write(99) m21
      write(99) m22
      write(99) m23
      write(99) ise1
      write(99) ise2
      write(99) ise3
      write(99) isea
      write(99) qxt
      write(99) qzt
      write(99) tam1
      write(99) tam2
      write(99) isub
      write(99) nta
      write(99) nte
      write(99) ipt
      write(99) totl
      write(99) rtc
      write(99) rts
      write(99) ire
      write(99) ipr
      write(99) irmod2
      write(99) dtr
      write(99) nre
      write(99) nur
      write(99) nch
      write(99) nqc
      write(99) npp
      write(99) nrr
      write(99) nu
      write(99) dphix
      write(99) dphiz
      write(99) qx0
      write(99) qz0
      write(99) dres
      write(99) dfft
      write(99) cma1
      write(99) cma2
      write(99) nstart
      write(99) nstop
      write(99) iskip
      write(99) iconv
      write(99) imad
      write(99) ipos
      write(99) iav
      write(99) iwg
      write(99) ivox
      write(99) ivoz
      write(99) ires
      write(99) ifh
      write(99) toptit
      write(99) kwtype
      write(99) itf
      write(99) icr
      write(99) idis
      write(99) icow
      write(99) istw
      write(99) iffw
      write(99) nprint
      write(99) ndafi
      write(99) qwsk
      write(99) betx
      write(99) betz
      write(99) alfx
      write(99) alfz
      write(99) iskew
      write(99) nskew
      write(99) hmal
      write(99) sixtit
      write(99) commen
      write(99) ithick
      write(99) clo6
      write(99) clop6
      write(99) dki
      write(99) sigman
      write(99) sigman2
      write(99) sigmanq
      write(99) clobeam
      write(99) beamoff
      write(99) parbe
      write(99) track6d
      write(99) ptnfac
      write(99) sigz
      write(99) sige
      write(99) partnum
      write(99) parbe14
      write(99) emitx
      write(99) emity
      write(99) emitz
      write(99) gammar
      write(99) nbeam
      write(99) ibbc
      write(99) ibeco
      write(99) ibtyp
      write(99) lhc
      write(99) cotr
      write(99) rrtr
      write(99) imtr
      write(99) bbcu
      write(99) ibb6d
      write(99) imbb
      write(99) as
      write(99) al
      write(99) sigm
      write(99) dps
      write(99) idz
      write(99) dp1
      write(99) itra
      write(99) x
      write(99) y
      write(99) bet0
      write(99) alf0
      write(99) clo
      write(99) clop
      write(99) cro
      write(99) is
      write(99) ichrom
      write(99) nnumxv
      write(99) xsi
      write(99) zsi
      write(99) smi
      write(99) aai
      write(99) bbi
      write(99) ampt
      write(99) tlim
      write(99) tasm
      write(99) preda
      write(99) idial
      write(99) nord
      write(99) nvar
      write(99) nvar2
      write(99) nsix
      write(99) ncor
      write(99) ipar
      write(99) nordf
      write(99) nvarf
      write(99) nord1
      write(99) ndimf
      write(99) idptr
      write(99) inorm
      write(99) imod1
      write(99) imod2
      write(99) icorr
      write(99) nctype
      write(99) namp
      write(99) nmom
      write(99) nmom1
      write(99) nmom2
      write(99) weig1
      write(99) weig2
      write(99) dpmax
      write(99) coel
      write(99) ekv
      write(99) fokqv
      write(99) aaiv
      write(99) bbiv
      write(99) smiv
      write(99) zsiv
      write(99) xsiv
      write(99) xsv
      write(99) zsv
      write(99) qw
      write(99) qwc
      write(99) clo0
      write(99) clop0
      write(99) eps
      write(99) epsa
      write(99) ekk
      write(99) cr
      write(99) ci
      write(99) xv
      write(99) yv
      write(99) dam
      write(99) ekkv
      write(99) sigmv
      write(99) dpsv
      write(99) dp0v
      write(99) sigmv6
      write(99) dpsv6
      write(99) ejv
      write(99) ejfv
      write(99) xlv
      write(99) zlv
      write(99) pstop
      write(99) rvv
      write(99) ejf0v
      write(99) numxv
      write(99) nms
      write(99) nlostp
      write(99) dpd
      write(99) dpsq
      write(99) fok
      write(99) rho
      write(99) fok1
      write(99) si
      write(99) co
      write(99) g
      write(99) gl
      write(99) sm1
      write(99) sm2
      write(99) sm3
      write(99) sm12
      write(99) as3
      write(99) as4
      write(99) as6
      write(99) sm23
      write(99) rhoc
      write(99) siq
      write(99) aek
      write(99) afok
      write(99) hp
      write(99) hm
      write(99) hc
      write(99) hs
      write(99) wf
      write(99) wfa
      write(99) wfhi
      write(99) rhoi
      write(99) hi
      write(99) fi
      write(99) hi1
      write(99) xvl
      write(99) yvl
      write(99) ejvl
      write(99) dpsvl
      write(99) oidpsv
      write(99) sigmvl
      write(99) iv
      write(99) aperv
      write(99) ixv
      write(99) clov
      write(99) clopv
      write(99) alf0v
      write(99) bet0v
      write(99) ampv
      write(99) clo6v
      write(99) clop6v
      write(99) hv
      write(99) bl1v
      write(99) tas
      write(99) qwcs
      write(99) di0xs
      write(99) di0zs
      write(99) dip0xs
      write(99) dip0zs
      write(99) xau
      write(99) cloau
      write(99) di0au
      write(99) tau
      write(99) tasau
      write(99) wx
      write(99) x1
      write(99) x2
      write(99) fake
      write(99) e0f
      write(99) numx
      write(99) cotr
      write(99) rrtr
      write(99) imtr
!     these other values???
      write(99) numl
      write(99) niu
      write(99) amp0
      write(99) amp
      write(99) damp
      write(99) chi0
      write(99) chid
      write(99) rat
      write(99) exz
      write(99) time0
      write(99) time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
      subroutine dumphex(dumpname,n,i)
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character*(*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
!     my cr variables
      write(99,100) 'time0 ',time0
      write(99,100) 'time1 ',time1
      write(99,100) 'sixrecs ',sixrecs
      write(99,100) 'binrec ',binrec
      write(99,100) 'binrecs ',binrecs
      write(99,100) 'numlcr ',numlcr
      write(99,100) 'rerun ',rerun
      write(99,100) 'restart ',restart
      write(99,100) 'checkp ',checkp
      write(99,100) 'fort95 ',fort95
      write(99,100) 'fort96 ',fort96
      write(99,100) 'arecord ',arecord
      write(99,100) 'stxt ',stxt
      write(99,100) 'runtim ',runtim
!     mycrio variables
      write(99,100) 'crnumlcr',crnumlcr
      write(99,100) 'crnuml',crnuml
      write(99,100) 'crsixrecs',crsixrecs
      write(99,100) 'crbinrec',crbinrec
      write(99,100) 'crbinrecs',crbinrecs
      write(99,100) 'crsythck',crsythck
      write(99,100) 'crtime3',crtime3
      write(99,100) 'crnapxo',crnapxo
      write(99,100) 'crnapx',crnapx
      write(99,100) 'cre0',cre0
      write(99,100) 'crnumxv(npart)',crnumxv
      write(99,100) 'crnnumxv(npart)',crnnumxv
      write(99,100) 'crnlostp(npart)',crnlostp
      write(99,100) 'crpstop(npart)',crpstop
      write(99,100) 'crxv',crxv
      write(99,100) 'cryv',cryv
      write(99,100) 'crsigmv',crsigmv
      write(99,100) 'crdpsv',crdpsv
      write(99,100) 'crdpsv1',crdpsv1
      write(99,100) 'crejv',crejv
      write(99,100) 'crejfv',crejfv
!     some tracking stuff
      write(99,100) 'nwri',nwri
      write(99,100) 'ktrack',ktrack
      write(99,100) 'strack',strack
      write(99,100) 'strackc',strackc
      write(99,100) 'stracks',stracks
      write(99,100) 'dpsv1',dpsv1
!
      write(99,100) 'ierro ',ierro
      write(99,100) 'erbez ',erbez
      write(99,100) 'pi ',pi
      write(99,100) 'pi2 ',pi2
      write(99,100) 'pisqrt ',pisqrt
      write(99,100) 'rad ',rad
      write(99,100) 'il ',il
      write(99,100) 'mper ',mper
      write(99,100) 'mblo ',mblo
      write(99,100) 'mbloz ',mbloz
      write(99,100) 'msym ',msym
      write(99,100) 'kanf ',kanf
      write(99,100) 'iu ',iu
      write(99,100) 'ic ',ic
      write(99,100) 'ed ',ed
      write(99,100) 'el ',el
      write(99,100) 'ek ',ek
      write(99,100) 'sm ',sm
      write(99,100) 'kz ',kz
      write(99,100) 'kp ',kp
      write(99,100) 'xpl ',xpl
      write(99,100) 'xrms ',xrms
      write(99,100) 'zpl ',zpl
      write(99,100) 'zrms ',zrms
      write(99,100) 'mel ',mel
      write(99,100) 'mtyp ',mtyp
      write(99,100) 'mstr ',mstr
      write(99,100) 'a ',a
      write(99,100) 'bl1 ',bl1
      write(99,100) 'bl2 ',bl2
      write(99,100) 'rvf ',rvf
      write(99,100) 'idfor ',idfor
      write(99,100) 'napx ',napx
      write(99,100) 'napxo ',napxo
      write(99,100) 'numlr ',numlr
      write(99,100) 'nde ',nde
      write(99,100) 'nwr ',nwr
      write(99,100) 'ird ',ird
      write(99,100) 'imc ',imc
      write(99,100) 'irew ',irew
      write(99,100) 'ntwin ',ntwin
      write(99,100) 'iclo6 ',iclo6
      write(99,100) 'iclo6r ',iclo6r
      write(99,100) 'iver ',iver
      write(99,100) 'ibidu ',ibidu
      write(99,100) 'qs ',qs
      write(99,100) 'e0 ',e0
      write(99,100) 'pma ',pma
      write(99,100) 'ej ',ej
      write(99,100) 'ejf ',ejf
      write(99,100) 'phas0 ',phas0
      write(99,100) 'phas ',phas
      write(99,100) 'hsy ',hsy
      write(99,100) 'crad ',crad
      write(99,100) 'hsyc ',hsyc
      write(99,100) 'phasc ',phasc
      write(99,100) 'dppoff ',dppoff
      write(99,100) 'sigmoff ',sigmoff
      write(99,100) 'tlen ',tlen
      write(99,100) 'iicav ',iicav
      write(99,100) 'itionc ',itionc
      write(99,100) 'ition ',ition
      write(99,100) 'idp ',idp
      write(99,100) 'ncy ',ncy
      write(99,100) 'ixcav ',ixcav
      write(99,100) 'dpscor ',dpscor
      write(99,100) 'sigcor ',sigcor
      write(99,100) 'icode ',icode
      write(99,100) 'idam ',idam
      write(99,100) 'its6d ',its6d
      write(99,100) 'bk0 ',bk0
      write(99,100) 'ak0 ',ak0
      write(99,100) 'bka ',bka
      write(99,100) 'aka ',aka
      write(99,100) 'benki ',benki
      write(99,100) 'benkc ',benkc
      write(99,100) 'r00 ',r00
      write(99,100) 'irm ',irm
      write(99,100) 'nmu ',nmu
      write(99,100) 'zfz ',zfz
      write(99,100) 'iorg ',iorg
      write(99,100) 'mzu ',mzu
      write(99,100) 'bezr ',bezr
      write(99,100) 'izu0 ',izu0
      write(99,100) 'mmac ',mmac
      write(99,100) 'mcut ',mcut
      write(99,100) 'exterr ',exterr
      write(99,100) 'extalign ',extalign
      write(99,100) 'tiltc ',tiltc
      write(99,100) 'tilts ',tilts
      write(99,100) 'mout2 ',mout2
      write(99,100) 'icext ',icext
      write(99,100) 'icextal ',icextal
      write(99,100) 'aper ',aper
      write(99,100) 'di0 ',di0
      write(99,100) 'dip0 ',dip0
      write(99,100) 'ta ',ta
      write(99,100) 'dma ',dma
      write(99,100) 'dmap ',dmap
      write(99,100) 'dkq ',dkq
      write(99,100) 'dqq ',dqq
      write(99,100) 'de0 ',de0
      write(99,100) 'ded ',ded
      write(99,100) 'dsi ',dsi
      write(99,100) 'dech ',dech
      write(99,100) 'dsm0 ',dsm0
      write(99,100) 'itco ',itco
      write(99,100) 'itcro ',itcro
      write(99,100) 'itqv ',itqv
      write(99,100) 'iout ',iout
      write(99,100) 'qw0 ',qw0
      write(99,100) 'iq ',iq
      write(99,100) 'iqmod ',iqmod
      write(99,100) 'kpa ',kpa
      write(99,100) 'iqmod6 ',iqmod6
      write(99,100) 'bez ',bez
      write(99,100) 'elbe ',elbe
      write(99,100) 'bezb ',bezb
      write(99,100) 'ilin ',ilin
      write(99,100) 'nt ',nt
      write(99,100) 'iprint ',iprint
      write(99,100) 'ntco ',ntco
      write(99,100) 'eui ',eui
      write(99,100) 'euii ',euii
      write(99,100) 'nlin ',nlin
      write(99,100) 'bezl ',bezl
      write(99,100) 'betam ',betam
      write(99,100) 'pam ',pam
      write(99,100) 'betac ',betac
      write(99,100) 'pac ',pac
      write(99,100) 'bclorb ',bclorb
      write(99,100) 'nhmoni ',nhmoni
      write(99,100) 'nhcorr ',nhcorr
      write(99,100) 'nvmoni ',nvmoni
      write(99,100) 'nvcorr ',nvcorr
      write(99,100) 'ncororb ',ncororb
      write(99,100) 'apx ',apx
      write(99,100) 'apz ',apz
      write(99,100) 'sigma0 ',sigma0
      write(99,100) 'iclo ',iclo
      write(99,100) 'ncorru ',ncorru
      write(99,100) 'ncorrep ',ncorrep
      write(99,100) 'icomb0 ',icomb0
      write(99,100) 'icomb ',icomb
      write(99,100) 'ratio ',ratio
      write(99,100) 'ratioe ',ratioe
      write(99,100) 'iratioe ',iratioe
      write(99,100) 'icoe ',icoe
      write(99,100) 'ise ',ise
      write(99,100) 'mesa ',mesa
      write(99,100) 'mp ',mp
      write(99,100) 'm21 ',m21
      write(99,100) 'm22 ',m22
      write(99,100) 'm23 ',m23
      write(99,100) 'ise1 ',ise1
      write(99,100) 'ise2 ',ise2
      write(99,100) 'ise3 ',ise3
      write(99,100) 'isea ',isea
      write(99,100) 'qxt ',qxt
      write(99,100) 'qzt ',qzt
      write(99,100) 'tam1 ',tam1
      write(99,100) 'tam2 ',tam2
      write(99,100) 'isub ',isub
      write(99,100) 'nta ',nta
      write(99,100) 'nte ',nte
      write(99,100) 'ipt ',ipt
      write(99,100) 'totl ',totl
      write(99,100) 'rtc ',rtc
      write(99,100) 'rts ',rts
      write(99,100) 'ire ',ire
      write(99,100) 'ipr ',ipr
      write(99,100) 'irmod2 ',irmod2
      write(99,100) 'dtr ',dtr
      write(99,100) 'nre ',nre
      write(99,100) 'nur ',nur
      write(99,100) 'nch ',nch
      write(99,100) 'nqc ',nqc
      write(99,100) 'npp ',npp
      write(99,100) 'nrr ',nrr
      write(99,100) 'nu ',nu
      write(99,100) 'dphix ',dphix
      write(99,100) 'dphiz ',dphiz
      write(99,100) 'qx0 ',qx0
      write(99,100) 'qz0 ',qz0
      write(99,100) 'dres ',dres
      write(99,100) 'dfft ',dfft
      write(99,100) 'cma1 ',cma1
      write(99,100) 'cma2 ',cma2
      write(99,100) 'nstart ',nstart
      write(99,100) 'nstop ',nstop
      write(99,100) 'iskip ',iskip
      write(99,100) 'iconv ',iconv
      write(99,100) 'imad ',imad
      write(99,100) 'ipos ',ipos
      write(99,100) 'iav ',iav
      write(99,100) 'iwg ',iwg
      write(99,100) 'ivox ',ivox
      write(99,100) 'ivoz ',ivoz
      write(99,100) 'ires ',ires
      write(99,100) 'ifh ',ifh
      write(99,100) 'toptit ',toptit
      write(99,100) 'kwtype ',kwtype
      write(99,100) 'itf ',itf
      write(99,100) 'icr ',icr
      write(99,100) 'idis ',idis
      write(99,100) 'icow ',icow
      write(99,100) 'istw ',istw
      write(99,100) 'iffw ',iffw
      write(99,100) 'nprint ',nprint
      write(99,100) 'ndafi ',ndafi
      write(99,100) 'qwsk ',qwsk
      write(99,100) 'betx ',betx
      write(99,100) 'betz ',betz
      write(99,100) 'alfx ',alfx
      write(99,100) 'alfz ',alfz
      write(99,100) 'iskew ',iskew
      write(99,100) 'nskew ',nskew
      write(99,100) 'hmal ',hmal
      write(99,100) 'sixtit ',sixtit
      write(99,100) 'commen ',commen
      write(99,100) 'ithick ',ithick
      write(99,100) 'clo6 ',clo6
      write(99,100) 'clop6 ',clop6
      write(99,100) 'dki ',dki
      write(99,100) 'sigman ',sigman
      write(99,100) 'sigman2 ',sigman2
      write(99,100) 'sigmanq ',sigmanq
      write(99,100) 'clobeam ',clobeam
      write(99,100) 'beamoff ',beamoff
      write(99,100) 'parbe ',parbe
      write(99,100) 'track6d ',track6d
      write(99,100) 'ptnfac ',ptnfac
      write(99,100) 'sigz ',sigz
      write(99,100) 'sige ',sige
      write(99,100) 'partnum ',partnum
      write(99,100) 'parbe14 ',parbe14
      write(99,100) 'emitx ',emitx
      write(99,100) 'emity ',emity
      write(99,100) 'emitz ',emitz
      write(99,100) 'gammar ',gammar
      write(99,100) 'nbeam ',nbeam
      write(99,100) 'ibbc ',ibbc
      write(99,100) 'ibeco ',ibeco
      write(99,100) 'ibtyp ',ibtyp
      write(99,100) 'lhc ',lhc
      write(99,100) 'cotr ',cotr
      write(99,100) 'rrtr ',rrtr
      write(99,100) 'imtr ',imtr
      write(99,100) 'bbcu ',bbcu
      write(99,100) 'ibb6d ',ibb6d
      write(99,100) 'imbb ',imbb
      write(99,100) 'as ',as
      write(99,100) 'al ',al
      write(99,100) 'sigm ',sigm
      write(99,100) 'dps ',dps
      write(99,100) 'idz ',idz
      write(99,100) 'dp1 ',dp1
      write(99,100) 'itra ',itra
      write(99,100) 'x ',x
      write(99,100) 'y ',y
      write(99,100) 'bet0 ',bet0
      write(99,100) 'alf0 ',alf0
      write(99,100) 'clo ',clo
      write(99,100) 'clop ',clop
      write(99,100) 'cro ',cro
      write(99,100) 'is ',is
      write(99,100) 'ichrom ',ichrom
      write(99,100) 'nnumxv ',nnumxv
      write(99,100) 'xsi ',xsi
      write(99,100) 'zsi ',zsi
      write(99,100) 'smi ',smi
      write(99,100) 'aai ',aai
      write(99,100) 'bbi ',bbi
      write(99,100) 'ampt ',ampt
      write(99,100) 'tlim ',tlim
      write(99,100) 'tasm ',tasm
      write(99,100) 'preda ',preda
      write(99,100) 'idial ',idial
      write(99,100) 'nord ',nord
      write(99,100) 'nvar ',nvar
      write(99,100) 'nvar2 ',nvar2
      write(99,100) 'nsix ',nsix
      write(99,100) 'ncor ',ncor
      write(99,100) 'ipar ',ipar
      write(99,100) 'nordf ',nordf
      write(99,100) 'nvarf ',nvarf
      write(99,100) 'nord1 ',nord1
      write(99,100) 'ndimf ',ndimf
      write(99,100) 'idptr ',idptr
      write(99,100) 'inorm ',inorm
      write(99,100) 'imod1 ',imod1
      write(99,100) 'imod2 ',imod2
      write(99,100) 'icorr ',icorr
      write(99,100) 'nctype ',nctype
      write(99,100) 'namp ',namp
      write(99,100) 'nmom ',nmom
      write(99,100) 'nmom1 ',nmom1
      write(99,100) 'nmom2 ',nmom2
      write(99,100) 'weig1 ',weig1
      write(99,100) 'weig2 ',weig2
      write(99,100) 'dpmax ',dpmax
      write(99,100) 'coel ',coel
      write(99,100) 'ekv ',ekv
      write(99,100) 'fokqv ',fokqv
      write(99,100) 'aaiv ',aaiv
      write(99,100) 'bbiv ',bbiv
      write(99,100) 'smiv ',smiv
      write(99,100) 'zsiv ',zsiv
      write(99,100) 'xsiv ',xsiv
      write(99,100) 'xsv ',xsv
      write(99,100) 'zsv ',zsv
      write(99,100) 'qw ',qw
      write(99,100) 'qwc ',qwc
      write(99,100) 'clo0 ',clo0
      write(99,100) 'clop0 ',clop0
      write(99,100) 'eps ',eps
      write(99,100) 'epsa ',epsa
      write(99,100) 'ekk ',ekk
      write(99,100) 'cr ',cr
      write(99,100) 'ci ',ci
      write(99,100) 'xv ',xv
      write(99,100) 'yv ',yv
      write(99,100) 'dam ',dam
      write(99,100) 'ekkv ',ekkv
      write(99,100) 'sigmv ',sigmv
      write(99,100) 'dpsv ',dpsv
      write(99,100) 'dp0v ',dp0v
      write(99,100) 'sigmv6 ',sigmv6
      write(99,100) 'dpsv6 ',dpsv6
      write(99,100) 'ejv ',ejv
      write(99,100) 'ejfv ',ejfv
      write(99,100) 'xlv ',xlv
      write(99,100) 'zlv ',zlv
      write(99,100) 'pstop ',pstop
      write(99,100) 'rvv ',rvv
      write(99,100) 'ejf0v ',ejf0v
      write(99,100) 'numxv ',numxv
      write(99,100) 'nms ',nms
      write(99,100) 'nlostp ',nlostp
      write(99,100) 'dpd ',dpd
      write(99,100) 'dpsq ',dpsq
      write(99,100) 'fok ',fok
      write(99,100) 'rho ',rho
      write(99,100) 'fok1 ',fok1
      write(99,100) 'si ',si
      write(99,100) 'co ',co
      write(99,100) 'g ',g
      write(99,100) 'gl ',gl
      write(99,100) 'sm1 ',sm1
      write(99,100) 'sm2 ',sm2
      write(99,100) 'sm3 ',sm3
      write(99,100) 'sm12 ',sm12
      write(99,100) 'as3 ',as3
      write(99,100) 'as4 ',as4
      write(99,100) 'as6 ',as6
      write(99,100) 'sm23 ',sm23
      write(99,100) 'rhoc ',rhoc
      write(99,100) 'siq ',siq
      write(99,100) 'aek ',aek
      write(99,100) 'afok ',afok
      write(99,100) 'hp ',hp
      write(99,100) 'hm ',hm
      write(99,100) 'hc ',hc
      write(99,100) 'hs ',hs
      write(99,100) 'wf ',wf
      write(99,100) 'wfa ',wfa
      write(99,100) 'wfhi ',wfhi
      write(99,100) 'rhoi ',rhoi
      write(99,100) 'hi ',hi
      write(99,100) 'fi ',fi
      write(99,100) 'hi1 ',hi1
      write(99,100) 'xvl ',xvl
      write(99,100) 'yvl ',yvl
      write(99,100) 'ejvl ',ejvl
      write(99,100) 'dpsvl ',dpsvl
      write(99,100) 'oidpsv ',oidpsv
      write(99,100) 'sigmvl ',sigmvl
      write(99,100) 'iv ',iv
      write(99,100) 'aperv ',aperv
      write(99,100) 'ixv ',ixv
      write(99,100) 'clov ',clov
      write(99,100) 'clopv ',clopv
      write(99,100) 'alf0v ',alf0v
      write(99,100) 'bet0v ',bet0v
      write(99,100) 'ampv ',ampv
      write(99,100) 'clo6v ',clo6v
      write(99,100) 'clop6v ',clop6v
      write(99,100) 'hv ',hv
      write(99,100) 'bl1v ',bl1v
      write(99,100) 'tas ',tas
      write(99,100) 'qwcs ',qwcs
      write(99,100) 'di0xs ',di0xs
      write(99,100) 'di0zs ',di0zs
      write(99,100) 'dip0xs ',dip0xs
      write(99,100) 'dip0zs ',dip0zs
      write(99,100) 'xau ',xau
      write(99,100) 'cloau ',cloau
      write(99,100) 'di0au ',di0au
      write(99,100) 'tau ',tau
      write(99,100) 'tasau ',tasau
      write(99,100) 'wx ',wx
      write(99,100) 'x1 ',x1
      write(99,100) 'x2 ',x2
      write(99,100) 'fake ',fake
      write(99,100) 'e0f ',e0f
      write(99,100) 'numx ',numx
      write(99,100) 'cotr ',cotr
      write(99,100) 'rrtr ',rrtr
      write(99,100) 'imtr ',imtr
!     these other values???
      write(99,100) 'numl ',numl
      write(99,100) 'niu ',niu
      write(99,100) 'amp0 ',amp0
      write(99,100) 'amp ',amp
      write(99,100) 'damp ',damp
      write(99,100) 'chi0 ',chi0
      write(99,100) 'chid ',chid
      write(99,100) 'rat ',rat
      write(99,100) 'exz ',exz
      write(99,100) 'time0 ',time0
      write(99,100) 'time1 ',time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
 100  format (a10,(Z20))
      end
!DUMPS
+ei
+dk hdf5K
+if hdf5
!>
!! @brief module that contains the code necessary for hdf5 support
!!
!<
      MODULE SIXTRACKHDF5
      
      USE HDF5
      
      IMPLICIT NONE

        CHARACTER(LEN=20), PARAMETER :: HFNAME = "tracks2.h5"
        INTEGER(HID_T) :: hfile_id
        INTEGER(HID_T) :: h5set_id       ! Dataset identifier
        INTEGER(HID_T) :: h5space_id,memspace     ! Dataspace identifier
        INTEGER(HID_T) :: crp_list        ! dataset creatation property identifier 
        CHARACTER(LEN=6), PARAMETER :: h5setname = "tracks"     ! Dataset name
        INTEGER     ::   h5error
        INTEGER, PARAMETER :: incr = 1024
        INTEGER(HSIZE_T), DIMENSION(2) :: h5dims,maxdims,data_dims,     &
     &                                    offset
        INTEGER     ::   h5rank = 2                        ! Dataset rank
        REAL, DIMENSION(9,incr) :: data_in2
      CONTAINS
      
      SUBROUTINE WRITETOFILE
+if debug
+ca crcoall
+ei
          CALL h5dextend_f(h5set_id, h5dims, h5error)
          CALL h5dget_space_f(h5set_id, h5space_id, h5error)
          
          !
          ! Get updated dataspace
          !
          data_dims(1)=9 ! to be sure..
          data_dims(2)=mod(h5dims(2)-1,incr)+1
          offset(1)=0
          offset(2)=h5dims(2)-data_dims(2)
          !
          ! Select hyperslab in the dataset.
          !
          CALL h5sselect_hyperslab_f(h5space_id, H5S_SELECT_SET_F,      &
     &                               offset, data_dims , h5error)
          CALL h5screate_simple_f(h5rank, data_dims, memspace, h5error) 
+if debug
      write (lout,*) "DBG HDFw",h5dims,"off",offset,"ddims",data_dims
+ei
          CALL H5dwrite_f(h5set_id, H5T_NATIVE_REAL, data_in2,          &
            data_dims, h5error,file_space_id = h5space_id, mem_space_id &
     &       = memspace)
      END SUBROUTINE WRITETOFILE
      END MODULE SIXTRACKHDF5
     
      !>
      !! @todo attribute (header) not yet working...
      !< 
      SUBROUTINE INITHDF5
        USE SIXTRACKHDF5

        CHARACTER(LEN=9), PARAMETER :: aname = "header"   ! Attribute name

        INTEGER(HID_T) :: attr_id       ! Attribute identifier 
        INTEGER(HID_T) :: aspace_id     ! Attribute Dataspace identifier 
        INTEGER(HID_T) :: atype_id      ! Attribute Dataspace identifier 
        INTEGER(HSIZE_T) :: adims = 1   ! Attribute dimension
        INTEGER     ::   arank = 1      ! Attribure rank
        INTEGER(SIZE_T) :: attrlen      ! Length of the attribute string

        CHARACTER*80 ::  attr_data      ! Attribute data
        attr_data = "1=pid 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=DE/E 9=type"
        attrlen = 80
        h5dims=(/9,0/)

          !Initialize FORTRAN predifined datatypes
          CALL h5open_f(h5error) 

          CALL h5fcreate_f(HFNAME, H5F_ACC_TRUNC_F, hfile_id, h5error)
          
          !Create the data space with unlimited length.
          maxdims = (/INT(9,HSIZE_T), H5S_UNLIMITED_F/)
          CALL h5screate_simple_f(h5rank, h5dims, h5space_id,           &
     &      h5error, maxdims)
          !Modify dataset creation properties, i.e. enable chunking
          CALL h5pcreate_f(H5P_DATASET_CREATE_F, crp_list, h5error)
          CALL h5pset_deflate_f (crp_list, 4, h5error)
          
          data_dims=(/9,incr/)
          CALL h5pset_chunk_f(crp_list, h5rank, data_dims, h5error)
          
          !Create a dataset with 9Xunlimited dimensions using cparms creation properties .
          CALL h5dcreate_f(hfile_id, h5setname, H5T_NATIVE_REAL,        &
     &                     h5space_id, h5set_id, h5error, crp_list )

          ! Create datatype for the attribute.
          CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, h5error)
          CALL h5tset_size_f(atype_id, attrlen, h5error)

          !Create a dataspace for the attribute
          CALL h5screate_f(H5S_SCALAR_F,aspace_id,h5error)

          ! Create dataset attribute.
          CALL h5acreate_f(h5set_id, aname, atype_id, aspace_id,        &
     &                     attr_id, h5error)
          
          ! Write the attribute data.
          data_dims(1) = 1
          CALL h5awrite_f                                               &
     &    (attr_id, atype_id, attr_data, data_dims, h5error)
          data_dims(1) = 9
          ! Close the attribute. 
          CALL h5aclose_f(attr_id, h5error)
    
      END SUBROUTINE INITHDF5

      SUBROUTINE APPENDREADING(pid,turn,s,x,xp,y,yp,dee,typ)
       USE SIXTRACKHDF5
       INTEGER turn,pid,typ
       DOUBLE PRECISION x,xp,y,yp,dee,s
+if debug
+ca crcoall
+ei

+if debug
      write (lout,*) "DBG HDF app: using position mod(h5dims(2),incr)", &
      & mod(h5dims(2),incr)
+ei
       data_in2(1,mod(h5dims(2),incr) + 1)=pid
       data_in2(2,mod(h5dims(2),incr) + 1)=turn
       data_in2(3,mod(h5dims(2),incr) + 1)=s
       data_in2(4,mod(h5dims(2),incr) + 1)=x
       data_in2(5,mod(h5dims(2),incr) + 1)=xp
       data_in2(6,mod(h5dims(2),incr) + 1)=y
       data_in2(7,mod(h5dims(2),incr) + 1)=yp
       data_in2(8,mod(h5dims(2),incr) + 1)=dee
       data_in2(9,mod(h5dims(2),incr) + 1)=typ

       h5dims(2)=h5dims(2)+1
+if debug
       write (lout,*) "DBG HDF app: h5dims(2) now,", h5dims(2)
+ei

+if debug
!rkwee
       write (lout,*) "DBG HDF app: data_in2[-1]", pid, turn, &
       & s, x, xp, y, yp, dee, typ
+ei
          !
          !Extend the dataset. Dataset becomes 10 x 3.
          !
          if (mod(h5dims(2),incr).eq.0) then
              CALL WRITETOFILE()
          endif
      END SUBROUTINE APPENDREADING
      
      SUBROUTINE CLOSEHDF5
       USE SIXTRACKHDF5
        
          if (mod(h5dims(2),incr).ne.0) then
              CALL WRITETOFILE()
          endif

       !
       ! End access to the dataset and release resources used by it.
       !
       CALL h5dclose_f(h5set_id, h5error)
  
       !
       ! Terminate access to the data space.
       !
       CALL h5sclose_f(h5space_id, h5error)
     
       !
       ! Close the file.
       !
       CALL h5fclose_f(hfile_id, h5error)
  
       !
       ! Close FORTRAN interface.
       !
       CALL h5close_f(h5error)
      END SUBROUTINE CLOSEHDF5
+ei
+dk beamGasK
+if .not.beamgas
      subroutine nobeamgasactive
+ca crcoall
      write(lout,*) &
      "Dummy routine in beamgas.f if beamgas module off"
      end subroutine
+ei
+if beamgas
!>
!! @brief Module containing constants for beamgas part
!!
!<
      module beamgascommon
!       common to beamGasInit and beamGas
      integer, parameter :: bgmaxx=40000,bamount=1000
      integer bgmax,bgid,bgiddb(bgmaxx),ibgloc,pressID,njobs,njobthis,  &
     &        dpmjetevents
      real pressARRAY(2,bgmaxx)
!       bgParameters are s_null, n_null and n_here
!       these values are needed to know when enough particles are scattered
!       at a given point
!       s_null tells you how far the scattering process has gone so far
!       required that s_now > s_null (move s_null to s_now+ small delta
!       afterwards)
!       n_null tells you how many particles are scattered in previous gas
!       elements
!       n_here is a counter telling you how many particles are scattered
!       at this location
      double precision bgParameters(3)
      real bgxpdb(bgmaxx),bgypdb(bgmaxx),bgEdb(bgmaxx)
      end module beamgascommon

      module lorentzcommon
      ! Common to lorentzBoost and createLorentzMatrix
      double precision lorentzmatrix(4,4),new4MomCoord(4)
      end module lorentzcommon
!>
!! \brief YIL subroutine beam gas scattering process.
!!
!! 
!! This is a part of the inclusion of beam gas simulation for sixtrack
!!
!! Any "pressure element" (i.e. an element starting with\n
!! press) should call this function.\n
!! It will cycle through all primary particles and\n
!! scatter according to rules generated.
!! 
!! @author Yngve Inntjore Levinsen <yngve.inntjore.levinsen@cern.ch>
!!
!! @date Last modified 21. Jul. 2010
!!
!!
!! \param myix The block ID number
!! \param secondary This is the array that tells which of the 64 particles are secondaries
!! \param totals This is the position around the ring, calculated from the start flag in fort.2
!! \param myenom This is an array with the energy of the 64 particles
!! \param ipart This is an array with the id number of each particle
!!
!! \warning This is the one-turn version
!! \return The subroutine does not return anything
!! \see thin6d, beamGasInit and rotateMatrix
!< 
      subroutine beamGas( myix, secondary, totals, myenom, ipart )      
!BELOW YOU FIND NEW ADDITIONS:
      use beamgascommon
      use lorentzcommon
      implicit none
!YIL: parnum
!+ca parnum

!YIL: parpro
+ca parpro

!YIL: parbeam
+ca parbeam

!YIL: collpara
+ca collpara

!YIL: COMMON
+ca common

!YIL: COMMONMN
+ca commonmn

!~: commonm1
+ca commonm1

!YIL: INFO
+ca info

!YIL: DBCOMMON
+ca dbcommon

!YIL: commontr
+ca commontr

+ca crcoall

!YIL: This is leftovers that does not have a cd-block

      !YIL need to save, this is input variable
      double precision myenom
      integer ipart(npart)
      
      !YIL: think this probably should be saved as well...
      integer   mynp
      common /mynp/ mynp

!These are local subroutine stuff
      double precision totals,oldCoordinates(5),protonmass,             &
     & totMomentum, doLorentz,tmpPX,tmpPY
      

      integer choice,myix
      double precision rotm(3,3), z(3),ztmp(3) ! the variable used to store rotation matrix and coordinates
!       CHECK: Is ichar('0')=48 and so on for all systems??
      
      integer i,j,k,i_tmp
      
      pressID=0
      j=1
      do while (pressID.eq.0.and.j.le.bgmaxx)
       if ((pressARRAY(1,j).gt.(totals-0.01)).and.                      &
     &     (pressARRAY(1,j).le.(totals+0.01)))                          &
     &          pressID=j
        j=j+1
      enddo
      if (pressID.eq.0) then
       write(lout,*) 'Couldnt find pressure marker at',totals
       stop
      endif
      
      doLorentz=0
      if ((abs(yv(1,1)).gt.3e-3).or.(abs(yv(2,1)).gt.3e-3)) then ! do a Lorentz boost of DPMJET events
       !YIL warning: hardcoded mass of protons:
       protonmass=938.3
       doLorentz=1
        tmpPX=yv(1,1) !don't think I can send array elements to functions??
        tmpPY=yv(2,1)
        call createLorentzMatrix(myenom,tmpPX,tmpPY,protonmass)
      endif
      do j = 2,napx
      choice=0
      if ((secondary(j).eq.0).and.(part_abs(j).eq.0).and.               &
     &      (bgParameters(1).le.totals)) then   
+if debug
      write(lout,*) 'DEBUG> BG scattering: ',j,bgParameters(3)+1,          &
     & pressARRAY(2,pressID)*njobs*dpmjetevents
+ei
  668 continue
!       Warning: We round DOWN to the nearest integer at each 
!       location. It is needed in order not to run out of particles
!       In generate_pmarkers.py the normalized sum is accordingly changed to 1
      if ((pressARRAY(2,pressID)*njobs*dpmjetevents).gt.                &
     &    (bgParameters(3)+1)) then
      bgParameters(3)=bgParameters(3)+1
      if (((bgParameters(2)+bgParameters(3)).gt.(dpmjetevents*njobthis))&
     & .and.((bgParameters(2)+bgParameters(3)).le.                      &
     & (dpmjetevents*(njobthis+1)))) then
!       The scattering id is increased by one for each interaction
      bgid=bgid+1
      
      do while (bgid.gt.bgiddb(ibgloc))
!       get to the right place in the lists
         ibgloc=ibgloc+1
      enddo
      
      if(bgid.lt.bgiddb(ibgloc)) then ! no proton for this scattering event
!       check that this works correctly!!!!!!
         write(777,*) ipart(j)+100*samplenumber,iturn,totals,xv(1,j),   &
     &      yv(1,j),xv(2,j),yv(2,j),mys(j),(0-myenom)/myenom,           &
     &      bgid+njobthis*dpmjetevents
!       writing down the scattering location information
      write(667,*) ipart(j)+100*samplenumber,iturn,totals,xv(1,j),      &
     &   yv(1,j),xv(2,j),yv(2,j),sigmv(j),ejv(j),                       &
     &   bgid+njobthis*dpmjetevents,bgid,ejv(j),xv(1,j),xv(2,j),yv(1,j),&
     &   yv(2,j)
         part_abs(j) = 1
      goto 669
      endif
      if(bgid.eq.bgiddb(ibgloc)) then ! a proton was found for this scattering event

            choice=ibgloc
!        If several protons, the one with max energy is used
!        THIS IS NECESSARY SINCE ALL PROTONS ARE READ INTO LIST!
      do i_tmp = 1,10
        if (bgiddb(choice).ne.bgiddb(ibgloc+i_tmp)) then
          exit
        endif
        if (bgEdb(ibgloc+i_tmp).gt.bgEdb(choice)) then
          choice=ibgloc+i_tmp
        endif  
      end do

         
         oldCoordinates(1)=yv(1,j)
         oldCoordinates(2)=yv(2,j)
         oldCoordinates(3)=ejv(j)
         oldCoordinates(4)=xv(1,j)
         oldCoordinates(5)=xv(2,j)
         
         if(doLorentz.eq.1d0) then ! we need to boost the dpmjet event first:
         totMomentum=sqrt(bgEdb(choice)**2-(protonmass*1e-3)**2)
         tmpPX=bgxpdb(choice)*totMomentum
         tmpPY=bgypdb(choice)*totMomentum
         protonmass=protonmass*1e-3
         call lorentzBoost(tmpPX,tmpPY,totMomentum,protonmass)
         protonmass=protonmass*1e3
!         This returns E,px,py,pz, need xp,yp
         totMomentum=sqrt(new4MomCoord(2)**2+new4MomCoord(3)**2+        &
     &    new4MomCoord(4)**2)
         call rotateMatrix(yv(1,1),yv(2,1),rotm) !we also need to "rotate back" before we're in the "same state"
         z(1) = (new4MomCoord(2)/totMomentum)
         z(2) = (new4MomCoord(3)/totMomentum)
         z(3) = (new4MomCoord(4)/totMomentum)
!          rotating the vector into the orbit reference system:
         z = matmul(rotm,z)
          if (z(3).eq.0) then
           write(lout,*) "ERROR> there is something wrong",             &
     &      " with your dpmjet event", bgiddb(choice),totMomentum,      &
     &      new4MomCoord
           stop
          else
!           boosted xp event
           bgxpdb(choice) = z(1)
!           boosted yp event
           bgypdb(choice) = z(2)
           bgEdb(choice) = new4MomCoord(1) ! boosted energy
! DEBUG: 
!         write(684,*) bgxpdb(choice),bgypdb(choice),bgEdb(choice),      &
!     &     new4MomCoord
! END DEBUG
          endif
         endif ! doLorentz
         call rotateMatrix(yv(1,j),yv(2,j),rotm)
!          creating resulting vector [x,y,z] from dpmjet:
         z(1) = (bgxpdb(choice)) ! this is correct, since dpmjet gives xp=px/p and so on...
         z(2) = (bgypdb(choice))
         z(3) = sqrt(1-z(1)**2-z(2)**2)
         
!          rotating the vector into the orbit reference system:
          ztmp=z
          z=matmul(rotm,z)
!                adding the angles to the yv vector:
      if (z(3).eq.0) then
        yv(1,j) = acos(0.0)*1e3
        yv(2,j) = 1.0*yv(1,j)
      else
!        xp
        yv(1,j) = atan(z(1)/z(3))*1e3
!        yp
        yv(2,j) = atan(z(2)/z(3))*1e3
      endif
!        energy WARNING: I DO NOT KNOW ALL THE PLACES I NEED TO INSERT THE ENERGY????
         ejv(j) = bgEdb(choice)*1000
!YIL Copied this here, think these are all variables in need of an update
!++  Energy update, as recommended by Frank [comment from collimat part]
!
         ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
         rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
         dpsv(j)=(ejfv(j)-e0f)/e0f
         oidpsv(j)=1.0/(1.0+dpsv(j))
         dpsv1(j)=dpsv(j)*1.0d3*oidpsv(j)
      
!       writing down the scattering location information
      write(667,*) ipart(j)+100*samplenumber,iturn,totals,xv(1,j),      &
     &   yv(1,j),xv(2,j),yv(2,j),sigmv(j),oldCoordinates(3),            &
     &   bgid+njobthis*dpmjetevents,bgid,ejv(j),oldCoordinates(4),      &
     &   oldCoordinates(5),oldCoordinates(1),oldCoordinates(2)
         secondary(j)=1
         
!       if bgid.eq.bgiddb(ibgloc) end statement
      endif
      
!       if njob correct range statement
      else if((bgParameters(2)+bgParameters(3)).le.                     &
     &   (dpmjetevents*njobthis)) then
      goto 668
      endif
!       if (pressARRAY(2,pressID)*njobs*dpmjetevents).gt.(bgParameters(3)+1)
      else
      bgParameters(1) = totals+0.001
      bgParameters(2) = bgParameters(2)+bgParameters(3)
      bgParameters(3) = 0
!       if (pressARRAY(2,pressID)*njobs*dpmjetevents).gt.(bgParameters(3)+1)
      endif
!       check secondary if statement
      endif
!       end j=1,napx statement
  669 continue
      enddo
      end subroutine
      
      
!>
!! \brief YIL subroutine beam gas initiation.
!!
!! This function must be called during the initialization of\n
!! the simulation, if beam gas should be included.
!! 
!! @author Yngve Inntjore Levinsen <yngve.inntjore.levinsen@cern.ch>
!!
!! @date Last updated 25. July 2009
!!
!! \warning This is the version with scattering only in first turn
!! \param myenom Needs to know nom. energy to know which events to skip
!! \return The subroutine does not return anything
!! \see beamGas and maincr
!! \todo pressure marker ID not used anymore, should be removed
!< 
      subroutine beamGasInit(myenom)
      
      use beamgascommon
      IMPLICIT NONE

+ca crcoall
      
      integer check,j,i
      double precision myenom,minenergy

      integer   mynp
      common /mynp/ mynp
      
      character*11 bg_var
      integer filereaderror, previousEvent,numberOfEvents
      real bg_val,ecutoff,pPOS,pVAL

      write(lout,*) '************************'
      write(lout,*) '****                 ***'
      write(lout,*) '***Beam gas initiation**'
      write(lout,*) '****      YIL        ***'
      write(lout,*) '************************'
      write(lout,*) ''
      
! DEBUG: open debug file...      
!      open(684,file='debugfile.txt')
! END DEBUG
      open(666,file='dpmjet.eve')
      open(667,file='scatterLOC.txt')
      write(667,*)'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=z 9=E',      &
     & ' 10=eventID 11=dpmjetID 12=newEnergy 13=oldX 14=oldY 15=oldXP   & 
     & 16=oldYP'
      write(667,*)'# These are original coordinates of proton after impa&
     &ct, and old xp,yp'
      write(667,*)
      

!       initialize pressure markers array
!       DO THIS BEFORE OTHER STUFF, AS YOU MIGHT DO STUPID THINGS TO VARIABLES
!       (LEARNED THE HARD WAY!!!)
      open(778,file='beamgas_config.txt')
      open(779,file='pressure_profile.txt')
      filereaderror=0
      do
         read(778,*,IOSTAT=filereaderror) bg_var, bg_val
      if (filereaderror.lt.0) then
!       end of file
         exit
      else if (filereaderror.eq.0.and.bg_var.eq.'thisjob') then
        njobthis = bg_val
      else if (filereaderror.eq.0.and.bg_var.eq.'njobs') then
        njobs = bg_val
      else if (filereaderror.eq.0.and.bg_var.eq.'dpmjetev') then
        dpmjetevents = bg_val
      else if (filereaderror.eq.0.and.bg_var.eq.'ecutoff') then
        ecutoff = bg_val
      end if
      end do 
      j=1
      do
         read(779,*,IOSTAT=filereaderror) pPOS, pVAL
      if (filereaderror.eq.0) then
      pressARRAY(1,j)=pPOS
      pressARRAY(2,j)=pVAL
      j=j+1
       if (j>bgmaxx) then
         write(lout,*) 'ERROR> Too many pressure markers!'
         stop
       endif
      else if (filereaderror.lt.0) then
!       means that end of file is reached
         exit
      else if (filereaderror.gt.0) then
!       means that this line did not correspond to normal input
!       do not need to perform anything (probably a comment line)
      end if
      end do
      do 1328 i = j,bgmaxx
       pressARRAY(1,i)=-1.0
       pressARRAY(2,i)=0.0
1328  continue
!       count the number of lines in dpmjet
      j=1
      previousEvent=0
      numberOfEvents=0
!       Here you can set the energy acceptance (0.95 means at least 95% of nominal energy)
!       0.001 is because minenergy must be in GeV whereas myenom is in MeV
!       Note to self: Remember to update this in batchrun.sh immediately! :)
      minenergy=ecutoff*myenom*0.001
      filereaderror=0
      do
!          2212 is the proton id. We do not load other particles.
!          The other particles will be used to generate a complete file
!          afterwards.
!          ONLY LOAD PROTONS WITH ENERGY OFFSET BELOW 5%!!
         read(666,*,IOSTAT=filereaderror) bgiddb(j), check, bgxpdb(j),  &
     &      bgypdb(j), bgEdb(j)
         if (check.eq.2212.and.bgEdb(j).gt.minenergy) then
            if (bgiddb(j).ne.previousEvent) then
               previousEvent=bgiddb(j)
               numberOfEvents=numberOfEvents+1
            endif
            j=j+1
         endif
         if (filereaderror.lt.0) exit
!        If we have more events in the dpmjet file than
!        what we are supposed to simulate, we stop here...
         if (previousEvent.gt.dpmjetevents) exit
         if (numberOfEvents.gt.(bgmaxx-1)) then
         write(lout,*) 'ERROR> Too many dpmjet events!'
         stop
      endif
      enddo
!       number of lines in dpmjet - 1
      bgmax=j
      close(666)
      write(lout,*) 'INFO> Trackable events in dpmjet.eve: ', bgmax-1
      if (numberOfEvents.gt.mynp) then 
         write(lout,*) 'ERROR> You need to generate less dpmjet events!'
         write(lout,*) 'ERROR> There were too many trackable events...'
         write(lout,*) 'ERROR> Maximum for this sixtrack run is: ',mynp
         write(lout,*) 'ERROR> You generated ',numberOfEvents,' trackable  &
     &events'
         stop
      endif
      write(lout,*) 'INFO> This is job number: ', njobthis
      write(lout,*) 'INFO> Total number of jobs is: ', njobs
      write(lout,*) 'INFO> Total number of particles in simulation: ',     &
     &   njobs*dpmjetevents
      close(778)
      open(777,file='localLOSSES.txt')
      write(777,*)                                                      &
     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=z 9=DE/E 10=CollisionID'
      write(777,*) '# Note that name is not unique, but CollisionID is'
      write(777,*) '# Note that s is particle coordinate, not bunch     &
     & coordinate'
      
!       YOU HAVE TO PUT THESE INITIALIZATIONS AT THE END OF THE ROUTINE
!       FOR SOME STRANGE FORTRAN-REASON
      bgParameters(1)=0.0
      bgParameters(2)=0.0
      bgParameters(3)=0.0
      
      bgid=0
      check=0
      ibgloc=1
      
      end subroutine
      
!> \brief The routine returns a 3x3 rotation matrix for cartesian coordinates
!! 
!! The function rotates cartesian coordinates based on an angle of the old and new\n
!! z-axis in the xz-plane (ax) and yz-plane (ay), given in milliradians. Typically\n
!! a particle with a small offset from the closed orbit (z-direction)
!! 
!! @author Yngve Inntjore Levinsen <yngve.inntjore.levinsen@cern.ch>
!!
!! @date Last modified: 26. Mar. 2010
!! 
!! \warning The angles of the particle should be in rad even though ax and ay
!! are in millirad! Dpmjet uses rad while sixtrack stores xp,yp in millirad!
!! \warning edit Mar10: changed sign of entire matrix, think it was wrong?
!! \param ax Angle in x-direction [millirad]
!! \param ay Angle in y-direction [millirad]
!! \param matrix 3x3 array which will contain the returned rotation matrix
!! 
!! \return The subroutine returns a 3x3 rotation matrix
!! \see beamGas
!!
!<
      subroutine rotateMatrix(ax,ay,matrix)
      double precision matrix(3,3)
      double precision sinax, sinay, cosax, cosay
      double precision ax,ay
      
      sinax = sin(ax*0.001)
      cosax = cos(ax*0.001)
      sinay = sin(ay*0.001)
      cosay = cos(ay*0.001)
      
      matrix(1,1)=cosax
      matrix(1,2)=-sinax*sinay
      matrix(1,3)=sinax*cosay
      
      matrix(2,1)=-sinax*sinay
      matrix(2,2)=cosay
      matrix(2,3)=sinay*cosax
      
      
      matrix(3,1)=-sinax
      matrix(3,2)=-sinay
      matrix(3,3)=cosax*cosay
      end subroutine

!>
!! \brief Performs Lorentz boost on a given coordinate set
!!
!! This code performs a Lorentz boost on the coordinates px,py,E
!! The Lorentz transfer matrix must be initialized first, using subroutine
!! createLorentzMatrix.
!! 
!! @author Yngve Inntjore Levinsen <yngve.inntjore.levinsen@cern.ch>
!!
!! @date Last modified 28. July 2010
!!
!!
!! \param px [GeV] Momentum in x-direction
!! \param py [GeV] Momentum in y-direction
!! \param p [GeV] Total particle momentum
!! \param mass [GeV] Particle mass
!!
!! \return new4MomCoord will contain the 4-momentum coordinates after boost
!! \see createLorentzMatrix
!< 
      subroutine lorentzBoost(px,py,ptot,mass)
      
      use lorentzcommon
      implicit none
       
       double precision px,py,ptot,mass
       double precision oldcoord(4)

       integer i,j
       
       
       oldcoord(1)=sqrt(ptot**2+mass**2)
       oldcoord(2)=px
       oldcoord(3)=py
       oldcoord(4)=sqrt(ptot**2-px**2-py**2) ! E/c, px,py,pz
       do j=1,4 
        new4MomCoord(j)=0.0
       enddo
       
       ! Matrix multiplication: 
       do i=1,4
         do j=1,4
         new4MomCoord(i)=new4MomCoord(i)+lorentzmatrix(i,j)*oldcoord(j)
         enddo
       enddo        
!        write(*,*)
!        write(*,*) "DEBUG, n4M: ", new4MomCoord
!        write(*,*)
!        do i=1,4
!         write(*,*) "DEBUG, lM: ", lorentzmatrix(i,1:4)
!        enddo
      end subroutine 
!>
!! \brief Creates Lorentz transform matrix
!!
!! This subroutine sets up (or updates) the Lorentz matrix
!! used for Lorentz boost. This Lorentz boost is used for 
!! implementing the crossing angle in distributions that
!! are coming from head-on collisions. Used for IR cross talk.
!! Because the boost shouldn't increase the energy of the distribution,
!! the entire matrix is divided by the gamma factor!
!!  
!! @author Yngve Inntjore Levinsen <yngve.inntjore.levinsen@cern.ch>
!!
!! @date Last modified 28. July 2010
!!
!!
!! \param E [MeV] energy of the BEAM
!! \param xp [mrad] forward cosine in x-direction of the ORBIT coordinates
!! \param yp [mrad] forward cosine in y-direction of the ORBIT coordinates
!! \param mass [MeV] mass of the particle type
!!
!! \return Nothing
!! \warning Matrix divided by gamma factor!
!! \see lorentzBoost
!< 
      subroutine createLorentzMatrix(E,xp,yp,mass)
       use lorentzcommon
       implicit none

       double precision E,xp,yp,mass
       ! local variables:
       double precision v0,gpart,p0,b(3),b2,b2inv,g

       integer i,j
        
        gpart=E/mass ! relativistic gamma for the particles
        p0=sqrt(E**2-mass**2)
        v0=p0/(gpart*mass)
! !         print v0
        b(1)=xp*1e-3*v0 ! relativistic beta...
        b(2)=yp*1e-3*v0
        b(3)=0.0 ! Assumed no movement of CM in longitudinal direction...
        b2=0.0
        do j=1,3
         b2=b2+b(j)*b(j)
        enddo
        if (b2>0) then
         b2inv=1/b2
        else
         b2inv=0
                endif
        g=1.0/sqrt(1.0-b2) ! relativistic gamma for the boost
!         write(*,*) "DEBUG, g: ",g, v0, xp,yp,E,mass

                lorentzmatrix(1,1)=g /g
      do j=2,4 
       lorentzmatrix(1,j)=g /g
        lorentzmatrix(1,j)=-b(j-1)*g /g
        lorentzmatrix(j,1)=-b(j-1)*g /g
        
        lorentzmatrix(j,j) = (1.0 + (g-1.0)* b(j-1)**2*b2inv) /g
      enddo
!         
        lorentzmatrix(2,3) = ((g-1)* b(1)*b(2)*b2inv) /g
        lorentzmatrix(3,2) = (lorentzmatrix(2,3)) /g
        
        lorentzmatrix(2,4) = ((g-1)* b(1)*b(3)*b2inv) /g
        lorentzmatrix(4,2) = (lorentzmatrix(2,4)) /g
        
        lorentzmatrix(3,4) = ((g-1)* b(2)*b(3)*b2inv) /g
        lorentzmatrix(4,3) = (lorentzmatrix(3,4)) /g
        
!        do i=1,4
!         write(*,*) "DEBUG,lMAT: ", lorentzmatrix(i,1:4)
!        enddo
      end subroutine


+ei
