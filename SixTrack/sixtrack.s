+cd version
      character(len=8) version  !Keep data type in sync with 'cr_version'
      character(len=10) moddate !Keep data type in sync with 'cr_moddate'
      integer itot,ttot
      data version /'4.7.17'/
      data moddate /'07.11.2017'/
+cd license
!!SixTrack
!!
!The code contains the SixTrack particle simulation code written by
!!F. Schmidt, DESY, CERN
!!E. Mcintosh, H. Ranshall, H. Grote, F. James,
!!K. Koelbig, K. Heinemann, M. Vaenttinen,
!!R. Assman, C. Bracco, R. Bruce, D. Mirarchi, V. Previtali,
!!S. Redaelli, G. Robert-Demolaize, E. Quaranta
!!A. Rossi, C. Tambasco, T. Weiler,
!!J. Barranco, Y. Sun, Y. Levinsen, M. Fjellstrom,
!!A. Santamaria, R. Kwee-Hinzmann, A. Mereghetti, K. Sjobak,
!!M. Fiascaris, J.F. Wagner, J. Wretborn, V.K. Berglyd Olsen, CERN
!!M. Fitterer, FNAL, CERN
!!A. Patapenka,  NIU, CERN
!!G. Robert-Demolaize, BNL
!!V. Gupta, Google Summer of Code (GSoC)
!!J. Molson UMAN, LAL, CERN
!!S. Kostoglou, NTUA, CERN
!!
!!Copyright 2014 CERN. This software is distributed under the terms of the GNU
!!Lesser General Public License version 2.1, copied verbatim in the file
!!``COPYING''.
!!
!!In applying this licence, CERN does not waive the privileges and immunities
!!granted to it by virtue of its status as an Intergovernmental Organization or
!!submit itself to any jurisdiction.
+cd rhicelens
!GRDRHIC
      real(kind=fPrec) tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz),totals,sampl(nblz)
      integer ielem
      integer namepart(npart)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy,sampl,namepart,totals
+if bnlelens
!GRDRHIC
!GRD-042008
      real(kind=fPrec) twojx,twojy,twojr,sumtwojx,sumtwojy,             &
     &sumsquarex,sumsquarey,x_temp,xp_temp,y_temp,yp_temp
      real(kind=fPrec) limit_twojx,limit_twojy,limit_twojr
      integer n_cut,n_nocut
      common /cumulsigma/ twojx,twojy,twojr,sumtwojx,sumtwojy,          &
     &sumsquarex,sumsquarey,x_temp,xp_temp,y_temp,yp_temp,n_cut,n_nocut,&
     &limit_twojx,limit_twojy,limit_twojr
      integer napx00
      parameter (napx00=64)
      integer   mynp
      common /mynp/ mynp
      real(kind=fPrec) myx,myxp,myy,myyp,myp,mys
      common /coord/ myx(npart),myxp(npart),myy(npart),myyp(npart),     &
     &myp(npart),mys(npart)
      integer   samplenumber
      common /samplenumber/ samplenumber
!GRD-042008
!GRDRHIC
+ei
+cd bnlio
! This is empty if -crlibm and causes a problem with astuce
! if +crlibm we define parameters for dtostr
+if crlibm
      character(len=8192) ch
      character(len=25) ch1
      integer errno,l1,l2
      integer dtostr
+ei
+cd errout
!     Set the exit status in case of an error.
      integer errout_status
      common /errout/ errout_status
+cd commtim
      real r1,timestart,timenow
      common /mytimes/timestart
+cd crco
      integer sixrecs,binrec,binrecs,bnlrec,bllrec,numlcr
      logical rerun,start,restart,checkp,fort95,fort96,read95,read96
      character(len=1024) arecord
      character(len=20) stxt
      character(len=80) runtim
! Note order of placement in COMMON crdata is important
! for the alignment of the data
      common /crdata/                                                   &
     &sixrecs,binrec,binrecs((npart+1)/2),bnlrec,bllrec,                &
     &numlcr,rerun,start,restart,checkp,                                &
     &fort95,fort96,read95,read96,arecord,stxt,runtim
      integer crnumlcr,crnuml,crnapxo,crnapx,crnumxv,crnnumxv,crnlostp, &
     &crsixrecs,crbinrec,crbinrecs,crbnlrec,crbllrec,cril
      logical crpstop,crsythck
      real crtime3
      real(kind=fPrec) cre0,crxv,cryv,crsigmv,crdpsv,crdpsv1,crejv,     &
     &crejfv,craperv,crxvl,cryvl,crdpsvl,crejvl,crsigmvl

      character(len=8)  cr_version !Keep data type in sync with 'version'
      character(len=10) cr_moddate !Keep data type in sync with 'moddate'
+if bnlelens
!GRDRHIC
!GRD-042008
      integer crnamepart,crn_nocut,crn_cut
      real(kind=fPrec) crtotals,crsumtwojx,crsumtwojy,                  &
     &crsumsquarex,crsumsquarey,                                        &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr
!GRDRHIC
!GRD-042008
+ei
      common/crio/                                                      &
     &cre0,crxv(2,npart),cryv(2,npart),                                 &
     &crsigmv(npart),crdpsv(npart),crdpsv1(npart),crejv(npart),         &
     &crejfv(npart),craperv(npart,2),crxvl(2,npart),cryvl(2,npart),     &
     &crdpsvl(npart),crejvl(npart),crsigmvl(npart),                     &
+if bnlelens
!GRDRHIC
!GRD-042008
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
!GRDRHIC
!GRD-042008
+ei
     &            crsixrecs,crbinrec,crbinrecs((npart+1)/2),crbnlrec,   &
     &crbllrec,cril,                                                    &
     &crnumlcr,crnuml,crsythck,                                         &
     &                crtime3,                                          &
     &crnapxo,crnapx,                                                   &
+if .not.bnlelens
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart)
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart),    &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crnamepart(npart)
!GRDRHIC
!GRD-042008
+ei

+cd parpro
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
+if .not.bignpart.and..not.hugenpart
      parameter(npart = 64,nmac = 1)
+ei
+if bignpart.and..not.hugenpart
!See also:
! - subroutine wzsubv
      parameter(npart = 2048,nmac = 1)
+ei
+if hugenpart.and..not.bignpart
!See also:
! - subroutine wzsubv
      parameter(npart = 65536,nmac = 1)
+ei

!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag" version:
! 6000/20000 -> 30% multipoles
+if .not.collimat
+if bignblz
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=200000,        &
     &nzfz = 3000000,mmul = 20) !up to 60'000 multipoles
+ei
+if hugenblz
      parameter(nele=1200,nblo=600,nper=16,nelb=280,nblz=400000,        &
     &nzfz = 6000000,mmul = 20) !up to 120'000 multipoles -> 48MB/nzfz-array (20%)
+ei
+if .not.bignblz.and..not.hugenblz
      parameter(nele=1200,nblo=600,nper=16,nelb=140,nblz=20000,         &
     &nzfz = 300000,mmul = 20) !up to 6'000 multipoles
+ei
+ei ! / not collimat
+if collimat
+if beamgas
      parameter(nele=50000,nblo=10000,nper=16,nelb=140,nblz=200000,     &
     &nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / beamgas
+if .not.beamgas
+if bignblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=200000,        &
     &nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / bignblz
+if hugenblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=400000,        &
     &nzfz = 3840000,mmul = 11) !up to 120'000 multipoles (20%)
+ei ! / hugenblz
+if .not.bignblz.and..not.hugenblz
      parameter(nele=5000,nblo=400,nper=16,nelb=140,nblz=15000,         &
     &nzfz = 144000,mmul = 11) !up to 4500 multipoles
+ei ! / not bignblz
+ei ! / not beamgas
+ei ! / collimat

+if collimat
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
+ei
+if .not.collimat
      parameter(nran = 2000000,ncom = 100,mran = 500,mpa = 6,nrco = 5,  &
+ei
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20)
+if .not.bignblz.and..not.hugenblz
      parameter(nbb = 350)
+ei
+if bignblz.or.hugenblz
      parameter(nbb = 500)
+ei
+cd parbeam
      integer idim,kstep,nx,ny
      real(kind=fPrec) h,hrecip,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77_fPrec, ycut = 7.46_fPrec )
      parameter ( h = 1.0_fPrec/63.0_fPrec )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
+cd parbeam_exp
      integer beam_expflag      ! 0: Old BEAM block, 1: New BEAM::EXPERT
      logical beam_expfile_open ! have we opened the file 'beam_expert.txt'?
      common /beam_exp/ beam_expflag, beam_expfile_open
+cd beamdim
      real(kind=fPrec) cc,xlim,ylim
      parameter(cc = 1.12837916709551_fPrec)
      parameter(xlim = 5.33_fPrec)
      parameter(ylim = 4.29_fPrec)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
+cd common
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      
      real(kind=fPrec) a,ak0,aka,alfx,alfz,amp0,aper,bbcu,              &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,         &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4

+if time
      real(kind=fPrec) tcnst35,exterr35,zfz35
      integer icext35
+ei
      real hmal
      character(len=16) bez,bezb,bezr,erbez,bezl
      character(len=80) toptit,sixtit,commen !DANGER: If the len changes, CRCHECK will break.
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
+if time
      common/rand35/exterr35(nblz,40),icext35(nblz),zfz35(nzfz),        &
     &tcnst35(nblz)
+ei
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,18),track6d(6,npart),    &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
! wire parameters for closed orbit calculation (FOX part)
! for FOX length of variable names must be smaller 8
      integer, parameter :: wire_max = 350 ! max. number of wires (same as BB interactions)
      real(kind=fPrec) wire_clo            ! closed orbit at wire
      real(kind=fPrec) wireclo0         ! initial coordinates for closed orbit
      integer wire_num_aux              ! auxiliary variable to count number of wires
      integer wire_num                  ! wire number for each structure element (default = 0 if no wire)
      common/wireco/ wire_clo(6,wire_max),wire_num(nblz)
+cd comApeInfo
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 28-11-2016
!     always in main code
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character(len=16) aper_filename             ! name of the output file
      integer loadunit                       ! unit for the external load file
      character(len=16) load_file             ! name of the external load file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost
      integer plost
!     flag for killing particles at the aperture check or let them live
      logical apflag
      logical lexist
      real(kind=fPrec) ape
+if .not.backtrk
      common/apert/ ape(7,nele),kape(nele),lapeofftlt(nele),            &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,     &
     &  apflag, load_file, loadunit
+ei
+if backtrk
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 24-11-2016
!     NB: add also temporary variables for back-tracking
!         inserted in main code by the 'backtrk' compilation flag
      common/apert/ ape(7,nele),kape(nele),lapeofftlt(nele),            &
     &  plost(npart), yold(2,npart), apold(7), sold, bktpre, kapold,    &
     &  limifound, aper_filename, aperunit, ldmpaper, apflag,           &
     &  load_file, loadunit
+ei
!     recognised aperture types:
!     - 2: rectangle
!     - 3: ellipse
!     - 4: rectellipse
!     - 5: octagon
!     - 6: racetrack
!     A.Mereghetti
!     last modified: 01-12-2016
      character(len=2) rect,elli,reel,ratr,octa,circ,nana
      data  rect, elli, reel, ratr, octa, circ, nana                    &
     &    / 'RE', 'EL', 'RL', 'RT', 'OC', 'CR', 'NA' /
+if backtrk
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 24-11-2016
!     additional variables for back-tracking, when computing locations of
!        lost particles
!     inserted in main code by the 'backtrk' compilation flag
      integer kapold
      real(kind=fPrec) yold,sold,apold,bktpre
+ei

+cd commons
      integer idz,itra
+if vvector
+if .not.datamods
      real(kind=fPrec) al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),dps(mpa),idz(2)
+ei
+if datamods
      real(kind=fPrec) chi0,chid,dp1,dps,exz,sigm
      common/syos/sigm(mpa),dps(mpa),idz(2)
+ei
      common/anf/chi0,chid,exz(2,6),dp1,itra
+ei
+if .not.vvector
      real(kind=fPrec) a2,al,as,at,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,2,nele),at(6,2,2,nele),a2(6,2,2,nele),al(6,2,2,nele),sigm(mpa),dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
+ei
+cd commont1
      integer ichrom,is
      real(kind=fPrec) alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
+cd commont2
      integer ichrom,issss
      real(kind=fPrec) alf0,amp,bet0,clo,clop,cro,xxtr,yytr
      common/tra/xxtr(mpa,2),yytr(mpa,2),amp(2),                        &
     &bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),issss(2),ichrom
+cd common1
      integer iav,iconv,icow,icr,idis,iffw,ifh,imad,ipos,ires,iskip,    &
     &istw,itf,ivox,ivoz,iwg,kwtype,ndafi,nprint,nstart,nstop
      real(kind=fPrec) cma1,cma2,dfft,dphix,dphiz,dres,qx0,qz0
      real hmal
      character(len=80) toptit,sixtit,commen
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/pawc/hmal(nplo)
+cd common2
      integer nnumxv
      common/postr2/nnumxv(npart)
+cd commonl
      real(kind=fPrec) aml6,edcor
      common/sixdim/aml6(6,6),edcor(2)
+cd commonxz
      real(kind=fPrec) aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
! fixes for CPU time (for all versions, not just crlibm).
      real pretime,posttime,tottime
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     status of connection
!     inserted in main code by the 'fluka' compilation flag
      integer fluka_con
+ei
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto,          &
     &pretime,posttime,tottime
+cd commonta
      real(kind=fPrec) tasm
      common/tasm/tasm(6,6)
+cd commond1
      common/daele/alda,asda,aldaq,asdaq,smida,xx,yy,dpda,dpda1,sigmda, &
     &ej1,ejf1,rv
+cd commd1da
      integer alda_da,asda_da,aldaq_da,asdaq_da,smida_da,xx_da,         &
     &yy_da,dpda_da,dpda1_da,sigmda_da,ej1_da,ejf1_da,rv_da
      common/daele/alda_da(2,6),asda_da(2,6),aldaq_da(2,6),             &
     &asdaq_da(2,6),smida_da(mcor),xx_da(2),yy_da(2),dpda_da,dpda1_da,  &
     &sigmda_da,ej1_da,ejf1_da,rv_da
+cd commond2
      real(kind=fPrec) ald6,asd6
      common/dael6/ald6(nele,2,6,nema),asd6(nele,2,6,nema)
+cd commonas
      integer idao,iscrri
      integer          iscrda
      real(kind=fPrec) rscrri
      common/dascr/iscrda(100),rscrri(100),iscrri(100),idao
+cd commondl
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      real(kind=fPrec) dpmax,preda,weig1,weig2
      character(len=16) coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
+cd commadha
      integer iamp
      real x
      real(kind=fPrec) ham,hama,hamp
      common/hamil1/ham(0:3),x(10)
      common/hamil2/hama(0:4),hamp(0:1),iamp
+cd commadh1
      integer jeltot,maxa,maxp
      real(kind=fPrec) hda
      common/ad1/hda(0:3,3,0:3,0:4000),jeltot,maxa,maxp
+cd commadh2
      integer jeltot,nordp,nordm,norda
      real(kind=fPrec) hda,hdp
      common/ad2/hda(0:4,5,0:8000),hdp(0:1,5,0:8000),jeltot,nordp,nordm,&
     &norda
+cd commonds
      integer icode,idam,its6d
      real(kind=fPrec) dpscor,sigcor
      common/corcom/dpscor,sigcor,icode,idam,its6d
+cd commonmn
+if time
      real(kind=fPrec) aaiv35,bbiv35
      common/timemain/aaiv35(mmul,nmac,nblz),bbiv35(mmul,nmac,nblz)
+ei
      integer iv,ixv,nlostp,nms,numxv
+if .not.datamods
      real(kind=fPrec) aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
+ei
+if datamods
      real(kind=fPrec) aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam,      &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,eps,epsa,fake,fi,fok,fok1,fokqv,     &
     &g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,     &
+ei
+if rvet
     &rvet,                                                             &
+ei
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
+if .not.datamods
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
+ei
+if datamods
     &fokqv(npart),aaiv(mmul,nmac,nblz),                                &
+ei
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
+if rvet
     &rvet(npart),                                                      &
+ei
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
+if .not.datamods
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
+ei
+if datamods
      common/main3/ clo6v(3,npart),clop6v(3,npart),                     &
     &tas(npart,6,6),qwcs(npart,3),di0xs(npart),                        &
+ei
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
+cd commonm1
      integer numx
      real(kind=fPrec) e0f
+if cr
      logical sythckcr
      common/main4/ e0f,numx,sythckcr
+ei
+if .not.cr
      common/main4/ e0f,numx
+ei
+cd commontr
      integer ktrack,nwri
      real(kind=fPrec) dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
+cd commonc
      integer ichromc,ilinc,iqmodc
      real(kind=fPrec) clon,chromc,corr,wxys
      common/correct/ corr(3,3),chromc(2),wxys(3),clon(6),iqmodc,       &
     &ichromc,ilinc
+cd commonex
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
+cd exactvars
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
      real(kind=fPrec) pz
+cd ex4Ddrift
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
            enddo
+cd ex6Ddrift
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              sigmv(j)=sigmv(j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              sigmv(j)=sigmv(j)+stracki*(one-(rvv(j)/pz))
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
              sigmv(j)=sigmv(j)*c1e3
            enddo
+cd exDAdrift
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
!FOX  X(1)=X(1)*C1M3 ;
!FOX  X(2)=X(2)*C1M3 ;
!FOX  Y(1)=Y(1)*C1M3 ;
!FOX  Y(2)=Y(2)*C1M3 ;
!FOX  SIGMDA=SIGMDA*C1M3 ;
!FOX  PZ=SQRT(ONE-Y(1)*Y(1)-Y(2)*Y(2)) ;
!FOX  X(1)=X(1)+EL(JX)*(Y(1)/PZ) ;
!FOX  X(2)=X(2)+EL(JX)*(Y(2)/PZ) ;
!FOX  SIGMDA=SIGMDA+(ONE-(RV/PZ))*EL(JX) ;
!FOX  X(1)=X(1)*C1E3 ;
!FOX  X(2)=X(2)*C1E3 ;
!FOX  Y(1)=Y(1)*C1E3 ;
!FOX  Y(2)=Y(2)*C1E3 ;
!FOX  SIGMDA=SIGMDA*C1E3 ;
!-----------------------------------------------------------------------
+cd commphin
      common/phasecom/ phase(3,npos+1)
      common/invari/ dani(ninv+1)
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!-----                                                                   -----
!-----    NEW BLOCKS PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----        G. ROBERT-DEMOLAIZE, October 27th, 2004                    -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
+cd collpara
      integer max_ncoll,maxn,numeff,numeffdpop,outlun,nc
      parameter (max_ncoll=100,nc=32,numeff=32,maxn=20000,              &
     &numeffdpop=29,outlun=54)
+cd database
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap

!SEPT2005 for slicing process
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr

      real(kind=fPrec) myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap,        &
     &xbeat,xbeatphase,ybeat,ybeatphase,                                &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength

      character(len=24) name_sel
      character(len=80) coll_db
      character(len=16) castordir
      character(len=80) filename_dis

      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
     &emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap,        &
     &xbeat,xbeatphase,ybeat,ybeatphase,                                &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbtrthin

      integer   mynp
      common /mynp/ mynp

!++ Vectors of coordinates

      real(kind=fPrec) mygammax,mygammay
!
      character(len=80) dummy
!
      ! IN "+CD DBTRTHIN" and "+CD DBDATEN"
!      real(kind=fPrec) remitx_dist,remity_dist,
!     &     remitx_collgap,remity_collgap
!      common  /remit/ remitx_dist, remity_dist,
!     &     remitx_collgap,remity_collgap
!

      real(kind=fPrec) ielem,iclr,grd
      character(len=160) ch
      character(len=320) ch1
      logical flag
!
      integer k,np0
!
      character(len=160) cmd
      character(len=160) cmd2
      character(len=1) ch0
      character(len=2) ch00
      character(len=3) ch000
      character(len=4) ch0000
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbdaten

      ! IN "+CD DBTRTHIN", "+CD DBDATEN" and "+CD DBTHIN6D"
!      logical cut_input
!      common /cut/ cut_input

      ! IN "+CD DBTRTHIN" and "+CD DBDATEN"
      real(kind=fPrec) remitx_dist,remity_dist,                         &
     &     remitx_collgap,remity_collgap
      common  /remit/ remitx_dist, remity_dist,                         &
     &     remitx_collgap,remity_collgap
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dblinopt
!
! THIS BLOCK IS COMMON TO WRITELIN,LINOPT,TRAUTHIN,THIN6D AND MAINCR
!
      real(kind=fPrec) tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Variables for finding the collimator with the smallest gap
! and defining, stroring the gap rms error
!
      character(len=16) coll_mingap1, coll_mingap2
      real(kind=fPrec) gap_rms_error(max_ncoll), nsig_err, sig_offset
      real(kind=fPrec) mingap,gap_h1,gap_h2,gap_h3,gap_h4
      integer coll_mingap_id

      common /gap_err/ gap_rms_error
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+cd dbthin6d
!
      integer ios,num_surhit,numbin,ibin,                               &
     &num_selabs,iturn_last_hit,iturn_absorbed,iturn_survive,imov,      &
     &ipart(npart),totalelem,selelem,unitnumber,distnumber,turnnumber,  &
     &jb,                                                               &
!MAY2005
     &flukaname(npart)
!MAY2005
!     SR, 29-08-2005: add the required variable for slicing collimators
      integer jjj, ijk
!
      real zbv
!
      real(kind=fPrec) c_length    !length in m
      real(kind=fPrec) c_rotation  !rotation angle vs vertical in radian
      real(kind=fPrec) c_aperture  !aperture in m
      real(kind=fPrec) c_offset    !offset in m
      real(kind=fPrec) c_tilt(2)   !tilt in radian
      real(kind=fPrec) cx(npart),cxp(npart),cy(npart),cyp(npart),       &
     &cp(npart),cs(npart),rcx(npart),rcxp(npart),rcy(npart),rcyp(npart),&
     &rcp(npart),rcs(npart),rcx0(npart),rcxp0(npart),rcy0(npart),       &
     &rcyp0(npart),rcp0(npart),enom_gev,betax,betay,xmax,ymax,          &
     &nsig,calc_aperture,gammax,gammay,gammax0,gammay0,gammax1,gammay1, &
     &xj,xpj,yj,ypj,pj,arcdx,arcbetax,xdisp,rxjco,ryjco,                &
     &rxpjco,rypjco,c_rmstilt,                                          &
     &c_systilt,scale_bx,scale_by,scale_bx0,scale_by0,xkick,            &
     &ykick,bx_dist,by_dist,xmax_pencil,ymax_pencil,xmax_nom,ymax_nom,  &
     &nom_aperture,pencil_aperture,xp_pencil(max_ncoll),                &
     &yp_pencil(max_ncoll),x_pencil0,y_pencil0,sum,sqsum,               &
     &csum(max_ncoll),csqsum(max_ncoll),average,sigma,sigsecut,nspxd,   &
     &xndisp,xgrd(npart),xpgrd(npart),ygrd(npart),ypgrd(npart),zpj,     &
     &pgrd(npart),ejfvgrd(npart),sigmvgrd(npart),rvvgrd(npart),         &
     &dpsvgrd(npart),oidpsvgrd(npart),dpsv1grd(npart),                  &
     &dnormx,dnormy,driftx,drifty,                                      &
     &xnorm,xpnorm,xangle,ynorm,ypnorm,yangle,                          &
     &grdpiover2,grdpiover4,grd3piover4

!SEPT2005-SR, 29-08-2005 --- add parameter for the array length ---- TW
      real(kind=fPrec) x_sl(100),x1_sl(100),x2_sl(100),                 &
     &     y1_sl(100), y2_sl(100),                                      &
     &     angle1(100), angle2(100),                                    &
     &     max_tmp,                                                     &
     &     a_tmp1, a_tmp2, ldrift, mynex2, myney2,                      &
     &     Nap1pos,Nap2pos,Nap1neg,Nap2neg,                             &
     &     tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2,         &
     &     beamsize1, beamsize2,betax1,betax2,betay1,betay2,            &
     &     alphax1, alphax2,alphay1,alphay2,minAmpl
!SEPT2005

      character(len=4) c_material     !material

      common /dbthinc/ cx,cxp,cy,cyp,                                   &
     &cp,cs,rcx,rcxp,rcy,rcyp,                                          &
     &rcp,rcs,rcx0,rcxp0,rcy0,                                          &
     &rcyp0,rcp0,enom_gev,betax,betay,xmax,ymax,                        &
     &nsig,calc_aperture,gammax,gammay,gammax0,gammay0,gammax1,gammay1, &
     &xj,xpj,yj,ypj,pj,arcdx,arcbetax,xdisp,rxjco,ryjco,                &
     &rxpjco,rypjco,c_rmstilt,                                          &
     &c_systilt,scale_bx,scale_by,scale_bx0,scale_by0,xkick,            &
     &ykick,bx_dist,by_dist,xmax_pencil,ymax_pencil,xmax_nom,ymax_nom,  &
     &nom_aperture,pencil_aperture,xp_pencil,                           &
     &yp_pencil,x_pencil0,y_pencil0,sum,sqsum,                          &
     &csum,csqsum,average,sigma,sigsecut,nspxd,                         &
     &xndisp,xgrd,xpgrd,ygrd,ypgrd,zpj,                                 &
     &pgrd,ejfvgrd,sigmvgrd,rvvgrd,                                     &
     &dpsvgrd,oidpsvgrd,dpsv1grd,                                       &
     &dnormx,dnormy,driftx,drifty,                                      &
     &xnorm,xpnorm,xangle,ynorm,ypnorm,yangle,                          &
     &grdpiover2,grdpiover4,grd3piover4,                                &
     &x_sl,x1_sl,x2_sl,                                                 &
     &     y1_sl, y2_sl,                                                &
     &     angle1, angle2,                                              &
     &     max_tmp,                                                     &
     &     a_tmp1, a_tmp2, ldrift, mynex2, myney2,                      &
     &     Nap1pos,Nap2pos,Nap1neg,Nap2neg,                             &
     &     tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2,         &
     &     beamsize1, beamsize2,betax1,betax2,betay1,betay2,            &
     &     alphax1, alphax2,alphay1,alphay2,minAmpl,                    &
     &ios,num_surhit,numbin,ibin,                                       &
     &num_selabs,iturn_last_hit,iturn_absorbed,iturn_survive,imov,      &
     &ipart,totalelem,selelem,unitnumber,distnumber,turnnumber,         &
     &jb,flukaname,                                                     &
     &jjj,ijk,zbv,c_length,c_rotation,                                  &
     &c_aperture,c_offset,c_tilt,c_material

! myran_gauss,rndm5,

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbcolcom
      logical firstcoll,found,onesided
      integer rnd_lux,rnd_k1,rnd_k2

      integer myix,myktrack

      real(kind=fPrec) nspx,nspy,mux0,muy0
      real(kind=fPrec) ax0,ay0,bx0,by0
      real(kind=fPrec) totals

      ! IN "+CD DBTRTHIN", "+CD DBDATEN" and "+CD DBTHIN6D"
      logical cut_input
      common /cut/ cut_input

      real(kind=fPrec) xbob(nblz),ybob(nblz),xpbob(nblz),ypbob(nblz),   &
     &xineff(npart),yineff(npart),xpineff(npart),ypineff(npart)

      common /xcheck/ xbob,ybob,xpbob,ypbob,xineff,yineff,xpineff,      &
     &ypineff
      real(kind=fPrec) mux(nblz),muy(nblz)
      common /mu/ mux,muy

      common /collocal/ myix,myktrack,totals,firstcoll,found,onesided

!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+cd dbcommon
!
! THIS BLOCK IS COMMON TO BOTH THIN6D, BEAMGAS, AND TRAUTHIN SUBROUTINES
!
      integer ieff,ieffdpop
!
      real(kind=fPrec) myemitx0_dist,myemity0_dist,                     &
     &     myemitx0_collgap,myemity0_collgap,                           &
     &     myemitx,myalphay,mybetay,myalphax,                           &
     &     mybetax,rselect
      common /ralph/ myemitx0_dist,myemity0_dist,                       &
     &     myemitx0_collgap,myemity0_collgap,                           &
     &     myalphax,myalphay,mybetax,                                   &
     &     mybetay,rselect


! M. Fiascaris for the collimation team
! variables for global inefficiencies studies
! of normalized and off-momentum halo
! Last modified: July 2016

      real(kind=fPrec) neff(numeff),rsig(numeff)
      common  /eff/ neff,rsig

      integer counteddpop(npart,numeffdpop)
      integer counted2d(npart,numeff,numeffdpop)
      real(kind=fPrec) neffdpop(numeffdpop),dpopbins(numeffdpop)
      integer npartdpop(numeffdpop)
      common  /effdpop/ neffdpop,dpopbins,npartdpop,counteddpop
      real(kind=fPrec) dpopmin,dpopmax,mydpop,neff2d(numeff,numeffdpop)
      common /eff2d/ neff2d
!
      integer  nimpact(50)
      real(kind=fPrec) sumimpact(50),sqsumimpact(50)
      common  /rimpact/ sumimpact,sqsumimpact,nimpact
!
      integer  nampl(nblz)
      character(len=16)  ename(nblz)
      real(kind=fPrec) sum_ax(nblz),sqsum_ax(nblz),sum_ay(nblz),        &
     &sqsum_ay(nblz),sampl(nblz)
      common  /ampl_rev/ sum_ax,sqsum_ax,sum_ay,sqsum_ay,sampl,ename,   &
     &nampl
!
      real(kind=fPrec) neffx(numeff),neffy(numeff)
      common /efficiency/ neffx,neffy


      integer secondary(npart),tertiary(npart),other(npart),            &
     &part_hit_before_pos(npart), part_hit_before_turn(npart)
      real(kind=fPrec) part_indiv(npart),part_linteract(npart)

      integer part_hit_pos(npart),part_hit_turn(npart),                 &
     &     part_abs_pos(npart),part_abs_turn(npart),                    &
     &     n_tot_absorbed,n_absorbed,                                   &
     &     part_select(npart),nabs_type(npart)
      real(kind=fPrec) part_impact(npart)
      common /stats/ part_impact,                                       &
     &     part_hit_pos,part_hit_turn,                                  &
     &     part_hit_before_pos, part_hit_before_turn,                   &
     &     part_abs_pos,part_abs_turn,                                  &
     &     nabs_type,part_indiv,                                        &
     &     part_linteract,secondary,tertiary,other
      common /n_tot_absorbed/ n_tot_absorbed,n_absorbed
      common /part_select/ part_select
!
!      real(kind=fPrec) x00(maxn),xp00(maxn),y00(maxn),yp00(maxn)
!      common   /beam00/ x00,xp00,y00,yp00
!
      logical firstrun
      common /firstrun/ firstrun
!
      integer nsurvive,nsurvive_end,num_selhit,n_impact
      common /outcoll/ nsurvive,num_selhit,n_impact,nsurvive_end
!
      integer napx00
      common /napx00/ napx00
!
      integer  icoll
      common  /icoll/  icoll
!
!UPGRADE January 2005
!     INTEGER DB_NCOLL
      integer db_ncoll
!
      character(len=16) db_name1(max_ncoll),db_name2(max_ncoll)
      character(len=4) db_material(max_ncoll)
!APRIL2005
      real(kind=fPrec) db_nsig(max_ncoll),db_length(max_ncoll),         &
     &db_offset(max_ncoll),db_rotation(max_ncoll),                      &
     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
      common /colldatabase/ db_nsig,db_length,db_rotation,db_offset,    &
     &db_bx,db_by,db_tilt,db_name1,db_name2,db_material,db_ncoll
!      real(kind=fPrec) db_length(max_ncoll),db_rotation(max_ncoll),     &
!     &db_offset(max_ncoll),                                             &
!     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
!      common /colldatabase/ db_length,db_rotation,db_offset,db_bx,db_by,&
!!     &DB_TILT,DB_NAME1,DB_NAME2,DB_MATERIAL,DB_NCOLL
!     &db_tilt,db_name1,db_name2,db_material,db_ncoll,db_nabs,db_ntot,   &
!     &db_startabs
!APRIL2005
!
      integer cn_impact(max_ncoll),cn_absorbed(max_ncoll)
      real(kind=fPrec) caverage(max_ncoll),csigma(max_ncoll)
      common /collsummary/ caverage,csigma,cn_impact,cn_absorbed
!
      real(kind=fPrec) myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn)
      common /coord/ myx,myxp,myy,myyp,myp,mys
!
      integer counted_r(npart,numeff),counted_x(npart,numeff),          &
     &counted_y(npart,numeff)
      common /counting/ counted_r,counted_x,counted_y

      integer   samplenumber
      character(len=4) smpl
      character(len=80) pfile
      common /samplenumber/ pfile,smpl,samplenumber
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbpencil
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      real(kind=fPrec) xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd dbcollim
!     BLOCK DBCOLLIM
!     This block is common to collimaterhic and collimate2
!     It is NOT compatible with block DBCOMMON, as some variable names overlap...
      

      logical onesided,hit
      integer nprim,filel,mat,nev,j,nabs,nhit,np,icoll,nabs_tmp
      
      integer lhit_pos(npart),lhit_turn(npart),                         &
     &     part_abs_pos_local(npart), part_abs_turn_local(npart),       &
     &     name(npart),nabs_type(npart)
!MAY2005
      real(kind=fPrec) p0,xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax   &
     &,length,zlm,x,x00,xp,z,z00,zp,p,sp,dpop,s,enom,x_in(npart),       &
     &xp_in(npart),y_in(npart),yp_in(npart),p_in(npart),s_in(npart),    &
     &indiv(npart),lint(npart),                                         &
     &keeps,fracab,mybetax,mybetaz,mymux,mymuz,sigx,                    &
     &sigz,norma,xpmu,atdi,drift_length,mirror,tiltangle,impact(npart)
!
      real(kind=fPrec) c_length    !length in m
      real(kind=fPrec) c_rotation  !rotation angle vs vertical in radian
      real(kind=fPrec) c_aperture  !aperture in m
      real(kind=fPrec) c_offset    !offset in m
      real(kind=fPrec) c_tilt(2)   !tilt in radian
      character(len=4) c_material  !material
!
      character(nc) filen,tit
!
      real   xlow,xhigh,xplow,xphigh,dx,dxp
!
!AUGUST2006 Added ran_gauss for generation of pencil/     ------- TW
!           sheet beam distribution  (smear in x and y)
!
      common /cmom/xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax,length,  &
     &nev
      common /materia/mat
      common /phase/x,xp,z,zp,dpop
      common /nommom/p0
      common /cjaw1/zlm
      common /other/mybetax,mybetaz,mymux,mymuz,atdi
      common /icoll/  icoll
!
      data   dx,dxp/.5e-4,20.e-4/                                        !hr09
!
!     END BLOCK DBCOLLIM
+cd collMatNum
!     EQ 2016 added variables for collimator material numbers
      integer nmat, nrmat
      parameter(nmat=14,nrmat=12)

+cd flukavars
!     RB DM 2014 added variables for FLUKA output
      real(kind=fPrec) xInt,xpInt,yInt,ypInt,sInt
      common/flukaVars/xInt,xpInt,yInt,ypInt,sInt
!
!
+cd info
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
+cd dbmkdist
!
!++ Vectors of coordinates
!
      integer i,j,mynp,nloop
      real(kind=fPrec) myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      character(len=80)   dummy
!
      ! IN "+CD DBTRTHIN", "+CD DBDATEN", "+CD DBTHIN6D", and "+CD DBMKDIST"
      logical cut_input
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd funint
      real tftot
      common/funint/tftot
+cd interac
      integer mat,mcurr
+ca collMatNum
      real(kind=fPrec) xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,zatom,exenergy
!electron density and plasma energy
      real(kind=fPrec) edens, pleng
!      parameter(fnavo=6.02214129e23_fPrec)
      real cgen
      character(4) mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat)
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
      common/cions/edens(nmat),pleng(nmat)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   dbdcum

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code

!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure

      real(kind=fPrec) dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )

      real(kind=fPrec) eps_dcum              ! Tolerance for machine length mismatch [m]
      parameter ( eps_dcum = c1m6 )

      common /dcumdb/ dcum(0:nblz+1)

+cd   dbreaddis

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for reading a beam distribution
!     always in main code

!     in case the DIST input block is issued, the beam distribution
!       is read from a text file

      logical dist_enable                    ! DIST input block given
      logical dist_echo                      ! echo the read distribution?
      character(len=16) dist_filename        !
      integer dist_read_unit                 ! unit for reading the distribution
      integer dist_echo_unit                 ! unit for echoing the distribution

      common /readdisdb/ dist_filename, dist_echo, dist_enable,dist_read_unit, dist_echo_unit

!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!

+cd elensparam
!     M. Fitterer, FNAL
!     Common block for electron lens definition
      
      ! variables to save elens parameters for tracking etc.
      integer          :: elens_type(nele)      ! integer for elens type
                                                ! 0 : Un-initialized.
                                                ! 1 : Hollow annular elens, uniform profile
      real(kind=fPrec) :: elens_theta_max(nele) ! maximum kick strength [mrad]
      real(kind=fPrec) :: elens_r2(nele)        ! outer radius R2 [mm]
      real(kind=fPrec) :: elens_r2ovr1(nele)    ! R2/R1 where R1 is the inner radius
      real(kind=fPrec) :: elens_offset_x(nele),                         &
     &                    elens_offset_y(nele)  ! hor./vert. offset of elens [mm]
      integer          :: elens_bend_entrance(nele),                    &
     &                    elens_bend_exit(nele) ! switch for elens bends
      common /elensco/ elens_type,elens_theta_max,elens_r2,             &
     &elens_r2ovr1,elens_offset_x,elens_offset_y,elens_bend_entrance,   &
     &     elens_bend_exit
+cd elenstracktmp
!     Dummy variables used in tracking block for calculation
!     of the kick for the ideal annualar e-lens
      real(kind=fPrec) :: rrelens,frrelens,r1elens,xelens,yelens
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd wireparam
!     A. Patapenka (NIU), M. Fitterer (FNAL)
!     Common block for wire definition
      ! variables to save wire parameters for tracking etc.
      real(kind=fPrec) :: wire_current(nele)    ! wire current [A]
      real(kind=fPrec) :: wire_lint(nele)       ! integrated length of the wire [m]
      real(kind=fPrec) :: wire_lphys(nele)      ! physical length of the wire [m]
      ! integer to include or not closed orbit in the separation between beam and wire
      ! 0  : Un-initialized if wire element not found
      ! +1 : dispx is the distance between x0=y0=0 and the wire
      ! -1 : dispx is the distance between the closed orbit and the wire 
      !
      !    x=y=0    <->   xco     <->    xwire
      !               closed orbit    wire position
      ! wire_flagco = +1: dispx = xwire -> rx = x + xsep
      ! wire_flagco = -1: dispx = xwire - xco -> rx = x - xco + xsep
      ! -> rx = x + xwire
      integer          :: wire_flagco(nele)     
      real(kind=fPrec) :: wire_dispx(nele),                             &
     &                    wire_dispy(nele)      ! hor./vert. displacement of the wire [mm]
      real(kind=fPrec) :: wire_tiltx(nele),                             &
     &                    wire_tilty(nele)      ! hor./vert. tilt of the wire [degrees] -90 < tilty < 90,
                                                !  uses the same definition as the DISP block
      common /wireparamco/ wire_current,wire_lint,wire_lphys,           &
     &wire_flagco,wire_dispx,wire_dispy,wire_tiltx,wire_tilty
+cd wiretracktmp
! temporary variables
      real(kind=fPrec) RTWO !RTWO=x^2+y^2
      real(kind=fPrec) NNORM_, NNORM
      real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi

!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd   comgetfields
!
!     COMGETFIELDS
!     Definitions needed to use the getfields_split() subroutine
!     
!     A.Mereghetti, for the FLUKA Team
!     last modified: 29-08-2014
!     some variables / parameters for a more flexible parsing of input lines
!     always in main code

!     parameters for the parser
      integer getfields_n_max_fields, getfields_l_max_string
      parameter ( getfields_n_max_fields = 10  ) ! max number of returned fields
      parameter ( getfields_l_max_string = 161 ) ! max len of parsed line and its fields
                                                 ! (nchars in daten +1 to always make room for \0)

!     array of fields
      character getfields_fields                                        &
     &     ( getfields_n_max_fields )*( getfields_l_max_string )
!     number of identified fields
      integer getfields_nfields
!     length of each what:
      integer getfields_lfields( getfields_n_max_fields )
!     an error flag
      logical getfields_lerr
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd stringzerotrim
! Definitions necessary for using the "stringzerotrim" function,
! which is defined in deck "stringhandling".
! Requires block comgetfields for getfields_l_max_string.
! Used in at least DYNK, FMA, ZIPF, DUMP, and SCATTER.
! K. Sjobak, BE-ABP/HSS
      integer stringzerotrim_maxlen

      !Note: This is also used for DYNK, and should AT LEAST be able to store a bez+char(0) -> 17.
      parameter (stringzerotrim_maxlen=getfields_l_max_string)
      
      character(len=stringzerotrim_maxlen) stringzerotrim ! Define the function
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
+cd timefct
          expt =  exp_mb(-real(n,fPrec)/tcnst35(i))
+cd dainicom
!FOX  D V DA EXT SIGMDA NORD NVAR ; D V DA EXT DPDA NORD NVAR ;
!FOX  D V DA EXT DPDA1 NORD NVAR ; D V DA EXT RV NORD NVAR ;
!FOX  D V DA EXT XX NORD NVAR 2 ; D V DA EXT YY NORD NVAR 2 ;
!FOX  D V DA EXT EJ1 NORD NVAR ; D V DA EXT EJF1 NORD NVAR ;
!FOX  D V DA EXT ALDA NORD NVAR 2 6 ; D V DA EXT ASDA NORD NVAR 2 6 ;
!FOX  D V DA EXT ALDAQ NORD NVAR 2 6 ; D V DA EXT ASDAQ NORD NVAR 2 6 ;
!FOX  D V DA EXT SMIDA NORD NVAR MCOR ;
+cd daini
!FOX  B D ;
!FOX  D V DA COM SIGMDA NORD NVAR ; D V DA COM DPDA NORD NVAR ;
!FOX  D V DA COM DPDA1 NORD NVAR ; D V DA COM RV NORD NVAR ;
!FOX  D V DA COM XX NORD NVAR 2 ; D V DA COM YY NORD NVAR 2 ;
!FOX  D V DA COM EJ1 NORD NVAR ; D V DA COM EJF1 NORD NVAR ;
!FOX  D V DA COM ALDA NORD NVAR 2 6 ; D V DA COM ASDA NORD NVAR 2 6 ;
!FOX  D V DA COM ALDAQ NORD NVAR 2 6 ; D V DA COM ASDAQ NORD NVAR 2 6 ;
!FOX  D V DA COM SMIDA NORD NVAR MCOR ;
!FOX  D V DA INT X NORD NVAR 2 ; D V DA INT Y NORD NVAR 2 ;
!FOX  D V DA INT YP NORD NVAR 2 ; D V DA INT DKIP NORD NVAR ;
!FOX  D V DA INT CORROLD NORD NVAR MCOP ;
!FOX  D V DA INT CORRNEW NORD NVAR MCOP ;
!FOX  D V DA INT CORRAU1 NORD NVAR MCOP ;
!FOX  D V DA INT CORRAU2 NORD NVAR MCOP ;
!FOX  D V DA INT AA NORD NVAR 11 ;  D V DA INT BB NORD NVAR 11 ;
!FOX  D V DA INT TRACKI NORD NVAR 6 ;
!FOX  D V DA INT PUX NORD NVAR ; D V DA INT PUZ NORD NVAR ;
!FOX  D V DA INT EJF0 NORD NVAR ; D V DA INT EKK NORD NVAR ;
!FOX  D V DA INT XL NORD NVAR ; D V DA INT ZL NORD NVAR ;
!FOX  D V DA INT CRKVE NORD NVAR ; D V DA INT CIKVE NORD NVAR ;
!FOX  D V DA INT CRKVEUK NORD NVAR ; D V DA INT CBZBF NORD NVAR ;
!FOX  D V DA INT YV1J NORD NVAR ; D V DA INT YV2J NORD NVAR ;
!FOX  D V DA INT CRKVEBF NORD NVAR ; D V DA INT CIKVEBF NORD NVAR ;
!FOX  D V DA INT RHO2BF NORD NVAR ; D V DA INT TKBF NORD NVAR ;
!FOX  D V DA INT XRBF NORD NVAR ; D V DA INT CCCC NORD NVAR ;
!FOX  D V DA INT ZRBF NORD NVAR ; D V DA INT XBBF NORD NVAR ;
!FOX  D V DA INT ZBBF NORD NVAR ; D V DA INT CRXBF NORD NVAR ;
!FOX  D V DA INT CBXBF NORD NVAR ; D V DA INT CRZBF NORD NVAR ;
!FOX  D V DA INT WX NORD NVAR ; D V DA INT WY NORD NVAR ;
!FOX  D V DA INT CRABAMP NORD NVAR ;
!FOX  D V DA INT CRABAMP2 NORD NVAR ;
!FOX  D V DA INT CRABAMP3 NORD NVAR ;
!FOX  D V DA INT CRABAMP4 NORD NVAR ;
+if rvet
!FOX  D V DA INT RVET NORD NVAR ;
+ei
!FOX  D V RE INT AAI NBLZ MMUL ; D V RE INT BBI NBLZ MMUL ;
!FOX  D V RE INT TILTC NBLZ ; D V RE INT TILTS NBLZ ;
!FOX  D V RE INT DPS MPA ; D V RE INT SIGM MPA ;
!FOX  D V RE INT DKI NELE 3 ; D V RE INT BL1 NBLO 2 6 ;
!FOX  D V RE INT EL NELE ; D V RE INT EJ MPA ; D V RE INT EJF MPA ;
!FOX  D V RE INT SMI NBLZ ; D V RE INT SMIZF NBLZ ;
!FOX  D V RE INT ED1 ; D V RE INT ED2 ;
!FOX  D V RE INT DPDAV2 6 ; D V RE INT RRTR NTR 6 6 ;
!FOX  D V RE INT COTR NTR 6 ; D V RE INT DPDAV ; D V RE INT BETR0 ;
!FOX  D V RE INT E0 ; D V RE INT E0F ; D V RE INT PMA ;
!FOX  D V RE INT XS ; D V RE INT ZS ; D V RE INT OX ; D V RE INT OXP ;
!FOX  D V RE INT OZ ; D V RE INT OZP ; D V RE INT SIGM1 ;
!FOX  D V RE INT BEAMOFF1 ; D V RE INT BEAMOFF2 ;
!FOX  D V RE INT BEAMOFF4 ; D V RE INT BEAMOFF5 ; D V RE INT BEAMOFF6 ;
!FOX  D V RE INT DPS1 ; D V RE INT RKBF ; D V RE INT RBF ;
!FOX  D V RE INT R2BF ; D V RE INT BBCU NBB 12 ;
!FOX  D V RE INT SIGMAN 2 NBB ; D V RE INT PTNFAC NELE ;
!FOX  D V RE INT CRAD ; D V RE INT GAMMAR ; D V RE INT PARBE NELE 18 ;
!FOX  D V RE INT PARTNUM ; D V RE INT PISQRT ; D V RE INT SCRKVEB ;
!FOX  D V RE INT SCIKVEB ; D V RE INT STARTCO ; D V RE INT RATIOE NELE ;
!FOX  D V RE INT PARBE14 ; D V RE INT PI ;
!FOX  D V RE INT SIGMDAC ; D V RE INT DUMMY ;
!FOX  D V RE INT ED NELE ; D V RE INT EK NELE ;
!FOX  D V RE INT WIRECLO0 ;
+if .not.fast
!FOX  D V RE INT C2E3 ; D V RE INT C1E6 ;
+ei
+if fast
!FOX  D V RE INT C5M4 ; D V RE INT C2E3 ; D V RE INT C1E6 ;
+ei
!FOX  D V RE INT C1E3 ; D V RE INT C1M3 ; D V RE INT C1M6 ;
!FOX  D V RE INT C1M9 ; D V RE INT C1M12 ; D V RE INT C1M15 ;
!FOX  D V RE INT C1M18 ; D V RE INT C1M21 ; D V RE INT C1M24 ;
!FOX  D V RE INT ONE ; D V RE INT TWO ; D V RE INT THREE ;
!FOX  D V RE INT FOUR ; D V RE INT ZERO ; D V RE INT HALF ;
!FOX  D V RE INT CRABFREQ ; D V RE INT CRABPHT ;
!FOX  D V RE INT CRABPHT2 ; D V RE INT CRABPHT3 ;
!FOX  D V RE INT CRABPHT4 ;
!FOX  D V RE INT CLIGHT ;
!FOX  D V IN INT IDZ 2 ; D V IN INT KX ; D V IN INT IX ; D V IN INT JX ;
!FOX  D V IN INT I ; D V IN INT IPCH ; D V IN INT K ; D V IN INT KKK ;
!FOX  D V IN INT IVAR ; D V IN INT IRRTR ; D V IN INT KK ;
!FOX  D V IN INT IMBB NBLZ ;
!FOX  D V IN INT WIRE_NUM NBLZ ;
!FOX  D F RE DARE 1 ;
!FOX  D V DA INT PZ NORD NVAR ;
!FOX  E D ;
+cd dump1
      write(32)                                                         &
+cd dump2
      read(32)                                                          &
+cd dump3
!
!  left out to do tracking
!  numl,niu,amp0,amp(2),damp,chi0,chid,rat,exz(2,6),time0,time1
!
!
+if time
     &tcnst35,exterr35,icext35,zfz35,                                   &
+ei
     &ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
     &ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
     &idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
     &iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
     &hsyc,phasc,dppoff,sigmoff,tlen,                                   &
     &iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
     &sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
     &zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
     &mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
     &dech,dsm0,itco,itcro,itqv,iout,qw0,iq,iqmod,kpa,iqmod6,bez,elbe,  &
     &bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac,pac,  &
     &bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,sigma0,iclo,           &
     &ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
     &icoe,ise,mesa,mp,m21,m22,m23,                                     &
     &ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
     &rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
     &qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
     &iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
     &nprint,ndafi,qwsk,betx,betz,                                      &
     &alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
     &sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
     &sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
     &ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,wire_num,          &
+if vvector
     &as,al,sigm,dps,idz,dp1,itra,                                      &
+ei
+if .not.vvector
     &as,at,a2,al,sigm,dps,idz,dp1,itra,                                &
+ei
     &x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
     &bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
     &nvar2,nsix,ncor,ipar,nordf,                                       &
     &nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
     &icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
     &ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
     &clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
     &dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
+if rvet
     &rvet,                                                             &
+ei
     &ejf0v,numxv,nms,nlostp,dpd,                                       &
     &dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
     &rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
     &ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
     &clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
     &di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr
+cd clor6
              if(iclo6r.eq.0) then
                clo6(1)=clo(1)
                clop6(1)=clop(1)
                clo6(2)=clo(2)
                clop6(2)=clop(2)
                clo6(3)=zero
                clop6(3)=zero
              else
+if fio
+if crlibm
                call enable_xp()
+ei
                read(33,*,round='nearest') (clo6(l),clop6(l), l=1,3)
+if crlibm
                call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
                read(33,*) (clo6(l),clop6(l), l=1,3)
+ei
+if crlibm
                read(33,*) ch 
                lineno=lineno+1
                ch1(:nchars+3)=ch(:nchars)//' / '
                call splitfld(errno,33,lineno,nofields,nf,ch1,fields)
                do l=1,3
                  if (nf.gt.0) then
                    clo6(l)=fround(errno,fields,l*2-1)
                    nf=nf-1
                  endif
                  if (nf.gt.0) then
                    clop6(l)=fround(errno,fields,l*2)
                    nf=nf-1
                  endif
                enddo
+ei
+ei
              endif
              call clorb(zero)
              call betalf(zero,qw)
              call phasad(zero,qwc)
              sigm(1)=clo6(3)
              dps(1)=clop6(3)
+if debug 
!     call dumpbin('bqmodda',1,3)
!     call abend('before qmodda 1 3                                 ')
!     write(*,*) '1st call qmodda'
+ei
              call qmodda(3,qwc)
+if debug 
!     call dumpbin('aqmodda',1,3)
!     call abend('after  qmodda 1 3                                 ')
+ei
              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
                nlin=nlinoo
              endif
              dp1=dp10+clop6(3)
+if debug 
!     call dumpbin('ecdclor6',1,3)
!     call abend('end cd clor6                                      ')
+ei
+cd beamcou
+if debug
!       write(*,*) 'Beam coupling'
+ei
              dps0=dps(1)
              dps(1)=zero
              iqmodc=4
              call mydaini(1,2,nd2,nd,nd2,1)
              ilinc=2
              call mydaini(2,2,nd2,nd,nd2,1)
              dps(1)=dps0
+if debug
!     call dumpbin('abeamcou',2,22)
!     call abend('after beam coupling                               ')
+ei
+cd multini
!-- Initialize multipoles, combining settings from fort.2 with
!-- coefficients from MULT and random values from FLUC.
!-- Used in program maincr and from initialize_element.
      r0=ek(ix)
      if(abs(r0).le.pieni) goto 150 ! label 150 - just after this code
      nmz=nmu(ix)
      if(nmz.eq.0) then
         izu=izu+2*mmul
         goto 150
      endif
      im=irm(ix)
      r0a=one
      do k=1,nmz
         izu=izu+1
         aaiv(k,m,i)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a !hr05
+if time
         aaiv35(k,m,i)=(ed(ix)*(ak0(im,k)+zfz35(izu)*aka(im,k)))/r0a !hr05
+ei
         aai(i,k)=aaiv(k,m,i)
         izu=izu+1
         bbiv(k,m,i)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a !hr05
+if time
         bbiv35(k,m,i)=(ed(ix)*(bk0(im,k)+zfz35(izu)*bka(im,k)))/r0a !hr05
+ei
         bbi(i,k)=bbiv(k,m,i)
         
         r0a=r0a*r0
      enddo
      
      izu=izu+2*mmul-2*nmz
!------------------------------------------------------------------------------------

+cd alignf
+if .not.tilt
!FOX  XL=X(1)-XS ;
!FOX  ZL=X(2)-ZS ;
!FOX  CRKVE=XL ;
!FOX  CIKVE=ZL ;
+ei
+if tilt
!FOX  XL=(X(1)-XS)*TILTC(I)+(X(2)-ZS)*TILTS(I) ;
!FOX  ZL=-(X(1)-XS)*TILTS(I)+(X(2)-ZS)*TILTC(I) ;
!FOX  CRKVE=XL ;
!FOX  CIKVE=ZL ;
+ei
+cd alignu
+if .not.tilt
        xl=x(1,1)-xs
        zl=x(1,2)-zs
        crkve=xl
        cikve=zl
+ei
+if tilt
        xl=(x(1,1)-xs)*tiltc(k)+(x(1,2)-zs)*tilts(k)
        zl=(x(1,2)-zs)*tiltc(k)-(x(1,1)-xs)*tilts(k)                     !hr02
        crkve=xl
        cikve=zl
+ei
+cd alignsa
+if .not.tilt
                        xl=x(j,1)-xs
                        zl=x(j,2)-zs
                        crkve=xl
                        cikve=zl
+ei
+if tilt
                        xl=(x(j,1)-xs)*tiltc(i)+(x(j,2)-zs)*tilts(i)
                        zl=(x(j,2)-zs)*tiltc(i)-(x(j,1)-xs)*tilts(i)     !hr08
                        crkve=xl
                        cikve=zl
+ei
+cd alignsb
+if .not.tilt
                      xl=x(j,1)-xs
                      zl=x(j,2)-zs
+ei
+if tilt
                      xl=(x(j,1)-xs)*tiltc(i)+(x(j,2)-zs)*tilts(i)
                      zl=(x(j,2)-zs)*tiltc(i)-(x(j,1)-xs)*tilts(i)       !hr08
+ei
+cd alignl
+if .not.tilt
        xl=t(1,1)-xs
        zl=t(1,3)-zs
        crkve=xl
        cikve=zl
+ei
+if tilt
        xl=(t(1,1)-xs)*tiltc(k)+(t(1,3)-zs)*tilts(k)
        zl=(t(1,3)-zs)*tiltc(k)-(t(1,1)-xs)*tilts(k)                    !hr02
        crkve=xl
        cikve=zl
+ei
+cd alignva
+if .not.tilt
            xlv(j)=xv(1,j)-xsiv(1,i)
            zlv(j)=xv(2,j)-zsiv(1,i)
            crkve=xlv(j)
            cikve=zlv(j)
+ei
+if tilt
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
+ei
+cd alignvb
+if .not.tilt
            xlvj=xv(1,j)-xsiv(1,i)
            zlvj=xv(2,j)-zsiv(1,i)
+ei
+if tilt
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
+ei
+cd stra01
+if .not.tilt
        strack(i)=smiv(1,i)*c1e3
+ei
+if tilt
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra02
+if .not.tilt
        strack(i)=smiv(1,i)
+ei
+if tilt
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra2dpe
+if .not.tilt
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
+ei
+if tilt
        strack(i)=zero
        strackx(i)=ed(IX)*tiltc(i)
        stracks(i)=ed(IX)*tilts(i)
        strackz(i)=ek(IX)*tiltc(i)
        strackc(i)=ek(IX)*tilts(i)
+ei
+cd solenoid
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
+cd stra03
+if .not.tilt
        strack(i)=smiv(1,i)*c1m3
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra04
+if .not.tilt
        strack(i)=smiv(1,i)*c1m6
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra05
+if .not.tilt
        strack(i)=smiv(1,i)*c1m9
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra06
+if .not.tilt
        strack(i)=smiv(1,i)*c1m12
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra07
+if .not.tilt
        strack(i)=smiv(1,i)*c1m15
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra08
+if .not.tilt
        strack(i)=smiv(1,i)*c1m18
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra09
+if .not.tilt
        strack(i)=smiv(1,i)*c1m21
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra10
+if .not.tilt
        strack(i)=smiv(1,i)*c1m24
+ei
+if tilt
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
+ei
+cd stra11
+if .not.tilt
              strack(i)=dki(ix,1)/dki(ix,3)
+ei
+if tilt
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra12
+if .not.tilt
              strack(i)=dki(ix,1)
+ei
+if tilt
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra13
+if .not.tilt
              strack(i)=dki(ix,2)/dki(ix,3)
+ei
+if tilt
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd stra14
+if .not.tilt
              strack(i)=dki(ix,2)
+ei
+if tilt
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
+ei
+cd kickfho
!FOX  CRKVEUK=CRKVE*XL-CIKVE*ZL ;
!FOX  CIKVE=CRKVE*ZL+CIKVE*XL ;
!FOX  CRKVE=CRKVEUK ;
+cd kickf01h
+if .not.tilt
!FOX  Y(1)=Y(1)+EKK ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+EKK*TILTC(I) ;
!FOX  Y(2)=Y(2)+EKK*TILTS(I) ;
+ei
+cd kickfxxh
+if .not.tilt
!FOX  Y(1)=Y(1)+EKK*CRKVE ;
!FOX  Y(2)=Y(2)-EKK*CIKVE ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+EKK*(TILTC(I)*CRKVE+TILTS(I)*CIKVE) ;
!FOX  Y(2)=Y(2)+EKK*(-TILTC(I)*CIKVE+TILTS(I)*CRKVE) ;
+ei
+cd kickfdpe
+if .not.tilt
!FOX  Y(1)=Y(1)+ED(IX)*CRKVE/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+EK(IX)*CIKVE/(ONE+DPDA) ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+(ED(IX)*TILTC(I)*CRKVE-EK(IX)*TILTS(I)*CIKVE)/
!FOX  (ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(EK(IX)*TILTC(I)*CIKVE+ED(IX)*TILTS(I)*CRKVE)/
!FOX  (ONE+DPDA) ;
+ei
+cd kickfso1
!FOX  Y(1)=Y(1)-X(2)*ED(IX) ;
!FOX  Y(2)=Y(2)+X(1)*ED(IX) ;
!FOX  CRKVE=Y(1)-X(1)*ED(IX)*EK(IX) ;
!FOX  CIKVE=Y(2)-X(2)*ED(IX)*EK(IX) ;
!FOX  Y(1)=CRKVE*COS(EK(IX))+CIKVE*SIN(EK(IX)) ;
!FOX  Y(2)=-CRKVE*SIN(EK(IX))+CIKVE*COS(EK(IX)) ;
!FOX  CRKVE=X(1)*COS(EK(IX))+X(2)*SIN(EK(IX)) ;
!FOX  CIKVE=-X(1)*SIN(EK(IX))+X(2)*COS(EK(IX)) ;
!FOX  X(1)=CRKVE ;
!FOX  X(2)=CIKVE ;
!FOX  Y(1)=Y(1)+X(2)*ED(IX) ;
!FOX  Y(2)=Y(2)-X(1)*ED(IX) ;
+cd kickf01v
+if .not.tilt
!FOX  Y(2)=Y(2)+EKK ;
+ei
+if tilt
!FOX  Y(1)=Y(1)-EKK*TILTS(I) ;
!FOX  Y(2)=Y(2)+EKK*TILTC(I) ;
+ei
+cd kickfxxv
+if .not.tilt
!FOX  Y(1)=Y(1)+EKK*CIKVE ;
!FOX  Y(2)=Y(2)+EKK*CRKVE ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+EKK*(TILTC(I)*CIKVE-TILTS(I)*CRKVE) ;
!FOX  Y(2)=Y(2)+EKK*(TILTC(I)*CRKVE+TILTS(I)*CIKVE) ;
+ei
+cd kicksho
                        crkveuk=crkve*xl-cikve*zl
                        cikve=crkve*zl+cikve*xl
                        crkve=crkveuk
+cd kicks01h
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*tiltc(i)
                        y(j,2)=y(j,2)+ekk(j)*tilts(i)
+ei
+cd kicksxxh
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)*crkve
                        y(j,2)=y(j,2)-ekk(j)*cikve
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
                        y(j,2)=y(j,2)+ekk(j)*(tilts(i)*crkve-           &!hr02
     &tiltc(i)*cikve)                                                    !hr02
+ei
+cd kicks01v
+if .not.tilt
                        y(j,2)=y(j,2)+ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*tilts(i)
                        y(j,2)=y(j,2)+ekk(j)*tiltc(i)
+ei
+cd kicksxxv
+if .not.tilt
                        y(j,1)=y(j,1)+ekk(j)*cikve
                        y(j,2)=y(j,2)+ekk(j)*crkve
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*(tiltc(i)*cikve-           &
     &tilts(i)*crkve)
                        y(j,2)=y(j,2)+ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
+ei
+cd kickb01h
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*tiltc(i)
                        y(j,2)=y(j,2)-ekk(j)*tilts(i)
+ei
+cd kickbxxh
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)*crkve
                        y(j,2)=y(j,2)+ekk(j)*cikve
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
                        y(j,2)=y(j,2)-ekk(j)*(tilts(i)*crkve-           &!hr02
     &tiltc(i)*cikve)                                                    !hr02
+ei
+cd kickb01v
+if .not.tilt
                        y(j,2)=y(j,2)-ekk(j)
+ei
+if tilt
                        y(j,1)=y(j,1)+ekk(j)*tilts(i)
                        y(j,2)=y(j,2)-ekk(j)*tiltc(i)
+ei
+cd kickbxxv
+if .not.tilt
                        y(j,1)=y(j,1)-ekk(j)*cikve
                        y(j,2)=y(j,2)-ekk(j)*crkve
+ei
+if tilt
                        y(j,1)=y(j,1)-ekk(j)*(tiltc(i)*cikve-           &
     &tilts(i)*crkve)
                        y(j,2)=y(j,2)-ekk(j)*(tiltc(i)*crkve+           &
     &tilts(i)*cikve)
+ei
+cd kickvho
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
+cd kickv01h
+if .not.tilt
            yv(1,j)=yv(1,j)+strack(i)*oidpsv(j)
+ei
+if tilt
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
+ei
+cd kickvxxh
+if .not.tilt
            yv(1,j)=yv(1,j)+(strack(i)*oidpsv(j))*crkve                  !hr02
            yv(2,j)=yv(2,j)-(strack(i)*oidpsv(j))*cikve                  !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
+ei
+cd kickvdpe
+if .not.tilt
            yv(1,j)=yv(1,j)+(strackx(i)*oidpsv(j))*crkve                 !hr02
            yv(2,j)=yv(2,j)-(strackz(i)*oidpsv(j))*cikve                 !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
+ei
+cd kickvso1
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!
! TODO: Check if ejf0v should be e0f?? or oidpsv=ejf0v(j)/ejfv(j)=1/(1+delta)
!
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
            yv(1,j)=crkve*cos_mb((strackz(i)*ejf0v(j))/ejfv(j))+        &!hr02
     &cikve*sin_mb((strackz(i)*ejf0v(j))/ejfv(j))                        !hr02
            yv(2,j)=cikve*cos_mb((strackz(i)*ejf0v(j))/ejfv(j))-        &!hr02
     &crkve*sin_mb((strackz(i)*ejf0v(j))/ejfv(j))                        !hr02
            crkve=xv(1,j)*cos_mb((strackz(i)*ejf0v(j))/ejfv(j))+        &!hr02
     &xv(2,j)*sin_mb((strackz(i)*ejf0v(j))/ejfv(j))                      !hr02
            cikve=xv(2,j)*cos_mb((strackz(i)*ejf0v(j))/ejfv(j))-        &!hr02
     &xv(1,j)*sin_mb((strackz(i)*ejf0v(j))/ejfv(j))                      !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
+cd kickvso2
        crkve=sigmv(j)-half*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))*  &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
+cd kickelens
            select case (elens_type(ix))
              case (1)
! ANNULAR: hollow elens with uniform annular profile for collimation
! Space charge density is:
! 0     if r < R1
! Const if R1 < r < R2
! 0     if r > R2
! Parameters:
!   elens_theta_max is the maximum kick in radians
!   elens_r2 is R2 in mm
!   elens_r2ovr1 = R2 / R1 (by default, 1.5)
!   elens_offset_x - x offset
!   elens_offset_y - y offset
!   elens_bend_entrance - switch bends on at entrance
!   elens_bend_exit - switch bends on at exit
! internal parameters to calculate kick:
!   xelens = x(proton) + elens_offset_x
!   yelens = y(proton) + elens_offset_y
!   rrelens = sqrt(xelens**2+yelens**2)
!   r1elens = radius R1 [mm]
!   frrelens = shape function [1/mm]

! kick from ideal annular profile
! 1) apply offset of e-lens
                xelens=xv(1,j)+elens_offset_x(ix)
                yelens=xv(2,j)+elens_offset_y(ix)
! 2) calculate radius
                rrelens=sqrt((xelens)**2+(yelens**2)) ! radius of particle in p-beam relative to center of elens beam
                r1elens=elens_r2(ix)/elens_r2ovr1(ix) ! inner radius elens
! 3) calculate kick
                if (rrelens.gt.r1elens) then ! rrelens <= r1 -> no kick from elens
                  if (rrelens.lt.elens_r2(ix)) then ! r1 <= rrelens < r2
                    frrelens = (elens_r2(ix)/(rrelens**2))*             &
     &((((rrelens**2)/(r1elens**2))-1)/(elens_r2ovr1(ix)**2 - 1))
                  endif
                  if (rrelens.ge.elens_r2(ix)) then ! r1 < r2 <= rrelens
                    frrelens = elens_r2(ix)/(rrelens**2)
                  endif
                  yv(1,j)=yv(1,j)-elens_theta_max(ix)*frrelens*xelens   &
     &                 * oidpsv(j)
                  yv(2,j)=yv(2,j)-elens_theta_max(ix)*frrelens*yelens   &
     &                 * oidpsv(j)
                endif
! include bends at entrance and exit of elens
              case default
               write(lout,*) 'ERROR in deck kickelens: elens_type='     &
     &,elens_type(ix),' not recognized. Possible values for type are: ',&
     &'1.'
                call prror(-1) 
              end select
+cd scat_tck
      !Thick scattering
      if (scatter_debug) then
         write(lout,*) "SCATTER> In scat_tck, ix=",                     &
     &        ix, "bez='"//trim(bez(ix))//"' napx=",napx, "turn=",n
      endif
!     TODO
+cd scat_thi
      !Thin scattering
      ! It is already checked that scatter_elemPointer != 0
      call scatter_thin(ix,n)
      
+cd kickv01v
+if .not.tilt
            yv(2,j)=yv(2,j)+strack(i)*oidpsv(j)
+ei
+if tilt
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
+ei
+cd kickvxxv
+if .not.tilt
            yv(1,j)=yv(1,j)+(strack(i)*oidpsv(j))*cikve                  !hr02
            yv(2,j)=yv(2,j)+(strack(i)*oidpsv(j))*crkve                  !hr02
+ei
+if tilt
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
+ei
+cd kickl01h
+if .not.tilt
        dyy1=ekk
        dyy2=zero
+ei
+if tilt
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
+ei
+cd kicklxxh
+if .not.tilt
        dyy1=ekk*crkve
        dyy2=-ekk*cikve
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
+ei
+cd cclxxh
+if .not.tilt
        dyy1=ekk*crkve*cos_mb((((sigz/clight)*ek(IX)*c1e3)*two)*pi)
        dyy2=-ekk*cikve*cos_mb((((sigz/clight)*ek(IX)*c1e3)*two)*pi)
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
        dyy2=ekk*(tilts(k)*crkve-tiltc(k)*cikve)                         !hr02
+ei
+cd kickldpe
+if .not.tilt
        dyy1=(ed(IX)*crkve)/(one+dpp)                                    !hr02
        dyy2=(ek(IX)*cikve)/(one+dpp)                                    !hr02
+ei
+if tilt
        dyy1=((ed(IX)*tiltc(k))*crkve-(ek(IX)*tilts(k))*cikve)/(one+dpp) !hr02
        dyy2=((ek(IX)*tiltc(k))*cikve+(ed(IX)*tilts(k))*crkve)/(one+dpp) !hr02
+ei
+cd kicklso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            dyy1=(crkve*cos_mb(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_mb(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_mb(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_mb(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
+cd kickl01v
+if .not.tilt
        dyy1=zero
        dyy2=ekk
+ei
+if tilt
        dyy1=(-one*ekk)*tilts(k)                                         !hr08
        dyy2=ekk*tiltc(k)
+ei
+cd kicklxxv
+if .not.tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*cikve-tilts(k)*crkve)
        dyy2=ekk*(tiltc(k)*crkve+tilts(k)*cikve)
+ei
+cd kicku01h
+if .not.tilt
        y(1,1)=y(1,1)+ekk
+ei
+if tilt
        y(1,1)=y(1,1)+ekk*tiltc(k)
        y(1,2)=y(1,2)+ekk*tilts(k)
+ei
+cd kickuxxh
+if .not.tilt
        dyy1=ekk*crkve
        dyy2=(-one*ekk)*cikve                                            !hr08
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+ei
+if tilt
        dyy1=ekk*crkve
        dyy2=(-one*ekk)*cikve                                            !hr08
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickudpe
+if .not.tilt
        dyy1=ed(IX)*crkve
        dyy2=ek(IX)*cikve
        y(1,1)=y(1,1)+dyy1/(one+dpp)
        y(1,2)=y(1,2)+dyy2/(one+dpp)
+ei
+if tilt
        dyy1=(ed(IX)*crkve)/(one+dpp)                                    !hr02
        dyy2=(ek(IX)*cikve)/(one+dpp)                                    !hr02
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickuso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            dyy1=(crkve*cos_mb(ek(IX)/(one+dpp))+                       &!hr02
     &cikve*sin_mb(ek(IX)/(one+dpp)))-y(1,1)                             !hr02
            dyy2=(cikve*cos_mb(ek(IX)/(one+dpp))-                       &!hr02
     &crkve*sin_mb(ek(IX)/(one+dpp)))-y(1,2)                             !hr02
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+cd kicku01v
+if .not.tilt
        y(1,2)=y(1,2)+ekk
+ei
+if tilt
        y(1,1)=y(1,1)-ekk*tilts(k)
        y(1,2)=y(1,2)+ekk*tiltc(k)
+ei
+cd kickuxxv
+if .not.tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
+ei
+if tilt
        dyy1=ekk*cikve
        dyy2=ekk*crkve
        y(1,1)=(y(1,1)+tiltc(k)*dyy1)-tilts(k)*dyy2                      !hr02
        y(1,2)=(y(1,2)+tiltc(k)*dyy2)+tilts(k)*dyy1                      !hr02
+ei
+cd kickq01h
        qu=zero
        qv=zero
+cd kickq02h
+if .not.tilt
        qu=ekk
        qv=zero
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
        qv=(-one*ekk)*tiltsk                                             !hr08
+ei
+cd kickqdpe
+if .not.tilt
        qu=ed(IX)/(one+dpp)
        quz=ek(IX)/(one+dpp)
        qv=zero
        qvz=zero
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
        qv=((-one*ed(IX))*tiltsk)/(one+dpp)                              !hr02
        quz=((-one*ek(IX))*tiltck)/(one+dpp)                             !hr02
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
+ei
+cd kickqso1
        qu=ed(IX)
        qv=ek(IX)
+cd kickq03h
+if .not.tilt
        qu=(ekk*two)*crkve                                               !hr02
        qv=(ekk*two)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq04h
+if .not.tilt
        qu=(three*ekk)*crkve                                             !hr02
        qv=(three*ekk)*cikve                                             !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*crkve+tiltsk*cikve)                       !hr02
        qv=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
+ei
+cd kickq05h
+if .not.tilt
        qu=(four*ekk)*crkve                                              !hr02
        qv=(four*ekk)*cikve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(four*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
        qv=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
+ei
+cd kickq06h
+if .not.tilt
        qu=(five*ekk)*crkve                                               !hr02
        qv=(five*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(five*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(five*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq07h
+if .not.tilt
        qu=(six*ekk)*crkve                                               !hr02
        qv=(six*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(six*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(six*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq08h
+if .not.tilt
        qu=(seven*ekk)*crkve                                               !hr02
        qv=(seven*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(seven*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(seven*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq09h
+if .not.tilt
        qu=(eight*ekk)*crkve                                               !hr02
        qv=(eight*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(eight*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(eight*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq10h
+if .not.tilt
        qu=(nine*ekk)*crkve                                               !hr02
        qv=(nine*ekk)*cikve                                               !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(nine*ekk)*(tiltck*crkve+tiltsk*cikve)                         !hr02
        qv=(nine*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
+ei
+cd kickq01v
        qu=zero
        qv=zero
+cd kickq02v
+if .not.tilt
        qu=zero
        qv=-one*ekk                                                      !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(-one*ekk)*tiltsk                                             !hr02
        qv=(-one*ekk)*tiltck                                             !hr02
+ei
+cd kickq03v
+if .not.tilt
        qu=(ekk*two)*cikve                                               !hr02
        qv=((-one*ekk)*two)*crkve                                        !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=((-one*ekk)*two)*(tiltck*crkve+tiltsk*cikve)                  !hr02
+ei
+cd kickq04v
+if .not.tilt
        qu=(three*ekk)*cikve                                             !hr02
        qv=((-one*three)*ekk)*crkve                                      !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cikve-tiltsk*crkve)                       !hr02
        qv=((-one*three)*ekk)*(tiltck*crkve+tiltsk*cikve)                !hr02
+ei
+cd kickq05v
+if .not.tilt
        qu=(four*ekk)*cikve                                              !hr02
        qv=((-one*four)*ekk)*crkve                                       !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(four*ekk)*(tiltck*cikve-tiltsk*crkve)                        !hr02
        qv=((-one*four)*ekk)*(tiltck*crkve+tiltsk*cikve)                 !hr02
+ei
+cd kickq06v
+if .not.tilt
        qu=(five*ekk)*cikve                                               !hr02
        qv=(-five*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(five*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-five*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq07v
+if .not.tilt
        qu=(six*ekk)*cikve                                               !hr02
        qv=(-six*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(six*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-six*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq08v
+if .not.tilt
        qu=(seven*ekk)*cikve                                               !hr02
        qv=(-seven*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(seven*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-seven*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq09v
+if .not.tilt
        qu=(eight*ekk)*cikve                                               !hr02
        qv=(-eight*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(eight*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-eight*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kickq10v
+if .not.tilt
        qu=(nine*ekk)*cikve                                               !hr02
        qv=(-nine*ekk)*crkve                                              !hr02
+ei
+if tilt
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(nine*ekk)*(tiltck*cikve-tiltsk*crkve)                         !hr02
        qv=(-nine*ekk)*(tiltck*crkve+tiltsk*cikve)                        !hr02
+ei
+cd kicka01h
+if .not.tilt
        mpe=20
        dyy1=ekk
        dyy2=zero
        qu=zero
        qv=zero
+ei
+if tilt
        mpe=20
        dyy1=ekk*tiltc(k)
        dyy2=ekk*tilts(k)
        qu=zero
        qv=zero
+ei
+cd kicka02h
+if .not.tilt
        dyy1=ekk*xl
        dyy2=(-one*ekk)*zl                                                     !hr02
        mpe=20
        qu=ekk
        qv=zero
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*xl+tilts(k)*zl)
        dyy2=ekk*(tilts(k)*xl-tiltc(k)*zl)                               !hr08
        mpe=20
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=ekk*tiltck
        qv=(-one*ekk)*tiltsk                                             !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
+ei
+cd kickadpe
+if .not.tilt
        dyy1=(ed(IX)*xl)/(one+dpp)                                       !hr02
        dyy2=(ek(IX)*zl)/(one+dpp)                                       !hr02
        mpe=20
        qu=ed(IX)/(one+dpp)
        quz=ek(IX)/(one+dpp)
        qv=zero
        qvz=zero
+ei
+if tilt
        dyy1=((ed(IX)*tiltc(k))*xl-(ek(IX)*tilts(k))*zl)/(one+dpp)       !hr02
        dyy2=((ek(IX)*tiltc(k))*zl+(ed(IX)*tilts(k))*xl)/(one+dpp)       !hr02
        mpe=20
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ed(IX)*tiltck)/(one+dpp)                                     !hr02
        qv=((-one*ed(IX))*tiltsk)/(one+dpp)                              !hr02
        quz=((-one*ek(IX))*tiltck)/(one+dpp)                             !hr02
        qvz=(ek(IX)*tiltsk)/(one+dpp)                                    !hr02
+ei
+cd kickaso1
            crkve=y(1,1)-((x(1,1)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            cikve=y(1,2)-((x(1,2)*ed(IX))*ek(IX))/(one+dpp)              !hr02
            dyy1=(crkve*cos_mb(ek(IX))/(one+dpp))+                      &!hr02
     &(cikve*sin_mb(ek(IX))/(one+dpp))-y(1,1)                            !hr02
            dyy2=cikve*cos_mb(ek(IX)/(one+dpp))-                        &!hr02
     &crkve*sin_mb(ek(IX)/(one+dpp))-y(1,2)                              !hr02
        mpe=20
        qu=ed(IX)
        qv=ek(IX)
+cd phas1so1
!--solenoid
          elseif(kzz.eq.25) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
            enddo
+cd phas2so1
            crkve=t(i,2)-(t(i,1)*qu)*qv                                  !hr02
            cikve=t(i,4)-(t(i,3)*qu)*qv                                  !hr02
            t(i,2)=crkve*cos_mb(qv)+cikve*sin_mb(qv)                     !hr02
            t(i,4)=cikve*cos_mb(qv)-crkve*sin_mb(qv)                     !hr02
            crkve=t(i,1)*cos_mb(qv)+t(i,3)*sin_mb(qv)                    !hr02
            cikve=t(i,3)*cos_mb(qv)-t(i,1)*sin_mb(qv)                    !hr02
            t(i,1)=crkve
            t(i,3)=cikve
+cd phas3so1
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)             
              endif
              phi(l)=phi(l)+dphi/pie
            enddo
+cd kicka03h
+if .not.tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        qu=(ekk*two)*xl                                                  !hr02
        qv=(ekk*two)*zl                                                  !hr02
        ab2(2)=-one*qv                                                   !hr02
        ab1(3)=ekk
+ei
+if tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltck=tiltc(k)*tiltc(k)-tilts(k)*tilts(k)
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*xl+tiltsk*zl)                               !hr02
        qv=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltck
        ab2(3)=ekk*tiltsk
+ei
+cd kicka04h
+if .not.tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        qu=(three*ekk)*cxzyr                                             !hr02
        qv=(three*ekk)*cxzyi                                             !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(3)=(three*ekk)*xl                                            !hr02
        ab2(3)=((-one*three)*ekk)*zl                                     !hr02
        ab1(4)=ekk
+ei
+if tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                       !hr02
        qv=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        ab2(3)=(three*ekk)*(tiltsk*xl-tiltck*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltck
        ab2(4)=ekk*tiltsk
+ei
+cd kicka05h
+if .not.tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(3)=(six*ekk)*cxzyr                                           !hr02
        ab2(3)=(-six*ekk)*cxzyi                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*cxzyr                                              !hr02
        qv=(four*ekk)*cxzyi                                              !hr02
        ab2(2)=-one*qv                                                   !hr08
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(4)=(four*ekk)*xl                                             !hr02
        ab2(4)=((-one*four)*ekk)*zl                                      !hr02
        ab1(5)=ekk
+ei
+if tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        ab1(3)=(six*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        ab2(3)=(six*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        qv=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        ab2(4)=(four*ekk)*(tiltsk*xl-tiltck*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltck
        ab2(5)=ekk*tiltsk
+ei
+cd kicka06h
+if .not.tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(4)=(c1e1*ekk)*cxzyr                                          !hr02
        ab2(4)=(-c1e1*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(c1e1*ekk)*cxzyr                                          !hr02
        ab2(3)=(-c1e1*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(five*ekk)*cxzyr                                               !hr02
        qv=(five*ekk)*cxzyi                                               !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(5)=(five*ekk)*xl                                              !hr02
        ab2(5)=(-five*ekk)*zl                                             !hr02
        ab1(6)=ekk
+ei
+if tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        ab1(4)=(c1e1*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(c1e1*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(c1e1*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(c1e1*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(five*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(five*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=(five*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(5)=(five*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltck
        ab2(6)=ekk*tiltsk
+ei
+cd kicka07h
+if .not.tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(5)=(15.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(5)=(-15.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(4)=(-20.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(15.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(5)=(-15.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(six*ekk)*cxzyr                                               !hr02
        qv=(six*ekk)*cxzyi                                               !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(6)=(six*ekk)*xl                                              !hr02
        ab2(6)=(-six*ekk)*zl                                             !hr02
        ab1(7)=ekk
+ei
+if tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        ab1(5)=(15.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(15.0_fPrec*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(20.0_fPrec*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(15.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(5)=(15.0_fPrec*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(six*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(six*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=(six*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(6)=(six*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltck
        ab2(7)=ekk*tiltsk
+ei
+cd kicka08h
+if .not.tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(6)=(21.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(6)=(-21.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(5)=(-35.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(4)=(-35.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(3)=(-21.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(seven*ekk)*cxzyr                                               !hr02
        qv=(seven*ekk)*cxzyi                                               !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(7)=(seven*ekk)*xl                                              !hr02
        ab2(7)=(-seven*ekk)*zl                                             !hr02
        ab1(8)=ekk
+ei
+if tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        ab1(6)=(21.0_fPrec*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        ab2(6)=(21.0_fPrec*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(35.0_fPrec*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(35.0_fPrec*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(21.0_fPrec*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(seven*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(seven*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=(seven*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(7)=(seven*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltck
        ab2(8)=ekk*tiltsk
+ei
+cd kicka09h
+if .not.tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(7)=(28.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(7)=(-28.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(6)=(-56.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(5)=(-70.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(4)=(-56.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28.0_fPrec*ekk)*cxzyr                                          !hr02
        ab2(3)=(-28.0_fPrec*ekk)*cxzyi                                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(eight*ekk)*cxzyr                                               !hr02
        qv=(eight*ekk)*cxzyi                                               !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=(-one*ekk)*cxzyi                                            !hr02
        ab1(8)=(eight*ekk)*xl                                              !hr02
        ab2(8)=(-eight*ekk)*zl                                             !hr02
        ab1(9)=ekk
+ei
+if tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
        ab1(7)=(28.0_fPrec*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        ab2(7)=(28.0_fPrec*ekk)*(tiltsk5*cxzyr-tiltck5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56.0_fPrec*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        ab2(6)=(56.0_fPrec*ekk)*(tiltsk4*cxzyr-tiltck4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        ab2(5)=(70.0_fPrec*ekk)*(tiltsk3*cxzyr-tiltck3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        ab2(4)=(56.0_fPrec*ekk)*(tiltsk2*cxzyr-tiltck2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        ab2(3)=(28.0_fPrec*ekk)*(tiltsk1*cxzyr-tiltck1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(eight*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(eight*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=(eight*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        ab2(8)=(eight*ekk)*(tiltsk*xl-tiltck*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltck
        ab2(9)=ekk*tiltsk
+ei
+cd kicka10h
+if .not.tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(nine*ekk)*cxzyr                                               !hr02
        qv=(nine*ekk)*cxzyi                                               !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyr
        dyy2=-ekk*cxzyi
+ei
+if tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(nine*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                         !hr02
        qv=(nine*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        dyy2=ekk*(tilts(k)*cxzyr-tiltc(k)*cxzyi)                         !hr02
+ei
+cd kicka01v
+if .not.tilt
        mpe=20
        dyy1=zero
        dyy2=ekk
        qu=zero
        qv=zero
+ei
+if tilt
        mpe=20
        dyy1=(-one*ekk)*tilts(k)                                         !hr02
        dyy2=ekk*tiltc(k)
        qu=zero
        qv=zero
+ei
+cd kicka02v
+if .not.tilt
        dyy1=ekk*zl
        dyy2=ekk*xl
        mpe=2
        mx=-1
        qu=zero
        qv=-one*ekk                                                      !hr02
        ab2(2)=ekk
+ei
+if tilt
        dyy1=ekk*(tiltc(k)*zl-tilts(k)*xl)
        dyy2=ekk*(tiltc(k)*xl+tilts(k)*zl)
        mpe=2
        mx=-1
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(-one*ekk)*tiltsk                                             !hr02
        qv=(-one*ekk)*tiltck                                             !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
+ei
+cd kicka03v
+if .not.tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        qu=(ekk*two)*zl                                                  !hr02
        qv=((-one*ekk)*two)*xl                                           !hr02
        ab2(2)=-one*qv
        ab2(3)=ekk
+ei
+if tilt
        mpe=3
        mx=1
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(ekk*two)*(tiltck*zl-tiltsk*xl)                               !hr02
        qv=((-one*ekk)*two)*(tiltck*xl+tiltsk*zl)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=ekk*tiltsk
        ab2(3)=ekk*tiltck
+ei
+cd kicka04v
+if .not.tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        qu=(three*ekk)*cxzyi                                             !hr02
        qv=((-one*three)*ekk)*cxzyr                                      !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(3)=(three*ekk)*zl                                            !hr02
        ab2(3)=(three*ekk)*xl                                            !hr02
        ab2(4)=ekk
+ei
+if tilt
        mpe=4
        mx=2
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(three*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                       !hr02
        qv=((-one*three)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(3)=(three*ekk)*(tiltck*zl-tiltsk*xl)                         !hr02
        ab2(3)=(three*ekk)*(tiltck*xl+tiltsk*zl)                         !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=ekk*tiltsk
        ab2(4)=ekk*tiltck
+ei
+cd kicka05v
+if .not.tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(3)=(six*ekk)*cxzyi                                           !hr02
        ab2(3)=(six*ekk)*cxzyr                                           !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*cxzyi                                              !hr02
        qv=((-one*four)*ekk)*cxzyr                                       !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(4)=(four*ekk)*zl                                             !hr08
        ab2(4)=(four*ekk)*xl                                             !hr08
        ab2(5)=ekk
+ei
+if tilt
        mpe=5
        mx=3
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        ab1(3)=(six*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                   !hr02
        ab2(3)=(six*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(four*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=((-one*four)*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)
        ab1(2)=qu
        ab2(2)=-one*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck=tiltckuk
        ab1(4)=(four*ekk)*(tiltck*zl-tiltsk*xl)                          !hr02
        ab2(4)=(four*ekk)*(tiltck*xl+tiltsk*zl)                          !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=ekk*tiltsk
        ab2(5)=ekk*tiltck
+ei
+cd kicka06v
+if .not.tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(4)=(c1e1*ekk)*cxzyi                                          !hr02
        ab2(4)=(c1e1*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(c1e1*ekk)*cxzyi                                          !hr02
        ab2(3)=(c1e1*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(five*ekk)*cxzyi                                               !hr02
        qv=(-five*ekk)*cxzyr                                              !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(5)=(five*ekk)*zl                                              !hr02
        ab2(5)=(five*ekk)*xl                                              !hr02
        ab2(6)=ekk
+ei
+if tilt
        mpe=6
        mx=4
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        ab1(4)=(c1e1*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(c1e1*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(c1e1*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(c1e1*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(five*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-five*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck=tiltckuk
        ab1(5)=(five*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(5)=(five*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=ekk*tiltsk
        ab2(6)=ekk*tiltck
+ei
+cd kicka07v
+if .not.tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(5)=(15.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(5)=(15.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(4)=(20.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(15.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(3)=(15.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(six*ekk)*cxzyi                                               !hr02
        qv=(-six*ekk)*cxzyr                                              !hr02
        ab2(2)=-one*qv
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(6)=(six*ekk)*zl                                              !hr02
        ab2(6)=(six*ekk)*xl                                              !hr02
        ab2(7)=ekk
+ei
+if tilt
        mpe=7
        mx=5
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        ab1(5)=(15.0_fPrec*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(15.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(20.0_fPrec*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(20.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(15.0_fPrec*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(15.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(six*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)
        qv=(-six*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck=tiltckuk
        ab1(6)=(six*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(6)=(six*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=ekk*tiltsk
        ab2(7)=ekk*tiltck
+ei
+cd kicka08v
+if .not.tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(6)=(21.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(6)=(21.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(5)=(35.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(4)=(35.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(3)=(21.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(seven*ekk)*cxzyi                                               !hr02
        qv=(-seven*ekk)*cxzyr                                              !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(7)=(seven*ekk)*zl                                              !hr02
        ab2(7)=(seven*ekk)*xl                                              !hr02
        ab2(8)=ekk
+ei
+if tilt
        mpe=8
        mx=6
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        ab1(6)=(21.0_fPrec*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
        ab2(6)=(21.0_fPrec*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(35.0_fPrec*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(35.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(35.0_fPrec*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(35.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(21.0_fPrec*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(21.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(seven*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-seven*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck=tiltckuk
        ab1(7)=(seven*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(7)=(seven*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=ekk*tiltsk
        ab2(8)=ekk*tiltck
+ei
+cd kicka09v
+if .not.tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        ab1(7)=(28.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(7)=(28.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(6)=(56.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(5)=(70.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(4)=(56.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28.0_fPrec*ekk)*cxzyi                                          !hr02
        ab2(3)=(28.0_fPrec*ekk)*cxzyr                                          !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(eight*ekk)*cxzyi                                               !hr02
        qv=(-eight*ekk)*cxzyr                                              !hr02
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
        ab1(8)=(eight*ekk)*zl                                              !hr02
        ab2(8)=(eight*ekk)*xl                                              !hr02
        ab2(9)=ekk
+ei
+if tilt
        mpe=9
        mx=7
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk1=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck1=tiltckuk
        tiltckuk=tiltck1*tiltc(k)-tiltsk1*tilts(k)
        tiltsk2=tiltck1*tilts(k)+tiltsk1*tiltc(k)
        tiltck2=tiltckuk
        tiltckuk=tiltck2*tiltc(k)-tiltsk2*tilts(k)
        tiltsk3=tiltck2*tilts(k)+tiltsk2*tiltc(k)
        tiltck3=tiltckuk
        tiltckuk=tiltck3*tiltc(k)-tiltsk3*tilts(k)
        tiltsk4=tiltck3*tilts(k)+tiltsk3*tiltc(k)
        tiltck4=tiltckuk
        tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
        tiltsk5=tiltck4*tilts(k)+tiltsk4*tiltc(k)
        tiltck5=tiltckuk
        ab1(7)=(28.0_fPrec*ekk)*(tiltck5*cxzyi-tiltsk5*cxzyr)                  !hr02
        ab2(7)=(28.0_fPrec*ekk)*(tiltck5*cxzyr+tiltsk5*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(6)=(56.0_fPrec*ekk)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr02
        ab2(6)=(56.0_fPrec*ekk)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(5)=(70.0_fPrec*ekk)*(tiltck3*cxzyi-tiltsk3*cxzyr)                  !hr02
        ab2(5)=(70.0_fPrec*ekk)*(tiltck3*cxzyr+tiltsk3*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(4)=(56.0_fPrec*ekk)*(tiltck2*cxzyi-tiltsk2*cxzyr)                  !hr02
        ab2(4)=(56.0_fPrec*ekk)*(tiltck2*cxzyr+tiltsk2*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        ab1(3)=(28.0_fPrec*ekk)*(tiltck1*cxzyi-tiltsk1*cxzyr)                  !hr02
        ab2(3)=(28.0_fPrec*ekk)*(tiltck1*cxzyr+tiltsk1*cxzyi)                  !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(eight*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-eight*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        ab1(2)=qu
        ab2(2)=-one*qv                                                   !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
        tiltckuk=tiltck5*tiltc(k)-tiltsk5*tilts(k)
        tiltsk=tiltck5*tilts(k)+tiltsk5*tiltc(k)
        tiltck=tiltckuk
        ab1(8)=(eight*ekk)*(tiltck*zl-tiltsk*xl)                           !hr02
        ab2(8)=(eight*ekk)*(tiltck*xl+tiltsk*zl)                           !hr02
        tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
        tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
        tiltck=tiltckuk
        ab1(9)=ekk*tiltsk
        ab2(9)=ekk*tiltck
+ei
+cd kicka10v
+if .not.tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        qu=(nine*ekk)*cxzyi                                               !hr02
        qv=(-nine*ekk)*cxzyr                                              !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*cxzyi
        dyy2=ekk*cxzyr
+ei
+if tilt
        mpe=20
        cxzr=xl
        cxzi=zl
        cxzyr=cxzr**2-cxzi**2                                            !hr08
        cxzyi=cxzr*cxzi+cxzi*cxzr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr08
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr02
        qu=(nine*ekk)*(tiltck*cxzyi-tiltsk*cxzyr)                         !hr02
        qv=(-nine*ekk)*(tiltck*cxzyr+tiltsk*cxzyi)                        !hr02
        cxzyrr=cxzyr*cxzr-cxzyi*cxzi
        cxzyi=cxzyr*cxzi+cxzyi*cxzr
        cxzyr=cxzyrr
        dyy1=ekk*(tiltc(k)*cxzyi-tilts(k)*cxzyr)
        dyy2=ekk*(tiltc(k)*cxzyr+tilts(k)*cxzyi)
+ei
+cd bpmdata
!---------Collect BPM data
          if(ix.gt.0.and.bez(ix)(1:3).eq.'BPM'.and.n.lt.100001) then
          if(n.eq.1) then
            open(ix+100,file=bez(ix),status='unknown')
            endif
            write(ix+100,'(7e18.10,1x)') xv(1,1),yv(1,1),xv(2,1),       &
     &yv(2,1), sigmv(1), dpsv(1),ejfv(1)
          if(n.eq.100000) then
            close(ix+100)
            endif
          endif
+cd crabkick
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3

        do j=1,napx ! loop over particles
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03

+if .not.tilt
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph(ix))         !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*two)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph(ix)))*c1m3   !hr03
+ei
+if tilt
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph(ix))         !hr03
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*two)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph(ix)))*c1m3   !hr03
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
+cd ccmul2
! JBG RF CC Multipoles
          pi=four*atan_mb(one)
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 2', crabamp2
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph2(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((half*(crabamp2*oidpsv(j)))*(crkve**2-       &!hr13
     &cikve**2))*(((crabfreq*two)*pi)/clight))*c1m3)*                   &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
+ei
+if tilt
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((half*(crabamp2*oidpsv(j)))*(crkve**2-       &!hr13
     &cikve**2))*(((crabfreq*two)*pi)/clight))*c1m3)*                   &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul2s
! JBG RF CC Multipoles 2
          pi=four*atan_mb(one)
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
+ca alignva
+if .not.tilt
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*two)*pi)/clight))*c1m3)*                             & 
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
+ei
+if tilt
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*two)*pi)/clight))*c1m3)*                             & 
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph2(ix))
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul3
! JBG RF CC Multipoles
          pi=four*atan_mb(one)
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 3', crabamp3
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph3(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((two*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((one/three)*(crabamp3*oidpsv(j)))*(crkve**3-  &!hr13
     &(three*cikve**2)*crkve))*(((crabfreq*two)*pi)/clight))*c1m6)*     &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
+ei
+if tilt
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      yv(2,j)=yv(2,j)-((two*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)-(((((one/three)*(crabamp3*oidpsv(j)))*(crkve**3-  &!hr13
     &(three*cikve**2)*crkve))*(((crabfreq*two)*pi)/clight))*c1m6)*     &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
+ei
       ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul3s
! JBG RF CC Multipoles 2
          pi=four*atan_mb(one)
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
+ca alignva
+if .not.tilt
!        yv(2,j)=yv(2,j)-2*(1/2.)*(crabamp3*oidpsv(j))*c1m3*             &
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((two*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((one/three)*(crabamp3*oidpsv(j)))*(cikve**3-  &
     &((three*crkve**2)*cikve)))*(((crabfreq*two)*pi)/clight))*c1m6)*   & 
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
+ei
+if tilt
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         & 
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((two*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((one/three)*(crabamp3*oidpsv(j)))*(cikve**3-  &
     &((three*crkve**2)*cikve)))*(((crabfreq*two)*pi)/clight))*c1m6)*   & 
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph3(ix))
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul4
! JBG RF CC Multipoles
          pi=four*atan_mb(one)
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
!          write(*,*) ''
!          write(*,*) '-------------------'
!          write(*,*) 'CRAB AMP 4', crabamp4
!          write(*,*) 'FREQ',  crabfreq
!          write(*,*) 'PHASE', crabph4(ix)
!          write(*,*) '-------------------'
          do j=1,napx
+ca alignva
+if .not.tilt
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(three*crkve)*cikve**2))*c1m6)*                         &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((three*cikve)*crkve**2-cikve**3))*c1m6)*                         &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((0.25_fPrec*(crabamp4*oidpsv(j)))*(crkve**4- &!hr13
     &(six*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*two)*pi)/clight))*c1m9)*                              &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
+ei
+if tilt
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(three*crkve)*cikve**2))*c1m6)*                         &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((three*cikve)*crkve**2-cikve**3))*c1m6)*                         &!hr13
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((0.25_fPrec*(crabamp4*oidpsv(j)))*(crkve**4- &!hr13
     &(six*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*two)*pi)/clight))*c1m9)*                              &!hr13
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd ccmul4s
! JBG RF CC Multipoles
          pi=four*atan_mb(one)
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
          do j=1,napx
+ca alignva
+if .not.tilt
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(three*cikve)*crkve**2))*c1m6)*                         &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((three*crkve)*cikve**2-crkve**3))*c1m6)*                         &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*tow)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*two)*pi)/clight))*c1m9)*                              &
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
+ei
+if tilt
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(three*cikve)*crkve**2))*c1m6)*                         &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((three*crkve)*cikve**2-crkve**3))*c1m6)*                         &
     &cos_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*two)*pi)/clight))*c1m9)*                              &
     &sin_mb((((sigmv(j)/clight)*crabfreq)*two)*pi + crabph4(ix))
+ei
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
+cd acdipkick
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=four*atan_mb(one)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
          acdipamp=(ed(ix)*clight)*c1m3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
+if .not.tilt
              if(nramp1.gt.nac) then
                yv(xory,j)=yv(xory,j)+(((acdipamp*                      &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &real(nac,fPrec))/real(nramp1,fPrec))/ejfv(j)                       !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
                yv(xory,j)=yv(xory,j)+(acdipamp*                        &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))/ejfv(j)             !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
              yv(xory,j)=yv(xory,j)+((acdipamp*                         &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &((-one*real(nac-nramp1-nramp2-nplato,fPrec))/real(nramp2,fPrec)))/&
     &ejfv(j)      !hr03
              endif
+ei
+if tilt
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &real(nac,fPrec))/real(nramp1,fPrec))/ejfv(j)                       !hr03
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &real(nac,fPrec))/real(nramp1,fPrec))/ejfv(j)                       !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))/ejfv(j)             !hr03
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))/ejfv(j)             !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &((-one*real(nac-nramp1-nramp2-nplato,fPrec))/                     &
     &real(nramp2,fPrec)))/ejfv(j)      !hr03
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin_mb(((two*pi)*qd)*real(nac,fPrec)+acphase))*                   &!hr03
     &((-one*real(nac-nramp1-nramp2-nplato,fPrec))/                     &
     &real(nramp2,fPrec)))/ejfv(j)      !hr03
              endif
+ei
      enddo
      endif
+cd kispa10h
+if .not.tilt
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          ekko=ekk
          cxzyr=cxzr**2-cxzi**2                                          !hr08
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36.0_fPrec*ekko)*cxzyr                                    !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126.0_fPrec*ekko)*cxzyr                                   !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84.0_fPrec*ekko)*cxzyr                                    !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
          ekk=ekko*tiltck10
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36.0_fPrec*ekko)*(tiltck8*cxzyr+tiltsk8*cxzyi)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126.0_fPrec*ekko)*(tiltck6*cxzyr+tiltsk6*cxzyi)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84.0_fPrec*ekko)*(tiltck4*cxzyr+tiltsk4*cxzyi)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd kispa10v
+if .not.tilt
          ekko=ekk
          cxzyr=cxzr**2-cxzi**2                                          !hr08
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36.0_fPrec*ekko)*cxzyi                                          !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126.0_fPrec*ekko)*cxzyi                                         !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84.0_fPrec*ekko)*cxzyi                                          !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
          tiltck=tiltc(k)**2-tilts(k)**2                                 !hr08
          tiltsk=two*tiltc(k)*tilts(k)
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck4=tiltckuk
          tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
          tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck6=tiltckuk
          tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
          tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck8=tiltckuk
          tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
          tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
          tiltck=tiltckuk
          tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
          tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
          tiltck10=tiltckuk
          ekko=ekk
          ekk=(-one*ekko)*tiltsk10                                       !hr03
          call detune(5,ekk,ep,beta,dtu,dtup,dfac)
          cxzyr=cxzr*cxzr-cxzi*cxzi
          cxzyi=cxzr*cxzi+cxzi*cxzr
          ekk=(36.0_fPrec*ekko)*(tiltck8*cxzyi-tiltsk8*cxzyr)                  !hr03
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(126.0_fPrec*ekko)*(tiltck6*cxzyi-tiltsk6*cxzyr)                 !hr03
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          cxzyrr=cxzyr*cxzr-cxzyi*cxzi
          cxzyi=cxzyr*cxzi+cxzyi*cxzr
          cxzyr=cxzyrr
          ekk=(84.0_fPrec*ekko)*(tiltck4*cxzyi-tiltsk4*cxzyr)                  !hr03
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd beams1
!start: beam-beam element
      if(nbeam.ge.1) then
        do 15 i=1,nbb
          nbeaux(i)=0
   15   continue
        do i=1,iu
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(kz(ix).eq.20.and.parbe(ix,2).eq.zero) then                 !hr03
!--round beam
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.2.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=1
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                endif
              endif
!--elliptic beam x>z
              if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=2
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
!--elliptic beam z>x
              if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.2) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=3
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
            endif
          endif
        enddo
      endif
!end: beam-beam element
+cd beams21
!--beam-beam element
        if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.zero) then         !hr08
          strack(i)=crad*ptnfac(ix)
          if(abs(strack(i)).le.pieni) then
            ktrack(i)=31
            goto 290
          endif
          if(nbeaux(imbb(i)).eq.1) then
            ktrack(i)=41
            if(ibeco.eq.1) then
              do 42 j=1,napx
+cd beams22
   42         continue
            endif
          endif
          if(nbeaux(imbb(i)).eq.2) then
            ktrack(i)=42
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
+cd beams23
            endif
            endif
          endif
          if(nbeaux(imbb(i)).eq.3) then
            ktrack(i)=43
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
+cd beams24
            endif
            endif
          endif
          goto 290
!--Hirata's 6D beam-beam kick
        else if(kzz.eq.20.and.parbe(ix,2).gt.zero) then                   !hr03
          ktrack(i)=44
          parbe(ix,4)=(((-one*crad)*ptnfac(ix))*half)*c1m6               !hr03
          if(ibeco.eq.1) then
            track6d(1,1)=parbe(ix,5)*c1m3
            track6d(2,1)=zero
            track6d(3,1)=parbe(ix,6)*c1m3
            track6d(4,1)=zero
            track6d(5,1)=zero
            track6d(6,1)=zero
            napx0=napx
            napx=1
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            beamoff(1,imbb(i))=track6d(1,1)*c1e3
            beamoff(2,imbb(i))=track6d(3,1)*c1e3
            beamoff(4,imbb(i))=track6d(2,1)*c1e3
            beamoff(5,imbb(i))=track6d(4,1)*c1e3
            beamoff(6,imbb(i))=track6d(6,1)
            napx=napx0
          endif
          goto 290
        endif
+cd wire
! wire
        if(kzz.eq.15) then
          ktrack(i)=45
          goto 290
        endif
+cd elens
!electron lens (HEL)
        if(kzz.eq.29) then
          ktrack(i)=63
          goto 290
        endif
+cd scatter
! SCATTER block
       if (kzz.eq.40 .and. scatter_elemPointer(ix).ne.0) then
          ! FOR NOW, ASSUME THIN SCATTER; ktrack(i)=65 RESERVED FOR THICK SCATTER
          ktrack(i)=64
          goto 290
        endif
+cd crab1
        if(kzz.eq.23) then
          ktrack(i)=53
          goto 290
        else if(kzz.eq.-23) then
          ktrack(i)=54
          goto 290
        endif
! JBG RF CC Multipoles
+cd crab_mult
        if(kzz.eq.26) then
          ktrack(i)=57
          goto 290
        else if(kzz.eq.-26) then
          ktrack(i)=58
          goto 290
        endif
        if(kzz.eq.27) then
          ktrack(i)=59
          goto 290
        else if(kzz.eq.-27) then
          ktrack(i)=60
          goto 290
        endif
        if(kzz.eq.28) then
          ktrack(i)=61
          goto 290
        else if(kzz.eq.-28) then
          ktrack(i)=62
          goto 290
        endif
+cd acdip1
        if(kzz.eq.16) then
          ktrack(i)=51
          goto 290
        else if(kzz.eq.-16) then
          ktrack(i)=52
          goto 290
        endif
+cd beamcof
!FOX  CRKVEBF=X(1) ;
!FOX  CIKVEBF=X(2) ;
            startco=(dare(x(1))-clobeam(1,imbb(i)))+parbe(ix,5)
+if debug
!     if (umcalls.eq.8) then
!       call wda('startco',startco,1,0,0,0)
!     endif
+ei
            call dapok(crkvebf,jj,startco)
            startco=(dare(x(2))-clobeam(2,imbb(i)))+parbe(ix,6)
+if debug
!     if (umcalls.eq.8) then
!       call wda('startco',startco,2,0,0,0)
!     endif
+ei
            call dapok(cikvebf,jj,startco)
            if(ibbc.eq.1) then
!FOX  CCCC=CRKVEBF ;
!FOX  CRKVEBF=CCCC*BBCU(IMBB(I),11)+CIKVEBF*BBCU(IMBB(I),12) ;
!FOX  CIKVEBF=-CCCC*BBCU(IMBB(I),12)+CIKVEBF*BBCU(IMBB(I),11) ;
            endif
+cd beamr1f
!FOX  RHO2BF=CRKVEBF*CRKVEBF+CIKVEBF*CIKVEBF ;
+cd beamr1of
            if(ibbc.eq.0) then
              crk=parbe(ix,5)
              cik=parbe(ix,6)
            else
               crk=parbe(ix,5)*bbcu(imbb(i),11) +                       &
     &             parbe(ix,6)*bbcu(imbb(i),12)
               cik=parbe(ix,6)*bbcu(imbb(i),11) -                       &
     &             parbe(ix,5)*bbcu(imbb(i),12)
            endif
            rho2b=crk**2+cik**2                                          !hr03
            if(rho2b.gt.pieni) &
+cd beamr2f
      if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=RHO2BF/(TWO*SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I))) ;
+cd beamr2s
            if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
            tkbf=rho2bf/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))      !hr03
+cd beamr2of
            if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
            tkb=rho2b/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))        !hr03
+cd beamr3f
      if(ibbc.eq.0) then
!FOX   Y(1)=Y(1)+(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)/(ONE+DPDA) ;
!FOX   Y(2)=Y(2)+(CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)/(ONE+DPDA) ;
      else
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC/(ONE+DPDA) ;
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC/(ONE+DPDA) ;
      endif
+cd beamr3s1
              qu1=((((crad*ptnfac(ix))*crkvebf)/                        &!hr03
     &rho2bf)*(one-exp_mb(-one*tkbf)))/(one+dpp)                         !hr03
              qv1=((((crad*ptnfac(ix))*cikvebf)/                        &!hr03
     &rho2bf)*(one-exp_mb(-one*tkbf)))/(one+dpp)                         !hr03
+cd beamr3s2
              qu=((qu1-((((crad*ptnfac(ix))*crkvebf)/                   &!hr03
     &rho2bf)*(one-exp_mb(-one*tkbf)))/(one+dpp))/crkve)*half            !hr03
              qv=((qv1-((((crad*ptnfac(ix))*cikvebf)/                   &!hr03
     &rho2bf)*(one-exp_mb(-one*tkbf)))/(one+dpp))/cikve)*half            !hr03
+cd beamr3of
            beamoff4=(((crad*ptnfac(ix))*crk)/                          &!hr03
     &rho2b)*(one-exp_mb(-one*tkb))                                      !hr03
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!       write(*,*) 'beamoff4 1',beamoff4
!       call wda('beamoff4',beamoff4,1,0,0,0)
!     endif
+ei
            beamoff5=(((crad*ptnfac(ix))*cik)/                          &!hr03
     &rho2b)*(one-exp_mb(-one*tkb))                                      !hr03
+cd beam11s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2bf=two*(sigman(1,imbb(i))**2-                             &!hr08
     &sigman(2,imbb(i))**2)                                              !hr08
+cd beam21s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2bf=two*(sigman(2,imbb(i))**2-                             &!hr08
     &sigman(1,imbb(i))**2)                                              !hr08
+if debug
!     if (umcalls.eq.8) then
!       call wda('r2bf',r2bf,1,0,0,0)
!     endif
+ei
+cd beam11of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2b=two*(sigman(1,imbb(i))**2-                              &!hr08
     &sigman(2,imbb(i))**2)                                              !hr08
+cd beam21of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            r2b=two*(sigman(2,imbb(i))**2-                              &!hr08
     &sigman(1,imbb(i))**2)                                              !hr08
+cd beama1s
            rbf=sqrt(r2bf)
            rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
+if debug
!     if (umcalls.eq.8) then
!       call wda('rkbf',rkbf,1,0,0,0)
!     endif
+ei
+cd beama1of
            rb=sqrt(r2b)
            rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
+cd beama2f
!FOX  XRBF=CRKVEBF/RBF ;
      if(dare(xrbf).lt.zero) then
!FOX  XRBF=-XRBF ;
      endif
!FOX  ZRBF=CIKVEBF/RBF ;
      if(dare(zrbf).lt.zero) then
!FOX  ZRBF=-ZRBF ;
      endif
+cd beama2s
            xrbf=abs(crkvebf/rbf)
            zrbf=abs(cikvebf/rbf)
+cd beama2of
            if(ibbc.eq.0) then
               crk=parbe(ix,5)
               cik=parbe(ix,6)
            else
               crk=parbe(ix,5)*bbcu(imbb(i),11) +                       &
     &             parbe(ix,6)*bbcu(imbb(i),12)
               cik=parbe(ix,6)*bbcu(imbb(i),11) -                       &
     &             parbe(ix,5)*bbcu(imbb(i),12)
            endif
            xrb=abs(crk)/rb
            zrb=abs(cik)/rb
+cd beam12f
            call errff(xrbf,zrbf,crxbf,crzbf)
+cd beam12s
            call errf(xrbf,zrbf,crxbf,crzbf)
+cd beam12of
+if debug
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
            call errf(xrb,zrb,crxb,crzb)
+if debug
!     call wda('12ofcrxb',crxb,0,0,0,0)
!     call wda('12ofcrzb',crzb,0,0,0,0)
!     write(*,*) '12ofcrxb',crxb
!     write(*,*) '12ofcrzb',crzb
!
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
+cd beam22f
            call errff(zrbf,xrbf,crzbf,crxbf)
+cd beam22s
            call errf(zrbf,xrbf,crzbf,crxbf)
+cd beam22of
+if debug
!     call wda('12ofxrb',xrb,0,0,0,0)
!     call wda('12ofzrb',zrb,0,0,0,0)
!     write(*,*) '12ofxrb',xrb
!     write(*,*) '12ofzrb',zrb
+ei
            call errf(zrb,xrb,crzb,crxb)
+if debug
!     call wda('22ofcrxb',crxb,0,0,0,0)
!     call wda('22ofcrzb',crzb,0,0,0,0)
!     write(*,*) '22ofcrxb',crxb
!     write(*,*) '22ofcrzb',crzb
!
!     call wda('22ofxrb',xrb,0,0,0,0)
!     call wda('22ofzrb',zrb,0,0,0,0)
!     write(*,*) '22ofxrb',xrb
!     write(*,*) '22ofzrb',zrb
+ei
+cd beama3f
      if(abs(sigman(1,imbb(i))).lt.pieni.or.                            &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
!FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
!FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
!FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
+cd beama3s
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            tkbf=(crkvebf**2/sigman(1,imbb(i))**2+                      &!hr03
     &cikvebf**2/sigman(2,imbb(i))**2)*half                              !hr03
            xbbf=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrbf              !hr03
            zbbf=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrbf              !hr03
+cd beama3of
            if(abs(sigman(1,imbb(i))).lt.pieni.or.                      &
     &abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
            tkb=(crk**2/sigman(1,imbb(i))**2+                           &!hr03
     &cik**2/sigman(2,imbb(i))**2)*half                                  !hr03
            xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
            zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
+cd beam13f
            call errff(xbbf,zbbf,cbxbf,cbzbf)
+cd beam13s
            call errf(xbbf,zbbf,cbxbf,cbzbf)
+cd beam13of
            call errf(xbb,zbb,cbxb,cbzb)
+cd beam23f
            call errff(zbbf,xbbf,cbzbf,cbxbf)
+cd beam23s
            call errf(zbbf,xbbf,cbzbf,cbxbf)
+cd beam23of
            call errf(zbb,xbb,cbzb,cbxb)
+cd beama4f
      scrkveb=sign(one,dare(crkvebf))
      scikveb=sign(one,dare(cikvebf))
+if debug
!     call wda('a4f1',scrkveb,1,0,0,0)
!     call wda('a4f1',scikveb,1,0,0,0)
!     call wda('ibbc',0d0,ibbc,0,0,0)
+ei
      if(ibbc.eq.0) then
+if debug
!ERIC PROBLEM IS HERE before wda of y1/y2
!       if (umcalls.eq.8) then
!         call wda('bexpy1',0d0,1,0,0,0)
!         write(*,*) 'Here we are'
!         call dumpda('bexpy1',1,0)
!         read(444)
!       endif
+ei
!FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)/(ONE+DPDA) ;
+if debug
!     if (umcalls.eq.8) then
!       call wda('aexpy1',y(1),1,0,0,0)
!       write(*,*) 'Hereafter'
!         call dumpda('aexpy1',1,0)
!       read(444)
!     endif
+ei
!FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)/(ONE+DPDA) ;
+if debug
!     call wda('a4f1 0 y1',y(1),1,0,0,0)
!     call wda('a4f1 0 y2',y(2),2,0,0,0)
+ei
      else
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC/(ONE+DPDA) ;
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC/(ONE+DPDA) ;
+if debug
!     call wda('a4f1 n y1',y(1),1,0,0,0)
!     call wda('a4f1 n y2',y(2),2,0,0,0)
+ei
      endif
+cd beama4s1
              qu1=((rkbf*(crzbf-exp_mb(-one*tkbf)*cbzbf))*               !hr03
     &sign(one,crkvebf))/(one+dpp)                                       !hr03
              qv1=((rkbf*(crxbf-exp_mb(-one*tkbf)*cbxbf))*               !hr03
     &sign(one,cikvebf))/(one+dpp)                                       !hr03
+cd beama4s2
              qu=((qu1-((rkbf*(crzbf-exp_mb(-one*tkbf)*cbzbf))*         &!hr03
     &sign(one,crkvebf))/(one+dpp))/crkve)*half                          !hr03
              qv=((qv1-((rkbf*(crxbf-exp_mb(-one*tkbf)*cbxbf))*          !hr03
     &sign(one,cikvebf))/(one+dpp))/cikve)*half                          !hr03
+cd beama4of
+if debug
!     call wda('4ofrkb',rkb,0,0,0,0)
!     call wda('4ofcrzb',crzb,0,0,0,0)
!     call wda('4oftkb',tkb,0,0,0,0)
!     call wda('4ofcbzb',cbzb,0,0,0,0)
!     call wda('4ofcrk',crk,0,0,0,0)
!     call wda('4ofexp',-exp_mb(-one*tkb),0,0,0,0)
!
!     write(*,*) '4ofrkb',rkb
!     write(*,*) '4ofcrzb',crzb
!     write(*,*) '4oftkb',tkb
!     write(*,*) '4ofcbzb',cbzb
!     write(*,*) '4ofcrk',crk
!     write(*,*) '4ofexp',-exp_mb(-one*tkb)
+ei
              beamoff4=(rkb*(crzb-exp_mb(-one*tkb)*cbzb))*              &!hr03
     &sign(one,crk)                                                      !hr03
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!       write(*,*) 'beamoff4 2',beamoff4
!       call wda('beamoff4',beamoff4,2,0,0,0)
!       call dumpda('beamoff4',0,0)
!       call dumpum('beamoff4',0,0)
!       read(222)
!     endif
+ei
              beamoff5=(rkb*(crxb-exp_mb(-one*tkb)*cbxb))*              &!hr03
     &sign(one,cik)                                                      !hr03
+cd beamco
              if(ibbc.eq.0) then
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6)
              else
                crkveb(j)=                                              &
     &((xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5))*bbcu(imbb(i),11) +     &
     &((xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6))*bbcu(imbb(i),12)
                cikveb(j)=                                              &
     &((xv(2,j)-clobeam(2,imbb(i)))+parbe(ix,6))*bbcu(imbb(i),11) -     &
     &((xv(1,j)-clobeam(1,imbb(i)))+parbe(ix,5))*bbcu(imbb(i),12)
              endif
+cd beamcoo
              if(ibbc.eq.0) then
                crkveb(j)=parbe(ix,5)
                cikveb(j)=parbe(ix,6)
              else
                crkveb(j)=parbe(ix,5)*bbcu(imbb(i),11) +                &
     &                parbe(ix,6)*bbcu(imbb(i),12)
                cikveb(j)=parbe(ix,6)*bbcu(imbb(i),11)-                 &
     &               parbe(ix,5)*bbcu(imbb(i),12)
              endif
+cd beamr1
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
+cd beamr2
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
+cd beamr3
            if(ibbc.eq.0) then
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(4,imbb(i)))                      !hr03
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(5,imbb(i)))                      !hr03
            else
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-   &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)     !hr03
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+   &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp_mb(-one*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)     !hr03
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
+cd beamr3o
                beamoff(4,imbb(i))=((strack(i)*crkveb(j))/rho2b(j))*    &!hr03
     &(one-exp_mb(-one*tkb(j)))                                          !hr03
                beamoff(5,imbb(i))=((strack(i)*cikveb(j))/rho2b(j))*    &!hr03
     &(one-exp_mb(-one*tkb(j)))                                          !hr03
+cd beam11
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
+cd beam21
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
+cd beama1
              rb(j)=sqrt(r2b(j))
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
+cd beama2
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
+cd beam12
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
+cd beam22
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
+cd beama3
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
+cd beam13
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
+cd beam23
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
+cd beama4
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp_mb(-one*tkb(j))*                                              &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp_mb(-one*tkb(j))*                                              &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
              else
                cccc=((rkb(j)*(crzb(j)-exp_mb(-one*tkb(j))*cbzb(j)))*   &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp_mb(-one*tkb(j))*cbxb(j)))* &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)           !hr03
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
                cccc=((rkb(j)*(crzb(j)-exp_mb(-one*tkb(j))*cbzb(j)))*   &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp_mb(-one*tkb(j))*cbxb(j)))* &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
+cd beama4o
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp_mb(-one*tkb(j))*  &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp_mb(-one*tkb(j))*  &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
            enddo
+cd beamwzf1
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
+cd beamwzf2
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
+cd beam6d
!--Hirata's 6D beam-beam kick
            do j=1,napx
               track6d(1,j)=((xv(1,j)+parbe(ix,5)) -                    &
     &              clobeam(1,imbb(i)))*c1m3
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+parbe(ix,6)) -                     &
     &             clobeam(2,imbb(i)))*c1m3
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
+cd beam6dfi
          parbe(ix,4)=(((-one*crad)*ptnfac(ix))*half)*c1m6               !hr08
!--Hirata's 6D beam-beam kick
          dummy=dare(x(1))
!FOX      TRACKI(1)=(X(1)+PARBE(IX,5)-DUMMY)*C1M3 ;
!FOX      YP(1)=Y(1)*(ONE+DPDA) ;
          dummy=dare(yp(1))
!FOX      TRACKI(2)=(YP(1)-DUMMY)*C1M3 ;
          dummy=dare(x(2))
!FOX      TRACKI(3)=(X(2)+PARBE(IX,6)-DUMMY)*C1M3 ;
!FOX      YP(2)=Y(2)*(ONE+DPDA) ;
          dummy=dare(yp(2))
!FOX      TRACKI(4)=(YP(2)-DUMMY)*C1M3 ;
          dummy=dare(sigmda)
!FOX      TRACKI(5)=(SIGMDA-DUMMY)*C1M3 ;
          dummy=dare(dpda)
!FOX      TRACKI(6)=DPDA-DUMMY ;
          call beaminf(tracki,parbe,sigz,bbcu,imbb(i),ix,ibbc)
          if(ibeco.eq.1) then
            beamoff1=dare(tracki(1))*c1e3
            beamoff2=dare(tracki(3))*c1e3
            beamoff4=dare(tracki(2))*c1e3
            beamoff5=dare(tracki(4))*c1e3
            beamoff6=dare(tracki(6))
          else
            beamoff1=zero
            beamoff2=zero
            beamoff4=zero
            beamoff5=zero
            beamoff6=zero
          endif
+if debug
!GOTCHA
!     if (dokcalls.ge.445959) then
!         write(*,*) 'beamoff4 3',beamoff4
!       call wda('beamoff4',beamoff4,3,0,0,0)
!     endif
+ei
          dummy=dare(x(1))
!FOX      X(1)=TRACKI(1)*C1E3+DUMMY-BEAMOFF1 ;
          dummy=dare(x(2))
!FOX      X(2)=TRACKI(3)*C1E3+DUMMY-BEAMOFF2 ;
          dummy=dare(yp(1))
!FOX      YP(1)=TRACKI(2)*C1E3+DUMMY-BEAMOFF4 ;
          dummy=dare(yp(2))
!FOX      YP(2)=TRACKI(4)*C1E3+DUMMY-BEAMOFF5 ;
          dummy=dare(dpda)
!FOX      DPDA=TRACKI(6)+DUMMY-BEAMOFF6 ;
!FOX      DPDA1=DPDA*C1E3 ;
!FOX      Y(1)=YP(1)/(ONE+DPDA) ;
!FOX      Y(2)=YP(2)/(ONE+DPDA) ;
!FOX      EJF1=E0F*(ONE+DPDA) ;
!FOX      EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX      RV=EJ1/E0*E0F/EJF1 ;
          if(ithick.eq.1) call envada
+cd multf01
+if .not.tilt
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!FOX  DKIP=DKI(IX,1)/(ONE+DPDA) ;
!FOX  Y(1)=Y(1)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*DKIP ;
            else
!FOX  Y(1)=Y(1)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
!FOX  SIGMDA=SIGMDA+RV*DKI(IX,1)*XL ;
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!FOX  DKIP=DKI(IX,2)/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)-(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*DKIP ;
            else
!FOX  Y(2)=Y(2)+DKI(IX,2)*DPDA*C1E3/(ONE+DPDA) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
!FOX  SIGMDA=SIGMDA-RV*DKI(IX,2)*ZL ;
            endif
          endif
+ei
+if tilt
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!FOX  DKIP=DKI(IX,1)/(ONE+DPDA) ;
!FOX  Y(1)=Y(1)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*
!FOX  TILTC(I)*DKIP
!FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*(ONE-TILTC(I)) ;
!FOX  Y(2)=Y(2)-(DKI(IX,1)/DKI(IX,3)*XL+DPDA*C1E3)*
!FOX  TILTS(I)*DKIP
!FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*TILTS(I) ;
            else
!FOX  Y(1)=Y(1)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA)*TILTC(I)
!FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*(ONE-TILTC(I)) ;
!FOX  Y(2)=Y(2)-DKI(IX,1)*DPDA*C1E3/(ONE+DPDA)*TILTS(I)
!FOX  +C1E3*DKI(IX,1)/(ONE+DPDA)*TILTS(I) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
!FOX  SIGMDA=SIGMDA+RV*DKI(IX,1)*XL ;
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
!FOX  DKIP=DKI(IX,2)/(ONE+DPDA) ;
!FOX  Y(1)=Y(1)+(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*
!FOX  TILTS(I)*DKIP
!FOX  +C1E3*DKI(IX,2)/(ONE+DPDA)*TILTS(I) ;
!FOX  Y(2)=Y(2)-(DKI(IX,2)/DKI(IX,3)*ZL-DPDA*C1E3)*
!FOX  TILTC(I)*DKIP
!FOX  -C1E3*DKI(IX,2)/(ONE+DPDA)*(ONE-TILTC(I)) ;
            else
!FOX  Y(1)=Y(1)-DKI(IX,2)*DPDA*C1E3/(ONE+DPDA)*TILTS(I)
!FOX  +C1E3*DKI(IX,2)/(ONE+DPDA)*TILTS(I) ;
!FOX  Y(2)=Y(2)+DKI(IX,2)*DPDA*C1E3/(ONE+DPDA)*TILTC(I)
!FOX  -C1E3*DKI(IX,2)/(ONE+DPDA)*(ONE-TILTC(I)) ;
            endif
            if(idp.eq.1.and.iabs(ition).eq.1) then
!FOX  SIGMDA=SIGMDA-RV*DKI(IX,2)*ZL ;
            endif
          endif
+ei
+cd multf02
!FOX  YV1J=BBI(I,1)+BBI(I,2)*XL+AAI(I,2)*ZL ;
!FOX  YV2J=AAI(I,1)-BBI(I,2)*ZL+AAI(I,2)*XL ;
!FOX  CRKVE=XL ;
!FOX  CIKVE=ZL ;
+cd multf03
!FOX  CRKVEUK=CRKVE*XL-CIKVE*ZL ;
!FOX  CIKVE=CRKVE*ZL+CIKVE*XL ;
!FOX  CRKVE=CRKVEUK ;
!FOX  YV1J=YV1J+BBI(I,K)*CRKVE+AAI(I,K)*CIKVE ;
!FOX  YV2J=YV2J-BBI(I,K)*CIKVE+AAI(I,K)*CRKVE ;
+cd multf04
+if .not.tilt
!FOX  Y(1)=Y(1)+YV1J/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+YV2J/(ONE+DPDA) ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+(TILTC(I)*YV1J-TILTS(I)*YV2J)/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(TILTC(I)*YV2J+TILTS(I)*YV1J)/(ONE+DPDA) ;
+ei
+cd multf05
+if .not.tilt
!FOX  Y(1)=Y(1)+BBI(I,1)/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+AAI(I,1)/(ONE+DPDA) ;
+ei
+if tilt
!FOX  Y(1)=Y(1)+(TILTC(I)*BBI(I,1)-TILTS(I)*AAI(I,1))/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(TILTC(I)*AAI(I,1)+TILTS(I)*BBI(I,1))/(ONE+DPDA) ;
+ei
+cd mults01
+if .not.tilt
                            y(j,1)=y(j,1)-(((dki(ix,1)/dki(ix,3))       &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)-((((dki(ix,1)/dki(ix,3))     &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)-((((dki(ix,1)/dki(ix,3))     &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd mults02
+if .not.tilt
                        y(j,1)=y(j,1)-((dki(ix,1)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)-(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)-(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd mults03
                            sigm(j)=sigm(j)+(rvf(j)*dki(ix,1))*xl        !hr03
+cd mults04
+if .not.tilt
                            y(j,2)=y(j,2)-(((dki(ix,2)/dki(ix,3))       &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)+((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)-((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei
+cd mults05
+if .not.tilt
                        y(j,2)=y(j,2)+((dki(ix,2)*dps(j))*c1e3)/(one+dps&!hr08
     &(j))                                                               !hr08
+ei
+if tilt
                            y(j,1)=(y(j,1)-(((dki(ix,2)*dps(j))*c1e3)*  &!hr08
     &tilts(i))/(one+dps(j)))                                           &!hr08
     &+((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr08
                            y(j,2)=(y(j,2)+(((dki(ix,2)*dps(j))*c1e3)*  &!hr08
     &tiltc(i))/(one+dps(j)))                                           &!hr08
     &-((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr08
+ei
+cd mults06
                            sigm(j)=sigm(j)-(rvf(j)*dki(ix,2))*zl        !hr03
+cd mults07
                          odps1=one/(one+dps(j))
                          yv1j=(bbi(i,1)+bbi(i,2)*xl)+aai(i,2)*zl        !hr03
                          yv2j=(aai(i,1)-bbi(i,2)*zl)+aai(i,2)*xl        !hr03
                          crkve=xl
                          cikve=zl
+cd mults08
                            crkveuk=crkve*xl-cikve*zl
                            cikve=crkve*zl+cikve*xl
                            crkve=crkveuk
                            yv1j=(yv1j+bbi(i,k)*crkve)+aai(i,k)*cikve    !hr03
                            yv2j=(yv2j-bbi(i,k)*cikve)+aai(i,k)*crkve    !hr03
+cd mults09
+if .not.tilt
                          y(j,1)=y(j,1)+yv1j*odps1
                          y(j,2)=y(j,2)+yv2j*odps1
+ei
+if tilt
                          y(j,1)=y(j,1)+(tiltc(i)*yv1j-tilts(i)*yv2j)   &
     &*odps1
                          y(j,2)=y(j,2)+(tiltc(i)*yv2j+tilts(i)*yv1j)   &
     &*odps1
+ei
+cd mults10
+if .not.tilt
                        y(j,1)=y(j,1)+bbi(i,1)*odps1
                        y(j,2)=y(j,2)+aai(i,1)*odps1
+ei
+if tilt
                        y(j,1)=y(j,1)+(tiltc(i)*bbi(i,1)-               &
     &tilts(i)*aai(i,1))*odps1
                        y(j,2)=y(j,2)+(tiltc(i)*aai(i,1)+               &
     &tilts(i)*bbi(i,1))*odps1
+ei
+cd multb01
+if .not.tilt
                            y(j,1)=y(j,1)+(((dki(ix,1)/dki(ix,3))       &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))/(one                                 &!hr03
     &+dps(j))                                                           !hr03
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,1)/dki(ix,3))      &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)+(((dki(ix,1)/dki(ix,3))      &!hr03
     &*xl+dps(j)*c1e3)* dki(ix,1))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd multb02
+if .not.tilt
                        y(j,1)=y(j,1)+((dki(ix,1)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*(one-tiltc(i))                    !hr03
                            y(j,2)=(y(j,2)+(((dki(ix,1)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,1))/(one+dps(j)))*tilts(i)                          !hr03
+ei
+cd multb03
                            sigm(j)=sigm(j)-(rvf(j)*dki(ix,1))*xl        !hr03
+cd multb04
+if .not.tilt
                            y(j,2)=y(j,2)+(((dki(ix,2)/dki(ix,3))       &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))/(one                                 &!hr03
     &+dps(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)-((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tilts(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)+((((dki(ix,2)/dki(ix,3))     &!hr03
     &*zl-dps(j)*c1e3)* dki(ix,2))*tiltc(i))/(one                       &!hr03
     &+dps(j)))                                                         &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei
+cd multb05
+if .not.tilt
                        y(j,2)=y(j,2)-((dki(ix,2)*dps(j))*c1e3)/(one+dps&!hr03
     &(j))
+ei
+if tilt
                            y(j,1)=(y(j,1)+(((dki(ix,2)*dps(j))*c1e3)*  &!hr03
     &tilts(i))/(one+dps(j)))                                           &!hr03
     &-((c1e3*dki(ix,2))/(one+dps(j)))*tilts(i)                          !hr03
                            y(j,2)=(y(j,2)-(((dki(ix,2)*dps(j))*c1e3)*  &!hr03
     &tiltc(i))/(one+dps(j)))                                           &!hr03
     &+((c1e3*dki(ix,2))/(one+dps(j)))*(one-tiltc(i))                    !hr03
+ei                                    
+cd multb06
                            sigm(j)=sigm(j)+(rvf(j)*dki(ix,2))*zl        !hr03
+cd multb09
+if .not.tilt
                          y(j,1)=y(j,1)-yv1j*odps1
                          y(j,2)=y(j,2)-yv2j*odps1
+ei
+if tilt
                          y(j,1)=y(j,1)-(tiltc(i)*yv1j-tilts(i)*yv2j)   &
     &*odps1
                          y(j,2)=y(j,2)-(tiltc(i)*yv2j+tilts(i)*yv1j)   &
     &*odps1
+ei
+cd multb10
+if .not.tilt
                        y(j,1)=y(j,1)-bbi(i,1)*odps1
                        y(j,2)=y(j,2)-aai(i,1)*odps1
+ei
+if tilt
                        y(j,1)=y(j,1)-(tiltc(i)*bbi(i,1)-               &
     &tilts(i)*aai(i,1))*odps1
                        y(j,2)=y(j,2)-(tiltc(i)*aai(i,1)+               &
     &tilts(i)*bbi(i,1))*odps1
+ei
+cd mul4v01
+if .not.tilt
            yv(1,j)=yv(1,j)-((strack(i)*xlvj)*oidpsv(j)                 &!hr03
     &+dpsv1(j))*dki(ix,1)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
+ei
+cd mul4v02
+if .not.tilt
            yv(1,j)=yv(1,j)-strack(i)*dpsv1(j)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
+ei
+cd mul4v03
+if .not.tilt
            yv(2,j)=yv(2,j)-((strack(i)*zlvj)* oidpsv(j)                &!hr03
     &-dpsv1(j))*dki(ix,2)
+ei
+if tilt
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
+ei
+cd mul4v04
+if .not.tilt
            yv(2,j)=yv(2,j)+strack(i)*dpsv1(j)
+ei
+if tilt
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
+ei
+cd mul4v05
+if time
              yv1j=(bbiv(1,1,i)*expt+bbiv35(1,1,i)*(one-expt))          &!hr03
     &+(bbiv(2,1,i)*expt+bbiv35(2,1,i)*(one-expt))*xlvj                 &!hr03
     &+(aaiv(2,1,i)*expt+aaiv35(2,1,i)*(one-expt))*zlvj                  !hr03
              yv2j=(aaiv(1,1,i)*expt+aaiv35(1,1,i)*(one-expt))          &!hr03
     &-(bbiv(2,1,i)*expt+bbiv35(2,1,i)*(one-expt))*zlvj                 &!hr03
     &+(aaiv(2,1,i)*expt+aaiv35(2,1,i)*(one-expt))*xlvj                  !hr03
              crkve=xlvj
              cikve=zlvj
+ei
+if .not.time
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
+ei
+cd mul4v06
+if time
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
                  yv1j=(yv1j+(bbiv(k,1,i)*expt+bbiv35(k,1,i)*(one-expt))&!hr03
     &*crkve)                                                           &!hr03
     &+(aaiv(k,1,i)*expt+aaiv35(k,1,i)*(one-expt))                      &!hr03
     &*cikve                                                             !hr03
                  yv2j=(yv2j-(bbiv(k,1,i)*expt+bbiv35(k,1,i)*(one-expt))&!hr03
     &*cikve)                                                           &!hr03
     &+(aaiv(k,1,i)*expt+aaiv35(k,1,i)*(one-expt))                      &!hr03
     &*crkve                                                             !hr03
+ei
+if .not.time
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
+ei
+cd mul4v07
+if .not.tilt
              yv(1,j)=yv(1,j)+yv1j*oidpsv(j)
              yv(2,j)=yv(2,j)+yv2j*oidpsv(j)
+ei
+if tilt
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
+ei
+cd mul4v08
+if .not.tilt
+if time
              yv(1,j)=yv(1,j)+(bbiv(1,1,i)*expt                         &
     &+bbiv35(1,1,i)*(one-expt))*oidpsv(j)                               !hr03
              yv(2,j)=yv(2,j)+(aaiv(1,1,i)                              &
     &+aaiv35(1,1,i)*(one-expt))*oidpsv(j)                               !hr03
+ei
+if .not.time
              yv(1,j)=yv(1,j)+bbiv(1,1,i)*oidpsv(j)
              yv(2,j)=yv(2,j)+aaiv(1,1,i)*oidpsv(j)
+ei
+ei
+if tilt
+if time
              yv(1,j)=yv(1,j)+(tiltc(i)*(bbiv(1,1,i)*expt               &
     &+bbiv35(1,1,i)*(one-expt))-                                       &!hr03
     &tilts(i)*(aaiv(1,1,i)*expt+aaiv35(1,1,i)*(one-expt)))             &!hr03
     &*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*(aaiv(1,1,i)*expt               &
     &+aaiv35(1,1,i)*(one-expt))+                                       &!hr03
     &tilts(i)*(bbiv(1,1,i)*expt+bbiv35(1,1,i)*(one-expt)))             &!hr03
     &*oidpsv(j)
+ei
+if .not.time
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
+ei
+ei
+cd mul6v01
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
+cd mul6v02
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
+cd multl01
+if .not.tilt
            qu=(((-one*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)+qu*xl)-dppi*dpp                               !hr03
+ei
+if tilt
            qu=(((-one*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)+(qu*xl-dppi*dpp)*tiltc(k)                     &
     &+dppi*(one-tiltc(k))
            t(1,4)=(t(1,4)+(qu*xl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
+ei
+cd multl02
+if .not.tilt
              t(i,2)=t(i,2)+qu*t(i,1)
+ei
+if tilt
              t(i,2)=t(i,2)+(qu*t(i,1))*tiltc(k)                         !hr08
              t(i,4)=t(i,4)+(qu*t(i,3))*tilts(k)                         !hr08
+ei
+cd multl03
+if .not.tilt
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=t(1,2)-dppi*dpp
+ei
+if tilt
            dppi=(c1e3*dki(ix,1))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)-(dppi*dpp)*tiltc(k))                         &!hr03
     &+dppi*(one-tiltc(k))
            t(1,4)=(t(1,4)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
+ei
+cd multl04
+if .not.tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,4)=t(1,4)-qu*zl+dppi*dpp
+ei
+if tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)+(qu*zl-dppi*dpp)*tilts(k))                   &!hr03
     &+dppi*tilts(k)
            t(1,4)=(t(1,4)+(dppi*dpp-qu*zl)*tiltc(k))                   &!hr03
     &-dppi*(one-tiltc(k))
+ei
+cd multl05
+if .not.tilt
              t(i,4)=t(i,4)-qu*t(i,3)
+ei
+if tilt
              t(i,2)=t(i,2)+(qu*t(i,1))*tilts(k)                         !hr03
              t(i,4)=t(i,4)-(qu*t(i,3))*tiltc(k)                         !hr03
+ei
+cd multl06
+if .not.tilt
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,4)=t(1,4)+dppi*dpp
+ei
+if tilt
            dppi=(c1e3*dki(ix,2))/(one+dpp)                              !hr03
            t(1,2)=(t(1,2)-(dppi*dpp)*tilts(k))                         &!hr03
     &+dppi*tilts(k)
            t(1,4)=(t(1,4)+(dppi*dpp)*tiltc(k))                         &!hr03
     &-dppi*(one-tiltc(k))
+ei
+cd multl07a
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
+cd multl07b
          qu=bb(2)
          qv=-one*aa(2)
          dyy1=bb(1)+bb(2)*crkve+aa(2)*cikve
          dyy2=aa(1)-bb(2)*cikve+aa(2)*crkve
+cd multl07c
            l1=l-1
            qu=qu+real(l1,fPrec)*(bb(l)*crkve+aa(l)*cikve)                     !hr03
            qv=qv+real(l1,fPrec)*(bb(l)*cikve-aa(l)*crkve)                     !hr03
            crkveuk=crkve*xl-cikve*zl
            cikve=crkve*zl+cikve*xl
            crkve=crkveuk
            dyy1=(dyy1+bb(l)*crkve)+aa(l)*cikve                          !hr03
            dyy2=(dyy2-bb(l)*cikve)+aa(l)*crkve                          !hr03
+cd multl07d
          qu=zero
          qv=zero
          dyy1=bb(1)
          dyy2=aa(1)
+cd multl07e
        tiltck=tiltc(k)**2-tilts(k)**2                                   !hr03
        tiltsk=(two*tiltc(k))*tilts(k)                                   !hr03
        qu1=tiltck*qu-tiltsk*qv
        qv=tiltck*qv+tiltsk*qu
        qu=qu1
        dyy11=tiltc(k)*dyy1-tilts(k)*dyy2
        dyy2=tiltc(k)*dyy2+tilts(k)*dyy1
        dyy1=dyy11
+cd multl08
+if .not.tilt
            t(6,2)=t(6,2)-(qu*xl+dppi)/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-((qu*xl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
            t(6,4)=(t(6,4)-((qu*xl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
+ei
+cd multl09
+if .not.tilt
            t(6,2)=t(6,2)-dppi/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &-(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
            t(6,4)=(t(6,4)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)
+ei
+cd multl10
+if .not.tilt
            t(6,4)=t(6,4)+(qu*zl+dppi)/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-((qu*zl+dppi)/(one+dpp))*tilts(k))           &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
            t(6,4)=(t(6,4)+((qu*zl+dppi)/(one+dpp))*tiltc(k))           &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
+ei
+cd multl11
+if .not.tilt
            t(6,4)=t(6,4)+dppi/(one+dpp)
+ei
+if tilt
            t(6,2)=(t(6,2)-(dppi/(one+dpp))*tilts(k))                   &!hr03
     &-(dppi/(one+dpp))*tilts(k)                                         !hr03
            t(6,4)=(t(6,4)+(dppi/(one+dpp))*tiltc(k))                   &!hr03
     &+(dppi/(one+dpp))*(one-tiltc(k))                                   !hr03
+ei
+cd multl12
+if .not.tilt
            if(iv.eq.2) ekk=(((((bb(4)+                                 &!hr03
     &four*(bb(5)*cr(2)+aa(5)*ci(2)))+10d0*                              &!hr03
     &(bb(6)*cr(3)+aa(6)*ci(3)))+20d0*(bb(7)*cr(4)+aa(7)*ci(4)))+35d0*  &!hr03
     &(bb(8)*cr(5)+aa(8)*ci(5)))+56d0*(bb(9)*cr(6)+aa(9)*ci(6)))+84d0*  &!hr03
     &(bb(10)*cr(7)+aa(10)*ci(7))                                        !hr03
           if(iv.eq.3) ekk=(((bb(6)+6d0*(bb(7)*cr(2)+aa(7)*ci(2)))+21d0*&!hr03
     &(bb(8)*cr(3)+aa(8)*ci(3)))+56d0*(bb(9)*cr(4)+aa(9)*ci(4)))+126d0* &!hr03
     &(bb(10)*cr(5)+aa(10)*ci(5))                                        !hr03
            if(iv.eq.4) ekk=(bb(8)+8d0*(bb(9)*cr(2)+aa(9)*ci(2)))+36d0* &!hr03
     &(bb(10)*cr(3)+aa(10)*ci(3))
            if(iv.eq.5) ekk=bb(10)
            call detune(iv,ekk,ep,beta,dtu,dtup,dfac)
+ei
+if tilt
            tiltck=tiltc(k)**2-tilts(k)**2                               !hr03
            tiltsk=(two*tiltc(k))*tilts(k)                               !hr03
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk4=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck4=tiltckuk
            tiltckuk=tiltck4*tiltc(k)-tiltsk4*tilts(k)
            tiltsk=tiltck4*tilts(k)+tiltsk4*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk6=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck6=tiltckuk
            tiltckuk=tiltck6*tiltc(k)-tiltsk6*tilts(k)
            tiltsk=tiltck6*tilts(k)+tiltsk6*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk8=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck8=tiltckuk
            tiltckuk=tiltck8*tiltc(k)-tiltsk8*tilts(k)
            tiltsk=tiltck8*tilts(k)+tiltsk8*tiltc(k)
            tiltck=tiltckuk
            tiltckuk=tiltck*tiltc(k)-tiltsk*tilts(k)
            tiltsk10=tiltck*tilts(k)+tiltsk*tiltc(k)
            tiltck10=tiltckuk
            if(iv.eq.2) then
              ekk= ((((((((((((tiltck4* bb(4)                     -     &!hr03
     &tiltsk4*(             aa(4)       ))+                             &!hr03
     &four *tiltck4*(bb(5) *cr(2)+aa(5) *ci(2)))+                       &!hr03
     &four *tiltsk4*(bb(5) *ci(2)-aa(5) *cr(2)))+                       &!hr03
     &10d0 *tiltck4*(bb(6) *cr(3)+aa(6) *ci(3)))+                       &!hr03
     &10d0 *tiltsk4*(bb(6) *ci(3)-aa(6) *cr(3)))+                       &!hr03
     &20d0 *tiltck4*(bb(7) *cr(4)+aa(7) *ci(4)))+                       &!hr03
     &20d0 *tiltsk4*(bb(7) *ci(4)-aa(7) *cr(4)))+                       &!hr03
     &35d0 *tiltck4*(bb(8) *cr(5)+aa(8) *ci(5)))+                       &!hr03
     &35d0 *tiltsk4*(bb(8) *ci(5)-aa(8) *cr(5)))+                       &!hr03
     &56d0 *tiltck4*(bb(9) *cr(6)+aa(9) *ci(6)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltck4*(bb(10)*cr(7)+aa(10)*ci(7)))+                       &!hr03
     &84d0 *tiltsk4*(bb(10)*ci(7)-aa(10)*cr(7))
            endif
            if(iv.eq.3) then
              ekk= ((((((((tiltck6* bb(6)                     -         &!hr03
     &tiltsk6*(             aa(6)       ))+                             &!hr03
     &6d0  *tiltck6*(bb(7) *cr(2)+aa(7) *ci(2)))+                       &!hr03
     &6d0  *tiltsk6*(bb(7) *ci(2)-aa(7) *cr(2)))+                       &!hr03
     &21d0 *tiltck6*(bb(8) *cr(3)+aa(8) *ci(3)))+                       &!hr03
     &21d0 *tiltsk6*(bb(8) *ci(3)-aa(8) *cr(3)))+                       &!hr03
     &56d0 *tiltck6*(bb(9) *cr(4)+aa(9) *ci(4)))+                       &!hr03
     &56d0 *tiltsk6*(bb(9) *ci(4)-aa(9) *cr(4)))+                       &!hr03
     &126d0*tiltck6*(bb(10)*cr(5)+aa(10)*ci(5)))+                       &!hr03
     &126d0*tiltsk6*(bb(10)*ci(5)-aa(10)*cr(5))
            endif
            if(iv.eq.4) then
              ekk= ((((tiltck8* bb(8)                     -             &!hr03
     &tiltsk8*(             aa(8)       ))+                             &!hr03
     &8d0  *tiltck8*(bb(9) *cr(2)+aa(9) *ci(2)))+                       &!hr03
     &8d0  *tiltsk8*(bb(9) *ci(2)-aa(9) *cr(2)))+                       &!hr03
     &36d0 *tiltck8*(bb(10)*cr(3)+aa(10)*ci(3)))+                       &!hr03
     &36d0 *tiltsk8*(bb(10)*ci(3)-aa(10)*cr(3))
            endif
            if(iv.eq.5) then
              ekk= tiltck10*bb(10)-tiltsk10*aa(10)
            endif
            call detune(iv,ekk,ep,beta,dtu,dtup,dfac)
+ei
+cd multl13
          l1=l-1
          izu=izu+1
          aa(l)=ak0(im,l)+zfz(izu)*aka(im,l)
          aa(l)=(benkr*aa(l))/r0a                                        !hr03
          izu=izu+1
          bb(l)=bk0(im,l)+zfz(izu)*bka(im,l)
          bb(l)=(benkr*bb(l))/r0a                                        !hr03
          r0a=r0a*r0
          if(l.gt.2) then
            cxzyrr=cxzyr*cxzr-cxzyi*cxzi
            cxzyi=cxzyr*cxzi+cxzyi*cxzr
            cxzyr=cxzyrr
            cr(l)=cxzyr
            ci(l)=cxzyi
          endif
          dyy1=(dyy1+bb(l)*cr(l))+aa(l)*ci(l)                            !hr03
          dyy2=(dyy2-bb(l)*ci(l))+aa(l)*cr(l)                            !hr03
          if(l.gt.1.and.ium.ne.1) then
            qu=qu+real(l1,fPrec)*(bb(l)*cr(l1)+aa(l)*ci(l1))                   !hr03
            qv=qv+real(l1,fPrec)*(bb(l)*ci(l1)-aa(l)*cr(l1))                   !hr03
          endif
+cd multu01
+if .not.tilt
            qu=(((-one*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            y(1,1)=(y(1,1)+qu*xl)-((dpp*c1e3)*dki(ix,1))/(one+dpp)       !hr03
+ei
+if tilt
            qu=(((-one*dki(ix,1))/dki(ix,3))*dki(ix,1))/(one+dpp)        !hr03
            y(1,1)=(y(1,1)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tiltc(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
            y(1,2)=(y(1,2)+(qu*xl-((dpp*c1e3)*dki(ix,1))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
+ei
+cd multu02
+if .not.tilt
              y(j,1)=y(j,1)+qu*x(j,1)
+ei
+if tilt
              y(j,1)=y(j,1)+(qu*x(j,1))*tiltc(k)                         !hr03
              y(j,2)=y(j,2)+(qu*x(j,2))*tilts(k)                         !hr03
+ei
+cd multu03
+if .not.tilt
            y(1,1)=y(1,1)-((dki(ix,1)*dpp)/(one+dpp))*c1e3               !hr03
+ei
+if tilt
            y(1,1)=(y(1,1)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*(one-tiltc(k))                       !hr03
            y(1,2)=(y(1,2)-(((dki(ix,1)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((c1e3*dki(ix,1))/(one+dpp))*tilts(k)                             !hr03
+ei
+cd multu04
+if .not.tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            y(1,2)=(y(1,2)-qu*zl)+((dpp*c1e3)*dki(ix,2))/(one+dpp)       !hr03
+ei
+if tilt
            qu=((dki(ix,2)/dki(ix,3))*dki(ix,2))/(one+dpp)               !hr03
            y(1,1)=(y(1,1)+(qu*zl-((dpp*c1e3)*dki(ix,2))                &!hr03
     &/(one+dpp))*tilts(k))                                             &!hr03
     &+((c1e3*dki(ix,2))/(one+dpp))*tilts(k)                             !hr03
            y(1,2)=(y(1,2)+(((dpp*c1e3)*dki(ix,2))                      &!hr03
     &/(one+dpp)-qu*zl)*tiltc(k))                                       &!hr03
     &-((c1e3*dki(ix,2))/(one+dpp))*(one-tiltc(k))                       !hr03
+ei
+cd multu05
+if .not.tilt
              y(j,2)=y(j,2)-qu*x(j,2)
+ei
+if tilt
              y(j,1)=y(j,1)+(qu*x(j,1))*tilts(k)                         !hr03
              y(j,2)=y(j,2)-(qu*x(j,2))*tiltc(k)                         !hr03
+ei
+cd multu06
+if .not.tilt
            y(1,2)=y(1,2)+((dki(ix,2)*dpp)/(one+dpp))*c1e3               !hr03
+ei
+if tilt
            y(1,1)=(y(1,1)-(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tilts(k)) &!hr03
     &+((dki(ix,2)/(one+dpp))*c1e3)*tilts(k)                             !hr03
            y(1,2)=(y(1,2)+(((dki(ix,2)*dpp)/(one+dpp))*c1e3)*tiltc(k)) &!hr03
     &-((dki(ix,2)/(one+dpp))*c1e3)*(one-tiltc(k))                       !hr03
+ei
+cd bnlin
!GRDRHIC
!GRD-2007
!GRD-2007 REQUIRED FOR RHIC BEAM-BEAM STUDIES
!GRD-2007 OPTION IS ACTIVATED IF "LHC" PARAMETER IN BEAM-BEAM
!GRD-2007 BLOCK IN FORT.3 IS SET TO 9
!GRD-042008
           if(lhc.eq.9) then
! Write a line to fort.10 for all platforms (including LSF)
+if boinc
             if (.not.restart) then
               write(10,'(a10,a60)') 'title     ',sixtit(1:60)
               endfile (10,iostat=ierro)
               backspace (10,iostat=ierro)
               bnlrec=bnlrec+1
             endif
+ei
+if .not.boinc
             write(10,'(a60)') sixtit(1:60)
             endfile (10,iostat=ierro)
             backspace (10,iostat=ierro)
+ei
             call bnlrdis(20000)
               write(lout,*) 'Sample number 1'
!TEST
!ERIC              napx=napx00
               do j = 1, napx
                 pstop(nlostp(j))=.false.
               enddo
               do j = 1, napx
                  xv(1,j)  = c1e3*myx(j) +torbx(1)
                  yv(1,j)  = c1e3*myxp(j)+torbxp(1)
                  xv(2,j)  = c1e3*myy(j) +torby(1)
                  yv(2,j)  = c1e3*myyp(j)+torbyp(1)
                  sigmv(j) = mys(j)
                  ejv(j)   = myp(j)
                  ejfv(j)=sqrt(ejv(j)**2-pma**2)                         !hr03
                  rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
                  dpsv(j)=(ejfv(j)-e0f)/e0f
                  oidpsv(j)=one/(one+dpsv(j))
                  dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                      !hr03
cc2008
                  namepart(j) = samplenumber*100 + j
cc2008
               enddo
           endif
!GRD-2007
!GRD-042008
!GRDRHIC
+cd bnlout
!GRD-042008
!GRDRHIC
!GRD-2007
!GRD-2007 ADDITIONAL OUTPUT FILE FOR MULTI-PARTICLES BEAM-BEAM STUDIES
!GRD-2007
          do j=1,napx
            if(pstop(nlostp(j))) goto 599
!GRD-042008
+if debug
!           if (n.ge.990) then
!             write(99,*) 'before j ',j,xv(1,j),xv(2,j),yv(1,j),yv(2,j)
!             endfile (99,iostat=ierro)
!             backspace (99,iostat=ierro)
!           endif
+ei
            x_temp=(xv(1,j)-torbx(i-1))*c1m3                             !hr03
            y_temp=(xv(2,j)-torby(i-1))*c1m3                             !hr03
            xp_temp=(yv(1,j)-torbxp(i-1))*c1m3                           !hr03
            yp_temp=(yv(2,j)-torbyp(i-1))*c1m3                           !hr03
            twojx = (tbetax(i-1)*(xp_temp**2)+                          &!hr03
     &               ((two*talphax(i-1))*x_temp)*xp_temp)+              &!hr03
     &               ((one+talphax(i-1)**2)/tbetax(i-1))*(x_temp**2)     !hr03
            twojy = (tbetay(i-1)*(yp_temp**2)+                          &!hr03
     &               ((two*talphay(i-1))*y_temp)*yp_temp)+              &!hr03
     &               ((one+talphay(i-1)**2)/tbetay(i-1))*(y_temp**2)     !hr03
            twojr = sqrt(twojx**2+twojy**2)
            if(n.eq.1) then
               if(j.eq.1) then
+if debug
!                 write(*,*) 'coucou'
+ei
                  limit_twojx = 25.0_fPrec*(2.5e-6_fPrec/(e0/pma))                   !hr03
                  limit_twojy = 25.0_fPrec*(2.5e-6_fPrec/(e0/pma))                   !hr03
                  limit_twojr = 25.0_fPrec*(2.5e-6_fPrec/(e0/pma))                   !hr03
               endif
            endif
            if(twojr.le.limit_twojr) then
              sumtwojx=sumtwojx+twojx
              sumtwojy=sumtwojy+twojy
              sumsquarex=sumsquarex+x_temp**2
              sumsquarey=sumsquarey+y_temp**2
              n_nocut=n_nocut +1
            else
              n_cut=n_cut+1
+if .not.boinc
              write(53,'(i8,1x,i8)') n,namepart(j)
+ei
+if boinc
              write(10,'(a10,i8,1x,i8)') 'lostID    ',n,namepart(j)
+ei
+if cr
+if .not.boinc
              endfile (53,iostat=ierro)
              backspace (53,iostat=ierro)
              bllrec=bllrec+1
+ei
+if boinc
              endfile (10,iostat=ierro)
              backspace (10,iostat=ierro)
              bnlrec=bnlrec+1
+ei
+ei
            endif
!GRD-042008
 599        continue
          enddo
+if debug
!     write(99,*) 'after  update bnl n ',n
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napx)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
!GRD-042008
          if(mod(n,nwr(3)).eq.0) then
            write(lout,*) 'dumping stats at turn number ',n
+if crlibm
! Use dtostr for correct binary decimal conversion
           l1=1
+if .not.boinc
! use Unit 52 
+ei 
+if boinc
! use Unit 10 and initialise string with header
            ch(l1:l1+10)='output    '           
            l1=l1+11
+ei
! Now do conversions
! First the 3 integers using internal read
            write(ch(l1:l1+8),'(i8)') n
            l1=l1+9
            write(ch(l1:l1+9),'(1x,i8)') n_cut
            l1=l1+10
            write(ch(l1:l1+9),'(1x,i8)') n_nocut
            l1=l1+10
! and now the four real(kind=fPrec)
! We return the length of the string (always 24)
            errno=dtostr(sumsquarex,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumsquarey,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumtwojx,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(sumtwojy,ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
+if .not.boinc
! write string to 52
            write(52,'(a)') ch(1:l1-1)
+ei
+if boinc 
! write string to 10
            write(10,'(a)') ch(1:l1-1)
+ei
+ei
+if .not.crlibm
+if .not.boinc
            write(52,'(i8,2(1x,i8),4(1x,e15.8))')                       &
+ei
+if boinc
            write(10,'(a10,i8,2(1x,i8),4(1x,e15.8))')                   &
     &'output    ',                                                     &
+ei
     &n,n_cut,n_nocut,                                                  &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy
+ei
+if cr
+if .not.boinc
      endfile (52,iostat=ierro)
      backspace (52,iostat=ierro)
+ei
+if boinc
      endfile (10,iostat=ierro)
      backspace (10,iostat=ierro)
+ei
            bnlrec=bnlrec+1
+ei
            sumsquarex=zero
            sumsquarey=zero
            sumtwojx=zero
            sumtwojy=zero
            n_cut=0
            n_nocut=0
!05-2008
!
          endif
!GRD-042008
!GRD-2007
!GRD-042008
!GRDRHIC
+cd bnltwiss
!GRDRHIC
!GRD-042008
!GRD-2007
            if(n.eq.1.and.lhc.eq.9) then
               totals=totals+strack(i)
               sampl(i)=totals
+if crlibm
! Use dtostr for correct binary decimal conversion
               l1=1
+if .not.boinc
! Use Unit 51
+ei
+if boinc
! Use Unit 10 and initialise string with header
               ch(l1:l1+10)='SixTwiss  '
               l1=l1+11
+ei
! Now do the conversions
! A 5-digit integer, followed by 7 real(kind=fPrec) numbers
               write(ch(l1:l1+5),'(i5)') i
               l1=l1+6
! and now the 7 real(kind=fPrec)
! We return the length of the string (always 24)
            errno=dtostr(sampl(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(tbetax(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(tbetay(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(talphax(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(talphay(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(torbx(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
            errno=dtostr(torby(i),ch1)
            ch(l1:l1+errno)=' '//ch1(1:errno)
            l1=l1+errno+1
+if .not.boinc
! write string to 51
            write(51,'(a)') ch(1:l1-1)
+ei
+if boinc
! write string to 10
            write(10,'(a)') ch(1:l1-1)
+ei
+ei
+if .not.crlibm
+if .not.boinc
               write(51,'(i5,(1x,f15.10),6(1x,f20.13))')                &
+ei
+if boinc
                 write(10,'(a10,i5,(1x,f15.10),6(1x,f20.13))')          &
     &'SixTwiss  ',                                                     &
+ei
     &i,sampl(i),tbetax(i),tbetay(i),talphax(i),talphay(i),torbx(i),    &
     &torby(i)
+ei
+if boinc
               bnlrec=bnlrec+1
               endfile (10,iostat=ierro)
               backspace (10,iostat=ierro)
+ei
+if .not.boinc
               endfile (51,iostat=ierro)
               backspace (51,iostat=ierro)
+ei
            endif
!GRDRHIC
!GRD-042008
!GRD-2007
+cd thcklin
+if debug
!     if (i.ge.673.and.j.le.2) then
!       call warr('bl30 i j',xv(1,2),i,j,0,0)
!       call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
+ei
                puxve1=xv(1,j)
                puzve1=yv(1,j)
                puxve2=xv(2,j)
                puzve2=yv(2,j)
         sigmv(j)=(((((sigmv(j)+as(1,1,j,jx))+puxve1*((as(2,1,j,jx)+ as &!hr03
     &(4,1,j,jx)*puzve1)+as(5,1,j,jx)*puxve1))+ puzve1*(as              &!hr03
     &(3,1,j,jx)+as(6,1,j,jx)*puzve1))                                  &!hr03
     &+as(1,2,j,jx))+puxve2*(as(2,2,j,jx)+ as                           &!hr03
     &(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2))+ puzve2*(as               &!hr03
     &(3,2,j,jx)+as(6,2,j,jx)*puzve2)                                    !hr03
        xv(1,j)=(al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1)+             &
     &real(idz1,fPrec)*al(5,1,j,jx)                                      !hr03
        xv(2,j)=(al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2)+             &
     &real(idz2,fPrec)*al(5,2,j,jx)                                      !hr03
        yv(1,j)=(al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1)+             &
     &real(idz1,fPrec)*al(6,1,j,jx)                                      !hr03
        yv(2,j)=(al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2)+             &
     &real(idz2,fPrec)*al(6,2,j,jx)                                      !hr03
+if debug
!     if (i.ge.673.and.j.le.2) then
!       call warr('al30 i j',xv(1,2),i,j,0,0)
!       call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
+ei
+cd sqrtfox0
+if rvet
!FOX  RVET=C1E3*PMA*PMA*(TWO+DPDA)*DPDA/E0/(ONE+DPDA) ;
!FOX  RVET=RVET/(E0*(ONE+DPDA)+SQRT(E0*E0+E0F*E0F*(TWO*DPDA+
!FOX  DPDA*DPDA))) ;
+ei
+if .not.rvet
!
+ei
+cd sqrtfox
+if rvet
!FOX  EL(JX)*(RVET-C5M4*RV*(Y(1)*Y(1)+Y(2)*Y(2))) ;
+ei
+if fast
!FOX  EL(JX)*(C1E3-RV*(C1E3+(Y(1)*Y(1)+Y(2)*Y(2))*C5M4)) ;
+ei
+if .not.fast.and..not.rvet
!FOX  EL(JX)*(C1E3-RV*SQRT(C1E6+Y(1)*Y(1)+Y(2)*Y(2))) ;
+ei
+cd sqrts
+if .not.fast
     &sqrt((c1e6+y(j,1)**2)+                                            &!hr03
     &y(j,2)**2))                                                        !hr03
+ei
+if fast
     &(c1e3+(y(j,1)**2+                                                 &!hr03
     &y(j,2)**2)*c5m4))                                                  !hr03
+ei
+cd sqrtv
+if rvet
      rvet(j)=((((c1e3*pma**2)*(two+dpsv(j)))*dpsv(j))/e0)/(one+dpsv(j))
            rvet(j)=rvet(j)/(e0*(one+dpsv(j))+                          &!hr03
     &sqrt(e0**2+e0f**2*(two*dpsv(j)+dpsv(j)**2)))                       !hr03
            sigmv(j)=sigmv(j)+stracki*(rvet(j)-(c5m4*rvv(j))*(yv(1,j)   &!hr03
     &**2+yv(2,j)**2))                                                   !hr03
+ei
+if fast
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &!hr03
     &**2+yv(2,j)**2)*c5m4))                                             !hr03
+ei
+if .not.fast.and..not.rvet
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt((c1e6+yv(1,j)   &!hr03
     &**2)+yv(2,j)**2))                                                  !hr03
+ei
      
+cd lostpart
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
+if backtrk
!         A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!         last modified: 24-11-2016
!         store old infos for back-tracking at aperture check at downstream locations
!         inserted in main code by the 'backtrk' compilation flag
          if ( kape(ix).ne.0 ) then
!           Store old s value
            sold  =  dcum(i)
!           Store information of aperture
            kapold = kape(ix)
            do j=1,7
              apold(j) = ape(j,ix)
            end do
          end if
+ei

+cd backtrkinit

!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 24-11-2016
!     initialise variables for back-tracking particles
!     inserted in main code by the 'backtrk' compilation flag
!     . store 'old' angle of particles
      do j=1,napx
        yold(1,j) = yv(1,j)
        yold(2,j) = yv(2,j)
      end do
!     . store 'old' s value
      sold = dcum(0)
!     . store information of aperture
!       force general aperture, i.e. RE with aper(1) and aper(2)
!       assumption: tracked particles do not fall outside aperture
!         limits in the first elements...
      kapold = 2
      do j=1,7
         apold(j) = zero
      end do
      apold(1) = aper(1)
      apold(2) = aper(2)
      apold(3) = sqrt(two)*aper(1)
      apold(4) = sqrt(two)*aper(2)
      if ( ktrack(1).ne.1 ) then
         if ( kape(ic(1)-nblo).ne.0 ) then
!        the first entry of the lattice sequence is a 
!           SINGLE ELEMENT, to which an aperture profile
!           is assigned
            kapold = kape(ic(1)-nblo)
            do j=1,7
               apold(j) = ape(j,ic(1)-nblo)
            end do
         endif
      endif
+cd backtrksave

!         A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!         last modified: 24-11-2016
!         store old angle of particles
!         inserted in main code by the 'backtrk' compilation flag
          do j=1,napx
            yold(1,j) = yv(1,j)
            yold(2,j) = yv(2,j)
          end do

+cd umlalid
          iwrite=0
          if(nlin.eq.0) then
            iwrite=1
          else
            do ii=1,nlin
              if(typ.eq.bezl(ii)) iwrite=1
            enddo
          endif
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
!FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag1.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          else
            call dacop(dpda1,damap(5))
            do j1=1,4
              do ii=1,4
                jj(ii)=1
                call dapek(damap(j1),jj,rdd(j1,ii))
                jj(ii)=0
              enddo
            enddo
            jj(5)=1
            do j1=1,4
              call dapek(damap(j1),jj,rdd(j1,5))
            enddo
            jj(5)=0
            do j1=1,2
              ii=2*j1
              d(j1)=(((rdd(ii-1,1)*dicu(1)+rdd(ii-1,2)*dicu(2))+        &!hr03
     &rdd(ii-1,3)*dicu(3))+rdd(ii-1,4)*dicu(4))+rdd(ii-1,5)              !hr03
              dp(j1)=(((rdd(ii,1)*dicu(1)+rdd(ii,2)*dicu(2))+           &!hr03
     &rdd(ii,3)*dicu(3))+rdd(ii,4)*dicu(4))+rdd(ii,5)                    !hr03
            enddo
          endif
          call dacct(damap,nvar,aa2,nvar,damap,nvar)
!         calculate linear 6D optics parameter for each element
!         by calculating the matrix of eigenvectors (tas)
          do j=1,ndimf
            ii=2*j
            if(j.eq.1) then
              i2=4
              i3=6
            elseif(j.eq.2) then
              i2=2
              i3=6
            elseif(j.eq.3) then
              i2=2
              i3=4
            endif
            jj(ii-1)=1
            call dapek(damap(ii-1),jj,angp(1,ii-1))
            call dapek(damap(ii),jj,au(ii,ii-1))
            jj(ii-1)=0
            jj(ii)=1
            call dapek(damap(ii-1),jj,angp(1,ii))
            call dapek(damap(ii),jj,au(ii,ii))
            jj(ii)=0
            jj(i2-1)=1
            call dapek(damap(ii-1),jj,au(i2-1,i2-1))
            call dapek(damap(ii),jj,au(i2,i2-1))
            jj(i2-1)=0
            jj(i2)=1
            call dapek(damap(ii-1),jj,au(i2-1,i2))
            call dapek(damap(ii),jj,au(i2,i2))
            jj(i2)=0
            jj(i3-1)=1
            call dapek(damap(ii-1),jj,au(i3-1,i3-1))
            call dapek(damap(ii),jj,au(i3,i3-1))
            jj(i3-1)=0
            jj(i3)=1
            call dapek(damap(ii-1),jj,au(i3-1,i3))
            call dapek(damap(ii),jj,au(i3,i3))
            jj(i3)=0
            
!     Store tas matrix (normalisation of phase space) and closed orbit for FMA and DUMP normalization.
!     Variable added to DUMP block module variables;
!     units dumptas: mm,mrad,mm,mrad,mm,1.e-3 -> convert later to 1.e3
            if(ic(i)-nblo.gt.0) then !check if structure element is a block
              if(ldump(ic(i)-nblo)) then !check if particles are dumped at this element
                dumptas(ic(i)-nblo,ii-1,ii-1)=angp(1,ii-1)
                dumptas(ic(i)-nblo,ii-1,ii  )=angp(1,ii)
                dumptas(ic(i)-nblo,ii  ,ii-1)=au(ii,ii-1)
                dumptas(ic(i)-nblo,ii  ,ii  )=au(ii,ii  )
                dumptas(ic(i)-nblo,ii-1,i2-1)=au(i2-1,i2-1)
                dumptas(ic(i)-nblo,ii  ,i2-1)=au(i2  ,i2-1)
                dumptas(ic(i)-nblo,ii-1,i2  )=au(i2-1,i2  )
                dumptas(ic(i)-nblo,ii  ,i2  )=au(i2  ,i2  )
                dumptas(ic(i)-nblo,ii-1,i3-1)=au(i3-1,i3-1)
                dumptas(ic(i)-nblo,ii  ,i3-1)=au(i3  ,i3-1)
                dumptas(ic(i)-nblo,ii-1,i3  )=au(i3-1,i3  )
                dumptas(ic(i)-nblo,ii  ,i3  )=au(i3  ,i3  )
!    closed orbit in canonical variables x,px,y,py,sig,delta [mm,mrad,mm,mrad,mm,1.e-3]
!    convert to x,xp,y,yp,sig,delta [mm,mrad,mm,mrad,mm,1]
!     -> check units used in dumpclo (is x' or px used?) 
                dumpclo(ic(i)-nblo,2*j-1)=c(j)
                if (j.eq.3) then !dp/p
                  dumpclo(ic(i)-nblo,2*j)  =cp(j)*c1m3
                else ! xp,yp
                  dumpclo(ic(i)-nblo,2*j)  =cp(j)/(one+cp(3)*c1m3)
                endif
              endif
            endif
           
            b1(j)=angp(1,ii-1)**2+angp(1,ii)**2                          !hr08
            b2(j)=au(i2-1,i2-1)**2+au(i2-1,i2)**2                        !hr08
            b3(j)=au(i3-1,i3-1)**2+au(i3-1,i3)**2                        !hr08
            al1(j)=-one*(angp(1,ii-1)*au(ii,ii-1)+angp(1,ii)*au(ii,ii))  !hr03
           al2(j)=-one*(au(i2-1,i2-1)*au(i2,i2-1)+au(i2-1,i2)*au(i2,i2)) !hr03
           al3(j)=-one*(au(i3-1,i3-1)*au(i3,i3-1)+au(i3-1,i3)*au(i3,i3)) !hr03
            g1(j)=au(ii,ii-1)**2+au(ii,ii)**2                            !hr04
            g2(j)=au(i2,i2-1)**2+au(i2,i2)**2                            !hr04
            g3(j)=au(i3,i3-1)**2+au(i3,i3)**2                            !hr04
            if(ndimf.eq.3) then
              call dainv(damap,nvar,damapi,nvar)
              jj(6)=1
              call dapek(damapi(5),jj,aui(1))
              call dapek(damapi(6),jj,aui(2))
              jj(6)=0
              if(j.lt.3) then
                d(j)=au(i3-1,i3-1)*aui(1)+au(i3-1,i3)*aui(2)
                dp(j)=au(i3,i3-1)*aui(1)+au(i3,i3)*aui(2)
              else
                d(j)=angp(1,ii-1)*aui(1)+angp(1,ii)*aui(2)
                dp(j)=au(ii,ii-1)*aui(1)+au(ii,ii)*aui(2)
              endif
            endif
            sx=angp(2,ii-1)*angp(1,ii)-angp(1,ii-1)*angp(2,ii)
            cx=angp(1,ii-1)*angp(2,ii-1)+angp(1,ii)*angp(2,ii)
            if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
              dphi(j)=atan2_mb(sx,cx)/x2pi
            else
              dphi(j)=zero
            endif
            phi(j)=phi(j)+dphi(j)
          enddo !end of optics calculation

          if(ic(i)-nblo.gt.0) then !check if structure element is a block
             if(ldump(ic(i)-nblo)) then !check if particles are dumped at this element
                
!     do the unit conversion + inversion of dumptas
!     convert from units [mm,mrad,mm,mrad,1.e-3] to [mm,mrad,mm,mrad,1] as needed for normalization

               dumptas(ic(i)-nblo,1:5,6)=                               &
     &                 dumptas(ic(i)-nblo,1:5,6)*c1e3
               dumptas(ic(i)-nblo,6,1:5)=                               &
     &              dumptas(ic(i)-nblo,6,1:5)*c1m3
               
!     invert the tas matrix
                call invert_tas(dumptasinv(ic(i)-nblo,:,:),             &
     &               dumptas(ic(i)-nblo,:,:))
!     dumptas and dumptasinv are now in units [mm,mrad,mm,mrad,1]
                
             endif
          endif
          
          do j=1,ndimf
            ii=2*j
            angp(2,ii-1)=angp(1,ii-1)
            angp(2,ii)=angp(1,ii)
          enddo
!         write optics parameter for each element (LINE block)
          if(iwrite.eq.1) then
            iii=i
            if(typ(:8).eq.'START   ') iii=0
            write(lout,10030) iii,typ(:8),tl,phi(1),b1(1),al1(1),g1(1), &
     &d(1),dp(1),c(1),cp(1)
            if(ndimf.eq.3) then
              write(lout,10040) b2(1),al2(1),g2(1)
              write(lout,10050) typ(9:16),b3(1),al3(1),g3(1)
            else
              write(lout,10055) typ(9:16),b2(1),al2(1),g2(1)
            endif
            write(lout,10060)
            write(lout,10070) phi(2),b1(2),al1(2),g1(2),d(2),dp(2),c(2),&
     &cp(2)
            write(lout,10080) b2(2),al2(2),g2(2)
            if(ndimf.eq.3) then
              write(lout,10090) b3(2),al3(2),g3(2)
              write(lout,10060)
              write(lout,10100) -phi(3),b1(3),al1(3),g1(3),d(3),dp(3),  &
     &c(3),cp(3)
              write(lout,10080) b2(3),al2(3),g2(3)
              write(lout,10040) b3(3),al3(3),g3(3)
            endif
            write(lout,10010)
          endif
+cd umlalid1
          ibb=ibb+1
          if(ibb.gt.nbb) call prror(102)
          imbb(i)=ibb
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
!FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag2.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          endif
          call dainv(damap,nvar,damapi,nvar)
          call dacct(damap,nvar,aa2,nvar,aa2r,nvar)
          call dacct(damap,nvar,damap1,nvar,damap,nvar)
          call dacct(damap,nvar,damapi,nvar,damap,nvar)
+if debug
!         write(*,*) 'bbcu set in umlalid1'
!     call warr('umlid1bbcu',bbcu(ibb,1),ibb,1,0,0)
!     call warr('umlid1bbcu',bbcu(ibb,2),ibb,2,0,0)
!     call warr('umlid1bbcu',bbcu(ibb,3),ibb,3,0,0)
+ei
            do ii=1,3
              call damul(damap(i4(ii,1)),damap(i4(ii,2)),angno)
              call averaged(angno,aa2r,.false.,angno)
              do j=1,ndimf
                j1=2*j
                jj(j1-1)=1
                jj(j1)=1
                call dapek(angno,jj,angnoe(j))
                jj(j1-1)=0
                jj(j1)=0
              enddo
              if(ndimf.eq.3) then
                bbcu(ibb,ii)=two*((emitx*angnoe(1)+emity*angnoe(2))+    &!hr03
     &emitz*angnoe(3))
+if debug
!     call warr('umlid1bbcii',bbcu(ibb,ii),ibb,ii,1,0)
+ei
              else
                bbcu(ibb,ii)=two*(emitx*angnoe(1)+emity*angnoe(2))
+if debug
!     call warr('umlid1bbcii',bbcu(ibb,ii),ibb,ii,2,0)
+ei
              endif
            enddo
            if (beam_expflag .eq. 0) then !Old-style input
              if(parbe(ix,2).gt.zero) then
                do ii=4,10
                  call damul(damap(i4(ii,1)),damap(i4(ii,2)),angno)
                  call averaged(angno,aa2r,.false.,angno)
                  do j=1,ndimf
                    j1=2*j
                    jj(j1-1)=1
                    jj(j1)=1
                    call dapek(angno,jj,angnoe(j))
                    jj(j1-1)=0
                    jj(j1)=0
                  enddo
                  if(ndimf.eq.3) then
                    bbcu(ibb,ii) = two *                                &
     &               ((emitx*angnoe(1)+emity*angnoe(2))+emitz*angnoe(3))
                  else
                    bbcu(ibb,ii)=two*(emitx*angnoe(1)+emity*angnoe(2))
                  endif
                enddo
              endif
              if(lhc.eq.1) then
                dummy=bbcu(ibb,1)
                bbcu(ibb,1)=bbcu(ibb,2)
                bbcu(ibb,2)=dummy
                dummy=bbcu(ibb,4)
                bbcu(ibb,4)=bbcu(ibb,9)
                bbcu(ibb,9)=dummy
                dummy=bbcu(ibb,5)
                bbcu(ibb,5)=bbcu(ibb,7)
                bbcu(ibb,7)=dummy
                dummy=bbcu(ibb,6)
                bbcu(ibb,6)=bbcu(ibb,10)
                bbcu(ibb,10)=dummy
              endif
              if(lhc.eq.2) then
                bbcu(ibb,1)=bbbx(ix)
                bbcu(ibb,2)=bbby(ix)
                bbcu(ibb,3)=bbbs(ix)
              endif

            !Indentation break, sorry :(

          else if (beam_expflag .eq. 1) then !New style input
            if(parbe(ix,2).gt.zero) then
               bbcu(ibb,1)=parbe(ix,7)
               bbcu(ibb,4)=parbe(ix,8)
               bbcu(ibb,6)=parbe(ix,9)
               bbcu(ibb,2)=parbe(ix,10)
               bbcu(ibb,9)=parbe(ix,11)
               bbcu(ibb,10)=parbe(ix,12)
               bbcu(ibb,3)=parbe(ix,13)
               bbcu(ibb,5)=parbe(ix,14)
               bbcu(ibb,7)=parbe(ix,15)
               bbcu(ibb,8)=parbe(ix,16)
            endif
            if(parbe(ix,2).eq.zero) then
               bbcu(ibb,1)=parbe(ix,1)
               bbcu(ibb,2)=parbe(ix,3)
            endif
          else
             write(lout,'(a)') "ERROR in +cd umlalid1"
             write(lout,'(a)') "beam_expflag was", beam_expflag
             write(lout,'(a)') " expected 0 or 1. This is a BUG!"
             call prror(-1)
          end if

          if (.not.beam_expfile_open) then
             inquire(unit=600,opened=lopen)
             if (lopen) then
                write(lout,'(a)') "Error when opening beam_expert.txt"
                write(lout,'(a)') "Unit 600 already taken."
                call prror(-1)
             endif
+if boinc
             call boincrf("beam_expert.txt",filename)
             open(600,file=filename,                                    &
     &            status='replace',action="write")
+ei
+if .not.boinc
             open(600,file="beam_expert.txt",                           &
     &            status='replace',action="write")
+ei
             beam_expfile_open = .true.
             !This line will be a comment if copy-pasted into fort.3
             write(600,'(a,g13.6,a,g13.6,a,g13.6,a)')                   &
     &            "/ ******* USING emitx=",emitx,                       &
     &            ", emity=",emity,                                     &
     &            ", emitz=",emitz," ******"
          endif
          
          if(parbe(ix,2).eq.0.0) then !4D
             !Note: One should always use the CRLIBM version when converting,
             ! in order to guarantee the exact same results from the converted input file.
+if .not.crlibm
             write(600,"(a16,1x,a1,1x,5g30.20)")                        &
     &            bez(ix), "0", bbcu(ibb,1),bbcu(ibb,2),                &
     &            parbe(ix,5), parbe(ix,6), ptnfac(ix)
+ei
+if crlibm
             l1 = 1
             write(ch,'(a16,1x,a1)') bez(ix), "0"
             l1 = len(trim(ch))+1
             
             errno=dtostr(bbcu(ibb,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,2),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(ptnfac(ix),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(600,*) trim(ch)
+ei
          else                      ! 6D
+if .not.crlibm
             write(600,"(a16,1x,i4,1x,4g30.20)")                        &
     &            bez(ix), int(parbe(ix,2)),                            &
     &            parbe(ix,1), parbe(ix,3),                             &
     &            parbe(ix,5), parbe(ix,6)
             write(600,"(5g30.20)")                                     &
     &            bbcu(ibb,1), bbcu(ibb,4), bbcu(ibb,6),                &
     &            bbcu(ibb,2), bbcu(ibb,9)
             write(600,"(6g30.20)")                                     &
     &            bbcu(ibb,10), bbcu(ibb,3), bbcu(ibb,5),               &
     &            bbcu(ibb,7), bbcu(ibb,8), ptnfac(ix)
+ei
+if crlibm
             l1 = 1
             write(ch,'(a16,1x,i4)') bez(ix), int(parbe(ix,2))
             l1 = len(trim(ch))+1

             errno=dtostr(parbe(ix,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,3),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(parbe(ix,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
                          
             write(600,*) trim(ch)

             l1 = 1
             ch = ' '

             errno=dtostr(bbcu(ibb,1),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,4),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,6),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,2),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(bbcu(ibb,9),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(600,*) trim(ch)

             l1 = 1
             ch = ' '

             errno=dtostr(bbcu(ibb,10),ch1) ! Return value is the string length (always 24)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,3),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,5),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             errno=dtostr(bbcu(ibb,7),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(bbcu(ibb,8),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1

             errno=dtostr(ptnfac(ix),ch1)
             ch(l1:l1+errno) = ch1(1:errno)
             l1 = l1+errno+1
             
             write(600,*) trim(ch)
+ei
            endif !END if(parbe(ix,2).eq.0.0)
          
        if((bbcu(ibb,1).le.pieni).or.(bbcu(ibb,2).le.pieni)) then 
            call prror(88)
          endif
          if(ibbc.eq.1) then
            sfac1=bbcu(ibb,1)+bbcu(ibb,2)
            sfac2=bbcu(ibb,1)-bbcu(ibb,2)
            sfac2s=one
            if(sfac2.lt.zero) sfac2s=-one                            !hr08
            sfac3=sqrt(sfac2**2+(four*bbcu(ibb,3))*bbcu(ibb,3))          !hr03
            if(sfac3.gt.sfac1) call prror(103)
            sfac4=(sfac2s*sfac2)/sfac3                                   !hr03
            sfac5=(((-one*sfac2s)*two)*bbcu(ibb,3))/sfac3                !hr03
            sigman(1,ibb)=sqrt(((sfac1+sfac2*sfac4)+                    &!hr03
     &(two*bbcu(ibb,3))*sfac5)*half)                                     !hr03
            sigman(2,ibb)=sqrt(((sfac1-sfac2*sfac4)-                    &!hr03
     &(two*bbcu(ibb,3))*sfac5)*half)                                     !hr03
            bbcu(ibb,11)=sqrt(half*(one+sfac4))
            bbcu(ibb,12)=(-one*sfac2s)*sqrt(half*(one-sfac4))            !hr03
            if(bbcu(ibb,3).lt.zero) bbcu(ibb,12)=-one*bbcu(ibb,12)       !hr03
          else
            bbcu(ibb,11)=one
            sigman(1,ibb)=sqrt(bbcu(ibb,1))
            sigman(2,ibb)=sqrt(bbcu(ibb,2))
          endif
          if(parbe(ix,2).gt.zero) then !6D -> convert units
            do ii=1,10
              bbcu(ibb,ii)=bbcu(ibb,ii)*c1m6
            enddo
          endif
+cd trom01
        if(kzz.eq.22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+                  &!hr03
     &t(i,ll)*rrtr(imtr(ix),ll-1,ll))+                                  &!hr03
     &dpr(i)*rrtr(imtr(ix),ll-1,6)                                       !hr03
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+                       &
     &t(i,ll)*rrtr(imtr(ix),ll,ll))+                                     &
     &dpr(i)*rrtr(imtr(ix),ll,6)
            enddo
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
+cd trom02
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr03
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr03
+cd trom03
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)                                         !hr08
            endif
            if(-one*dphi.gt.pieni) dphi=dphi+pi                          !hr03
+cd trom04
            phi(l)=phi(l)+dphi/pie
          enddo
        endif
+cd trom05
            phi(l)=phi(l)+dphi
          enddo
        endif
+cd trom06
            phi(l)=phi(l)+dphi/pie
          enddo

!          nr=nr+1
!+if .not.collimat.and..not.bnlelens
!          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
!+ei
!+if collimat.or.bnlelens
!          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
!+ei
!          if(ntco.ne.0) then
!            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
!          endif
!          goto 500
        endif
+cd trom10
        if(kzz.eq.22) then
          do j=1,ium
            do kx=1,2
              ll=kx*2
              puf=x(j,kx)
           x(j,kx)=((cotr(imtr(ix),ll-1)+rrtr(imtr(ix),ll-1,ll-1)*puf)+ &!hr03
     &rrtr(imtr(ix),ll-1,ll)*y(j,kx))+dpr(j)*                           &!hr03
     &rrtr(imtr(ix),ll-1,6)                                              !hr03
           y(j,kx)=((cotr(imtr(ix),ll)+rrtr(imtr(ix),ll,ll-1)*puf)+     &!hr03
     &rrtr(imtr(ix),ll,ll)*y(j,kx))+dpr(j)*                             &!hr03
     &rrtr(imtr(ix),ll,6)                                                !hr03
            enddo
          enddo
        endif
+cd trom20
        if(kzz.eq.22) then
          irrtr=imtr(ix)
!FOX  SIGMDA=SIGMDA+COTR(IRRTR,5)+RRTR(IRRTR,5,1)*X(1)+
!FOX  RRTR(IRRTR,5,2)*Y(1)+RRTR(IRRTR,5,3)*X(2)+RRTR(IRRTR,5,4)*Y(2) ;
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  X(1)=COTR(IRRTR,1)+RRTR(IRRTR,1,1)*PUX+RRTR(IRRTR,1,2)*PUZ+
!FOX  RRTR(IRRTR,1,6)*DPDA1 ;
!FOX  Y(1)=COTR(IRRTR,2)+RRTR(IRRTR,2,1)*PUX+RRTR(IRRTR,2,2)*PUZ+
!FOX  RRTR(IRRTR,2,6)*DPDA1 ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  X(2)=COTR(IRRTR,3)+RRTR(IRRTR,3,3)*PUX+RRTR(IRRTR,3,4)*PUZ+
!FOX  RRTR(IRRTR,3,6)*DPDA1 ;
!FOX  Y(2)=COTR(IRRTR,4)+RRTR(IRRTR,4,3)*PUX+RRTR(IRRTR,4,4)*PUZ+
!FOX  RRTR(IRRTR,4,6)*DPDA1 ;
      endif
+cd trom30
        if(kzz.eq.22) then
          ktrack(i)=3
          goto 290
        endif
+cd trom40
          irrtr=imtr(ix)
          do j=1,napx
+cd trom41
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
+cd trom42
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(real(idz(1),fPrec)*dpsv3(j))*           &
     &rrtr(irrtr,1,6)   !hr03
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(real(idz(1),fPrec)*dpsv3(j))*           &
     &rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(real(idz(2),fPrec)*dpsv3(j))*           &
     &rrtr(irrtr,3,6)   !hr03
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(real(idz(2),fPrec)*dpsv3(j))*           &
     &rrtr(irrtr,4,6)   !hr03
          enddo

!----------------------------------------------------------------------
! Wire element.

+cd wirekick
! MODEL OF STRAIGHT CURRENT WIRE
!
!     The model provides a transfer map of a straight current wire. 
!     Description:
!     1. Infinitly thin wire with arbitrary orientation.
!     2. Thin element in SixTrack (L)=0
!     3. Parameters: 
!     dx, dy: horizontal and vertical distances between wire midpoint
!     and closed orbit [mm] 
!     (parameters are given by dx and dy in WIRE block)
!     tx, ty: tilt of the wire w.r.t the closed orbit in the
!     horizontal and vertical planes (in degrees) 
!     (parameters are given by tiltx and tilty in WIRE block)
!     L - physical length of the wire element [m]
!     cur - current of the wire [Amperes]
!     embl - embedding drift (integrated length or integration interval) [m] 
!     4. The transport map is given for canonical variables (x,px...)
!
! The MAP is constructed out of the following steps:
!     1. Declaration of shifted canonical variables: 
!          rx = x+dx; ry = y+dy  in the same way as for the BEAM-BEAM element
!     2. Symplectic Rotation by the tilt angles tx, ty (in 4D space: px, rx, py, ry)
!     3. Wire kick for a longitudinally aligned wire (= kick for tx=ty=0)
!     4. Symplectic Rotation back by the tilt angles -ty, -yx (in 4D space: ...taking only PX, PY)
!--------------------------------------------------------------
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I

!     magnetic rigidity
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            

      tx = wire_tiltx(ix) !tilt x [degrees] 
      ty = wire_tilty(ix) !tilt y [degrees]
      tx = tx*(pi/c180e0) ![rad]
      ty = ty*(pi/c180e0) ![rad]
      dx = wire_dispx(ix) !displacement x [mm]
      dy = wire_dispy(ix) !displacement y [mm]
      embl = wire_lint(ix) !integrated length [m]
      l = wire_lphys(ix) !physical length [m]
      cur = wire_current(ix)

      if (abs(wire_flagco(ix)).ne.1) then
        write(lout,                                                     &
     &fmt='((A,A,/),(A,I0,A,A,/),(A,I0,A,I0,/))')                       &
     &'ERROR: in wirekick -  wire_flagco defined in WIRE block must ',  &
     &'be either 1 or -1! Did you define all wires in the WIRE block?', &
     &'bez(',ix,') = ',bez(ix),                                         &
     &'wire_flagco(',ix,') = ',wire_flagco(ix)
        call prror(-1)
      endif
      NNORM=c1m7/chi

      IF (wire_flagco(ix).eq.1) THEN
         dxi = (dx+wire_clo(1,wire_num(i)) )*c1m3
         dyi = (dy+wire_clo(2,wire_num(i)) )*c1m3 
      ELSE IF (wire_flagco(ix).eq.-1) THEN
         dxi = (dx)*c1m3
         dyi = (dy)*c1m3
      END IF 
      
      do j=1, napx

      yv(1,j) = yv(1,j) * c1m3 !SI
      yv(2,j) = yv(2,j) * c1m3 !SI
    
! 1 shift
      IF (wire_flagco(ix).eq.1) THEN
         xi = (xv(1,j)+dx)*c1m3 !SI
         yi = (xv(2,j)+dy)*c1m3 !SI
      ELSE IF (wire_flagco(ix).eq.-1) THEN
         xi = (xv(1,j)+( dx-wire_clo(1,wire_num(i)) ))*c1m3 !SI
         yi = (xv(2,j)+( dy-wire_clo(2,wire_num(i)) ))*c1m3 !SI
      END IF 

! x'-> px; y'->py
      yv(1,j) = yv(1,j)*(one + dpsv(j))
      yv(2,j) = yv(2,j)*(one + dpsv(j))

!ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
          yi = yi-(((xi*sin_mb(tx))*yv(2,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_mb(atan_mb(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx)
          xi = xi*(cos_mb(tx)-sin_mb(tx)*tan_mb(atan_mb(yv(1,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))
          yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin_mb(atan_mb(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)
      
          xi = xi-(((yi*sin_mb(ty))*yv(1,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_mb(atan_mb(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)
          yi = yi*(cos_mb(ty)-sin_mb(ty)*tan_mb(atan_mb(yv(2,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))
          yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                  &
     &sin_mb(atan_mb(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)
      
! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO

! ibeco = 1
      elseif(ibeco.eq.1) then
! 2 symplectic rotation of coordinate system (tx, ty)

          dyi = dyi-(((dxi*sin_mb(tx))*yv(2,j))/                        &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_mb(atan_mb(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx) 
          dxi = dxi*(cos_mb(tx)-sin_mb(tx)*tan_mb(atan_mb(yv(1,j)/      &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))
 
          yi = yi-(((xi*sin_mb(tx))*yv(2,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(2,j)**2))/                               &
     &cos_mb(atan_mb(yv(1,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-tx)
          xi = xi*(cos_mb(tx)-sin_mb(tx)*tan_mb(atan_mb(yv(1,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))

          yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                  &
     &sin_mb(atan_mb(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)
              
          dxi = dxi-(((dyi*sin_mb(ty))*yv(1,j))/                        &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_mb(atan_mb(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)
          dyi = dyi*(cos_mb(ty)-sin_mb(ty)*tan_mb(atan_mb(yv(2,j)/      &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))
      
          xi = xi-(((yi*sin_mb(ty))*yv(1,j))/                           &
     &sqrt((one+dpsv(j))**2-yv(1,j)**2))/                               &
     &cos_mb(atan_mb(yv(2,j)/sqrt(((one+dpsv(j))**2-yv(1,j)**2)-        &
     &yv(2,j)**2))-ty)
          yi = yi*(cos_mb(ty)-sin_mb(ty)*tan_mb(atan_mb(yv(2,j)/        &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))

         yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                   &
     &sin_mb(atan_mb(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)

! 3 apply wire kick
          RTWO = xi**2+yi**2
          yv(1,j) = yv(1,j)-(((CUR*NNORM)*xi)*                          &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)-(((CUR*NNORM)*yi)*                          &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
          RTWO = dxi**2+dyi**2
          yv(1,j) = yv(1,j)+(((CUR*NNORM)*dxi)*                         &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO
          yv(2,j) = yv(2,j)+(((CUR*NNORM)*dyi)*                         &
     &(sqrt((embl+L)**2+four*RTWO)-sqrt((embl-L)**2+four*RTWO) ))/RTWO
      
      endif

! 4 SYMPLECTIC ROTATION OF COORDINATE SYSTEM (-ty, -tx)
      yv(2,j) = sqrt((one+dpsv(j))**2-yv(1,j)**2)*                      &
     &sin_mb(atan_mb(yv(2,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)
      yv(1,j) = sqrt((one+dpsv(j))**2-yv(2,j)**2)*                      &
     &sin_mb(atan_mb(yv(1,j)/                                           &
     &sqrt(((one+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)

! px -> x'; py -> y'
      yv(1,j) = yv(1,j)/(one + dpsv(j))
      yv(2,j) = yv(2,j)/(one + dpsv(j))
!-----------------------------------------------------------------------
! END OF WIRE MAP
!-----------------------------------------------------------------------
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
!-----------------------------------------------------------------------
      enddo
!-----------------------------------------------------------------------
+cd open
!--OPENING DATA FILES
+if boinc
      call boincrf('fort.2',filename)
+if fio
      open(2,file=filename,form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(2,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(2,file='fort.2',form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(2,file='fort.2',form='formatted',status='unknown')
+ei

+ei !END of +if .not.boinc
+if boinc
      call boincrf('fort.3',filename)
+if fio
      open(3,file=filename,form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(3,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(3,file='fort.3',form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(3,file='fort.3',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

! Why no non-boinc version of fort fort.4?
! "Geometry and strength Parameters (format as file #2)"
+if boinc
      call boincrf('fort.4',filename)
      open(4,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(4,file='fort.4',form='formatted',status='unknown')
+ei !END of +if boinc

+if nagfor
+if boinc
      call boincrf('fort.7',filename)
      open(7,file=filename,form='formatted',status='unknown',recl=303)
+ei
+if .not.boinc
      open(7,file='fort.7',form='formatted',status='unknown',recl=303)
+ei
+ei !END of +if nagfor
+if .not.nagfor
+if boinc
      call boincrf('fort.7',filename)
      open(7,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(7,file='fort.7',form='formatted',status='unknown')
+ei
+ei !END of +if .not.nagfor

+if boinc
      call boincrf('fort.8',filename)
+if fio
      open(8,file=filename,form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(8,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(8,file='fort.8',form='formatted',status='unknown',           &
     &round='nearest')
+ei
+if .not.fio
      open(8,file='fort.8',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc
+if boinc
      call boincrf('fort.9',filename)
      open(9,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(9,file='fort.9',form='formatted',status='unknown')
+ei

! We no longer open fort.10 except for BOINC AND BNLELENS
! When we are returning everything from BOINC we can
! use the proper files as normal
+if bnlelens
+if nagfor
+if boinc
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei !END of +if boinc
+ei !END of +if nagfor
+if .not.nagfor
+if boinc
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+ei !END of +if .not.nagfor
+ei !END of +if bnlelens

+if boinc
      call boincrf('fort.11',filename)
+if fio
      open(11,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(11,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(11,file='fort.11',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(11,file='fort.11',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.12',filename)
+if fio
      open(12,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(12,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(12,file='fort.12',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(12,file='fort.12',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.13',filename)
+if fio
      open(13,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(13,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(13,file='fort.13',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(13,file='fort.13',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.14',filename)
+if fio
      open(14,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(14,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(14,file='fort.14',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(14,file='fort.14',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.15',filename)
+if fio
      open(15,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(15,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(15,file='fort.15',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(15,file='fort.15',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.16',filename)
+if fio
      open(16,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(16,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(16,file='fort.16',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(16,file='fort.16',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.17',filename)
+if fio
      open(17,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(17,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(17,file='fort.17',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(17,file='fort.17',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.18',filename)
+if fio
      open(18,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(18,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(18,file='fort.18',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(18,file='fort.18',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.19',filename)
+if fio
      open(19,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(19,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(19,file='fort.19',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(19,file='fort.19',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.20',filename)
+if fio
      open(20,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(20,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(20,file='fort.20',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(20,file='fort.20',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc
      
+if boinc
      call boincrf('fort.21',filename)
+if fio
      open(21,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(21,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(21,file='fort.21',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(21,file='fort.21',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.22',filename)
+if fio
      open(22,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(22,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(22,file='fort.22',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(22,file='fort.22',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.23',filename)
+if fio
      open(23,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(23,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(23,file='fort.23',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(23,file='fort.23',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.24',filename)
+if fio
      open(24,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(24,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(24,file='fort.24',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(24,file='fort.24',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.25',filename)
+if fio
      open(25,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(25,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(25,file='fort.25',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(25,file='fort.25',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.26',filename)
+if fio
      open(26,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(26,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(26,file='fort.26',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(26,file='fort.26',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.27',filename)
+if fio
      open(27,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(27,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(27,file='fort.27',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(27,file='fort.27',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.28',filename)
+if fio
      open(28,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(28,file=filename,form='formatted',status='unknown')
+ei
+ei !END of +if boinc
+if .not.boinc
+if fio
      open(28,file='fort.28',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(28,file='fort.28',form='formatted',status='unknown')
+ei
+ei !END of +if .not.boinc

+if boinc
      call boincrf('fort.29',filename)
+if fio
      open(29,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(29,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(29,file='fort.29',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(29,file='fort.29',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.30',filename)
+if fio
      open(30,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(30,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(30,file='fort.30',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(30,file='fort.30',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.31',filename)
+if fio
      open(31,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(31,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(31,file='fort.31',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(31,file='fort.31',form='formatted',status='unknown')
+ei
+ei

! Why no non-BOINC version of fort.32?
! "Binary dump of full accelerator description"
+if boinc
      call boincrf('fort.32',filename)
      open(32,file=filename,status='unknown',form='unformatted')
+ei
+if .not.boinc
      open(32,file='fort.32',form='unformatted',status='unknown')
+ei

+if boinc
      call boincrf('fort.33',filename)
+if fio
      open(33,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(33,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(33,file='fort.33',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(33,file='fort.33',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.34',filename)
+if fio
      open(34,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(34,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(34,file='fort.34',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(34,file='fort.34',form='formatted',status='unknown')
+ei
+ei

+if boinc
      call boincrf('fort.35',filename)
+if fio
      open(35,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(35,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(35,file='fort.35',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(35,file='fort.35',form='formatted',status='unknown')
+ei
+ei

!     Tracking output files fort.91-i; i=1..32
!     used for postprocessing
+if .not.bnlelens
+if .not.stf !Separate output files (no SingleTrackFile)
+if boinc
      call boincrf('fort.59',filename)
      open(59,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(59,file='fort.59',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.60',filename)
      open(60,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(60,file='fort.60',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.61',filename)
      open(61,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(61,file='fort.61',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.62',filename)
      open(62,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(62,file='fort.62',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.63',filename)
      open(63,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(63,file='fort.63',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.64',filename)
      open(64,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(64,file='fort.64',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.65',filename)
      open(65,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(65,file='fort.65',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.66',filename)
      open(66,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(66,file='fort.66',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.67',filename)
      open(67,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(67,file='fort.67',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.68',filename)
      open(68,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(68,file='fort.68',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.69',filename)
      open(69,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(69,file='fort.69',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.70',filename)
      open(70,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(70,file='fort.70',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.71',filename)
      open(71,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(71,file='fort.71',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.72',filename)
      open(72,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(72,file='fort.72',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.73',filename)
      open(73,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(73,file='fort.73',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.74',filename)
      open(74,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(74,file='fort.74',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.75',filename)
      open(75,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(75,file='fort.75',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.76',filename)
      open(76,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(76,file='fort.76',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.77',filename)
      open(77,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(77,file='fort.77',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.78',filename)
      open(78,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(78,file='fort.78',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.79',filename)
      open(79,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(79,file='fort.79',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.80',filename)
      open(80,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(80,file='fort.80',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.81',filename)
      open(81,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(81,file='fort.81',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.82',filename)
      open(82,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(82,file='fort.82',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.83',filename)
      open(83,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(83,file='fort.83',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.84',filename)
      open(84,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(84,file='fort.84',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.85',filename)
      open(85,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(85,file='fort.85',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.86',filename)
      open(86,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(86,file='fort.86',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.87',filename)
      open(87,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(87,file='fort.87',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.88',filename)
      open(88,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(88,file='fort.88',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.89',filename)
      open(89,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(89,file='fort.89',form='unformatted',status='unknown')
+ei
+if boinc
      call boincrf('fort.90',filename)
      open(90,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(90,file='fort.90',form='unformatted',status='unknown')
+ei
+ei !END +if .not.stf
+if stf
+if boinc
      call boincrf('singletrackfile.dat',filename)
      open(90,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
      open(90,file='singletrackfile.dat',form='unformatted',                 &
     &status='unknown')
+ei
+ei ! END +if stf
+ei ! END +if .not.bnlelens
      
+if boinc
      call boincrf('fort.98',filename)
      open(98,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(98,file='fort.98',form='formatted',status='unknown')
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
+if cr
! For BOINC all output now goes to fort.10
+if .not.boinc
+if fio
      open(51,file='fort.51',form='formatted',round='nearest')
+ei
+if .not.fio
      open(51,file='fort.51',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if .not.boinc
+if fio
      open(51,file='SixTwiss.dat',form='formatted',round='nearest')
+ei
+if .not.fio
      open(51,file='SixTwiss.dat',form='formatted')
+ei
+ei
+ei ! END +if .not.cr

+if cr
+if .not.boinc
+if fio
      open(52,file='fort.52',form='formatted',round='nearest')
+ei
+if .not.fio
      open(52,file='fort.52',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(52,file='beambeam-output.dat',form='formatted',              &
     &round='nearest')
+ei
+if .not.fio
      open(52,file='beambeam-output.dat',form='formatted')
+ei
+ei ! END +if .not.cr

+if cr
+if .not.boinc
+if fio
      open(53,file='fort.53',form='formatted',round='nearest')
+ei
+if .not.fio
      open(53,file='fort.53',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(53,file='beambeam-lostID.dat',form='formatted',              &
     &round='nearest')
+ei
+if .not.fio
      open(53,file='beambeam-lostID.dat',form='formatted')
+ei
+ei ! END +if .not.cr

+if cr
+if boinc
      call boincrf('fort.54',filename)
+if fio
      open(54,file=filename,form='formatted',round='nearest')
+ei
+if .not.fio
      open(54,file=filename,form='formatted')
+ei
+ei
+ei ! END +if cr
      
+if .not.boinc
+if fio
      open(54,file='fort.54',form='formatted',round='nearest')
+ei
+if .not.fio
      open(54,file='fort.54',form='formatted')
+ei
+ei
+if .not.cr
+if fio
      open(54,file='beambeamdist.dat',form='formatted',                 &
     &round='nearest')
+ei
+if .not.fio
      open(54,file='beambeamdist.dat',form='formatted')
+ei
+ei

+if cr
+if .not.boinc
+if fio
      open(97,file='fort.97',form='formatted',round='nearest')
+ei
+if .not.fio
      open(97,file='fort.97',form='formatted')
+ei
+ei
+ei ! END +if cr
+if .not.cr
+if fio
      open(97,file='checkdist.dat',form='formatted',round='nearest')
+ei
+if .not.fio
      open(97,file='checkdist.dat',form='formatted')
+ei
+ei ! END +if .not.cr
!GRDRHIC
!GRD-042008
+ei ! END +if bnlelens
      
!Eric for the DA coefficients in BINARY
      open(111,file='fort.111',form='unformatted')
! Write a BINARY fort.10 of sumda for checking
      open(110,file='fort.110',form='unformatted')

+if debug
!DUMPS 99
+if boinc
      call boincrf('dump',filename)
      open(99,file=filename,form='unformatted')
      call boincrf('arrays',filename)
      open(100,file=filename,form='unformatted')
+ei
+if .not.boinc
      open(99,file='dump',form='unformatted')
      open(100,file='arrays',form='unformatted')
+ei
+ei ! END +if debug

!     A.Mereghetti, D.Sinuela Pastor and P.G.Ortega, for the FLUKA Team
!     last modified: 04-07-2014
!     open unit where lostpart will dump lost particles
!     allways in main code
      open(999)

! END of +cd open

+cd flukaclose

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     clean closure of communication with fluka and un-set mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      fluka_con = fluka_is_running()
      if (fluka_con.eq.0) then
        if ( .not. fluka_connected ) then
!         temporarily connect to fluka, to properly terminate the run
          fluka_con = fluka_connect()
          if (fluka_con.eq.-1) then
!           no hope to properly close the run
            write(lout,*) '[Fluka] unable to connect to fluka while'
            write(lout,*) '        closing the simulation: please,'
            write(lout,*) '        manually kill all its instances'
            write(fluka_log_unit,*) '# unable to connect to fluka while'
            write(fluka_log_unit,*) '#  closing the simulation: please,'
            write(fluka_log_unit,*) '#  manually kill all its instances'
            goto 1982
          endif
          write(lout,*) '[Fluka] Successfully connected to Fluka server'
          write(lout,*) '[Fluka]     (only temporarily)'
          write(fluka_log_unit,*)                                       &
     &'# Successfully connected to Fluka server'
          write(fluka_log_unit,*)                                       &
     &'#     (only temporarily)'
        endif
        call fluka_end
      endif
 1982 call fluka_mod_end
      flush(lout)
!      flush(fluka_log_unit)

+cd rvet0
      e0f=sqrt(e0**2-pma**2)                                             !hr03
+if rvet
!FOX  RVET=C1E3*PMA*PMA*(TWO+DPDA)*DPDA/E0/DPD ;
!FOX  RVET=RVET/(E0*DPD+SQRT(E0*E0+E0F*E0F*(TWO*DPDA+DPDA*DPDA))) ;
+ei
+cd rvet1
+if rvet
        rvet(j)=((((c1e3*pma**2)*(two+dpsv(j)))*dpsv(j))/e0)/dpd(j)      !hr03
        rvet(j)=rvet(j)/(e0*dpd(j)+                                     &!hr03
     &sqrt(e0**2+e0f**2*(two*dpsv(j)+dpsv(j)**2)))                       !hr03
+ei
+if .not.rvet
!
+ei
+cd rvet2
+if .not.rvet
        rv=(ej(1)*e0f)/(e0*ejf(1))
+ei
+if rvet
        rv=(ej(1)*e0f)/(e0*ejf(1))
        rvet=((((c1e3*pma**2)*(two+dps(1)))*dps(1))/e0)/(one+dps(1))
        rvet=rvet/(e0*(one+dps(1))+sqrt(e0**2+e0f**2*(two*dps(1)+       &!hr03
     &dps(1)*dps(1))))                                                   !hr03
+ei
+cd dalin1
        jmel=mel(ix)
        if(idp.eq.0.or.ition.eq.0) then
          if(ithick.eq.1) then
            do jb=1,jmel
              jx=mtyp(ix,jb)
              do ip=1,6
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,1,ip,ien)
                enddo
                if(nvar2.eq.4) then
                  call darea6(alda(1,ip),zfeld1,4)
                else if(nvar2.eq.5) then
                  call darea6(alda(1,ip),zfeld1,5)
                endif
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,2,ip,ien)
                enddo
                if(nvar2.eq.4) then
                  call darea6(alda(2,ip),zfeld1,4)
                else if(nvar2.eq.5) then
                  call darea6(alda(2,ip),zfeld1,5)
                endif
              enddo
+cd dalin2
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  X(1)=ALDA(1,1)*PUX+ALDA(1,2)*PUZ+ALDA(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDA(1,3)*PUX+ALDA(1,4)*PUZ+ALDA(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  X(2)=ALDA(2,1)*PUX+ALDA(2,2)*PUZ+ALDA(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDA(2,3)*PUX+ALDA(2,4)*PUZ+ALDA(2,6)*IDZ(2) ;
+cd dalin3
            enddo
          else
!FOX  X(1)=X(1)+BL1(IX,1,2)*Y(1) ;
!FOX  X(2)=X(2)+BL1(IX,2,2)*Y(2) ;
          endif
+cd dalin4
        else
          do jb=1,jmel
            jx=mtyp(ix,jb)
            if(ithick.eq.1) then
              do ip=1,6
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,1,ip,ien)
                  zfeld2(ien)=asd6(jx,1,ip,ien)
                enddo
                if(nvar2.eq.5) then
                  call darea6(alda(1,ip),zfeld1,5)
                  call darea6(asda(1,ip),zfeld2,5)
                else if(nvar2.eq.6) then
                  call darea6(alda(1,ip),zfeld1,6)
                  call darea6(asda(1,ip),zfeld2,6)
                endif
                do ien=1,nord+1
                  zfeld1(ien)=ald6(jx,2,ip,ien)
                  zfeld2(ien)=asd6(jx,2,ip,ien)
                enddo
                if(nvar2.eq.5) then
                  call darea6(alda(2,ip),zfeld1,5)
                  call darea6(asda(2,ip),zfeld2,5)
                else if(nvar2.eq.6) then
                  call darea6(alda(2,ip),zfeld1,6)
                  call darea6(asda(2,ip),zfeld2,6)
                endif
              enddo
+cd dalin5
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  SIGMDA=SIGMDA+ASDA(1,1)+ASDA(1,2)*PUX+
!FOX  ASDA(1,3)*PUZ+ASDA(1,4)*PUX*PUZ+ASDA(1,5)*PUX*PUX+
!FOX  ASDA(1,6)*PUZ*PUZ ;
!FOX  X(1)=ALDA(1,1)*PUX+ALDA(1,2)*PUZ+ALDA(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDA(1,3)*PUX+ALDA(1,4)*PUZ+ALDA(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  SIGMDA=SIGMDA+ASDA(2,1)+ASDA(2,2)*PUX+
!FOX  ASDA(2,3)*PUZ+ASDA(2,4)*PUX*PUZ+ASDA(2,5)*PUX*PUX+
!FOX  ASDA(2,6)*PUZ*PUZ ;
!FOX  X(2)=ALDA(2,1)*PUX+ALDA(2,2)*PUZ+ALDA(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDA(2,3)*PUX+ALDA(2,4)*PUZ+ALDA(2,6)*IDZ(2) ;
+cd dalin6
!            else !moved outside of dalin6 /Mattias
!FOX  X(1)=X(1)+EL(JX)*Y(1) ;
!FOX  X(2)=X(2)+EL(JX)*Y(2) ;
+cd dalino
          do 60 kx=1,2
            if(ithick.eq.1) then
!FOX  PUX=X(KX) ;
!FOX  PUZ=Y(KX) ;
            endif
            if(idp.eq.0.or.ition.eq.0) then
              if(ithick.eq.1) then
!FOX  X(KX)=BL1(IX,KX,1)*PUX+BL1(IX,KX,2)*PUZ+
!FOX  BL1(IX,KX,5)*IDZ(KX)*DPDA*C1E3 ;
!FOX  Y(KX)=BL1(IX,KX,3)*PUX+BL1(IX,KX,4)*PUZ+
!FOX  BL1(IX,KX,6)*IDZ(KX)*DPDA*C1E3 ;
              else
!FOX  X(KX)=X(KX)+BL1(IX,KX,2)*Y(KX) ;
              endif
            else
              do 50 jb=1,jmel
                jx=mtyp(ix,jb)
                if(ithick.eq.1) then
                  do 40 ip=1,6
                    do 30 ien=1,nord+1
                      zfeld1(ien)=ald6(jx,kx,ip,ien)
                      zfeld2(ien)=asd6(jx,kx,ip,ien)
   30               continue
                    if(nvar2.eq.5) then
                      call darea6(alda(kx,ip),zfeld1,5)
                      call darea6(asda(kx,ip),zfeld2,5)
                    else if(nvar2.eq.6) then
                      call darea6(alda(kx,ip),zfeld1,6)
                      call darea6(asda(kx,ip),zfeld2,6)
                    endif
   40             continue
!FOX  SIGMDA=SIGMDA+ASDA(KX,1)+ASDA(KX,2)*PUX+
!FOX  ASDA(KX,3)*PUZ+ASDA(KX,4)*PUX*PUZ+ASDA(KX,5)*PUX*PUX+
!FOX  ASDA(KX,6)*PUZ*PUZ ;
!FOX  X(KX)=ALDA(KX,1)*PUX+ALDA(KX,2)*PUZ+ALDA(KX,5)*IDZ(KX) ;
!FOX  Y(KX)=ALDA(KX,3)*PUX+ALDA(KX,4)*PUZ+ALDA(KX,6)*IDZ(KX) ;
!FOX  PUX=X(KX) ;
!FOX  PUZ=Y(KX) ;
                else
!FOX  X(KX)=X(KX)+EL(JX)*Y(KX) ;
                  if (kx.eq.1) then
+ca sqrtfox0
!FOX  SIGMDA=SIGMDA+
+ca sqrtfox
                  endif
                endif
   50         continue
            endif
   60     continue

+dk close
      subroutine closeUnits
      use floatPrecision
      use scatter, only : scatter_closefiles
      use dynk, only : ldynk, nfuncs_dynk, funcs_dynk, iexpr_dynk

      use dump, only : dump_closeUnits
      implicit none
+ca parpro
+ca common
+ca comgetfields
+ca parbeam_exp
      integer i
      logical lopen
!-----------------------------------------------------------------------
!--CLOSE(DATA FILES
      close(2,err=2)
 2    continue
      close(3,err=3)
 3    continue
      close(4,err=4)
 4    continue
      close(7,err=7)
 7    continue
      close(8,err=8)
 8    continue
      close(9,err=9)
 9    continue
      close(10,err=10)
 10    continue
      close(11,err=11)
 11    continue
      close(12,err=12)
 12    continue
      close(13,err=13)
 13    continue
      close(14,err=14)
 14    continue
      close(15,err=15)
 15    continue
      close(16,err=16)
 16    continue
      close(17,err=17)
 17    continue
      close(18,err=18)
 18    continue
      close(19,err=19)
 19    continue
      close(20,err=20)
 20    continue
      close(21,err=21)
 21    continue
      close(22,err=22)
 22    continue
      close(23,err=23)
 23    continue
      close(24,err=24)
 24    continue
      close(25,err=25)
 25    continue
      close(26,err=26)
 26    continue
      close(27,err=27)
 27    continue
      close(28,err=28)
 28    continue
      close(29,err=29)
 29    continue
      close(30,err=30)
 30    continue
      close(31,err=31)
 31    continue
      close(32,err=32)
 32    continue
      close(33,err=33)
 33    continue
      close(34,err=34)
 34    continue
      close(35,err=35)
 35    continue
+if .not.stf
      close(59,err=59)
 59    continue
      close(60,err=60)
 60    continue
      close(61,err=61)
 61    continue
      close(62,err=62)
 62    continue
      close(63,err=63)
 63    continue
      close(64,err=64)
 64    continue
      close(65,err=65)
 65    continue
      close(66,err=66)
 66    continue
      close(67,err=67)
 67    continue
      close(68,err=68)
 68    continue
      close(69,err=69)
 69    continue
      close(70,err=70)
 70    continue
      close(71,err=71)
 71    continue
      close(72,err=72)
 72    continue
      close(73,err=73)
 73    continue
      close(74,err=74)
 74    continue
      close(75,err=75)
 75    continue
      close(76,err=76)
 76    continue
      close(77,err=77)
 77    continue
      close(78,err=78)
 78    continue
      close(79,err=79)
 79    continue
      close(80,err=80)
 80    continue
      close(81,err=81)
 81    continue
      close(82,err=82)
 82    continue
      close(83,err=83)
 83    continue
      close(84,err=84)
 84    continue
      close(85,err=85)
 85    continue
      close(86,err=86)
 86    continue
      close(87,err=87)
 87    continue
      close(88,err=88)
 88    continue
      close(89,err=89)
 89    continue
+ei !END +if .not.stf
      close(90,err=90)
 90    continue
      close(98,err=98)
 98    continue

+if bnlelens
!GRDRHIC
!GRD-042008
+if .not.boinc
      close(51,err=51)
 51    continue
      close(52,err=52)
 52    continue
      close(53,err=53)
 53    continue
      close(97,err=97)
 97    continue
+ei
      close(54,err=54)
 54    continue
!GRDRHIC
!GRD-042008
+ei ! END +if bnlelens

+if hdf5
      call CLOSEHDF5()
+ei
+if debug
      close(99,err=99)
 99    continue
      close(100,err=100)
 100    continue
+ei
!Eric....and more to come
      close(110,err=110)
 110    continue
      close(111,err=111)
 111    continue

      if(beam_expfile_open) then
         close(600,err=600)
      endif
 600  continue

      call dump_closeUnits
      
!     A.Mereghetti, for the FLUKA Team
!     last modified: 02-09-2014
!     close units for logging dynks
!     always in main code
      if (ldynk) then
         ! dynksets.dat
         inquire(unit=665, opened=lopen)
         if (lopen) close(665,err=665)
 665     continue
         
         do i=1,nfuncs_dynk
            if ( funcs_dynk(i,2).eq.3) then !PIPE FUN
               ! InPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)), opened=lopen)
               if ( lopen ) close(iexpr_dynk(funcs_dynk(i,3)))
               
               ! OutPipe
               inquire(unit=iexpr_dynk(funcs_dynk(i,3)+1), opened=lopen)
               if ( lopen ) then
                  write(iexpr_dynk(funcs_dynk(i,3))+1,"(a)")            &
     &                 "CLOSEUNITS"
                  close(iexpr_dynk(funcs_dynk(i,3))+1)
               endif
            endif
         end do
      end if

      call scatter_closefiles

!     A.Mereghetti, D.Sinuela Pastor and P.G.Ortega, for the FLUKA Team
!     last modified: 04-07-2014
!     close unit where lostpart has dumped lost particles
!     always in main code
      close(999)
      
      return
      end subroutine

+dk cor_ord
      subroutine coruord
!-----------------------------------------------------------------------
!---- PROGRAM FOR THE TUNESHIFT CORRECTIONS
!----
!----   =========>      FIRST & SECOND ORDER CORRECTIONS      <=========
!----   =========>            AMPLITUDE & CHROMATIC           <=========
!----   =========>                  EFFECTS                   <=========
!----
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      
      use crcoall
      implicit none
      integer i,ifail,istate,iter,iuser,iwork,j,jaord,jbound,jcol,jcomp,&
     &jconf,jord,jpord,jrow,jsex,jvar,k,kcol,l,liwork,lwork,mcor,n,     &
     &nclin,ncnln,nconf,ndim2,nout,nrel,nrowa,nrowj,nrowr
      real(kind=fPrec) a,bl,bu,c,cjac,clamda,objf,objgrd,r,user,work
      real(kind=fPrec) ainv,bmat,chia,chib,cmat,cvec,det,detinv,dvec,   &
     &pi2in,sex,sgn
      external e04udm,objfun1
      parameter(mcor = 10)
      parameter(ndim2 = 6)
+ca commondl
+ca commadha
+ca commadh1
      dimension a(2,10),cjac(1,1),c(1)
      dimension r(10,10),bu(20),bl(20),clamda(20),objgrd(10)
      dimension ainv(2,2),bmat(2,10),cmat(2,10),cvec(2),dvec(2)
      dimension work(450),user(500),sex(10),sgn(10,10)
      dimension istate(20),iwork(40),iuser(3)
      data sgn/100*one/ainv,bmat,cmat,cvec,dvec/48*zero/
      save
!-----------------------------------------------------------------------
      pi2in=one/(eight*atan_mb(one))
!-----------------------------------------------------------------------
      do 40 i=0,3
        do 30 j=1,3
          do 20 k=0,3
            do 10 l=0,4000
              hda(i,j,k,l)=zero
   10       continue
   20     continue
   30   continue
   40 continue
!-----------------------------------------------------------------------
      do 50 j=1,10
        sgn(j,j)=-one
   50 continue

!-----------------------------------------------------------------------
!---- SPECIFIES THE I/O UNITS FOR THE NAG ROUTINES
!-----------------------------------------------------------------------
      nout=26
      call x04abf(1,nout)
!-----------------------------------------------------------------------
      jeltot=ncor
!-----------------------------------------------------------------------
      jaord=namp
      jpord=nmom
!-----------------------------------------------------------------------
      call readd1(user,jaord,jpord)
!-----------------------------------------------------------------------
      if(jaord.eq.2.or.jpord.eq.3) goto 130

!-----------------------------------------------------------------------
!---- DEFINES THE MATRIX WITH THE LINEAR CONSTRAINTS
!-----------------------------------------------------------------------
      do 80 jrow=1,2
        do 60 jcol=1,jeltot
          a(jrow,jcol)=hda(jrow-1,1,1,3**(jcol-1))
   60   continue
        do 70 jcol=1,jeltot-2
          bmat(jrow,jcol)=-one*a(jrow,jcol+2)                            !hr04
   70   continue
!-----------------------------------------------------------------------
        cvec(jrow)=-one*hda(jrow-1,1,1,0)                                !hr04
   80 continue

!-----------------------------------------------------------------------
!---- DEFINES THE RELATION BETWEEN THE FIRST TWO SEXTUPOLES AND THE
!---- OTHERS
!-----------------------------------------------------------------------
      det=(a(1,1)*a(2,2)-a(2,1)*a(1,2))
      detinv=one/det
      ainv(1,1)=detinv*a(2,2)
      ainv(1,2)=-one*detinv*a(1,2)                                       !hr04
      ainv(2,1)=-one*detinv*a(2,1)                                       !hr04
      ainv(2,2)=detinv*a(1,1)
!-----------------------------------------------------------------------
      do 120 jrow=1,2
!-----------------------------------------------------------------------
        do 100 jcol=1,jeltot
          do 90 kcol=1,2
            cmat(jrow,jcol)=cmat(jrow,jcol)+ainv(jrow,kcol) *bmat       &
     &(kcol,jcol)
   90     continue
  100   continue
!-----------------------------------------------------------------------
        do 110 jcol=1,2
          dvec(jrow)=dvec(jrow)+ainv(jrow,jcol)*cvec(jcol)
  110   continue
  120 continue
!-----------------------------------------------------------------------
!---- WRITES ON THE EXIT FILE
!-----------------------------------------------------------------------
  130 write(lout,10000)
      write(lout,10010)
      write(lout,10020) jeltot,jaord,jpord
      write(lout,10030)
!-----------------------------------------------------------------------
      nrel=2
      nconf=jeltot-2
      if(jaord.eq.2.or.jpord.eq.3) then
        nrel=0
        nconf=1
      end if
!-----------------------------------------------------------------------
      do 240 jconf=1,jeltot
!-----------------------------------------------------------------------
!---- DEFINES EXTRA PARAMETERS
!-----------------------------------------------------------------------
        n=jeltot
        nclin=nrel
        ncnln=0
        nrowa=2
        nrowj=1
        nrowr=10
!-----------------------------------------------------------------------
        liwork=30
        lwork=450
!-----------------------------------------------------------------------
        do 140 jbound=1,n
          bu(jbound)=c1e10
          bl(jbound)=-c1e10
  140   continue
!-----------------------------------------------------------------------
        do 150 jbound=1,nclin
          bu(n+jbound)=-hda(jbound-1,1,1,0)
          bl(n+jbound)=bu(n+jbound)
  150   continue
!-----------------------------------------------------------------------
        do 160 jvar=1,n
          x(jvar)=zero
  160   continue
!-----------------------------------------------------------------------
        if(nrel.eq.2) then
!-----------------------------------------------------------------------
!---- DEFINES THE INITIAL GUESS SO THAT IT SATISFIES THE LINEAR
!---- CONSTRAINTS
!-----------------------------------------------------------------------
          do 180 jvar=1,2
            do 170 jcol=1,n-2
              x(jvar)=(x(jvar)+cmat(jvar,jcol)*sgn(jcol,jconf)) +dvec   &!hr04
     &(jvar)
              x(jcol+2)=sgn(jcol,jconf)
  170       continue
  180     continue
!-----------------------------------------------------------------------
        else if(nrel.eq.0) then
!-----------------------------------------------------------------------
          do 190 jvar=1,n
            x(jvar)=sgn(jvar,jconf)
  190     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        iuser(1)=jaord
        iuser(2)=jpord
        if(iuser(1).eq.0) iuser(3)=1
        if(iuser(2).eq.0) iuser(3)=iuser(1)+1
!-----------------------------------------------------------------------
        ifail=-1
!-----------------------------------------------------------------------
        call e04uef('MAJOR ITERATION LIMIT = 100')
!-----------------------------------------------------------------------
        call e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,e04udm,     &
     &objfun1,iter,istate,c,cjac,clamda,objf,objgrd,r,x,iwork,liwork,   &
     &work,lwork,iuser,user,ifail)
!-----------------------------------------------------------------------
        if(ifail.ne.0.and.ifail.ne.5) then
!-----------------------------------------------------------------------
          write(lout,10040) ifail
          call prror(-1)
        end if
!-----------------------------------------------------------------------
        do 200 jsex=1,jeltot
          sex(jsex)=x(jsex)
          write(lout,10050) coel(jsex),sex(jsex)
  200   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN DP/P AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 210 jord=1,maxp
          call hamilton1(1,jord)
!-----------------------------------------------------------------------
!---- WRITES THE VALUES OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10060) jord
          write(lout,10070)
          write(lout,10080) hda(1,1,jord,0),hda(0,1,jord,0)
          write(lout,10090)
          write(lout,10080) ham(1),ham(0)
          write(lout,10100)
!-----------------------------------------------------------------------
  210   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN AMP AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 230 jord=2,maxa
!-----------------------------------------------------------------------
          call hamilton1(jord,0)
!-----------------------------------------------------------------------
!---- COMPUTES THE FUNCTION CHI
!-----------------------------------------------------------------------
          if(jord.eq.2) then
!-----------------------------------------------------------------------
            chib=(pi2in/sqrt(three))*sqrt((((two*hda(0,2,0,0)**2 +hda   &!hr04
     &(1,2,0,0)**2)+two*hda(2,2,0,0)**2)+hda(0,2,0,0) *hda(1,2,0,0)     &!hr04
     &)+hda(1,2,0,0)*hda(2,2,0,0))                                       !hr04
          chia=(pi2in/sqrt(three))*sqrt((((two*ham(0)**2+ham(1)**2)+two &!hr04
     &*ham(2)**2)+ham(0)*ham(1))+ham(1)*ham(2))                          !hr04
!-----------------------------------------------------------------------
          else if(jord.eq.3) then
!-----------------------------------------------------------------------
      chib=(pi2in/sqrt(30.d0))*sqrt((((((((27.d0*hda(3,3,0,0)**2 +5.d0  &!hr04
     &*hda(2,3,0,0)**2)+5.d0*hda(1,3,0,0)**2)+27.d0*hda(0,3,0,0)**2)    &!hr04
     &+(9.d0*hda(3,3,0,0))*hda(2,3,0,0))+(9.d0*hda(1,3,0,0))*hda        &!hr04
     &(0,3,0,0))+(6.d0*hda(2,3,0,0))*hda(1,3,0,0))+(3.d0*hda(3,3,0,0)   &!hr04
     &)*hda(1,3,0,0)) +(3.d0*hda(2,3,0,0))*hda(0,3,0,0))                 !hr04
      chia=(pi2in/sqrt(30.d0))*sqrt((((((((27.d0*ham(3)**2 +5.d0*ham(2) &!hr04
     &**2)+5.d0*ham(1)**2)+27.d0*ham(0)**2)+(9.d0*ham(3))*ham(2))+(9.d0 &!hr04
     &*ham(1))*ham(0))+(6.d0*ham(2))*ham(1))+(3.d0*ham(3))*ham(1))+(3.d0&!hr04
     &*ham(2))*ham(0))
!-----------------------------------------------------------------------
          end if
!-----------------------------------------------------------------------
!---- WRITES THE VALUE OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10110) jord
          write(lout,10120)
!-----------------------------------------------------------------------
          do 220 jcomp=0,jord
!-----------------------------------------------------------------------
            write(lout,10130)jcomp,jord-jcomp,hda(jcomp,jord,0,0),jcomp,jord-jcomp,ham(jcomp)
!-----------------------------------------------------------------------
  220     continue
          write(lout,10140) jord-1,chib,jord-1,chia
          write(lout,10100)
!-----------------------------------------------------------------------
  230   continue
!-----------------------------------------------------------------------
  240 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
10000 format(//80('-')//t10,29('O')/t10,2('O'),25x,2('O')/t10,          &
     &'OO  TUNE-SHIFT CORRECTION  OO', /t10,2('O'),25x,2('O')/t10,29('O'&
     &)//80('-')//)
10010 format(//t26,'*** ORDER-BY-ORDER CORRECTIONS ***'//)
10020 format(t10,'NUMBER OF CORRECTOR ELEMENTS ',t48,i8/ t10,           &
     &'TUNE-SHIFT ORDER (AMPLITUDE) ',t48,i8/ t10,                      &
     &'TUNE-SHIFT ORDER (MOMENTUM) ',t48,i8)
10030 format(/,t10,'VALUES OF THE INTEGRATED GRADIENTS OF THE ',        &
     &'CORRECTOR MULTIPOLES',/)
10040 format(//,t10,' ERROR IN ROUTINE E04UCF. IFAIL = ',i8)
10050 format(/,t10,'CORRECTOR ELEMENT  - ',a16,' - ',4x,e20.14)
10060 format(//,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,       &
     &'MOMENTUM DEPENDENCE ')
10070 format(/,t10,'BEFORE CORRECTION ')
10080 format(/,'H_1,0    = ',2x,e16.8,7x,'H_0,1    = ', 2x,e16.8)
10090 format(/,t10,'AFTER CORRECTION ')
10100 format(//80('-'))
10110 format(//,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,       &
     &'AMPLITUDE DEPENDENCE',/)
10120 format(/,t10,'BEFORE CORRECTION ',20x,'AFTER CORRECTION ')
10130 format(/,t10,'H_',i1,',',i1,'    = ',e16.8,11x, 'H_',i1,',',i1,   &
     &'    = ',e16.8)
10140 format(/,t10,'CHI_',i1,',0  = ',e16.8,11x, 'CHI_',i1,',0  = ',e16.&
     &8)
      end

      subroutine readd1(user,jaord,jpord)
!-----------------------------------------------------------------------
!---- SUBROUTINE TO READ DATA
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer icont,ind,j,j1,j2,j3,j4,j5,j6,jaord,jcomp,jel,jord,jpord, &
     &maxcomp,njx,njx1,njz,njz1,nmax,np,ncoef,nord,point,kointer
      real user
      real(kind=fPrec) cc
+ca commadha
+ca commadh1
      dimension ind(10),user(500)
+if crlibm
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=20)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      real(kind=fPrec) fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      nmax=40
!-----------------------------------------------------------------------
      maxa=jaord+1
      maxp=jpord
      if(jpord.eq.0) then
        maxp=jaord+1
        maxcomp=maxa
      else if(jaord.eq.0) then
        maxa=jpord
        maxcomp=1
      end if
!-----------------------------------------------------------------------
      rewind 23
!-----------------------------------------------------------------------
! Unit 23 is opened with round='nearest' if fio is selected
+if .not.crlibm
   10 read(23,'(I6,2X,G20.14,I5,4X,18(2I2,1X))',end=30) ncoef,cc,nord,  &
     &njx,njx1,njz,njz1,np,(ind(jel),jel=1,jeltot)
      read(23,*,end=30) cc
+ei
+if crlibm
   10 read(23,*,end=30) ch
      ch1(:nchars+3)=ch(:nchars)//' / '
      lineno=lineno+1
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read (fields(1),*) ncoef
        nf=nf-1
      endif
      if (nf.gt.0) then
        cc=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(3),*) nord
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(4),*) njx
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(5),*) njx1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(6),*) njz
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(7),*) njz1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(8),*) np
        nf=nf-1
      endif
      do jel=1,jeltot
        if (nf.gt.0) then
          read (fields(8+jel),*) ind(jel)
          nf=nf-1
        endif
      enddo
      read(23,*,end=30) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cc=fround(errno,fields,1)
        nf=nf-1
      endif
+ei
!-----------------------------------------------------------------------
!---- CODING IND IN BASE 3
!-----------------------------------------------------------------------
      if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).le.maxa.and. np.le.  &
     &maxp) then
        point=0
        do 20 j=1,jeltot
          point=point+ind(j)*3**(j-1)
   20   continue
        if(point.gt.4000) then
          write(lout,10000)
          write(lout,'(a)') "Problem with data in fort.23"
          call prror(-1)
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hda(njx,njx+njz,np,point)=cc+hda(njx,njx+njz,np,point)
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      goto 10
!-----------------------------------------------------------------------
!---- DEFINES DATA FOR THE ROUTINE OBJFUN
!-----------------------------------------------------------------------
   30 if(jeltot.eq.1) then
!-----------------------------------------------------------------------
        do 50 jcomp=0,maxcomp
          icont=0
          do 40 jord=0,2
            j1=jord
!-----------------------------------------------------------------------
            icont=icont+1
            kointer=j1
!-----------------------------------------------------------------------
            user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,kointer)
   40     continue
   50   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
        do 80 jcomp=0,maxcomp
          icont=0
          do 70 jord=0,2
            do 60 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              icont=icont+1
              kointer=j1+j2*3
!-----------------------------------------------------------------------
              user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,kointer)
   60       continue
   70     continue
   80   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
        do 120 jcomp=0,maxcomp
          icont=0
          do 110 jord=0,2
            do 100 j1=0,jord
              do 90 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                icont=icont+1
                kointer=(j1+j2*3)+j3*3**2                                !hr04
!-----------------------------------------------------------------------
                user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord, kointer)
   90         continue
  100       continue
  110     continue
  120   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
        do 170 jcomp=0,maxcomp
          icont=0
          do 160 jord=0,2
            do 150 j1=0,jord
              do 140 j2=0,jord-j1
                do 130 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                  icont=icont+1
                  kointer=((j1+j2*3)+j3*3**2)+j4*3**3                    !hr04
!-----------------------------------------------------------------------
                  user(jcomp*nmax+icont)=hda(jcomp,jaord+1,jpord,       &
     &kointer)
  130           continue
  140         continue
  150       continue
  160     continue
  170   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
        do 230 jcomp=0,maxcomp
          icont=0
          do 220 jord=0,2
            do 210 j1=0,jord
              do 200 j2=0,jord-j1
                do 190 j3=0,jord-j1-j2
                  do 180 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    icont=icont+1
                    kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4        !hr04
!-----------------------------------------------------------------------
                    user(jcomp*nmax+icont)=hda(jcomp,jaord+1, jpord,    &
     &kointer)
  180             continue
  190           continue
  200         continue
  210       continue
  220     continue
  230   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
        do 300 jcomp=0,maxcomp
          icont=0
          do 290 jord=0,2
            do 280 j1=0,jord
              do 270 j2=0,jord-j1
                do 260 j3=0,jord-j1-j2
                  do 250 j4=0,jord-j1-j2-j3
                    do 240 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      icont=icont+1
                 kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5 !hr04
!-----------------------------------------------------------------------
                      user(jcomp*nmax+icont)=hda(jcomp,jaord+1, jpord,  &
     &kointer)
  240               continue
  250             continue
  260           continue
  270         continue
  280       continue
  290     continue
  300   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(//,t10,' INDEX OUT OF BOUND IN ROUTINE READD ')
      end

!-----------------------------------------------------------------------
!---- COMPUTES THE VALUE OF THE HAMILTONIAN AFTER CORRECTIONS
!-----------------------------------------------------------------------
subroutine hamilton1(ja,jp)
  
  ! Updated to Fortran 2015 by V.K.B. Olsen, 19/11/2017
  use floatPrecision
  use numerical_constants
  use mathlib_bouncer
  implicit none

  integer j1,j2,j3,j4,j5,j6,ja,jcomp,jel,jord,jp,l,ncoef,kointer
  real(kind=fPrec) tham
  dimension tham(0:3)
+ca commadha
+ca commadh1
  save

  do jcomp=0,3
    tham(jcomp)=zero
  end do

  if(jp.eq.0) then
    ncoef=ja
  else
    ncoef=1
  end if

  select case (jeltot)
    case (1)
      do jord=0,2
        j1=jord
        kointer=j1
        do l=0,ncoef
          tham(l)=tham(l)+hda(l,ja,jp,kointer)*(x(1)**j1)
        end do
      end do
    
    case (2)
      do jord=0,2
        do j1=0,jord
          j2=jord-j1
          kointer=j1+j2*3
          do l=0,ncoef
            tham(l)=tham(l)+(hda(l,ja,jp,kointer)*(x(1)**j1))*(x(2)**j2) !hr04
          end do
        end do
      end do
      
    case (3)
      do jord=0,2
        do j1=0,jord
          do j2=0,jord-j1
            j3=jord-j1-j2
            kointer=(j1+j2*3)+j3*3**2 ! hr04
            do l=0,ncoef
              tham(l)=tham(l)+((hda(l,ja,jp,kointer)*(x(1)**j1))*(x(2)**j2))*(x(3)**j3) ! hr04
            end do
          end do
        end do
      end do
      
    case (4)
      do jord=0,2
        do j1=0,jord
          do j2=0,jord-j1
            do j3=0,jord-j1-j2
              j4=jord-j1-j2-j3
              kointer=((j1+j2*3)+j3*3**2)+j4*3**3 ! hr04
              do l=0,ncoef
                  tham(l) = tham(l)+(((hda(l,ja,jp,kointer)*(x(1)**j1))(x(2)**j2))*(x(3)**j3))*(x(4)**j4) ! hr04
              end do
            end do
          end do
        end do
      end do
      
    case (5)
      do jord=0,2
        do j1=0,jord
          do j2=0,jord-j1
            do j3=0,jord-j1-j2
              do j4=0,jord-j1-j2-j3
                j5=jord-j1-j2-j3-j4
                kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4 ! hr04
                do l=0,ncoef
                  tham(l)=tham(l)+((((hda(l,ja,jp,kointer)*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5) ! hr04
                end do
              end do
            end do
          end do
        end do
      end do
      
    case (6)
      do jord=0,2
        do j1=0,jord
          do j2=0,jord-j1
            do j3=0,jord-j1-j2
              do j4=0,jord-j1-j2-j3
                do j5=0,jord-j1-j2-j3-j4
                  j6=jord-j1-j2-j3-j4-j5
                  kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5 ! hr04
                  do l=0,ncoef
                    tham(l)=tham(l)+(((((hda(l,ja,jp,kointer)*&
                            (x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))*(x(6)**j6) ! hr04
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
    
  end select
    
  do jel=0,ncoef
    ham(jel)=tham(jel)
  end do
    
  return
    
end subroutine hamilton1

      subroutine objfun1(mode,n,x,objf,objgrd,nstate,iuser,user)
!-----------------------------------------------------------------------
!---- ROUTINE TO COMPUTE THE VALUE OF THE FUNCTION AND OF ITS
!---- DERIVATIVES
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer icont,iuser,j1,j2,j3,j4,j5,j6,jel,jord,jvar,l,mode,n,nmax,&
     &nstate,kointer
      real user
      real(kind=fPrec) fder,fun,objf,objgrd,x
      dimension iuser(*),x(10),objgrd(10),user(*),fun(0:3),fder(0:3,10)
      save
!-----------------------------------------------------------------------
      nmax=40
!-----------------------------------------------------------------------
      do 20 jel=0,3
        do 10 jvar=1,n
          fder(jel,jvar)=zero
   10   continue
        fun(jel)=zero
   20 continue
!-----------------------------------------------------------------------
      if(n.eq.1) then
!-----------------------------------------------------------------------
        do 40 l=0,iuser(3)
          icont=0
          do 30 jord=0,2
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
            icont=icont+1
!-----------------------------------------------------------------------
            fun(l)=fun(l)+user(l*nmax+icont)*(x(1)**j1)
            fder(l,1)=fder(l,1)+(user(l*nmax+icont)*real(j1,fPrec))*    &
     &(x(1)**(j1-1))                                                          !hr04
   30     continue
   40   continue
!-----------------------------------------------------------------------
      else if(n.eq.2) then
!-----------------------------------------------------------------------
        do 70 l=0,iuser(3)
          icont=0
          do 60 jord=0,2
            do 50 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*3
              icont=icont+1
!-----------------------------------------------------------------------
              fun(l)=fun(l)+(user(l*nmax+icont)*(x(1)**j1))*(x(2)**j2)
              fder(l,1)=fder(l,1)+((user(l*nmax+icont)*real(j1,fPrec))* &
     &(x(1)**(j1-1)))*(x(2)**j2)                                         !hr04
              fder(l,2)=fder(l,2)+((user(l*nmax+icont)*real(j2,fPrec))  &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1))                                        !hr04
   50       continue
   60     continue
   70   continue
!-----------------------------------------------------------------------
      else if(n.eq.3) then
!-----------------------------------------------------------------------
        do 110 l=0,iuser(3)
          icont=0
          do 100 jord=0,2
            do 90 j1=0,jord
              do 80 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*3)+j3*3**2                                !hr04
                icont=icont+1
!-----------------------------------------------------------------------
              fun(l)=fun(l)+((user(l*nmax+icont)*(x(1)**j1))*(x(2)**j2))&!hr04
     &*(x(3)**j3)                                                        !hr04
              fder(l,1)=fder(l,1)+(((user(l*nmax+icont)*real(j1,fPrec))*&
     &(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3)                             !hr04
                fder(l,2)=fder(l,2)+(((user(l*nmax+icont)*              &
     &real(j2,fPrec))*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3)             !hr04
                fder(l,3)=fder(l,3)+(((user(l*nmax+icont)*              &
     &real(j3,fPrec))*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1))             !hr04
   80         continue
   90       continue
  100     continue
  110   continue
!-----------------------------------------------------------------------
      else if(n.eq.4) then
!-----------------------------------------------------------------------
        do 160 l=0,iuser(3)
          icont=0
          do 150 jord=0,2
            do 140 j1=0,jord
              do 130 j2=0,jord-j1
                do 120 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                  kointer=j1+j2*3+j3*3**2+j4*3**3
                  icont=icont+1
!-----------------------------------------------------------------------
                  fun(l)=fun(l)+(((user(l*nmax+icont)*(x(1)**j1))       &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
          fder(l,1)=fder(l,1)+((((user(l*nmax+icont)*real(j1,fPrec))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3 )**j3))*(x(4)**j4)                  !hr04
            fder(l,2)=fder(l,2)+((((user(l*nmax+icont)*real(j2,fPrec))  &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3 )**j3))*(x(4)**j4)               !hr04
            fder(l,3)=fder(l,3)+((((user(l*nmax+icont)*real(j3,fPrec))  &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3 )**(j3-1)))*(x(4)**j4)               !hr04
            fder(l,4)=fder(l,4)+((((user(l*nmax+icont)*real(j4,fPrec))  &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3 )**j3))*(x(4)**(j4-1))               !hr04
  120           continue
  130         continue
  140       continue
  150     continue
  160   continue
!-----------------------------------------------------------------------
      else if(n.eq.5) then
!-----------------------------------------------------------------------
        do 220 l=0,iuser(3)
          icont=0
          do 210 jord=0,2
            do 200 j1=0,jord
              do 190 j2=0,jord-j1
                do 180 j3=0,jord-j1-j2
                  do 170 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4        !hr04
                    icont=icont+1
!-----------------------------------------------------------------------
                    fun(l)=fun(l)+((((user(l*nmax+icont)*(x(1)**j1))    &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
           fder(l,1)=fder(l,1)+(((((user(l*nmax+icont) *real(j1,fPrec)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
           fder(l,2)=fder(l,2)+(((((user(l*nmax+icont) *real(j2,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
           fder(l,3)=fder(l,3)+(((((user(l*nmax+icont) *real(j3,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
           fder(l,4)=fder(l,4)+(((((user(l*nmax+icont) *real(j4,fPrec)) &
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &
     &*(x(5)**j5)
           fder(l,5)=fder(l,5)+(((((user(l*nmax+icont) *real(j5,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)            &!hr04
     &**(j5-1))                                                          !hr04
  170             continue
  180           continue
  190         continue
  200       continue
  210     continue
  220   continue
!-----------------------------------------------------------------------
      else if(n.eq.6) then
!-----------------------------------------------------------------------
        do 290 l=0,iuser(3)
          icont=0
          do 280 jord=0,2
            do 270 j1=0,jord
              do 260 j2=0,jord-j1
                do 250 j3=0,jord-j1-j2
                  do 240 j4=0,jord-j1-j2-j3
                    do 230 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                 kointer=((((j1+j2*3)+j3*3**2)+j4*3**3)+j5*3**4)+j6*3**5
                      icont=icont+1
!-----------------------------------------------------------------------
                     fun(l)=fun(l)+(((((user(l*nmax+icont) *(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
          fder(l,1)=fder(l,1)+((((((user(l*nmax+icont) *real(j1,fPrec)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
          fder(l,2)=fder(l,2)+((((((user(l*nmax+icont) *real(j2,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
          fder(l,3)=fder(l,3)+((((((user(l*nmax+icont) *real(j3,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
          fder(l,4)=fder(l,4)+((((((user(l*nmax+icont) *real(j4,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &!hr04
     &*(x(5)**j5))*(x(6)**j6)                                            !hr04
          fder(l,5)=fder(l,5)+((((((user(l*nmax+icont) *real(j5,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x               &!hr04
     &(5)**(j5-1)))*(x(6)**j6)                                           !hr04
          fder(l,6)=fder(l,6)+((((((user(l*nmax+icont) *real(j6,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))                  &!hr04
     &*(x(5)**j5))*(x(6)**(j6-1))                                        !hr04
  230               continue
  240             continue
  250           continue
  260         continue
  270       continue
  280     continue
  290   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      if(iuser(2).eq.0) then
!-----------------------------------------------------------------------
        if(iuser(1).eq.1) then
!-----------------------------------------------------------------------
          objf=(((2.d0*fun(0)**2+fun(1)**2)+2.d0*fun(2)**2)+fun         &
     &(0)*fun(1))+fun(2)*fun(1)
!-----------------------------------------------------------------------
          do 300 jvar=1,n
          objgrd(jvar)=((4.d0*fun(0)+fun(1))*fder(0,jvar)+ ((2.d0*fun(1)&!hr04
     &+fun(0))+fun(2))*fder(1,jvar))+ (4.d0*fun(2)+fun(1))*fder         &!hr04
     &(2,jvar)                                                           !hr04
  300     continue
!-----------------------------------------------------------------------
        else
!-----------------------------------------------------------------------
          objf=(((((((27.d0*fun(3)**2+5.d0*fun(2)**2)+5.d0*fun(1)**2)+  &!hr04
     &27.d0*fun(0)**2)+                                                 &!hr04
     &9.d0*fun(3)*fun(2))+9.d0*fun(1)*fun(0))+6.d0*fun(2)*fun           &!hr04
     &(1))+3.d0*fun(3)*fun(1))+3.d0*fun(2)*fun(0)                        !hr04
!-----------------------------------------------------------------------
          do 310 jvar=1,n
        objgrd(jvar)=((((54.d0*fun(3)+9.d0*fun(2))+3.d0*fun(1)) *fder   &!hr04
     &(3,jvar) +(((10.d0*fun(2)+9.d0*fun(3))+6.d0*fun(1))+3.d0* fun(0)  &!hr04
     &)*fder(2,jvar))+(((10.d0*fun(1)+9.d0*fun(0))+6.d0*fun(2))+3.d0*   &!hr04
     &fun(3))*fder(1,jvar))+((54.d0*fun(0)+9.d0*fun(1))+3.d0*fun(2))    &!hr04
     &*fder(0,jvar)                                                      !hr04
  310     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
      else
!-----------------------------------------------------------------------
        objf=fun(0)**2+fun(1)**2                                         !hr04
        do 320 jvar=1,n
          objgrd(jvar)=(two*fun(0))*fder(0,jvar) +(two*fun(1))*fder     &!hr04
     &(1,jvar)                                                           !hr04
  320   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      return
      end
+dk cor_glo
      subroutine coruglo
!-----------------------------------------------------------------------
!---- PROGRAM FOR THE TUNESHIFT CORRECTIONS
!----
!----   =========>            CHROMATIC EFFECTS                <========
!----   =========>           GLOBAL MINIMIZATION               <========
!----
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none

      integer i,ifail,istate,iter,itype,iuser,iwork,j,jbound,jcol,      &
     &jcomp,jconf,jord,jrow,jsex,jvar,kcol,l,liwork,lwork,mcor,n,nclin, &
     &ncnln,ndim2,nout,nrowa,nrowj,nrowr
      real a,bl,bu,c,cjac,clamda,objf,objgrd,r,user,work
      real(kind=fPrec) ainv,bmat,chia,chib,cmat,cvec,delta,detinv,dvec, &
     &pi2in,sex,sgn,value
      external e04udm,objfun2
      parameter(mcor = 10)
      parameter(ndim2 = 6)
+ca commondl
+ca commadha
+ca commadh2
      dimension a(2,10),cjac(1,1),c(1)
      dimension r(10,10),bu(20),bl(20),clamda(20),objgrd(10)
      dimension ainv(2,2),bmat(2,10),cmat(2,10),cvec(2),dvec(2)
      dimension work(450),user(500),sex(10),sgn(10,10)
      dimension istate(20),iwork(40),iuser(2)
      data sgn/100*one/ainv,bmat,cmat,cvec,dvec/48*zero/
      save
!-----------------------------------------------------------------------
      pi2in=one/(eight*atan_mb(one))
!-----------------------------------------------------------------------
      do 30 i=0,4
        do 20 j=1,5
          do 10 l=0,8000
            hda(i,j,l)=zero
            if(i.le.1) hdp(i,j,l)=zero
   10     continue
   20   continue
   30 continue
!-----------------------------------------------------------------------
      do 40 j=1,10
        sgn(j,j)=-one
   40 continue
!-----------------------------------------------------------------------
!---- SPECIFIES THE I/O UNITS FOR THE NAG ROUTINES
!-----------------------------------------------------------------------
      nout=26
      call x04abf(1,nout)
!-----------------------------------------------------------------------
      jeltot=ncor
!-----------------------------------------------------------------------
      delta=dpmax
      nordm=nmom1
      nordp=nmom2
!-----------------------------------------------------------------------
      value=zero
!-----------------------------------------------------------------------
      itype=0
!-----------------------------------------------------------------------
      call readd2(user)
!-----------------------------------------------------------------------
!---- DEFINES THE MATRIX WITH THE LINEAR CONSTRAINTS
!-----------------------------------------------------------------------
      do 70 jrow=1,2
        do 50 jcol=1,jeltot
          a(jrow,jcol)=hdp(jrow-1,1,(nordp+1)**(jcol-1))
   50   continue
        do 60 jcol=1,jeltot-2
          bmat(jrow,jcol)=-one*a(jrow,jcol+2)                            !hr04
   60   continue
!-----------------------------------------------------------------------
        cvec(jrow)=-one*hdp(jrow-1,1,0)                                  !hr04
   70 continue
!-----------------------------------------------------------------------
!---- DEFINES THE RELATION BETWEEN THE FIRST TWO SEXTUPOLES AND THE
!---- OTHERS
!-----------------------------------------------------------------------
      detinv=one/(a(1,1)*a(2,2)-a(2,1)*a(1,2))
      ainv(1,1)=detinv*a(2,2)
      ainv(1,2)=(-one*detinv)*a(1,2)                                     !hr04
      ainv(2,1)=(-one*detinv)*a(2,1)                                     !hr04
      ainv(2,2)=detinv*a(1,1)
!-----------------------------------------------------------------------
      do 110 jrow=1,2
!-----------------------------------------------------------------------
        do 90 jcol=1,jeltot
          do 80 kcol=1,2
            cmat(jrow,jcol)=cmat(jrow,jcol)+ainv(jrow,kcol) *bmat       &
     &(kcol,jcol)
   80     continue
!-----------------------------------------------------------------------
   90   continue
        do 100 jcol=1,2
          dvec(jrow)=dvec(jrow)+ainv(jrow,jcol)*cvec(jcol)
  100   continue
  110 continue
!-----------------------------------------------------------------------
!---- WRITES ON THE EXIT FILE
!-----------------------------------------------------------------------
      write(lout,10000)
      write(lout,10010)
      write(lout,10020) jeltot,nordm,nordp,delta,weig1,weig2,value
      write(lout,10030)
!-----------------------------------------------------------------------
      do 210 jconf=1,jeltot-2
!-----------------------------------------------------------------------
!---- INITIALIZATION
!-----------------------------------------------------------------------
        iuser(1)=nordp
        iuser(2)=nordm
        user(1)=weig1
        user(2)=weig2
        user(3)=value
        user(4)=delta*c1e3
        user(5)=one/(user(4)**(2*nordm+1))
!-----------------------------------------------------------------------
!---- DEFINES EXTRA PARAMETERS
!-----------------------------------------------------------------------
        n=jeltot
        nclin=2
        ncnln=0
        nrowa=2
        nrowj=1
        nrowr=10
!-----------------------------------------------------------------------
        liwork=30
        lwork=450
!-----------------------------------------------------------------------
        do 120 jbound=1,n
          bu(jbound)=c1e2
          bl(jbound)=-c1e2
  120   continue
!-----------------------------------------------------------------------
        do 130 jbound=1,nclin
          bu(n+jbound)=-one*hdp(jbound-1,1,0)                            !hr04
          bl(n+jbound)=-one*hdp(jbound-1,1,0)                            !hr04
  130   continue
!-----------------------------------------------------------------------
        do 140 jvar=1,n
          x(jvar)=zero
  140   continue
!-----------------------------------------------------------------------
!---- DEFINES THE INITIAL GUESS SO THAT IT SATISFIES THE LINEAR
!---- CONSTRAINTS
!-----------------------------------------------------------------------
        do 160 jvar=1,2
          do 150 jcol=1,n-2
            x(jvar)=(x(jvar)+cmat(jvar,jcol)*sgn(jcol,jconf))+dvec(jvar) !hr04
            x(jcol+2)=sgn(jcol,jconf)
  150     continue
  160   continue
!-----------------------------------------------------------------------
        ifail=-1
!-----------------------------------------------------------------------
        call e04uef('MAJOR ITERATION LIMIT = 100')
!-----------------------------------------------------------------------
        call e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,e04udm,     &
     &objfun2,iter,istate,c,cjac,clamda,objf,objgrd,r,x,iwork,liwork,   &
     &work,lwork,iuser,user,ifail)
!-----------------------------------------------------------------------
        if(ifail.ne.0.and.ifail.ne.5) then
!-----------------------------------------------------------------------
          write(lout,10040) ifail
          call prror(-1)
        end if
!-----------------------------------------------------------------------
        do 170 jsex=1,jeltot
          sex(jsex)=x(jsex)
          write(lout,10050) coel(jsex),sex(jsex)
  170   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN DP/P AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 180 jord=1,nordp
!-----------------------------------------------------------------------
          iamp=0
!-----------------------------------------------------------------------
          call hamilton2(jord)
!-----------------------------------------------------------------------
!---- WRITES THE VALUES OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10060) jord
          write(lout,10070)
          write(lout,10080) hdp(1,jord,0),hdp(0,jord,0)
          write(lout,10090)
          write(lout,10080) hamp(1),hamp(0)
          write(lout,10100)
!-----------------------------------------------------------------------
  180   continue
!-----------------------------------------------------------------------
!---- COMPUTES THE NEW HAMILTONIAN IN AMP AFTER THE CORRECTIONS
!-----------------------------------------------------------------------
        do 200 jord=2,norda
!-----------------------------------------------------------------------
          iamp=1
!-----------------------------------------------------------------------
          call hamilton2(jord)
!-----------------------------------------------------------------------
!---- COMPUTES THE FUNCTION CHI
!-----------------------------------------------------------------------
          if(jord.eq.2) then
!-----------------------------------------------------------------------
         chib=(pi2in/sqrt(3.d0))*sqrt((((2.d0*hda(0,2,0)**2 +hda(1,2,0) &!hr04
     &**2)+2.d0*hda(2,2,0)**2)+hda(0,2,0) *hda(1,2,0))+hda(1,2,0)*hda   &!hr04
     &(2,2,0))                                                           !hr04
            chia=(pi2in/sqrt(3.d0))*sqrt((((2.d0*hama(0)**2+hama(1)**2) &
     &+2.d0*hama(2)**2)+hama(0)*hama(1))+hama(1)*hama(2))
!-----------------------------------------------------------------------
          else if(jord.eq.3) then
!-----------------------------------------------------------------------
            chib=(pi2in/sqrt(30.d0))*                                   &!hr04
     &sqrt((((((((27.d0*hda(3,3,0)**2 +5.d0*hda                         &!hr04
     &(2,3,0)**2)+5.d0*hda(1,3,0)**2)+27.d0*hda(0,3,0)**2)+9.d0*hda     &!hr04
     &(3,3,0)*hda(2,3,0))+9.d0*hda(1,3,0)*hda(0,3,0))+6.d0*hda          &!hr04
     &(2,3,0)* hda(1,3,0))+3.d0*hda(3,3,0)*hda(1,3,0))+3.d0*hda         &!hr04
     &(2,3,0)*hda(0,3,0))                                                !hr04
            chia=(pi2in/sqrt(30.d0))*                                   &!hr04
     &sqrt((((((((27.d0*hama(3)**2 +5.d0*hama(2)                        &!hr04
     &**2)+5.d0*hama(1)**2)+27.d0*hama(0)**2)+9.d0*hama(3)*hama(2))     &!hr04
     &+9.d0*hama(1)*hama(0))+6.d0*hama(2)*hama(1))+3.d0*hama(3)         &!hr04
     &*hama(1))+3.d0*hama(2)*hama(0))                                    !hr04
!-----------------------------------------------------------------------
          end if
!-----------------------------------------------------------------------
!---- WRITES THE VALUE OF THE HAMILTONIAN
!-----------------------------------------------------------------------
          write(lout,10110) jord
          write(lout,10120)
!-----------------------------------------------------------------------
          do 190 jcomp=0,jord
!-----------------------------------------------------------------------
            write(lout,10130) jcomp, jord-jcomp, hda(jcomp,jord,0), jcomp, jord-jcomp, hama(jcomp)
!-----------------------------------------------------------------------
  190     continue
          write(lout,10140) jord-1,chib,jord-1,chia
          write(lout,10100)
!-----------------------------------------------------------------------
  200   continue
!-----------------------------------------------------------------------
  210 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
10000 format(//80('-')//t10,29('O')/t10,2('O'),25x,2('O')/t10,          &
     &'OO  TUNE-SHIFT CORRECTION  OO', /t10,2('O'),25x,2('O')/t10,29('O'&
     &)//80('-')//)
10010 format(//t26,'*** GLOBAL CHROMATIC CORRECTIONS ***'//)
10020 format(t10,'NUMBER OF CORRECTOR ELEMENTS ',t48,i8/ t10,           &
     &'MINIMUM ORDER OF THE MINIMIZATION ',t48,i8/ t10,                 &
     &'MAXIMUM ORDER OF THE MINIMIZATION ',t48,i8/ t10,                 &
     &'MAXIMUM VALUE OF MOMENTUM DEVIATION ',t48,f9.3/ t10,             &
     &'WEIGHT HORIZONTAL TUNE ',t48,f9.3/ t10,'WEIGHT VERTICAL TUNE ',  &
     &t48,f9.3/ t10,'QUADRATIC COEFFICIENT IN DP/P',t48,f9.3)
10030 format(//,t10,'VALUES OF THE INTEGRATED GRADIENTS OF THE ',       &
     &'CORRECTOR MULTIPOLES',//,t10,'GLOBAL MOMENTUM CORRECTIONS')
10040 format(//,t10,' ERROR IN ROUTINE E04UCF. IFAIL = ',i8)
10050 format(//,t10,'CORRECTOR ELEMENT  - ',a16,' - ',4x,e20.14)
10060 format(///,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,      &
     &'MOMENTUM DEPENDENCE ')
10070 format(//,t10,'BEFORE CORRECTION ')
10080 format(//,'H_1,0    = ',2x,e16.8,7x,'H_0,1    = ', 2x,e16.8)
10090 format(//,t10,'AFTER CORRECTION ')
10100 format(//80('-'))
10110 format(///,t10,'HAMILTONIAN DEPENDENCE OF ORDER ' ,2x,i3,5x,      &
     &'AMPLITUDE DEPENDENCE',/)
10120 format(//,t10,'BEFORE CORRECTION ',20x,'AFTER CORRECTION ')
10130 format(//,t10,'H_',i1,',',i1,'    = ',e16.8,11x, 'H_',i1,',',i1,  &
     &'    = ',e16.8)
10140 format(//,t10,'CHI_',i1,',0  = ',e16.8,11x, 'CHI_',i1,',0  = ',e16&
     &.8)
      end
      subroutine readd2(user)
!-----------------------------------------------------------------------
!---- SUBROUTINE TO READ DATA
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer icont,ind,j,j1,j2,j3,j4,j5,j6,jcomp,jel,jord,jp,ncoef,njx,&
     &njx1,njz,njz1,nor,np,point,kointer
      real user
      real(kind=fPrec) cc
+ca commadha
+ca commadh2
      dimension ind(10),user(500)
+if crlibm
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      integer nofields
      parameter (nofields=20)
      character(len=nchars) fields(nofields)
      integer errno,nfields,nunit,lineno,maxf,nf
      real(kind=fPrec) fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      rewind 23
!-----------------------------------------------------------------------
! Unit 23 is opened round='nearest' if fio is selected
+if .not.crlibm
   10 read(23,*,end=40) ncoef,cc,nor,njx,njx1,njz,njz1,np,(ind(jel),jel &
     &=1,jeltot)
      read(23,*,end=40) cc
+ei
+if crlibm
   10 nunit=23
      read(23,*,end=40) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read (fields(1),*) ncoef
        nf=nf-1
      endif
      if (nf.gt.0) then
        cc=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(3),*) nor
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(4),*) njx
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(5),*) njx1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(6),*) njz
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(7),*) njz1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read (fields(8),*) np
        nf=nf-1
      endif
      do jel=1,jeltot
        if (nf.gt.0) then
          read (fields(8+jel),*) ind(jel)
          nf=nf-1
        endif
      enddo
      read(23,*,end=40) ch
      lineno=lineno+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,23,lineno,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cc=fround(errno,fields,1)
        nf=nf-1
      endif
+ei
!-----------------------------------------------------------------------
!---- CODING IND IN BASE NORDP+1
!-----------------------------------------------------------------------
      if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).eq.1.and. np.gt.0.and&
     &.np.le.nordp) then
        point=0
        do 20 j=1,jeltot
          point=point+ind(j)*(nordp+1)**(j-1)
   20   continue
        if(point.gt.8000) then
          write(lout,10000)
          call prror(-1)
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hdp(njx,np,point)=cc+hdp(njx,np,point)
!-----------------------------------------------------------------------
      else if(njx.eq.njx1.and.njz.eq.njz1.and.(njx+njz).lt.10.and. np   &
     &.eq.0) then
        point=0
        norda=njx+njz
        do 30 j=1,jeltot
          point=point+ind(j)*(nordp+1)**(j-1)
   30   continue
        if(point.gt.8000) then
          write(lout,10000)
          call prror(-1)
        end if
!-----------------------------------------------------------------------
!---- DATA PROCESSING
!-----------------------------------------------------------------------
        hda(njx,njx+njz,point)=cc+hda(njx,njx+njz,point)
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      goto 10
!-----------------------------------------------------------------------
!---- DEFINES DATA FOR THE ROUTINE OBJFUN
!-----------------------------------------------------------------------
   40 icont=5
!-----------------------------------------------------------------------
      if(jeltot.eq.1) then
!-----------------------------------------------------------------------
        do 70 jcomp=0,1
          do 60 jp=nordm,nordp
            do 50 jord=0,jp
              j1=jord
!-----------------------------------------------------------------------
              icont=icont+1
              kointer=j1
!-----------------------------------------------------------------------
              user(icont)=hdp(jcomp,jp,kointer)
   50       continue
   60     continue
   70   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
        do 110 jcomp=0,1
          do 100 jp=nordm,nordp
            do 90 jord=0,jp
              do 80 j1=0,jord
                j2=jord-j1
!-----------------------------------------------------------------------
                icont=icont+1
                kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
                user(icont)=hdp(jcomp,jp,kointer)
   80         continue
   90       continue
  100     continue
  110   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
        do 160 jcomp=0,1
          do 150 jp=nordm,nordp
            do 140 jord=0,jp
              do 130 j1=0,jord
                do 120 j2=0,jord-j1
                  j3=jord-j1-j2
!-----------------------------------------------------------------------
                  icont=icont+1
                  kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2              !hr04
!-----------------------------------------------------------------------
                  user(icont)=hdp(jcomp,jp,kointer)
  120           continue
  130         continue
  140       continue
  150     continue
  160   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
        do 220 jcomp=0,1
          do 210 jp=nordm,nordp
            do 200 jord=0,jp
              do 190 j1=0,jord
                do 180 j2=0,jord-j1
                  do 170 j3=0,jord-j1-j2
                    j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                    icont=icont+1
                    kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4      &!hr04
     &*(nordp+1)**3                                                      !hr04
!-----------------------------------------------------------------------
                    user(icont)=hdp(jcomp,jp,kointer)
  170             continue
  180           continue
  190         continue
  200       continue
  210     continue
  220   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
        do 290 jcomp=0,1
          do 280 jp=nordm,nordp
            do 270 jord=0,jp
              do 260 j1=0,jord
                do 250 j2=0,jord-j1
                  do 240 j3=0,jord-j1-j2
                    do 230 j4=0,jord-j1-j2-j3
                      j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                      icont=icont+1
                      kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4   &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                      user(icont)=hdp(jcomp,jp,kointer)
  230               continue
  240             continue
  250           continue
  260         continue
  270       continue
  280     continue
  290   continue
!-----------------------------------------------------------------------
      else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
        do 370 jcomp=0,1
          do 360 jp=nordm,nordp
            do 350 jord=0,jp
              do 340 j1=0,jord
                do 330 j2=0,jord-j1
                  do 320 j3=0,jord-j1-j2
                    do 310 j4=0,jord-j1-j2-j3
                      do 300 j5=0,jord-j1-j2-j3-j4
                        j6=jord-j1-j2-j3-j4-j6
!-----------------------------------------------------------------------
                        icont=icont+1
                        kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)   &!hr04
     &+j4*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                 !hr04
!-----------------------------------------------------------------------
                        user(icont)=hdp(jcomp,jp,kointer)
  300                 continue
  310               continue
  320             continue
  330           continue
  340         continue
  350       continue
  360     continue
  370   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(//,t10,' INDEX OUT OF BOUND IN ROUTINE READD ')
      end

      subroutine hamilton2(jp)
!-----------------------------------------------------------------------
!---- COMPUTES THE VALUE OF THE HAMILTONIAN AFTER CORRECTIONS
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none
      integer j,j1,j2,j3,j4,j5,j6,jel,jord,jp,l,kointer
      real(kind=fPrec) thama,thamp
+ca commadha
+ca commadh2
      dimension thamp(0:1),thama(0:4)
      save
!-----------------------------------------------------------------------
      if(iamp.eq.0) then
!-----------------------------------------------------------------------
        thamp(0)=zero
        thamp(1)=zero
!-----------------------------------------------------------------------
        if(jeltot.eq.1) then
!-----------------------------------------------------------------------
          do 20 jord=0,jp
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
!-----------------------------------------------------------------------
            do 10 l=0,1
              thamp(l)=thamp(l)+hdp(l,jp,kointer)*(x(1)**j1)
   10       continue
   20     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
          do 50 jord=0,jp
            do 40 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
              do 30 l=0,1
                thamp(l)=thamp(l)+hdp(l,jp,kointer)*(x(1)**j1)          &
     &*(x(2)**j2)
   30         continue
   40       continue
   50     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
          do 90 jord=0,jp
            do 80 j1=0,jord
              do 70 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2                !hr04
!-----------------------------------------------------------------------
                do 60 l=0,1
                  thamp(l)=thamp(l)+((hdp(l,jp,kointer)*(x(1)**j1))     &!hr04
     &*(x(2)**j2))*(x(3)**j3)                                            !hr04
   60           continue
   70         continue
   80       continue
   90     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
          do 140 jord=0,jp
            do 130 j1=0,jord
              do 120 j2=0,jord-j1
                do 110 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
               kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4*(nordp+1) &!hr04
     &**3                                                                !hr04
!-----------------------------------------------------------------------
                  do 100 l=0,1
                    thamp(l)=thamp(l)+(((hdp(l,jp,kointer)*(x(1)**j1))  &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
  100             continue
  110           continue
  120         continue
  130       continue
  140     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
          do 200 jord=0,jp
            do 190 j1=0,jord
              do 180 j2=0,jord-j1
                do 170 j3=0,jord-j1-j2
                  do 160 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4     &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                    do 150 l=0,1
                    thamp(l)=thamp(l)+((((hdp(l,jp,kointer)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
  150               continue
  160             continue
  170           continue
  180         continue
  190       continue
  200     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
          do 270 jord=0,jp
            do 260 j1=0,jord
              do 250 j2=0,jord-j1
                do 240 j3=0,jord-j1-j2
                  do 230 j4=0,jord-j1-j2-j3
                    do 220 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4  &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                    !hr04
!-----------------------------------------------------------------------
                      do 210 l=0,1
                   thamp(l)=thamp(l)+(((((hdp(l,jp,kointer)*(x(1)**j1)) &
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &
     &*(x(6)**j6)
  210                 continue
  220               continue
  230             continue
  240           continue
  250         continue
  260       continue
  270     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        do 280 jel=0,1
          hamp(jel)=thamp(jel)
  280   continue
!-----------------------------------------------------------------------
      else
!-----------------------------------------------------------------------
        do 290 j=0,4
          thama(j)=0.d0
  290   continue
!-----------------------------------------------------------------------
        if(jeltot.eq.1) then
!-----------------------------------------------------------------------
          do 310 jord=0,jp
            j1=jord
!-----------------------------------------------------------------------
            kointer=j1
!-----------------------------------------------------------------------
            do 300 l=0,jp
              thama(l)=thama(l)+hda(l,jp,kointer)*(x(1)**j1)
  300       continue
  310     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.2) then
!-----------------------------------------------------------------------
          do 340 jord=0,jp
            do 330 j1=0,jord
              j2=jord-j1
!-----------------------------------------------------------------------
              kointer=j1+j2*(nordp+1)
!-----------------------------------------------------------------------
              do 320 l=0,jp
                thama(l)=thama(l)+hda(l,jp,kointer)*(x(1)**j1)          &
     &*(x(2)**j2)
  320         continue
  330       continue
  340     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.3) then
!-----------------------------------------------------------------------
          do 380 jord=0,jp
            do 370 j1=0,jord
              do 360 j2=0,jord-j1
                j3=jord-j1-j2
!-----------------------------------------------------------------------
                kointer=(j1+j2*(nordp+1))+j3*(nordp+1)**2                !hr04
!-----------------------------------------------------------------------
                do 350 l=0,jp
                  thama(l)=thama(l)+((hda(l,jp,kointer)*(x(1)**j1))     &!hr04
     &*(x(2)**j2))*(x(3)**j3)                                            !hr04
  350           continue
  360         continue
  370       continue
  380     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.4) then
!-----------------------------------------------------------------------
          do 430 jord=0,jp
            do 420 j1=0,jord
              do 410 j2=0,jord-j1
                do 400 j3=0,jord-j1-j2
                  j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
               kointer=((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4*(nordp+1) &!hr04
     &**3                                                                !hr04
!-----------------------------------------------------------------------
                  do 390 l=0,jp
                    thama(l)=thama(l)+(((hda(l,jp,kointer)*(x(1)**j1))  &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
  390             continue
  400           continue
  410         continue
  420       continue
  430     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.5) then
!-----------------------------------------------------------------------
          do 490 jord=0,jp
            do 480 j1=0,jord
              do 470 j2=0,jord-j1
                do 460 j3=0,jord-j1-j2
                  do 450 j4=0,jord-j1-j2-j3
                    j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                    kointer=(((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4     &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4                                     !hr04
!-----------------------------------------------------------------------
                    do 440 l=0,jp
                    thama(l)=thama(l)+((((hda(l,jp,kointer)*(x(1)**j1)) &
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)
  440               continue
  450             continue
  460           continue
  470         continue
  480       continue
  490     continue
!-----------------------------------------------------------------------
        else if(jeltot.eq.6) then
!-----------------------------------------------------------------------
          do 560 jord=0,jp
            do 550 j1=0,jord
              do 540 j2=0,jord-j1
                do 530 j3=0,jord-j1-j2
                  do 520 j4=0,jord-j1-j2-j3
                    do 510 j5=0,jord-j1-j2-j3-j4
                      j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                      kointer=((((j1+j2*(nordp+1))+j3*(nordp+1)**2)+j4  &!hr04
     &*(nordp+1)**3)+j5*(nordp+1)**4)+j6*(nordp+1)**5                    !hr04
!-----------------------------------------------------------------------
                      do 500 l=0,jp
                   thama(l)=thama(l)+(((((hda(l,jp,kointer)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
  500                 continue
  510               continue
  520             continue
  530           continue
  540         continue
  550       continue
  560     continue
!-----------------------------------------------------------------------
        end if
!-----------------------------------------------------------------------
        do 570 jel=0,jp
          hama(jel)=thama(jel)
  570   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      return
!-----------------------------------------------------------------------
      end

      subroutine objfun2(mode,n,x,objf,objgrd,nstate,iuser,user)
!-----------------------------------------------------------------------
!---- ROUTINE TO COMPUTE THE VALUE OF THE FUNCTION AND OF ITS
!---- DERIVATIVES
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none
      integer icont,iuser,j1,j2,j3,j4,j5,j6,jel,jord,jp,jvar,kord,l,    &
     &mode,n,nstate,kointer
      real user
      real(kind=fPrec) add1,add2,fder,fun,objf,objgrd,sgn,tunedx,       &
     &tunedy,tunex,tuney,weight,x
      dimension x(10),objgrd(10),user(*),fun(0:1,10),fder(0:1,10,10)
      dimension iuser(*),tunedx(10),tunedy(10)
      save
!-----------------------------------------------------------------------
      do 30 jel=0,1
        do 20 jord=1,iuser(1)
          do 10 jvar=1,n
            fder(jel,jord,jvar)=0.d0
   10     continue
          fun(jel,jord)=0.d0
   20   continue
   30 continue
!-----------------------------------------------------------------------
      icont=5
!-----------------------------------------------------------------------
      if(n.eq.1) then
!-----------------------------------------------------------------------
        do 60 l=0,1
          do 50 jp=iuser(2),iuser(1)
            do 40 jord=0,jp
              j1=jord
!-----------------------------------------------------------------------
              kointer=j1
              icont=icont+1
!-----------------------------------------------------------------------
              fun(l,jp)=fun(l,jp)+user(icont)*(x(1)**j1)
        fder(l,jp,1)=fder(l,jp,1)+(user(icont)*real(j1,fPrec))*(x(1)    &!hr04
     &**(j1-1))                                                          !hr04
   40       continue
   50     continue
   60   continue
!-----------------------------------------------------------------------
      else if(n.eq.2) then
!-----------------------------------------------------------------------
        do 100 l=0,1
          do 90 jp=iuser(2),iuser(1)
            do 80 jord=0,jp
              do 70 j1=0,jord
                j2=jord-j1
!-----------------------------------------------------------------------
                kointer=j1+j2*(iuser(1)+1)
                icont=icont+1
!-----------------------------------------------------------------------
                fun(l,jp)=fun(l,jp)+(user(icont)*(x(1)**j1))*(x(2)**j2)  !hr04
          fder(l,jp,1)=fder(l,jp,1)+((user(icont)*real(j1,fPrec))*(x(1) &!hr04
     &**(j1-1)))*(x(2)**j2)                                              !hr04
          fder(l,jp,2)=fder(l,jp,2)+((user(icont)*real(j2,fPrec))       &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1))                                        !hr04
   70         continue
   80       continue
   90     continue
  100   continue
!-----------------------------------------------------------------------
      else if(n.eq.3) then
!-----------------------------------------------------------------------
        do 150 l=0,1
          do 140 jp=iuser(2),iuser(1)
            do 130 jord=0,jp
              do 120 j1=0,jord
                do 110 j2=0,jord-j1
                  j3=jord-j1-j2
!-----------------------------------------------------------------------
                  kointer=(j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2        !hr04
                  icont=icont+1
!-----------------------------------------------------------------------
               fun(l,jp)=fun(l,jp)+((user(icont)*(x(1)**j1))*(x(2)**j2))&!hr04
     &*(x(3)**j3)                                                        !hr04
            fder(l,jp,1)=fder(l,jp,1)+(((user(icont)*real(j1,fPrec))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3)                               !hr04
            fder(l,jp,2)=fder(l,jp,2)+(((user(icont)*real(j2,fPrec))    &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3)                            !hr04
            fder(l,jp,3)=fder(l,jp,3)+(((user(icont)*real(j3,fPrec))    &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1))                            !hr04
  110           continue
  120         continue
  130       continue
  140     continue
  150   continue
!-----------------------------------------------------------------------
      else if(n.eq.4) then
!-----------------------------------------------------------------------
        do 210 l=0,1
          do 200 jp=iuser(2),iuser(1)
            do 190 jord=0,jp
              do 180 j1=0,jord
                do 170 j2=0,jord-j1
                  do 160 j3=0,jord-j1-j2
                    j4=jord-j1-j2-j3
!-----------------------------------------------------------------------
                    kointer=((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2)+j4&!hr04
     &*(iuser(1)+1)**3                                                   !hr04
                    icont=icont+1
!-----------------------------------------------------------------------
                    fun(l,jp)=fun(l,jp)+(((user(icont)*(x(1)**j1))      &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                                !hr04
           fder(l,jp,1)=fder(l,jp,1)+((((user(icont)*real(j1,fPrec))*(x &!hr04
     &(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4)                   !hr04
              fder(l,jp,2)=fder(l,jp,2)+((((user(icont)*real(j2,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4)                !hr04
              fder(l,jp,3)=fder(l,jp,3)+((((user(icont)*real(j3,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4)                !hr04
              fder(l,jp,4)=fder(l,jp,4)+((((user(icont)*real(j4,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1))                !hr04
  160             continue
  170           continue
  180         continue
  190       continue
  200     continue
  210   continue
!-----------------------------------------------------------------------
      else if(n.eq.5) then
!-----------------------------------------------------------------------
        do 280 l=0,1
          do 270 jp=iuser(2),iuser(1)
            do 260 jord=0,jp
              do 250 j1=0,jord
                do 240 j2=0,jord-j1
                  do 230 j3=0,jord-j1-j2
                    do 220 j4=0,jord-j1-j2-j3
                      j5=jord-j1-j2-j3-j4
!-----------------------------------------------------------------------
                   kointer=(((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2)+j4&!hr04
     &*(iuser(1)+1)**3)+j5*(iuser(1)+1)**4                               !hr04
                      icont=icont+1
!-----------------------------------------------------------------------
                      fun(l,jp)=fun(l,jp)+((((user(icont)*(x(1)**j1))   &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5)                    !hr04
             fder(l,jp,1)=fder(l,jp,1)+(((((user(icont)*real(j1,fPrec)) &!hr04
     &*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
             fder(l,jp,2)=fder(l,jp,2)+(((((user(icont)*real(j2,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
             fder(l,jp,3)=fder(l,jp,3)+(((((user(icont)*real(j3,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))*(x(4)**j4))              &!hr04
     &*(x(5)**j5)                                                        !hr04
             fder(l,jp,4)=fder(l,jp,4)+(((((user(icont)*real(j4,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**(j4-1)))              &!hr04
     &*(x(5)**j5)                                                        !hr04
             fder(l,jp,5)=fder(l,jp,5)+(((((user(icont)*real(j5,fPrec)) &!hr04
     &*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x               &!hr04
     &(5)**(j5-1))                                                       !hr04
  220               continue
  230             continue
  240           continue
  250         continue
  260       continue
  270     continue
  280   continue
!-----------------------------------------------------------------------
      else if(n.eq.6) then
!-----------------------------------------------------------------------
        do 360 l=0,1
          do 350 jp=iuser(2),iuser(1)
            do 340 jord=0,jp
              do 330 j1=0,jord
                do 320 j2=0,jord-j1
                  do 310 j3=0,jord-j1-j2
                    do 300 j4=0,jord-j1-j2-j3
                      do 290 j5=0,jord-j1-j2-j3-j4
                        j6=jord-j1-j2-j3-j4-j5
!-----------------------------------------------------------------------
                    kointer=((((j1+j2*(iuser(1)+1))+j3*(iuser(1)+1)**2) &!hr04
     &+j4*(iuser(1)+1)**3) +j5*(iuser(1)+1)**4)+j6                      &!hr04
     &*(iuser(1)+1)**4                                                   !hr04
                        icont=icont+1
!-----------------------------------------------------------------------
                       fun(l,jp)=fun(l,jp)+(((((user(icont)*(x(1)**j1)) &!hr04
     &*(x(2)**j2))*(x(3)**j3))*(x(4)**j4))*(x(5)**j5))                  &!hr04
     &*(x(6)**j6)                                                        !hr04
                       fder(l,jp,1)=fder(l,jp,1)+((((((user(icont)*real &!hr04
     &(j1,fPrec))*(x(1)**(j1-1)))*(x(2)**j2))*(x(3)**j3))               &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)
                       fder(l,jp,2)=fder(l,jp,2)+((((((user(icont)*real &!hr04
     &(j2,fPrec))*(x(1)**j1))*(x(2)**(j2-1)))*(x(3)**j3))               &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)                                !hr04
                       fder(l,jp,3)=fder(l,jp,3)+((((((user(icont)*real &!hr04
     &(j3,fPrec))*(x(1)**j1))*(x(2)**j2))*(x(3)**(j3-1)))               &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**j6)                                !hr04
                       fder(l,jp,4)=fder(l,jp,4)+((((((user(icont)*real &!hr04
     &(j4,fPrec))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))*(x(4)             &!hr04
     &**(j4-1)))*(x(5)**j5))*(x(6)**j6)                                  !hr04
                       fder(l,jp,5)=fder(l,jp,5)+((((((user(icont)*real &!hr04
     &(j5,fPrec))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))                   &!hr04
     &*(x(4)**j4))*(x(5)**(j5-1)))*(x(6)**j6)                            !hr04
                       fder(l,jp,6)=fder(l,jp,6)+((((((user(icont)*real &!hr04
     &(j6,fPrec))*(x(1)**j1))*(x(2)**j2))*(x(3)**j3))                   &!hr04
     &*(x(4)**j4))*(x(5)**j5))*(x(6)**(j6-1))                            !hr04
  290                 continue
  300               continue
  310             continue
  320           continue
  330         continue
  340       continue
  350     continue
  360   continue
!-----------------------------------------------------------------------
      end if
!-----------------------------------------------------------------------
      tunex=zero
      tuney=zero
!-----------------------------------------------------------------------
      do 370 jvar=1,n
        tunedx(jvar)=zero
        tunedy(jvar)=zero
  370 continue
!-----------------------------------------------------------------------
      do 400 jord=iuser(2),iuser(1)
        do 390 kord=iuser(2),iuser(1)
          sgn=one
          if(((jord+kord)/2)*2.ne.(jord+kord)) sgn=-one
          add1=one/real((jord+kord)+1,fPrec)                             !hr04
          add2=user(3)/real((jord+kord)+3,fPrec)                         !hr04
          weight=((user(4)**((jord+kord)+1))*(one+sgn))*(add1+add2)*    &!hr04
     &user(5)                                                            !hr04
          tunex=tunex+(fun(0,jord)*fun(0,kord))*weight                   !hr04
          tuney=tuney+(fun(1,jord)*fun(1,kord))*weight                   !hr04
          do 380 jvar=1,n
            tunedx(jvar)=tunedx(jvar)+(fun(0,jord)*fder(0,kord, jvar))  &!hr04
     &*weight                                                            !hr04
            tunedy(jvar)=tunedy(jvar)+(fun(1,jord)*fder(1,kord, jvar))  &!hr04
     &*weight                                                            !hr04
  380     continue
  390   continue
  400 continue
!-----------------------------------------------------------------------
      objf=user(1)**2*tunex+user(2)**2*tuney                             !hr04
!-----------------------------------------------------------------------
      do 410 jvar=1,n
        objgrd(jvar)=(two*user(1)**2)*tunedx(jvar)+ (two*user(2)**2)    &
     &*tunedy(jvar)
  410 continue
!-----------------------------------------------------------------------
      return
      end
+dk errf
      subroutine errf(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! purpose:                                                             *
!   modification of wwerf, real(kind=fPrec) complex error function,    *
!   written at cern by k. koelbig.                                     *
!   taken from mad8                                                    *
! input:                                                               *
!   xx, yy    (real)    argument to cerf.                              *
! output:                                                              *
!   wx, wy    (real)    function result.                               *
!----------------------------------------------------------------------*
!---- real(kind=fPrec) version.
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none

      integer n,nc,nu
      real(kind=fPrec) cc,h,q,rx,ry,saux,sx,sy,tn,tx,ty,wx,wy,x,        &
     &xh,xl,xlim,xx,y,yh,ylim,yy
      parameter(cc = 1.12837916709551_fPrec)
      parameter(xlim = 5.33_fPrec)
      parameter(ylim = 4.29_fPrec)
      dimension rx(33),ry(33)
      save
!-----------------------------------------------------------------------
      x=abs(xx)
      y=abs(yy)
      if(y.lt.ylim.and.x.lt.xlim) then
        q=(one-y/ylim)*sqrt(one-(x/xlim)**2)
        h=one/(3.2_fPrec*q)
        nc=7+int(23.0_fPrec*q)                                               !hr05
!       xl=h**(1-nc)
        xl=exp_mb((1-nc)*log_mb(h))                                      !yil11
+if debug
!       call wda('errfq',q,nc,0,0,0)
!       call wda('errfh',h,nc,0,0,0)
!       call wda('errfxl',xl,nc,0,0,0)
+ei
+if debug
!       call wda('errfxlrn',xl,nc,0,0,0)
+ei
        xh=y+half/h
        yh=x
        nu=10+int(21.0_fPrec*q)
+if debug
!       call wda('errfxh',xh,nu,0,0,0)
!       call wda('errfyh',yh,nu,0,0,0)
+ei
        rx(nu+1)=zero
        ry(nu+1)=zero
        do 10 n=nu,1,-1
          tx=xh+real(n,fPrec)*rx(n+1)                                          !hr05
          ty=yh-real(n,fPrec)*ry(n+1)                                          !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(n)=(half*tx)/tn                                            !hr05
          ry(n)=(half*ty)/tn                                            !hr05
   10   continue
        sx=zero
        sy=zero
        do 20 n=nc,1,-1
          saux=sx+xl
          sx=rx(n)*saux-ry(n)*sy
          sy=rx(n)*sy+ry(n)*saux
          xl=h*xl
   20   continue
        wx=cc*sx
        wy=cc*sy
      else
        xh=y
        yh=x
        rx(1)=zero
        ry(1)=zero
        do 30 n=9,1,-1
          tx=xh+real(n,fPrec)*rx(1)                                            !hr05
          ty=yh-real(n,fPrec)*ry(1)                                            !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(1)=(half*tx)/tn                                            !hr05
          ry(1)=(half*ty)/tn                                            !hr05
   30   continue
        wx=cc*rx(1)
        wy=cc*ry(1)
      endif
!      if(y.eq.0.) wx=exp(-x**2)
      if(yy.lt.zero) then
        wx=(two*exp_mb(y**2-x**2))*cos_mb((two*x)*y)-wx                  !hr05
        wy=((-one*two)*exp_mb(y**2-x**2))*sin_mb((two*x)*y)-wy           !hr05
        if(xx.gt.zero) wy=-one*wy                                        !hr05
      else
        if(xx.lt.zero) wy=-one*wy
      endif
      end
      subroutine wzsubv(n,vx,vy,vu,vv)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!  Vectorised for up to 64 argument values by E.McIntosh, 30.10.1997.
!  Much impoved using short vector buffers Eric 1st May, 2014.
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
!  *********************************************************************
      use floatPrecision
      use numerical_constants
      implicit none

      dimension vx(*),vy(*),vu(*),vv(*)
      integer i,j,k,n,vmu,vnu
      real(kind=fPrec) a1,a2,b1,b2,vd12i,vd12r,vd23i,vd23r,             &
     &vd34i,vd34r,vp,vq,vqsq,vr,vsimag,vsreal,vt,vtdd13i,vtdd13r,       &
     &vtdd24i,vtdd24r,vtdddi,vtdddr,vti,vtr,vu,vusum,vusum3,vv,         &
     &vvsum,vvsum3,vw1i,vw1r,vw2i,vw2r,vw3i,vw3r,vw4i,vw4r,vx,          &
     &vxh,vxhrel,vy,vyh,vyhrel
      integer npart
+if .not.bignpart.and..not.hugenpart
      parameter(npart = 64)
+ei
+if bignpart.and..not.hugenpart
! See also +cd parpro
      parameter(npart = 2048)
+ei
+if hugenpart.and..not.bignpart
! See also +cd parpro
      parameter(npart = 65536)
+ei
      integer idim,kstep,nx,ny
      real(kind=fPrec) h,hrecip,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77_fPrec, ycut = 7.46_fPrec )
      parameter ( h = one/63.0_fPrec )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      parameter ( a1 = 0.5124242248_fPrec, a2 = 0.0517653588_fPrec )
      parameter ( b1 = 0.2752551286_fPrec, b2 = 2.7247448714_fPrec )
      real(kind=fPrec) xm,xx,yy
      parameter (xm=1e16_fPrec)
!     temporary arrays to facilitate vectorisation
      integer in,out,ins,outs
      dimension ins(npart),outs(npart)
!-----------------------------------------------------------------------
      save
      in=0
      out=0
      do i=1,n
        if (vx(i).ge.xcut.or.vy(i).ge.ycut) then
          out=out+1
          outs(out)=i
          if (out.eq.npart) then
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
            do j=1,out
              xx=vx(outs(j))
              yy=vy(outs(j))
              if (xx.ge.xm) xx=xm
              if (yy.ge.xm) yy=xm
              vp=xx**2-yy**2
              vq=(two*xx)*yy
              vqsq=vq**2
!  First term.
              vt=vp-b1
              vr=a1/(vt**2+vqsq)
              vsreal=vr*vt
              vsimag=-vr*vq                              
!  Second term
              vt=vp-b2
              vr=a2/(vt**2+vqsq)
              vsreal=vsreal+vr*vt
              vsimag=vsimag-vr*vq
!  Multiply by i*z.
              vu(outs(j))=-(yy*vsreal+xx*vsimag)
              vv(outs(j))=xx*vsreal-yy*vsimag
            enddo
            out=0
          endif
        else
          in=in+1
          ins(in)=i
          if (in.eq.npart) then
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
            do j=1,in
              vxh = hrecip*vx(ins(j))
              vyh = hrecip*vy(ins(j))
              vmu = int(vxh)
              vnu = int(vyh)
!  Compute divided differences.
              k = 2 + vmu + vnu*kstep
              vw4r = wtreal(k)
              vw4i = wtimag(k)
              k = k - 1
              vw3r = wtreal(k)
              vw3i = wtimag(k)
              vd34r = vw4r - vw3r
              vd34i = vw4i - vw3i
              k = k + kstep
              vw2r = wtreal(k)
              vw2i = wtimag(k)
              vd23r = vw2i - vw3i
              vd23i = vw3r - vw2r
              vtr = vd23r - vd34r
              vti = vd23i - vd34i
              vtdd24r = vti - vtr
              vtdd24i = -one* ( vtr + vti )                             !hr05
              k = k + 1
              vw1r = wtreal(k)
              vw1i = wtimag(k)
              vd12r = vw1r - vw2r
              vd12i = vw1i - vw2i
              vtr = vd12r - vd23r
              vti = vd12i - vd23i
              vtdd13r = vtr + vti
              vtdd13i = vti - vtr
              vtdddr = vtdd13i - vtdd24i
              vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
              vxhrel = vxh - real(vmu,fPrec)
              vyhrel = vyh - real(vnu,fPrec)
              vusum3=half*(vtdd13r+                                     &
     &       (vxhrel*vtdddr-vyhrel*vtdddi))
              vvsum3=half*(vtdd13i+                                     &
     &       (vxhrel*vtdddi+vyhrel*vtdddr))
              vyhrel = vyhrel - one
              vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
              vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
              vxhrel = vxhrel - one
              vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
              vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
            enddo
            in=0
          endif
        endif
      enddo
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
      do j=1,out
        xx=vx(outs(j))
        yy=vy(outs(j))
        if (xx.ge.xm) xx=xm
        if (yy.ge.xm) yy=xm
        vp=xx**2-yy**2
        vq=(two*xx)*yy
        vqsq=vq**2
!  First term.
        vt=vp-b1
        vr=a1/(vt**2+vqsq)
        vsreal=vr*vt
        vsimag=-vr*vq                              
!  Second term
        vt=vp-b2
        vr=a2/(vt**2+vqsq)
        vsreal=vsreal+vr*vt
        vsimag=vsimag-vr*vq
!  Multiply by i*z.
        vu(outs(j))=-(yy*vsreal+xx*vsimag)
        vv(outs(j))=xx*vsreal-yy*vsimag
      enddo
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
      do j=1,in
        vxh = hrecip*vx(ins(j))
        vyh = hrecip*vy(ins(j))
        vmu = int(vxh)
        vnu = int(vyh)
!  Compute divided differences.
        k = 2 + vmu + vnu*kstep
        vw4r = wtreal(k)
        vw4i = wtimag(k)
        k = k - 1
        vw3r = wtreal(k)
        vw3i = wtimag(k)
        vd34r = vw4r - vw3r
        vd34i = vw4i - vw3i
        k = k + kstep
        vw2r = wtreal(k)
        vw2i = wtimag(k)
        vd23r = vw2i - vw3i
        vd23i = vw3r - vw2r
        vtr = vd23r - vd34r
        vti = vd23i - vd34i
        vtdd24r = vti - vtr
        vtdd24i = -one* ( vtr + vti )                             !hr05
        k = k + 1
        vw1r = wtreal(k)
        vw1i = wtimag(k)
        vd12r = vw1r - vw2r
        vd12i = vw1i - vw2i
        vtr = vd12r - vd23r
        vti = vd12i - vd23i
        vtdd13r = vtr + vti
        vtdd13i = vti - vtr
        vtdddr = vtdd13i - vtdd24i
        vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
        vxhrel = vxh - real(vmu,fPrec)
        vyhrel = vyh - real(vnu,fPrec)
        vusum3=half*(vtdd13r+                                           &
     & (vxhrel*vtdddr-vyhrel*vtdddi))
        vvsum3=half*(vtdd13i+                                           &
     & (vxhrel*vtdddi+vyhrel*vtdddr))
        vyhrel = vyhrel - one
        vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
        vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
        vxhrel = vxhrel - one
        vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
        vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
      enddo
      return
      end
      subroutine wzsub(x,y,u,v)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!  *********************************************************************
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none
      integer k,mu,nu
      real(kind=fPrec) a1,a2,b1,b2,d12i,d12r,d23i,d23r,d34i,d34r,p,     &
     &q,qsq,r,simag,sreal,t,tdd13i,tdd13r,tdd24i,tdd24r,tdddi,tdddr,ti, &
     &tr,u,usum,usum3,v,vsum,vsum3,w1i,w1r,w2i,w2r,w3i,w3r,w4i,w4r,x,xh,&
     &xhrel,y,yh,yhrel
+ca parpro
+ca parbeam
      parameter ( a1 = 0.5124242248_fPrec, a2 = 0.0517653588_fPrec )
      parameter ( b1 = 0.2752551286_fPrec, b2 = 2.7247448714_fPrec )
      save
!-----------------------------------------------------------------------
      if ( x.ge.xcut .or. y.ge.ycut ) goto 1000
      xh = hrecip*x
      yh = hrecip*y
      mu = int(xh)
      nu = int(yh)
!  Compute divided differences.
      k = 2 + mu + nu*kstep
      w4r = wtreal(k)
      w4i = wtimag(k)
      k = k - 1
      w3r = wtreal(k)
      w3i = wtimag(k)
      d34r = w4r - w3r
      d34i = w4i - w3i
      k = k + kstep
      w2r = wtreal(k)
      w2i = wtimag(k)
      d23r = w2i - w3i
      d23i = w3r - w2r
      tr = d23r - d34r
      ti = d23i - d34i
      tdd24r = ti - tr
      tdd24i = -one* ( tr + ti )                                         !hr05
      k = k + 1
      w1r = wtreal(k)
      w1i = wtimag(k)
      d12r = w1r - w2r
      d12i = w1i - w2i
      tr = d12r - d23r
      ti = d12i - d23i
      tdd13r = tr + ti
      tdd13i = ti - tr
      tdddr = tdd13i - tdd24i
      tdddi = tdd24r - tdd13r
!  Evaluate polynomial.
      xhrel = xh - real(mu,fPrec)
      yhrel = yh - real(nu,fPrec)
      usum3 = half*( tdd13r + ( xhrel*tdddr - yhrel*tdddi ) )
      vsum3 = half*( tdd13i + ( xhrel*tdddi + yhrel*tdddr ) )
      yhrel = yhrel - one
      usum = d12r + ( xhrel*usum3 - yhrel*vsum3 )
      vsum = d12i + ( xhrel*vsum3 + yhrel*usum3 )
      xhrel = xhrel - one
      u = w1r + ( xhrel*usum - yhrel*vsum )
      v = w1i + ( xhrel*vsum + yhrel*usum )
      return
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
 1000 p=x**2-y**2
      q=(2.d0*x)*y                                                       !hr05
      qsq=q**2
!  First term.
      t=p-b1
      r=a1/(t**2+qsq)
      sreal=r*t
      simag=(-one*r)*q                                                   !hr05
!  Second term
      t=p-b2
      r=a2/(t**2+qsq)
      sreal=sreal+r*t
      simag=simag-r*q
!  Multiply by i*z.
      u=-one*(y*sreal+x*simag)                                           !hr05
      v=x*sreal-y*simag
      return
!
      end
+dk adia
      subroutine adia(numx,e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-INCREASE
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none
      integer numx
      real(kind=fPrec) e0f
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      if(numx.eq.1) phas0=phas
      if(numx.le.nde(1)) phas=zero
      if(numx.le.nde(1)) return
      if(numx.gt.nde(2)) phas=zero
      if(numx.gt.nde(2)) return
      phas=phas0
      e0=e0+hsy(1)*sin_mb(phas)
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
+dk adib
      subroutine adib(e0f)
!-----------------------------------------------------------------------
!  ADIABATIC ENERGY-DECREASE
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      implicit none
      real(kind=fPrec) e0f
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      if(abs(phas0).le.pieni) return
      e0=e0+hsy(1)*sin_mb(phas)
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      return
      end
+dk daten
      subroutine daten
!-----------------------------------------------------------------------
!  READS INPUT DATA FROM FILE FORT.3 AND/OR FORT.2
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use scatter, only : scatter_active, scatter_debug,                &
     &     scatter_seed1,scatter_seed2,                                 &
     &     scatter_dumpdata,                                            &
     &     scatter_parseELEM, scatter_parseProfile,                     &
     &     scatter_parseGenerator, scatter_parseSEED,                   &
     &     scatter_allocate

      use dynk, only : ldynk, ldynkdebug, ldynkfiledisable,             &
     &     dynk_parseFUN, dynk_parseSET, dynk_dumpdata,                 &
     &     dynk_inputsanitycheck, dynk_allocate

      use fma, only : fma_fname,fma_method,fma_numfiles,fma_norm_flag,  &
     &     fma_first,fma_last,fma_max,fma_flag,fma_writeNormDUMP,       &
     &     fma_parseInputLine

      use dump, only : dump_parseInputLine, dump_parseInputDone

      use zipf, only : zipf_parseInputDone, zipf_parseInputline
      
      use physical_constants
      use numerical_constants

+if fluka

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka

+ei

      use crcoall
      implicit none
      integer i,i1,i2,i3,ia,icc,ichrom0,iclr,ico,icy,idi,iexnum,iexread,&
     &ifiend16,ifiend8,ii,il1,ilin0,im,imo,imod,imtr0,irecuin,iw,iw0,ix,&
     &izu,j,j0,j1,j2,jj,k,k0,k10,k11,ka,ke,ki,kk,kpz,kzz,l,l1,l2,l3,l4, &
     &ll,m,mblozz,mout,mout1,mout3,mout4,nac,nbidu,ncy2,ndum,nfb,nft,   &
     &i4,i5
+if time
      integer ifiend35
      real(kind=fPrec) tcnst
+ei
      real(kind=fPrec) ak0d,akad,alc,alignx,alignz,                     &
     &ap11,ap22,ap33,ap44,apang,ofxx,ofzz,apxx,apzz,bk0d,bkad,          &
     &cosy,dummy,emitnx,emitny,extaux,halc,halc2,halc3,harm,phag,pmat,  &
     &qbet,qigam,r0,r0a,rdev,rmean,rsqsum,rsum,tilt,u0,                 &
     &xang,xstr,xpl0,xplane,xrms0,zpl0,zrms0
      !For BEAM-EXP
      real(kind=fPrec) separx,separy
      real(kind=fPrec) mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11
      
      character(len=16) sing,stru,prin,trac,diff,sync,ende,bloc,comm
      character(len=16) fluc,chro,tune,iter,limi,orbi,deco
      character(len=16) beze,bez0,go,comb,sear,subr
      character(len=16) free,geom,cavi,disp,reso,bezext
      character(len=16) idat,idat2,next,mult,line,init,ic0,imn,icel,irel
      character(len=16) iss,iqq,iele,ilm,ilm0,idum,corr,norm
      character(len=16) kl,kr,orga,post,ripp,beam,trom
      character(len=16) coll
      character(len=60) ihead
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      logical beam_xstr
+if crlibm
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,nf
      real(kind=fPrec) fround
+ei
+if .not.crlibm
      integer nunit
+ei
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/
+ca parpro
+ca commonex
+ca common
+ca commons
+ca commont1
+ca commondl
!
+if collimat
+ca collpara
+ca dbdaten
+ca dbpencil
+ca database
+ca dbcolcom
      logical has_coll
+ei
+if .not.collimat
      logical do_coll
+ei
!
+if bnlelens
+ca rhicelens
+ei
+ca comgetfields
+ca stringzerotrim
+ca elensparam
+ca wireparam
+ca parbeam_exp
+ca comApeInfo
+ca dbreaddis

      !Fluka related, might be best to lock to real64
      real(kind=fPrec) tmpamplfact, tmplen

      dimension icel(ncom,20),iss(2),iqq(5)
      dimension beze(nblo,nelb),ilm(nelb),ilm0(40),bez0(nele),ic0(10)
      dimension extaux(40),bezext(nblz)
      data sing,stru,prin,sync,ende,next,comm                           &
     &/'SING','STRU','PRIN','SYNC','ENDE','NEXT','COMM'/
      data fluc,mult,chro,iter,tune,line,trac,diff                      &
     &/'FLUC','MULT','CHRO','ITER','TUNE','LINE','TRAC','DIFF'/
      data limi,orbi,bloc,init,go,sear,subr,reso,disp,post,ripp,deco    &
     &/'LIMI','ORBI','BLOC','INIT','GO','SEAR','SUBR',                  &
     &'RESO','DISP','POST','RIPP','DECO'/
      data comb,free,geom,cavi,beam,trom                                &
     &/'COMB','FREE','GEOM','CAV','BEAM','TROM'/
      data idum,kl,kr,orga,norm,corr/' ','(',')','ORGA','NORM','CORR'/
      data coll /'COLL'/
!     - elens
      character(len=16) elens
      data elens /'ELEN'/
!     - wire
      character(len=16) wire
      data wire /'WIRE'/
!     - scatter
      character(len=16) scat
      data scat /'SCAT'/
!     - coupling:
      character(len=16) fluk
      data fluk /'FLUK'/
!     - read particle distribution for FLUKA:
      character(len=16) dist
      data dist /'DIST'/

+if crlibm
      real(kind=fPrec) round_near
+ei

      logical lapefound
      logical lerr1

      save
!-----------------------------------------------------------------------
      if(mmul.lt.10.or.mmul.gt.20) call prror(85)
      irecuin=0
      iss(1)=' '
      iss(2)=' '

      do i=1,5
        iqq(i)=' '
      end do

      do i=1,nele
        bez0(i)=' '
      end do

      do i=1,nblo
        do j=1,nelb
          beze(i,j)=' '
        end do
      end do

      do i=1,40
        ilm0(i)=' '
        extaux(i)=zero
      end do

      do i=1,10
        coel(i)=' '
      end do

      do i=1,ncom
        do j=1,20
          icel(i,j)=' '
        end do
      end do

      do i=1,10
        ic0(i)=' '
      end do

      do i=1,nelb
        ilm(i)=' '
      end do

      emitnx=zero
      emitny=zero
      ihead=' '
      sixtit=' '
      nbidu=0
      iclo6=0
      iclo6r=0
      iclr=0
      icy=0
      ncy=0
      ncy2=0
      ndum=0
      numl=1

!  Initialise new input parameters
      numlmax=1000000
      numlcp=0
      napx=0
      amp(1)=c1m3
      amp0=zero
      ird=0
      imc=0
      idial=0
      idz(1)=1
      idz(2)=1
      idfor=0
      irew=0
      nde(1)=0
      nde(2)=0
      nwr(1)=1
      nwr(2)=1
      nwr(3)=1
      nwr(4)=10000
      ntwin=1
      harm=one
      alc=c1m3
      phag=zero
      tlen=one
      pma=pmap
      ition=0
      dpscor=one
      sigcor=one
      iconv=0
      imad=0
      iskip=1
      cma1=one
      cma2=one
      qs=zero
      itra=0
      chi0=zero
      chid=zero
      rat=zero
      ipos=0
      iav=1
      iwg=1
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      ivox=1
      ivoz=1
      ires=1
      dres=one
      ifh=0
      dfft=one
      idis=0
      icow=0
      istw=0
      iffw=0
      nprint=1
      ndafi=1
      itco=500
      dma=c1m12
      dmap=c1m15
      itcro=10
      dech=c1m10
      de0=c1m9
      ded=c1m9
      dsi=c1m9
      dsm0=c1m10
      itqv=10
      dkq=c1m10
      dqq=c1m10
      ichrom=0
      iqmod=0
      im=0
      imtr0=0
      ilin=0
      nlin=0
      iout=0
      idp=0
      izu0=0
      mmac=1
      mcut=0
      mout=0
      mout1=0
      mout2=0
      mout3=0
      mout4=0
      kanf=1
      iclo=0
      isub=0
      irmod2=0
      iorg=0
      ise=0
      iskew=0
      preda=c1m38
+if .not.collimat
      do_coll = .false.
+ei
+if collimat
      has_coll = .false.
+ei
   90 read(3,10010,end=1530,iostat=ierro) idat,ihead
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 90
      if(idat.ne.free.and.idat.ne.geom) call prror(1)
      imod=1
! imod=1: free, definition of elements in fort.3
! imod=2: geom, definition of elements in fort.2
      if(idat.eq.geom) imod=2
      write(lout,10130)
      write(lout,10030)
      write(lout,10180) ihead
      sixtit(1:60)=ihead
      if(imod.eq.1) write(lout,10190)
      if(imod.eq.2) write(lout,10200)
      write(lout,10130)
      if(imod.eq.2) then
  100   read(2,10000,end=1520,iostat=ierro) idat
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(idat(1:1).eq.'/') goto 100
! single elements
        if(idat.eq.sing) goto 120
          write(lout,*) "idat = '"//idat//"'"
          call prror(15)
        endif
  110 read(3,10000,end=1530,iostat=ierro) idat
      if(ierro.gt.0) call prror(58)
      nunit=3
      lineno3=lineno3+1
      if(idat(1:1).eq.'/') goto 110
      if(idat.eq.sing) goto 120
      if(idat.eq.bloc) goto 190
      if(idat.eq.stru) goto 320
      if(idat.eq.prin) goto 550
      if(idat.eq.disp) goto 170
      if(idat.eq.tune) goto 600
      if(idat.eq.sync) goto 710
      if(idat.eq.iter) goto 940
      if(idat.eq.fluc) goto 790
      if(idat.eq.mult) goto 740
      if(idat.eq.chro) goto 560
      if(idat.eq.trac) goto 510
      if(idat.eq.diff) goto 520
      if(idat.eq.line) goto 660
      if(idat.eq.limi) goto 950
      if(idat.eq.orbi) goto 980
      if(idat.eq.init) goto 500
      if(idat.eq.comb) goto 1030
      if(idat.eq.subr) goto 1110
      if(idat.eq.reso) goto 1120
      if(idat.eq.sear) goto 1200
      if(idat.eq.orga) goto 880
      if(idat.eq.post) goto 1280
      if(idat.eq.ripp) goto 1290
      if(idat.eq.deco) goto 1320
      if(idat.eq.comm) goto 1390
      if(idat.eq.norm) goto 1400
      if(idat.eq.corr) goto 1410
      if(idat.eq.beam) goto 1600
      if(idat.eq.trom) goto 1700
!GRD
      if(idat.eq.coll) goto 1285
!GRD

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     brand new input blocks
!     always in main code
!     - coupling:
      if(idat.eq.fluk) goto 1800

!     - read particle distribution:
      if(idat.eq.dist) goto 1900

      if(idat.eq."DUMP") goto 2000 !Hard-coded name, as variable name "dump" conflicted with module name
      if(idat.eq."DYNK") goto 2200 !Hard-coded name, as variable name "dynk" conflicted with module name
      if(idat.eq."FMA")  goto 2300 !Hard-coded name, as variable name "fma" conflicted with module name
      if(idat.eq.elens) goto 2400
      if(idat.eq.wire)  goto 2500
      !Reserved:
      !DIST = 2600
      !HION = 2700
      if(idat.eq."ZIPF") goto 2800 !Hard-coded name, as variable name "zipf" conflicted with module name
      if(idat.eq.scat) goto 2900
      
      if(idat.eq.next) goto 110
      if(idat.eq.ende) goto 771
      write(lout,*) "idat = '"//idat//"'"
      call prror(15)
!-----------------------------------------------------------------------
!  DATENBLOCK SINGLE ELEMENTS
!  ELLEMENTLISTE
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  120 i=1
  130 if(imod.eq.1) then
  140   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 140
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  150   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 150
        if(ch(:4).eq.next) then
  160     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 160
          if(idat.ne.bloc) then
            write(lout,*) "idat = '"//idat//"'"
            call prror(15)
          endif
          goto 190
        endif
      endif
!      if(ch(17:17).ne." ") call prror(104)
      i2=0
      do i1=1,80
        if(ch(i1:i1).ne." ".and.i2.eq.0) then
          i2=i1
        elseif(i2.gt.0) then
          if(ch(i1:i1).eq." ") then
            if(i1-i2.gt.16) then
              call prror(104)
            else
              goto 165
            endif
          endif
        endif
      enddo
 165  if(i1.gt.72) call prror(104)
      call intepr(1,1,ch,ch1) ! read in single element
!     write (*,*) 'ch1:'//ch1//':'
+if fio
+if crlibm
      call enable_xp()
+ei
      ! read fort.2 (or fort.3), idat -> bez = single element name,
      ! kz = type of element,
      ! ed,ek,el = strength, random error on strenght, length (can be anything)
      ! bbbx,bbby,bbbs = beam-beam, beam-beam parameters (will be removed soon)
      read(ch1,*,round='nearest')                                       &
     & idat,kz(i),ed(i),ek(i),el(i),bbbx(i),bbby(i),bbbs(i)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
!     write (*,*) 'ERIC'
      ! read fort.2 (or fort.3), idat -> bez = single element name,
      ! kz = type of element,
      ! ed,ek,el = strength, random error on strenght, length (can be anything)
      ! bbbx,bbby,bbbs = beam-beam, beam-beam parameters (will be removed soon)
      read(ch1,*) idat,kz(i),ed(i),ek(i),el(i),bbbx(i),bbby(i),bbbs(i)
+ei
+if crlibm
!     write(*,*) 'eric'
      if (nunit.eq.2) then
        call splitfld(errno,nunit,lineno2,nofields,nf,ch1,fields) !fort.2 input
      elseif (nunit.eq.3) then
        call splitfld(errno,nunit,lineno3,nofields,nf,ch1,fields) !fort.3 input
      else
         write(lout,*) 'ERROR in DATEN: nunit NOT 2 nor 3!'
         write(lout,*) 'Almost certainly a bug.'
         call prror(-1)
      endif
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) kz(i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ed(i)=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ek(i)=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        el(i)=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbx(i)=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbby(i)=fround(errno,fields,7)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bbbs(i)=fround(errno,fields,8)
        nf=nf-1
      endif
+ei
+ei
      !Check that the name is unique
      do j=1,i-1! i = index of current line
         if ( bez(j).eq.idat ) then
            write(lout,*) "ERROR in DATEN:"
            write(lout,*) "Got multiple copies of element ", bez(j)
            call prror(-1)
         endif
      enddo

      if(kz(i).eq.25) then
        ed(i)=ed(i)/two
        ek(i)=ek(i)/two
      endif
!--CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
      if((kz(i).eq.4.or.kz(i).eq.5).and.abs(el(i)).gt.pieni)            &
     &ed(i)=-one*ed(i)                                                   !hr05
!--CAVITIES
      if(abs(kz(i)).eq.12) then
        if(abs(ed(i)).gt.pieni.and.abs(ek(i)).gt.pieni) then
          ncy2=ncy2+1
          itionc(i)=kz(i)/abs(kz(i))
          kp(i)=6
        endif
      endif
!----------------------------------------
! Handled by initialize_element subroutine:
!-----------------------------------------
!-- CHANGING SIGN OF CURVATURE OF VERTICAL THICK DIPOLE
!-- THIN LENS (+/- 1-10)
!-- MULTIPOLES (11)
!-- CAVITY (+/- 12)
!-- CRABCAVITY (23/-23) / CC multipoles order 2/3/4 (+/- 23/26/27/28)
!-- ELECTRON LENSE (29)
      call initialize_element(i,.true.)

!--ACDIPOLE
      if(abs(kz(i)).eq.16) then
        if(abs(ed(i)).le.pieni) then
           kz(i)=0
           ed(i)=zero                                                     !hr05
           ek(i)=zero                                                    !hr05
           el(i)=zero                                                    !hr05
        else
           acdipph(i)=el(i)
           el(i)=zero                                                    !hr05
        endif
      endif
!--General
      if(abs(el(i)).gt.pieni.and.kz(i).ne.0) ithick=1
      if(i.gt.nele-1) call prror(16)
      if(abs(kz(i)).ne.12 .or. (abs(kz(i)).eq.12.and.ncy2.eq.0) )kp(i)=0
! set element name
      bez(i)=idat
      bez0(i)=idat
      if(ncy2.eq.0) then
        !If no active RF cavities are seen so far in the single element list,
        ! add a CAV element to the end of the list.
        ! This is then overwritten when reading the next element, so that if
        ! and only if no active RF cavities are found, a CAV element can be
        ! used in the structure to enable 6D tracking using the parameters
        ! from the SYNC block.
        i=i+1
        il=i
        bez(i)=cavi
        bez0(i)=cavi
        kp(i)=6
      else
        il=i
        i=i+1
      endif
      goto 130
!-----------------------------------------------------------------------
!  DATENBLOCK DISPLACEMENT OF ELEMENTS
!-----------------------------------------------------------------------
  170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 170
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
      xpl0=zero
      xrms0=zero
      zpl0=zero
      zrms0=zero
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,xpl0,xrms0,zpl0,zrms0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,xpl0,xrms0,zpl0,zrms0
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        xpl0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        xrms0=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zpl0=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        zrms0=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
      do 180 j=1,il
        if(idat.ne.bez(j)) goto 180
        xpl(j)=xpl0
        xrms(j)=xrms0
        zpl(j)=zpl0
        zrms(j)=zrms0
!----Insertion for AC dipole
        if(abs(kz(j)).eq.16) then
          nturn1(j)=int(xpl0)
          nturn2(j)=int(xrms0)
          nturn3(j)=int(zpl0)
          nturn4(j)=int(zrms0)
          xpl(j)=zero
          xrms(j)=zero
          zpl(j)=zero
          zrms(j)=zero
          if(xrms0.eq.zero.and.zpl0.eq.zero.and.zrms0.eq.zero) then         !hr05
            write(lout,*) "ac dipole disregarded (0 length)"
            kz(j)=0
            ed(j)=zero                                                   !hr05
            ek(j)=zero                                                   !hr05
          endif
        endif
  180 continue
      goto 170
!-----------------------------------------------------------------------
!  BLOCK DEFINITIONS
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  190 if(imod.eq.1) then
  200   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 200
      endif
      if(imod.eq.2) then
  210   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 210
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) mper,(msym(k),k=1,mper)
      if(mper.gt.nper) call prror(17)
      i=0

  220 do m=1,40
        ilm0(m)=idum
      end do

      if(imod.eq.1) then
  240   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 240
        if(ch(:4).eq.next) goto 110
      else if(imod.eq.2) then
  250   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 250
        if(ch(:4).eq.next) then
  260     read(2,10000,end=1520,iostat=ierro) idat
          if(ierro.gt.0) call prror(57)
          nunit=2
          lineno2=lineno2+1
          if(idat(1:1).eq.'/') goto 260
          if(idat.ne.stru) then
            write(lout,*) "idat = '"//idat//"'"
            call prror(15)
          endif
          goto 320
        endif
      endif
      call intepr(2,1,ch,ch1)
! reading character strings so OK
      read(ch1,*) idat,(ilm0(m),m=1,40)
      if(idat.eq.idum) goto 270
      i=i+1 ! Current BLOC number
      if(i.gt.nblo-1) call prror(18)
      bezb(i)=idat
      k0=0
      mblo=i ! Update total number of BLOCs
  270 ka=k0+1
      ke=k0+40
      do 300 l=ka,ke
        if(l.gt.nelb) call prror(26)
        ilm(l)=ilm0(l-k0)
        if(ilm(l).eq.idum) goto 310
        mel(i)=l         ! Number of single elements in this block
        beze(i,l)=ilm(l) ! Name of the current single element
        do 280 j=1,il    ! Search for the single element idx j
          if(bez0(j).eq.ilm(l)) goto 290
  280   continue
        erbez=ilm(l)
        call prror(19)
  290   mtyp(i,l)=j ! Block i / sub-element l has single element index j
        if(kz(j).ne.8) elbe(i)=elbe(i)+el(j) ! Count block length (kz=8 -> edge focusing->skip!)
  300 continue
  310 k0=l-1
      goto 220

!-----------------------------------------------------------------------
!  STRUCTURE INPUT
!  imod = 1 if geometry in fort.3 (FREE), imod = 2 if in fort.2 (GEOM)
!-----------------------------------------------------------------------
  320 i=0

  330 do k=1,40
        ilm0(k)=idum
      end do

      if(imod.eq.1) then
  350   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        nunit=3
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 350
      endif
      if(imod.eq.2) then
  360   read(2,10020,end=1520,iostat=ierro) ch
        if(ierro.gt.0) call prror(57)
        nunit=2
        lineno2=lineno2+1
        if(ch(1:1).eq.'/') goto 360
      endif
      if(ch(:4).eq.next) goto 110
      i2=1
      ! Look for repetition with syntax N( ... )
      do 420 ii=1,80
        if(ch(ii:ii).eq.kl) then !kl='('
          if(ii.gt.1) then

            do jj=1,ii-1
              if(ch(jj:jj).ne.' ') goto 380
            end do

          endif
          iw=1
          goto 390
  380     read(ch(:ii-1),*) iw
  390     ia=i
          iw0=iw-1
          i2=ii+1
          goto 430
        endif
        if(ch(ii:ii).eq.kr) then !kr=')'
          if(iw0.le.0) goto 330
          idi=i-ia
          do 410 k=1,iw0
            do j=1,idi
              ic(i+j)=ic(i+j-idi)
            end do
            i=i+idi
  410     continue
          mbloz=i
          goto 330
        endif
  420 continue
      ! Create the structure
  430 call intepr(3,i2,ch,ch1)
! reading character strings so OK
      read(ch1,*) (ilm0(k),k=1,40)
      do 490 k=1,40
        if(ilm0(k).eq.idum) goto 490
        if(ilm0(k).eq.go) goto 480
        i=i+1
        do 440 j=1,mblo !is it a BLOC?
          if(bezb(j).eq.ilm0(k)) goto 470
  440   continue
        do 450 l=1,il   !is it a SINGLE ELEMENT?
          if(bez0(l).eq.ilm0(k)) goto 460
  450   continue
        ! It was neither BLOC or SINGLE ELEMENT! ERROR!
        erbez=ilm0(k)
        call prror(20)
        
        ! Handle SINGLE ELEMENT
  460   continue
        ic(i)=l+nblo
        if(bez0(l).eq.cavi) icy=icy+1
        goto 490

        !Handle BLOC
  470   ic(i)=j
        goto 490
        !Handle GO
  480   kanf=i+1
  490 continue
      mbloz=i
      if(mbloz.gt.nblz-2) call prror(21)
      goto 330
!-----------------------------------------------------------------------
!  INITIAL COORDINATES
!-----------------------------------------------------------------------
  500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then !iclr = line number in initial coordinate block
        iclr=iclr+1
      else
        goto 500
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      if(iclr.eq.1) then
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & itra,chi0,chid,rat,iver
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) itra,chi0,chid,rat,iver
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itra
          nf=nf-1
        endif
        if (nf.gt.0) then
          chi0=fround(errno,fields,2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          chid=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          rat=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
            read (fields(5),*) iver
            nf=nf-1
        endif
+ei
+ei
        if(itra.gt.2) call prror(40)
      endif
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & exz(1,1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) exz(1,1)
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & exz(1,2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) exz(1,2)
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & exz(1,3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.4) read(ch1,*) exz(1,3)
+ei
+if crlibm
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.5) read(ch1,*,round='nearest')                         &
     & exz(1,4)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.5) read(ch1,*) exz(1,4)
+ei
+if crlibm
      if(iclr.eq.5) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.6) read(ch1,*,round='nearest')                         &
     & exz(1,5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.6) read(ch1,*) exz(1,5)
+ei
+if crlibm
      if(iclr.eq.6) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.7) read(ch1,*,round='nearest')                         &
     & exz(1,6)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.7) read(ch1,*) exz(1,6)
+ei
+if crlibm
      if(iclr.eq.7) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(1,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.8) read(ch1,*,round='nearest')                         &
     & exz(2,1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.8) read(ch1,*) exz(2,1)
+ei
+if crlibm
      if(iclr.eq.8) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.9) read(ch1,*,round='nearest')                         &
     & exz(2,2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.9) read(ch1,*) exz(2,2)
+ei
+if crlibm
      if(iclr.eq.9) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.10) read(ch1,*,round='nearest')                        &
     & exz(2,3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.10) read(ch1,*) exz(2,3)
+ei
+if crlibm
      if(iclr.eq.10) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,3)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.11) read(ch1,*,round='nearest')                        &
     & exz(2,4)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.11) read(ch1,*) exz(2,4)
+ei
+if crlibm
      if(iclr.eq.11) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,4)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.12) read(ch1,*,round='nearest')                        &
     & exz(2,5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.12) read(ch1,*) exz(2,5)
+ei
+if crlibm
      if(iclr.eq.12) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,5)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.13) read(ch1,*,round='nearest')                        &
     & exz(2,6)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.13) read(ch1,*) exz(2,6)
+ei
+if crlibm
      if(iclr.eq.13) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          exz(2,6)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.14) read(ch1,*,round='nearest')                        &
     & e0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.14) read(ch1,*) e0
+ei
+if crlibm
      if(iclr.eq.14) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          e0=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.15) read(ch1,*,round='nearest')                        &
     & ej(1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.15) read(ch1,*) ej(1)
+ei
+if crlibm
      if(iclr.eq.15) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(1)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.16) read(ch1,*,round='nearest')                        &
     & ej(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.16) read(ch1,*) ej(2)
+ei
+if crlibm
      if(iclr.eq.16) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          ej(2)=fround(errno,fields,1)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.16) goto 500
      dp1=exz(1,6)
      iclr=0
      if(iver.ne.0.and.iver.ne.1) iver=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  TRACKING PARAMETERS
!-----------------------------------------------------------------------
  510 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
        iclr=iclr+1
      else
        goto 510
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
! Two new options for Turns to checkpoint and max turns/job.
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     &numl,numlr,napx,amp(1),amp0,ird,imc,niu(1),niu(2),numlcp,numlmax
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) then
        read(ch1,*)                                                     &
     &numl,numlr,napx,amp(1),amp0,ird,imc,niu(1),niu(2),numlcp,numlmax
      endif
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) numl
        nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) numlr
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) napx
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          amp0=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(6),*) ird
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) imc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) niu(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) niu(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(10),*) numlcp
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(11),*) numlmax
          nf=nf-1
        endif
      endif
+ei
+ei
      ! and default nnmul to numl
      nnuml=numl
      ! and numlcp to 1000
      if(numlcp.eq.0) numlcp=1000
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & idz(1),idz(2),idfor,irew,iclo6
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      if(iclr.eq.2) read(ch1,*) idz(1),idz(2),idfor,irew,iclo6
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & nde(1),nde(2),                                                   &
     &nwr(1),nwr(2),nwr(3),nwr(4),ntwin,ibidu,iexact
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      if(iclr.eq.3) read(ch1,*) nde(1),nde(2),                          &
     &nwr(1),nwr(2),nwr(3),nwr(4),ntwin,ibidu,iexact
+ei
      if(iclo6.eq.5.or.iclo6.eq.6) then
        iclo6=iclo6-4
        iclo6r=1
      endif
      if(iclo6.eq.2.and.idfor.eq.0) idfor=1
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(iclr.ne.3) goto 510
      iclr=0
      nbidu=1
      goto 110
!-----------------------------------------------------------------------
!  DIFFERENTIAL ALGEBRA
!-----------------------------------------------------------------------
  520 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 520
      ndum=ndum+1
      if(ch(:4).eq.next) then
        ndum=0
        goto 110
      endif
      if(ndum.eq.1) then
        ch1(:nchars+3)=ch(:nchars)//' / '
        idial=1
        numlr=0
        napx=1
        imc=1
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & nord,nvar,preda,nsix,ncor
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) nord,nvar,preda,nsix,ncor
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) nord
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(2),*) nvar
          nf=nf-1
        endif
        if (nf.gt.0) then
          preda=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(4),*) nsix
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(5),*) ncor
          nf=nf-1
        endif
+ei
+ei
        if(nvar.le.4) ition=0
        if(nord.le.0.or.nvar.le.0) call prror(91)
      else
        call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
        read(ch1,*) (ilm0(i),i=1,ncor)
      endif
      if(iclo6.eq.1.or.iclo6.eq.2) nsix=0
      if(nvar.ne.6) then
      nsix=0
      iclo6=0
      endif
      if(nvar.eq.5) then
        idp=1
        ition=1
        hsy(1)=zero
      endif
      if(ndum.eq.1) then
      if(nsix.ne.1) nsix=0
      if(nord.gt.nema) call prror(52)
      nvar2=nvar
      goto 520
      else
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
        do 540 j1=1,ncor
          do 530 j2=1,il
            if(ilm0(j1).eq.bez(j2)) then
              if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
              ipar(j1)=j2
              goto 540
            endif
  530     continue
          call prror(66)
  540   continue
      else
        ncor=0
        write(lout,*)' '
        write(lout,*)'NO EXTRA PARAMETERS FOR THE MAP SPECIFIED'
        write(lout,*)' '
      endif
      ndum=0
      nvar=nvar2+ncor
      goto 110
      endif
!-----------------------------------------------------------------------
!  PRINTOUT INPUT PARAMETERS
!-----------------------------------------------------------------------
  550 iout=1
      goto 110
!-----------------------------------------------------------------------
!  CHROMATCITY ADJUSTMENT
!-----------------------------------------------------------------------
  560 ichrom=1
      ichrom0=0
      do 580 l=1,2
  570 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 570
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.1) read(ch1,*,round='nearest')                            &
     & iss(1),cro(1),ichrom0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.1) read(ch1,*) iss(1),cro(1),ichrom0
+ei
+if crlibm
      if(l.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) iss(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(3),*) ichrom0
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iss(2),cro(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.2) read(ch1,*) iss(2),cro(2)
+ei
+if crlibm
      if (l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iss(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
  580 continue

      do j=1,il
        if(iss(1).eq.bez(j)) is(1)=j
        if(iss(2).eq.bez(j)) is(2)=j
      end do

      if(ichrom0.ge.1.and.ichrom0.le.3) ichrom=ichrom0
      goto 110

!-----------------------------------------------------------------------
!  TUNE ADJUSTMENT
!-----------------------------------------------------------------------
  600 iqmod=1
      do 630 l=1,3
  610 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 610
      if(ch(:4).eq.next) then
        if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni) then

          do j=1,il
            if(iqq(1).eq.bez(j)) iq(1)=j
            if(iqq(2).eq.bez(j)) iq(2)=j
          end do

          goto 110
        else
          write(lout,10370)
          iqmod=0
          iqmod6=0
          goto 110
        endif
      endif
      call intepr(1,1,ch,ch1)
      if(l.eq.1) then
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & iqq(1),qw0(1),iqmod6
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) iqq(1),qw0(1),iqmod6
+ei
+if crlibm
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) iqmod6
          nf=nf-1
        endif
+ei
+ei
        if(iqmod6.eq.1) then
          iqmod6=0
        elseif(iqmod6.eq.2) then
          iqmod6=1
          iqmod=0
        elseif(iqmod6.eq.3) then
          iqmod6=1
        endif
      endif
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iqq(2),qw0(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.2) read(ch1,*) iqq(2),qw0(2)
+ei
+if crlibm
      if(l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(l.eq.3) read(ch1,*,round='nearest')                            &
     & iqq(3),qw0(3)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(l.eq.3) read(ch1,*) iqq(3),qw0(3)
+ei
+if crlibm
      if(l.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(3)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(3)=fround(errno,fields,2)
        nf=nf-1
        endif
      endif
+ei
+ei
  630 continue
  640 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 640
      call intepr(4,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & iqq(4),iqq(5)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) iqq(4),iqq(5)
+ei
      if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni                  &
     &.and.abs(qw0(3)).gt.pieni) then
        do 650 j=1,il
          if(iqq(1).eq.bez(j)) iq(1)=j
          if(iqq(2).eq.bez(j)) iq(2)=j
          if(iqq(3).eq.bez(j)) iq(3)=j
          if(iqq(4).eq.bez(j)) kpa(j)=1
          if(iqq(5).eq.bez(j)) kpa(j)=2
 650    continue
        goto 110
      else
        write(lout,10370)
        iqmod=0
        iqmod6=0
        write(lout,*) 'TUNE ADJUSTED'
        goto 110
      endif
!-----------------------------------------------------------------------
!  LINEAR OPTICS CALCULATION
!  - in the 4D case (ilin=1) the subroutine linopt is called
!  - in the 6d case (ilin=2) the optics parameters are calculated and 
!    printed in the subroutine umlauda (calculated in the common block
!    umlalid)
!-----------------------------------------------------------------------
 660  continue
      ilin0=1
      read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 660
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,nt,ilin0,ntco,eui,euii
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,nt,ilin0,ntco,eui,euii
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nt
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ilin0
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(4),*) ntco
        nf=nf-1
      endif
      if (nf.gt.0) then
        eui=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        euii=fround(errno,fields,6)
        nf=nf-1
      endif
+ei
+ei
      iprint=0
      if(idat.ne.'BLOCK'.and.idat.ne.'ELEMENT') call prror(45)
      if(idat.eq.'BLOCK') iprint=1
      ilin=1
      if(ilin0.ge.1.and.ilin0.le.3) ilin=ilin0

  670 do m=1,40
        ilm0(m)=idum
      end do

  690 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 690
      if(ch(:4).eq.next) goto 110
      call intepr(2,1,ch,ch1)
! ilm0 are character strings, should be OK
      read(ch1,*) (ilm0(m),m=1,40)
      do 700 m=1,40
      if(ilm0(m).eq.idum) goto 700
      nlin=nlin+1
      if(nlin.gt.nele) call prror(81)
      bezl(nlin)=ilm0(m)
  700 continue
      goto 670

!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!-----------------------------------------------------------------------
  710 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 710
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & harm,alc,u0,phag,tlen,pma,ition,dppoff
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) read(ch1,*) harm,alc,u0,phag,tlen,pma,ition,dppoff
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          harm=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          alc=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          u0=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          phag=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          tlen=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          pma=real(fround(errno,fields,6),fPrec)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ition
          nf=nf-1
        endif
        if (nf.gt.0) then
          dppoff=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & dpscor,sigcor
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) dpscor,sigcor
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          dpscor=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          sigcor=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.2) goto 710
      iclr=0
      if(abs(pma-pmap).le.c1m1) pmat=pmap
      if(abs(pma-pmae).le.c1m1) pmat=pmae
      if(pmat.ne.pmap.and.pmat.ne.pmae) then
        write(lout,*)
        write(lout,*) 'Warning: Particle is neither proton nor electron'
        write(lout,*) 'pma:  ', pma
        write(lout,*) 'pmap: ', pmap
        write(lout,*)
      endif
      if(pma.lt.pieni) call prror(27)
      crad=(crade*pmae)/pma                                              !hr05
      if(abs(tlen).le.pieni) call prror(25)
      if(ncy2.eq.0) then
        ncy=icy*mper
        idp=1
        if(ncy.ne.0) goto 720
        idp=0
        write(lout,10130)
        write(lout,10340)
  720   phas=phag*rad
        if(ncy.ne.0) then
          hsy(1)=u0/real(ncy,fPrec)
        else
          hsy(1)=u0
        endif
        if(nvar.eq.5) then
          idp=1
          ition=1
          hsy(1)=zero
        endif
        halc=harm*alc
        halc2=harm/tlen
        hsy(3)=(two*pi)*halc2                                            !hr05
        cosy=cos_mb(phas)
        qigam=(pma**2/e0)/e0                                             !hr05
        qbet=one-qigam
        halc3=((((((-one*(qigam-alc))*real(ition,fPrec))*harm)*u0)/e0)  &
     &*cosy)/((two*pi)*qbet)                                             !hr05
        if(halc3.lt.zero) call prror(28)
        qs=sqrt(halc3)
      else
        idp=1
        ncy=0
        do 725 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(abs(kz(ix)).eq.12) ncy=ncy+1
          endif
  725   continue
        do 730 j=1,il
          if(abs(kz(j)).eq.12) then
            hsyc(j)=((two*pi)*ek(j))/tlen                                !hr05
            if(nvar.eq.5) then
              ition=1
              ed(j)=zero
            endif
          endif
  730   continue
      endif
      goto 110
!-----------------------------------------------------------------------
!  MULTIPOLE COEFFICIENTS  FOR KZ = 11
!-----------------------------------------------------------------------
  740 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 740
      ! Get first data line: name, R_0, \delta_0
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & imn,r0,benki
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) imn,r0,benki
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) imn
        nf=nf-1
      endif
      if (nf.gt.0) then
        r0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        benki=fround(errno,fields,3)
        nf=nf-1
      endif
+ei
+ei
      ! Renaming variables?
      i=1
      r0a=one
      im=im+1
      benkc(im)=benki
      r00(im)=r0
      ! Find single element which matches the name, set its
      ! irm from the MULT block counter im.
      do 750 j=1,il
      if(imn.eq.bez(j)) then
        irm(j)=im
        goto 760
      endif
  750 continue
  760 write(lout,10130)
      write(lout,10210) imn,r0,benki
      ! Read data lines: B_n rms-B_n A_n rms-A_n
  770 bk0d=zero
      bkad=zero
      ak0d=zero
      akad=zero
  780 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 780
      if(ch(:4).eq.next) goto 110
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & bk0d,bkad,ak0d,akad
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) bk0d,bkad,ak0d,akad
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        bk0d=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bkad=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ak0d=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        akad=fround(errno,fields,4)
        nf=nf-1
      endif
+ei
+ei
      ! Set nmu for the current single element (j)
      ! to the currently highest multipole seen (i)
      if(abs(bk0d).gt.pieni.or.abs(bkad).gt.pieni                       &
     &.or.abs(ak0d).gt.pieni.or.abs(akad).gt.pieni) nmu(j)=i
      write(lout,10220) i,bk0d,bkad,ak0d,akad
      bk0(im,i)=(benki*bk0d)/r0a                                         !hr05
      ak0(im,i)=(benki*ak0d)/r0a                                         !hr05
      bka(im,i)=(benki*bkad)/r0a                                         !hr05
      aka(im,i)=(benki*akad)/r0a                                         !hr05
      i=i+1
      r0a=r0a*r0
      if(i.gt.mmul+1) call prror(105)
      if(ch(:4).ne.next) goto 770 ! loop
      write(lout,10380)
      write (lout,*) 'BENKI done'
      goto 770
!-----------------------------------------------------------------------
!  FLUCTUATION RANDOM STARTING NUMBER
!-----------------------------------------------------------------------
  790 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 790
      ! Read izu0, mmac, mout, mcut
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & izu0, mmac, mout, mcut
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) izu0, mmac, mout, mcut
+ei
      mcut=iabs(mcut)
+if vvector
      if(mmac.gt.nmac) call prror(55)
+ei
      !Generate normal distributed random numbers into zfz
      call recuin(izu0,irecuin)
      call ranecu(zfz,nzfz,mcut)
      rsum=zero

      do i=1,nzfz
        rsum=rsum+zfz(i)
      end do

      rmean=rsum/real(nzfz,fPrec)                                              !hr05
      rsqsum=zero

      do i=1,nzfz
        rsqsum=rsqsum+(zfz(i)-rmean)**2                                    !hr05
      end do

      rdev=sqrt(rsqsum/real(nzfz,fPrec))                                       !hr05
      write(lout,10410) izu0,nzfz,rmean,rdev
      if(mcut.eq.0) write(lout,10430)
      if(mcut.gt.0) write(lout,10440) mcut
      write(lout,10130)
      ! Set flags mout1, mout2, mount3, mout4 depending on mout
      ! Enables/disables different functionality
      if(mout.ge.8) mout4=1
      if(mout.eq.7.or.mout.eq.15) then
        mout1=1
        mout2=1
        mout3=1
      else if(mout.eq.6.or.mout.eq.14) then
        mout2=1
        mout3=1
      else if(mout.eq.5.or.mout.eq.13) then
        mout1=1
        mout3=1
      else if(mout.eq.4.or.mout.eq.12) then
        mout3=1
      else if(mout.eq.3.or.mout.eq.11) then
        mout1=1
        mout2=1
      else if(mout.eq.2.or.mout.eq.10) then
        mout2=1
      else if(mout.eq.1.or.mout.eq.9) then
        mout1=1
      endif
      
      ! Reads from fort.16 IF mout1==1
      if(mout1.eq.1) then
        write(lout,*)
        write(lout,*) '          Multipole errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0 ! Reading regular multipoles(1) or skew components (2)
        ifiend16=0
        iexnum=0
        read(16,10020,end=861)
        rewind 16

        do 860 i=1,mper*mbloz ! Loop over all structure elements
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend16.eq.0) then
                read(16,10020,end=820,iostat=ierro) ch
                lineno16=lineno16+1
              else
                goto 820
              endif
              call intepr(3,1,ch,ch1) ! Read the name of element
! ilm0 are character strings, should be OK
              read(ch1,*) ilm0(1)
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
+if fio
+if crlibm
      call enable_xp()
+ei
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)

              
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
+ei
+if crlibm
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 840
  820         ifiend16=1
              if(iexnum.eq.0) call prror(80)
              do 830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
  830         continue
  840         continue
            endif ! closing if(iexread.eq.0) then
            if(ilm0(1).eq.bez(ix)) then
+if debug
!             call warr('ilm0(1)',0d0,1,i,0,0)
+ei
              icext(i)=ix
              do 850 k=1,40
                exterr(i,k)=extaux(k)
+if debug
!     call warr('extaux',extaux(k),i,k,0,0)
+ei
  850         continue
              iexread=0
              goto 860
            endif
          endif
  860   continue
  861   continue
        write(lout,*) '        From file fort.16 :',iexnum,             &
     &' values read in.'
        write(lout,*)
      endif
+if time
      if(mout1.eq.1) then
        write(lout,*)
        write(lout,*) '  Time-d  Multipole errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0
        ifiend35=0
        iexnum=0
        read(35,10020,end=1861)
        rewind 35
        do 1860 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend35.eq.0) then
                read(35,10020,end=1820,iostat=ierro) ch
                lineno35=lineno35+1
              else
                goto 1820
              endif
              call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),tcnst
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(ch1,*) ilm0(1),tcnst
+ei
+if crlibm
              call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tcnst=fround(errno,fields,2)
                nf=nf-1
              endif
+ei
+ei
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(1),&
     &extaux(2),                                                        &
     &extaux(3)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(4),&
     &extaux(5),                                                        &
     &extaux(6)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(7),&
     &extaux(8),                                                        &
     &extaux(9)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(10)&
     &,extaux(11),                                                      &
     &extaux(12)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(13)&
     &,extaux(14),                                                      &
     &extaux(15)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(16)&
     &,extaux(17),                                                      &
     &extaux(18)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(19)&
     &,extaux(20)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(21)&
     &,extaux(22),                                                      &
     &extaux(23)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(24)&
     &,extaux(25),                                                      &
     &extaux(26)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(27)&
     &,extaux(28),                                                      &
     &extaux(29)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(30)&
     &,extaux(31),                                                      &
     &extaux(32)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(33)&
     &,extaux(34),                                                      &
     &extaux(35)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(36)&
     &,extaux(37),                                                      &
     &extaux(38)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro,round='nearest') extaux(39)&
     &,extaux(40)
              lineno35=lineno35+1
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(35,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(19),extaux(20)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno35=lineno35+1
              read(35,*,end=870,iostat=ierro) extaux(39),extaux(40)
              lineno35=lineno35+1
+ei
+if crlibm
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(35,10020,end=870,iostat=ierro) ch
        lineno35=lineno35+1
        ch1(:nchars+3)=ch(:nchars)//' / '
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(35,10020,end=870,iostat=ierro) ch
      lineno35=lineno35+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
      if (nf.gt.0) then
          extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
          extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(35,10020,end=870,iostat=ierro) ch
        lineno35=lineno35+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(35,10020,end=870,iostat=ierro) ch
      lineno35=lineno35+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,35,lineno35,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 1840
 1820        ifiend35=1
              if(iexnum.eq.0) call prror(80)
              do 1830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
 1830        continue
 1840        continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icext35(i)=ix
                tcnst35(i)=tcnst
               do 1850 k=1,40
                exterr35(i,k)=extaux(k)
1850        continue
              iexread=0
              goto 1860
            endif
          endif
 1860  continue
 1861  continue
        write(lout,*) '        From file fort.35 :',iexnum,             &
     &' values read in.'
        write(lout,*)
      endif
+ei
      if(mout3.eq.1) then
        write(lout,*)
        write(lout,*) '          Alignment errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0
        ifiend8=0
        iexnum=0
        read(8,10020,end=1581)
        rewind 8
        do 1580 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(8,10020,end=1550,iostat=ierro) ch
                if(ierro.gt.0) call prror(86)
                lineno8=lineno8+1
              else
                goto 1550
              endif
              call intepr(1,1,ch,ch1)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),alignx,alignz,tilt
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
              read(ch1,*) ilm0(1),alignx,alignz,tilt
+ei
+if crlibm
              call splitfld(errno,8,lineno8,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignx=fround(errno,fields,2)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignz=fround(errno,fields,3)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tilt=fround(errno,fields,4)
                nf=nf-1
              endif
!             alignx=DBLE(SNGL(alignx))
!             alignz=DBLE(SNGL(alignz))
!             tilt=DBLE(SNGL(tilt))
!             call roundnulp(alignx,1024)
!             call roundnulp(alignz,1024)
!             call roundnulp(tilt,1024)
+ei
+ei
+if debug
!     call warr('ilm0(1)',0d0,1,0,0,0)
!     call warr('alignx',alignx,I,1,0,0)
!     call warr('alignz',alignz,I,2,0,0)
!     call warr('tilt',tilt,I,3,0,0)
+ei
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1570
 1550         ifiend8=1
              if(iexnum.eq.0) call prror(86)
              do 1560 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(86)
 1560         continue
 1570         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1580
            endif
          endif
 1580   continue
 1581   continue
        write(lout,*) '        From file fort.8 :',iexnum,              &
     &' values read in.'
        write(lout,*)
      endif
      izu=0
      iexnum=0
      if(mout4.eq.1) then
        read(30,10020,end=1591)
        rewind 30
        do 1590 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 1590
            if(kzz.eq.15) goto 1590
            izu=izu+3
            read(30,10020,end=1591,iostat=ierro) ch
            if(ierro.gt.0) call prror(87)
            lineno30=lineno30+1
            call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
            read(ch1,*,round='nearest')                                 &
     & ilm0(1),zfz(izu-2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
            read(ch1,*) ilm0(1),zfz(izu-2)
+ei
            iexnum=iexnum+1
            if(kz(ix).eq.11) izu=izu+2*mmul
          endif
 1590   continue
        if(iexnum.gt.0) then
          write(lout,*)
          write(lout,*)'          Single (random) kick errors read in ',&
     &'from external file'
          write(lout,*)
          write(lout,*) '        From file fort.30 :',iexnum,           &
     &' values read in.'
          write(lout,*)
        endif
        iexread=0
        ifiend8=0
        iexnum=0
        rewind 30
        do 1593 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
 1595         ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(30,10020,end=1594,iostat=ierro) ch
                if(ierro.gt.0) call prror(87)
                lineno30=lineno30+1
              else
                goto 1594
              endif
              call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
              read(ch1,*,round='nearest')                               &
     & ilm0(1),dummy,alignx,alignz,tilt
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
              read(ch1,*) ilm0(1),dummy,alignx,alignz,tilt
+ei
              if(((abs(alignx)+abs(alignz))+abs(tilt)).le.pieni)        &!hr05
     &goto 1595
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1596
 1594         ifiend8=1
              do 1597 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(87)
 1597         continue
 1596         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1593
            endif
          endif
 1593   continue
 1591   continue
      endif
      goto 110
  870 call prror(80)

!-----------------------------------------------------------------------
!  ORGANISATION OF RANDOM NUMBERS
!-----------------------------------------------------------------------
  880 write(lout,10130)
      write(lout,10350)

      do i=1,3
        do j=1,nele
          bezr(i,j)=idum !Initialize all bezr to idum=' '
        end do
      end do
      
  900 iorg=iorg+1
  910 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 910
      if(ch(:4).eq.next) goto 110
      call intepr(3,1,ch,ch1)
      ! bezr are character strings, should be OK
      read(ch1,*) idat,bezr(2,iorg),bezr(3,iorg)
      if(idat.ne.next) then !Isn't this already checked for above?
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).eq.idum)     &
     &        write(lout,10360) idat
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).ne.idum)     &
     &        write(lout,10390) idat,bezr(2,iorg)
         if(idat.ne.mult)                                               &
     &        bezr(1,iorg)=idat
         if(idat.eq.mult.and.                                           &
     &        bezr(2,iorg).ne.idum.and.bezr(3,iorg).ne.idum) then
            write(lout,10400) bezr(2,iorg),bezr(3,iorg)
            im=im+1
            j0=0
            j1=0

            do i=1,il
               if(bez(i).eq.bezr(2,iorg)) j1=i
               if(bez(i).eq.bezr(3,iorg)) j0=i
            end do

            if(j0.eq.0.or.j1.eq.0.or.kz(j0).ne.11.or.kz(j1).ne.11)      &
     &              call prror(29)

            irm(j0)=im
            benkc(j0)=benkc(j1)
            r00(j0)=r00(j1)
            imo=irm(j1)
            nmu(j0)=nmu(j1)

            do i1=1,nmu(j0)
               bk0(im,i1)=bk0(imo,i1)
               bka(im,i1)=bka(imo,i1)
               ak0(im,i1)=ak0(imo,i1)
               aka(im,i1)=aka(imo,i1)
            end do

         endif
         goto 900
      endif
      write(lout,10130)
      goto 110
!-----------------------------------------------------------------------
!  ITERATION ERRORS FOR CLOSED ORBIT ,TUNE ADJUSTMENT AND CHROMATICITY
!-----------------------------------------------------------------------
  940 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 940
      endif
      if(ch(:4).eq.next) then
      iclr=0
      goto 110
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & itco,dma,dmap
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.1) read(ch1,*) itco,dma,dmap
+ei
+if crlibm
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itco
        endif
        if (nf.gt.0) then
          dma=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dmap=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & itqv,dkq,dqq
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) itqv,dkq,dqq
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itqv
          nf=nf-1
        endif
        if (nf.gt.0) then
          dkq=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dqq=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & itcro,dsm0,dech
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) itcro,dsm0,dech
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itcro
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsm0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dech=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
+ei
+ei
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & de0,ded,dsi,aper(1),aper(2)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(iclr.eq.4) read(ch1,*) de0,ded,dsi,aper(1),aper(2)
+ei
+if crlibm
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          de0=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          ded=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsi=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(2)=fround(errno,fields,5)
          nf=nf-1
        endif
      endif
+ei
+ei
      if(iclr.ne.4) goto 940
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  APERTURE LIMITATIONS
!  A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!  last modified: 14-01-2015
!  original LIMI block extended to deal with RectEllipse, Octagon and
!     RaceTrack aperture types, and with offset/tilting of profile
!  Possibility to read the apertures from external file with LOAD keyword
!-----------------------------------------------------------------------
  950 continue
      loadunit = 3
  951 continue
      read(loadunit,10020,end=952,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 951

!  P.G.Ortega, 14-01-2015, reading apertures from external file
      if(ch(:4).eq.'LOAD') then
        call intepr(5,1,ch,ch1)
        read(ch1,*) idat, loadunit, load_file
        inquire( file=load_file, exist=lexist )
        if ( .not. lexist ) then
            write(lout,*) "APERTURE LOAD FILE ",load_file," NOT FOUND ",&
     &      "IN THE RUNNING FOLDER"
            call prror(-1)
        endif
        if(load_file .ne. ' ') then
           open(loadunit,file=load_file,form='formatted') 
           write(lout,*) 'APERTURES READ FROM FILE: ',load_file
        else
           open(loadunit,form='formatted')
           write(lout,*) 'APERTURES READ FROM FILE: fort.',loadunit
        endif
        goto 951
      endif

!  P.G.Ortega,  04-07-2014, flag for dumping the aperture model
      if(ch(:4).eq.prin) then
        call intepr(5,1,ch,ch1)
        read(ch1,*) idat, aperunit, aper_filename
        ldmpaper  = .true.
        goto 951
      endif

!  P.G.Ortega,  14-08-2014, flag for saving particles at aperture check
      if(ch(:4).eq.'SAVE') then
        apflag  = .true.
        goto 951
      endif

      if(ch(:4).eq.next) then
        if ( limifound ) then
          write(lout,10320)
!         dump all elements found:
          do ii=1,il
            if( kape(ii).eq.1 ) then
              irel=circ
            else if( kape(ii).eq.2 ) then
              irel=rect
            else if( kape(ii).eq.3 ) then
              irel=elli
            else if( kape(ii).eq.4 ) then
              irel=reel
            else if( kape(ii).eq.5 ) then
              irel=octa
            else if( kape(ii).eq.6 ) then
              irel=ratr
            end if

            if ( kape(ii) .ne. 0 ) then
              write(lout,10330)                                         &
     &           bez(ii), irel, ape(1,ii), ape(2,ii), ape(3,ii),        &
     &               ape(4,ii), ape(5,ii), ape(6,ii), ape(7,ii)
            endif
          enddo
+if backtrk
!         A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!         last modified: 12-06-2014
!         echo precision for back-tracking, when computing locations of lost
!            particles
!         inserted in main code by the 'backtrk' compilation flag
          write(lout,*)''
          write(lout,*)'       back-tracking at aperture LIMIs is on'
          write(lout,*)'            with precision [m]:',bktpre
          write(lout,*)''
+ei
        else
          write(lout,                                                   &
     &        '(t10,"NO SINGLE ELEMENT IS ASSIGNED AN APETURE MODEL!")')
        endif
        goto 110
      endif
      ap11=zero
      ap22=zero
      ap33=zero
      ap44=zero
      apang=zero
      ofxx=zero
      ofzz=zero

+if .not.backtrk
      if(ch(:4).eq.'PREC') then
        write(lout,*)
        write(lout,*) 'WARNING: PREC statement active only in case'
        write(lout,*) '  backtrc pre-processing is on; ignoring...'
        write(lout,*)
        goto 951
      endif
+ei
+if backtrk
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 12-06-2014
!     set precision for back-tracking, when computing locations of lost
!         particles
!     inserted in main code by the 'backtrk' compilation flag
      if(ch(:4).eq.'PREC') then
        call intepr(1,1,ch,ch1)
        read(ch1,*) idat, tmplen
        if ( tmplen.le.zero ) then
          write(lout,*) 'WARNING: Wrong precision value: ', tmplen
          write(lout,*) '  in LIMI input block, ignoring...'
          write(lout,*) '  Using default [m]: ', bktpre
        else
           bktpre = tmplen
        endif
        goto 951
      endif
+ei
      call intepr(8,1,ch,ch1)
+if fio
+if crlibm 
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,irel,ap11,ap22,ap33,ap44,apang,ofxx,ofzz
+ei

+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,irel,ap11,ap22,ap33,ap44,apang,ofxx,ofzz
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) irel
        nf=nf-1
      endif
      if (nf.gt.0) then
        ap11=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ap22=fround(errno,fields,4)
          nf=nf-1
      endif
      if (nf.gt.0) then
        ap33=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ap44=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        apang=fround(errno,fields,7)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ofxx=fround(errno,fields,8)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ofzz=fround(errno,fields,9)
        nf=nf-1
      endif

+ei
+ei
      lapefound=.false.
      do 970 j=1,il
      if(idat.ne.bez(j)) goto 970
      lapefound=.true.
      ape(1,j)=ap11
      ape(2,j)=ap22
      ape(3,j)=ap33
      ape(4,j)=ap44
      ape(5,j)=apang
      ape(6,j)=ofxx
      ape(7,j)=ofzz
      if(irel.eq.circ) then !Circle
        kape(j)=1
      else if(irel.eq.rect) then !Rectangle
        kape(j)=2
!       get ready for a RL-equinvalent description
        ape(3,j)=sqrt(two)*ape(1,j)
        ape(4,j)=sqrt(two)*ape(2,j)
      else if(irel.eq.elli) then !Ellipse
        kape(j)=3
!       get ready for a RL-equinvalent description
        ape(3,j)=ape(1,j)
        ape(4,j)=ape(2,j)
      else if(irel.eq.reel) then !Rectellipse
        kape(j)=4
      else if(irel.eq.octa) then !Octagon  
        kape(j)=5
      else if(irel.eq.ratr) then !Racetrack
        kape(j)=6
      else
        write(lout,*) 'Aperture profile not identified for element ',   &
     &idat
        write(lout,*) '  value:', irel
        call prror(-1)
      endif
      if (ape(5,j).ne.zero.or.ape(6,j).ne.zero.or.ape(7,j).ne.zero) then
         lapeofftlt(j) = .true.
      endif
      limifound=.true.
  970 continue

      if(.not. lapefound) then
        write(lout,*)
        write(lout,*) 'WARNING: Unidentified element ', idat
        write(lout,*) '  in LIMI input block, ignoring...'
        write(lout,*)
      endif
      goto 951
  952 continue
      if ( loadunit .ne. 3 ) then
        close(loadunit)
        goto 950
      endif
      goto 1530

!-----------------------------------------------------------------------
!  ORBIT CORRECTION
!-----------------------------------------------------------------------
  980 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 980
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & sigma0,ncorru,ncorrep
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) sigma0,ncorru,ncorrep
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        sigma0(1)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sigma0(2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) ncorru 
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ncorrep
        nf=nf-1
      endif
+ei
+ei
      iclo=1
  990 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 990
      iele=idum
      call intepr(4,1,ch,ch1)
! integers so should be OK
      read(ch1,*) idat,iele
      if(idat.eq.next) goto 110
      if(idat.ne.'HMON='.and.idat.ne.'HCOR='.and. idat.ne.'VMON='.and.  &
     &idat.ne.'VCOR=') call prror(44)
      if(idat.eq.'HMON='.or.idat.eq.'VMON=') goto 1010
      do 1000 j=1,il
      if(iele.ne.bez(j)) goto 1000
      if(idat.eq.'HCOR=') then
        if(kp(j).eq.-4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.1.and.kz(j).ne.11) call prror(82)
        kp(j)=4
      endif
      if(idat.eq.'VCOR=') then
        if(kp(j).eq.4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.-1.and.kz(j).ne.11) call prror(82)
        kp(j)=-4
      endif
 1000 continue
      goto 990
 1010 do 1020 j=1,il
      if(iele.ne.bez(j)) goto 1020
      if(idat.eq.'HMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.-3) call prror(83)
        kp(j)=3
      endif
      if(idat.eq.'VMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.3) call prror(83)
        kp(j)=-3
      endif
 1020 continue
      goto 990

!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
 1030 ii=0

      do jj=1,ncom
        do ll=1,20
          icel(jj,ll)=idum
        end do
      end do 

      write(lout,10130)
      write(lout,10300)
 1050 ii=ii+1
      if(ii.gt.ncom) goto 1100
 1060 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1060
      if(ch(:4).eq.next) goto 110
      icoe=ii
      call intepr(5,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & idat,(ratio(ii,l),icel(ii,l),l=1,20)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) idat,(ratio(ii,l),icel(ii,l),l=1,20)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif

      do l=1,20
        if (nf.gt.0) then
          ratio(ii,l)=fround(errno,fields,l*2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(l*2+1),*) icel(ii,l)
          nf=nf-1
        endif
      end do
+ei
+ei
      do j=1,il
        if(idat.ne.bez(j)) goto 1070
        kp(j)=5
        icomb0(ii)=j
        ratioe(j)=one

 1070   do l=1,20
          if(bez(j).eq.icel(ii,l)) then
            icomb(ii,l)=j
            ratioe(j)=ratio(ii,l)
          endif
        end do
      end do


      jj=icomb0(ii)
      if(jj.eq.0) goto 1050
      do 1090 m=1,20
        ico=icomb(ii,m)
        if(ico.eq.jj) call prror(92)
        if(ico.eq.0) goto 1090
        write(lout,10310) bez(jj),bez(ico),ratio(ii,m)
        iratioe(ico)=jj
        if(el(jj).le.pieni) then
          if(el(ico).le.pieni) then
            ed(ico)=ed(jj)*ratio(ii,m)
          else
            ek(ico)=ed(jj)*ratio(ii,m)
          endif
        else
          if(el(ico).le.pieni) then
            ed(ico)=ek(jj)*ratio(ii,m)
          else
            ek(ico)=ek(jj)*ratio(ii,m)
          endif
        endif
 1090 continue
      goto 1050
 1100 write(lout,10290) ncom
      goto 110
!-----------------------------------------------------------------------
!  SUBRESONANCE CALCULATION
!-----------------------------------------------------------------------
 1110 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1110
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & nta,nte,qxt,qzt,tam1,tam2,ipt,totl
+if crlibm
      call enable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) nta,nte,qxt,qzt,tam1,tam2,ipt,totl
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nta
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nte
        qxt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(7),*) ipt
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,8)
        nf=nf-1
      endif
+ei
+ei
      if(nta.lt.2) call prror(37)
      if(nte.lt.nta.or.nte.gt.9) call prror(37)
      isub=1
      goto 110

!-----------------------------------------------------------------------
!  RESONANCE-COMPENSATION
!-----------------------------------------------------------------------
 1120 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1120
      ch1(:nchars+3)=ch(:nchars)//' / '
! all integers so should be OK
      read(ch1,*) nre
      if(nre.ne.0) read(ch1,*) nre,npp,nrr(1),nrr(2),nrr(3),            &
     &ipr(1),ipr(2),ipr(3)
      if(nre.ne.0.and.(npp.lt.2.or.npp.gt.nrco)) call prror(46)
      if(nre.lt.0.or.nre.gt.3) call prror(47)
      if(abs(nrr(1)).gt.npp.or.abs(nrr(2)).gt.npp                       &
     &.or.abs(nrr(3)).gt.npp) call prror(48)
 1130 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1130
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nur
      if(nur.ne.0) read(ch1,*) nur,nu(1),nu(2),nu(3)
      if(nur.lt.0.or.nur.gt.3) call prror(49)
      if(nu(1).gt.9.or.nu(2).gt.9.or.nu(3).gt.9                         &
     &.or.nu(1).lt.0.or.nu(2).lt.0.or.nu(3).lt.0) call prror(50)
 1140 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1140
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & totl,qxt,qzt,tam1,tam2
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) totl,qxt,qzt,tam1,tam2
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        totl=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qxt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
 1150 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1150
      call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
      read(ch1,*) (ilm0(i),i=1,6)
 1160 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1160
      call intepr(6,1,ch,ch1)
      read(ch1,*) nch
      if(nch.ne.0) read(ch1,*) nch,ilm0(7),ilm0(8)
 1170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1170
      call intepr(7,1,ch,ch1)
      read(ch1,*) nqc
+if fio
+if crlibm
      call enable_xp()
+ei
      if(nqc.ne.0) read(ch1,*,round='nearest')                          &
     & nqc,ilm0(9),ilm0(10),qw0
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      if(nqc.ne.0) read(ch1,*) nqc,ilm0(9),ilm0(10),qw0
+ei
+if crlibm
      if(nqc.ne.0) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) nqc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) ilm0(9)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ilm0(10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,4)
          nf=nf-1
        endif
      endif
+ei
+ei
      do 1190 k=1,10
      do 1180 j=1,il
        if(ilm0(k).ne.bez(j)) goto 1180
        ire(k)=j
        if(nre.eq.1.and.k.lt.3.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.2.and.k.lt.5.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.3.and.k.lt.7.and.abs(kz(j)).ne.npp) call prror(39)
        if(nch.eq.1.and.(k.eq.7.or.k.eq.8).and.kz(j).ne.3) call prror   &
     &(11)
        if(nqc.eq.1.and.(k.eq.9.or.k.eq.10).and.kz(j).ne.2) call prror  &
     &(8)
        goto 1190
 1180 continue
      if((nre.eq.1.and.k.lt.3).or.(nre.eq.2.and.k.lt.5).or.             &
     &(nre.eq.3.and.k.lt.7).or.(nch.eq.1.and.(k.eq.7.or.k.eq.8)).or.    &
     &(nqc.eq.1.and.(k.eq.9.or.k.eq.10))) call prror(3)
 1190 continue
      irmod2=1
      goto 110

!-----------------------------------------------------------------------
!  SEARCH FOR OPTIMUM PLACES TO COMPENSATE RESONANCES
!-----------------------------------------------------------------------
 1200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1200
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & qxt,qzt,tam1,tam2,totl
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) qxt,qzt,tam1,tam2,totl
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        qxt=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
          tam2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
 1210 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1210
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & mesa,mp,m21,m22,m23,ise1,ise2,ise3
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) mesa,mp,m21,m22,m23,ise1,ise2,ise3
+ei
      if(mp.lt.2.or.mp.gt.9) call prror(37)
      if(abs(m21).gt.mp.or.abs(m22).gt.mp                               &
     &.or.abs(m23).gt.mp) call prror(48)
      ise=1
      k0=0

 1220 do m=1,40
        ilm0(m)=idum
      end do

 1240 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      lineno3=lineno3+1

      if(ch(1:1).eq.'/') goto 1240
      call intepr(3,1,ch,ch1)

! character strings so should be OK
      read(ch1,*) idat,(ilm0(m),m=2,40)
      if(idat.eq.next) goto 110
      ilm0(1)=idat
      ka=k0+1
      ke=k0+40
      do 1260 k=ka,ke
      if(k.gt.nele) call prror(2)
      if(k.gt.mesa) goto 110
      ki=k-k0
      if(ilm0(ki).eq.idum) goto 1270
      do 1250 j=1,il
        if(ilm0(ki).ne.bez(j)) goto 1250
        isea(k)=j
        if(abs(kz(j)).ne.mp) call prror(39)
        goto 1260
 1250 continue
      call prror(3)
 1260 continue
 1270 k0=k-1
      goto 1220

!-----------------------------------------------------------------------
!  POSTPROCESSING
!-----------------------------------------------------------------------
 1280 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 1280
      endif
      ch1(:83)=ch(:80)//' / '

      !Line 1
      if(iclr.eq.1) toptit(1)=ch
      
      
      !Line 2
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & iav,nstart,nstop,iwg,dphix,dphiz,                                &
     &iskip,iconv,imad,cma1,cma2
+if crlibm
      call disable_xp()
+ei
+ei ! END +if fio
+if .not.fio
+if .not.crlibm
      if(iclr.eq.2) read(ch1,*) iav,nstart,nstop,iwg,dphix,dphiz,       &
     &iskip,iconv,imad,cma1,cma2
+ei
+if crlibm
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iav
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) nstart
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) nstop
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) iwg
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphix=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphiz=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) iconv
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) imad
        nf=nf-1
        endif
        if (nf.gt.0) then
          cma1=fround(errno,fields,10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cma2=fround(errno,fields,11)
          nf=nf-1
        endif
      endif
+ei
+ei ! END +if .not.fio

      !Line 3
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
+if crlibm
      call disable_xp()
+ei
+ei ! END +if fio
+if .not.fio
+if .not.crlibm
      if(iclr.eq.3) read(ch1,*) qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
+ei
+if crlibm
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          qx0=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qz0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ivox
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) ivoz
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(5),*) ires
          nf=nf-1
        endif
        if (nf.gt.0) then
          dres=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ifh
          nf=nf-1
        endif
        if (nf.gt.0) then
          dfft=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
+ei
+ei ! END +if .not.fio

      !Line 4
+if fio
+if crlibm
      call enable_xp()
+ei
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & kwtype,itf,icr,idis,icow,istw,iffw,                              &
     &nprint,ndafi
+if crlibm
      call disable_xp()
+ei
+ei !END +if fio
+if .not.fio
      if(iclr.eq.4) read(ch1,*) kwtype,itf,icr,idis,icow,istw,iffw,     &
     &nprint,ndafi
+ei !END +if .not.fio

+if stf
      if (imad.eq.1) then
         write(lout,*) "ERROR in daten::POST:"
         write(lout,*) "imad not supported for STF version."
         call prror(-1)
      endif
+ei !END +if stf
      
      kwtype=0
      icr=0
      if(iskip.le.0) iskip=1
      if(iclr.ne.4) goto 1280
      if(nprint.ne.1) nprint=0
      iclr=0
      if(nstart.lt.0) nstart=0
      if(nstop.lt.0) nstop=0
      if(nstop.lt.nstart) then
         nstart=0
         nstop=0
      endif
      if(iconv.ne.1) iconv=0
      if(abs(cma1).le.pieni) cma1=one
      cma1=cma1*c1e3
      if(abs(cma2).le.pieni) cma2=one
      ipos=1
      goto 110
!-----------------------------------------------------------------------
!  POWER SUPPLY RIPPLE
!-----------------------------------------------------------------------
 1290 continue
      write(lout,*)
      write(lout,*) "ERROR: old RIPP module is no longer supported"
      write(lout,*) "Please convert your RIPP block (in fort.3) to DYNK"
      write(lout,*) "The script rippconvert.py (in the pytools folder)"
      write(lout,*) " can be used to automatically convert the fort.3!"
      write(lout,*)
      call prror(-1)

!Code for just skipping over the RIPP block, which runs the simulation without RIPP:
 1300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      write(lout,*) 'ignoring line:'
      write(lout,*) ch
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1300
      if(ch(:4).eq.next) goto 110
      goto 1300
!-----------------------------------------------------------------------
!  DECOUPLING ROUTINE
!-----------------------------------------------------------------------
 1320 iskew=1
 1330 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1330
      call intepr(3,1,ch,ch1)
! character strings again
      read(ch1,*) idat,(ilm0(m),m=2,4)
      if(idat.eq.next) then
      iskew=0
      goto 110
      endif
      ilm0(1)=idat
      do 1350 i=1,2
 1340 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1340
      if(ch(:4).eq.next) then
        iskew=2
        goto 1360
      endif
      call intepr(1,1,ch,ch1)
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & ilm0(4+i),qwsk(i)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) ilm0(4+i),qwsk(i)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) ilm0(4+i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qwsk(i)=fround(errno,fields,2)
        nf=nf-1
      endif
+ei
+ei
 1350 continue
 1360 continue

      do i=1,6
      do j=1,il
        if(iskew.eq.2.and.i.gt.4) goto 1380
        if(ilm0(i).eq.bez(j)) then
          if(i.le.4) then
            if(kz(j).ne.-2) call prror(62)
          else
            if(kz(j).ne.2) call prror(8)
          endif
          nskew(i)=j
          do i2=1,6
            if(nskew(i2).ne.0.and.(nskew(i2).eq.nskew(i)) .and.(i2.ne.i)&
     &) call prror(63)
          end do
        endif
      end do
      end do
 1380 continue
      goto 110

!GRD-----------------------------------------------------------------------
!  COLLIMATION INPUT BLOCK
!GRD-----------------------------------------------------------------------
 1285 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1

+if collimat
      has_coll = .true. !We have a collimation block.
      if (ilin.ne.1) then
         write(lout,*) "ERROR DETECTED:"
         write(lout,*) "Incompatible flag with collimation version"
         write(lout,*) "detected in the LINEAR OPTICS block."
         write(lout,*) ""
         write(lout,*) "You have not chosen ilin=1 (4D mode),"
         write(lout,*) "which is required for the collimation version."
         write(lout,*) ""
         write(lout,*) "Note that the ilin=2 (6D mode) is not"
         write(lout,*) "compatible with the collimation version."
         write(lout,*) ""
         write(lout,*) "Current setting ilin=",ilin
         call prror(-1)
      endif
+ei

      if(ch(1:1).ne.'/') then
         iclr=iclr+1
      else
         goto 1285
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      
+if .not.collimat
      if (iclr.eq.1) then
         read(ch1,*) do_coll
         if (do_coll) then
           write(lout,*)
           write(lout,*) "ERR> Collimation not forseen in this version;"
           write(lout,*) "ERR> Please use proper version"
           write(lout,*) "ERR> or set do_coll to .FALSE."
           write(lout,*)
           call prror(-1)
         endif
      endif
+ei ! END +if .not.collimat

+if collimat
!APRIL2005
+if fio
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & do_coll !Does not make sense with round=nearest: do_coll is a logical...
+ei
+if .not.fio
      if(iclr.eq.1) read(ch1,*) do_coll
+ei
      
+if fio
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & nloop,myenom
+ei
+if .not.fio
      if(iclr.eq.2) read(ch1,*) nloop,myenom
+ei
      !Does not work for bnlelens, but collimat+bnlelens doesn't work anyway...
      !Note: After daten, napx = napx*2; in daten napx is the number of particle pairs.
      if(iclr.eq.2 .and. nloop*napx*2.gt.maxn) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "nloop =", nloop
         write(lout,*) "napx  =", napx,"(-> napx*2=",napx*2,"particles)"
         write(lout,*) "maxn  =", maxn
         write(lout,*) "mynp  = nloop*napx*2 =",nloop*napx*2,"> maxn"
         write(lout,*) "Please reduce the number of particles or loops"
         write(lout,*) ""
         
         call prror(-1)
      endif

      if(iclr.eq.2 .and. napx*2.ge.100 .and. nloop.gt.1) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "If nloop > 1 then you must have napx*2 < 100"
         write(lout,*) " or else the particle numbers in the"
         write(lout,*) " output gets confused."
         write(lout,*) "napx  = ", napx
         write(lout,*) "nloop = ", nloop
         
         call prror(-1)
      endif
      
+if fio
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & do_thisdis,mynex,mdex,myney,mdey,       &
+ei
+if .not.fio
      if(iclr.eq.3) read(ch1,*) do_thisdis,mynex,mdex,myney,mdey,       &
+ei
     &filename_dis,enerror,bunchlength
!JUNE2005
!UPGRADE JANUARY 2005
+if fio
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        &
!     & NSIG_PRIM,NSIG_SEC
+ei
+if .not.fio
!      if(iclr.eq.4) read(ch1,*) NSIG_PRIM,NSIG_SEC
+ei
+if fio
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        
!     & nsig_prim,nsig_sec,nsig_ter
+ei
+if .not.fio
!      if(iclr.eq.4) read(ch1,*) nsig_prim,nsig_sec,nsig_ter
+ei
+if fio
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & do_nsig,                                                         &
+ei
+if .not.fio
      if(iclr.eq.4) read(ch1,*) do_nsig,                                &
+ei
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,             &
     &nsig_tcli,                                                        &
!     &nsig_tcth,nsig_tctv,                                              &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi
+if fio
      if(iclr.eq.5) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.5) read(ch1,*)                                         &
+ei
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcxrp,nsig_tcryo
+if fio
      if(iclr.eq.6) read(ch1,*,round='nearest')                         &
     & n_slices,smin_slices,smax_slices,                                &
+ei
+if .not.fio
      if(iclr.eq.6) read(ch1,*) n_slices,smin_slices,smax_slices,       &
+ei
     &recenter1,recenter2
+if fio
      if(iclr.eq.7) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.7) read(ch1,*)                                         &
+ei
     & fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1
+if fio
      if(iclr.eq.8) read(ch1,*,round='nearest')                         &
+ei
+if .not.fio
      if(iclr.eq.8) read(ch1,*)                                         &
+ei
     & fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2
!
+if fio
      if(iclr.eq.9) read(ch1,*,round='nearest')                         &
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
+ei
+if .not.fio
      if(iclr.eq.9) read(ch1,*)                                         &
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
+ei
+if fio
      if(iclr.eq.10) read(ch1,*,round='nearest')                        &
     & do_select,do_nominal,                  &
+ei
+if .not.fio
      if(iclr.eq.10) read(ch1,*) do_select,do_nominal,                  &
+ei
     &rnd_seed,dowrite_dist,name_sel,do_oneside,                        &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude
+if fio
      if(iclr.eq.11) read(ch1,*,round='nearest')                        &
     & xbeat,xbeatphase,ybeat,                                          &
+ei
+if .not.fio
      if(iclr.eq.11) read(ch1,*) xbeat,xbeatphase,ybeat,                &
+ei
     &ybeatphase
!AUGUST2006 ADDED offset variables for mechanical errors    ---- TW
!JANUAR2007 added rms error for gap and switch to min gap   ---- TW
+if fio
      if(iclr.eq.12) read(ch1,*,round='nearest')                        &
     & c_rmstilt_prim,c_rmstilt_sec,                                    &
+ei
+if .not.fio
      if(iclr.eq.12) read(ch1,*) c_rmstilt_prim,c_rmstilt_sec,          &
+ei
     &c_systilt_prim,c_systilt_sec,c_rmsoffset_prim,c_rmsoffset_sec,    &
     &c_sysoffset_prim,c_sysoffset_sec,c_offsettilt_seed,               &
     &c_rmserror_gap,do_mingap
+if fio
      if(iclr.eq.13) read(ch1,*,round='nearest')                        &
     & radial,nr,ndr
+ei
+if .not.fio
      if(iclr.eq.13) read(ch1,*) radial,nr,ndr
+ei
+if fio
      if(iclr.eq.14) read(ch1,*,round='nearest')                        &
     & driftsx,driftsy,cut_input,                                       &
+ei
+if .not.fio
      if(iclr.eq.14) read(ch1,*) driftsx,driftsy,cut_input,             &
+ei
     &systilt_antisymm
!AUGUST2006 ADDED rmsx, rmsy and distr. type for pencil beam ---- TW
+if fio
      if(iclr.eq.15) read(ch1,*,round='nearest')                        &
     &                                                                  &
+ei
+if .not.fio
      if(iclr.eq.15) read(ch1,*)                                        &
+ei
     &ipencil,pencil_offset,pencil_rmsx,pencil_rmsy,pencil_distr
!APRIL2005
+if g4collimat
      if(ipencil.gt.0) then
        write(lout,*) 'pencil distribution not supported with geant4'
        call prror(-1)
      endif
+ei
+if fio
      if(iclr.eq.16) read(ch1,*,round='nearest')                        &
     & coll_db,ibeam
+ei
+if .not.fio
      if(iclr.eq.16) read(ch1,*) coll_db,ibeam
+ei
!APRIL2005
+if fio
      if(iclr.eq.17) read(ch1,*,round='nearest')                        &
     & dowritetracks, cern, castordir,                                  &
+ei
+if .not.fio
      if(iclr.eq.17) read(ch1,*) dowritetracks, cern, castordir,        &
+ei
     &jobnumber, sigsecut2, sigsecut3
!
+ei ! END +if collimat

!     Use this code for both collimat and non-collimat
      if(iclr.ne.17) goto 1285
 1287 continue
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  COMMENT LINE
!-----------------------------------------------------------------------
 1390 read(3,10020,end=1530,iostat=ierro) commen
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(commen(1:1).eq.'/') goto 1390
      if(commen(:4).eq.next) then
      commen=' '
      endif
      goto 110
!-----------------------------------------------------------------------
!  NORMAL FORMS
!-----------------------------------------------------------------------
 1400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1400
      if(ch(:4).eq.next) then
      goto 110
      else
      if(idial.eq.0.and.numl.ne.0) then
        write(lout,10130)
        write(lout,*)
        call prror(78)
      endif
      inorm=1
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
      read(ch1,*,round='nearest')                                       &
     & nordf,nvarf,nord1,idptr
+ei
+if .not.fio
      read(ch1,*) nordf,nvarf,nord1,idptr
+ei
      if(nord.ne.0.and.nordf.gt.nord+1) imod1=1
      if(nvar.ne.0.and.nvarf.gt.nvar) then
        nvarf=nvar
        imod2=1
      endif
      if(idptr.lt.0.or.idptr.gt.6) idptr=0
      endif
!-----------------------------------------------------------------------
!  TUNESHIFT CORRECTIONS
!-----------------------------------------------------------------------
 1410 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1410
      if(ch(:4).eq.next) goto 110
      icorr=1
      ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
      read(ch1,*,round='nearest')                                       &
     & nctype,ncor
+ei
+if .not.fio
      read(ch1,*) nctype,ncor
+ei
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
      read(3,10020,end=1530,iostat=ierro) ch
      lineno3=lineno3+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call intepr(3,1,ch,ch1)
! coel are character strings so should be OK
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & (coel(i),i=1,ncor)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
      read(ch1,*) (coel(i),i=1,ncor)
+ei
      do 1430 j1=1,ncor
        do 1420 j2=1,il
          if(coel(j1).eq.bez(j2)) then
            if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
            ipar(j1)=j2
            goto 1430
          endif
 1420   continue
        call prror(66)
 1430 continue
      else
      call prror(70)
      endif
      if(nctype.eq.0) then
      read(3,*) namp,nmom,dummy,dummy,dummy
      lineno3=lineno3+1
      if(namp+nmom.eq.0) call prror(71)
      if(namp*nmom.ne.0) call prror(72)
      if(namp.lt.0.or.namp.gt.2) call prror(73)
      if(nmom.lt.0.or.nmom.eq.1.or.nmom.gt.3) call prror(74)
      if(namp.eq.1.or.nmom.eq.2) then
        nord=6
      else
        nord=7
      endif
      else
+if fio
+if crlibm
      call enable_xp()
+ei
      read(3,*, round='nearest') nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(3,*) nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
+ei
+if crlibm
      read(3,*) ch1
      lineno3=lineno3+1
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nmom1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nmom2
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        dpmax=fround(errno,fields,5)
        nf=nf-1
      endif
+ei
+ei
      if(nmom1.lt.2.or.nmom1.gt.3) call prror(75)
      if(nmom1.gt.nmom2) call prror(76)
      if(nmom2.lt.2.or.nmom2.gt.3) call prror(77)
      nord=2*(nmom2+1)
      endif
!-----------------------------------------------------------------------
      idial=1
      numlr=0
      napx=1
      imc=1
      preda=1.d-38
      nsix=1
      nvar=5
      nvar2=nvar
      nvar=nvar2+ncor
!-----------------------------------------------------------------------
      inorm=1
      nordf=nord+1
      nvarf=nvar
!-----------------------------------------------------------------------
      goto 1410
!-----------------------------------------------------------------------
!  Beam-Beam Element
!-----------------------------------------------------------------------
      ! ! ! Read 1st line of BEAM block ! ! !
 1600 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1600
      if(ch(:4).eq.next) goto 110

      if (nbeam.ge.1) then
         write(lout,*)                                                  &
     &        "ERROR: There can only be one BEAM block in fort.3"
         call prror(-1)
      endif
      
      if (ch(:6) .eq."EXPERT") then
         beam_expflag = 1
         
 1601    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1601
         if(ch(:4).eq.next) goto 110
         ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*)                                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')                                        &
     &           "First line should have 9 fields, got", nf
            call prror(-1)
         endif
         
         partnum = fround(errno,fields,1)
         emitnx  = fround(errno,fields,2)
         emitny  = fround(errno,fields,3)
         sigz    = fround(errno,fields,4)
         sige    = fround(errno,fields,5)
         read(fields(6),*) ibeco
         read(fields(7),*) ibtyp
         read(fields(8),*) lhc
         read(fields(9),*) ibbc
+ei
+ei
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
!GRD-2007
+if bnlelens
!GRDRHIC
!GRD-042008
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2).and.(lhc.ne.9))
     &      lhc=1
!GRDRHIC
!GRD-042008
+ei
+if .not.bnlelens
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
+ei
!GRD-2007
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset !Initialize complex error function for FAST BB kick

         ! ! ! Read other lines of BEAM block ! ! !
 1660    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1660
         if(ch(:4).eq.next) goto 110

+if fio
!+if crlibm
!         call enable_xp()
!+ei
!         read(ch1,*,round='nearest')                                       &
!     &      idat,i,xang,xplane,separx,separy,
!     &      mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8, &
!     &      mm9,mm10,mm11
!+if crlibm
!         call disable_xp()
!+ei
        write(lout,*)                                                   &
     &       'ERROR in BEAM block (EXPERT mode): '//                    &
     &       'fortran IO currently not supported.'
        call prror(-1)
+ei
+if .not.fio
+if .not.crlibm
         call intepr(1,1,ch,ch1)
         read(ch1,*) idat,i

         if (i.gt.0) then !6D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            read(ch,*) mm1,mm2,mm3,mm4,mm5
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            read(ch,*) mm6,mm7,mm8,mm9,mm10,mm11
            
         else if (i.eq.0) then  !4D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
         else
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')                                  &
     &           "Expected number of slices >= 0; but got",             &
     &           i, " in element ",idat
            call prror(-1)
         endif
+ei
+if crlibm  !The CRLIBM version has much more robust error checking...
         call intepr(1,1,ch,ch1)
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (.not.(nf.eq.6 .or. nf.eq.7)) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')                                        &
     &           "First line of an element definition should "//        &
     &           "have 6 or 7 fields, got", nf
            call prror(-1)
         endif
         
         read(fields(2),*) i !read number of slices
         
         if (i.gt.0) then  !6D
            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "First line of a 6D element definition should "//   &
     &              "have 6 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat !Name
            read(fields(2),*) i    !slices (ibsix)
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            ch1(:nchars+3)=ch(:nchars)//' / '
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.5) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "Second line of a 6D element definition should "//  &
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm1=fround(errno,fields,1)
            mm2=fround(errno,fields,2)
            mm3=fround(errno,fields,3)
            mm4=fround(errno,fields,4)
            mm5=fround(errno,fields,5)
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            ch1(:nchars+3)=ch(:nchars)//' / '
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "Third line of a 6D element definition should "//   &
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm6=fround(errno,fields,1)
            mm7=fround(errno,fields,2)
            mm8=fround(errno,fields,3)
            mm9=fround(errno,fields,4)
            mm10=fround(errno,fields,5)
            mm11=fround(errno,fields,6)
            
         else if(i.eq.0) then ! 4D
            if (nf.ne.7) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "First line of a 6D element definition should "//   &
     &              "have 7 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            mm1=fround(errno,fields,7)
         else
            read(fields(1),*) idat
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')                                  &
     &           "Expected number of slices >= 0; but got",             &
     &           i, " in element ",idat
            call prror(-1)
         endif
+ei
+ei
         
         do j=1,il !loop over single lements
            if(idat.eq.bez(j)) then
               if(kz(j).ne.20) then
                  write(lout,'(a)') "ERROR when reading BEAM block:"
                  write(lout,'(a,a16,a,i5,a)')                          &
     &                 "Found element named ",bez(j),                   &
     &                 " but type is",kz(j), ", expected type 20!"
                  call prror(-1)
               else
                  
                  if(parbe(j,5).ne.zero .or. parbe(j,6).ne.zero         &
     &                 .or. ptnfac(j).ne.zero                           &
     &                 .or. bbbx(j).ne.zero .or. bbby(j).ne.zero        &
     &                 .or. bbbs(j).ne.zero ) then
                     !Note: Data moved from ed/ek/el to parbe/ptnfac in initialize_element
                     write(lout,'(a)') "ERROR when reading BEAM block:"
                     write(lout,'(a,a16,a)')                            &
     &                    "Using EXPERT mode, but element ", bez(j),    &
     &                    " does not have ed=ek=el=bbbx=bbby=bbbs=0.0"//&
     &                    " in the SINGLE ELEMENTS list."
                     call prror(-1)
                  endif
                  if (i.gt.0) then ! 6D, allow 1 or more slices
                     parbe(j,17)=1      ! Is 6D
                     parbe(j,2)=real(i,fPrec) ! Number of slices
                     parbe(j,1)=xang
                     parbe(j,3)=xplane
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     parbe(j,7)=mm1
                     parbe(j,8)=mm2
                     parbe(j,9)=mm3
                     parbe(j,10)=mm4
                     parbe(j,11)=mm5
                     parbe(j,12)=mm6
                     parbe(j,13)=mm7
                     parbe(j,14)=mm8
                     parbe(j,15)=mm9
                     parbe(j,16)=mm10
                     ptnfac(j)=mm11
                     goto 1660
                  else if(i.eq.0) then ! 4D, single slice only
                     parbe(j,17)=0      ! Type is 4D
                     parbe(j,2)=real(i,fPrec) ! Number of slices is always 0
                     parbe(j,1)=xang    ! not the crossing angle but sigmaxx
                     parbe(j,3)=xplane  ! not the xplane but sigmayy
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     ptnfac(j)=mm1
                     goto 1660
                  endif
               endif
            endif
         end do
         goto 1660
         
      else ! Old-style BEAM block
         write (lout,'(a)') "READING OLD-STYLE BEAM BLOCK"
         write (lout,'(a)') " Check the file 'beam_expert.txt'"//       &
     &        " for conversion to the new 'EXPERT' format."
         write (lout,'(a)') " To convert to the new format,"//          &
     &        " copy-paste these lines into the BEAM"//                 &
     &        " block in fort.3, replacing line 2 onwards."
         write (lout,'(a)') " Then write EXPERT on the first line"//    &
     &        " of the BEAM block, above the current first line."
         write(lout,'(a)') " Finally, in the SINGLE ELEMENTS list"//    &
     &        " (normally in fort.2) set the parameters of all"//       &
     &        " beam-beam lenses (type 20) to 0.0."
         write(lout,'(a)') " "
         write(lout,'(a)') " This procedure produces a new"//           &
     &        " set of input files that should have bit-for-bit"//      &
     &        " identical results to this one."
         write(lout,'(a)') " The easiest way to check this is"//        &
     &        " to run both simulations side-by-side and compare"//     &
     &        " the standard output in a text diff tool like meld."
         write(lout,'(a)') " If the results are not identical,"//       &
     &        " this is a bug; please report it to the developers!"
+if .not.crlibm
         write(lout,'(a)') " "
         write(lout,'(a)') "NOTE: THIS SIXTRACK BINARY WAS"//           &
     &        " NOT COMPILED WITH CRLIBM, CONVERSION WILL NOT BE EXACT."
+ei
         write(lout,'(a)') " "
         
         ch1(:nchars+3)=ch(:nchars)//' / '
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*)                                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)')                                           &
     &           "WARNING in DATEN reading BEAM (not EXPERT)"
            write(lout,'(a,i4)') "First line should have 9 fields,"//   &
     &           " got ", nf
            !Treating this as a warning, or else we would invalidate
            !lots of working input files
            !call prror(-1)
         endif
         
         if (nf.gt.0) then
            partnum=fround(errno,fields,1)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitnx=fround(errno,fields,2)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitny=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sigz=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sige=fround(errno,fields,5)
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(6),*) ibeco
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(7),*) ibtyp
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(8),*) lhc
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(9),*) ibbc
            nf=nf-1
         endif
+ei
+ei
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
!GRD-2007
+if bnlelens
!GRDRHIC
!GRD-042008
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2).and.(lhc.ne.9))
     &      lhc=1
!GRDRHIC
!GRD-042008
+ei
+if .not.bnlelens
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
+ei
!GRD-2007
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset
         
         ! ! ! Read other lines of BEAM block ! ! !
 1610    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1610
         if(ch(:4).eq.next) goto 110  ! Done yet?

         !Check number of arguments gotten
         call getfields_split( ch, getfields_fields, getfields_lfields, &
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(-1)
         beam_xstr = .false.
         if (getfields_nfields .eq. 5) then
            beam_xstr=.true.
         elseif (getfields_nfields .eq. 4) then
            beam_xstr=.false.
         else
            write(lout,*) "ERROR in parsing BEAM block"
            write(lout,*) "Number of arguments in data line 2,..."
            write(lout,*) " is expected to be 4 or 5"
            call prror(-1)
         end if
         call intepr(1,1,ch,ch1)
+if fio
+if crlibm
         call enable_xp()
+ei
         read(ch1,*,round='nearest')                                       &
     &      idat,i,xang,xplane,xstr
+if crlibm
         call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
         read(ch1,*) idat,i,xang,xplane,xstr
+ei
+if crlibm
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.gt.0) then
            read(fields(1),*) idat
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(2),*) i
            nf=nf-1
         endif
         if (nf.gt.0) then
            xang=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xplane=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xstr=fround(errno,fields,5)
            nf=nf-1
         endif
+ei
+ei
         if ( .not. beam_xstr ) then
            write(lout,*) "WARNING in parsing BEAM block"
            write(lout,*) "No xstr present, assuming xstr=xang"
            xstr = xang
         endif
      
         if(i.lt.0) i=0
         do 1620 j=1,il
            if(idat.eq.bez(j).and.kz(j).eq.20) then
               ibb6d=1
               parbe(j,2)=real(i,fPrec) !hr12
               parbe(j,1)=xang
               parbe(j,3)=xplane
               parbe(j,18)=xstr
               goto 1610
            endif
 1620    continue
         goto 1610
      endif
!-----------------------------------------------------------------------
!  TROMBONE ELEMENT KZ=22
!-----------------------------------------------------------------------
 1700 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1700
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
+if fio
      read(ch1,*,round='nearest')                                       &
     & imn
+ei
+if .not.fio
      read(ch1,*) imn
+ei
      imtr0=imtr0+1
      if(imtr0.gt.ntr) call prror(100)
      do 1710 j=1,il
        if(imn.eq.bez(j)) then
          imtr(j)=imtr0
          goto 1720
        endif
 1710 continue
      call prror(98)
 1720 j1=0
      if(imtr0.eq.1) write(lout,10130)
      if(imtr0.eq.1) write(lout,10700)
      write(lout,10710) imtr0,imn
 1730 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1730
      if(ch(:4).eq.next) call prror(99)
      ch1(:nchars+3)=ch(:nchars)//' / '
      j1=j1+3
+if fio
+if crlibm
      call enable_xp()
+ei
      read(ch1,*,round='nearest')                                       &
     & cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
      read(ch1,*) cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cotr(imtr0,j1-2)=fround(errno,fields,1) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1-1)=fround(errno,fields,2) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1)=fround(errno,fields,3) 
        nf=nf-1
      endif
+ei
+ei
      if(j1.lt.6) goto 1730
      do j=1,6
        j1=0
 1740   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 1740
        if(ch(:4).eq.next) call prror(99)
        ch1(:nchars+3)=ch(:nchars)//' / '
        j1=j1+3
+if fio
+if crlibm
      call enable_xp()
+ei
        read(ch1,*,round='nearest')                                     &
     & rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),                           &
     &rrtr(imtr0,j,j1)
+if crlibm
      call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(ch1,*) rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),              &
     &rrtr(imtr0,j,j1)
+ei
+if crlibm
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-1)=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1)=fround(errno,fields,3)
        nf=nf-1
      endif
+ei
+ei
        if(j1.lt.6) goto 1740
      enddo
      goto 1700
!-----------------------------------------------------------------------
!  COUPLING WITH FLUKA
!  A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!  last modified: 17-07-2013
!-----------------------------------------------------------------------
 1800 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
+if .not.fluka

!     inserted in main code if the 'fluka' compilation flag is NOT issued

      write(lout,*)
      write(lout,*) "     FLUKA coupling not supported in this version"
      write(lout,*) "     please recompile with proper flags"
      write(lout,*)
      call prror(-1)

+ei
+if fluka

!     inserted in main code by the 'fluka' compilation flag

      if(ch(1:1).eq.'/') goto 1800
      if(ch(:4).eq.next) then
        write(lout,10520) fluk
        if ( fluka_enable ) then
!         dump all elements found:
          do ii=1,il
             if(fluka_type(ii).ne.FLUKA_NONE) then
               write(lout,10510) bez(ii), fluka_type(ii),                  &
     &                        fluka_geo_index(ii),fluka_synch_length(ii)
             endif
          enddo
          write(lout,*) ''
          write(lout,*) '        keys to FLUKA types:'
          write(lout,*) FLUKA_ELEMENT,' --> simple element'
          write(lout,*) FLUKA_ENTRY,' --> entrance point'
          write(lout,*) FLUKA_EXIT,' --> exit point'
          write(lout,*) ''
          if ( fluka_debug  ) write(lout,*) "        --> DEBUG enabled!"
        else
          write(lout,*) ''
          write(lout,*) ' !! no element flagged for coupling !!'
          write(lout,*) '    --> disabling coupling flags/labelling'
          write(lout,*) ''
          fluka_enable = .false.
          fluka_debug  = .false.
          do ii=1,il
             fluka_type(ii) = FLUKA_NONE
          enddo
        endif
        goto 110
      endif

      lineno3=lineno3+1
      ch1(:83)=ch(:80)//' / '
      if(ch1(:4).eq.'DEBU') then
        fluka_debug = .true.
        goto 1800
      elseif(ch1(:4).eq.'LOGU') then
        read(ch1,*) idat, ii
        if ( ii.gt.0 ) then
          fluka_log_unit = ii
        else
          write(lout,*) ' no valid unit for logging coupling messages'
          write(lout,*) '   in block ',fluk
          write(lout,*) '   parsed line:'
          write(lout,*) ch(:80)
          write(lout,*) ''
          call prror(-1)
        endif
      endif

!     parse line:
      read(ch1,*) idat, idat2, ii, tmplen

!     1. find idat (ie name of entrance element) in the list of SINGLE ELEMENTs:
      do i1=1,il
         if(bez(i1).eq.idat) goto 1801
      enddo
!     failing research:
      write(lout,*) ''
      write(lout,*) ' Un-identified SINGLE ELEMENT ', idat
      write(lout,*) '   in block ',fluk
      write(lout,*) '   parsed line:'
      write(lout,*) ch(:80)
      write(lout,*) ''
      call prror(-1)

!     2. find idat2 (ie name of exit element) in the list of SINGLE ELEMENTs:
 1801 do i2=1,il
         if(bez(i2).eq.idat2) goto 1802
      enddo
!     failing research:
      write(lout,*) ''
      write(lout,*) ' Un-identified SINGLE ELEMENT ', idat2
      write(lout,*) '   in block ',fluk
      write(lout,*) '   parsed line:'
      write(lout,*) ch(:80)
      write(lout,*) ''
      call prror(-1)

 1802 continue

!     3. check that the current markers have not been already flagged
      if ( fluka_type(i1).ne.FLUKA_NONE ) then
        write(lout,*) ''
        write(lout,*) ' SINGLE ELEMENT ', bez(i1)
        write(lout,*) '   in block ',fluk
        write(lout,*) '   was alredy labelled as fluka marker:'
        write(lout,*) '     you cannot overwrite'
        write(lout,*) '   parsed line:'
        write(lout,*) ch(:80)
        write(lout,*) ''
        call prror(-1)
      endif
      if ( fluka_type(i2).ne.FLUKA_NONE ) then
        write(lout,*) ''
        write(lout,*) ' SINGLE ELEMENT ', bez(i2)
        write(lout,*) '   in block ',fluk
        write(lout,*) '   was alredy labelled as fluka marker:'
        write(lout,*) '     you cannot overwrite'
        write(lout,*) '   parsed line:'
        write(lout,*) ch(:80)
        write(lout,*) ''
        call prror(-1)
      endif

!     4. disentangle between just a simple element or an interval of elements
!        in the accelerator structure, labelled as Fluka insertion:
      if ( i1.eq.i2 ) then
        fluka_type(i1) = FLUKA_ELEMENT
        fluka_geo_index(i1)  = ii
        fluka_synch_length(i1) = tmplen
        write(fluka_log_unit,*)                                         &
     &'# Found         Fluka element as SING EL num',i1
      else
        fluka_type(i1) = FLUKA_ENTRY
        fluka_geo_index(i1)  = ii
        fluka_type(i2) = FLUKA_EXIT
        fluka_geo_index(i2)  = ii
        fluka_synch_length(i2) = tmplen
        write(fluka_log_unit,*)                                         &
     &'# Found entrance Fluka element as SING EL num',i1
        write(fluka_log_unit,*)                                         &
     &'# Found exit     Fluka element as SING EL num',i2
      endif
!     wait to find at least one FLUKA insertion before actually enabling
!       the coupling
      if(.not.fluka_enable) fluka_enable = .true.

+ei
      goto 1800

!-----------------------------------------------------------------------
!  READ INITIAL DISTRIBUTION
!  A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!  last modified: 17-07-2013
!  always in main code
!-----------------------------------------------------------------------
 1900 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      if(ch(1:1).eq.'/') goto 1900
      if(ch(:4).eq.next) goto 110

      lineno3=lineno3+1
      ch1(:83)=ch(:80)//' / '

!     keywords:
      if(ch1(:4).eq.'ECHO') then
        dist_echo = .true.
      elseif(ch1(:4).eq.'RDUN') then
        read(ch1,*) idat, dist_read_unit
      elseif(ch1(:4).eq.'ECUN') then
        read(ch1,*) idat, dist_echo_unit
      elseif(ch1(:4).eq.'READ') then
        read(ch1,*) idat, dist_filename
        if(.not.dist_enable) dist_enable = .true.
      endif

      goto 1900

!-----------------------------------------------------------------------
!  DUMP BEAM POPULATION
!  A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!  K.Sjobak, BE-ABP/HSS, BE-ABP/LAT
!  last modified: 03-09-2015
!  always in main code
!-----------------------------------------------------------------------
 2000 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 ! Line number used for some crash output
      if(ch(1:1).eq.'/') goto 2000 !Skip comment line
      
      !Done with DUMP, write out!
      if(ch(:4).eq.next) then
         call dump_parseInputDone
         goto 110
      endif !END writeout when finished reading
      
      call dump_parseInputLine(ch)
      
      ! Go to next line
      goto 2000

!-----------------------------------------------------------------------
!  DYNAMIC KICKS
!  A.Mereghetti, for the FLUKA Team
!  K.Sjobak & A. Santamaria, BE-ABP/HSS
!  last modified: 21-01-2014
!  always in main code
!-----------------------------------------------------------------------
 2200 continue
      !We have a DYNK block; let's allocate the memory for it!
      if (ldynk) then
         write (lout,*)
         write (lout,*) "******************************************"
         write (lout,*) "** More than one DYNK block encountered **"
         write (lout,*) "******************************************"
         call prror(51)
      endif
      call dynk_allocate
      
 2201 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2201 ! skip comment line

      ! Which type of block? Look at start of string (no leading blanks allowed)

      if (ch(:4).eq."DEBU") then
         ldynkdebug = .true.
         write (lout,*) "DYNK> DYNK block debugging is ON"
         goto 2201 !loop DYNK
         
      else if (ch(:6).eq."NOFILE") then
         ldynkfiledisable = .true.
         write (lout,*) "DYNK> Disabled writing dynksets.dat"
         goto 2201 !loop DYNK
         
      else if (ch(:3).eq."FUN") then
         call getfields_split( ch, getfields_fields, getfields_lfields, &
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write (lout,'(1x,A,I4,A)')                                  &
     &           "DYNKDEBUG> Got a FUN block, len=",                    &
     &           len(ch), ": '"// trim(ch)// "'"
            do ii=1,getfields_nfields
               write (lout,*)                                           &
     &              "DYNKDEBUG> Field(",ii,") ='"//                     &
     &              getfields_fields(ii)(1:getfields_lfields(ii))//"'"
            enddo
         endif
         call dynk_parseFUN(getfields_fields,                           &
     &        getfields_lfields, getfields_nfields)
         goto 2201 !loop DYNK

      else if (ch(:3).eq."SET") then
         call getfields_split( ch, getfields_fields, getfields_lfields, &
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(51)
         if (ldynkdebug) then
            write (lout,'(1x,A,I4,A)')                                  &
     &           "DYNKDEBUG> Got a SET block, len=",                    &
     &           len(ch), ": '"//trim(ch)//"'"
            do ii=1,getfields_nfields
               write (lout,*)                                           &
     &              "DYNKDEBUG> Field(",ii,") ='"//                     &
     &              getfields_fields(ii)(1:getfields_lfields(ii))//"'"
            enddo
         endif
         call dynk_parseSET(getfields_fields,                           &
     &        getfields_lfields, getfields_nfields)
         goto 2201 !loop DYNK

      else if (ch(:4).eq.next) then
         if (ldynkdebug) then
            write (lout,*) "DYNKDEBUG> Finished parsing DYNK block"
            call dynk_dumpdata
         endif
         
         ldynk = .true.
         
         call dynk_inputsanitycheck
         goto 110 ! Read next block or ENDE

      else
         write (lout,*)
         write (lout,*) "*******************************************"
         write (lout,*) "ERROR while parsing DYNK block in fort.3"
         write (lout,*)                                                 &
     &        "Expected keywords FUN, SET, DEBU, NOFILE or NEXT"
         write (lout,*) "Got ch:"
         write (lout,*) "'"//ch//"'"
         write (lout,*) "*******************************************"
         call prror(51)
      endif
      ! Should never arrive here
      write (lout,*) "*****************************"
      write (lout,*) "*LOGIC ERROR IN PARSING DYNK*"
      write (lout,*) "*****************************"
      call prror(51)
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!  FMA
!  M. Fitterer, R. De Maria, K. Sjobak, BE/ABP-HSS
!  last modified: 07-01-2016
!  always in main code
!-----------------------------------------------------------------------
 2300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2300 ! skip comment lines

      if (ch(:4).eq.next) then
         goto 110 ! loop to next BLOCK in fort.3
      endif

      call fma_parseInputLine(ch)
      
      goto 2300
!-----------------------------------------------------------------------
!  Electron Lense, kz=29,ktrack=63
!  M. Fitterer,  FNAL
!  last modified: 20-06-2016
!-----------------------------------------------------------------------
 2400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2400 ! skip comment lines

      if (ch(:4).eq.next) then
!       4) loop over single elements to check that they have been defined in the fort.3 block
        do j=1,nele
          if(kz(j).eq.29) then
            if(elens_type(j).eq.0) then
              write(lout,*)                                             &
     &'ERROR: elens ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '// &
     &'not defined in fort.3. You must define every elens in the '//    &
     &'ELEN block in fort.3!'
               call prror(-1)
            endif
          endif
        enddo
        goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
+if fio
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: fortran IO format currently not ',   &
     &       'supported!'
        call prror(-1)
+ei

!     1) read in elens parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,    &
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check number of arguments
!     If a new type of elens is implemented, may need to modify this!
      if(getfields_nfields.ne.9) then
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 9'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)                                                  &
     &        "ERROR in ELEN block: Element name max 16 characters;"//  &
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))&
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of elens
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_elens=29)
            if(kz(j).ne.29) then
               write(lout,*)                                            &
     &              'ERROR: element type mismatch for ELEN!'//          &
     &              'Element type is kz(',j,') = ',kz(j),'!= 29'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_elens=29)
               write(lout,*)                                            &
     &'ERROR: length el(j) (elens is treated as thin element), '//      &
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//&
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,      &
     &')=',ek(j),'. Please check your input in the single element '//   &
     &'definition of your ELEN. All values except for the type need '// &
     &'to be zero.'
               call prror(-1)
            endif
            if (elens_type(j).ne.0) then
               write(lout,*) "ERROR in ELEN block:"//                   &
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            select case ( getfields_fields(2)(1:getfields_lfields(2)) )
            case ("ANNULAR")
               ! Read in this case
               elens_type(j) = 1
+if .not.crlibm
               read (getfields_fields(3)(1:getfields_lfields(3)),*)     &
     &              elens_theta_max(j)
               read (getfields_fields(4)(1:getfields_lfields(4)),*)     &
     &              elens_r2(j)
               read (getfields_fields(5)(1:getfields_lfields(5)),*)     &
     &              elens_r2ovr1(j)
               read (getfields_fields(6)(1:getfields_lfields(6)),*)     &
     &              elens_offset_x(j)
               read (getfields_fields(7)(1:getfields_lfields(7)),*)     &
     &              elens_offset_y(j)
+ei
+if crlibm
               elens_theta_max(j)= round_near (                         &
     &              errno,getfields_lfields(3)+1, getfields_fields(3) )
               if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,3,elens_theta_max(j) )
               elens_r2(j)       = round_near (                         &
     &              errno,getfields_lfields(4)+1, getfields_fields(4) )
               if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,4,elens_r2(j) )
               elens_r2ovr1(j)   = round_near (                         &
     &              errno,getfields_lfields(5)+1, getfields_fields(5) )
               if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,5,elens_r2ovr1(j) )
               elens_offset_x(j) = round_near (                         &
     &              errno,getfields_lfields(6)+1, getfields_fields(6) )
               if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,6,elens_offset_x(j) )
               elens_offset_y(j) = round_near (                         &
     &              errno,getfields_lfields(7)+1, getfields_fields(7) )
               if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,7,elens_offset_y(j) )
+ei
               read(getfields_fields(8)(1:getfields_lfields(8)),'(I10)')&
     &              elens_bend_entrance(j)
               read(getfields_fields(9)(1:getfields_lfields(9)),'(I10)')&
     &              elens_bend_exit(j)
               
               ! Make checks for this case
               if(elens_r2ovr1(j).le.1) then
                  write(lout,*)                                         &
     &'ERROR: ELEN radius ratio r2/r1 must be larger than 1, but is ',  &
     &elens_r2ovr1(j),'<1'
                 call prror(-1)
              end if
              if(elens_bend_entrance(j).ne. 1 .and.                     &
     &           elens_bend_entrance(j).ne.-1 .and.                     &
     &           elens_bend_entrance(j).ne. 0      ) then
                 write(lout,*)                                          &
     &'ERROR: ELEN flag for taking bends at entrance into account must' &
     &//' be -1,0,1, but elens_bend_entrance =',                        &
     &elens_bend_entrance(j)
                 call prror(-1)
              end if
              if(elens_bend_exit(j).ne. 1 .and.                         &
     &           elens_bend_exit(j).ne.-1 .and.                         &
     &           elens_bend_exit(j).ne.0       ) then
                 write(lout,*)                                          &
     &'ERROR: ELEN flag for taking bends at exit into account must'     &
     &//' be -1,0,1, but elens_bend_exit =',                            &
     &elens_bend_exit(j)
                 call prror(-1)
              end if

              ! print a summary of elens parameters
              write(lout,                                               &
     &fmt='((A,/),(A,A,/),(A,A,A,I4,/),5(A,D10.3,A,/),(A,/),'           &
     &//'2(A,I4,/))')                                                   &
     &'ELENS found in list of single elements with: ',                  &
     &'name     = ',bez(j),                                             &
     &'type     = ',getfields_fields(2)(1:getfields_lfields(2)),        &
     &        ' = ',elens_type(j),                                      &
     &'thetamax = ',elens_theta_max(j),' mrad',                         &
     &'r2       = ',elens_r2(j),' mm',                                  &
     &'r2/r1    = ',elens_r2ovr1(j),'',                                 &
     &'offset_x = ',elens_offset_x(j),' mm',                            &
     &'offset_y = ',elens_offset_y(j),' mm',                            &
     &'enable bends at:',                                               &
     &'  entrance = ',elens_bend_entrance(j),                           &
     &'  exit     = ',elens_bend_exit(j)
      
            case default
               write(lout,*) "ERROR in ELEN: "//                        &
     &              "Elens type '"//                                    &
     &              getfields_fields(2)(1:getfields_lfields(2))//       &
     &              "' not recognized. Remember to use all UPPER CASE!"
               call prror(-1)
            end select
            
            goto 2401           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in ELEN: "//                                 &
     &     "Un-identified SINGLE ELEMENT '",                            &
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2401 continue
      
      goto 2400 ! at NEXT statement -> check that all single elements with kz(j) = 29 (elens) have been defined in ELEN block

!-----------------------------------------------------------------------
!  Wire, kz=+/-15,ktrack=45
!  A. Patapenka (NIU), M. Fitterer,  FNAL
!  last modified: 22-12-2016
!-----------------------------------------------------------------------
 2500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2500 ! skip comment lines
     
      if (ch(:4).eq.next) then
!       4) loop over single elements to check that they have been defined in the fort.3 block
        do j=1,nele
          if(kz(j).eq.15) then
            if(wire_flagco(j).eq.0) then
              write(lout,*)                                             &
     &'ERROR: wire ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '//  &
     &'not defined in fort.3. You must define every wire in the '//     &
     &'WIRE block in fort.3!'
               call prror(-1)
            endif
          endif
        enddo
        goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
+if fio
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: fortran IO format currently not ',   &
     &       'supported!'
        call prror(-1)
+ei

!     1) read in wire parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,    &
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check number of arguments
      if(getfields_nfields.ne.9) then
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 9'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)                                                  &
     &        "ERROR in WIRE block: Element name max 16 characters;"//  &
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))&
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of wire
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_wire=15)
            if(kz(j).ne.15) then
               write(lout,*)                                            &
     &              'ERROR: element type mismatch for WIRE! '//         &
     &'Element type is kz(',j,') = ',kz(j),'!= +15'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_wire=+/-15)
               write(lout,*)                                            &
     &'ERROR: length el(j) (wire is treated as thin element), '//       &
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//&
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,      &
     &')=',ek(j),'. Please check your input in the single element '//   &
     &'definition of your WIRE. All values except for the type need '// &
     &'to be zero.'
               call prror(-1)
            endif
            if (wire_flagco(j).ne.0) then
               write(lout,*) "ERROR in WIRE block:"//                   &
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            read(getfields_fields(2)(1:getfields_lfields(2)),'(I10)')   &
     &           wire_flagco(j)
+if .not.crlibm
            read (getfields_fields(3)(1:getfields_lfields(3)),*)        &
     &           wire_current(j)
            read (getfields_fields(4)(1:getfields_lfields(4)),*)        &
     &           wire_lint(j)
            read (getfields_fields(5)(1:getfields_lfields(5)),*)        &
     &           wire_lphys(j)
            read (getfields_fields(6)(1:getfields_lfields(6)),*)        &
     &           wire_dispx(j)
            read (getfields_fields(7)(1:getfields_lfields(7)),*)        &
     &           wire_dispy(j)
            read (getfields_fields(8)(1:getfields_lfields(8)),*)        &
     &           wire_tiltx(j)
            read (getfields_fields(9)(1:getfields_lfields(9)),*)        &
     &           wire_tilty(j)
+ei
+if crlibm
            wire_current(j)= round_near (                               &
     &           errno,getfields_lfields(3)+1, getfields_fields(3) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,3,wire_current(j) )
            wire_lint(j)       = round_near (                           &
     &           errno,getfields_lfields(4)+1, getfields_fields(4) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,4,wire_lint(j) )
            wire_lphys(j)   = round_near (                              &
     &           errno,getfields_lfields(5)+1, getfields_fields(5) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,5,wire_lphys(j) )
            wire_dispx(j) = round_near (                                &
     &           errno,getfields_lfields(6)+1, getfields_fields(6) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,6,wire_dispx(j) )
            wire_dispy(j) = round_near (                                &
     &           errno,getfields_lfields(7)+1, getfields_fields(7) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,7,wire_dispy(j) )
            wire_tiltx(j) = round_near (                                &
     &           errno,getfields_lfields(8)+1, getfields_fields(8) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,8,wire_tiltx(j) )
            wire_tilty(j) = round_near (                                &
     &           errno,getfields_lfields(9)+1, getfields_fields(9) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,9,wire_tilty(j) )
+ei
            
            ! Make checks for the wire parameters
            if(wire_flagco(j).ne. 1 .and. wire_flagco(j).ne.-1) then
               write(lout,*)                                            &
     &"ERROR: WIRE flag for defining the wire separation "//            &
     &"must be -1 (disp* = distance closed orbit and beam)"//           &
     &"or 1 (disp* = distance from x=y=0 <-> beam), but "//             &
     &"wire_flagco = ",wire_flagco(j)
               call prror(-1)
            end if
            if((wire_lint(j).lt.0) .or. (wire_lphys(j).lt.0)) then
              write(lout,*)                                             &
     &'ERROR: WIRE integrated and physical length must larger than 0! ' &
     &// 'wire_lint = ',wire_lint(j),', wire_lphys = ',wire_lphys(j)
              call prror(-1)
            end if
            if((abs(wire_tiltx(j)) .ge. 90) .or.                        &
     &         (abs(wire_tilty(j)) .ge. 90)) then
              write(lout,*)                                             &
     &'ERROR: WIRE tilt angle must be within [-90,90] degrees! '        &
     &//'wire_tiltx = ',wire_tiltx(j),', wire_tilty = ',wire_tilty(j)
              call prror(-1)
            end if

! print a summary of the wire parameters
            write(lout,                                                 &
     &fmt='((A,/),(A,A,/),(A,I4,/),7(A,D10.3,A,/))')                    &
     &'WIRE found in list of single elements with: ',                   &
     &'name               = ',bez(j),                                   &
     &'flagco             = ',wire_flagco(j),                           &
     &'current            = ',wire_current(j),' A',                     &
     &'integrated length  = ',wire_lint(j),' m',                        &
     &'physical length    = ',wire_lphys(j),' m',                       &
     &'hor. displacement  = ',wire_dispx(j),' mm',                      &
     &'vert. displacement = ',wire_dispy(j),' mm',                      &
     &'hor. tilt          = ',wire_tiltx(j),' degrees',                 &
     &'vert. tilt         = ',wire_tilty(j),' degrees'
! ignore wire if current, length or displacment are 0 or
! wire_flagco not set (case wire_flagco = 0)
! for displacement only ignore if wire_dispx = wire_dispy = 0
            if( abs(wire_flagco(j)*(wire_current(j)*(wire_lint(j)       &
     &*(wire_lphys(j)*(wire_dispx(j)+wire_dispy(j)))))).le.pieni ) then
              kz(j) = 0 ! treat element as marker

              write(lout,                                               &
     &fmt='((A,A,A,/),(A,A,/),4(A,I0,A,D10.3,/))')                      &
     &'WARNING: WIRE element ',bez(j),'ignored!',                       &
     &'Elements are ignored if current, displacment, integrated ',      &
     &'or physical length are 0! ',                                     &
     &'wire_dispx(',j,') = ',wire_dispx(j),                             &
     &'wire_dispy(',j,') = ',wire_dispy(j),                             &
     &'wire_lint(',j,') = ',wire_lint(j),                               &
     &'wire_lphys(',j,') = ',wire_lphys(j)
            end if

            goto 2501           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in WIRE: "//                                 &
     &     "Un-identified SINGLE ELEMENT '",                            &
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2501 continue
      
      goto 2500 ! at NEXT statement -> check that all single elements with kz(j) = 15 (wire) have been defined in WIRE block

!-----------------------------------------------------------------------
!  ZIPF
!  K. Sjobak, BE-ABP/HSS
!  Last modified: 7/2-2017
!-----------------------------------------------------------------------
 2800 read(3,10020, end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2800 ! skip comment line
      
      if (ch(:4).eq.next) then
         call zipf_parseInputDone
         goto 110                  !Read next block or ENDE
      endif
      
      call zipf_parseInputline(ch)
      goto 2800                    !Read the next line of the ZIPF block

!-----------------------------------------------------------------------
!  SCATTER
!  K. Sjobak, V.K. Berglyd Olsen BE-ABP-HSS
!  Last modified: 29-08-2017
!-----------------------------------------------------------------------
 2900 continue
      ! We have a SCATTER block; let's allocate the memory for it!
      if (scatter_active) then
         write(lout,*) "ERROR while parsing SCATTER in fort.3"
         write(lout,*) "More than one SCATTER block encountered?"
         call prror(-1)
      end if
      call scatter_allocate
      
 2901 read(3,10020, end=1530, iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2901 ! skip comment line
      
      if (ch(:4).eq.next) then
         
         scatter_active = .true.

         if (scatter_seed1.eq.-1 .and. scatter_seed2.eq.-1) then
            write(lout,*) "ERROR while parsing SCATTER in fort.3"
            write(lout,*) "No SEED sets were specified"
            call prror(-1)
         endif
         
         if (scatter_debug) call scatter_dumpdata
         goto 110               !Read next block or ENDE
      endif
      
      if (ch(:5).eq."DEBUG") then
         scatter_debug = .true.
         write(lout,'(a)') "SCATTER> Scatter block debugging is ON."
         goto 2901
      endif
      
      call getfields_split( ch, getfields_fields, getfields_lfields,    &
     &     getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) call prror(51)
      if (scatter_debug) then
         write (lout,'(A,I4,A)')                                        &
     &        "SCATTER> Got a block, len=",                             &
     &        len(trim(ch)), ": '"// trim(ch)// "'"
         do ii=1,getfields_nfields
            write (lout,'(a,I4,A)')                                     &
     &           "SCATTER> Field(",ii,") ='"//                          &
     &           getfields_fields(ii)(1:getfields_lfields(ii))//"'"
         enddo
      endif

      ! ***** PARSE SCATTER ELEM STATEMENT *****
      if (ch(:4).eq."ELEM") then
         call scatter_parseElem(getfields_fields,getfields_lfields,     &
     &                          getfields_nfields)
      ! ***** PARSE SCATTER PRO STATEMENT *****
      else if (ch(:3).eq."PRO") then
         call scatter_parseProfile(getfields_fields,getfields_lfields,  &
     &                             getfields_nfields)
      ! ***** PARSE SCATTER GEN STATEMENT *****
      else if (ch(:3).eq."GEN") then
         call scatter_parseGenerator(getfields_fields,getfields_lfields,&
     &                               getfields_nfields)
      ! ***** PARSE SCATTER SEED STATEMENT *****
      else if (ch(:4).eq."SEED") then
         call scatter_parseSEED(getfields_fields,getfields_lfields,     &
     &                          getfields_nfields)
      else
         write(lout,'(a)') "SCATTER> ERROR, line type not recognized:"
         write(lout,'(a)') "SCATTER> '"//trim(ch)//"'"
         call prror(-1)
      endif
      
      goto 2901                 !Read the next line of the SCATTER block
      
!----------------------------------------------------------------------------
!     ENDE was reached; we're done parsing fort.3, now do some postprocessing.
!-----------------------------------------------------------------------------
  771 if(napx.ge.1) then
        if(e0.lt.pieni.or.e0.le.pma) call prror(27)
        if(nbeam.ge.1) parbe14=                                         &!hr05
     &(((((-one*crad)*partnum)/four)/pi)/emitnx)*c1e6                    !hr05
        gammar=pma/e0
        crad=(((two*crad)*partnum)*gammar)*c1e6                          !hr05
        emitx=emitnx*gammar
        emity=emitny*gammar
+if collimat
        remitx_dist=emitnx0_dist*gammar
        remity_dist=emitny0_dist*gammar
        remitx_collgap=emitnx0_collgap*gammar
        remity_collgap=emitny0_collgap*gammar
+ei
      endif
+if collimat
      if (.not.has_coll) then
         !Breaks at least DUMP (negative particle IDs) and DYNK (1-pass actions).
         write(lout,*) ""
         write(lout,*) "ERROR in parsing fort.3:"
         write(lout,*) "This is the collimation version of SixTrack,"
         write(lout,*) " but no COLL block was found,"
         write(lout,*) " not even one with do_coll = .false."
         write(lout,*) "Please use the non-collimation version!"
         call prror(-1)
      endif
+ei
      if(idp.eq.0.or.ition.eq.0.or.nbeam.lt.1) then
        do j=1,il   ! converting 6D lenses to 4D
          if (beam_expflag .eq. 1) then
             if (parbe(j,2) .gt. 0) then
               parbe(j,2)=zero
               parbe(j,1)=parbe(j,7)
               parbe(j,3)=parbe(j,10)
             endif
          else
             parbe(j,2)=zero
          endif
        enddo
      else
        do j=1,il
          if(parbe(j,2).gt.real(mbea,fPrec)) then
             write(lout,'(a,i5,a,i5,a,a16,a,i5)')                       &
     &            'ERROR: Requested ',                                  &
     &            int(parbe(j,2)), " slices for 6D beam-beam element"// &
     &            ' #',j, " named ", bez(j), ", maximum is mbea =",mbea
            parbe(j,2)=real(mbea,fPrec)
            call prror(-1) !Treat this warning as an error
         endif
        enddo
      endif
      if(iout.eq.0) return
      write(lout,10050)
      write(lout,10060)
      il1=il
      if(ncy2.eq.0) il1=il-1
      do 1435 k=1,il1
      if(abs(kz(k)).eq.12) then
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),phasc(k),xpl(k),   &
     &xrms(k),zpl(k),zrms(k)
        kz(k)=abs(kz(k))
        phasc(k)=phasc(k)*rad
      else
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),el(k),xpl(k),      &
     &xrms(k),                                                          &
     &zpl(k),zrms(k)
      endif
 1435 continue
      write(lout,10130)
      write(lout,10080)
      write(lout,10090) mper,(msym(k),k=1,mper)
      write(lout,10250) mblo,mbloz
      write(lout,10100)
      do 1450 l=1,mblo
      kk=mel(l)
      ll=kk/6
      if(ll.ne.0) then
        do 1440 l1=1,ll
          l2=(l1-1)*6+1
          l3=l2+5
          if(l2.eq.1) then
            write(lout,10260) l,bezb(l),kk,(beze(l,k),k=1,6)
          else
            write(lout,10270) (beze(l,k),k=l2,l3)
          endif
 1440   continue
        if(mod(kk,6).ne.0) then
          l4=ll*6+1
          write(lout,10270) (beze(l,k),k=l4,kk)
        endif
      else
        write(lout,10260) l,bezb(l),kk,(beze(l,k),k=1,kk)
      endif
 1450 continue
      write(lout,10120)
      mblozz=mbloz/5+1
      do 1480 k=1,mblozz
      k10=(k-1)*5
      if((mbloz-k10).eq.0) goto 1480
      do 1470 l=1,5
        if((k10+l).gt.mbloz) ic0(l)=' '
        if((k10+l).gt.mbloz) goto 1470
        icc=ic(k10+l)
        if(icc.gt.nblo) goto 1460
        ic0(l)=bezb(icc)
        goto 1470
 1460   ic0(l)=bez0(icc-nblo)
 1470 continue
      k11=k10+1
      write(lout,10280) k11,(ic0(l),l=1,5)
 1480 continue
      write(lout,10130)
 1490 if(idp.eq.0) goto 1500
      if(nbeam.ge.1) then !Write out with BB parameters
         if(beam_expflag .eq. 0) then  !The old BEAM format
            if(partnum.gt.zero) then !Beams have same charge
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,            &
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,       &
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            endif
            
         elseif (beam_expflag .eq. 1) then ! The new BEAM-EXPERT format
            if(partnum.gt.zero) then !Beams have same charge
               ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,            &
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,       &
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            endif
         else
            write(lout,'(a)') "ERROR in subroutine daten"
            write(lout,'(a)') "beam_expflag was", beam_expflag
            write(lout,'(a)') " expected 0 or 1. This is a BUG!"
            call prror(-1)
         endif
      else !No beam beam
        write(lout,10142) ncy,dp1,dppoff,tlen,pma,e0
      endif
      if(ncy2.eq.0) then
        write(lout,10143) harm,u0,phag,qs,alc
      else
        write(lout,*)
      endif
      if(beam_expflag .eq. 0) then
         if(ibb6d.eq.1) then
            write(lout,                                                 &
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    CROSSING_ANGLE',            &
     &'     CROSSING_PLANE     COUPLING_ANGLE'/t10,85('-')/)")
            do j=1,il
               if(parbe(j,2).gt.zero)                                   &
     &              write(lout,"(t10,a16,5x,i4,7x,d17.10,2x,d17.10)")   &
     &              bez(j),int(parbe(j,2)),parbe(j,1),parbe(j,3)
            enddo
         endif
         
      elseif(beam_expflag .eq. 1) then
         write(lout,                                                    &
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    XING_ANGLE',                &
     &'  XING_PLANE   HOR_SEP     VER_SEP        S11        S12      ', &
     &'  S22         S33         S34         S44         S13         ', &
     &'S14         S23         S24'/t10,200('-')/)")
         do j=1,il
            if(kz(j).eq.20.and.parbe(j,17).eq.1)then
               write(lout,                                              &
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,      &
     &2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,        &
     &1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")            &
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6),      &
     &parbe(j,7),parbe(j,8),parbe(j,9),parbe(j,10),parbe(j,11),         &
     &parbe(j,12),parbe(j,13),parbe(j,14),parbe(j,15),parbe(j,16)
            endif
         enddo
         write(lout,                                                    &
     &"(//,t30,'4D BEAM-BEAM ELEMENTS'/t30,24('-')//                    &
     &t10,'ELEMENT           #_OF_SLICES        S11   ',                &
     &'     S22       HOR_SEP     VER_SEP'/t10,80('-')/)")
         do j=1,il
            if (kz(j).eq.20.and.parbe(j,17).eq.0) then
               write(lout,                                              &
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")    &
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6)
            endif
         enddo
         
      else
         write(lout,'(a)') "ERROR in subroutine daten"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
      write(lout,10130)
 1500 continue
      write(lout,10150)
      nfb=nde(1)
      nac=nde(2)
      nft=numl-nde(2)
      if(numl.le.nde(2)) nft=0
      if(numl.le.nde(2)) nac=numl
      if(numl.le.nde(1)) nac=0
      if(numl.le.nde(1)) nfb=numl
      write(lout,10160) numl,numlr,nwr(4),nfb,nwr(1),nac,nwr(2),nft,    &
     &nwr(3),                                                           &
     &kanf,amp(1),rat,itco,dma,dmap,itqv,dkq,dqq
      write(lout,10170) itcro,dsm0,dech,de0,ded,dsi
      write(lout,10130)
      write(lout,10040)
      write(lout,10130)
      goto 1540
 1520 call prror(41)
 1530 call prror(42)
 1540 continue
+if vvector
      !Check that the number of particles is OK
      if(((2*mmac)*imc)*napx.gt.npart) call prror(54)                    !hr05
+ei

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      return
10000 format(11(a4,1x))
10010 format(a4,8x,a60)
10020 format(a)
10030 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
     &'OO  SIXTRACK-INPUT  OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10040 format(t10,21('O')/t10,2('O'),17x,2('O')/t10,                     &
     &'OO  PREPROCESSING  OO', /t10,2('O'),17x,2('O')/t10,21('O'))
10050 format(//131('-')//t43,'*** RING PARAMETERS ***'/)
10060 format(t30,'SINGLE ELEMENTS:'/'  NO   NAME  TYP      ',           &
     &' 1/RHO          STRENGTH          LENGTH           X-POS     ',  &
     &'     X-RMS            Y-PO          Y-RMS     ' /131('-'))
10080 format(/t30,'RINGSTRUCTURE:'//)
10090 format(t10,'NO. OF SUPERPERIODS AND SYMMETRY ' ,t50,i3,'   ',15i4,&
     &'   ')
10100 format(//131('-')//t30,'BLOCKSTRUCTURE:'/ t30,                    &
     &'(BLOCKTYP--NO. OF SINGLE ELEMENTS--SINGLE ELEMENT TYPES)'//)
!10110 format(t10,i3,' ---',i3,' --- ',30i3)
10120 format(//131('-')//t30,'BLOCKSTRUCTURE OF SUPERPERIOD:'//)
10130 format(/131('-')/)
10142 format(t30,'SYNCHROTRON OSCILLATIONS'//                           &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10143 format(                                                           &
     &t10,'HARMONIC NUMBER',t74,f6.0/                                   &
     &t10,'CIRCUMF. VOLTAGE   (MV)',t66,f14.9/                          &
     &t10,'EQUILIBRIUM PHASE     (DEG)',t66,f14.9/                      &
     &t10,'FREQUENCY (IN UNITS OF REVOLUTION-FREQ.) QS-LINEAR',         &
     &t66 ,f14.9/                                                       &
     &t10,'MOMENTUM COMPACTION',t66,f14.9/)
10150 format(//t43,'*** TRACKING PARAMETERS ***'/)
10160 format(t10,'NUMBER OF REVOLUTIONS  ',t48,i8/ t10,                 &
     &'NUMBER OF REVERSE-REVOLUTIONS',t48,i8/ t10,                      &
     &'TURNS PER COOR.-PRINTOUT',t48,i8/ t10,'FLAT BOTTOM UP TO TURN ', &
     &t48,i8/ t10,'TURNS PER PRINT ON DATASET',t48,i8/ t10,             &
     &'ACCELERATION UP TO TURN',t48,i8/ t10,'TURNS PER PRINT ON DATASET'&
     &,t48,i8/ t10,'FLAT TOP NUMBER OF TURNS',t48,i8/ t10,              &
     &'TURNS PER PRINT ON DATASET',t48,i8/ t10,                         &
     &'TRACKING START AT ELEMENT NO.',t48,i8/ t10,                      &
     &'INITIAL AMPLITUDE-H IN (MM)',t49,f7.3/ t10,                      &
     &'COUPLING  EPS-Y/EPS-X',t49,f7.3/ t10,                            &
     &'NUMBER OF C.-O. ITERATIONS ',t48,i8/ t10,                        &
     &'PRECISION OF C.-O. DEVIATION',t47,d10.3/ t10,                    &
     &'PRECISION OF C.-O. SLOPE   ',t47,d10.3/ t10,                     &
     &'NUMBER OF Q-ADJ. ITERATIONS',t48,i8/ t10,                        &
     &'CHANGE IN K-STRENGTH BY',t47,d10.3/ t10,                         &
     &'PRECISION OF Q-ADJUSTEMENT',t47,d10.3)
10170 format(t10,'NUMBER OF CHROMAT.-ADJ. ITER.',t48,i8/ t10,           &
     &'CHANGE IN SEX.-STRENGTH BY',t47,d10.3/ t10,                      &
     &'PRECISION OF CHROMAT.-ADJ.',t47,d10.3/ t10,                      &
     &'DP-INTERVAL F. CROMAT.-ADJ.',t47,d10.3/ t10,                     &
     &'DP-INTERVAL FOR DISPERSION',t47,d10.3/ t10,                      &
     &'PRECISION FOR C.-O. RMS',t47,d10.3/)
10180 format(t5/t10,a60)
10190 format(t10,'PROGRAM MODE : FREE FORMAT INPUT')
10200 format(t10,'PROGRAM MODE : FREE FORMAT INPUT --READ FROM ',       &
     &'EXTRA GEOMETRY STRENGTH FILE--')
10220 format(t10,i4,2(' ',d15.8),5x,2(' ',d15.8))
10250 format(t10,'NUMBER OF DIFFERENT BLOCKS',t50,i3/ t10,              &
     &'BLOCKS PER PERIOD',t49,i5//)
10290 format(t10,'MORE THAN ',i5,' COMBINATIONS SPECIFIED'/)
10300 format(//131('-')//t10,'DATA BLOCK COMBINATION OF ELEMENTS',      &
     &'  THE FOLLOWING ELEMENTS ARE RELATED IN STRENGTHS--->'/ t10,     &
     &'ELEMENT RELATED TO ELEMENT BY THE RATIO'/)
10320 format(//131('-')//t10,'DATA BLOCK APERTURE LIMITATIONS'/ /t10,   &
     &'NAME',16x,'TYP',5x,'APER_1',7x,'APER_2',8x,'APER_3',7x,          &
     &'APER_4',7x,'ANGLE',8x,'X_OFFSET',5x,'Y_OFFSET'/)
10340 format(t10,'NO CAVITIES SPECIFIED'/)
10350 format(//131('-')//t10,'DATA BLOCK ORGANISATION OF RANDOM NUMBERS'&
     &/5x,'|          |      OWN RANDOM NUMBERS      |      SAME RAN' , &
     &'DOM NUMBERS      |   SAME MULTIPOLECOEFFICIENTS  |'/131('-'))
10370 format(t10,'DESIRED TUNE TO ADJUST IS ZERO'/ t10,                 &
     &'DATA BLOCK TUNE ADJUSTMENT  IGNORED')
10380 format(t10,'HIGHER MULTIPOLES THAN 20-POLES ARE NOT ALLOWED' ,    &
     &' AND THEREFORE IGNORED')
10410 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
!10420 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
!     &'OO   NORMAL FORMS   OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10430 format(/5x,'No cut on random distribution'//)
10440 format(/5x,'Random distribution has been cut to: ',i4,' sigma.'//)
10500 format(//131('-')//t10,'SUMMARY OF DATA BLOCK ',a4,' INFOs')
10520 format(//131('-')//t10,'DATA BLOCK ',a4,' INFOs'/ /t10,           &
     &'NAME',20x,'TYPE',5x,'INSERTION POINT',4x,'SYNCH LENGTH [m]')
10070 format(1x,i3,1x,a16,1x,i3,1x,d17.10,1x,d17.10,1x,d17.10,1x,d14.7, &
     &1x,d13.6,1x,d14.7,1x,d13.6)
10210 format(t10,'DATA BLOCK MULTIPOLE COEFFICIENTS'/ t10,              &
     &'MULTIPOLE                    ',a16/t10,'RADIUS IN MM            '&
     &,f15.7/ t10,'BENDING STRENGTH IN MRAD',f15.7// t10,19x,'NORMAL',25&
     &x,'      SKEW '// t10,'      MEAN            RMS-VALUE     ',     &
     &'       MEAN            RMS-VALUE'/)
!10240 format(t10,a16,3(2x,d16.10),2x,i10)
10260 format(t4,i4,1x,a16,1x,i2,1x,6(1x,a16))
10270 format(t28,6(1x,a16))
10280 format(t3,i6,1x,5(a16,1x))
10310 format(t10,a16,10x,a16,6x,f20.15)
10330 format(t10,a16,4x,a2,7(1x,f12.4))
10360 format(5x,'| ELEMENT  |           ',a16,'           |           ',&
     &'    |               |               |               |')
10390 format(5x,'| ELEMENTS |                              |    ',a16,  &
     &'   |    ',a16,'   |               |               |')
10400 format(5x,'| ELEMENTS |                              |          ' &
     &,'     |               |    ',a16,'   |    ',a16,'   |')
10490 format(t10,a16,4x,a40,2x,1pe16.9)
10510 format(t10,a16,4x,i8,12x,i8,4x,1pe16.9)
10700 format(t10,'DATA BLOCK TROMBONE ELEMENT'/                         &
     &t10,'TROMBONE #      NAME'/)
10710 format(t22,i4,5x,a16)
10890 format(1x,'--> function ',i2,' of combo # ',i4,' of element',a16, &
     &'does not exist!')
10891 format(1x,'--> single element ',a16,' is a thick lens one!')
      end subroutine daten
      
      subroutine write4
!-----------------------------------------------------------------------
!     WRITE MODIFIED GEOMETRY FILE ON UNIT 4
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer ii,ikz
      real(kind=fPrec) rdum1,rdum2,rel1
      character(len=160)  ch
      character(len=320) ch1
      character(len=16) idat
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/ 
+ca parpro
+ca common
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ii=0
      rewind 2
 1    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
        goto 1
      elseif(ch(:4).eq.'SING') then
        write(4,*) ch
      else
        return
      endif
 2    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
      else
        ii=ii+1
        if(ch(:4).ne.'NEXT') then
          call intepr(1,1,ch,ch1)
+if fio
          read(ch1,*,round='nearest')                                   &
     & idat,ikz,rdum1,rdum2,rel1
+ei
+if .not.fio
          read(ch1,*) idat,ikz,rdum1,rdum2,rel1
+ei
          if(ikz.eq.11) then
            write(4,10000) idat,ikz,rdum1,rdum2,rel1
          else
            if(abs(rel1).le.pieni) then
              if(ncororb(ii).eq.0) then
                write(4,10000) idat,ikz,sm(ii),rdum2,rel1
              else
                write(4,10000) idat,ikz,sm(ii),ek(ii),rel1
              endif
            else
              write(4,10000) idat,ikz,rdum1,ek(ii),rel1
            endif
          endif
        else
          write(4,*) ch
          goto 3
        endif
      endif
      goto 2
 3    read(2,*,end=90) ch
      lineno2=lineno2+1
      write(4,*) ch
      goto 3
 90   continue
10000 format(a16,1x,i2,1x,d22.15,1x,d22.15,1x,d17.10)
      end
      subroutine intepr(i,j,ch,ch1)
!-----------------------------------------------------------------------
!     SUBROUTINE TO INTEPRET INPUT WITH CHARACTERS AND NUMBERS MIXED
!
!     I ... TYPE OF COMBINATION
!
!         1  LINE WITH 1 CHARACTERSTRING FOLLOWED BY NUMBERS
!         2  LINE WITH CHARACTERSTRINGS, IF THE FIRST 5 CHARACTERS
!            ARE BLANKS THIS IS INTERPRETED AS A BLANK CHARACTER
!         3  LINE WITH CHARACTERSTRINGS
!         4  LINE WITH 2 CHARACTERSTRINGS
!         5  LINE WITH 1 CHARACTERSTRING AND N*(NUMBER,CHA.STRING)
!         6  LINE WITH 1 NUMBER AND 2 CHARACTERSTRINGS
!         7  LINE WITH 1 NUMBER, 2 CHARACTERSTRINGS AND NUMBERS
!         8  LINE WITH 2 CHARACTERSTRINGS AND NUMBERS
!
!     J ... SKIP THE FIRST (J-1) CHARACTERS OF CHARACTERSTRING CH
!    CH ... INPUT CHARACTERSTRING
!   CH1 ... OUTPUT CHARACTERSTRING
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      implicit none
!ERIC
      integer i,i0,i1,i2,i3,i4,iev,ii,j
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      save
!-----------------------------------------------------------------------
+if bnlelens
!GRDRHIC
!GRD-042008
      ch1=""
!GRDRHIC
!GRD-042008
+ei
      i0=0
      i1=j
      i2=1
      i4=0
      do 10 ii=j,nchars
        if(i0.eq.0.and.ch(ii:ii).eq.' ') then
          if(i.eq.2.and.ii.eq.5.and.ch(:5).eq.'     ') then
            ch1(:4)=''' '' '
            i2=5
          endif
          i1=ii+1
          goto 10
        endif
        i0=1
        if(ch(ii:ii).eq.' ') then
          i4=i4+1
          iev=1
          if(mod(i4,2).eq.0) iev=0
          if(i.eq.1) goto 20
          if(i.eq.2.or.i.eq.3.or.i.eq.4.or. (i.eq.5.and.iev.eq.1.).or.  &
     &(i.eq.6.and.i4.ge.2).or. (i.eq.7.and.(i4.eq.2.or.i4.eq.3)).or.    &
     &(i.eq.8.and.i4.lt.3)) then
            i3=((i2+ii)-i1)+2                                            !hr05
            ch1(i2:i3)=''''//ch(i1:ii-1)//''' '
            if(i.eq.4.and.i4.eq.2) goto 30
            i2=i3+1
          endif
          if((i.eq.5.and.iev.eq.0).or. (i4.eq.1.and.(i.eq.6.or.i.eq.7)))&
     &then
            i3=(i2+ii)-i1                                                !hr05
            ch1(i2:i3)=ch(i1:ii)
            i2=i3+1
          endif
          if((i.eq.7.and.i4.gt.3).or.(i.eq.8.and.i4.eq.3)) goto 40
          i0=0
          i1=ii+1
        endif
   10 continue
      goto 30
   20 ch1(1:nchars+nchars)=''''//ch(i1:ii-1)//''''//ch(ii:nchars)//' / '
      return
   30 i3=i3+1
      ch1(i3:i3+2)=' / '
      return
   40 i3=i2+nchars+3-i1
      ch1(i2:i3)=ch(i1:nchars)//' / '
      return
      end
      
      subroutine initialize_element(ix,lfirst)
!-----------------------------------------------------------------------
!     K.Sjobak & A.Santamaria, BE-ABP/HSS
!     last modified: 23-12-2016
!     Initialize a lattice element with index elIdx,
!     such as done when reading fort.2 (GEOM) and in DYNK.
!     
!     Never delete an element from the lattice, even if it is not making a kick.
!     If the element is not recognized, do nothing (for now).
!     If trying to initialize an element (not lfirst) which is disabled,
!     print an error and exit.
!-----------------------------------------------------------------------

      use floatPrecision
      use dynk, only : dynk_elemdata
      use numerical_constants
      use crcoall
      implicit none
      
      integer, intent(in) :: ix
      logical, intent(in) :: lfirst

      integer im, izu, k, m, nmz, r0, r0a !needed to use multini

+ca parpro !needed for common
+ca common
+ca commonmn
+ca commontr
+ca commonxz
+ca comgetfields
+ca stringzerotrim
+ca elensparam
+ca wireparam

      !Temp variables
      integer i

!--Nonlinear Elements
! TODO: Merge these cases into 1 + subcases?
      if(abs(kz(ix)).eq.1) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)             ! Also done in envar() which is called from clorb()
                 smiv(1,i)=sm(ix)+smizf(i) ! Also done in program maincr
                 smi(i)=smiv(1,i)          ! Also done in program maincr
+ca stra01                                 ! Also done in trauthin()/trauthck()
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.2) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra02
               endif
            enddo
         endif
      elseif(abs(kz(ix)).eq.3) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra03
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.4) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra04
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.5) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra05
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.6) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra06
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.7) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra07
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.8) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra08
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.9) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra09
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.10) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
+ca stra10
               endif
            enddo
         endif

!--Multipoles
      elseif(kz(ix).eq.11) then
         
         !MULT support removed until we have a proper use case.
!c$$$         if (lfirst) then
!c$$$            dynk_elemdata(ix,1) = el(ix) !Flag for type
!c$$$            dynk_elemdata(ix,2) = ed(ix) !Bending strenght
!c$$$            dynk_elemdata(ix,3) = ek(ix) !Radius
!c$$$         else
!c$$$            el(ix) = dynk_elemdata(ix,1)
!c$$$            dynk_elemdata(ii,2) = ed(ii) !Updated in dynk_setvalue
!c$$$            ek(ii) = dynk_elemdata(ix,3)
!c$$$         end if
         
         ! Moved from daten():
         if (abs(el(ix)+one).le.pieni) then
            dki(ix,1) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         else if(abs(el(ix)+two).le.pieni) then
            dki(ix,2) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         endif
         !Otherwise, i.e. when el=0, dki(:,1) = dki(:,2) = dki(:,3) = 0.0

         !MULT support removed until we have a proper use case.
!c$$$         !All multipoles:
!c$$$         if(.not.lfirst) then
!c$$$            do i=1,iu
!c$$$               if ( ic(i)-nblo.eq.ix ) then
!c$$$                  if(ktrack(i).eq.31) goto 100 !ERROR
!c$$$                  !--Initialize smiv as usual
!c$$$                  sm(ix)=ed(ix)
!c$$$                  smiv(m,i)=sm(ix)+smizf(i)
!c$$$                  smi(i)=smiv(m,i)
!c$$$
!c$$$                  !--Using the right izu & setting aaiv, bbiv (see multini)
!c$$$                  izu = dynk_izuIndex(ix)
!c$$$+ca multini !Also in program maincr()
!c$$$ 150              continue ! needs to be after a multini block
!c$$$
!c$$$                  ! From trauthin()&trauthck() (they are identical)
!c$$$                  r0=ek(ix)
!c$$$                  nmz=nmu(ix)
!c$$$                  if(abs(r0).le.pieni.or.nmz.eq.0) then
!c$$$                     if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                    abs(dki(ix,2)).le.pieni) then
!c$$$C                       ktrack(i)=31
!c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
!c$$$     &                       abs(dki(ix,2)).le.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                          ktrack(i)=33
!c$$$+ca stra11
!c$$$                        else
!c$$$C                          ktrack(i)=35
!c$$$+ca stra12
!c$$$                        endif
!c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                       abs(dki(ix,2)).gt.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=37
!c$$$+ca stra13
!c$$$                        else
!c$$$C                            ktrack(i)=39
!c$$$+ca stra14
!c$$$                        endif
!c$$$                     endif
!c$$$                  else
!c$$$                     if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                    abs(dki(ix,2)).le.pieni) then
!c$$$C                        ktrack(i)=32
!c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
!c$$$     &                       abs(dki(ix,2)).le.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=34
!c$$$+ca stra11
!c$$$                        else
!c$$$C                           ktrack(i)=36
!c$$$+ca stra12
!c$$$                        endif
!c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                       abs(dki(ix,2)).gt.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=38
!c$$$+ca stra13
!c$$$                        else
!c$$$C                           ktrack(i)=40
!c$$$+ca stra14
!c$$$                        endif
!c$$$                     endif
!c$$$                  endif
!c$$$               endif
!c$$$            enddo
!c$$$         endif

!--Cavities (ktrack = 2 for thin)
      elseif(abs(kz(ix)).eq.12) then
         !Moved from daten
         phasc(ix) = el(ix)
         el(ix) = zero
         dynk_elemdata(ix,3) = phasc(ix)
         if (.not.lfirst) then

            ! Doesn't work, as i is not initialized here.
            !if (.not.ktrack(i).eq.2) goto 100 !ERROR
            
            phasc(ix) = phasc(ix)*rad
            
            hsyc(ix) = ((two*pi)*ek(ix))/tlen         ! daten SYNC block
            hsyc(ix)=(c1m3*hsyc(ix))*real(itionc(ix),fPrec) ! trauthin/trauthck
         endif
!--BEAM-BEAM
      elseif(kz(ix).eq.20) then
         if (lfirst) then
            ! Only for old-style BEAM-BEAM lenses
            ! if DYNK-ified, there needs to be checks for parbeam_exp as well,
            ! as in this case modifying ed/ek/el and then calling initialize_element
            ! would be neccessary...
            ! Note that the BEAM::EXPERT block input checker relies on the data from
            ! ed/ek/el has been moved to parbe/ptnfac.
            ! For DYNKification of BEAM, I think lots of the code from
            ! trauthin/trauthck needs to be copied here?
            ptnfac(ix)=el(ix)
            el(ix)=zero

            parbe(ix,5) = ed(ix)
            ed(ix)=zero
            parbe(ix,6) = ek(ix)
            ek(ix)=zero
         endif
!--Crab Cavities
!   Note: If setting something else than el(),
!   DON'T call initialize_element on a crab, it will reset the phase to 0.
      elseif(abs(kz(ix)).eq.23) then
         !Moved from daten()
         crabph(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 2
      elseif(abs(kz(ix)).eq.26) then
         !Moved from daten()
         crabph2(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 3
      elseif(abs(kz(ix)).eq.27) then
         !Moved from daten()
         crabph3(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 4
      else if(abs(kz(ix)).eq.28) then
         !Moved from daten()
         crabph4(ix)=el(ix)
         el(ix)=zero
!--Wire
      else if(kz(ix).eq.15) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
!--e-lens
      else if(kz(ix).eq.29) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
      endif

      return

      !Error handlers
 100  continue
      write (lout,*) "ERROR in initialize_element, tried to set"
      write (lout,*) "the strength of an element which is disabled."
      write (lout,*) "bez = ", bez(ix)
      call prror(-1)

      end subroutine initialize_element

+if crlibm
      
      subroutine splitfld(errno,nunit,lineno,nfields,nf,chars,fields)
      use floatPrecision
      use crcoall
      implicit none
      integer errno,nunit,lineno,nfields,nf,i,j,k,l,lf
      character(len=*) chars
      character(len=*) fields(*)
      character(len=999) localstr
!     This routine splits the chars input into space separated
!     fields, up to nfields maximum. It returns the no of
!     fields in nf. All spaces are ignored but treated as separators.
!     A / is a line terminator as provided in ch1 typically.
!     This corresponds to Fortran treatment with an * format spec.
            
      j=0
      nf=0
      do i=1,nfields
        fields(i)=' '
         
        ! Get the length we can use to store a field,
        ! should be equal to maxf in the calling function
        lf=len(fields(i))

 8889   k=0   !Index into the current field; goto label for new field or no field yet
 8888   j=j+1 !Index into the input array; goto label for reading another character
        ! Check that we stay within the given length of chars
        if (j.gt.len(chars)) then
          errno=1
          go to 8887
        endif

        !Don't start a new field before we hit a non-space
        if (k.eq.0.and.chars(j:j).eq.' ') go to 8888

        if (chars(j:j).ne.' '.and.chars(j:j).ne.'/') then
          !We have a field
          k=k+1
          if (k.ge.lf) then
            !Field is too long;
            ! remember that the last position (#lf in FORTRAN, lf-1 in C)
            ! is reseved for a \0, to be used in the C code.
            do j=1,nf
              l=len(fields(j))
              localstr=fields(j)(1:l)
              write(lout,*) 'splitfld:'//localstr(1:lf)//':'
            enddo
            errno=2
            call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
          endif
          fields(i)(k:k)=chars(j:j)
          go to 8888
        else
          if (chars(j:j).eq.'/') then
! we are all through but may have a field
            if (k.ne.0) nf=nf+1
! Eric for debug
!     do j=1,nf
!       l=len(fields(j)
!       localstr=fields(j)(1:l)
!       write(*,*) 'splitfld:'//localstr)//':'
!     enddo
            return
          else
! Must have a space, field separator
            nf=nf+1
          endif
        endif
      enddo
      
 8890 continue
! If we get here we have a problem unless there
! is nothing left but ' '*/
 8886 j=j+1
      if (j.gt.len(chars)) go to 8887
      if (chars(j:j).eq.'/') return
      if (chars(j:j).eq.' ') go to 8886
      errno=3
 8887 continue
! Eric for debug
      do j=1,nf
        l=len(fields(j)) 
        localstr=fields(j)(1:l)
        write(lout,*) 'splitfld:'//localstr//':'
      enddo
      call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      end subroutine splitfld

      real(kind=fPrec) function fround(errno,fields,f)
      use floatPrecision
      implicit none
      integer maxf
      ! MAXF be kept in sync with maxf in various routines
      ! We maybe should use len(field(f)) here, like is done in splitfld...
      parameter (maxf=30)
      integer errno,f
      character(len=*) fields(*)
      real(kind=real64) round_near,value
      real(kind=real64) ftemp
      ftemp=round_near(errno,maxf,fields(f))
      fround=real(ftemp,fPrec)

      if (errno.ne.0) then
        value=fround
        call rounderr(errno,fields,f,value)
      endif
      return
      end function fround
      
      subroutine rounderr(errno,fields,f,value)
      use floatPrecision
      use crcoall
      implicit none
      integer nchars,nofields
      integer errno,nfields,f,l
      character(len=*) fields(*)
      character(len=999) localstr
      real(kind=fPrec) value

      write (lout,10000)
      write (lout,*) 'Data Input Error (probably in subroutine daten)'
      write (lout,*) 'Overfow/Underflow in strtod()'
      write (lout,*) 'Errno: ',errno
      l=len(fields(f))
      localstr=fields(f)(1:l)
      write (lout,*) 'f:fieldf:',f,':'//localstr
      write (lout,*) 'Function fround (rounderr) returning:',value
      
      call prror(-1)
      
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
      return
      end subroutine rounderr
      
      subroutine spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
      use crcoall
      implicit none
      integer errno,nunit,lineno,nfields,nf,lf,l
      character(len=*) chars
      character(len=999) localstr
      write (lout,10000)
      write (lout,*) 'Data Input Error (probably in subroutine daten)'
      write (lout,*) 'Reading unit no (fort.)',nunit,' Line',lineno
      l=len(chars)
      localstr=chars(1:l)
      write (lout,*) 'Input line:'//localstr//':'
      if (errno.eq.1) then
        write (lout,*)                                                     &
     &  'Input string too long, exceeds',len(chars),' characters'
      endif
      if (errno.eq.2) then
        write (lout,*)                                                     &
     &  'Field too long, exceeds',lf,' characters'
      endif
      if (errno.eq.3) then
        write (lout,*)                                                     &
     &  'Too many input fields, maximum of',nfields,' exceeded'
      endif
      
      call prror(-1)
      
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      end subroutine spliterr
      
      integer function dtostr(x,results)
! Uses the dtoa_c.c version of dtoa via the dtoaf.c interface in
! crlibm
      use floatPrecision
      use crcoall
      implicit none
      real(kind=fPrec) x
      character(len=24) results
      integer dtoaf 
      integer ilen,mode,ndigits,decpoint,mysign
      integer i,l,d,e
      character(len=1) str(17)
      character(len=24) lstr
      character(len=3) e3
      
      mode=2
      ndigits=17
      ilen=dtoaf(x,mode,ndigits,decpoint,mysign,str(1),1)
      if (ilen.le.0.or.ilen.gt.17) then
! Always returns 17 or less characters as requested
      write (lout,10000)
      write (lout,*) 'Routine dtoa[f] returned string length ',ilen
      write (lout,*) 'Error from dtostr, string length not 17'
      call prror(-1)
      
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      endif
      lstr=' '
      do i=1,ilen
        lstr(i:i)=str(i)
      enddo
! Now try my formatting
      d=decpoint
      e=0
      l=1
      lstr=' '
      if (mysign.ne.0) then
        lstr(l:l)='-'
      endif
      if (decpoint.eq.9999) then
! Infinity or Nan
        do i=1,ilen
          lstr(l+i:l+i)=str(i)
        enddo
      else
! Pad with zeros
        do i=ilen+1,17
          str(i)='0'
        enddo
        if (decpoint.le.0) then
          e=decpoint-1
          d=1
        else
! I am using 17 as decision point to avoid dddd.e+eee
! but rather d.ddde+eee
          if (decpoint.ge.17) then
            e=decpoint-1
            d=1
          else
            d=decpoint
          endif
        endif
! and copy with the decimal point
        do i=1,17
          lstr(l+i:l+i)=str(i)
          if (i.eq.d) then
            l=l+1
            lstr(l+i:l+i)='.'
          endif
        enddo
! and add exponent e+/-nnn
        l=20
        lstr(l:l)='e'
        l=21
        lstr(l:l)='+'
        if (e.lt.0) then
          lstr(l:l)='-'
          e=-e
        endif
        l=22
        write (e3,'(I3.3)') e
        lstr(l:l+2)=e3(1:3)
      endif  
      results=lstr(1:24)
      dtostr=24
      return
      end function dtostr
      
+ei ! END of crlibm-specific functions
      
      subroutine wzset
!  *********************************************************************
!
!  This subroutine must be called before subroutine WZSUB can be used to
!  compute values of the complex error function w(z).
!
!  Parameters xcut and ycut specify the opposite corners (xcut,0) and
!  (0,ycut) of the rectangle inside which interpolation is to be used
!  by subroutine WZSUB.
!
!  Parameter h is the side of the squares of the interpolation grid.
!
!  Parameters nx and ny must be set to the nearest integers to xcut/h
!  and ycut/h respectively (or to larger values).
!
!  Calls MYWWERF new version of (CERN library) WWERF (C335)
!
!  (G.A.Erskine, 29.09.1995)
!
!  *********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer i,j,k
      real(kind=fPrec) wi,wr,x,y
+ca parpro
+ca parbeam
      save
!-----------------------------------------------------------------------
      hrecip = one/h
      kstep = nx+2
      k = 0
      do 2 j=0,ny+1
         do 1 i=0,nx+1
            k = k+1
            x=real(i,fPrec)*h                                                  !hr05
            y=real(j,fPrec)*h                                                  !hr05
            call mywwerf(x,y,wr,wi)
            wtreal(k)=wr
            wtimag(k)=wi
 1       continue
 2    continue
      end subroutine wzset

      subroutine mywwerf(x,y,wr,wi)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer n
      real(kind=fPrec) c,c1,c2,c3,c4,hf,p,rr,ri,sr0,sr,si,tr,ti,vi,vr,  &
     &wi,wr,x,xa,xl,y,ya,zhi,zhr,z1,z10
      parameter (z1=one,hf=z1/two,z10=c1e1)
      parameter (c1=74.0_fPrec/z10,c2=83.0_fPrec/z10)
      parameter (c3=z10/32.0_fPrec,c4=16.0_fPrec/z10)
!     parameter (c=1.12837916709551257d0,p=(2d0*c4)**33)
      parameter (c=1.12837916709551257_fPrec)
      parameter (p=46768052394588893.3825_fPrec)
      dimension rr(37),ri(37)
      save
!-----------------------------------------------------------------------
      xa=abs(x)
      ya=abs(y)
      if(ya.lt.c1.and.xa.lt.c2) then
!        zh=dcmplx(ya+c4,xa)
        zhr=ya+c4
        zhi=xa
        rr(37)=zero
        ri(37)=zero
        do n=36,1,-1
!          t=zh+n*dconjg(r(n+1))
          tr=zhr+real(n,fPrec)*rr(n+1)                                         !hr05
          ti=zhi-real(n,fPrec)*ri(n+1)                                         !hr05
!          r(n)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(n)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(n)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
        xl=p
        sr=zero
        si=zero
        do n=33,1,-1
          xl=c3*xl
!          s=r(n)*(s+xl)
          sr0=rr(n)*(sr+xl)-ri(n)*si
          si=rr(n)*si+ri(n)*(sr+xl)
          sr=sr0
        enddo
!        v=c*s
        vr=c*sr
        vi=c*si
      else
        zhr=ya
        zhi=xa
        rr(1)=zero
        ri(1)=zero
        do n=9,1,-1
!          t=zh+n*dconjg(r(1))
          tr=zhr+real(n,fPrec)*rr(1)                                           !hr05
          ti=zhi-real(n,fPrec)*ri(1)                                           !hr05
!          r(1)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(1)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(1)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
!        v=c*r(1)
        vr=c*rr(1)
        vi=c*ri(1)
      endif
      if(ya.eq.zero) then                                                 !hr05
!        v=dcmplx(exp(-xa**2),dimag(v))
        vr=exp_mb(-one*xa**2)                                            !hr05
      endif
      if(y.lt.zero) then
!        v=2*exp(-dcmplx(xa,ya)**2)-v
        vr=(two*exp_mb(ya**2-xa**2))*cos_mb((two*xa)*ya)-vr              !hr05
        vi=(-two*exp_mb(ya**2-xa**2))*sin_mb((two*xa)*ya)-vi             !hr05
        if(x.gt.zero) vi=-one*vi                                          !hr05
      else
        if(x.lt.zero) vi=-one*vi                                          !hr05
      endif
      wr=vr
      wi=vi
      return
      end
+dk stringhandling
      subroutine getfields_split( tmpline, getfields_fields,            &
     &         getfields_lfields, getfields_nfields, getfields_lerr)
!
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak and A.Santamaria, BE-ABP-HSS
!     last modified: 24-02-2015
!     parse a line and split it into its fields
!       fields are returned as 0-terminated and padded string
!     always in main code
! input:
!  tmpline: usually line read in from fort.2 or fort.3. Values must be 
!           separated by spaces
! output:
!  array of values with 
!   getfields_fields(i):  (char) value of field
!   getfields_lfields(i): (int) length of field
!   getfields_nfields:    (int) number of fields
!   getfields_lerr:       (logical)
!-----------------------------------------------------------------------
!
      use crcoall
      implicit none
+ca comgetfields
      
      character tmpline*(getfields_l_max_string-1) !nchars in daten is 160

      intent(in) tmpline
      intent(out) getfields_fields, getfields_lfields,                  &
     &     getfields_nfields, getfields_lerr
      
!     runtime variables
      integer ii, jj
      logical lchar
      integer lenstr, istart

!     initialise output variables
      getfields_lerr = .false.
      getfields_nfields=0
      do ii=1,getfields_n_max_fields
         do jj=1,getfields_l_max_string
            getfields_fields(ii)(jj:jj) = char(0) ! ZERO terminate/pad
         enddo
         getfields_lfields(ii)=0
      enddo

!     parse the line
      lchar = .false.
      do ii=1, getfields_l_max_string-1 !For \0 termination
         if ( tmpline(ii:ii) .eq. ' ' ) then
!           blank char
            if ( lchar ) then
!              end of a string: record it
               getfields_lfields(getfields_nfields)          = lenstr
               getfields_fields (getfields_nfields)                     &
     &              (1:getfields_lfields(getfields_nfields)) =          &
     &              tmpline(istart:                                     &
     &               istart+getfields_lfields(getfields_nfields))
               lchar = .false.
            endif
         else
!           non-blank char
            if ( .not. lchar ) then
!              a new what starts
               getfields_nfields = getfields_nfields +1
               if ( getfields_nfields.gt.getfields_n_max_fields ) then
                  write (lout,*)'error! too many fields in line:'
                  write (lout,*) tmpline
                  write (lout,*)'please increase getfields_n_max_fields'
                  getfields_lerr = .true.
                  exit !Break do
               endif
               istart = ii
               lchar = .true.
               lenstr = 0
            endif
            lenstr = lenstr+1
         endif
      enddo

      end subroutine getfields_split

      function stringzerotrim(instring)
!----------------------------------------------------------------------------
!     K. Sjobak, BE-ABP/HSS
!     last modified: 30-10-2014
!     Replace "\0" with ' ' in strings.
!     Usefull before output, else "write (*,*)" will actually write all the \0s
!
!     Warning: Do not add any write(*,*) inside this function:
!     if this function is called by a write(*,*) and then does a write,
!     the program may deadlock!
!----------------------------------------------------------------------------
      implicit none
+ca comgetfields
+ca stringzerotrim
      character(len=stringzerotrim_maxlen) instring
      intent(in) instring
      
      integer ii
      
      do ii=1,stringzerotrim_maxlen
         if ( instring(ii:ii) .ne. char(0) ) then
            stringzerotrim(ii:ii) = instring(ii:ii)
         else 
            stringzerotrim(ii:ii) = ' '
         end if
      end do
      stringzerotrim = trim(stringzerotrim)

      end function stringzerotrim


+dk ranecu
subroutine ranecu(rvec,len,mcut)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer i,is1,is2,iseed1,iseed2,iz,j,k,len,mcut
      real(kind=fPrec) rvec0,rvec,pi,r
      dimension rvec(*),r(2)
      data iseed1,iseed2 / 12345, 67890 /
      save
!-----------------------------------------------------------------------
      pi = four*atan_mb(one)
!     DO 100 I = 1,LEN
      i=1
   10 do 20 j = 1,2
        k = iseed1/53668
        iseed1 = 40014*(iseed1-k*53668) - k*12211
        if (iseed1.lt.0) iseed1 = iseed1+2147483563
        k = iseed2/52774
        iseed2 = 40692*(iseed2-k*52774) - k*3791
        if (iseed2.lt.0) iseed2 = iseed2+2147483399
        iz = iseed1-iseed2
        if (iz.lt.1) iz = iz+2147483562
        r(j) = real(iz,fPrec)*4.656613e-10_fPrec                                     !hr05
   20 continue

      if (mcut.ge.0) then !mcut = -1 => Generate uniform numbers!
!     Convert r(1), r(2) from U(0,1) -> rvec0 as Gaussian with cutoff mcut (#sigmas):
         rvec0 = sqrt(((-one*two)*log_mb(r(1))))*cos_mb((two*pi)*r(2))      !hr05
      else if (mcut.eq.-1) then
         rvec0 = r(1)
      end if
      
      if(abs(rvec0).le.real(mcut,fPrec).or.mcut.eq.0.or.mcut.eq.-1) then
        rvec(i) = rvec0
        i=i+1
      endif
      if(i.le.len) goto 10
!     RVEC(I) = ((-TWO*LOG(R(1)))**HALF)*COS(TWO*PI*R(2))
! 100 CONTINUE
      return
      entry recuin(is1,is2)
      iseed1 = is1
      iseed2 = is2
      return
      entry recuut(is1,is2)
      is1 = iseed1
      is2 = iseed2
      return
end subroutine ranecu

+dk envars
subroutine envars(j,dpp,rv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei
      implicit none
      integer i,ih,j,kz1,l,ll
      real(kind=fPrec) aek,afok,as3,as4,as6,co,dpd,dpp,dpsq,fi,fok,fok1,&
     &fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoc,rhoi,rv,si,siq,sm1,         &
     &sm12,sm2,sm23,sm3,sm5,sm6,wf,wfa,wfhi
+if .not.vvector
      integer jm,k,m,na,ne
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      dpd=one+dpp
      dpsq=sqrt(dpd)
      do 190 i=1,il
        do ll=1,6
          do l=1,2
            al(ll,l,j,i)=zero
            as(ll,l,j,i)=zero
+if .not.vvector
            at(ll,l,j,i)=zero
            a2(ll,l,j,i)=zero
+ei
          enddo
        enddo
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
        goto(10,30,90,50,70,80,120,170,180),kz1
        goto 190

!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   10   do l=1,2
          al(1,l,j,i)=one
          al(2,l,j,i)=el(i)
          al(3,l,j,i)=zero
          al(4,l,j,i)=one
          as(6,l,j,i)=((-one*rv)*al(2,l,j,i))/c2e3                         !hr05
        end do

        as(1,1,j,i)=(el(i)*(one-rv))*c1e3                                !hr05
        goto 190

!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   30   ih=1
   40   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        fok1=(tan_mb(fok*half))/rho
        si=sin_mb(fok)
        co=cos_mb(fok)
        al(1,ih,j,i)=one
        al(2,ih,j,i)=rho*si
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
        al(5,ih,j,i)=((-one*dpp)*((rho*(one-co))/dpsq))*c1e3             !hr05
        al(6,ih,j,i)=((-one*dpp)*((two*tan_mb(fok*half))/dpsq))*c1e3     !hr05
        sm1=cos_mb(fok)
        sm2=sin_mb(fok)*rho
        sm3=(-one*sin_mb(fok))/rho                                       !hr05
        sm5=((-one*rho)*dpsq)*(one-sm1)                                  !hr05
        sm6=((-one*sm2)*dpsq)/rho                                        !hr05
        sm12=el(i)-sm1*sm2
        sm23=sm2*sm3
        as3=(-one*rv)*(((dpp*rho)/(two*dpsq))*sm23+sm5)                  !hr05
        as4=((-one*rv)*sm23)/c2e3                                        !hr05
        as6=((-one*rv)*(el(i)+sm1*sm2))/c4e3                             !hr05
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12+      &!hr05
     &dpp*(el(i)-sm2)))*c1e3                                             !hr05
        as(2,ih,j,i)=fok1*as3-rv*((dpp/((two*rho)*dpsq))*sm12+sm6)       !hr05
        as(3,ih,j,i)=as3
        as(4,ih,j,i)=as4+(two*as6)*fok1                                  !hr05
        as(5,ih,j,i)=(as6*fok1*2+fok1*as4)-(rv*sm12)/(c4e3*rho**2)       !hr05
        as(6,ih,j,i)=as6
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        g=tan_mb(fok*half)/rho
        gl=el(i)*g
        al(1,ih,j,i)=one-gl
        al(2,ih,j,i)=el(i)
        al(3,ih,j,i)=(-one*g)*(two-gl)                                   !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
        as6=((-one*rv)*al(2,ih,j,i))/c2e3                                !hr05
        as(4,ih,j,i)=((-one*two)*as6)*fok1                               !hr05
        as(5,ih,j,i)=as6*fok1**2                                         !hr05
        as(6,ih,j,i)=as6
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   50   ih=1
   60   fok=(el(i)*ed(i))/dpsq                                           !hr05
        if(abs(fok).le.pieni) goto 10
        rho=(one/ed(i))*dpsq
        si=sin_mb(fok)
        co=cos_mb(fok)
        rhoc=(rho*(one-co))/dpsq                                         !hr05
        siq=si/dpsq
        al(1,ih,j,i)=co
        al(2,ih,j,i)=rho*si
        al(3,ih,j,i)=(-one*si)/rho                                       !hr05
        al(4,ih,j,i)=co
        al(5,ih,j,i)=((-one*dpp)*rhoc)*c1e3                              !hr05
        al(6,ih,j,i)=((-one*dpp)*siq)*c1e3                               !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12 +     &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))*c1e3                                    !hr05
        as(2,ih,j,i)=(-one*rv)*((dpp/((two*rho)*dpsq))*sm12-dpd*siq)     !hr05
        as(3,ih,j,i)=(-one*rv)*(((dpp*rho)/(two*dpsq))*sm23-dpd*rhoc)    !hr05
        as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=((-one*rv)*sm12)/(c4e3*rho**2)                      !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
        al(1,ih,j,i)=one
        al(2,ih,j,i)=el(i)
        al(3,ih,j,i)=zero
        al(4,ih,j,i)=one
        as(6,ih,j,i)=((-one*rv)*al(2,ih,j,i))/c2e3                       !hr05
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   70   ih=2
        goto 40
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 60
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   90   fok=ek(i)/(one+dpp)
        aek=abs(fok)
        if(abs(fok).le.pieni) goto 10
        ih=0
        hi=sqrt(aek)
        fi=el(i)*hi
        if(fok.gt.zero) goto 110
  100   ih=ih+1
        al(1,ih,j,i)=cos_mb(fi)
        hi1=sin_mb(fi)
        al(2,ih,j,i)=hi1/hi
        al(3,ih,j,i)=(-one*hi1)*hi                                       !hr05
        al(4,ih,j,i)=al(1,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv))*c1e3                               !hr05
        as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-one*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  110   ih=ih+1
        hp=exp_mb(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        if(ih.eq.1) goto 100
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  120   ih=0
        fokq=ek(i)
  130   wf=ed(i)/dpsq
        fok=fokq/(dpd)-wf**2                                             !hr05
        if(abs(fok).le.pieni) goto 10
        afok=abs(fok)
        hi=sqrt(afok)
        fi=hi*el(i)
        if(fok.gt.zero) goto 160
  140   ih=ih+1
        si=sin_mb(fi)
        co=cos_mb(fi)
        wfa=((wf/afok)*(one-co))/dpsq                                    !hr05
        wfhi=((wf/hi)*si)/dpsq                                           !hr05
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
        al(3,ih,j,i)=(-one*si)*hi                                        !hr05
        al(4,ih,j,i)=co
        al(5,ih,j,i)=((-one*wfa)*dpp)*c1e3                               !hr05
        al(6,ih,j,i)=((-one*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(el(i)*(one-rv)-((rv*((dpp**2/(four*dpd))*sm12+    &!hr05
     &dpp*(el(i)-al(2,ih,j,i))))/afok)*wf**2)*c1e3                       !hr05
        as(2,ih,j,i)=(-one*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
        as(3,ih,j,i)=(-one*rv)*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-   &!hr05
     &dpd*wfa)                                                           !hr05
        as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=(((-one*rv)*sm12)*afok)/c4e3                        !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
        hp=exp_mb(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=el(i)
        if(abs(hi).le.pieni) goto 150
        al(2,ih,j,i)=hs/hi
  150   al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
        as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
        hp=exp_mb(fi)
        hm=one/hp
        hc=(hp+hm)*half
        hs=(hp-hm)*half
        al(1,ih,j,i)=hc
        al(2,ih,j,i)=hs/hi
        al(3,ih,j,i)=hs*hi
        al(4,ih,j,i)=hc
        wfa=((wf/afok)*(one-hc))/dpsq                                    !hr05
        wfhi=((wf/hi)*hs)/dpsq                                           !hr05
        al(5,ih,j,i)= (wfa*dpp)*c1e3                                     !hr05
        al(6,ih,j,i)=((-one*wfhi)*dpp)*c1e3                              !hr05
        sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
        sm23=al(2,ih,j,i)*al(3,ih,j,i)
        as(1,ih,j,i)=(((rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-        &!hr05
     &al(2,ih,j,i))))/afok)*wf**2+el(i)*(one-rv))*c1e3                   !hr05
        as(2,ih,j,i)=(-one*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
        as(3,ih,j,i)=rv*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-dpd*wfa)   !hr05
        as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
        as(5,ih,j,i)=((rv*sm12)*afok)/c4e3                               !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        ih=ih+1
        if(ih.gt.2) ih=1
        aek=abs(ek(i)/dpd)
        hi=sqrt(aek)
        fi=hi*el(i)
        si=sin_mb(fi)
        co=cos_mb(fi)
        al(1,ih,j,i)=co
        al(2,ih,j,i)=si/hi
        al(3,ih,j,i)=(-one*si)*hi                                        !hr05
        al(4,ih,j,i)=co
        as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-one*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/ &!hr05
     &c4e3                                                               !hr05
        as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
        fokq=-one*ek(i)                                                  !hr05
        goto 130
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   rhoi=ed(i)/dpsq
        fok=rhoi*tan_mb((el(i)*rhoi)*half)                               !hr05
        al(1,1,j,i)=one
        al(2,1,j,i)=zero
        al(3,1,j,i)=fok
        al(4,1,j,i)=one
        al(1,2,j,i)=one
        al(2,2,j,i)=zero
        al(3,2,j,i)=-one*fok                                             !hr05
        al(4,2,j,i)=one
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
+if .not.vvector
      do 220 k=1,mblo
        jm=mel(k)
        do 210 m=1,jm
          na=mtyp(k,m)
          ne=mtyp(k,jm-m+1)
          do 200 l=1,2
            at(1,l,j,na)=as(1,l,j,ne)
            at(2,l,j,na)=as(2,l,j,ne)
            at(3,l,j,na)=as(3,l,j,ne)
            at(4,l,j,na)=as(4,l,j,ne)
            at(5,l,j,na)=as(5,l,j,ne)
            at(6,l,j,na)=as(6,l,j,ne)
            a2(1,l,j,na)=al(1,l,j,ne)
            a2(2,l,j,na)=al(2,l,j,ne)
            a2(3,l,j,na)=al(3,l,j,ne)
            a2(4,l,j,na)=al(4,l,j,ne)
            a2(5,l,j,na)=al(5,l,j,ne)
            a2(6,l,j,na)=al(6,l,j,ne)
  200     continue
  210   continue
  220 continue
+ei
      return
end subroutine envars

+dk envada
      subroutine envada
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
  use numerical_constants
      implicit none
      integer i,ien,ih,ip,kz1,l,idaa
      real(kind=fPrec) dare,result
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commond1
+ca commond2
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
+ca dainicom
!FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
!FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
!FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
!FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
!FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
!FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
!FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
!FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
!FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
!FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
!FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
!FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
!FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
!FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
!FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
!FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
!FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
!FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
!FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
!FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
!FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
!FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
!FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
!FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX  DPD=ONE+DPDA ;
!FOX  DPSQ=SQRT(DPD) ;
      do 220 i=1,il
        do ih=1,2
          do ip=1,6
!FOX  ALDA(IH,IP)=ZERO ;
!FOX  ASDA(IH,IP)=ZERO ;
          end do
        end do
        if(abs(el(i)).le.pieni) goto 190
        kz1=kz(i)+1
!       goto(20,40,100,60,80,90,130,170,180),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 100
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 80
        if (kz1.eq.6) goto 90
        if (kz1.eq.7) goto 130
        if (kz1.eq.8) goto 170
        if (kz1.eq.9) goto 180
        goto 220
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 l=1,2
!FOX  ALDA(L,1)=ONE  ;
!FOX  ALDA(L,2)=EL(I) ;
!FOX  ALDA(L,3)=ZERO ;
!FOX  ALDA(L,4)=ONE ;
!FOX  ASDA(L,6)=-RV*ALDA(L,2)/C2E3 ;
   30   continue
!FOX  ASDA(1,1)=EL(I)*(ONE-RV)*C1E3 ;
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   ih=1
   50   continue
        if(abs(ed(i)).le.pieni) goto 20
!FOX  FOK=EL(I)*ED(I)/DPSQ ;
!FOX  RHO=ONE/ED(I)*DPSQ ;
!FOX  FOK1=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
!FOX  SI=SIN(FOK) ;
!FOX  CO=COS(FOK) ;
!FOX  ALDA(IH,1)=ONE ;
!FOX  ALDA(IH,2)=RHO*SI ;
!FOX  ALDA(IH,3)=ZERO ;
!FOX  ALDA(IH,4)=ONE ;
!FOX  ALDA(IH,5)=-DPDA*RHO*(ONE-CO)/DPSQ*C1E3 ;
!FOX  ALDA(IH,6)=-DPDA*TWO*SIN(FOK*HALF)/COS(FOK*HALF)/DPSQ*C1E3 ;
!FOX  SM1=COS(FOK) ;
!FOX  SM2=SIN(FOK)*RHO ;
!FOX  SM3=-SIN(FOK)/RHO ;
!FOX  SM5=-RHO*DPSQ*(ONE-SM1) ;
!FOX  SM6=-SM2*DPSQ/RHO ;
!FOX  SM12=EL(I)-SM1*SM2 ;
!FOX  SM23=SM2*SM3 ;
!FOX  AS3=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23+SM5) ;
!FOX  AS4=-RV*SM23/C2E3 ;
!FOX  AS6=-RV*(EL(I)+SM1*SM2)/C4E3 ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA*(EL(I)-SM2))
!FOX  +EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12+SM6)+FOK1*AS3 ;
!FOX  ASDA(IH,3)=AS3 ;
!FOX  ASDA(IH,4)=AS4+TWO*AS6*FOK1 ;
!FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO)+AS6*FOK1*FOK1+FOK1*AS4  ;
!FOX  ASDA(IH,6)=AS6 ;
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  G=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
!FOX  GL=EL(I)*G ;
!FOX  ALDA(IH,1)=ONE-GL ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,3)=-G*(TWO-GL) ;
!FOX  ALDA(IH,4)=ALDA(IH,1) ;
!FOX  AS6=-RV*ALDA(IH,2)/C2E3 ;
!FOX  ASDA(IH,4)=-TWO*AS6*FOK1 ;
!FOX  ASDA(IH,5)=AS6*FOK1*FOK1 ;
!FOX  ASDA(IH,6)=AS6 ;
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   ih=1
   70   continue
        if(abs(ed(i)).le.pieni) goto 20
!FOX  FOK=EL(I)*ED(I)/DPSQ ;
!FOX  RHO=(ONE/ED(I))*DPSQ ;
!FOX  SI=SIN(FOK) ;
!FOX  CO=COS(FOK) ;
!FOX  RHOC=RHO*(ONE-CO)/DPSQ ;
!FOX  SIQ=SI/DPSQ ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=RHO*SI ;
!FOX  ALDA(IH,3)=-SI/RHO ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ALDA(IH,5)=-DPDA*RHOC*C1E3 ;
!FOX  ALDA(IH,6)=-DPDA*SIQ*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12
!FOX  +DPDA*(EL(I)-ALDA(IH,2)))+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12-DPD*SIQ) ;
!FOX  ASDA(IH,3)=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23-DPD*RHOC) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO) ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  ALDA(IH,1)=ONE ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,3)=ZERO ;
!FOX  ALDA(IH,4)=ONE ;
!FOX  ASDA(IH,6)=-RV*ALDA(IH,2)/C2E3 ;
        goto 190
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET VERTIKAL
!-----------------------------------------------------------------------
   80   ih=2
        goto 50
!-----------------------------------------------------------------------
!  SEKTORMAGNET VERTIKAL
!-----------------------------------------------------------------------
   90   ih=2
        goto 70
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
  100   continue
        if(abs(ek(i)).le.pieni) goto 20
!FOX  FOK=EK(I)/(ONE+DPDA) ;
!FOX  AEK=FOK ;
        if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
        endif
        ih=0
!FOX  HI=SQRT(AEK) ;
!FOX  FI=EL(I)*HI ;
        if(ek(i).gt.zero) goto 120
  110   ih=ih+1
!FOX  ALDA(IH,1)=COS(FI) ;
!FOX  HI1=SIN(FI) ;
!FOX  ALDA(IH,2)=HI1/HI ;
!FOX  ALDA(IH,3)=-HI1*HI ;
!FOX  ALDA(IH,4)=ALDA(IH,1) ;
!FOX  ASDA(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  120   ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.1) goto 110
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  130   ih=0
!FOX  FOKQ=EK(I) ;
  140   continue
        if(abs(ek(i)).le.pieni) goto 60
        if(abs(ed(i)).le.pieni) goto 100
        if(abs(ek(i)-ed(i)**2).le.pieni) goto 20                         !hr08
!FOX  WF=ED(I)/DPSQ ;
!FOX  FOK=FOKQ/DPD-WF*WF ;
!FOX  AFOK=FOK ;
      if(dare(afok).lt.zero) then
!FOX  AFOK=-AFOK ;
      endif
!FOX  HI=SQRT(AFOK) ;
!FOX  FI=HI*EL(I) ;
        if(dare(fok).gt.zero) goto 160
  150   ih=ih+1
!FOX  SI=SIN(FI) ;
!FOX  CO=COS(FI) ;
!FOX  WFA=WF/AFOK*(ONE-CO)/DPSQ ;
!FOX  WFHI=WF/HI*SI/DPSQ ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=SI/HI ;
!FOX  ALDA(IH,3)=-SI*HI ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ALDA(IH,5)=-WFA*DPDA*C1E3 ;
!FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA
!FOX  *(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
!FOX  ASDA(IH,3)=-RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=-RV*SM12*AFOK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  AEK=EK(I)/DPD ;
      if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
      endif
!FOX  HI=SQRT(AEK) ;
!FOX  FI=HI*EL(I) ;
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        goto 190
!--DEFOCUSSING
  160   ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  WFA=WF/AFOK*(ONE-HC)/DPSQ ;
!FOX  WFHI=WF/HI*HS/DPSQ ;
!FOX  ALDA(IH,5)= WFA*DPDA*C1E3 ;
!FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(RV*(DPDA*DPDA/(FOUR*DPD)*SM12
!FOX  +DPDA*(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
!FOX  ASDA(IH,3)=RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=+RV*SM12*AFOK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  AEK=EK(I)/DPD ;
      if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
      endif
!FOX  HI=SQRT(AEK) ;
!FOX  FI=HI*EL(I) ;
!FOX  SI=SIN(FI) ;
!FOX  CO=COS(FI) ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=SI/HI ;
!FOX  ALDA(IH,3)=-SI*HI ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        goto 190
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET VERTICAL
!-----------------------------------------------------------------------
  170   ih=1
!FOX  FOKQ=-EK(I) ;
        goto 140
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  180   continue
!FOX  RHOI=ED(I)/DPSQ ;
!FOX  FOK=RHOI*SIN(EL(I)*RHOI*HALF)/COS(EL(I)*RHOI*HALF) ;
!FOX  ALDA(1,1)=ONE ;
!FOX  ALDA(1,2)=ZERO ;
!FOX  ALDA(1,3)=FOK ;
!FOX  ALDA(1,4)=ONE ;
!FOX  ALDA(2,1)=ONE ;
!FOX  ALDA(2,2)=ZERO ;
!FOX  ALDA(2,3)=-FOK ;
!FOX  ALDA(2,4)=ONE ;
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190   continue
        do ih=1,2
          do ip=1,6
            do ien=1,nord+1
              if (nvar2.eq.5) then
                call dapri6(alda(ih,ip),result,ien,5)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,5)
                asd6(i,ih,ip,ien) = result
              else if (nvar2.eq.6) then
                call dapri6(alda(ih,ip),result,ien,6)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,6)
                asd6(i,ih,ip,ien) = result
              else if (nvar2.eq.4) then
                call dapri6(alda(ih,ip),result,ien,4)
                ald6(i,ih,ip,ien) = result
                call dapri6(asda(ih,ip),result,ien,4)
                asd6(i,ih,ip,ien) = result
              endif
            end do
          end do
        end do
  220 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
      subroutine envquad(i,ipch)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer i,ih,ipch,idaa
      real(kind=fPrec) dare
+ca parpro
+ca common
+ca commondl
+ca commond1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
+ca dainicom
!FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
!FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
!FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
!FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
!FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
!FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
!FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
!FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
!FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
!FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
!FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
!FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
!FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
!FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
!FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
!FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
!FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
!FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
!FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
!FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
!FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
!FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
!FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
!FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX  DPD=ONE+DPDA ;
!FOX  DPSQ=SQRT(DPD) ;
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
      if(abs(ek(i)).le.pieni) goto 100
!FOX  FOK=(SMIDA(IPCH)*RATIOE(I))/(ONE+DPDA) ;
!FOX  AEK=FOK ;
      if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
      endif
      ih=0
!FOX  HI=SQRT(AEK) ;
!FOX  FI=EL(I)*HI ;
      if(ek(i).gt.zero) goto 30
   20 ih=ih+1
!FOX  ALDAQ(IH,1)=COS(FI) ;
!FOX  HI1=SIN(FI) ;
!FOX  ALDAQ(IH,2)=HI1/HI ;
!FOX  ALDAQ(IH,3)=-HI1*HI ;
!FOX  ALDAQ(IH,4)=ALDAQ(IH,1) ;
!FOX  ASDAQ(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
!FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
!FOX  ASDAQ(IH,5)=-RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
!FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.2) goto 100
!--DEFOCUSSING
   30 ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDAQ(IH,1)=HC ;
!FOX  ALDAQ(IH,2)=HS/HI ;
!FOX  ALDAQ(IH,3)=HS*HI ;
!FOX  ALDAQ(IH,4)=HC ;
!FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
!FOX  ASDAQ(IH,5)=+RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
!FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.1) goto 20
  100 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
      
+dk runda
subroutine runda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR NORMAL FORWARD-TRACKING
!        SPECIALLY PREPARED FOR NEW D.A.
!        5 --> 6  AND  ASD6 / ALD6
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use physical_constants
      use crcoall
      implicit none
      integer i,ich,i11,i480,icav,ien,ifam,iflag,iflag1,iflag2,ii,ip,   &
     &ipch,irrtr,iverg,ix,j,jb,jj,jmel,jx,k,kk,kkk,kpz,kzz,n,ncyo,nmz,  &
     &nsta,nsto,idaa
      real(kind=fPrec) beamoff1,beamoff2,beamoff4,beamoff5,             &
     &beamoff6,benkcc,betr0,c5m4,cbxb,cbzb,cik,crk,crxb,crzb,dare,dpdav,&
     &dpdav2,dummy,fake,ox,oxp,oz,ozp,r0,r000,r0a,r2b,r2bf,rb,rbf,rho2b,&
     &rkb,rkbf,scikveb,scrkveb,sigmdac,startco,tkb,xbb,xrb,xs,zbb,      &
     &zfeld1,zfeld2,zrb,zs, crabfreq, crabpht, crabpht2, crabpht3,      &
     &crabpht4
      character(len=300) ch
+ca parpro
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonxz
+ca commonm1
+ca commond1
+ca commond2
+ca commonc
      dimension zfeld1(100),zfeld2(100)
      dimension iverg(mcor)
      dimension fake(2,20),dpdav2(6),jj(100)
      save
!-----------------------------------------------------------------------
+ca daini
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0e-4_fPrec
+ei
      if(mout2.eq.1) then
+if nagfor
+if boinc
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown',recl=303)
+ei
+if .not.boinc
      open(99,file='fort.99',form='formatted',status='unknown',recl=303)
+ei
+ei
+if .not.nagfor
+if boinc
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(99,file='fort.99',form='formatted',status='unknown')
+ei
+ei
      endif
      do i=1,100
        jj(i)=0
      enddo
      if(mout2.eq.1) write(7,*) e0,pma
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      betr0=sqrt(one-(pma/e0)**2)
      do 10 i=1,mcor
   10 iverg(i)=0
      do 15 i=1,20
        fake(1,i)=zero
        fake(2,i)=zero
   15 continue
      time1=0.
      call timex(time1)
      if(niu(1).gt.1) then
        do i=1,2
          ii=2*i
          xxtr(1,i)=clon(ii-1)
          yytr(1,i)=clon(ii)
        enddo
        sigm(1)=clon(5)
        dps(1)=clon(6)
      endif
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      if(nvar2.ge.1) call davar(x(1),zero,1)
!FOX  X(1)=X(1)+OX ;
      if(nvar2.ge.2) call davar(yp(1),zero,2)
!FOX  YP(1)=YP(1)+OXP*(ONE+DPS(1)) ;
      if(nvar2.ge.3) call davar(x(2),zero,3)
!FOX  X(2)=X(2)+OZ ;
      if(nvar2.ge.4) call davar(yp(2),zero,4)
!FOX  YP(2)=YP(2)+OZP*(ONE+DPS(1)) ;
      if(nvar2.lt.5) then
!FOX  DPDA1=DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.5) then
        call davar(dpda1,zero,5)
!FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.6) then
        call davar(sigmda,zero,5)
        call davar(dpda1,zero,6)
!FOX  SIGMDA=SIGMDA+SIGM(1) ;
!FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;
      else
!FOX  SIGMDA=SIGM(1) ;
      endif
!FOX  CORROLD(1)=X(1) ;
!FOX  CORROLD(2)=YP(1) ;
!FOX  CORROLD(3)=X(2) ;
!FOX  CORROLD(4)=YP(2) ;
!FOX  CORROLD(5)=SIGMDA ;
!FOX  CORROLD(6)=DPDA1 ;
      do 5 kkk=1,6
        dpdav=dare(corrold(kkk))
!FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
    5   continue
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      write(lout,*) ' ENTERING MAP '
      write(lout,*) 'INITIAL COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      if(ncor.gt.0) then
        do 20 i=1,ncor
          do 20 ii=1,iu
            if(ipar(i).eq.(ic(ii)-nblo).and.iverg(i).eq.0) then
              iverg(i)=1
              call davar(smida(i),ed(ic(ii)-nblo),nvar2+i)
            endif
   20   continue
      endif
      nsta=niu(1)
      nsto=niu(2)
      if(niu(2).lt.niu(1)) nsto=nsto+iu
      do 490 n=1,numl
        numx=n-1
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
        ncyo=ncy
        if(ncy.eq.0) ncy=1
        if(ithick.eq.1) call envada
        ncy=ncyo
        iflag=0
        iflag1=0
        iflag2=0
        icav=0
        do 480 i480=nsta,nsto
          if(i480.gt.iu) then
            i=i480-iu
          else
            i=i480
          endif
          if(mout2.eq.1.and.i480.eq.nsta.and.n.eq.1) call write4
          if(iflag.eq.1) then
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
            if(ithick.eq.1) then
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
              if(icav.eq.0) then
!FOX  CORRNEW(1)=X(1) ;
!FOX  CORRNEW(2)=YP(1) ;
!FOX  CORRNEW(3)=X(2) ;
!FOX  CORRNEW(4)=YP(2) ;
!FOX  CORRNEW(5)=SIGMDA ;
!FOX  CORRNEW(6)=DPDA1 ;
                do 24 kkk=1,6
                  dpdav=dare(corrnew(kkk))
!FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24           continue
              else
!FOX  CORRAU2(1)=X(1) ;
!FOX  CORRAU2(2)=YP(1) ;
!FOX  CORRAU2(3)=X(2) ;
!FOX  CORRAU2(4)=YP(2) ;
!FOX  CORRAU2(5)=SIGMDA ;
!FOX  CORRAU2(6)=DPDA1 ;
                do 25 kkk=1,6
!FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                  dpdav=dare(corrau2(kkk))
!FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25           continue
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
!FOX  CORRAU2(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
!FOX  CORRAU1(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
              endif
              dpdav=dare(x(1))
!FOX  X(1)=CORROLD(1)+DPDAV ;
              dpdav=dare(yp(1))
!FOX  YP(1)=CORROLD(2)+DPDAV ;
              dpdav=dare(x(2))
!FOX  X(2)=CORROLD(3)+DPDAV ;
              dpdav=dare(yp(2))
!FOX  YP(2)=CORROLD(4)+DPDAV ;
              dpdav=dare(sigmda)
!FOX  SIGMDA=CORROLD(5)+DPDAV ;
              dpdav=dare(dpda1)
!FOX  DPDA1=CORROLD(6)+DPDAV ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
              icav=icav+1
              call envada
            endif
            iflag=0
          endif
          ix=ic(i)
          if(mout2.eq.1) then
            if(i480.eq.nsta.and.n.eq.1) then
              write(ch,*) 'START ',dare(x(1)),dare(y(1)),dare(x(2)),    &
     &dare(y(2)),dare(sigmda),dare(dpda)
              do ich=300,1,-1
                if(ch(ich:ich).ne.' ') goto 700
              enddo
 700          write(99,'(a)') ch(:ich)
            else
              if(ic(i-1).le.nblo) then
                write(ch,*) bez(mtyp(ic(i-1),mel(ic(i-1)))),dare(x(1)), &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 701
                enddo
 701            write(99,'(a)') ch(:ich)
              else
                write(ch,*) bez(ic(i-1)-nblo),dare(x(1)),               &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 702
                enddo
 702            write(99,'(a)') ch(:ich)
              endif
            endif
          endif
          if(ix.gt.nblo) goto 70
          if(mout2.eq.1.and.n.eq.1) then
            jmel=mel(ix)
            do jb=1,jmel
              jx=mtyp(ix,jb)
              if(el(jx).eq.zero) then
                write(7,*) '0'
                write(7,*) bez(jx)
              else
                if(ithick.eq.1) then
                  ifam=0
                  do ip=1,il
                    if(kz(ip).eq.kz(jx).and.el(ip).ne.zero) then
                      if((ed(jx).ne.zero.and.ed(ip).ne.zero).or.        &
     &(ek(jx).ne.zero.and.ek(ip).ne.zero)) then
                        ifam=ifam+1
                        if(bez(ip).eq.bez(jx)) goto 35
                      endif
                    endif
                  enddo
 35               continue
                  write(7,*) '1'
                  write(7,*) bez(jx)
                  if(kz(jx).eq.1.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.3.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.4.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.5.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.8.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.2.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &abs(ed(jx)).le.pieni.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).le.pieni.and.abs(ek(jx)).gt.pieni)) then
                    write(7,*) '2 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).gt.pieni.and.abs(ek(jx)).le.pieni)) then
                    write(7,*) '3 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  else
                    write(7,*) kz(jx),ifam
                    write(7,*) ed(jx),ek(jx),el(jx)
                  endif
                else
                  write(7,*) '2'
                  write(7,*) bez(jx)
                  write(7,*) el(jx)
                endif
              endif
            enddo
          endif
          if(ix.le.0) then
            call prror(93)
          endif
+ca dalin1
+ca dalin2
+ca dalin3
+ca dalin4
+ca dalin5
+ca dalin6
+ca sqrtfox0
!FOX  SIGMDA=SIGMDA+
+ca sqrtfox
              endif
            enddo
          endif
          goto 480
   70     ix=ix-nblo
          if(abs(dare(x(1))).gt.aint(aper(1)).or.abs(dare(x(2))).gt.aint(aper(2))) then
            write(lout,10000) j,numx,i,dare(x(1)),aper(1),dare(x(2)),aper(2),ix, kz(ix),bez(ix)
            goto 520
          endif
          kpz=abs(kp(ix))
          if(kpz.eq.0) goto 110
          goto(110,110,110,110,110,90),kpz
          goto 480
   90     if(nvar2.le.4.or.(nvar2.eq.5.and.nsix.ne.2)) goto 480
          ixcav=ix
          iicav=i
          if(nsix.eq.2) then
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
            call dapri(x(1),19)
            call dapri(yp(1),19)
            call dapri(x(2),19)
            call dapri(yp(2),19)
            call dapri(sigmda,19)
            call dapri(dpda1,19)
            if(ncor.gt.0) then
              write(lout,*) ' WARNING: in the 5*6 mode no extra parameters allowed'
            endif
            rewind 19
!     DADAL AUTOMATIC INCLUSION
            return
          endif
          if(ition.ne.0) then
!FOX  EJF0=EJF1 ;
            if(abs(dppoff).gt.pieni) then
              sigmdac=sigmoff(i)
!FOX  SIGMDA=SIGMDA-SIGMDAC ;
            endif
            call synoda
            if(mout2.eq.1.and.n.eq.1) then
              write(7,*) '5'
              if(kz(ix).eq.12) then
                write(7,*) bez(ix)
                write(ch,*) ed(ix),hsyc(ix),itionc(ix),phasc(ix)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 703
                enddo
 703            write(7,'(a)') ch(:ich)
              else
                write(7,*) 'CAV'
                write(ch,*) hsy(1),hsy(3),ition,phas
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 704
                enddo
 704            write(7,'(a)') ch(:ich)
              endif
            endif
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
          goto 480
  110     kzz=kz(ix)
          if(mout2.eq.1.and.n.eq.1) then
            if(kzz.eq.0) then
              write(7,*) '0'
              write(7,*) bez(ix)
            elseif((kzz.ge.1.and.kzz.le.10).or.                         &
     &(kzz.le.-1.and.kzz.ge.-10)) then
              write(7,*) '3'
              write(7,*) bez(ix)
+if tilt
              write(7,*) xsi(i),zsi(i),atan2_mb(tilts(i),tiltc(i))
+ei
+if .not.tilt
              write(7,*) xsi(i),zsi(i),zero
+ei
              write(7,*) kzz,smi(i)
            elseif(kzz.eq.11) then
              nmz=nmu(ix)
              write(7,*) '4'
              write(7,*) bez(ix)
+if tilt
              write(7,*) xsi(i),zsi(i),atan2_mb(tilts(i),tiltc(i))
+ei
+if .not.tilt
              write(7,*) xsi(i),zsi(i),zero
+ei
              if(abs(dki(ix,1)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 1',' 1'
                  write(7,*) dki(ix,1),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 1',' 0'
                  write(7,*) dki(ix,1),dki(ix,3)
                endif
              elseif(abs(dki(ix,2)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 0',' 1'
                  write(7,*) dki(ix,2),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 0',' 0'
                  write(7,*) dki(ix,2),dki(ix,3)
                endif
              else
                write(7,*) nmz,' 0',' 0',' 0'
              endif
              if(nmz.ge.1) then
                do ip=1,nmz
                  write(7,*) bbi(i,ip),aai(i,ip)
                enddo
              endif
            endif
          endif
          if(kzz.eq.15) then
!FOX  XX(1)=X(1) ;
!FOX  XX(2)=X(2) ;
!FOX  YY(1)=Y(1) ;
!FOX  YY(2)=Y(2) ;
          call wireda(ix,i)
!FOX  Y(1)=YY(1) ;
!FOX  Y(2)=YY(2) ;
             goto 480
          endif

          if(kzz.eq.20.and.parbe(ix,2).eq.zero) then                      !hr08
            if(nbeam.ge.1) then
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
+ca beamr1of
     &then
+ca beamr2of
+ca beamr3of
                  endif
                endif
+ca beamcof
+ca beamr1f
                if(abs(dare(rho2bf)).gt.pieni) then
+ca beamr2f
+ca beamr3f
                endif
              else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
+ca beam11of
+ca beama1of
+ca beama2of
+ca beam12of
+ca beama3of
+ca beam13of
+ca beama4of
                endif
+ca beam11s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam12f
+ca beama3f
+ca beam13f
+ca beama4f
              else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
+ca beam21of
+ca beama1of
+ca beama2of
+ca beam22of
+ca beama3of
+ca beam23of
+ca beama4of
                endif
+ca beam21s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam22f
+ca beama3f
+ca beam23f
+ca beama4f
              endif
              goto 480
            endif
            goto 480
          endif
          if(kzz.eq.20.and.parbe(ix,2).gt.zero) then                      !hr08
+ca beam6dfi
            goto 480
          endif
+ca trom20
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) then
            if(bez(ix).eq.'DAMAP') then
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
              if(icav.eq.0.or.ithick.ne.1) then
                if(nvar2.ge.1) call dapri(x(1),17)
                if(nvar2.ge.2) call dapri(yp(1),17)
                if(nvar2.ge.3) call dapri(x(2),17)
                if(nvar2.ge.4) call dapri(yp(2),17)
                if(nvar2.eq.5.and.nsix.ne.2) call dapri(dpda1,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(sigmda,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(dpda1,17)
              else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=SIGMDA ;
!FOX  CORRAU1(6)=DPDA1 ;
                do 115 kkk=1,6
                  dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  115           continue
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
!FOX  CORRAU1(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
!FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
                do 116 kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  116           continue
                call dapri(corrau2(1),17)
                call dapri(corrau2(2),17)
                call dapri(corrau2(3),17)
                call dapri(corrau2(4),17)
                call dapri(corrau2(5),17)
                call dapri(corrau2(6),17)
              endif
              if(ncor.gt.0) then
                do 120 i11=1,ncor
  120           call dapri(smida(i11),17)
              endif
            endif
            goto 480
          endif
          pi=four*atan_mb(one)

          if(kzz.eq.23) then
!FOX  CRABAMP=ED(IX)/(EJF1) ;
             crabfreq=ek(ix)*c1e3
             crabpht=crabph(ix)
!FOX  Y(1)=Y(1) - CRABAMP*C1E3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(1)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-23) then
!FOX  CRABAMP=ED(IX)/(EJF1) ;
             crabfreq=ek(ix)*c1e3
             crabpht=crabph(ix)
!FOX  Y(2)=Y(2) - CRABAMP*C1E3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(2)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
! JBG RF CC Multipoles
          if(kzz.eq.26) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
!FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  DPDA1=DPDA1 - (1/2.)*(CRABAMP2)*(CRKVE*CRKVE-
!FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
! JBG RF CC Multipoles
          if(kzz.eq.-26) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
!FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  DPDA1=DPDA1 - (CRABAMP2)*(CIKVE*CRKVE)
!FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(1)=Y(1) + 2*(1/2.)*CRABAMP3*((CRKVE*CRKVE)-
!FOX  (CIKVE*CIKVE))*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(2)=Y(2) - 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  DPDA1=DPDA1 - 2*(1/6.)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
!FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-27) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(2)=Y(2) - 2*(1/2.)*CRABAMP3*((CIKVE*CIKVE)-
!FOX  (CRKVE*CRKVE))*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(1)=Y(1) + 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  DPDA1=DPDA1 + 2*(1/6.)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
!FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
!FOX  (CRKVE*CRKVE*CRKVE-(3*CRKVE*CIKVE*CIKVE))*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  Y(2)=Y(2) - 6*(1/6.)*(CRABAMP4)*
!FOX  (3*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  DPDA1=DPDA1-6*(1/24.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
!FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.-28) then
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
!FOX  (CIKVE*CIKVE*CIKVE-(3*CIKVE*CRKVE*CRKVE))*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  Y(2)=Y(2) + 6*(1/6.)*(CRABAMP4)*
!FOX  (3*CRKVE*CIKVE*CIKVE-CRKVE*CRKVE*CRKVE)*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  DPDA1=DPDA1+6*(1/6.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CIKVE-
!FOX  CIKVE*CIKVE*CIKVE*CRKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          ipch=0
          if(ncor.gt.0) then
            do i11=1,ncor
              if(ipar(i11).eq.ix) ipch=i11
            end do
          end if
          if(ipch.ne.0) then
!FOX  EKK=(SMIDA(IPCH)+SMIZF(I))/(ONE+DPDA) ;
          else
!FOX  EKK=SMI(I)/(ONE+DPDA) ;
          end if
          xs=xsi(i)
          zs=zsi(i)
          if(mout2.eq.1.and.n.eq.1.and.icextal(i).ne.0) then
            write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),               &
     &extalign(i,1),extalign(i,2),extalign(i,3)
          end if
+ca alignf
          select case (kzz)
          case (1)  ! HORIZONTAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
+ca kickf01h
          case (2)  ! NORMAL QUADRUPOLE
+ca kickfxxh
          case (3)  ! NORMAL SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxh
          case (4)  ! NORMAL OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (5)  ! NORMAL DECAPOLE
!FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (6)  ! NORMAL DODECAPOL
!FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (7)  ! NORMAL 14-POL
!FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (8)  ! NORMAL 16-POL
!FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (9)  ! NORMAL 18-POL
!FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (10) ! NORMAL 20-POL
!FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
          case (11)
            r0  = ek(ix)
            nmz = nmu(ix)
+ca multf01
            if (abs(r0).le.pieni.or.nmz.eq.0) goto 480
            if(mout2.eq.1.and.n.eq.1) then
              benkcc = ed(ix)*benkc(irm(ix))
              r0a    = one
              r000   = r0*r00(irm(ix))
              do j=1,mmul
                fake(1,j)=(bbi(i,j)*r0a)/benkcc                            !hr08
                fake(2,j)=(aai(i,j)*r0a)/benkcc                            !hr08
                r0a=r0a*r000
              end do
              
              write(9,'(a16)') bez(ix)
              write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
              write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
              write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
              write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
              write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
              write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
              write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
              write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
              write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
              write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
              write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
              write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
              write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
              write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
              
              do j=1,20
                fake(1,j)=zero
                fake(2,j)=zero
              end do
            end if
            if(nmz.ge.2) then
+ca multf02
              do k=3,nmz
+ca multf03
              end do
+ca multf04
            else
+ca multf05
            end if
          case (12,13,14,15,16,17,18,19,20,21,22,23)
            goto 480
          case (24) ! DIPEDGE ELEMENT
+ca kickfdpe
          case (25) ! Solenoid
+ca kickfso1
          
          !-----------------
          !--SKEW ELEMENTS--
          !-----------------
          case (-1)  ! VERTICAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
+ca kickf01v
          case (-2)  ! SKEW QUADRUPOLE
+ca kickfxxv
          case (-3)  ! SKEW SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxv
          case (-4)  ! SKEW OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-5)  ! SKEW DECAPOLE
!FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-6)  ! SKEW DODECAPOL
!FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-7)  ! SKEW 14-POL
!FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-8)  ! SKEW 16-POL
!FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-9)  ! SKEW 18-POL
!FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          case (-10) ! SKEW 20-POL
!FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
          end select
          
  480   continue
        if(mout2.eq.1) then
          if(ic(iu).le.nblo) then
            write(ch,*) bez(mtyp(ic(iu),mel(ic(iu)))),dare(x(1)),       &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 705
            enddo
 705        write(99,'(a)') ch(:ich)
          else
            write(ch,*) bez(ic(iu)-nblo),dare(x(1)),                    &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 706
            enddo
 706        write(99,'(a)') ch(:ich)
          endif
        endif
  490 continue
  500 continue
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
      if(nsix.eq.2) nsix=0
      if(icav.eq.0.or.ithick.ne.1) then
        if(nvar2.ge.1) call dapri(x(1),18)
        if(nvar2.ge.2) call dapri(yp(1),18)
        if(nvar2.ge.3) call dapri(x(2),18)
        if(nvar2.ge.4) call dapri(yp(2),18)
        if(nvar2.eq.5) call dapri(dpda1,18)
        if(nvar2.eq.6) call dapri(sigmda,18)
        if(nvar2.eq.6) call dapri(dpda1,18)
      else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=SIGMDA ;
!FOX  CORRAU1(6)=DPDA1 ;
        do 505 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  505   continue
        if(ncor.gt.0) then
          do kkk=1,ncor
            kk=6+kkk
!FOX  CORRAU1(KK)=SMIDA(KKK) ;
            dpdav=dare(smida(kkk))
!FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
          enddo
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
        do 506 kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  506   continue
!FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
!FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
!FOX  X(1)=CORRAU2(1) ;
!FOX  Y(1)=CORRAU1(2) ;
!FOX  X(2)=CORRAU2(3) ;
!FOX  Y(2)=CORRAU1(4) ;
!FOX  SIGMDA=CORRAU2(5) ;
!FOX  DPDA1=CORRAU2(6) ;
!FOX  DPDA=DPDA1*C1M3 ;
        call dapri(corrau2(1),18)
        call dapri(corrau2(2),18)
        call dapri(corrau2(3),18)
        call dapri(corrau2(4),18)
        call dapri(corrau2(5),18)
        call dapri(corrau2(6),18)
      endif
      if(ncor.gt.0) then
        do 510 i11=1,ncor
  510   call dapri(smida(i11),18)
      endif
      write(lout,*) 'END COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      
      write(12,'(E22.15)') dare(x(1))
      write(12,'(E22.15)') dare(y(1))
      write(12,'(E22.15)') dare(x(2))
      write(12,'(E22.15)') dare(y(2))
      write(12,'(E22.15)') dare(sigmda)
      write(12,'(E22.15)') dare(dpda)

      write(lout,10010)
      
  520 continue
!     DADAL AUTOMATIC INCLUSION
      time2=0.
      call timex(time2)
!     time=time2-time1
      write(lout,10020) time1-time0
      write(lout,10030) nord,time2-time1
!-----------------------------------------------------------------------
      return
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. ',     &
     &i7,' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,              &
     &'HORIZ:  AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,       &
     &'VERT:   AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,       &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
10010 format(//t10,30('*')/t10,'**** ONE TURN COMPLETED ****'/ t10,30(  &
     &'*')/)
10020 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10030 format(/10x,'DA-Calculation of Order : ',i7,' took ', f12.3,      &
     &' second(s) of CPU Time'//131('-')//)
end subroutine runda

+dk umlau6
      subroutine umlauda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR 6-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
      use physical_constants
      use numerical_constants
      use mathlib_bouncer
      use dump, only : dumpclo, dumptas, dumptasinv, ldump
      use crcoall
      implicit none
      integer i,ibb,iii,i2,i3,i4,icav,icoonly,ien,iflag,iflag1,iflag2,  &
     &ii,ii2,ip,ipch,irrtr,ivar,ivar1,iwrite,ix,j,j1,jb,jj,jmel,jx,k,   &
     &kkk,kpz,kzz,mfile,nd2,nmz,idaa,angno,damap,damapi,damap1,f,aa2,   &
     &aa2r,a1,a1r,xy,h,df
      real(kind=fPrec) al1,al2,al3,angp,angnoe,au,aui,b1,b2,b3,beamoff1,&
     &beamoff2,beamoff4,beamoff5,beamoff6,betr0,c,c5m4,cbxb,cbzb,coefh1,&
     &cik,coefh2,coefv1,coefv2,cp,crk,crxb,crzb,cx,d,dicu,dare,det1,dp, &
     &dpdav,dpdav2,dphi,dps1,dps11,dummy,ed1,ed2,g1,g2,g3,ox,oxp,oxp1,  &
     &oz,ozp,ozp1,phi,r0,r2b,r2bf,rb,rbf,rdd,rho2b,rkb,rkbf,rrad,       &
     &scikveb,scrkveb,sfac1,sfac2,sfac2s,sfac3,sfac4,sfac5,sigm1,       &
     &sigmdac,startco,sx,tas,tkb,tl,x2pi,xbb,xrb,xs,zbb,zfeld1,zfeld2,  &
     &zrb,zs,  crabfreq, crabpht, crabpht2, crabpht3, crabpht4
      character(len=16) typ
+ca parpro
+ca commonex
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonl
+ca commonxz
+ca commonm1
+ca commond1
+ca commond2
+ca commonc
+ca commonta
      dimension damap(6),damapi(6),damap1(6)
      dimension aa2(6),aa2r(6),a1(6),a1r(6),xy(6),df(6)
      dimension zfeld1(100),zfeld2(100)
      dimension jj(100),dpdav2(6),rrad(3),rdd(6,6),dicu(20)
      dimension angnoe(3),angp(2,6),phi(3),dphi(3)
      dimension b1(3),b2(3),b3(3),al1(3),al2(3),al3(3),g1(3),g2(3),g3(3)
      dimension d(3),dp(3),c(3),cp(3),au(6,6),aui(2)
      dimension i4(10,2)
+if bnlelens
+ca rhicelens
+ei
!     for FMA analysis
+ca comgetfields
!+ca fma
! END for FMA analysis
+ca wireparam
+if debug
!     integer umcalls,dapcalls,dokcalls,dumpl
!     common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
+ei

! For treatment and/or conversion of BEAM parameters in/to the new format
+ca parbeam_exp
+if crlibm
      character(len=1000) ch
      character(len=25) ch1
      integer errno,l1
      integer dtostr
+ei
      logical lopen
      character(len=256) filename

      save
!-----------------------------------------------------------------------
+ca daini
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
+if debug
!     umcalls=umcalls+1
!     call wda('umcalls',0d0,1,umcalls,0,0)
+ei
      nd2=ndimf*2
      call etall(damap,6)
      call etall(damapi,6)
      call etall(damap1,6)
      call etall(angno,1)
      call etall(f,1)
      call etall(aa2,6)
      call etall(aa2r,6)
      call etall(a1,6)
      call etall(a1r,6)
      call etall(xy,6)
      call etall(h,1)
      call etall(df,6)
+if debug
!     call wda('uml2',0d0,2,0,0,0)
+ei
      if(iqmodc.eq.1) call danot(2)
      if(iqmodc.eq.3) call danot(1)
      if(ichromc.eq.1) call danot(3)
+if debug
!     call wda('uml3',0d0,3,0,0,0)
+ei
      icoonly=0
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ichromc.eq.2) icoonly=1
+if fast
      c5m4=5.0d-4
+ei
      do j=1,2
        angnoe(j)=zero
        do i=1,6
          angp(j,i)=zero
        enddo
      enddo
      do i=1,100
        jj(i)=0
      enddo
      x2pi=atan_mb(one)*eight
      i4(1,1)=1
      i4(1,2)=1
      i4(2,1)=3
      i4(2,2)=3
      i4(3,1)=1
      i4(3,2)=3
      i4(4,1)=1
      i4(4,2)=2
      i4(5,1)=1
      i4(5,2)=4
      i4(6,1)=2
      i4(6,2)=2
      i4(7,1)=2
      i4(7,2)=3
      i4(8,1)=2
      i4(8,2)=4
      i4(9,1)=3
      i4(9,2)=4
      i4(10,1)=4
      i4(10,2)=4
      e0f=sqrt(e0**2-pma**2)                                             !hr05
      betr0=sqrt(one-(pma/e0)**2)
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      sigm1=sigm(1)
      dps1=dps(1)
      if(iqmodc.eq.1) then
        if(el(iq(1)).le.pieni) then
          ed1=ed(iq(1))
        else
          ed1=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          ed2=ed(iq(2))
        else
          ed2=ek(iq(2))
        endif
      endif
      if(ichromc.eq.1) then
        ed1=ed(issss(1))
        ed2=ed(issss(2))
      endif
+if debug
!     call wda('uml4',0d0,4,0,0,0)
+ei
      call davar(x(1),ox,1)
      oxp1=oxp*(one+dps1)
      call davar(yp(1),oxp1,2)
      ivar=2
      if(nvar2.ge.4) then
        call davar(x(2),oz,3)
        ozp1=ozp*(one+dps1)
        call davar(yp(2),ozp1,4)
        ivar=4
      else
!FOX  X(2)=OZ ;
!FOX  YP(2)=OZP*(ONE+DPS1) ;
      endif
      dps11=dps1*c1e3
      if(nvar2.eq.3) then
        call davar(dpda1,dps11,3)
        ivar=ivar+1
      elseif(nvar2.eq.5) then
        call davar(dpda1,dps11,5)
        ivar=ivar+1
      elseif(nvar2.eq.6) then
        call davar(sigmda,sigm1,5)
        call davar(dpda1,dps11,6)
        ivar=ivar+2
      else
!FOX  SIGMDA=SIGM1 ;
!FOX  DPDA1=DPS1*C1E3 ;
      endif
      ivar1=ivar
      if(iqmodc.eq.1.or.ichromc.eq.1) then
        call davar(smida(1),ed1,ivar+1)
        call davar(smida(2),ed2,ivar+2)
        ivar=ivar+2
      endif
!--Normal Form Analysis for calculation of linear lattice functions
+if debug
!     call wda('uml5',0d0,5,ilinc,0,0)
+ei
      if(ilinc.eq.1.or.ilinc.eq.2) then
        mfile=18
!Eric
        rewind mfile
        rewind 111
!ERIC HERE
        call daread(damap,nvar,mfile,one)
+if debug
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml6',0d0,6,0,0,0)
+ei
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
        do j=1,nvar
          call dacop(damap(j),damap1(j))
          dummy=dare(damap1(j))
          call dacsu(damap1(j),dummy,damap1(j))
        enddo
        if(ndimf.eq.3) then
          call damul(damap1(5),damap1(5),angno)
          call averaged(angno,damap1,.true.,angno)
          jj(5)=1
          jj(6)=1
+if debug
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml7',0d0,7,0,0,0)
+ei
          call dapek(angno,jj,emitz)
+if debug
!     call warr('emitz',emitz,1,0,0,0)
!     call wda('uml8',0d0,8,0,0,0)
+ei
          jj(5)=0
          jj(6)=0
          if(abs(emitz).le.pieni) then
            emitz=zero
          else
            emitz=((sigz**2/emitz)*half)*c1e6                            !hr05
          endif
        endif
+if debug
!     call warr('emitz',emitz,2,0,0,0)
!     call wda('uml9',0d0,9,0,0,0)
+ei
+if debug
!     call dumpbin('emitz',1,1)
!     call dumpda('emitz',1,0)
!     call abend('          emitz                                   ')
+ei
        jj(5)=1
        do j=1,nd2
          call dapek(a1(j),jj,dicu(j))
        enddo
        jj(5)=0
      endif
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  CORROLD(1)=X(1) ;
!FOX  CORROLD(2)=YP(1) ;
!FOX  CORROLD(3)=X(2) ;
!FOX  CORROLD(4)=YP(2) ;
!FOX  CORROLD(5)=SIGMDA ;
!FOX  CORROLD(6)=DPDA1 ;
            do 5 kkk=1,6
              dpdav=dare(corrold(kkk))
!FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
    5       continue
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      iflag=0
      iflag1=0
      iflag2=0
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
      if(ithick.eq.1) call envada
      icav=0
      typ='START'
      phi(1)=zero
      phi(2)=zero
      phi(3)=zero
      ibb=0
      wire_num_aux=0
+if debug
!     call wda('biu',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('biu',0,0)
!     call abend('biu                                               ')
!     endif
+ei
!     start loop over single elements
      do 430 i=1,iu
        if(iqmodc.eq.2.or.iqmodc.eq.4) then
          if(i.eq.niu(1)) then
            do ii=1,2
              ii2=2*ii
              clon(ii2-1)=dare(x(ii))
              clon(ii2)=dare(y(ii))
            enddo
            clon(5)=dare(sigmda)
            clon(6)=dare(dpda)
          endif
        endif
+if debug
!     call wda('aclon',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aclon',0,0)
!     call abend('aclon                                             ')
!     endif
+ei
        if(ilinc.eq.1.and.i.eq.1) then
          write(lout,10000) nd2
          if(iprint.eq.1) write(lout,10130)
          write(lout,10010)
          write(lout,10020)
          write(lout,10010)
          tl=zero
+ca umlalid
        endif
+if debug
!     call wda('biflag',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call wda('biflag',0d0,iflag,0,0,0)
!       call dumpda('biflag',0,0)
!     call abend('biflag                                            ')
!     endif
+ei
        if(iflag.eq.1) then
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
          if(ithick.eq.1) then
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
            if(icav.eq.0) then
!FOX  CORRNEW(1)=X(1) ;
!FOX  CORRNEW(2)=YP(1) ;
!FOX  CORRNEW(3)=X(2) ;
!FOX  CORRNEW(4)=YP(2) ;
!FOX  CORRNEW(5)=SIGMDA ;
!FOX  CORRNEW(6)=DPDA1 ;
              do 24 kkk=1,6
                dpdav=dare(corrnew(kkk))
!FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24         continue
            else
!FOX  CORRAU2(1)=X(1) ;
!FOX  CORRAU2(2)=YP(1) ;
!FOX  CORRAU2(3)=X(2) ;
!FOX  CORRAU2(4)=YP(2) ;
!FOX  CORRAU2(5)=SIGMDA ;
!FOX  CORRAU2(6)=DPDA1 ;
              do 25 kkk=1,6
!FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                dpdav=dare(corrau2(kkk))
!FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25         continue
              if(ivar.gt.ivar1) then
!FOX  CORRAU2(7)=SMIDA(1) ;
!FOX  CORRAU2(8)=SMIDA(2) ;
                dpdav=dare(smida(1))
!FOX  CORRAU1(7)=SMIDA(1)-DPDAV ;
                dpdav=dare(smida(2))
!FOX  CORRAU1(8)=SMIDA(2)-DPDAV ;
              endif
+if debug
!     call wda('dacct',0d0,1,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('bdacct',0,0)
!     call abend('bdaccct                                           ')
!     endif
+ei
              call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
            endif
+if debug
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
+ei
            dpdav=dare(x(1))
!FOX  X(1)=CORROLD(1)+DPDAV ;
            dpdav=dare(yp(1))
!FOX  YP(1)=CORROLD(2)+DPDAV ;
            dpdav=dare(x(2))
!FOX  X(2)=CORROLD(3)+DPDAV ;
            dpdav=dare(yp(2))
!FOX  YP(2)=CORROLD(4)+DPDAV ;
            dpdav=dare(sigmda)
!FOX  SIGMDA=CORROLD(5)+DPDAV ;
            dpdav=dare(dpda1)
!FOX  DPDA1=CORROLD(6)+DPDAV ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
            icav=icav+1
            call envada
          endif
          iflag=0
        endif
        ix=ic(i)
        if(ix.gt.nblo) goto 50
        if(ix.le.0) then
          call prror(93)
        endif
+ca dalin1
+if debug
!     call wda('adlin1',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adlin1',0,0)
!     call abend('adlin1                                            ')
!     endif
+ei
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
+if debug
!     call wda('aenvquad',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aenvquad',0,0)
!     call abend('aenvquad                                          ')
!     endif
+ei
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
+ca dalin2
              endif
+ca dalin3
          if(ilinc.eq.1) then
            do jb=1,jmel
              jx=mtyp(ix,jb)
              typ=bez(jx)
              tl=tl+el(jx)
+ca umlalid
              if(i.eq.nt) goto 470
            enddo
          endif
+ca dalin4
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  SIGMDA=SIGMDA+ASDAQ(1,1)+ASDAQ(1,2)*PUX+
!FOX  ASDAQ(1,3)*PUZ+ASDAQ(1,4)*PUX*PUZ+ASDAQ(1,5)*PUX*PUX+
!FOX  ASDAQ(1,6)*PUZ*PUZ ;
!FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  SIGMDA=SIGMDA+ASDAQ(2,1)+ASDAQ(2,2)*PUX+
!FOX  ASDAQ(2,3)*PUZ+ASDAQ(2,4)*PUX*PUZ+ASDAQ(2,5)*PUX*PUX+
!FOX  ASDAQ(2,6)*PUZ*PUZ ;
!FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
+ca dalin5
              endif
            else
              if(iexact.eq.1) then
+ca exDAdrift
              else
! Regular drift
+ca dalin6
+ca sqrtfox0
!FOX  SIGMDA=SIGMDA+
+ca sqrtfox
              endif
            endif
            if(ilinc.eq.1) then
              typ=bez(jx)
              tl=tl+el(jx)
+ca umlalid
              if(i.eq.nt) goto 470
            endif
          enddo
        endif
+if debug
!     if (umcalls.eq.8) then
!     call wda('bgoto430',0d0,2,0,0,0)
!       call dumpda('bgoto430',0,0)
!     call abend('bgoto430                                          ')
!     endif
+ei
        goto 430
   50   ix=ix-nblo
+if debug
!     if (umcalls.eq.8) then
!     call wda('a50',0d0,ix,nblo,ix-nblo,0)
!       call dumpda('a50',0,0)
!     call abend('a50                                               ')
!     endif
+ei
        if(abs(dare(x(1))).gt.aint(aper(1)).or. abs(dare(x(2))).gt.aint(aper(2))) then
          write(lout,10120)j,i,dare(x(1)),aper(1),dare(x(2)),aper(2),ix,kz(ix),bez(ix)
          call prror(97)
        endif
        kpz=abs(kp(ix))
        if(kpz.ge.0 .and. kpz.lt.6) goto 80
        if(kpz.eq.6) goto 70
        goto 430
   70   continue
        if(ition.ne.0) then
!FOX  EJF0=EJF1 ;
          ixcav=ix
          if(abs(dppoff).gt.pieni) then
            sigmdac=dare(sigmda)
            sigmoff(i)=sigmdac
!FOX  SIGMDA=SIGMDA-SIGMDAC ;
          endif
          call synoda
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
        endif
        goto 440
   80   kzz=kz(ix)
        if(kzz.eq.15) then
! the same as in umlalid1
          wire_num_aux = wire_num_aux+1
! is the error number correct?
          if(wire_num_aux.gt.wire_max) then
               write(lout,                                              &
     &*) 'ERROR: maximum number of wires exceeded! Number of wires ='// &
     &'wire_num_aux = ',wire_num_aux,' > ',wire_max,' = wire_max'
            call prror(-1)
          endif
          wire_num(i) = wire_num_aux
!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
!FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(sigmda,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag2.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          endif
          call dainv(damap,nvar,damapi,nvar)
          call dacct(damap,nvar,aa2,nvar,aa2r,nvar)
          call dacct(damap,nvar,damap1,nvar,damap,nvar)
          call dacct(damap,nvar,damapi,nvar,damap,nvar)
! the same as in umlalid1
      
!FOX  XX(1)=X(1) ;
!FOX  XX(2)=X(2) ;
!FOX  YY(1)=Y(1) ;
!FOX  YY(2)=Y(2) ;
      wire_clo(1,wire_num(i))=dare(x(1))
      wire_clo(2,wire_num(i))=dare(x(2))
      wire_clo(4,wire_num(i))=dare(y(1))*(one+dare(DPDA))
      wire_clo(5,wire_num(i))=dare(y(2))*(one+dare(DPDA))
      if(ndimf.eq.3) then
         wire_clo(3,wire_num(i))=dare(SIGMDA)
         wire_clo(6,wire_num(i))=dare(DPDA)
      endif

      call wireda(ix,i)

!FOX  Y(1)=YY(1) ;
!FOX  Y(2)=YY(2) ;
          goto 440
        endif
        if(ilinc.eq.2.and.kzz.eq.20) then
          if(nbeam.ge.1) then
+ca umlalid1
          endif
          goto 440
        endif
        if(kzz.eq.20.and.iqmodc.eq.4) goto 440
        if(kzz.eq.20.and.parbe(ix,2).eq.zero) then                        !hr12
          if(nbeam.ge.1) then
            if(ilinc.eq.0) then
              clobeam(1,imbb(i))=dare(x(1))
              clobeam(2,imbb(i))=dare(x(2))
              clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
              clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
              if(ndimf.eq.3) then
                clobeam(3,imbb(i))=dare(sigmda)
                clobeam(6,imbb(i))=dare(dpda)
              endif
            endif
            if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
+ca beamr1of
     &then
+ca beamr2of
+ca beamr3of
                endif
              endif
+ca beamcof
+ca beamr1f
              if(abs(dare(rho2bf)).gt.pieni) then
+ca beamr2f
+ca beamr3f
              endif
            else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
+ca beam11of
+ca beama1of
+ca beama2of
+ca beam12of
+ca beama3of
+ca beam13of
+ca beama4of
              endif
+ca beam11s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam12f
+ca beama3f
+ca beam13f
+ca beama4f
            else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
+ca beam21of
+ca beama1of
+ca beama2of
+ca beam22of
+ca beama3of
+ca beam23of
+ca beama4of
              endif
+ca beam21s
+ca beama1s
+ca beamcof
+ca beama2f
+ca beam22f
+ca beama3f
+ca beam23f
+ca beama4f
            endif
            goto 440
          endif
          goto 440
        endif
        if(kzz.eq.20.and.parbe(ix,2).gt.zero) then                        !hr12
          if(ilinc.eq.0)then
            clobeam(1,imbb(i))=dare(x(1))
            clobeam(2,imbb(i))=dare(x(2))
            clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
            clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
            if(ndimf.eq.3)then
              clobeam(3,imbb(i))=dare(sigmda)
              clobeam(6,imbb(i))=dare(dpda)
            endif
          endif
+ca beam6dfi
          goto 440
        endif
          pi=four*atan_mb(one)
        if(kzz.eq.23) then
!FOX  CRABAMP=ED(IX)/(EJF1) ;
!       call dapri(EJF1,234)
!       write(*,*) crabamp, EJF1, EJF0,clight, "HELLO"
        crabfreq=ek(ix)*c1e3
        crabpht=crabph(ix)
!FOX  Y(1)=Y(1) - CRABAMP*C1E3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(1)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
        if(kzz.eq.-23) then
!FOX  CRABAMP=ED(IX)/(EJF1) ;
           crabfreq=ek(ix)*c1e3
           crabpht=crabph(ix)
!FOX  Y(2)=Y(2) - CRABAMP*C1E3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  DPDA1=DPDA1 - CRABAMP*CRABFREQ*2D0*PI/CLIGHT*X(2)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif

! JBG RF CC Multipoles
        if(kzz.eq.26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
+ca alignf ! JBG Including misalignments
!FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
!       call dapri(EJF1,234)
!       write(*,*) crabamp, EJF1, EJF0,clight, "HELLO"
        crabfreq=ek(ix)*c1e3 !JBG Input in MHz changed to kHz
        crabpht2=crabph2(ix)
!FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  DPDA1=DPDA1 - (1/2.)*(CRABAMP2)*(CRKVE*CRKVE-
!FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
          if(kzz.eq.-26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
!FOX  CRABAMP2=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
!FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT2);
!FOX  DPDA1=DPDA1 - (CRABAMP2)*(CIKVE*CRKVE)
!FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*C1M3*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT2) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(1)=Y(1) + 2*(1/2.)*CRABAMP3*((CRKVE*CRKVE)-
!FOX  (CIKVE*CIKVE))*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(2)=Y(2) - 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  DPDA1=DPDA1 - 2*(1/6.)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
!FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP3=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(2)=Y(2) - 2*(1/2.)*CRABAMP3*((CIKVE*CIKVE)-
!FOX  (CRKVE*CRKVE))*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(1)=Y(1) + 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  DPDA1=DPDA1 + 2*(1/6.)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
!FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT3) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
!FOX  (CRKVE*CRKVE*CRKVE-(3*CRKVE*CIKVE*CIKVE))*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  Y(2)=Y(2) - 6*(1/6.)*(CRABAMP4)*
!FOX  (3*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  DPDA1=DPDA1-6*(1/24.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
!FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
+ca alignf
!FOX  CRABAMP4=ED(IX)/(ONE+DPDA) ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  Y(1)=Y(1) + 6*(1/6.)*(CRABAMP4)*
!FOX  (CIKVE*CIKVE*CIKVE-(3*CIKVE*CRKVE*CRKVE))*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  Y(2)=Y(2) + 6*(1/6.)*(CRABAMP4)*
!FOX  (3*CRKVE*CIKVE*CIKVE-CRKVE*CRKVE*CRKVE)*C1M3*C1M3*
!FOX  COS(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI + CRABPHT4);
!FOX  DPDA1=DPDA1+6*(1/6.)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CIKVE-
!FOX  CIKVE*CIKVE*CIKVE*CRKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  SIN(SIGMDA/C1E3/CLIGHT*CRABFREQ*2D0*PI+CRABPHT4) ;
!FOX  EJF0=EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
+ca trom20
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 440
        if(kzz.eq.15) goto 440
        ipch=0
        if(iqmodc.eq.1) then
          if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
            ipch=1
          else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
            ipch=2
          endif
        endif
        if(ichromc.eq.1) then
          if(ix.eq.issss(1).or.iratioe(ix).eq.issss(1)) then
            ipch=1
          else if(ix.eq.issss(2).or.iratioe(ix).eq.issss(2)) then
            ipch=2
          endif
        endif
        if(ipch.ne.0) then
!FOX  EKK=(SMIDA(IPCH)*RATIOE(IX)+SMIZF(I))/(ONE+DPDA) ;
        else
!FOX  EKK=SMI(I)/(ONE+DPDA) ;
        endif
        xs=xsi(i)
        zs=zsi(i)
+ca alignf
        
        select case (kzz)
        case (1)  ! HORIZONTAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
+ca kickf01h
        case (2)  ! NORMAL QUADRUPOLE
+ca kickfxxh
        case (3)  ! NORMAL SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxh
        case (4)  ! NORMAL OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (5)  ! NORMAL DECAPOLE
!FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (6)  ! NORMAL DODECAPOL
!FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (7)  ! NORMAL 14-POL
!FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (8)  ! NORMAL 16-POL
!FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (9)  ! NORMAL 18-POL
!FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (10) ! NORMAL 20-POL
!FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxh
        case (11)
          r0  = ek(ix)
          nmz = nmu(ix)
+ca multf01
          if(abs(r0).le.pieni.or.nmz.eq.0) goto 440
          if(nmz.ge.2) then
+ca multf02
            do k=3,nmz
+ca multf03
            end do
+ca multf04
          else
+ca multf05
          end if
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 440
        case (24) ! DIPEDGE ELEMENT
+ca kickfdpe
        case (25) ! Solenoid
+ca kickfso1

        !-----------------
        !--SKEW ELEMENTS--
        !-----------------
        case (-1)  ! VERTICAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
+ca kickf01v
        case (-2)  ! SKEW QUADRUPOLE
+ca kickfxxv
        case (-3)  ! SKEW SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
+ca kickfho
+ca kickfxxv
        case (-4)  ! SKEW OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-5)  ! SKEW DECAPOLE
!FOX  EKK=EKK*C1M9 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-6)  ! SKEW DODECAPOL
!FOX  EKK=EKK*C1M12 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-7)  ! SKEW 14-POL
!FOX  EKK=EKK*C1M15 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-8)  ! SKEW 16-POL
!FOX  EKK=EKK*C1M18 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-9)  ! SKEW 18-POL
!FOX  EKK=EKK*C1M21 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        case (-10) ! SKEW 20-POL
!FOX  EKK=EKK*C1M24 ;
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfho
+ca kickfxxv
        end select
        
 440  continue
+if debug
!     if (umcalls.eq.8) then
!     call wda('a440   ',0d0,2,0,0,0)
!       call dumpda('a440   ',0,0)
!     call abend('a440                                              ')
!     endif
+ei
      if(ilinc.eq.1) then
        typ=bez(ix)
+ca umlalid
        if(i.eq.nt) goto 470
      endif
 430  continue ! END LOOP OVER SINGLE ELEMENTS IN UMLAUDA

!FOX  YP(1)=Y(1)*(ONE+DPDA) ;
!FOX  YP(2)=Y(2)*(ONE+DPDA) ;
+if debug
!     call wda('afox   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('afox   ',0,0)
!     call abend('afox                                              ')
!     endif
+ei
      if(icav.eq.0.or.ithick.ne.1) then
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=SIGMDA ;
!FOX  CORRAU1(6)=DPDA1 ;
+if debug
!     call wda('b435   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b435   ',0,0)
!     call abend('b435                                              ')
!     endif
+ei
        do 435 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  435   continue
        if(ivar.gt.ivar1) then
!FOX  CORRAU1(7)=SMIDA(1) ;
!FOX  CORRAU1(8)=SMIDA(2) ;
          dpdav=dare(smida(1))
!FOX  CORRNEW(7)=SMIDA(1)-DPDAV ;
          dpdav=dare(smida(2))
!FOX  CORRNEW(8)=SMIDA(2)-DPDAV ;
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
+if debug
!     call wda('b436   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b436   ',0,0)
!     call abend('b436                                              ')
!     endif
+ei
        do 436 kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  436   continue
!FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
!FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
!FOX  X(1)=CORRAU2(1) ;
!FOX  YP(1)=CORRAU2(2) ;
!FOX  X(2)=CORRAU2(3) ;
!FOX  YP(2)=CORRAU2(4) ;
!FOX  SIGMDA=CORRAU2(5) ;
!FOX  DPDA1=CORRAU2(6) ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      endif
      call dacop(x(1),damap(1))
      call dacop(x(2),damap(3))
      if(ndimf.eq.3) call dacop(sigmda,damap(5))
      if(icoonly.eq.1.or.iqmodc.eq.3) then
        call dacop(y(1),damap(2))
        call dacop(y(2),damap(4))
        if(ndimf.eq.3) call dacop(dpda,damap(6))
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(damap(ii),jj,aml6(ii,i))
            if(i.eq.6) aml6(ii,i)=aml6(ii,i)*c1e3
          enddo
          jj(i)=0
        enddo
        do i=1,nd2
          aml6(i,i)=aml6(i,i)-one
        enddo
      endif
+if debug
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
+ei
      call dacop(yp(1),damap(2))
      call dacop(yp(2),damap(4))
      if(ndimf.eq.3) then
        call dacop(sigmda,damap(5))
        call dacop(dpda1,damap(6))
      else
        call dacop(dpda1,damap(5))
      endif
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ilin.ge.2) then
        rewind 18
!Eric
        rewind 111
        call daprid(damap,1,nvar,18)
      endif
+if debug
!     call wda('boutput',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('boutput',0,0)
!     call abend('boutput                                           ')
!     endif
+ei
!--now do the output
      if(iqmodc.eq.1) call danot(3)
      if(iqmodc.eq.3) call danot(2)
      if(ichromc.eq.1) call danot(4)
      if(ilinc.eq.1.or.ilinc.eq.2.or.iqmodc.eq.1.or.iqmodc.eq.3.or.     &
     &ichromc.eq.1) then
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
      endif
      if(iqmodc.eq.1.or.iqmodc.eq.3) then
        call gettura(wxys,rrad)
        wxys(3)=abs(wxys(3))
        write(lout,*) (wxys(i),i=1,ndimf)
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(aa2(ii),jj,tas)
            if(i.eq.6.and.ii.ne.6) tas=tas*c1e3
            if(ii.eq.6.and.i.ne.6) tas=tas*c1m3
            tasm(ii,i)=tas
          enddo
          jj(i)=0
        enddo
      endif
      if(iqmodc.eq.1) then
        call dhdj(h,df)
        do i=1,ndimf
          call dapek(df(ndimf+i),jj,corr(1,i))
        enddo
        corr(1,3)=abs(corr(1,3))
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+1)=0
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+2)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(90)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-one*coefh2)/det1                                     !hr05
        corr(3,1)=(-one*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
      if(ichromc.eq.1) then
        call dhdj(h,df)
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,corr(1,1))
        call dapek(df(ndimf+2),jj,corr(1,2))
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+2)=0
        jj(nd2+3)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+3)=0
        jj(nd2+1)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(96)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-one*coefh2)/det1                                     !hr05
        corr(3,1)=(-one*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
 470  continue
+if debug
!     call wda('a470   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('a470   ',0,0)
!     call abend('a470                                              ')
!     endif
+ei
      call dadal(damap,6)
      call dadal(damapi,6)
      call dadal(damap1,6)
      call dadal(angno,1)
      call dadal(f,1)
      call dadal(aa2,6)
      call dadal(aa2r,6)
      call dadal(a1,6)
      call dadal(a1r,6)
      call dadal(xy,6)
      call dadal(h,1)
      call dadal(df,6)
!     DADAL AUTOMATIC INCLUSION
      return
!-----------------------------------------------------------------------
10000 format(/t5 ,'---- ENTRY ',i1,'D LINOPT ----')
10010 format(133('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f13.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format('|',6x,'|',8x,'|',12x,'|','Y','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10050 format('|',6x,'|',a8,'|',12x,'|','S','|',12x,'|',f13.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10055 format('|',6x,'|',a8,'|',12x,'|','Y','|',12x,'|',f13.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10060 format('|',6x,'|',8x,'|',12x,'|',103('-'))
10070 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f13.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10080 format('|',6x,'|',8x,'|',12x,'|','X','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10090 format('|',6x,'|',8x,'|',12x,'|','S','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10100 format('|',6x,'|',8x,'|',12x,'|','S','|',f12.7,'|',ES13.6,'|',    &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10110 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,        &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10120 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,        &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10130 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
      end
!
!-----------------------------------------------------------------------
! WIRE DIFFERENTIAL ALGEBRA
+dk wireda
      subroutine wireda(ix,i)
! MODEL OF STRAIGHT CURRENT WIRE
!
!     The model provides a transfer map of a straight current wire. 
!     Description:
!     1. Infinitly thin wire with arbitrary orientation.
!     2. Thin element in SixTrack (L)=0
!     3. Parameters: 
!     dx, dy: horizontal and vertical distances between wire midpoint
!     and closed orbit [mm] 
!     (parameters are given by dx and dy in WIRE block)
!     tx, ty: tilt of the wire w.r.t the closed orbit in the
!     horizontal and vertical planes (in degrees) 
!     (parameters are given by tiltx and tilty in WIRE block)
!     L - physical length of the wire element [m]
!     cur - current of the wire [Amperes]
!     embl - embedding drift (integrated length or integration interval) [m] 
!     4. The transport map is given for canonical variables (x,px...)
!
! The MAP is constructed out of the following steps:
!     1. Declaration of shifted canonical variables: 
!          rx = x+dx; ry = y+dy  in the same way as for the BEAM-BEAM element
!     2. Symplectic Rotation by the tilt angles tx, ty (in 4D space: px, rx, py, ry)
!     3. Wire kick for a longitudinally aligned wire (= kick for tx=ty=0)
!     4. Symplectic Rotation back by the tilt angles -ty, -yx (in 4D space: ...taking only PX, PY)
!--------------------------------------------------------------
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I

      use floatPrecision
      use mathlib_bouncer
      use physical_constants
      use numerical_constants
      use crcoall
      implicit none
      integer ix,idaa,i
      real(kind=fPrec) NNORM_, XCLO, YCLO
      real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi
+ca parpro
+ca common
+ca commons
+ca commont2
+ca commond1
+ca commondl
+ca commonl
+ca commonxz
+ca wireparam
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
+ca dainicom
!FOX  D V DA INT XI NORD NVAR ; D V DA INT YI NORD NVAR ;
!FOX  D V DA INT DXI NORD NVAR ; D V DA INT DYI NORD NVAR ;
!FOX  D V RE INT EMBL ; D V RE INT TX ; D V RE INT TY ;
!FOX  D V RE INT DX ; D V RE INT DY ;
!FOX  D V RE INT XCLO ; D V RE INT YCLO ;
!FOX  D V RE INT CHI ;
!FOX  D V RE INT CUR ;
!FOX  D V RE INT L ; D V RE INT ONE ; D V RE INT TWO ;
!FOX  D V RE INT C1M7 ;
!FOX  D V RE INT C1E3 ; D V RE INT C1M3 ;
!FOX  D V DA INT RTWO_ NORD NVAR ; 
!FOX  D V RE INT NNORM_ ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!-- WIRE
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I
!     magnetic rigidity

      CHI = (sqrt(e0**2-pmap**2)*c1e6)/clight
      TX = wire_tiltx(ix) !tilt x [degrees] 
      TY = wire_tilty(ix) !tilt y [degrees]
      TX = TX*(pi/c180e0) ![rad]
      TY = TY*(pi/c180e0) ![rad]
      DX = wire_dispx(ix) !displacement x [mm]
      DY = wire_dispy(ix) !displacement y [mm]
      EMBL = wire_lint(ix) !integrated length [m]
      L = wire_lphys(ix) !physical length [m]
      CUR = wire_current(ix)
      XCLO = wire_clo(1,wire_num(i))
      YCLO = wire_clo(2,wire_num(i))
      NNORM_=c1m7/chi

      if (abs(wire_flagco(ix)).ne.1) then
        write(lout,                                                     &
     &fmt='((A,A,/),(A,I0,A,A,/),(A,I0,A,I0,/))')                       &
     &'ERROR: in wirekick -  wire_flagco defined in WIRE block must ',  &
     &'be either 1 or -1!','bez(',ix,') = ',bez(ix),                    &
     &'wire_flagco(',ix,') = ',wire_flagco(ix)
        call prror(-1)
      endif

!FOX  YY(1)=YY(1)*C1M3;
!FOX  YY(2)=YY(2)*C1M3;

!!FOX  DXI=DX*C1M3;
!!FOX  DYI=DY*C1M3;
      IF (wire_flagco(ix).eq.1) THEN
!FOX  DXI=(DX+XCLO)*C1M3;
!FOX  DYI=(DY+YCLO)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
!FOX  DXI=DX*C1M3;
!FOX  DYI=DY*C1M3;
      END IF



!-----------------------------------------------------------------------
! X' -> PX'; Y' -> PY
!FOX  YY(1)=YY(1)*(ONE+DPDA) ;
!FOX  YY(2)=YY(2)*(ONE+DPDA) ;

! 1 SHIFT - see the part of the code were wireda is called ....

      IF (wire_flagco(ix).eq.1) THEN
!FOX  XI=(XX(1)+DX)*C1M3;
!FOX  YI=(XX(2)+DY)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
!FOX  XI=(XX(1)+(DX-XCLO))*C1M3;
!FOX  YI=(XX(2)+(DY-YCLO))*C1M3;
      END IF

! ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
!FOX  YI=YI-((XI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

!FOX  XI=XI-((YI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
!FOX  RTWO_=XI*XI+YI*YI;
!FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;

! ibeco =1
      elseif(ibeco.eq.1) then

!FOX  DYI=DYI-((DXI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  DXI=DXI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YI=YI-XI*SIN(TX)*YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

!FOX  DXI=DXI-((DYI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  DYI=DYI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  XI=XI-YI*SIN(TY)*YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
!FOX  RTWO_=XI*XI+YI*YI;
!FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
!FOX  RTWO_=DXI*DXI+DYI*DYI;
!FOX  YY(1)=YY(1)+(((CUR*NNORM_)*DXI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)+(((CUR*NNORM_)*DYI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
      endif

! 4 symplectic backward rotation of coordinate system (-ty, -tx)
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TY) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TX) ;

! PX -> X'; PY -> Y'
!FOX  YY(1)=YY(1)/(ONE+DPDA) ;
!FOX  YY(2)=YY(2)/(ONE+DPDA) ;

!FOX  YY(1)=YY(1)*C1E3;
!FOX  YY(2)=YY(2)*C1E3;

!     DADAL AUTOMATIC INCLUSION
      end
+dk runcav
      subroutine runcav
!-----------------------------------------------------------------------
!               DIFFERENTIAL ALGEBRA FOR CAVITY
!                          AUGUST 1994
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      integer idaa
      real(kind=fPrec) betr0,dare,sigmdac
+ca parpro
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonxz
+ca commonm1
+ca commond1
      save
!-----------------------------------------------------------------------
+ca daini
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      betr0=sqrt(one-(pma/e0)**2)
      write(lout,*) ' REENTERING MAP '
      call davar(x(1),zero,1)
      call davar(yp(1),zero,2)
      call davar(x(2),zero,3)
      call davar(yp(2),zero,4)
      call davar(sigmda,zero,5)
      call davar(dpda1,zero,6)
      call darea(x(1),18)
      call darea(yp(1),18)
      call darea(x(2),18)
      call darea(yp(2),18)
      call darea(sigmda,18)
      call darea(dpda1,18)
      rewind 18
!Eric
        rewind 111
      if(ition.ne.0) then
      e0f=sqrt(e0**2-pma**2)                                             !hr08
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  EJF1=E0F*(ONE+DPDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+PMA*PMA) ;
!FOX  EJF0=EJF1 ;
        if(abs(dppoff).gt.pieni) then
          sigmdac=sigmoff(iicav)
!FOX  SIGMDA=SIGMDA-SIGMDAC ;
        endif
        call synoda
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  Y(1)=YP(1)/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)/(ONE+DPDA) ;
      endif
      if(nvar2.ge.1) call dapri(x(1),18)
      if(nvar2.ge.2) call dapri(yp(1),18)
      if(nvar2.ge.3) call dapri(x(2),18)
      if(nvar2.ge.4) call dapri(yp(2),18)
      if(nvar2.eq.5) call dapri(dpda1,18)
      if(nvar2.eq.6) call dapri(sigmda,18)
      if(nvar2.eq.6) call dapri(dpda1,18)
      
      write(lout,*) 'END COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      
      write(12,'(E22.15)') dare(x(1))
      write(12,'(E22.15)') dare(y(1))
      write(12,'(E22.15)') dare(x(2))
      write(12,'(E22.15)') dare(y(2))
      write(12,'(E22.15)') dare(sigmda)
      write(12,'(E22.15)') dare(dpda)
      
      write(lout,10010)
!-----------------------------------------------------------------------
!     DADAL AUTOMATIC INCLUSION
      time2=0.
      call timex(time2)
!     time=time2-time1
      write(lout,10020) time1-time0
      write(lout,10030) nord,time2-time1
      return
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. ',     &
     &i7,' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,              &
     &'HORIZ:  AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,        &
     &'VERT:   AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,        &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
10010 format(//t10,30('*')/t10,'**** ONE TURN COMPLETED ****'/ t10,30(  &
     &'*')/)
10020 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10030 format(/10x,'DA-Calculation of Order : ',i7,' took ', f12.3,      &
     &' second(s) of CPU Time'//131('-')//)
      end

+dk synoda
      subroutine synoda
!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!        SPECIALLY PREPARED FOR NEW D.A.
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer ix,idaa
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commond1
+ca commonm1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
+ca dainicom
!FOX  D V RE INT E0 ; D V RE INT PMA ; D V RE EXT E0F ;
!FOX  D V RE INT HSY 3 ; D V RE INT PHAS ;
!FOX  D V RE EXT ED NELE ; D V RE EXT HSYC NELE ;
!FOX  D V RE EXT PHASC NELE ;
!FOX  D V RE INT C1E3 ; D V RE INT ONE ;
!FOX  D V IN EXT ITIONC NELE ; D V IN INT ITION ; D V IN INT IX ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      ix=ixcav
      if(kz(ix).eq.12) then
!FOX  EJ1=EJ1+ED(IX)*SIN(HSYC(IX)*SIGMDA/C1E3*
!FOX  ITIONC(IX)+PHASC(IX)) ;
      else
!FOX  EJ1=EJ1+HSY(1)*SIN(HSY(3)*SIGMDA/C1E3*ITION+PHAS) ;
      endif
!FOX  EJF1=SQRT(EJ1*EJ1-PMA*PMA) ;
!FOX  DPDA1=(EJF1-E0F)/E0F*C1E3 ;
      return
      end

+dk errff
      subroutine errff(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! PURPOSE:                                                             *
!   MODIFICATION OF WWERF, DOUBLE PRECISION COMPLEX ERROR FUNCTION,    *
!   WRITTEN AT CERN BY K. KOELBIG.                                     *
!   TAKEN FROM MAD8                                                    *
!   VERSION FOR MAP PRODUCTION USING BERZ'S DA PACKAGE                 *
! INPUT:                                                               *
!   XX, YY    (REAL)    ARGUMENT TO CERF.                              *
! OUTPUT:                                                              *
!   WX, WY    (REAL)    FUNCTION RESULT.                               *
!----------------------------------------------------------------------*
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      integer n,n1,nc,nuu,nuu1,idaa
      real(kind=fPrec) cc,dare,dum,xlim,ylim
+ca parpro
      parameter(cc = 1.12837916709551_fPrec)
      parameter(xlim = 5.33_fPrec)
      parameter(ylim = 4.29_fPrec)
+ca common
+ca commons
+ca commont2
+ca commondl
+ca commonl
+ca commonxz
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT XX NORD NVAR ; D V DA EXT YY NORD NVAR ;
!FOX  D V DA EXT WX NORD NVAR ; D V DA EXT WY NORD NVAR ;
!FOX  D V DA INT X NORD NVAR ; D V DA INT Y NORD NVAR ;
!FOX  D V DA INT Q NORD NVAR ; D V DA INT H NORD NVAR ;
!FOX  D V DA INT XH NORD NVAR ; D V DA INT YH NORD NVAR ;
!FOX  D V DA INT RX NORD NVAR 33 ; D V DA INT RY NORD NVAR 33 ;
!FOX  D V DA INT TX NORD NVAR ; D V DA INT TN NORD NVAR ;
!FOX  D V DA INT TY NORD NVAR ;D V DA INT SAUX NORD NVAR ;
!FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
!FOX  D V DA INT XL NORD NVAR ;
!FOX  D V RE INT XLIM ; D V RE INT YLIM ; D V RE INT TWO ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT HALF ;
!FOX  D V RE INT CC ; D V RE INT DUM ;
!FOX  D V IN INT NC ; D V IN INT N ; D V IN INT N1 ; D V IN INT NUU ;
!FOX  D V IN INT NUU1 ; D V IN INT NCC ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX  X=XX ;
!FOX  Y=YY ;
      if(dare(x).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(x) < 0'
!FOX    X=-X ;
      endif
      if(dare(y).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(y) < 0'
!FOX    Y=-Y ;
      endif
      if(dare(y).lt.ylim.and.dare(x).lt.xlim) then
!FOX    Q=(ONE-Y/YLIM)*SQRT(ONE-X*X/XLIM/XLIM) ;
!FOX    DUM=3.2D0 ;
!FOX    H=ONE/(DUM*Q) ;
        nc=7+int(23.0_fPrec*dare(q))
!FOX    XL=EXP((1-NC)*LOG(H)) ;
!FOX    XH=Y+HALF/H ;
!FOX    YH=X ;
        nuu=10+int(21.0_fPrec*dare(q))
        nuu1=nuu+1
!FOX    RX(NUU1)=ZERO ;
!FOX    RY(NUU1)=ZERO ;
        do 10 n=nuu,1,-1
          n1=n+1
!FOX      TX=XH+N*RX(N1) ;
!FOX      TY=YH-N*RY(N1) ;
!FOX      TN=TX*TX+TY*TY ;
!FOX      RX(N)=HALF*TX/TN ;
!FOX      RY(N)=HALF*TY/TN ;
   10   continue
!FOX    SX=ZERO ;
!FOX    SY=ZERO ;
        do 20 n=nc,1,-1
!FOX      SAUX=SX+XL ;
!FOX      SX=RX(N)*SAUX-RY(N)*SY ;
!FOX      SY=RX(N)*SY+RY(N)*SAUX ;
!FOX      XL=H*XL ;
   20   continue
!FOX    WX=CC*SX ;
!FOX    WY=CC*SY ;
      else
!FOX    XH=Y ;
!FOX    YH=X ;
!FOX    RX(1)=ZERO ;
!FOX    RY(1)=ZERO ;
        do 30 n=9,1,-1
!FOX      TX=XH+N*RX(1) ;
!FOX      TY=YH-N*RY(1) ;
!FOX      TN=TX*TX+TY*TY ;
!FOX      RX(1)=HALF*TX/TN ;
!FOX      RY(1)=HALF*TY/TN ;
   30   continue
!FOX    WX=CC*RX(1) ;
!FOX    WY=CC*RY(1) ;
      endif
!      if(dare(y).eq.0.) then
!!FOX    WX=EXP(-X*X) ;
!      endif
      if(dare(yy).lt.0.d0) then                                          !hr05
!FOX    WX=TWO*EXP(Y*Y-X*X)*COS(TWO*X*Y)-WX ;
!FOX    WY=-TWO*EXP(Y*Y-X*X)*SIN(TWO*X*Y)-WY ;
        if(dare(xx).gt.0.d0) then                                        !hr05
!FOX      WY=-WY ;
        endif
      else
        if(dare(xx).lt.0.d0) then                                        !hr05
!FOX      WY=-WY ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      return
      end

+dk beam6df
      subroutine beaminf(track,param,sigzs,bcu,ibb,ne,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999         
!
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      integer ibb,ibbc,ne,nsli,idaa
      real(kind=fPrec) alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,star,tphi,phi2,cphi2,sphi2,tphi2
+ca parpro
+ca commondl
      dimension param(nele,18),bcu(nbb,12),star(3,mbea)
+if bnlelens
+ca rhicelens
+ei
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         !sepax=param(ne,5)     !Not actually used anywhere?
         !sepay=param(ne,6)     !Not actually used anywhere?
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beaminf"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
      sphi=sin_mb(phi)
      sphi2=sin_mb(phi2)
      cphi=cos_mb(phi)
      cphi2=cos_mb(phi2)
      tphi=tan_mb(phi)
      tphi2=tan_mb(phi2)
      salpha=sin_mb(alpha)
      calpha=cos_mb(alpha)
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boostf(sphi,cphi,tphi,salpha,calpha,track)
      call sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
      call boostif(sphi,cphi,tphi,salpha,calpha,track)
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine boostf(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
! BOOSTF Boost Operation *******************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer idaa
      real(kind=fPrec) calpha,cphi,salpha,sphi,tphi,cphi2,sphi2,tphi2
+ca parpro
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A NORD NVAR ;
!FOX  D V DA INT H NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
!FOX  D V DA INT A1 NORD NVAR ; D V DA INT HD1 NORD NVAR ;
!FOX  D V DA INT H1X NORD NVAR ; D V DA INT H1Y NORD NVAR ;
!FOX  D V DA INT H1Z NORD NVAR ; D V DA INT X1 NORD NVAR ;
!FOX  D V DA INT Y1 NORD NVAR ;
!FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
!FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
!FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
!FOX  D V RE INT ONE ; D V RE INT C1E3 ;
!FOX  D V DA INT DET NORD NVAR ; D V DA INT H1 NORD NVAR ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX    H=TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
!FOX    TRACK(6)=TRACK(6)-CALPHA*TPHI*TRACK(2)
!FOX              -TRACK(4)*SALPHA*TPHI+H*TPHI*TPHI ;
!FOX    TRACK(2)=(TRACK(2)-TPHI*H*CALPHA)/CPHI ;
!FOX    TRACK(4)=(TRACK(4)-TPHI*H*SALPHA)/CPHI ;
!FOX    HD1=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-TRACK(2)*TRACK(2)-
!FOX    TRACK(4)*TRACK(4)) ;
!FOX    H1X=TRACK(2)/HD1 ;
!FOX    H1Y=TRACK(4)/HD1 ;
!FOX    H1Z=ONE-(ONE+TRACK(6))/HD1 ;
!FOX    X1=CALPHA*TPHI*TRACK(5)+(ONE+CALPHA*SPHI*H1X)*TRACK(1)
!FOX       +TRACK(3)*SALPHA*SPHI*H1X ;
!FOX    Y1=SALPHA*TPHI*TRACK(5)+(ONE+SALPHA*SPHI*H1Y)*TRACK(3)
!FOX       +TRACK(1)*CALPHA*SPHI*H1Y ;
!FOX    TRACK(5)=TRACK(5)/CPHI+H1Z*(SPHI*CALPHA*TRACK(1)
!FOX       +SPHI*SALPHA*TRACK(3)) ;
!FOX    TRACK(1)=X1 ;
!FOX    TRACK(3)=Y1 ;
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**SBCF ***Synchro-Beam for headon collision*********************
!****************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer ibb,ibbc,ibbc1,jsli,nsli,idaa
      real(kind=fPrec) bcu,cphi,cphi2,dare,f,sfac,star
+ca parpro
+ca commondl
      dimension star(3,mbea),bcu(nbb,12)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ;
!FOX  D V DA INT S NORD NVAR ; D V DA INT SP NORD NVAR ;
!FOX  D V DA INT DD NORD NVAR ;
!FOX  D V DA INT DUM NORD NVAR 13 ;
!FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
!FOX  D V DA INT SEPX NORD NVAR ; D V DA INT SEPY NORD NVAR ;
!FOX  D V DA INT SEPX0 NORD NVAR ; D V DA INT SEPY0 NORD NVAR ;
!FOX  D V DA INT COSTH NORD NVAR ; D V DA INT SINTH NORD NVAR ;
!FOX  D V DA INT COSTHP NORD NVAR ; D V DA INT SINTHP NORD NVAR ;
!FOX  D V DA INT BBFX NORD NVAR ; D V DA INT BBFY NORD NVAR ;
!FOX  D V DA INT BBF0 NORD NVAR ; D V DA INT BBGX NORD NVAR ;
!FOX  D V DA INT BBGY NORD NVAR ;
!FOX  D V RE EXT STAR 3 MBEA ; D V RE EXT F ; D V RE EXT BCU NBB 12 ;
!FOX  D V IN EXT IBB ;
!FOX  D V RE INT HALF ; D V RE INT TWO ; D V RE INT FOUR ;
!FOX  D V RE INT ZERO ; D V RE INT ONE ; D V RE INT C1E3 ;
!FOX  D V RE INT SFAC ; D V RE INT CPHI ; D V RE INT CPHI2 ;
!FOX  D V IN INT JSLI ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
!FOX    S=(TRACK(5)-STAR(3,JSLI))*HALF ;
!FOX    SP=S/CPHI2 ;
!FOX    DUM(1)=BCU(IBB,1)+TWO*BCU(IBB,4)*SP+BCU(IBB,6)*SP*SP ;
!FOX    DUM(2)=BCU(IBB,2)+TWO*BCU(IBB,9)*SP+BCU(IBB,10)*SP*SP ;
!FOX    DUM(3)=BCU(IBB,3)+(BCU(IBB,5)+BCU(IBB,7))*SP+
!FOX    BCU(IBB,8)*SP*SP ;
!FOX    DUM(4)=DUM(1)-DUM(2) ;
!FOX    DUM(5)=DUM(4)*DUM(4)+FOUR*DUM(3)*DUM(3) ;
        if(ibbc.eq.1.and.(abs(dare(dum(4))).gt.pieni.and.               &
     &abs(dare(dum(5))).gt.pieni)) then
          ibbc1=1
!FOX    DUM(5)=SQRT(DUM(5)) ;
        else
          ibbc1=0
        endif
!FOX    SEPX0=TRACK(1)+TRACK(2)*S-STAR(1,JSLI) ;
!FOX    SEPY0=TRACK(3)+TRACK(4)*S-STAR(2,JSLI) ;
        if(ibbc1.eq.1) then
          sfac=one
          if(dare(dum(4)).lt.zero) sfac=(-one*one)                       !hr05
!FOX    DUM(6)=SFAC*DUM(4)/DUM(5) ;
!FOX    DUM(7)=DUM(1)+DUM(2) ;
!FOX    COSTH=HALF*(ONE+DUM(6)) ;
          if(abs(dare(costh)).gt.pieni) then
!FOX    COSTH=SQRT(COSTH) ;
          else
!FOX    COSTH=ZERO ;
          endif
!FOX    SINTH=HALF*(ONE-DUM(6)) ;
          if(abs(dare(sinth)).gt.pieni) then
!FOX    SINTH=SFAC*SQRT(SINTH) ;
          else
!FOX    SINTH=ZERO ;
          endif
          if(dare(dum(3)).lt.zero) then
!FOX    SINTH=-SINTH ;
          endif
!FOX    SY=SFAC*DUM(5) ;
!FOX    SX=(DUM(7)+SY)*HALF ;
!FOX    SY=(DUM(7)-SY)*HALF ;
!FOX    SEPX=SEPX0*COSTH+SEPY0*SINTH ;
!FOX    SEPY=-SEPX0*SINTH+SEPY0*COSTH ;
        else
!FOX    SX=DUM(1) ;
!FOX    SY=DUM(2) ;
!FOX    SEPX=SEPX0 ;
!FOX    SEPY=SEPY0 ;
        endif
        if(dare(sx).gt.dare(sy)) then
          call bbff(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy)
        else
          call bbff(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx)
        endif
!FOX    BBFX=F*BBFX ;
!FOX    BBFY=F*BBFY ;
!FOX    BBGX=F*BBGX ;
!FOX    BBGY=F*BBGY ;
        if(ibbc1.eq.1) then
!FOX    DUM(8)=TWO*(BCU(IBB,4)-BCU(IBB,9)+(BCU(IBB,6)-BCU(IBB,10))*SP) ;
!FOX    DUM(9)=BCU(IBB,5)+BCU(IBB,7)+TWO*BCU(IBB,8)*SP ;
!FOX    DUM(10)=(DUM(4)*DUM(8)+FOUR*DUM(3)*DUM(9))/
!FOX    DUM(5)/DUM(5)/DUM(5) ;
!FOX    DUM(11)=SFAC*(DUM(8)/DUM(5)-DUM(4)*DUM(10)) ;
!FOX    DUM(12)=BCU(IBB,4)+BCU(IBB,9)+(BCU(IBB,6)+BCU(IBB,10))*SP ;
!FOX    DUM(13)=SFAC*(DUM(4)*DUM(8)*HALF+TWO*DUM(3)*DUM(9))/DUM(5) ;
          if(abs(dare(costh)).gt.pieni) then
!FOX    COSTHP=DUM(11)/FOUR/COSTH ;
          else
!FOX    COSTHP=ZERO ;
          endif
          if(abs(dare(sinth)).gt.pieni) then
!FOX    SINTHP=-DUM(11)/FOUR/SINTH ;
          else
!FOX    SINTHP=ZERO ;
          endif
!FOX    TRACK(6)=TRACK(6)-
!FOX    (BBFX*(COSTHP*SEPX0+SINTHP*SEPY0)+
!FOX    BBFY*(-SINTHP*SEPX0+COSTHP*SEPY0)+
!FOX    BBGX*(DUM(12)+DUM(13))+BBGY*(DUM(12)-DUM(13)))/
!FOX    CPHI*HALF ;
!FOX    BBF0=BBFX ;
!FOX    BBFX=BBF0*COSTH-BBFY*SINTH ;
!FOX    BBFY=BBF0*SINTH+BBFY*COSTH ;
        else
!FOX    TRACK(6)=TRACK(6)-
!FOX    (BBGX*(BCU(IBB,4)+BCU(IBB,6)*SP)+
!FOX    BBGY*(BCU(IBB,9)+BCU(IBB,10)*SP))/CPHI ;
        endif
!FOX    TRACK(6)=TRACK(6)-(BBFX*(TRACK(2)-BBFX*HALF)+
!FOX    BBFY*(TRACK(4)-BBFY*HALF))*HALF ;
!FOX    TRACK(1)=TRACK(1)+S*BBFX ;
!FOX    TRACK(2)=TRACK(2)-BBFX ;
!FOX    TRACK(3)=TRACK(3)+S*BBFY ;
!FOX    TRACK(4)=TRACK(4)-BBFY ;
 2000 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine boostif(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
! BOOSTIF **************inverse boost ****************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer idaa
      real(kind=fPrec) calpha,cphi,salpha,sphi,tphi
+ca parpro
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A1 NORD NVAR ;
!FOX  D V DA INT H1 NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
!FOX  D V DA INT H1D NORD NVAR ; D V DA INT H1X NORD NVAR ;
!FOX  D V DA INT H1Y NORD NVAR ; D V DA INT H1Z NORD NVAR ;
!FOX  D V DA INT DET NORD NVAR ; D V DA INT X1 NORD NVAR ;
!FOX  D V DA INT Y1 NORD NVAR ; D V DA INT Z1 NORD NVAR ;
!FOX  D V RE INT ONE ; D V RE INT TWO ;
!FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
!FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
!FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX    H1D=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
!FOX    H1X=TRACK(2)/H1D ;
!FOX    H1Y=TRACK(4)/H1D ;
!FOX    H1Z=ONE-(ONE+TRACK(6))/H1D ;
!FOX    H1=(TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)))*CPHI*CPHI ;
!FOX    DET=ONE/CPHI+TPHI*(H1X*CALPHA+H1Y*SALPHA-H1Z*SPHI) ;
!FOX    X1= TRACK(1)*(ONE/CPHI+SALPHA*(H1Y-H1Z*SALPHA*SPHI)*TPHI)
!FOX       +TRACK(3)*SALPHA*TPHI*(-H1X+H1Z*CALPHA*SPHI)
!FOX       -TRACK(5)*(CALPHA+H1Y*CALPHA*SALPHA*SPHI
!FOX       -H1X*SALPHA*SALPHA*SPHI)*TPHI ;
!FOX    Y1= TRACK(1)*CALPHA*TPHI*(-H1Y+H1Z*SALPHA*SPHI)
!FOX       +TRACK(3)*(ONE/CPHI+CALPHA*(H1X-H1Z*CALPHA*SPHI)*TPHI)
!FOX       -TRACK(5)*(SALPHA-H1Y*CALPHA*CALPHA*SPHI
!FOX       +H1X*CALPHA*SALPHA*SPHI)*TPHI ;
!FOX    Z1=-TRACK(1)*H1Z*CALPHA*SPHI
!FOX       -TRACK(3)*H1Z*SALPHA*SPHI
!FOX       +TRACK(5)*(ONE+H1X*CALPHA*SPHI+H1Y*SALPHA*SPHI) ;
!FOX    TRACK(1)=X1/DET ;
!FOX    TRACK(3)=Y1/DET ;
!FOX    TRACK(5)=Z1/DET ;
!FOX    TRACK(6)=TRACK(6)+CALPHA*SPHI*TRACK(2)
!FOX            +SALPHA*SPHI*TRACK(4) ;
!FOX    TRACK(2)=(TRACK(2)*CPHI+CALPHA*TPHI*H1) ;
!FOX    TRACK(4)=(TRACK(4)*CPHI+SALPHA*TPHI*H1) ;
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine bbff(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**********************************************************************
! BBFF gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer idaa
      real(kind=fPrec) dare,hundred,sqrpi2
+ca parpro
      parameter(sqrpi2 = 3.544907701811032_fPrec,hundred = c1e2)
+ca commondl
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT SEPX NORD NVAR ; D V DA EXT SEPY NORD NVAR ;
!FOX  D V DA EXT SIGXX NORD NVAR ; D V DA EXT SIGYY NORD NVAR ;
!FOX  D V DA EXT BBFX NORD NVAR ; D V DA EXT BBFY NORD NVAR ;
!FOX  D V DA EXT BBGX NORD NVAR ; D V DA EXT BBGY NORD NVAR ;
!FOX  D V DA INT SIGXY NORD NVAR ; D V DA INT EXPFAC NORD NVAR ;
!FOX  D V DA INT X NORD NVAR ; D V DA INT FAC NORD NVAR ;
!FOX  D V DA INT FAC2 NORD NVAR ; D V DA INT CONST NORD NVAR ;
!FOX  D V DA INT ARG1X NORD NVAR ; D V DA INT ARG1Y NORD NVAR ;
!FOX  D V DA INT ARG2X NORD NVAR ; D V DA INT ARG2Y NORD NVAR ;
!FOX  D V DA INT WX1 NORD NVAR ; D V DA INT WY1 NORD NVAR ;
!FOX  D V DA INT WX2 NORD NVAR ; D V DA INT WY2 NORD NVAR ;
!FOX  D V DA INT COMFAC NORD NVAR ; D V DA INT COMFAC2 NORD NVAR ;
!FOX  D V RE INT ZERO ; D V RE INT HALF ; D V RE INT ONE ;
!FOX  D V RE INT TWO ; D V RE INT FOUR ; D V RE INT HUNDRED ;
!FOX  D V RE INT SQRPI2 ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if(dare(sigxx).eq.dare(sigyy)) then
!FOX    X=SEPX*SEPX+SEPY*SEPY ;
        if(abs(dare(sigxx)+dare(sigyy)).gt.pieni) then
!FOX      CONST=X/(SIGXX+SIGYY) ;
        else
!FOX      CONST=ZERO ;
        endif
!FOX    EXPFAC=EXP(-CONST) ;
        if(abs(dare(x)).gt.pieni) then
!FOX      BBFX=TWO*SEPX*(ONE-EXPFAC)/X ;
!FOX      BBFY=TWO*SEPY*(ONE-EXPFAC)/X ;
!FOX      COMFAC=-SEPX*BBFX+SEPY*BBFY ;
          if(dare(sigxx).lt.zero) then
!FOX        SIGXX=-SIGXX ;
          endif
          if(dare(sigyy).lt.zero) then
!FOX        SIGYY=-SIGYY ;
          endif
!FOX      COMFAC2=(SIGXX+SIGYY)*(SIGXX+SIGYY) ;
!FOX      BBGX=(COMFAC+FOUR*SEPX*SEPX*CONST/X*EXPFAC)/(TWO*X) ;
!FOX      BBGY=(-COMFAC+FOUR*SEPY*SEPY*CONST/X*EXPFAC)/(TWO*X) ;
        else
!FOX      BBFX=ZERO ;
!FOX      BBFY=ZERO ;
!FOX      BBGX=ZERO ;
!FOX      BBGY=ZERO ;
        endif
      else
!FOX    X=SEPX*SEPX/SIGXX+SEPY*SEPY/SIGYY ;
!FOX    FAC2=TWO*(SIGXX-SIGYY) ;
        if(dare(sigxx).lt.dare(sigyy)) then
!FOX      FAC2=TWO*(SIGYY-SIGXX) ;
        endif
!FOX    FAC=SQRT(FAC2) ;
!FOX    CONST=SQRPI2/FAC ;
!FOX    SIGXY=SQRT(SIGXX/SIGYY) ;
!FOX    ARG1X=(SEPX/FAC) ;
        if(dare(sepx).lt.zero) then
!FOX      ARG1X=-(SEPX/FAC) ;
        endif
!FOX    ARG1Y=(SEPY/FAC) ;
        if(dare(sepy).lt.zero) then
!FOX      ARG1Y=-(SEPY/FAC) ;
        endif
        call errff(arg1x,arg1y,wy1,wx1)
        if(dare(x).lt.hundred) then
!FOX      EXPFAC=EXP(-X*HALF) ;
!FOX      ARG2X=ARG1X/SIGXY ;
!FOX      ARG2Y=ARG1Y*SIGXY ;
          call errff(arg2x,arg2y,wy2,wx2)
!FOX      BBFX=CONST*(WX1-EXPFAC*WX2) ;
!FOX      BBFY=CONST*(WY1-EXPFAC*WY2) ;
          if(dare(sepx).lt.zero) then
!FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
!FOX        BBFY=-BBFY ;
          endif
!FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
!FOX      BBGX=-(COMFAC+TWO*(EXPFAC/SIGXY-ONE))/FAC2 ;
!FOX      BBGY= (COMFAC+TWO*(EXPFAC*SIGXY-ONE))/FAC2 ;
        else
!FOX      BBFX=CONST*WX1 ;
!FOX      BBFY=CONST*WY1 ;
          if(dare(sepx).lt.zero) then
!FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
!FOX        BBFY=-BBFY ;
          endif
!FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
!FOX      BBGX=-(COMFAC-TWO)/FAC2 ;
!FOX      BBGY= -BBGX ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      return
      end
+dk maincr
      program maincr
      use floatPrecision
      use mathlib_bouncer
      use physical_constants
      use numerical_constants
+if datamods
      use bigmats
+ei
      use scatter, only : scatter_active, scatter_initialize

      use dynk, only : dynk_izuIndex

      use fma, only : fma_postpr, fma_flag

      use dump, only : dump_initialize, dumpclo,dumptas,dumptasinv

      use zipf, only : zipf_numfiles, zipf_dozip
      
      use, intrinsic :: iso_fortran_env, only : output_unit

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei
      
      use postprocessing, only : postpr, writebin_header, writebin
      
      use crcoall
      implicit none
+ca errout
!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  F. SCHMIDT, M. VANTTINEN
!
!  COLLIMATION VERSION, NOVEMBER 2004
!
!  G. ROBERT-DEMOLAIZE
!
!  COLLIMATION UPGRADE, JUNE 2005
!
!  G. ROBERT-DEMOLAIZE, S. REDAELLI
!
!  UPGRADED FOR COUPLING TO FLUKA, JULY 2013
!
!  A. MEREGHETTI, D. SINUELA PASTOR
!
!  FURTHER UPGRADE FOR COUPLING TO FLUKA, MAY-JUNE 2014
!
!  A. MEREGHETTI, P. GARCIA ORTEGA
!
!-----------------------------------------------------------------------
!  SIXTRACR CHECKPOINT/RESTART and CRLIBM (ENS Lyon)
!
!  E. MCINTOSH FEBRUARY 2005
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!  DATA FOR SUMMARY OF THE POSTPROCESSING   : UNIT 10
!  AUXILIARY FILE FOR THE INPUT             : UNIT 11
!  ASCII FILE WITH THE HORIZONTAL FFT DATA  : UNIT 14
!  ASCII FILE WITH THE VERTICAL FFT DATA    : UNIT 15
!  METAFILE FOR PLOTTING WITH GKS           : UNIT 20
!
+if cr
!  CHECKPOINT/RESTART FILES                 : UNIT 95,96
!  OPTIONAL DUMP.DEBUG FILE                 : UNIT 99
!  PROGRESS FILE                            : UNIT 91
!  INTERMEDIATE OUTPUT FILE (LOUT)          : UNIT 92
!  CHECKPOINT/RESTART LOGFILE               : UNIT 93
!  TEMPORARY SCRATCH FILE for C/R           : UNIT 94
+ei
!-----------------------------------------------------------------------
+ca parpro
+ca common
+ca commonex
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
! Eric needs nwri (clean up new variables and common blocks!)
+ca commontr
+if bnlelens
+ca rhicelens
+ei
+ca commonc
+if cr
+ca crco
+ei
+ca comgetfields
+ca dbdcum
+ca stringzerotrim

+ca comApeInfo
+ca dbreaddis

      integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,&
     &idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
     &jm,k,kpz,kzz,l,lkk,ll,m,mkk,ncorruo,ncrr,nd,nd2,ndafi2,           &
     &nerror,nlino,nlinoo,nmz,nthinerr
      real(kind=fPrec) alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
     &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
     &dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
     &gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
     &rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
     &tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
     &taus,x11,x13
      integer idummy(6)
      character(len=10) cmonth
      character(len=4) cpto
+if cr
      character(len=80) day
+ei
+if .not.cr
      character(len=80) day,runtim
+ei
      character(len=8) cdate,ctime,progrm !Note: Keep in sync with writebin_header and more
                                          !DANGER: If the len changes, CRCHECK will break.
+if boinc
      character(len=256) filename
+ei
+if crlibm
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      real(kind=fPrec) fround
      real(kind=fPrec) round_near
      data lineno /0/
+ei
+if debug
!     integer umcalls,dapcalls,dokcalls,dumpl
!     common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
+ei
      logical lopen
      dimension cmonth(12)
      data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
     &'  April   ','   May    ','   June   ','   July   ',' August  ',  &
     &' September',' October  ',' November ',' December '/
+ca version
!-----------------------------------------------------------------------
      
      errout_status = 0         ! Set to nonzero before calling abend in case of error.
                                ! If prror is called, it will be set internally.
      
+if crlibm
! Removed the call to disable_xp for Laurent
! but re-instated it
      call disable_xp()
+ei
+if debug
!     umcalls=0
!     dapcalls=0
!     dokcalls=0
!     dumpl=0
+ei
! Set napx,napxo,trtime for error handling
      napx=0
      napxo=0
      trtime=0.0
      napxto=0
      runtim=''
+if cr
      stxt=''
+ei
+if hdf5
       call INITHDF5()
+ei
+if boinc
      call boinc_init()
!     call boinc_init_graphics()
+ei
+if cr
! Main start for Checkpoint/Restart
      sythckcr=.false.
      numlcr=1
      rerun=.false.
      start=.true.
      restart=.false.
      checkp=.false.
      fort95=.false.
      fort96=.false.
      sixrecs=0
      binrec=0
      bnlrec=0
      bllrec=0
      do i=1,(npart+1)/2
        binrecs(i)=0
      enddo
      crtime3=0.
+if debug
                   !call system('../crmain  >> crlog')
+ei
+if boinc
 611  continue
+ei
      lout=92
!--   Very first get rid of any previous partial output
+if boinc
      call boincrf('fort.92',filename)
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
      rewind lout
      endfile (lout,iostat=ierro)
      close(lout)
+if boinc
      call boincrf('fort.92',filename)
+if fio
      open(lout,file=filename,form='formatted',status='unknown',        &
     &round='nearest')
+ei
+if .not.fio
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(lout,file='fort.92',form='formatted',status='unknown',       &
     &round='nearest')
+ei
+if .not.fio
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
+ei
!--   Now position the checkpoint/restart logfile=93
+if boinc
      call boincrf('fort.93',filename)
+if fio
      open(93,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(93,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
      open(93,file='fort.93',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(93,file='fort.93',form='formatted',status='unknown')
+ei
+ei
  606 read(93,'(a1024)',end=607) arecord
      goto 606
  607 backspace (93,iostat=ierro)
! and if BOINC issue an informatory message
+if boinc
      if (start) then
        write(93,*) 'SIXTRACR starts very first time'
      else
        write(93,*) 'SIXTRACR retry after unzip of Sixin.zip'
      endif
+ei
! Now we see if we have a fort.6 which implies
! that we can perhaps just restart using all exisiting files
! including the last checkpoints
! if not, we just do a start (with an unzip for BOINC)
+if boinc
      call boincrf('fort.6',filename)
+if fio
      open(output_unit,                                                 &
     &file=filename,form='formatted',status='old',err=602,              &
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,                                                 &
     &file=filename,form='formatted',status='old',err=602)
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
+ei
+if .not.boinc
+if fio
      open(output_unit,                                                 &
     &file='fort.6',form='formatted',status='old',err=602,              &
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,                                                 &
     &file='fort.6',form='formatted',status='old',err=602)
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
+ei
      rerun=.true.
      goto 605
+if boinc
  602 continue
! No fort.6 so we do an unzip of Sixin.zip
! BUT ONLY IF WE HAVE NOT DONE IT ALREADY
! and CLOSE 92 and 93
      if (start) then
        start=.false.
        close(92)
        close(93)
! Now, if BOINC, after no fort.6, call UNZIP Sixin.zip
! name hard-wired in our boinc_unzip_.
! Either it is only the fort.* input data or it is a restart.
! Removed temporarily??? because of problems.
! Re-instated and REQUIRED version 4516
        !call boinc_unzip()
        !call system('unzip Sixin.zip')
        
        call boincrf("Sixin.zip",filename)
        ! This function expects a normal, trimmed fortran string; it will do the zero-padding internally.
        call f_read_archive(trim(filename),".")
        go to 611
      endif
+if fio
      open(output_unit,                                                 &
     &file=filename,form='formatted',status='unknown',                  &
     &round='nearest')
+ei
+if .not.fio
      open(output_unit,                                                 &
     &file=filename,form='formatted',status='unknown')
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
+ei
+if .not.boinc
+if fio
 602  open(output_unit,                                                 &
     &file='fort.6',form='formatted',status='new',                      &
     &round='nearest')
+ei
+if .not.fio
 602  open(output_unit,                                                 &
     &file='fort.6',form='formatted',status='new')
+ei
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
+ei
!--   Now check for restart files fort.95/96 and OPEN them
+if boinc
  605 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='old',err=600)
+ei
+if .not.boinc
  605 open(95,file='fort.95',form='unformatted',status='old',err=600)
+ei
      fort95=.true.
      goto 608
+if boinc
  600 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='new')
+ei
+if .not.boinc
  600 open(95,file='fort.95',form='unformatted',status='new')
+ei
+if boinc
  608 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='old',err=601)
+ei
+if .not.boinc
  608 open(96,file='fort.96',form='unformatted',status='old',err=601)
+ei
      fort96=.true.
      goto 609
+if boinc
  601 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='new')
+ei
+if .not.boinc
  601 open(96,file='fort.96',form='unformatted',status='new')
+ei
+if boinc
  609 call boincrf('fort.91',filename)
+if fio
      open(91,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(91,file=filename,form='formatted',status='unknown')
+ei
+ei
+if .not.boinc
+if fio
  609 open(91,file='fort.91',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
  609 open(91,file='fort.91',form='formatted',status='unknown')
+ei
+ei
+ei ! END +if cr -- END of Main start for Checkpoint/Restart

+if .not.cr
      lout=output_unit
+ei
      
+if debug
                   !call system('../crmain  >> crlog')
+ei
!-----------------------------------------------------------------------
+ca open
      write(lout,10010) version,moddate
      tlim=1e7
      call timest(tlim)
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'st of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'nd of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
+if cr
        day=stxt//cdate(5:6)//'rd of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      else
+if cr
        day=stxt//cdate(5:6)//'th of' //cmonth(imonth)                  &
+ei
+if .not.cr
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
+ei
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)// &
     &'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(lout,'(a80)') runtim
+if cr
!     Log start messages
      write(93,*)
      write(93,*) 'SIXTRACR MAINCR ',runtim
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+ei
+if debug
                   !call system('../crmain  >> crlog')
+ei
!     A normal start, time0 is beginning
      pretime=0.0
      trtime=0.0
      posttime=0.0
      tottime=0.0
      time0=0.0
      time1=0.0
      time2=0.0
      time3=0.0
      tlim=1e7
      call timest(tlim)
      call timex(time0)
      do 10 i=1,nblz
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
   10 continue
      do 20 i=1,mmul
        cr(i)=zero
        ci(i)=zero
   20 continue
      do 30 i=1,2
        eps(i)=zero
        epsa(i)=zero
        ekk(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      do 60 i=1,npart
        nnumxv(i)=0
        xv(1,i)=zero
        xv(2,i)=zero
        yv(1,i)=zero
        yv(2,i)=zero
!       P.Garcia Ortega, for the FLUKA Team
!       last modified: 14-08-2014
!       additional variables for aperture check, to keep track of lost
!       particles if they are not killed
        plost(i)=0
+if backtrk
!       A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!       last modified: 12-06-2014
!       additional variables for back-tracking, when computing locations of
!          lost particles
!       inserted in main code by the 'backtrk' compilation flag
        yold(1,i)=zero
        yold(2,i)=zero
+ei
        dam(i)=zero
        ekkv(i)=zero
        sigmv(i)=zero
        dpsv(i)=zero
        dp0v(i)=zero
        ejv(i)=zero
        ejfv(i)=zero
        xlv(i)=zero
        zlv(i)=zero
        rvv(i)=one
+if rvet
        rvet(i)=zero
+ei
        ejf0v(i)=zero
        dpd(i)=zero
        dpsq(i)=zero
        fok(i)=zero
        rho(i)=zero
        fok1(i)=zero
        si(i)=zero
        co(i)=zero
        g(i)=zero
        gl(i)=zero
        sm1(i)=zero
        sm2(i)=zero
        sm3(i)=zero
        sm12(i)=zero
        as3(i)=zero
        as4(i)=zero
        as6(i)=zero
        sm23(i)=zero
        rhoc(i)=zero
        siq(i)=zero
        aek(i)=zero
        afok(i)=zero
        hp(i)=zero
        hm(i)=zero
        hc(i)=zero
        hs(i)=zero
        wf(i)=zero
        wfa(i)=zero
        wfhi(i)=zero
        rhoi(i)=zero
        hi(i)=zero
        fi(i)=zero
        hi1(i)=zero
        xvl(1,i)=zero
        xvl(2,i)=zero
        yvl(1,i)=zero
        yvl(2,i)=zero
        ejvl(i)=zero
        dpsvl(i)=zero
        oidpsv(i)=one
        sigmvl(i)=zero
        iv(i)=0
        aperv(i,1)=zero
        aperv(i,2)=zero
        ixv(i)=0
        clov(1,i)=zero
        clov(2,i)=zero
        clo6v(1,i)=zero
        clo6v(2,i)=zero
        clo6v(3,i)=zero
        clopv(1,i)=zero
        clopv(2,i)=zero
        clop6v(1,i)=zero
        clop6v(2,i)=zero
        clop6v(3,i)=zero
        alf0v(i,1)=zero
        alf0v(i,2)=zero
        bet0v(i,1)=zero
        bet0v(i,2)=zero
        ampv(i)=zero
+if .not.datamods !This code moved to bigmats.allocate_thickarrays
        do i1=1,nblo
          do i2=1,2
            do i3=1,6
              hv(i3,i2,i,i1)=zero
              bl1v(i3,i2,i,i1)=zero
            end do
          end do
        end do
+ei
        do i1=1,6
          do i2=1,6
            tas(i,i1,i2)=zero
          end do
        end do

        qwcs(i,1)=zero
        qwcs(i,2)=zero
        qwcs(i,3)=zero
        di0xs(i)=zero
        di0zs(i)=zero
        dip0xs(i)=zero
        dip0zs(i)=zero
   60 continue
      qwc(3)=zero
      call comnul
      commen=' '
      progrm='SIXTRACK'
      pi=four*atan_mb(one)
      pi2=pi*half
      pisqrt=sqrt(pi)
      rad=pi/c180e0                                                       !hr05

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise fluka module
!     inserted in main code by the 'fluka' compilation flag
      call fluka_mod_init(npart, nele, clight)
+ei

      call daten
+if datamods
      if (ithick.eq.1) call allocate_thickarrays(npart,nele,nblo)
+ei
+if debug
!     call dumpbin('adaten',999,9999)
!     call abend('after  daten                                      ')
+ei
+if debug.and.cr
!     write(93,*) 'ERIC IL= ',il
!     endfile (93,iostat=ierro)
!     backspace (93,iostat=ierro)
+ei
+if cr
      checkp=.true.
+if debug
                   !call system('../crmain  >> crlog')
+ei
      call crcheck
+ei
      if(ithick.eq.1) write(lout,10030)
      if(ithick.eq.0) write(lout,10040)
      if(ibidu.eq.2) then
        write(lout,10025)
        goto 550
      endif

+if .not.fluka
!--SETTING UP THE PLOTTING
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call hlimit(nplo)
        call hplint(kwtype)
        call igmeta(-20,-111)
        cpto='NPTO'
        if(icr.eq.1) cpto='PTO '
        call hplopt(cpto,1)
        call hplopt('DATE',1)
        call hplset('DATE',1.)
        call hplset('CSIZ',.15)
      endif

      !Postprocessing is on, but there are no particles
      if(ipos.eq.1.and.napx.eq.0) then
! and now we open fort.10 unless already opened for
! BOINC AND BNLELENS

+if nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',         &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei ! END +if nagfor

+if .not.nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei ! END +if .not.bnlelens
+ei ! END +if boinc
+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown')
+ei
+ei ! END +if .not.boinc
+ei ! END +if .not.nagfor

+if .not.stf
      do 70 i=1,ndafi !ndafi = number of files to postprocess (set by fort.3)
+if .not.cr
         call postpr(91-i)
+ei
+if cr
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(91-i,nnuml)
+ei
 70      continue
+ei ! END +if .not.stf
+if stf
!--   ndafi normally set in fort.3 to be "number of files to postprocess"
!--   Inside the postpr subroutine ndafi is modified as:
!--   ndafi=itopa(total particles) if once particle per header i.e ntwin=1,
!--   ndafi=itopa/2 if 2 particle per header i.e ntwin=2
      do 70 i=1,(2*ndafi),2
+if .not.cr
         call postpr(i)
+ei
+if cr
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(i,nnuml)
+ei
 70      continue
+ei ! END +if stf

      call sumpos
      goto 520 !Jump to after particle&optics initialization,
               ! and also after tracking.
      endif !if(ipos.eq.1.and.napx.eq.0)
+ei ! END +if .not.fluka

      do i=1,20
        fake(1,i)=zero
        fake(2,i)=zero
      end do

      itra=2
      amp00=amp(1)
      if(napx.ne.1) damp=((amp00-amp0)/real(napx-1,fPrec))/two                 !hr05
      napx=2*napx
      iation=abs(ition)
      ib0=0
      dp00=dp1
      if(napx.le.0.or.imc.le.0) goto 490
      do 260 m=1,mmac
+if debug
!       call warr('mmac and m',0d0,nmac,m,0,0)
!       write(*,*) 'do 260 mmac/m',mmac,m
+ei
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
        if(m.ge.2) then
          call recuin(m*izu0,irecuin)
          call ranecu(zfz,nzfz,mcut)
          rsum=zero

          do i=1,nzfz
            rsum=rsum+zfz(i)
          end do

          rmean=rsum/real(nzfz,fPrec)                                          !hr05
          rsqsum=zero

          do i=1,nzfz
            rsqsum=rsqsum+(zfz(i)-rmean)*(zfz(i)-rmean)
          end do

          rdev=sqrt(rsqsum/real(nzfz,fPrec))                                   !hr05
          write(lout,10320) m*izu0,nzfz,rmean,rdev
          write(lout,10070)
        endif
        if(m.eq.1) call ord

!       A.Mereghetti
!       last modified: 16-12-2016
!       initialise aperture of first and last elements of sequence
!       always in main code
        if (limifound) then
           write(lout,*) ' check that beginning/end of lattice'//       &
     &' structure is assigned aperture markers...'
           call contour_aperture_markers( iu, 1, .false. )
        end if

+if fluka
!       A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!       last modified: 01-12-2016
!       check integrity of coupling markers
!       inserted in main code by the 'fluka' compilation flag
        if (fluka_enable) call check_coupling_integrity
+ei

!       P. G. Ortega, for the FLUKA Team
!       last modified: 01-07-2014
!       dump aperture model
!       always in main code
        if (ldmpaper) then
          call dump_aperture_model
        endif

        call clorb(ded)

+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
        do l=1,2
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        call clorb(zero)
+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
        do l=1,2
          ll=2*l
          di0(l)=(clo0(l)-clo(l))/ded
          dip0(l)=(clop0(l)-clop(l))/ded
        end do

        call corrorb

        if(irmod2.eq.1) call rmod(dp1)
        if(iqmod.ne.0) call qmod0
        if(ichrom.eq.1.or.ichrom.eq.3) call chroma
        if(iskew.ne.0) call decoup
        if(ilin.eq.1.or.ilin.eq.3) then
          call linopt(dp1)
        endif
+if debug
!     call dumpbin('bbb',96,996)
!     call abend('bbb                                               ')
+ei
!--beam-beam element
        nlino=nlin
        nlin=0
        if(nbeam.ge.1) then
          do 135 i=1,nele
            if(kz(i).eq.20) then
              nlin=nlin+1
              if(nlin.gt.nele) call prror(81)
              bezl(nlin)=bez(i)
            endif
  135     continue
        endif
        if(isub.eq.1) call subre(dp1)
        if(ise.eq.1) call search(dp1)
+if debug
!     call dumpbin('asearch',95,995)
!     call abend('asearch                                           ')
+ei

        !! Initialize kicks
        izu=0
        do 150 i=1,iu
+if debug
!       call warr('i/iu',0d0,i,iu,0,0)
!       write(*,*) 'do 150 i/iu',i,iu
+ei
          ix=ic(i)
          if(ix.le.nblo) goto 150
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 150
          if(kzz.eq.15) goto 150
          if(iorg.lt.0) mzu(i)=izu
          izu=mzu(i)+1
          smizf(i)=zfz(izu)*ek(ix)
          smiv(m,i)=sm(ix)+smizf(i) ! Also in initalize_element!
          smi(i)=smiv(m,i)          ! Also in initalize_element!
+if debug
!         call warr('smizf(i)',smizf(i),i,0,0,0)
!         call warr('smiv(m,i)',smiv(m,i),m,i,0,0)
!         call warr('smi(i)',smi(i),i,0,0,0)
+ei
          izu=izu+1
          xsiv(m,i)=xpl(ix)+zfz(izu)*xrms(ix)
          xsi(i)=xsiv(m,i)
          izu=izu+1
          zsiv(m,i)=zpl(ix)+zfz(izu)*zrms(ix)
          zsi(i)=zsiv(m,i)
          if(mout2.eq.1) then
            if(kzz.eq.11) zfz(izu-2)=zero
            if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
            if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
            if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
            write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),           &
     &zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
          endif
         
!-- MULTIPOLE BLOCK
          if(kzz.eq.11) then
             dynk_izuIndex(ix)=izu
+ca multini
          endif
 150   continue
+if debug
!     call dumpbin('ado 150',150,150)
!     call abend('ado 150                                           ')
+ei
        dp1=zero
        if(ichrom.gt.1) then
          itiono=ition
          ition=0
          call chromda
          ition=itiono
          do ncrr=1,iu
            ix=ic(ncrr)
            if(ix.gt.nblo) ix=ix-nblo
            if(ix.eq.is(1).or.iratioe(ix).eq.is(1)) then
              smiv(m,ncrr)=smi(ncrr)
            else if(ix.eq.is(2).or.iratioe(ix).eq.is(2)) then
              smiv(m,ncrr)=smi(ncrr)
            endif
          enddo
        endif
        dp1=dp00
        dp0=dp00
        if(imc.gt.1) then
          ddp1=(two*dp0)/(real(imc,fPrec)-one)                                 !hr05
        endif
        do 250 ib=1,imc
          if(imc.gt.1) then
            dp1=dp0-(real(ib,fPrec)-one)*ddp1                                  !hr05
          endif
          dp10=dp1
!-----------------------------------------------------------------------
          if(idp.ne.1.or.iation.ne.1) iclo6=0
          if (iclo6.eq.1.or.iclo6.eq.2) then
            if(ib.eq.1) then
+ca clor6
+if debug
!     call dumpbin('aclor6',1,1)
!     call abend('after  clor6                                      ')
+ei
            endif
            if(iqmod6.eq.1) then
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif

            do 190 ib1=1,napx
              ib3=ib1+(m+ib-2)*napx
!--beam-beam element
              clo6v(1,ib3)=clo6(1)
              clo6v(2,ib3)=clo6(2)
              clo6v(3,ib3)=clo6(3)
              clop6v(1,ib3)=clop6(1)
              clop6v(2,ib3)=clop6(2)
              clop6v(3,ib3)=clop6(3)
              di0xs(ib3)=di0(1)
              di0zs(ib3)=di0(2)
              dip0xs(ib3)=dip0(1)
              dip0zs(ib3)=dip0(2)
              qwcs(ib3,1)=qwc(1)
              qwcs(ib3,2)=qwc(2)
              qwcs(ib3,3)=qwc(3)

              do i2=1,6
                do j2=1,6
                  tas(ib3,i2,j2)=tasm(i2,j2)
                end do
              end do

  190       continue
          else
            if(idp.eq.1.and.iation.eq.1) then
              ncorruo=ncorru
              ncorru=1
              call clorb(zero)
+if debug
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
+ei
              call betalf(zero,qw)
              call phasad(zero,qwc)
+if debug
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
+ei
!--beam-beam element
              if(nbeam.ge.1) then
              nd=3
              nd2=6
+ca beamcou
              endif
              ncorru=ncorruo
              iqmodc=3
              call mydaini(2,2,6,3,6,1)
+if debug
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
+ei
              do i=1,2
                qwc(i)=real(int(qwc(i)),fPrec)+wxys(i)
              enddo
              if(ilin.ge.2) then
+if debug
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
+ei
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
+if debug
!     call dumpbin('amydaini',999,9999)
!     call abend('after  mydaini                                    ')
+ei
                nlin=nlinoo
              endif
            else
              dps(1)=dp1
              ncorruo=ncorru
              ncorru=1
              call clorb(dp1)
              call betalf(dp1,qw)
              call phasad(dp1,qwc)
+if debug
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
+ei
              dp1=zero
!--beam-beam element
+if debug
!     call dumpbin('bbeam',1,1)
!     call abend('after bbeam                                       ')
!     write(*,*) 'call qmodda at beam-beam'
+ei
              dp1=dps(1)
              ncorru=ncorruo
              if(nvar2.le.5) then
                itiono=ition
                ition=0
              endif
              call qmodda(2,qwc)
+if debug 
!     call dumpbin('aqmodda',3,2)
!     call abend('after  qmodda 3 2                                 ')
+ei
              if(nvar2.le.5) ition=itiono
              if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)

              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                iqmodc=2
                call mydaini(1,2,5,2,5,1)
                ilinc=1
                call mydaini(2,2,5,2,5,1)
                nlin=nlinoo
              endif

              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif

            do 170 i=1,napx
              iar=(m+ib-2)*napx+i
              clo6v(1,iar)=clo(1)
              clop6v(1,iar)=clop(1)
              clo6v(2,iar)=clo(2)
              clop6v(2,iar)=clop(2)
              di0xs(iar)=di0(1)
              di0zs(iar)=di0(2)
              dip0xs(iar)=dip0(1)
              dip0zs(iar)=dip0(2)
              qwcs(iar,1)=qwc(1)
              qwcs(iar,2)=qwc(2)
              qwcs(iar,3)=zero

              do i2=1,4
                do j2=1,4
                  tas(iar,i2,j2)=tasm(i2,j2)
                end do
              end do

  170       continue
          endif
          iar=(m+ib-2)*napx+1

! save tas matrix and closed orbit for later dumping of the beam 
! distribution at the first element (i=-1)
! dumptas(*,*) [mm,mrad,mm,mrad,1] canonical variables
! tas(iar,*,*) [mm,mrad,mm,mrad,1] canonical variables
! clo6v,clop6v [mm,mrad,mm,mrad,1] canonical variables (x' or px?)
! for the initialization of the particles. Only in 5D thick the ta
! matrix is different for each particle.
! -> implement a check for this!
! In 4d,6d thin+thick and 5d thin we have:
!   tas(ia,*,*) = tas(1,*,*) for all particles ia
          if (iar .eq. 1) then
             do i3=1,3
                dumpclo(-1,i3*2-1) = clo6v(i3,1)
                dumpclo(-1,i3*2)   = clop6v(i3,1)
             enddo
             dumptas(-1,:,:) = tas(1,:,:)
!     invert the tas matrix
             call invert_tas(dumptasinv(-1,:,:),dumptas(-1,:,:))
!     dumptas and dumptasinv are now in units [mm,mrad,mm,mrad,1]
          endif
!     tas(iar,*,*) [mm,mrad,mm,mrad,1]
          
! convert to [mm,mrad,mm,mrad,1.e-3] for optics calculation
          tasiar16=tas(iar,1,6)*c1m3
          tasiar26=tas(iar,2,6)*c1m3
          tasiar36=tas(iar,3,6)*c1m3
          tasiar46=tas(iar,4,6)*c1m3
          tasiar56=tas(iar,5,6)*c1m3
          tasiar61=tas(iar,6,1)*c1e3
          tasiar62=tas(iar,6,2)*c1e3
          tasiar63=tas(iar,6,3)*c1e3
          tasiar64=tas(iar,6,4)*c1e3
          tasiar65=tas(iar,6,5)*c1e3
          bet0(1)=tas(iar,1,1)**2+tas(iar,1,2)**2                        !hr05
          bet0x2 =tas(iar,1,3)**2+tas(iar,1,4)**2                        !hr05
          bet0x3 =tas(iar,1,5)**2+tasiar16**2                            !hr05
          gam0x1 =tas(iar,2,1)**2+tas(iar,2,2)**2                        !hr05
          gam0x2 =tas(iar,2,3)**2+tas(iar,2,4)**2                        !hr05
          gam0x3 =tas(iar,2,5)**2+tasiar26**2                            !hr05
      alf0(1)=-one*(tas(iar,1,1)*tas(iar,2,1)+tas(iar,1,2)*tas(iar,2,2)) !hr05
      alf0x2 =-one*(tas(iar,1,3)*tas(iar,2,3)+tas(iar,1,4)*tas(iar,2,4)) !hr05
      alf0x3 =-one*(tas(iar,1,5)*tas(iar,2,5)+tasiar16*tasiar26)         !hr05
          bet0(2)=tas(iar,3,3)**2+tas(iar,3,4)**2                        !hr05
          bet0z2 =tas(iar,3,1)**2+tas(iar,3,2)**2                        !hr05
          bet0z3 =tas(iar,3,5)**2+tasiar36**2                            !hr05
          gam0z1 =tas(iar,4,3)**2+tas(iar,4,4)**2                        !hr05
          gam0z2 =tas(iar,4,1)**2+tas(iar,4,2)**2                        !hr05
          gam0z3 =tas(iar,4,5)**2+tasiar46**2                            !hr05
      alf0(2)=-one*(tas(iar,3,3)*tas(iar,4,3)+tas(iar,3,4)*tas(iar,4,4)) !hr05
      alf0z2 =-one*(tas(iar,3,1)*tas(iar,4,1)+tas(iar,3,2)*tas(iar,4,2)) !hr05
      alf0z3 =-one*(tas(iar,3,5)*tas(iar,4,5)+tasiar36*tasiar46)         !hr05
          bet0s1 =tas(iar,5,5)**2+tasiar56**2                            !hr05
          bet0s2 =tas(iar,5,1)**2+tas(iar,5,2)**2                        !hr05
          bet0s3 =tas(iar,5,3)**2+tas(iar,5,4)**2                        !hr05
          gam0s1 =tasiar65**2+tas(iar,6,6)**2                            !hr05
          gam0s2 =tasiar61**2+tasiar62**2                                !hr05
          gam0s3 =tasiar63**2+tasiar64**2                                !hr05
          alf0s1 =-one*(tas(iar,5,5)*tasiar65+tasiar56*tas(iar,6,6))     !hr05
          alf0s2 =-one*(tas(iar,5,1)*tasiar61+tas(iar,5,2)*tasiar62)     !hr05
          alf0s3 =-one*(tas(iar,5,3)*tasiar63+tas(iar,5,4)*tasiar64)     !hr05
+if debug
!     call dumpbin('abib1',1,1)
!     call abend('after bib1                                        ')
+ei
          do 220 ib1=1,napx
            iar=ib1+(m+ib-2)*napx

            do ib2=1,6
              do ib3=1,6
                tau(ib2,ib3)=tas(iar,ib3,ib2)
              end do
            end do

            if(abs(tau(1,1)).le.pieni.and.abs(tau(2,2)).le.pieni) then
              tau(1,1)=one
              tau(2,2)=one
            endif
            if(abs(tau(3,3)).le.pieni.and.abs(tau(4,4)).le.pieni) then
              tau(3,3)=one
              tau(4,4)=one
            endif
            if(abs(tau(5,5)).le.pieni.and.abs(tau(6,6)).le.pieni) then
              tau(5,5)=one
              tau(6,6)=one
              call dinv(6,tau,6,idummy,nerror)
              its6d=0
              if(ntwin.ne.2) then
                taus=(((((((((((((((((((                                &!hr05
     &abs(tau(5,1))+abs(tau(5,2)))+abs(tau(5,3)))+abs                   &!hr05
     &(tau(5,4)))+abs(tau(5,5)))+abs(tau(5,6)))+abs(tau(6,1)))          &!hr05
     &+abs(tau(6,2)))+abs(tau(6,3)))+abs(tau(6,4)))+abs                 &!hr05
     &(tau(6,5)))+abs(tau(6,6)))+abs(tau(1,5)))+abs(tau(2,5)))          &!hr05
     &+abs(tau(3,5)))+abs(tau(4,5)))+abs(tau(1,6)))+abs                 &!hr05
     &(tau(2,6)))+abs(tau(3,6)))+abs(tau(4,6)))-two                      !hr05
                if(abs(taus).ge.pieni) its6d=1
              endif
              do ib2=1,6
                do ib3=1,6
                  tasau(iar,ib2,ib3)=tau(ib2,ib3)
                end do
              end do
            endif
  220     continue
          if(ierro.ne.0) then
            write(lout,10230) dp1
            goto 520
          endif
          write(lout,10070)
          phag=(phas*c180e0)/pi                                           !hr05
          if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))         &
     &write(lout,10170)                                                 &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
            if(iclo6.eq.0) then
              write(lout,10150) phag,                                   &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10160) phag,                                   &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)            &
     &write(lout,10190) phag,                                           &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
            if(iclo6.eq.0) then
              write(lout,10210)                                         &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10220)                                         &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          write(lout,10080) dp1
          e0f=sqrt(e0**2-pma**2)                                         !hr05
          if(iclo6.eq.0) then
            write(lout,10110) clo(1),clop(1),clo(2),clop(2),idz(1),     &
     &idz(2),                                                           &
     &iver, idfor,iclo6,ition
          else
            write(lout,10120) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),&
     &clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
          endif
          do 240 ib1=1,napx
            !Loop over all particles (not pairs) with the same
            ! ib (momentum variation, 1..imc ) and
            !  m (seed,               1..mmac).
            !It appears that only the odd (1,3,5,..) indices are actually used?
            ib2=ib0+ib1        ! ib0 is fixed to 0 => ib2 equals ib1
            clov(1,ib2)=clo(1)
            clov(2,ib2)=clo(2)
            clopv(1,ib2)=clop(1)
            clopv(2,ib2)=clop(2)
            bet0v(ib2,1)=bet0(1)
            bet0v(ib2,2)=bet0(2)
            alf0v(ib2,1)=alf0(1)
            alf0v(ib2,2)=alf0(2)
            ampv(ib2)=amp(1)-damp*real(ib1-1,fPrec) !hr05
            if (ib1.eq.napx-1 .and. ib1.ne.1) then
               !Make sure that last amplitude EXACTLY corresponds to the end amplitude amp0
               ! This is helpfull when doing DA studies and checking the "overlap"
               ampv(ib2)=amp0
            endif
            dp0v(ib2)=dp10
            dpsv(ib2)=dp10
            oidpsv(ib2)=one/(one+dp1)
            nms(ib2)=m
            if (ithick.eq.1) then
               do 230 i=1,nele
                  ekv(ib2,i)=ek(i)
 230           continue
            endif
  240     continue
          ib0=ib0+napx
  250   continue
  260 continue
+if debug
!     call dumpbin('ado 260',260,260)
!     call abend('ado 260                                           ')
+ei

      napx=(napx*imc)*mmac                                               !hr05

+if fluka

!     A.Mereghetti, P. Garcia Ortega, D.Sinuela Pastor, V. Vlachoudis 
!             for the FLUKA Team
!     last modified: 11-06-2014
!     start connection to FLUKA and initialise max ID
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        fluka_con = fluka_is_running()
        if(fluka_con.eq.-1) then
          write(lout,*) '[Fluka] Error: Fluka is expected to run but it is'
           write(lout,*) '               NOT actually the case'
          write(fluka_log_unit,*) '# Fluka is expected to run but it is'
          write(fluka_log_unit,*) '               NOT actually the case'
          call prror(-1)
        endif
        write(lout,*) '[Fluka] Initializing FlukaIO interface...'
        write(fluka_log_unit,*) '# Initializing FlukaIO interface...'
        fluka_con = fluka_connect()
        if(fluka_con.eq.-1) then
          write(lout,*) '[Fluka] Error connecting to Fluka server'
          write(fluka_log_unit,*) '# Error connecting to Fluka server'
          call prror(-1)
        endif
        write(lout,*) '[Fluka] Successfully connected to Fluka server'
        write(fluka_log_unit,*) '# Successfully connected to Fluka server'
        fluka_connected = .true.
      endif

+ei

+if cr
      write(93,*) 'MAINCR setting napxo=',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+ei
      napxo=napx
      if(ibidu.eq.1) then
+ca dump1 !write(32)
+ca dump3 !list of variables
      endif
  550 continue
      
      
      if (idp.eq.0.or.ition.eq.0) then
         !4D tracking
         if (iclo6 .ne. 0) then
            write(lout,*) "ERROR: Doing 4D tracking but iclo6=",iclo6
            write(lout,*) "Expected iclo6.eq.0. for 4D tracking."
            call prror(-1)
         endif
      else
         !6D tracking
         if (iclo6 .eq. 0) then
            write(lout,*) "ERROR: Doing 6D tracking but iclo6=",iclo6
            write(lout,*) "Expected iclo6.ne.0. for 6D tracking."
            call prror(-1)
         endif
      endif
      
      
!!!   GENERATE THE INITIAL DISTRIBUTION
      if(ibidu.eq.2) then
+ca dump2 !read(32)
+ca dump3 !list of variables
        damp=((amp(1)-amp0)/real(napx/2-1,fPrec))/two                          !hr05
      endif

      do i=1,npart
        pstop(i)=.false.
        nnumxv(i)=numl
        numxv(i)=numl
      end do

      rat0=rat


!----- Initial distribution creation

!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     acquisition of initial distribution moved out of loop
!     always in main code

      if ( idfor.eq.3 ) then
!       A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!       last modified: 17-07-2013
!       initialize particle distribution, read from file
!       always in main code

        if(.not. dist_enable) then
          write(lout,*) 'idfor set to 3 but DIST block not present'
          call prror(-1)
        endif

        e0f=sqrt(e0**2-pma**2)

        call dist_readdis( napx, npart, e0, e0f, clight, xv(1,:), xv(2,:), yv(1,:), yv(2,:), sigmv(:), ejfv(:) )

!       finalise beam distribution creation
        do j=1, napx
!         values related to losses
          nlostp(j) = j
          pstop (j) = .false.

!         values related to momentum
          ejv   (j) = sqrt(ejfv(j)**2+pma**2)
          dpsv  (j) = (ejfv(j)-e0f)/e0f
          oidpsv(j) = one/(one+dpsv(j))

!         check existence of on-momentum particles in the distribution
          if ( abs(dpsv(j)).lt.c1m15 .or.  abs( (ejv(j)-e0)/e0 ) .lt.c1m15 ) then

!           warning with old infos:
            write(lout,*)''
            write(lout,'(5X,A22)') 'on-momentum particle!!'
            write(lout,'(5X,10X,4(1X,A25))') "momentum [MeV/c]","total energy [MeV]","Dp/p","1/(1+Dp/p)"
            write(lout,'(5X,"ORIGINAL: ",4(1X,1PE25.18))') ejfv(j), ejv(j), dpsv(j), oidpsv(j)

            ejfv(j)   = e0f
            ejv(j)    = e0
            dpsv(j)   = zero
            oidpsv(j) = one

!           warning with new infos:
            write(lout,'(5X,"CORRECTED:",4(1X,1PE25.18))') ejfv(j), ejv(j), dpsv(j), oidpsv(j)
            write(lout,*)''
          endif
        end do

!       A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!       last modified: 07-02-2014
!       in principle there is no need to fill in the unused places:
!       - nlostp(j) = j        with j=1,npart    filled in trauthin/trauthck
!       - pstop (j) = .false.  with j=1,npart    filled in maincr
!       - ejv   (j) = zero     with j=1,npart    filled in maincr
!       - dpsv  (j) = zero     with j=1,npart    filled in maincr
!       - oidpsv(j) = one      with j=1,npart    filled in maincr
!       nevertheless, let's do it, to be fully sure:
        do j=napx+1,npart
!         values related to losses
          nlostp(j) = j
          pstop (j) = .true.
!         values related to momentum
          ejv   (j) = zero
          dpsv  (j) = zero
          oidpsv(j) = one
        enddo

!       add closed orbit
        if(iclo6.eq.2) then
          do j=1, napx
            xv(1,j)=xv(1,j)+clo6v(1,j)
            yv(1,j)=yv(1,j)+clop6v(1,j)
            xv(2,j)=xv(2,j)+clo6v(2,j)
            yv(2,j)=yv(2,j)+clop6v(2,j)
            sigmv(j)=sigmv(j)+clo6v(3,j)
            dpsv(j)=dpsv(j)+clop6v(3,j)
            oidpsv(j)=one/(one+dpsv(j))
          end do
        end if

!       echo
        if ( dist_echo ) then
           open(unit=dist_echo_unit)
           rewind(dist_echo_unit)
           write(dist_echo_unit,'(" # ",A40,1PE25.18)') " # total energy of synch part [MeV]: ", e0
           write(dist_echo_unit,'(" # ",A40,1PE25.18)') " # momentum of synch part [MeV/c]: ", e0f
           write(dist_echo_unit,*) '#'
           write(dist_echo_unit,*) '# for every particle (j)'
           write(dist_echo_unit,*) '# xv(1), yv(1), xv(2), yv(2), sigmv, ejfv'
           do j = 1, napx
             write(dist_echo_unit,'(6(1X,1PE25.18))') xv(1, j), yv(1, j), xv(2,j), yv(2,j), sigmv(j), ejfv(j)
           end do
           close(dist_echo_unit)
        endif

      endif

      do 340 ia=1,napx,2
        if(idfor.ne.2) then
!---------------------------------------  SUBROUTINE 'ANFB' IN-LINE
          write(lout,10050)
          tasia56=tas(ia,5,6)*c1m3
          bet0x2=tas(ia,1,3)**2+tas(ia,1,4)**2                           !hr05
          bet0z2=tas(ia,3,1)**2+tas(ia,3,2)**2                           !hr05
          bet0s1=tas(ia,5,5)**2+tasia56**2                               !hr05
          dsign=one
          rat=rat0
          if(tas(ia,3,3).lt.(-one*pieni)) rat=-one*rat                   !hr05
          if(rat.lt.(-one*pieni)) dsign=-one*one                         !hr05
          x11=ampv(ia)/(sqrt(bet0v(ia,1))+sqrt(abs(rat)*bet0x2))
          x13=(x11*dsign)*sqrt(abs(rat))                                 !hr05
          amp(2)=(dsign*real(1-iver,fPrec))*                            &
     &(abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt(bet0v(ia,2)))                 !hr05
          x1(5)=zero
          x1(6)=dpsv(ia)*sqrt(bet0s1)
          chi=chi0*rad
          dchi=chid*rad
          do 320 i2=1,2
            i3=ia+i2-1
            sic=sin_mb(chi)
            coc=cos_mb(chi)
            x1(1)=x11*coc
            x1(2)=x11*sic
            x1(3)=x13*coc
            x1(4)=x13*sic
            do 300 ii=1,6
              x2(ii)=zero
              do 290 jj=1,6
                x2(ii)=x2(ii)+tas(ia,ii,jj)*x1(jj)
  290         continue
  300       continue
            if(iclo6.eq.1.or.iclo6.eq.2) then
              x2(2)=x2(2)/((one+x2(6))+clop6v(3,ia))                     !hr05
              x2(4)=x2(4)/((one+x2(6))+clop6v(3,ia))                     !hr05
            endif
            if(abs(bet0s1).le.pieni) x2(6)=dpsv(ia)
            if(iver.eq.1) then
              x2(3)=zero
              x2(4)=zero
            endif
            do 310 l=1,2
              ll=(l-1)*2
              xv(l,i3)=x2(1+ll)+exz(i2,1+ll)
              yv(l,i3)=x2(2+ll)+exz(i2,2+ll)
  310       continue
            sigmv(i3)=x2(5)+exz(i2,5)
            dpsv(i3)=x2(6)
            dpsic=dpsv(i3)+clop6v(3,ia)
            if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
              xv(1,i3)=xv(1,i3)+di0xs(ia)*dpsic
              xv(2,i3)=xv(2,i3)+di0zs(ia)*dpsic
              yv(1,i3)=yv(1,i3)+dip0xs(ia)*dpsic
              yv(2,i3)=yv(2,i3)+dip0zs(ia)*dpsic
            endif
            chi=chi+dchi
  320     continue
          write(lout,10260) ia,nms(ia)*izu0,dpsv(ia)
          write(lout,10060) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),        &
     &sigmv(ia),                                                        &
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1)
!---------------------------------------  END OF 'ANFB'
          if(iclo6.eq.2) then
            xv(1,ia)=xv(1,ia)+clo6v(1,ia)
            yv(1,ia)=yv(1,ia)+clop6v(1,ia)
            xv(2,ia)=xv(2,ia)+clo6v(2,ia)
            yv(2,ia)=yv(2,ia)+clop6v(2,ia)
            sigmv(ia)=sigmv(ia)+clo6v(3,ia)
            dpsv(ia)=dpsv(ia)+clop6v(3,ia)
            xv(1,ia+1)=xv(1,ia+1)+clo6v(1,ia)
            yv(1,ia+1)=yv(1,ia+1)+clop6v(1,ia)
            xv(2,ia+1)=xv(2,ia+1)+clo6v(2,ia)
            yv(2,ia+1)=yv(2,ia+1)+clop6v(2,ia)
            sigmv(ia+1)=sigmv(ia+1)+clo6v(3,ia)
            dpsv(ia+1)=dpsv(ia+1)+clop6v(3,ia)
            oidpsv(ia)=one/(one+dpsv(ia))
            oidpsv(ia+1)=one/(one+dpsv(ia+1))
          endif
          if(iclo6.ne.2) then
            xv(1,ia)=xv(1,ia)+(clov(1,ia)*real(idz(1),fPrec))*          &
     &real(1-idfor,fPrec)    !hr05
            yv(1,ia)=yv(1,ia)+(clopv(1,ia)*real(idz(1),fPrec))*         &
     &real(1-idfor,fPrec)   !hr05
            xv(2,ia)=xv(2,ia)+(clov(2,ia)*real(idz(2),fPrec))*          &
     &real(1-idfor,fPrec)    !hr05
            yv(2,ia)=yv(2,ia)+(clopv(2,ia)*real(idz(2),fPrec))*         &
     &real(1-idfor,fPrec)   !hr05
            xv(1,ia+1)=xv(1,ia+1)+(clov(1,ia)*real(idz(1),fPrec))*      &
     &real(1-idfor,fPrec)  !hr05
            yv(1,ia+1)=yv(1,ia+1)+(clopv(1,ia)*real(idz(1),fPrec))*     &
     &real(1-idfor,fPrec) !hr05
            xv(2,ia+1)=xv(2,ia+1)+(clov(2,ia)*real(idz(2),fPrec))*      &
     &real(1-idfor,fPrec)  !hr05
            yv(2,ia+1)=yv(2,ia+1)+(clopv(2,ia)*real(idz(2),fPrec))*     &
     &real(1-idfor,fPrec) !hr05
          endif
          ejfv(ia)=e0f*(one+dpsv(ia))
          ejfv(ia+1)=e0f*(one+dpsv(ia+1))
          ejv(ia)=sqrt(ejfv(ia)**2+pma**2)                               !hr05
          ejv(ia+1)=sqrt(ejfv(ia+1)**2+pma**2)                           !hr05
          epsa(1)=(ampv(ia)**2/bet0v(ia,1))                              !hr05
          epsa(2)=(amp(2)**2/bet0v(ia,2))                                !hr05
          write(lout,10020) ampv(ia),amp(2),epsa
        else
+if .not.crlibm
          read(13,*,iostat=ierro) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),  &
     &sigmv(ia),dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv            &
     &(2,ia+1), sigmv(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
+ei
+if crlibm
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(1,ia)]"
             call prror(-1)
          endif
          xv(1,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(1,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(1,ia)]"
             call prror(-1)
          endif
          yv(1,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(1,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(2,ia)]"
             call prror(-1)
          endif
          xv(2,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(2,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(2,ia)]"
             call prror(-1)
          endif
          yv(2,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(2,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ sigmv(ia)]"
             call prror(-1)
          endif
          sigmv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV sigmv(ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ dpsv(ia)]"
             call prror(-1)
          endif
          dpsv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV dpsv(ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(1,ia+1)]"
             call prror(-1)
          endif
          xv(1,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(1,ia+1)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(1,ia+1)]"
             call prror(-1)
          endif
          yv(1,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(1,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(2,ia+1)]"
             call prror(-1)
          endif
          xv(2,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(2,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(2,ia+1)]"
             call prror(-1)
          endif
          yv(2,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(2,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [READ sigmv(ia+1)]"
             call prror(-1)
          endif
          sigmv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [CONV sigmv(ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [READ dpsv(ia+1)]"
             call prror(-1)
          endif
          dpsv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [CONV dpsv(ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ e0]"
             call prror(-1)
          endif
          e0 = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV e0]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ ejv(ia)]"
             call prror(-1)
          endif
          ejv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV ejv(ia)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ ejv(ia+1)]"
             call prror(-1)
          endif
          ejv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV ejv(ia+1)]"
             call prror(-1)
          endif

+ei
          if(ierro.ne.0) call prror(56)
          e0f=sqrt(e0**2-pma**2)                                         !hr05
          ejfv(ia)=sqrt(ejv(ia)**2-pma**2)                               !hr05
          ejfv(ia+1)=sqrt(ejv(ia+1)**2-pma**2)                           !hr05
          oidpsv(ia)=one/(one+dpsv(ia))
          oidpsv(ia+1)=one/(one+dpsv(ia+1))
        endif
        write(lout,10090) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),&
     &dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1), sigmv       &
     &(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
        idam=3
        icode=0
        if(abs(xv(1,ia)).le.pieni.and.abs(yv(1,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+1
        endif
        if(abs(xv(2,ia)).le.pieni.and.abs(yv(2,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+2
        endif
        if(idp.eq.0.or.abs(ition).eq.0) then
          idam=idam-1
        else
          icode=icode+4
        endif
        if(idam.le.0) idam=1
        if(icode.le.0) icode=1
        ia2=(ia+1)/2
        if(ntwin.ne.2) then
          if(mod(ia+1,2).eq.0) then
            xau(1,1)= xv(1,ia)
            xau(1,2)= yv(1,ia)
            xau(1,3)= xv(2,ia)
            xau(1,4)= yv(2,ia)
            xau(1,5)=sigmv(ia)
            xau(1,6)= dpsv(ia)
            xau(2,1)= xv(1,ia+1)
            xau(2,2)= yv(1,ia+1)
            xau(2,3)= xv(2,ia+1)
            xau(2,4)= yv(2,ia+1)
            xau(2,5)=sigmv(ia+1)
            xau(2,6)= dpsv(ia+1)
            cloau(1)= clo6v(1,ia)
            cloau(2)=clop6v(1,ia)
            cloau(3)= clo6v(2,ia)
            cloau(4)=clop6v(2,ia)
            cloau(5)= clo6v(3,ia)
            cloau(6)=clop6v(3,ia)
            di0au(1)= di0xs(ia)
            di0au(2)=dip0xs(ia)
            di0au(3)= di0zs(ia)
            di0au(4)=dip0zs(ia)

            do ib2=1,6
              do ib3=1,6
                tau(ib2,ib3)=tasau(ia,ib2,ib3)
              end do
            end do

            call distance(xau,cloau,di0au,tau,dam1)
            dam(ia)=dam1
            dam(ia+1)=dam1
          endif !endif(mod(ia+1,2).eq.0)

+if bnlelens
          if (lhc.eq.9) then
            write(lout,*)                                               &
     & 'SKIPPING Binary File Initialisation for BNLELENS'
            go to 340
          endif
+ei !END +if bnlelens

!     Write header of track output file(s) used by postprocessing
!     for case ntwin.ne.2
+if cr
          if (.not.restart) then
+ei
+if .not.stf
            call writebin_header(ia,ia,91-ia2,ierro,                    &
     &        cdate,ctime,progrm)
+if cr
            flush(91-ia2)
            binrecs(ia2)=1
          endif
+ei
+ei ! END +if .not.stf
+if stf
            call writebin_header(ia,ia,90,ierro,                        &
     &        cdate,ctime,progrm)
+if cr
            flush(90)
            binrecs(ia2)=1
          endif
+ei
+ei ! END +if stf
        else !ELSE for "if(ntwin.ne.2)"
+if bnlelens
          if (lhc.eq.9) then
            write(lout,*)                                               &
     & 'SKIPPING Binary File Initialisation for BNLELENS'
            go to 340
          endif
+ei !END +if bnlelens

!     Write header of track output file(s) used by postprocessing
!     for case ntwin.eq.2

+if cr
          if (.not.restart) then
+ei
+if .not.stf
            call writebin_header(ia,ia+1,91-ia2,ierro,                  &
     &        cdate,ctime,progrm)
+if cr
            flush(91-ia2)
            binrecs(ia2)=1
          endif
+ei
+ei ! END +if .not.stf
+if stf
            call writebin_header(ia,ia+1,90,ierro,                      &
     &        cdate,ctime,progrm)
+if cr
            flush(90)
            binrecs(ia2)=1
          endif
+ei
+ei ! END +if stf
        endif !ENDIF (ntwin.ne.2)
        if(ierro.ne.0) then
          write(lout,*)
          write(lout,*) '*** ERROR ***,PROBLEMS WRITING TO FILE # : ',91&
     &-ia2
          write(lout,*) 'ERROR CODE : ',ierro
          write(lout,*)
          goto 520
        endif
  340 continue
+if cr
      if (lhc.ne.9) binrec=1    ! binrec:
                                ! The maximum number of reccords writen for all tracking data files
                                ! Thus crbinrecs(:) .le. binrec
+ei
      if(e0.gt.pieni) then
        do j=1,napx
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        end do
      else
        call prror(79)
      endif

      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)

!!! Really only neccessary for thick 4d tracking !!!
!!! In FLUKA version, this is moved to new subroutine "blocksv" (in a new deck)
+if .not.fluka
!-------------------------------------  START OF 'BLOCK'
      if (ithick.eq.1) then

      do 440 k=1,mblo
        jm=mel(k)
        ikk=mtyp(k,1)

        do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(mkk,lkk,ia,1)=al(mkk,lkk,ia,ikk)
            if(mkk.eq.5.or.mkk.eq.6) then
              hv(mkk,lkk,ia,1)=hv(mkk,lkk,ia,1)/dpoff
              end if
            end do
          end do
        end do

        if(jm.eq.1) goto 410
        do 400 j=2,jm
          ikk=mtyp(k,j)
          do 390 lkk=1,2
            do 380 ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(1,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(2,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(3,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(4,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(5,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(2,lkk,ia,ikk))+al(5,lkk,ia,ikk)/dpoff               !hr05
              hv(6,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(4,lkk,ia,ikk))+al(6,lkk,ia,ikk)/dpoff               !hr05
  380       continue
  390     continue
  400   continue

  410   do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              bl1v(mkk,lkk,ia,k)=hv(mkk,lkk,ia,jm)
            end do
          end do
        end do

  440 continue

      end if
!---------------------------------------END OF 'BLOCK'
+ei

+if fluka
  if(ithick.eq.1) then
!------ Compute matrices for linear tracking
    call envarsv(dpsv,oidpsv,rvv,ekv)
    if(idp.eq.0 .or. ition.eq.0) then
! ------- Only in case of thck4d
      call blocksv
    end if
  end if
+ei

+if fluka
!     P.Garcia Ortega, A.Mereghetti and V.Vlachoudis, for the FLUKA Team
!     last modified: 26-08-2014
!     send napx to fluka
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        write(lout,*) '[Fluka] Sending napx: ', napx
        write(fluka_log_unit,*) '# Sending napx: ', napx
        fluka_con = fluka_init_max_uid( napx )

        if (fluka_con .lt. 0) then
           write(lout,*) '[Fluka] Error: failed to send napx to fluka ',&
     &  napx
           write(fluka_log_unit, *) '# failed to send napx to fluka ',  &
     &  napx
           call prror(-1)
        end if

        write(lout,*) '[Fluka] Sending napx successful;'
        write(fluka_log_unit,*) '# Sending napx successful;'
        flush(lout)
        flush(fluka_log_unit)
      endif

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 18-01-2016
!     initialise energy/momentum/rest mass of reference particle in mod_fluka
!         and synch magnetic rigidity with Fluka (for the time being, consider
!         only protons);
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        write(lout,*) '[Fluka] Updating ref particle'
        write(fluka_log_unit,*) '# Updating ref particle'
        flush(lout)
        flush(fluka_log_unit)

        fluka_con = fluka_set_synch_part( e0, e0f, pma, 1 )

        if (fluka_con .lt. 0) then
          write(lout, *) '[Fluka] Error: failed to update ref particle'
          write(fluka_log_unit, *) '# failed to update ref particle'
          call prror(-1)
        end if

        write(lout,*) '[Fluka] Updating ref successful;'
        write(fluka_log_unit,*) '# Updating ref particle successful;'
        flush(lout)
        flush(fluka_log_unit)
      endif

+ei

!     A.Mereghetti, P. G. Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 01-07-2014
!     call routine for calculating dcum, necessary for the online
!        aperture check and in case of dumping particle population
!        or statistics or beam matrix
!     always in main code
      call cadcum
      if(idp.ne.0.and.ition.ne.0) then !6D tracking
         if ( abs( dcum(iu+1) - tlen ) .gt. eps_dcum ) then
            write(lout,'(1x,a)')                                        &
     &           "WARNING: Problem with SYNC block detected"
            write(lout,'(1x,a,f17.10)')                                 &
     &           "TLEN in sync block =",tlen
            write(lout,'(1x,a,f17.10)')                                 &
     &           "Length from DCUM   =",dcum(iu+1)
            write(lout,'(1x,a,f17.10)')                                 &
     &           "Difference         =",dcum(iu+1)-tlen
            write(lout,'(1x,a,e27.16,a)')                               &
     &           "Relative error     =",                                &
     &           2 * (dcum(iu+1)-tlen) / (dcum(iu+1)+tlen), " [m]"
            write(lout,'(1x,a,f17.10,a)')                               &
     &           "Tolerance eps_dcum =", eps_dcum, " [m]"
            write(lout,'(1x,a)')                                        &
     &           "Please fix the TLEN parameter in your SYNC block"
            write(lout,'(1x,a)')                                        &
     &           "so that it matches the "//                            &
     &           " calculated machine length from DCUM."
            write(lout,'(1x,a)')                                        &
     &           "If incorrect, the RF frequency"//                     &
     &           " may be (slightly) wrong."

            !It's a warning not an error, and the consequences seem relatively small.
            !Ideally, tlen should be calculated automatically based on the sequence.
            !call prror(-1)
         endif
      endif

!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     K. Sjobak, for BE/ABP-HSS
!     M. Fitterer, for FNAL
!     last modified: 21/02-2016
!     open units for dumping particle population or statistics
!     always in main code

      ! Initialize DUMP
      call dump_initialize

      ! ! ! Initialize SCATTER ! ! !
      if (scatter_active) then
         call scatter_initialize
      endif


!                                !
!     ****** TRACKING ******     !
!                                !
      write(lout,10200)
+if debug
!     call dumpbin('btrack',1,1)
!     call abend('btrack                                            ')
+ei
+if debug
                   !call system('../crmain  >> crlog')
+ei
      time1=0.
      call timex(time1)
! time1 is now pre-processing CPU
! note that this will be reset evry restart as we redo pre-processing
      pretime=time1-time0
!---------------------------------------  LOOP OVER TURNS TO BE TRACKED
      if(ithick.eq.0) call trauthin(nthinerr)
      if(ithick.eq.1) call trauthck(nthinerr)
+if debug
!     call dumpbin('atrack',1,1)
!     call abend('atrack                                            ')
+ei
      time2=0.
      call timex(time2)
! trtime is now the tracking time, BUT we must add other time for C/R
      trtime=time2-time1
+if cr
! because now crpoint will write tracking time
! using time3 as a temp
! and crcheck/crstart will reset crtime3
      trtime=trtime+crtime3
+ei
      if(nthinerr.eq.3000) goto 520
      if(nthinerr.eq.3001) goto 460
!---------------------------------------  END OF LOOP OVER TURNS
  460 continue
+if .not.fluka
      napxto=0
+ei
! and set numx=nnuml (for writebin) NOT for LOST particles
! because all lost set nnuml=numl
      numx=nnuml
      id=0

+if .not.fluka
+if cr
      if (.not.restart) then  
! If restart is true , we haven't done any tracking
! and must be running from very last checkpoint
        write(93,*) 'Very last call to WRITEBIN?'
        write(93,*) 'numlmax,nnuml,numl',numlmax,nnuml,numl
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        if (nnuml.eq.numl) then
! We REALLY have finished (or all particles lost)
! When all lost, nthinerr=3001, we set nnuml=numl
! and make sure we do the last WRITEBIN
          write(93,*) 'Very last call to WRITEBIN'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          call writebin(nthinerr)
          if(nthinerr.eq.3000) goto 520
        else
! I assume we are stopping because we have done nnuml turns
! which should be numlmax and do a writebin only if time
          write(93,*) 'Very last call to WRITEBIN?'
          write(93,*) 'numlmax,nnuml,nwri',numlmax,nnuml,nwri
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          if(mod(nnuml,nwri).eq.0) then
            write(93,*) 'Very last call to WRITEBIN'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call writebin(nthinerr)
            if(nthinerr.eq.3000) goto 520
          endif
        endif
! and do the very last checkpoint
        call callcrp()
      endif
+ei
+if .not.cr
      call writebin(nthinerr)
      if(nthinerr.eq.3000) goto 520
+ei
! If CR we have to worry about turns printed in fort.6
! If lost should be OK, otherwise we need to use nnuml instead
! of the numl in numxv/nnumxv???? Eric.
! where we reset [n]numxv to nnuml UNLESS particle lost
! Now we shall try using that fix at start of tracking
      do 470 ia=1,napxo,2
        ie=ia+1
        ia2=(ie)/2
        napxto=(napxto+numxv(ia))+numxv(ie)                              !hr05
        if(pstop(ia).and.pstop(ie)) then
!-- BOTH PARTICLES LOST
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),         &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),         &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(lout,10280)                                             &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejvl(ia),ejvl(ie)
          if(ierro.ne.0) write(lout,*)                                  &
     &'Warning from maincr: fort.12 has ',                              &
     &'corrupted output probably due to lost particle: ',ia,            &
     &' or: ',ie
        endif
        if(.not.pstop(ia).and.pstop(ie)) then
!-- SECOND PARTICLE LOST
          id=id+1
          write(lout,10240) ia,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),         &
     &abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          write(lout,10280)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),     &
     &e0,ejv(id),ejvl(ie)
          if(ierro.ne.0)                                                &
     &         write(lout,*) 'Warning from maincr: fort.12 has ',       &
     &         'corrupted output probably due to lost particle: ',ie
        endif
        if(pstop(ia).and..not.pstop(ie)) then
!-- FIRST PARTICLE LOST
          id=id+1
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),         &
     &abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(lout,10240) ie,nms(ia)*izu0,dp0v(ia),numxv(ie)
          write(lout,10280)                                             &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          write(12,10280,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
          if(ierro.ne.0)                                                &
     &         write(lout,*) 'Warning from maincr: fort.12 has ',       &
     &         'corrupted output probably due to lost particle: ',ia
        endif
        if(.not.pstop(ia).and..not.pstop(ie)) then
!-- BOTH PARTICLES STABLE
          id=id+1
          ig=id+1
          write(lout,10270) ia,ie,nms(ia)*izu0,dp0v(ia),numxv(ia)
          write(lout,10280)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          write(12,10280,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),           &
     &e0,ejv(id),ejv(ig)
          if(ierro.ne.0)                                                &
     &         write(lout,*) 'Warning from maincr: fort.12 has ',       &
     &         'corrupted output although particles stable'
          id=ig
        endif
  470 continue
+ei
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     print stable particles only
!     inserted in main code by the 'fluka' compilation flag
      write(lout,*)
      write(lout,10340)
      if ( napxo .gt. 0 ) then
        write(lout,*)
        write(lout,10350) napxo
        write(lout,*)
        write(lout,10360) 'ID', 'GEN', 'WEIGHT', 'X [m]', 'XP []',      &
     &    'Y [m]', 'YP[]', 'PC [GeV]', 'DE [eV]', 'DT [s]'
        write(lout,*)
        do ia=1,napxo
         if(.not.pstop(ia)) then
          write(lout,10370)                                             &
     &fluka_uid(ia), fluka_gen(ia), fluka_weight(ia),                   &
     &xv(1,ia)*c1m3, yv(1,ia)*c1m3, xv(2,ia)*c1m3, yv(2,ia)*c1m3,       &
     &ejfv(ia)*c1m3,(ejv(ia)-e0)*c1e6,-c1m3*(sigmv(ia)/clight)*(e0/e0f)
         end if
        end do
      end if
+ei

! POSTPROCESSING (POSTPR)

+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) go to 520
!GRDRHIC
!GRD-042008
+ei
! and we need to open fort.10 unless already opened
! for BOINC AND BNLELENS
+if nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',          &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',         &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei

+if .not.nagfor
+if boinc
+if .not.bnlelens
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',          &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown')
+ei
+ei
+ei

+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',         &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown')
+ei
+ei
+ei

+if .not.fluka
+if .not.stf
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
          do 480 ia=1,napxo,2
            ia2=(ia+1)/2
            iposc=iposc+1
+if .not.cr
            call postpr(91-ia2) !Postprocess file "fort.(91-ia2)"
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia2,nnuml)
+ei
  480     continue
          if(iposc.ge.1) call sumpos
        endif !END if(ipos.eq.1)
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,ndafi2
            if(ia.gt.ndafi) goto 510
+if .not.cr
            call postpr(91-ia)
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia,nnuml)
+ei
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
+ei !END +if .not.stf
+if stf
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
           do 480 ia=1,napxo,2
              iposc=iposc+1
+if .not.cr
              call postpr(ia) !Postprocess particle ia (and ia+1 if ntwin=2)
+ei
+if cr
              write(93,*) 'Calling POSTPR nnuml=',nnuml
              endfile (93,iostat=ierro)
              backspace (93,iostat=ierro)
              call postpr(ia,nnuml)
+ei
  480      continue
          if(iposc.ge.1) call sumpos
        endif
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,(2*ndafi2),2
            if(ia.gt.ndafi) goto 510
+if .not.cr
            call postpr(ia)
+ei
+if cr
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(ia,nnuml)
+ei
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
+ei !END +if stf

 520  continue !Finished postprocessing (POST in fort.3)
      
!     start fma
      if(fma_flag) then
        write(lout,*)'Calling FMA_POSTPR'
        call fma_postpr
      endif
!--HPLOTTING END
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call igmeta(999,0)
        call hplend
      endif
+ei !END +if .not.fluka

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 28-05-2014
!     collect a couple of goto statements, sending code flow
!       to different plotting points, which are not actually
!       inserted
!     inserted in main code by the 'fluka' compilation flag
 490  continue
 520  continue
+ca flukaclose
+ei
      time3=0.
      call timex(time3)
! Note that crpoint no longer destroys time2
      posttime=time3-time2
+if debug
      write(lout,*) 'BUG:',time3,time2,pretime,trtime,posttime
+if cr
      write(93,*)   'BUG:',time3,time2,pretime,trtime,posttime
+ei
+ei
! and now get grand total including post-processing
      tottime=(pretime+trtime)+posttime
      write(lout,10290) pretime
+if cr
! and TRY a FIX for napxto
!     if (nnuml.ne.numl) then
!       napxto=0
!       write(lout,*) 'numl=',numl,' nnuml=',nnuml
! We may have stopped because of numlmax
!       do ia=1,napxo
!         if (numxv(ia).eq.numl) then
! assumed stable
!     write(lout,*) 'ia=',ia,nnuml
!           napxto=napxto+nnuml
!         else
! assumed lost
!     write(lout,*) 'ia=',ia,' numxv=',numxv
!           napxto=napxto+numxv(ia)
!         endif
!       enddo 
!     endif
+ei
      write(lout,10300) napxto,trtime
      write(lout,10310) tottime
+if debug
!     call wda('THE END',0d0,9,9,9,9)
!     call dumpum('THE END',999,9999)
!     call dumpbin('THE END',999,9999)
!     call dumpzfz('THE END',9,9)
+ei
      call closeUnits

      if (zipf_numfiles.gt.0) then
         call zipf_dozip
      endif

!     We're done in maincr, no error :)
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,      &
     &' RANDOM SEED ',i8,/ t10,' MOMENTUM DEVIATION ',g12.5,            &
     &' LOST IN REVOLUTION ',i8,/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,   &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/)
+if .not.tilt
+if cr
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
+ei
+if .not.cr
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
+ei
+ei
+if tilt
+if cr
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
+ei
+if .not.cr
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
+ei
+ei
10020 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y = ',f15.3, '  PI*MRAD*MM')
10025 format(/t10,'Run started from binary dump file # 32')
10030 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10040 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10050 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
10060 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10070 format(/131('-'))
10080 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t8,                &
     &'========================================')
10090 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10110 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10120 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10150 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10))
10160 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10170 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/)
10180 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10190 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/)
10200 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10210 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10))
10220 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10230 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,                &
     &'RELATIVE MOMENTUM DEVIATION')
10240 format(1x/5x,'PARTICLE ',i7,' STABLE - RANDOM SEED ', i8,         &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
!10250 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
!     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10260 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5/)
10270 format(1x/5x,'PARTICLE ',i7,' AND ',i7,' STABLE - RANDOM SEED ',  &
     &i8,' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10280 format(10x,f47.33)
10290 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10300 format(/10x,'For ',i12,' Turn(s)',g12.3,' second(s) of ',         &
     &'Computing Time was needed'//131('-'))
10310 format(//10x,'Total Time used: ',g12.3,' second(s)'//131('-'))
10320 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
10330 format(/10x,'ERROR IN OPENING FILES')
10340 format(131('-'))
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     print stable particles only (format directives)
!     inserted in main code by the 'fluka' compilation flag
10350 format(4X,I8,1X,'SURVIVING PARTICLES:')
10360 format(2(1X,A8),8(1X,A16))
10370 format(2(1X,I8),8(1X,1PE16.9))
10380 format(10x,f47.33)
+ei
      end program maincr

+dk tra_thin
!!--------------------------------------------------------------------------
!!  TRACK THIN LENS PART
!!  F. SCHMIDT
!!  CHANGES FOR COLLIMATION MADE BY G. ROBERT-DEMOLAIZE, October 29th, 2004
!!--------------------------------------------------------------------------
subroutine trauthin(nthinerr)
  ! Updated to Fortran 2015 by V.K.B. Olsen, 19/11/2017
  use floatPrecision
  use mathlib_bouncer
  use numerical_constants
  use scatter, only : scatter_elemPointer
  use dynk, only : ldynk, dynk_isused, dynk_pretrack

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
  use mod_fluka
+ei
+if collimat
  use collimation
+ei

      use crcoall
      implicit none
      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      real(kind=fPrec) benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
      logical lopen
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
  dimension nbeaux(nbb)
+if collimat
+ca collpara
+ca dbtrthin
+ca database
+ca dbcommon
+ca dblinopt
+ca dbpencil
+ca info
+ca dbcolcom
+ei
+if bnlelens
+ca rhicelens
+ei
+ca parbeam_exp
  save

  do i=1,npart
    nlostp(i)=i
  end do
  do i=1,nblz
    ktrack(i)=0
    strack(i)=zero
    strackc(i)=zero
    stracks(i)=zero
  end do
+ca beams1

      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        !BLOC
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        goto 290
        !Non-linear/NOT BLOC
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
        kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        else if(kzz.eq.12) then
          !Disabled cavity; enabled cavities have kp=6 and are handled above
          ! Note: kz=-12 are transformed into +12 in daten after reading ENDE.
          ktrack(i)=31
          goto 290
        endif
+ca beams21
+ca beamcoo
+ca beamr1
     &goto 42
+ca beamr2
+ca beamr3o
+ca beams22
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam11   !do j=1,napx
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf1 !end do; do j=1,napx
+ca beama4o  !end do
+ca beams23  !end if; end if; end if;    if;if;if
+ca beam21   !do
+ca beama1
+ca beamcoo
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4o !end do
            else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4o
+ca beams24 !end if; end if; end if; goto 290

+ca wire
+ca acdip1
+ca crab1
+ca crab_mult
+ca elens
+ca scatter
+ca trom30
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),extalign(i,2),extalign(i,3)
        end if
        
        select case (kzz)
        case (1)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 11
+ca stra01
          end if
        case (2)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i)=12
+ca stra02
          end if
        case (3)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 13
+ca stra03
          end if
        case (4)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 14
+ca stra04
          end if
        case (5)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 15
+ca stra05
          end if
        case (6)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 16
+ca stra06
          end if
        case (7)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 17
+ca stra07
          end if
        case (8)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 18
+ca stra08
          end if
        case (9)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 19
+ca stra09
          end if
        case (10)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 20
+ca stra10
          end if
        case (11) ! Multipole block (also in initialize_element)
          r0  = ek(ix)
          nmz = nmu(ix)
          if(abs(r0).le.pieni.or.nmz.eq.0) then
            if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
              if ( dynk_isused(i) ) then
                write(lout,*) "ERROR: Element of type 11 (bez=",bez(ix),") is off in fort.2, but on in DYNK. Not implemented."
                call prror(-1)
              end if
              ktrack(i) = 31
            else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 33
+ca stra11
              else
                ktrack(i) = 35
+ca stra12
              end if
            else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 37
+ca stra13
              else
                ktrack(i) = 39
+ca stra14
              end if
            end if
          else
            if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
              ktrack(i) = 32
            else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 34
+ca stra11
              else
                ktrack(i) = 36
+ca stra12
              end if
            else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 38
+ca stra13
              else
                ktrack(i) = 40
+ca stra14
              end if
            end if
          end if
          if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
          if(mout2.eq.1) then
            benkcc = ed(ix)*benkc(irm(ix))
            r0a    = one
            r000   = r0*r00(irm(ix))
            
            do j=1,mmul
              fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
              fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
              r0a=r0a*r000
            end do
            
            write(9,'(a16)') bez(ix)
            write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
            write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
            
            do j=1,20
              fake(1,j)=zero
              fake(2,j)=zero
            end do
          end if
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 290
        case (24) ! DIPEDGE ELEMENT
+ca stra2dpe
          ktrack(i) = 55
        case (25) ! Solenoid
+ca solenoid
          ktrack(i) = 56
          
        !----------------
        !--Negative KZZ--
        !----------------
        case (-1)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 21
+ca stra01
          end if
        case (-2)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 22
+ca stra02
          end if
        case (-3)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 23
+ca stra03
          end if
        case (-4)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 24
+ca stra04
          end if
        case (-5)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 25
+ca stra05
          end if
        case (-6)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 26
+ca stra06
          end if
        case (-7)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 27
+ca stra07
          end if
        case (-8)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 28
+ca stra08
          end if
        case (-9)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 29
+ca stra09
          end if
        case (-10)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 30
+ca stra10
          end if
        case default
          ktrack(i)=31
        end select
        
  290 continue
      do j=1,napx
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
      end do
      nwri=nwr(3)
      if(nwri.eq.0) nwri=(numl+numlr)+1                                  !hr01

!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak, BE-ABP-HSS
!     last modified: 24-02-2015
!     save original kicks
!     always in main code
      if (ldynk) call dynk_pretrack

+if collimat
      if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then
+ei
+if .not.collimat
      if(idp.eq.0.or.ition.eq.0) then
+ei
        write(lout,*) ''
        write(lout,*) 'Calling thin4d subroutine'
        write(lout,*) ''
        call thin4d(nthinerr)
      else
+if collimat
        if (idp.eq.0.or.ition.eq.0) then
           write(lout,*) ""
           write(lout,*) "******* WARNING *******"
           write(lout,*) "Calling 6D tracking due to collimation!"
           write(lout,*) "Would normally have called thin4d"
           write(lout,*) ""
        endif
+ei

        hsy(3)=(c1m3*hsy(3))*real(ition,fPrec)                            !hr01
        do 310 jj=1,nele
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*                    &
     &     real(itionc(jj),fPrec)     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(lout,*) ''
          write(lout,*) 'Calling thin6dua subroutine'
          write(lout,*) ''

+if collimat
          if (do_coll) then
            write(lout,*)
            write(lout,*) "ERROR"
            write(lout,*) "thin6dua not supported by collimation"
            call prror(-1)
          endif
+ei
          call thin6dua(nthinerr)
        else
+if collimat
          call collimate_init()
!================================================================================
!Ralph make loop over 1e6/napx, a read xv(1,j) etc
!Du solltest zur Sicherheit dies resetten bevor Du in thin6d gehst
!Im Falle von Teilchenverluste werden n mlich pstop und nnumxv umgesetzt
!      do 80 i=1,npart
!        pstop(i)=.false.
!        nnumxv(i)=numl
!   80 numxv(i)=numl
!================================================================================
          do j = 1, int(mynp/napx00)
            write(lout,*) 'Sample number ', j, int(mynp/napx00)

            call collimate_start_sample(j)

            write(lout,*) ''
            write(lout,*) 'Calling thin6d subroutine'
            write(lout,*) ''
            call thin6d(nthinerr)

            call collimate_end_sample(j)

          end do
+ei ! endif collimat
+if .not.collimat
          write(lout,*) ''
          write(lout,*) 'Calling thin6d subroutine'
          write(lout,*) ''
          call thin6d(nthinerr)
+ei
        endif !end if(abs(phas).ge.pieni) then
      endif !end if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then ... else
+if collimat
      call collimate_exit()
+ei
  return
      
end subroutine trauthin

!>
!!  TRACK THIN LENS 4D
!!  F. SCHMIDT
!<
      subroutine thin4d(nthinerr)
      use floatPrecision
      use physical_constants
  use numerical_constants
      use mathlib_bouncer
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, dynk_apply

      use dump, only : dump_linesFirst, dump_lines, ldumpfront
      
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei
      use postprocessing, only : writebin
      use crcoall
      implicit none
+ca exactvars
+ca commonex
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,xlvj,xrb, &
     &yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) e0fo,e0o,xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost

+if time
      real(kind=fPrec) expt
+ei

+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim

+if cr
+ca crco
+ei

      dimension dpsv3(npart)

+if bnlelens
+ca rhicelens
+ca bnlio
+ei

+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp
+ca dbdcum
+ca comApeInfo

      save
!-----------------------------------------------------------------------
      nthinerr=0
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei

+if backtrk
+ca backtrkinit
+ei
+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN4D SIXTRACR restart numlcr',numlcr,'numl',numl
      endif
! and now reset numl to do only numlmax turns
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 640, n=numlcr,nnuml
+ei
+if .not.cr
      do 640 n=1,numl !loop over turns
+ei
+if boinc
!        call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
        numx=n-1

+if .not.fluka
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif
        
        call dump_linesFirst(n)
        
        ! loop over structure elements, single element: name + type + parameter,
        ! structure element = order of single elements/blocks
        do 630 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo ! ix = index of single element
!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
         call dump_lines(n,i,ix)
      endif

+if time
+ca timefct
+ei

+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         is the current entry an instance of a FLUKA element?
!         inserted in main code by the 'fluka' compilation flag
          if (fluka_enable) then
            if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                    !      be SINGLE ELEMENTs
              if(fluka_type(ix).ne.FLUKA_NONE) then
                if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                  call kernel_fluka_element( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 620
                else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                  fluka_inside = .true.
                  call kernel_fluka_entrance( n, i, ix )
                  goto 625
                else if(fluka_type(ix).eq.FLUKA_EXIT) then
                  fluka_inside = .false.
                  call kernel_fluka_exit( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 620
                end if
              end if
            end if
            if(fluka_inside) then
              if(fluka_debug) then
                write(lout,*) '[Fluka] Skipping lattice element at ', i
                write(fluka_log_unit,*)                                 &
     &'# Skipping lattice element at ', i
              end if
              goto 630
            end if
          endif
+ei

          goto(10,  630,  740, 630, 630, 630, 630, 630, 630, 630,       &!1-10
     &         30,  50,   70,   90, 110, 130, 150, 170, 190, 210,       &!11-20
     &         420, 440, 460,  480, 500, 520, 540, 560, 580, 600,       &!21-30
     &         620, 390, 230,  250, 270, 290, 310, 330, 350, 370,       &!31-40
     &         680, 700, 720,  630, 748, 630, 630, 630, 630, 630,       &!41-50
     &         745, 746, 751,  752, 753, 754, 630, 630, 630, 630,       &!51-60
     &         630, 630, 761),ktrack(i) ! 630 = skip element
          goto 630
   10     stracki=strack(i) 
          if(iexact.eq.0) then ! exact drift?
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
            enddo
          else
+ca ex4Ddrift
          endif
+if backtrk
+ca backtrksave
+ei
          goto 630
!--HORIZONTAL DIPOLE
   30     do 40 j=1,napx
+ca kickv01h ! astuce block with kick for element
   40     continue
          goto 620
!--NORMAL QUADRUPOLE
   50     do 60 j=1,napx
+ca alignva
+ca kickvxxh
   60     continue
          goto 620
!--NORMAL SEXTUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
   80     continue
          goto 620
!--NORMAL OCTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  100     continue
          goto 620
!--NORMAL DECAPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 620
!--NORMAL DODECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 620
!--NORMAL 14-POLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 620
!--NORMAL 16-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 620
!--NORMAL 18-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 620
!--NORMAL 20-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 620
  230     continue
          do 240 j=1,napx
+ca alignvb
+ca mul4v01
  240     continue
          goto 620
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
  260     continue
          goto 390
  270     continue
          do 280 j=1,napx
+ca mul4v02
  280     continue
          goto 620
  290     continue
          do 300 j=1,napx
+ca mul4v02
  300     continue
          goto 390
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v03
  320     continue
          goto 620
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
  340     continue
          goto 390
  350     continue
          do 360 j=1,napx
+ca mul4v04
  360     continue
          goto 620
  370     continue
          do 380 j=1,napx
+ca mul4v04
  380     continue
  390     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 410 j=1,napx
+ca alignvb
+ca mul4v05
                do 400 k=3,nmz
+ca mul4v06
  400           continue
+ca mul4v07
  410       continue
          else
            do 415 j=1,napx
+ca mul4v08
  415       continue
          endif
          goto 620
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  420     do 430 j=1,napx
+ca kickv01v
  430     continue
          goto 620
!--SKEW QUADRUPOLE
  440     do 450 j=1,napx
+ca alignva
+ca kickvxxv
  450     continue
          goto 620
!--SKEW SEXTUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  470     continue
          goto 620
!--SKEW OCTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  490     continue
          goto 620
!--SKEW DECAPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 620
!--SKEW DODECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 620
!--SKEW 14-POLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 620
!--SKEW 16-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 620
!--SKEW 18-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 620
!--SKEW 20-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 620
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 620
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 620
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 620
  740     continue
+ca trom40
+ca trom42
          goto 620
  745     continue
          xory=1
+ca acdipkick
          goto 620
  746     continue
          xory=2
+ca acdipkick
          goto 620
  751     continue
          xory=1
+ca crabkick
          goto 620
  752     continue
          xory=2
+ca crabkick
          goto 620
!--DIPEDGE ELEMENT
  753      continue
         do j=1,napx
+ca alignva
+ca kickvdpe
         enddo
          goto 620
!--solenoid
  754      continue
         do j=1,napx
+ca kickvso1
         enddo
          goto 620
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
          goto 620
!--Wire

  748     continue
+ca wirekick
  750     continue
          goto 620

!----------------------------

  620     continue

+ca lostpart

  625     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

  630   continue

!        call lostpart(nthinerr)
!        if(nthinerr.ne.0) return

        if(ntwin.ne.2) call dist1
+if .not.fluka
        if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
      napxto = napxto + napx
+ei

  640 continue
      return
      end subroutine thin4d

!>
!!  TRACK THIN LENS 6D
!!  F. SCHMIDT
!<
      subroutine thin6d(nthinerr)
      use floatPrecision
      use physical_constants
      use numerical_constants
      use mathlib_bouncer

+if datamods
      use bigmats
+ei
      use scatter, only : scatter_thin, scatter_debug
      use dynk, only : ldynk, dynk_apply
      use dump, only : dump_linesFirst, dump_lines, ldumpfront
+if beamgas
! <b>Additions/modifications:</b>
! - YIL: Added call to beamGas subroutine if element name starts with 
!   'press' or 'PRESS' (only for first turn)
! - YIL: Added call to beamGasInit just after readcollimator
+ei

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei

+if collimat
      use collimation
+ei
      use postprocessing, only : writebin
      use crcoall
      implicit none
+ca exactvars
+ca commonex
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,  &
     &xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) e0fo,e0o,xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,acdipamp1,       &
     &crabamp,crabfreq,                                                 &
     &crabamp2,crabamp3,crabamp4
+ca wiretracktmp
      logical llost
+if time
      real(kind=fPrec) expt
+ei
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim

+if collimat
+ca collpara
+ca dbcommon
+ca dbthin6d
+ca database
+ca dblinopt
+ca dbpencil
+ca info
+ca dbcolcom
+ei

+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei

+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp
+ca dbdcum
+ca comApeInfo
      real(kind=fPrec) dEpTur
      save
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0e-4_fPrec
+ei
      nthinerr=0

!     fluka
!     dE per turn [MeV]
      dEpTur=zero
      write(lout,*)'-->dEpTur[MeV]:',dEpTur

+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei

+if backtrk
+ca backtrkinit
+ei
+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

!This is the loop over turns: label 660
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
      endif
! and now reset numl to do only numlmax turns
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 660 n=numlcr,nnuml ! Loop over turns, CR version
+ei
+if .not.cr
      do 660 n=1,numl       ! Loop over turns
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
+if collimat
        call collimate_start_turn(n)
+ei
        numx=n-1

        if (dEpTur.ne.zero) then
           do j=1,napx
              ejf0v(j)=ejfv(j)
              ejv(j)=ejv(j)-dEpTur
              ejfv(j)=sqrt(ejv(j)**2-pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
              yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          enddo
        endif

+if .not.fluka
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei
      
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

        call dump_linesFirst(n)

!! This is the loop over each element: label 650
        do 650 i=1,iu !Loop over elements
+if collimat
      call collimate_start_element(i)
+ei
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo

+if beamgas
!YIL Call beamGas subroutine whenever a pressure-element is found
! should be faster/safer to first check the turn then do the name search
      if( iturn.eq.1 ) then
        if (bez(myix)(1:5).eq.'PRESS' .or.     
     &    bez(myix)(1:5).eq.'press' ) then
               call beamGas(myix, secondary,totals,myenom,ipart)
         endif
      endif
+ei beamgas

!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
         call dump_lines(n,i,ix)
      endif
      
+if time
+ca timefct
+ei

+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         is the current entry an instance of a FLUKA element?
!         inserted in main code by the 'fluka' compilation flag
          if (fluka_enable) then
            if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                    !      be SINGLE ELEMENTs
              if(fluka_type(ix).ne.FLUKA_NONE) then
                if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                  call kernel_fluka_element( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 640
                else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                  fluka_inside = .true.
                  call kernel_fluka_entrance( n, i, ix )
                  goto 645
                else if(fluka_type(ix).eq.FLUKA_EXIT) then
                  fluka_inside = .false.
                  call kernel_fluka_exit( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 640
                end if
              end if
            end if
            if(fluka_inside) then
              if(fluka_debug) then
                write(lout,*) '[Fluka] Skipping lattice element at ', i
                write(fluka_log_unit,*)                                 &
     &'# Skipping lattice element at ', i
              end if
              goto 650
            end if
          endif
+ei !END +if fluka

+if .not.collimat
!---------count:44
+if debug
!         if (n.eq.1) then
!           write (93,*) 'ktrack(i)=',ktrack(i)
!           endfile (93,iostat=ierro)
!           backspace (93,iostat=ierro)
!         endif
+ei
! JBG RF CC Multipoles
! JBG adding CC multipoles elements in tracking. ONLY in thin6d!!!
!     JBG 755 -RF quad, 756 RF Sext, 757 RF Oct
!          if (ktrack(i) .eq. 1) then !BLOCK of linear elements
!             write (lout,*) "Kick for element", i,ix, "[BLOCK]"
!          else
!             write(lout,*) "Kick for element",
!     &            i,ix,bez(ix),ktrack(i),kp(ix)
!          endif
          goto( 10, 30,740,650,650,650,650,650,650,650,                 &!1-10
     &          50, 70, 90,110,130,150,170,190,210,230,                 &!11-20
     &         440,460,480,500,520,540,560,580,600,620,                 &!21-30
     &         640,410,250,270,290,310,330,350,370,390,                 &!31-40
     &         680,700,720,730,748,650,650,650,650,650,                 &!41-50
     &         745,746,751,752,753,754,755,758,756,759,                 &!51-60
     &         757,760,761,762,763),ktrack(i)
+ei
+if collimat
!          if (myktrack .eq. 1) then !BLOCK of linear elements
!             write (*,*) "Kick for element", i,ix, "[BLOCK]"
!          else
!             write(*,*) "Kick for element", i,ix,bez(ix),myktrack,kp(ix)
!          endif
          goto(10,  30, 740, 650, 650, 650, 650, 650, 650, 650,         &!1-10
     &         50,  70,  90, 110, 130, 150, 170, 190, 210, 230,         &!11-20
     &        440, 460, 480, 500, 520, 540, 560, 580, 600, 620,         &!21-30
     &        640, 410, 250, 270, 290, 310, 330, 350, 370, 390,         &!31-40
     &        680, 700, 720, 730, 748, 650, 650, 650, 650, 650,         &!41-50
     &        745, 746, 751, 752, 753, 754, 755, 758, 756, 759,         &!51-60
     &        757, 760, 761, 762, 763 ),myktrack
          write (lout,*) "WARNING: Non-handled element in thin6d()!",   &
     &                " i=", i, "ix=", ix, "myktrack=",  myktrack,      &
     &                " bez(ix)='", bez(ix),"' SKIPPED"
+ei
          goto 650

   10     stracki=strack(i)
+if collimat

!==========================================
!Ralph drift length is stracki
!bez(ix) is name of drift
          totals=totals+stracki
!          write(*,*) 'ralph> Drift, total length: ', stracki,totals

!________________________________________________________________________
!++  If we have a collimator then...
!
!Feb2006
!GRD (June 2005) 'COL' option is for RHIC collimators
!
!     SR (17-01-2006): Special assignment to the TCS.TCDQ for B1 and B4,
!     using the new naming as in V6.500.
!     Note that this must be in the loop "if TCSG"!!
!
!     SR, 17-01-2006: Review the TCT assignments because the MADX names
!     have changes (TCTH.L -> TCTH.4L)
!
! JULY 2008 added changes (V6.503) for names in TCTV -> TCTVA and TCTVB 
! both namings before and after V6.503 can be used 
!
          if (do_coll .and.                                             &
     &         (bez(myix)(1:2).eq.'TC'                                  &
     &         .or. bez(myix)(1:2).eq.'tc'                              &
     &         .or. bez(myix)(1:2).eq.'TD'                              &
     &         .or. bez(myix)(1:2).eq.'td'                              &
     &         .or. bez(myix)(1:3).eq.'COL'                             &
     &         .or. bez(myix)(1:3).eq.'col')) then

          call collimate_start_collimator(stracki)

!++ For known collimators
          if(found) then
            call collimate_do_collimator(stracki)
            call collimate_end_collimator()
          end if ! end of check for 'found'
!------------------------------------------------------------------
!++  Here leave the known collimator IF loop...
!_______________________________________________________________________
!++  If it is just a drift...
          else
            do 23 j=1,napx
                xv(1,j)=xv(1,j)+stracki*yv(1,j)
                xv(2,j)=xv(2,j)+stracki*yv(2,j)
+if rvet
            rvet(j)=c1e3*pma*pma*(two+dpsv(j))*dpsv(j)/e0/(one+dpsv(j))
            rvet(j)=rvet(j)/(e0*(one+dpsv(j))+                          &
     &sqrt(e0*e0+e0f*e0f*(two*dpsv(j)+dpsv(j)*dpsv(j))))
            sigmv(j)=sigmv(j)+stracki*(rvet(j)-c5m4*rvv(j)*(yv(1,j)     &
     &*yv(1,j)+yv(2,j)*yv(2,j)))
+ei
+if fast
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &
     &*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
+ei
+if .not.fast.and..not.rvet
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt(c1e6+yv(1,j)    &
     &*yv(1,j)+yv(2,j)*yv(2,j)))
+ei
              xj     = (xv(1,j)-torbx(ie))/c1e3
              xpj    = (yv(1,j)-torbxp(ie))/c1e3
              yj     = (xv(2,j)-torby(ie))/c1e3
              ypj    = (yv(2,j)-torbyp(ie))/c1e3
              pj     = ejv(j)/c1e3

              if(firstrun) then
                if (iturn.eq.1.and.j.eq.1) then
                  sum_ax(ie)=zero
                  sum_ay(ie)=zero
                endif
              endif

              gammax = (one + talphax(ie)**2)/tbetax(ie)
              gammay = (one + talphay(ie)**2)/tbetay(ie)

              if (part_abs_pos(j).eq.0 .and. part_abs_turn(j).eq.0) then
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &two*talphax(ie)*xj*xpj +                                          &
     &tbetax(ie)*xpj**2 )/myemitx0_collgap)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &two*talphay(ie)*yj*ypj +                                          &
     &tbetay(ie)*ypj**2 )/myemity0_collgap)
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
              else
                nspx = zero
                nspy = zero
              endif
                sampl(ie)    = totals
                ename(ie)    = bez(myix)(1:16)

 23           continue

          endif
          goto 650
!GRD END OF THE CHANGES FOR COLLIMATION STUDIES, BACK TO NORMAL SIXTRACK STUFF
+ei

+if .not.collimat
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
+ca sqrtv
            enddo
          else
+ca ex6Ddrift

+if backtrk
+ca backtrksave
+ei
          endif
          goto 650
+ei
   30     do 40 j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(kz(ix).eq.12) then
              ejv(j)=ejv(j)+ed(ix)*sin_mb(hsyc(ix)*sigmv(j)+phasc(ix))
            else
              ejv(j)=ejv(j)+hsy(1)*sin_mb(hsy(3)*sigmv(j))
            endif
            ejfv(j)=sqrt(ejv(j)**2-pma**2)                               !hr01
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
            yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
 40       continue
          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
+ca kickv01h
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvxxh
   80     continue
          goto 640
  755     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul2
          goto 640
  758     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul2s
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  100     continue
          goto 640
  756     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul3
          goto 640 
  759     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul3s
          goto 640 
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 640
! JBG RF CC Multipoles
  757     continue
          xory=1
+ca ccmul4
          goto 640
  760     continue
          xory=1
! JBG RF CC Multipoles
+ca ccmul4s
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
+ca alignvb
+ca mul4v05
                do 420 k=3,nmz
+ca mul4v06
  420           continue
+ca mul4v07
  430       continue
          else
            do 435 j=1,napx
+ca mul4v08
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
+ca kickv01v
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvxxv
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  630     continue
          goto 640

!--4D BB kick
  680     continue
          do 690 j=1,napx
+ca beamco     !Get x-y offset
+ca beamr1     !Get r**2
     &goto 690 !The radius was too small -> Skip
+ca beamr2
+ca beamr3     !Kick the particles
  690     continue
          goto 640

  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then ! fast kick
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 640
  730     continue
+ca beam6d
          goto 640
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 640
  745     continue
          xory=1
+ca acdipkick
          goto 640
  746     continue
          xory=2
+ca acdipkick
          goto 640
  751     continue
          xory=1
+ca crabkick
          goto 640
  752     continue
          xory=2
+ca crabkick
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 640
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 640
!--scatter (thin)
 762     continue
+ca scat_thi
         goto 640
!--scatter (thick)
 763     continue
+ca scat_tck
         goto 640
!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 640

!----------------------------
+if collimat
! end of the loop over element type (myktrack and ktrack(i))
+ei

  640     continue
!GRD UPGRADE JANUARY 2005
+if collimat
      call collimate_end_element
+ei
!GRD END OF UPGRADE

+ca lostpart

  645     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

 650  continue !END loop over structure elements


+if collimat
      call collimate_end_turn
+ei

+if .not.collimat
!        call lostpart(nthinerr)
!        if(nthinerr.ne.0) return
        if(ntwin.ne.2) call dist1
+if .not.fluka
        if(mod(n,nwr(4)).eq.0) call write6(n)
+ei
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
      napxto = napxto + napx
+ei

  660 continue !END loop over turns

+if collimat
      close(99)
      close(53)

!GRD HERE WE SET THE FLAG FOR INITIALIZATION TO FALSE AFTER TURN 1
      firstrun = .false.
+ei

      return
      end subroutine thin6d

!==============================================================================
!
      subroutine thin6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THIN LENS 6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      use floatPrecision
      use physical_constants
  use numerical_constants
      use mathlib_bouncer

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei

+if datamods
      use bigmats
+ei
      
      use dynk, only : ldynk, dynk_apply
      use dump, only : dump_linesFirst, dump_lines, ldumpfront
      use postprocessing, only : writebin
      use crcoall
      implicit none
+ca exactvars
+ca commonex
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,e0fo,e0o,r0,r2b,rb,rho2b,rkb,stracki, &
     &tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      real(kind=fPrec) expt
+ei
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp
+ca dbdcum
+ca comApeInfo

+if fluka

!     A.Mereghetti, for the FLUKA Team
!     last modified: 12-01-2016
!     temporary integer variable, for updating ref part
!     inserted in main code by the 'fluka' compilation flag
      integer mtemp

+ei
      save
!-----------------------------------------------------------------------
+if fast
      c5m4=5.0e-4_fPrec
+ei
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei
      nthinerr=0

+if backtrk
+ca backtrkinit
+ei
+if fluka

!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THIN6DUA ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 660 n=numlcr,nnuml
+ei
+if .not.cr
      do 660 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
        numx=n-1

+if .not.fluka
        if(n.le.nde(1)) nwri=nwr(1)
        if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
        if(n.gt.nde(2)) nwri=nwr(3)
        if(nwri.eq.0) nwri=numl+numlr+1
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call dynk_apply(n)
        endif

        call dump_linesFirst(n)
        
        do 650 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
          ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
          ! as no dependency on ix in this case.
          ix=ic(i)-nblo
!Should this be inside "if ktrack .ne. 1"? (time/bpm)
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
         call dump_lines(n,i,ix)
      endif
      
+if time
+ca timefct
+ei

+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         is the current entry an instance of a FLUKA element?
!         inserted in main code by the 'fluka' compilation flag
          if (fluka_enable) then
            if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                    !      be SINGLE ELEMENTs
              if(fluka_type(ix).ne.FLUKA_NONE) then
                if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                  call kernel_fluka_element( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 640
                else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                  fluka_inside = .true.
                  call kernel_fluka_entrance( n, i, ix )
                  goto 645
                else if(fluka_type(ix).eq.FLUKA_EXIT) then
                  fluka_inside = .false.
                  call kernel_fluka_exit( n, i, ix )
+if backtrk
+ca backtrksave
+ei
                  goto 640
                end if
              end if
            end if
            if(fluka_inside) then
              if(fluka_debug) then
                write(lout,*) '[Fluka] Skipping lattice element at ', i
                write(fluka_log_unit,*)                                 &
     &'# Skipping lattice element at ', i
              end if
              goto 650
            end if
          endif
+ei
!--------count44
          goto(10 ,30 ,740,650,650,650,650,650,650,650,                 &!1-10
     &         50 ,70 ,90 ,110,130,150,170,190,210,230,                 &!11-20
     &         440,460,480,500,520,540,560,580,600,620,                 &!21-30
     &         640,410,250,270,290,310,330,350,370,390,                 &!31-40
     &         680,700,720,730,748,650,650,650,650,650,                 &!41-50
     &         745,746,751,752,753,754,650,650,650,650,                 &!51-60
     &         650,650,761),ktrack(i)
          goto 650
   10     stracki=strack(i)
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
+ca sqrtv
            enddo
          else
+ca ex6Ddrift
          endif

+if backtrk
+ca backtrksave
+ei

          goto 650
   30     e0o=e0
          e0fo=e0f
          call adia(n,e0f)

+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 18-01-2016
!         update energy/momentum of reference particle in mod_fluka
!            and synch magnetic rigidity with Fluka (for the time being,
!            consider only protons);
!         NB: adia(n,e0f) updates e0 first (contained in common 'syn')
!             and then e0f
!         inserted in main code by the 'fluka' compilation flag
          if(fluka_enable) then
            write(lout,*) '[Fluka] Updating ref particle'
            write(fluka_log_unit,*) '# Updating ref particle'
            mtemp = fluka_set_synch_part( e0, e0f, pma, 1 )
            if(mtemp .lt. 0) then
            write(lout,*) '[Fluka] Error: failed to update ref particle'
            write(fluka_log_unit, *) '# failed to update ref particle'
              call prror(-1)
            end if
            write(lout,*) '[Fluka] Updating ref particle successful;'
            write(fluka_log_unit,*)'# Updating ref particle successful;'
          endif
+ei

          do j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr
            if(kz(ix).eq.12) then
              ejv(j)=ejv(j)+ed(ix)*sin_mb((hsyc(ix)*sigmv(j)+phas)+     &!hr01
     &                                    phasc(ix))                     !hr01
            else
              ejv(j)=ejv(j)+hsy(1)*sin_mb(hsy(3)*sigmv(j)+phas)
            endif
!           ejfv(j)=sqrt(ejv(j)**2-pma**2)                               !hr01
            ejfv(j)=sqrt((ejv(j)-pma)*(ejv(j)+pma))
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
            if(sigmv(j).gt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                             !hr01
          end do

          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
+ca kickv01h
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
+ca alignva
+ca kickvxxh
   80     continue
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  100     continue
          goto 640
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  120     continue
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
+ca alignvb
+ca mul4v05
                do 420 k=3,nmz
+ca mul4v06
  420           continue
+ca mul4v07
  430       continue
          else
            do 435 j=1,napx
+ca mul4v08
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
+ca kickv01v
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
+ca alignva
+ca kickvxxv
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  630     continue
          goto 640
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 640
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 640
  730     continue
+ca beam6d
          goto 640
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 640
  745     continue
          xory=1
+ca acdipkick
          goto 640
  746     continue
          xory=2
+ca acdipkick
          goto 640
  751     continue
          xory=1
+ca crabkick
          goto 640
  752     continue
          xory=2
+ca crabkick
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 640
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 640

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 640

!----------------------------

  640     continue

+ca lostpart

  645     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

  650   continue
        !call lostpart(nthinerr)
        if(nthinerr.ne.0) return
        if(ntwin.ne.2) call dist1
+if .not.fluka
        if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
+ca bnlout
        endif
!GRDRHIC
!GRD-042008
+ei
  660 continue
      return
      end subroutine thin6dua

subroutine callcrp()
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if cr
+ca crco
+ei
      integer ia,ia2,ie,nthinerr
+if cr
      integer ncalls
+ei
+if boinc
      integer timech
+ei
+if bnlelens
+ca rhicelens
+ei
+if cr
      data ncalls /0/
+ei
      save
!-----------------------------------------------------------------------
+if cr
      ncalls=ncalls+1 
      write(91,*,iostat=ierro,err=11) numx,numl
      rewind 91
      if (restart) then
        write(93,*) 'CALLCRP/CRPOINT bailing out'
        write(93,*) 'numl, nnuml, numx, numlcr ',numl,nnuml,numx,numlcr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        return
      else
+if .not.debug
        if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*) 'CALLCRP numl, nnuml, numlcr, numx, nwri, numlcp '
        write(93,*) numl,nnuml,numlcr,numx,nwri,numlcp
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      endif
+if boinc
      if (checkp) then
! Now ALWAYS checkpoint
! NO, re-instated at user request
        call boinc_time_to_checkpoint(timech)
        if (timech.ne.0) then
          call crpoint
          call boinc_checkpoint_completed()
        endif
      endif
+ei
+if .not.boinc
      if (checkp) call crpoint
+ei
      return
   11 write(lout,*)                                                     &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : 91',ierro
      write(lout,*)'SIXTRACR WRITEBIN IO ERROR on Unit 91'
      call prror(-1)
+ei
      return
end subroutine callcrp

subroutine lostpart(turn, i, ix, llost, nthinerr)
!-----------------------------------------------------------------------
!
!     P.Garcia Ortega, A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified:  8-12-2014
!     aperture check and dump lost particles
!     always in main code
!-----------------------------------------------------------------------
!     7 April 2014
!-----------------------------------------------------------------------

      use floatPrecision
      use mathlib_bouncer
  use numerical_constants
      use physical_constants

+if fluka
      use mod_fluka
+ei
      use crcoall
      implicit none
!     parameters
      integer turn  ! turn number
      integer i     ! element entry in the lattice
      integer ix    ! single element type index
      logical llost ! at least one particle was lost


!      logical isnan
      logical myisnan
      integer ib2,ib3,ilostch,j,jj,jj1,jjx,lnapx
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
+if collimat
! Module to access ipart array
+ca collpara
+ca dbthin6d
+ca dbcommon
+ei
+ca dbdcum
+ca comApeInfo

!     temporary variables
      logical checkRE, checkEL, checkRL, checkOC, checkRT, checkCR
      logical lparID
      integer nthinerr
      real(kind=fPrec) apxx, apyy, apxy, aps, apc, radius2
      real(kind=fPrec) ap_oc_1, ap_oc_2, ap_oc_3
      real(kind=fPrec) xchk(2,npart)

+if backtrk
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 12-06-2014
!     additional variables for back-tracking, when computing locations of
!        lost particles
!     inserted in main code by the 'backtrk' compilation flag
      integer niter       ! number of iterations
      integer kapert      ! temporal integer for aperture type
      logical llos(npart) ! temporal logic array for interpolation
      real(kind=fPrec) xlos(2,npart), aprr(7), step(npart), length,     &
     & slos(npart), apnew(7), xnew(2)
+ei
      save
!-----------------------------------------------------------------------
      llost=.false.

!     Set pstop for each particle

      if ( limifound ) then

         if ( lapeofftlt(ix) ) then
!           Include offset and angle rotation
            do j=1,napx
               call roffpos( xv(1,j), xv(2,j), xchk(1,j), xchk(2,j),    &
     &                       ape(5,ix), ape(6,ix), ape(7,ix) )
            end do
         else
!           use original coordinates
            do j=1,napx
               xchk(1,j)=xv(1,j)
               xchk(2,j)=xv(2,j)
            end do
         end if

!        go through all possible types
         
         if ( kape(ix).eq.2 ) then
!           Rectangle
            do j=1,napx
               pstop(nlostp(j))=checkRE(xchk(1,j),xchk(2,j),ape(1,ix),ape(2,ix))&
     &  .or.myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else if( kape(ix).eq.3 ) then
!           Ellipse
            apxx = ape(3,ix)**2.
            apyy = ape(4,ix)**2.
            apxy = apxx * apyy
            do j=1,napx
               pstop(nlostp(j))=checkEL( xchk(1,j),xchk(2,j),apxx,apyy,apxy )   &
     & .or.myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else if( kape(ix).eq.4 ) then
!           RectEllipse
            apxx = ape(3,ix)**2.
            apyy = ape(4,ix)**2.
            apxy = apxx * apyy
            do j=1,napx
       pstop(nlostp(j))=checkRL(xchk(1,j),xchk(2,j),ape(1,ix),ape(2,ix),&
     &                      apxx, apyy, apxy ) .or.                     &
     &      myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else if( kape(ix).eq.5 ) then
!           Octagon
!           As in MAD-X:
!            x.gt.ap1 .or. y.gt.ap2 .or.
!           (ap2*tan_mb(pi/two-ap4)-ap1)*
!           (y-ap1*tan_mb(ap3))-
!           (ap2-ap1*tan_mb(ap3))*(x-ap1).lt.zero

!           Pre-calculate constants before the loop
            ap_oc_1 = ape(2,ix)*tan_mb(pi/two-ape(4,ix))-ape(1,ix)
            ap_oc_2 = ape(1,ix)*tan_mb(ape(3,ix))
            ap_oc_3 = ape(2,ix)-ape(1,ix)*tan_mb(ape(3,ix))

            do j=1,napx
            pstop(nlostp(j))=checkOC(xchk(1,j), xchk(2,j), ape(1,ix),   &
     &      ape(2,ix), ap_oc_1, ap_oc_2, ap_oc_3) .or.                  &
     &      myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else if( kape(ix).eq.6 ) then
!           Racetrack
!           NB: it follows the MadX definition
            apxy = ape(3,ix)**2.
            do j=1,napx
               pstop(nlostp(j))=checkRT( xchk(1,j), xchk(2,j),          &
     &              ape(1,ix), ape(2,ix), ape(3,ix), apxy ) .or.        &
     &      myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else if( kape(ix).eq.7 ) then
!           Circle
            radius2 = ape(1,ix)**2
            do j=1,napx
               pstop(nlostp(j))=checkCR( xchk(1,j),xchk(2,j),radius2 )   &
     & .or.myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         else
!           Unknown aperture type, general check (set in the ITER block)
            do j=1,napx
        pstop(nlostp(j))=checkRE( xchk(1,j), xchk(2,j), aper(1), aper(2))&
     &  .or.myisnan(xchk(1,j),xchk(1,j)).or.myisnan(xchk(2,j),xchk(2,j))
            end do
         endif
      else
!        no actual aperture profile is assigned to any SINGLE ELEMENT
!        use the general check (set in the ITER block)
         do j=1,napx
           pstop(nlostp(j))=checkRE(xv(1,j), xv(2,j), aper(1), aper(2)) &
     &  .or.myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
         end do
      end if

!     is there at least a particle lost?
      do j=1,napx
        if(pstop(nlostp(j))) then
          llost=.true.
          goto 10
        end if
      end do
 10   continue

      if ( llost ) then

+if backtrk
!        A. Mereghetti and P. Garcia Ortega, for the FLUKA Team
!        last modified: 24-11-2016
!        back-track particles, in order to better estimate actual loss point
!        inserted in main code by the 'backtrk' compilation flag

!        Initialise arrays
         do j=1,napx
           xlos(1,j) = xv(1,j)
           xlos(2,j) = xv(2,j)
           llos(j)   = pstop(j)
           slos(j)   = dcum(i)
           step(j)   = one
! AM -> !          AMdebug
! AM ->            if ( pstop(j) ) then
! AM ->               write (*,*) 'ape loss:', turn, i, ix, bez(ix), dcum(i),
! AM ->      &         fluka_uid(j), fluka_gen(j), xv(1,j)*1d-3, yv(1,j)*1d-3,
! AM ->      &         xv(2,j)*1d-3, yv(2,j)*1d-3, ejfv(j)*1d-3, llos(j)
! AM ->            endif
         enddo
     
         if ( kape(ix) .ne. 0 ) then

           ! initialize temporary aperture profile;
           ! it can be either a constant aperture or a changing one (only RL
           !    allowed, for the moment!)
           kapert = kape(ix)
           do jj=1,7
             apnew(jj) = ape(jj,ix)
           enddo
           if ( kape(ix) .ge. 5 .or. kapold .ge. 5 ) then
             ! force constant Racetrack or Octagon profile
             do jj=1,7
               apold(jj) = apnew(jj)
             end do
           else
             ! a possible RL-equivalent transition
             kapert = 4
           endif

           ! Length between elements
           length = dcum(i)-sold
           if ( length .lt. zero ) then
             ! pay attention to overflow:
             ! length = dcum(i)+(dcum(iu+1)-sold)
             length = length+dcum(iu+1)
           endif
           if ( length .le. bktpre ) goto 11

           ! Number of iterations (ln(2x/precision)/ln(2)+1)
           niter=nint(1.442695040889_fPrec*log_mb(two*length/bktpre)+2)

           ! Interpolation of the lost particles position down to bktpre
           ! only for already lost particles
           do jj=1,niter
             do j=1,napx
               if(pstop(j)) then
                 ! Update parameter
                 if ( llos(j) ) then
                   step(j) = step(j) - one / (two**(jj))
                 else
                   step(j) = step(j) + one / (two**(jj))
                 endif
           
                 ! step discretized, to compare with BeamLossPattern
                 if (jj.eq.niter) then
                   slos(j) = int((sold+length*step(j))/bktpre+1.)*bktpre
                   step(j) = (slos(j)-sold)/length
                 end if
           
                 ! Update position
                 xlos(1,j) = xv(1,j) -yold(1,j)*(one-step(j))*length
                 xlos(2,j) = xv(2,j) -yold(2,j)*(one-step(j))*length
                 slos(j)   = sold    +length*step(j)
           
                 ! Update apertures
                 do jj1=1,7
                   aprr(jj1)=apold(jj1)+(apnew(jj1)-apold(jj1))*step(j)
                 end do
           
                 ! Check aperture
                 if ( lapeofftlt(ix) ) then
                    call roffpos( xlos(1,j), xlos(2,j), xnew(1),xnew(2),&
     &                            aprr(5), aprr(6), aprr(7) )
                 else
                    xnew(1) = xlos(1,j)
                    xnew(2) = xlos(2,j)
                 end if
                 if ( kapert.eq.1 ) then
!                   Circle
                    radius2 = aprr(1)**2
                    llos(j)=checkCR(xnew(1),xnew(2),radius2) .or.       &
     &                  myisnan(xnew(1),xnew(1)).or.                    &
     &                  myisnan(xnew(2),xnew(2))
                 else if ( kapert.eq.2 ) then
!                    Rectangle
              llos(j)=checkRE(xnew(1),xnew(2),aprr(1),aprr(2))          &
     &  .or.myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
                 else if ( kapert.eq.3 ) then
!                    Ellipse
                     apxx = aprr(3)**2.
                     apyy = aprr(4)**2.
                     apxy = apxx * apyy
              llos(j)=checkEL( xnew(1),xnew(2),apxx,apyy,apxy )         &
     &  .or.myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
                 else if ( kapert.eq.4 ) then
!                   RectEllipse
                    apxx = aprr(3)**2.
                    apyy = aprr(4)**2.
                    apxy = apxx * apyy
                    llos(j) = checkRL( xnew(1),xnew(2),aprr(1),aprr(2), &
     &                       apxx, apyy, apxy ) .or.                    &
     &                  myisnan(xnew(1),xnew(1)).or.                    &
     &                  myisnan(xnew(2),xnew(2))
                 else if ( kapert.eq.5 ) then
!                   Octagon
            ap_oc_1 = aprr(2)*tan_mb(pi/two-aprr(4))-aprr(1)
            ap_oc_2 = aprr(1)*tan_mb(aprr(3))
            ap_oc_3 = aprr(2)-aprr(1)*tan_mb(aprr(3))

            llos(j)=checkOC(xnew(1), xnew(2), aprr(1),                  &
     &      aprr(2), ap_oc_1, ap_oc_2, ap_oc_3) .or.                    &
     &                  myisnan(xnew(1),xnew(1)).or.                    &
     &                  myisnan(xnew(2),xnew(2))
                 else if ( kapert.eq.6 ) then
!                   Racetrack
!                   NB: it follows the MadX definition
                    llos(j) = checkRT( xnew(1), xnew(2),                &
     &                     aprr(1), aprr(2), aprr(3), aprr(3)**2. ) .or.&
     &                  myisnan(xnew(1),xnew(1)).or.                    &
     &                  myisnan(xnew(2),xnew(2))
                 end if
! AM -> !                AMdebug
! AM ->                  write(*,*) 'new loss:', turn, i, ix, bez(ix), slos(j), 
! AM ->      &    fluka_uid(j), fluka_gen(j), xlos(1,j)*1d-3, yv(1,j)*1d-3,
! AM ->      &     xlos(2,j)*1d-3, yv(2,j)*1d-3, ejfv(j)*1d-3, llos(j)
               endif
             enddo
           enddo
           
  11       continue
        
         endif
+ei

!        If lost particles aren't killed, the lost info is dumped only
!        the first time they hit the aperture. Their secondaries generated
!        from a lost particles are considered lost as well
         if ( apflag ) then
           do j=1,napx
             if(pstop(nlostp(j))) then
               lparID = .false.
               jjx=1
+if collimat
               do jj=1,npart
+ei
+if .not.collimat
                 do jj=1,napx
+ei
                 if (plost(jj).ne.0) then
+if fluka
                 if ( fluka_uid(j).eq.plost(jj).or.                     &
     &                  fluka_gen(j).eq.plost(jj) )                     &
+ei
+if collimat
                   if ( ipart(j)+100*samplenumber .eq. plost(jj) )      &
+ei
+if .not.collimat.and..not.fluka
                   if ( j .eq. plost(jj) )                              &
+ei
     &             lparID=.true.
                   jjx=jj+1 !points to the last zero 
                 end if
               end do
               if (lparID) then
                 !old lost particle or secondary, don't print it
                 pstop(nlostp(j)) = .false.
               else
                 !new lost particle, store ID and print it
+if fluka
                 plost(jjx) = fluka_uid(j)
+ei
+if collimat
                 plost(jjx) = ipart(j)+100*samplenumber
+ei
+if .not.collimat.and..not.fluka
                 plost(jjx) = j
+ei
                end if
              end if
            end do
          end if


         ! Print to 999
         do j=1,napx
           if(pstop(nlostp(j))) then
+if backtrk
!            A. Mereghetti and P. Garcia Ortega, for the FLUKA Team
!            last modified: 11-06-2014
!            back-track particles, in order to better estimate actual loss point
!            inserted in main code by the 'backtrk' compilation flag
             if ( slos(j).gt.dcum(iu+1) ) then
                ! pay attention to overflow:
                slos(j)=slos(j)-dcum(iu+1)
             endif
+ei
             write(999,                                                 &
+if fluka
     &         '(3(1X,I8),1X,A16,1X,F12.5,2(1X,I8),8(1X,1PE14.7))')     &
+ei
+if .not.fluka
     &         '(3(1X,I8),1X,A16,1X,F12.5,1X,I8,7(1X,1PE14.7))')        &
+ei
+if .not.backtrk
     &         turn, i, ix, bez(ix), dcum(i),                           &
+ei
+if backtrk
     &         turn, i, ix, bez(ix), slos(j),                           &
+ei
+if fluka
     &         fluka_uid(j), fluka_gen(j), fluka_weight(j),             &
+ei
+if collimat
     &         ipart(j)+100*samplenumber,                               &
+ei
+if .not.fluka.and..not.collimat
     &         j,                                                       &
+ei
+if .not.backtrk
     &         xv(1,j)*c1m3, yv(1,j)*c1m3, xv(2,j)*c1m3,                &
+ei
+if backtrk
     &         xlos(1,j)*c1m3, yv(1,j)*c1m3, xlos(2,j)*c1m3,            &
+ei
     &         yv(2,j)*c1m3,ejfv(j)*c1m3, (ejv(j)-e0)*c1e6,             &
     &         -c1m3 * (sigmv(j)/clight) * (e0/e0f)
           endif
         end do

!flush loss particle file
      flush(999)

!     Don't kill lost particle if apflag is activated
      if ( apflag ) then
        do j=1,napx
          pstop(nlostp(j)) = .false.
         end do
      end if

! Record for postpr
      do j=1,napx
        if(pstop(nlostp(j))) then
!          aperv(nlostp(j),1)=apx(ix)
!          aperv(nlostp(j),2)=apz(ix)
          ixv(nlostp(j))=ix
          xvl(1,nlostp(j))=xv(1,j)
          xvl(2,nlostp(j))=xv(2,j)
          yvl(1,nlostp(j))=yv(1,j)
          yvl(2,nlostp(j))=yv(2,j)
          dpsvl(nlostp(j))=dpsv(j)
          ejvl(nlostp(j))=ejv(j)
          sigmvl(nlostp(j))=sigmv(j)
          numxv(nlostp(j))=numx
          nnumxv(nlostp(j))=numx
        end if
      end do

         ! Compact array
         lnapx=napx
         do j=napx,1,-1
           if(pstop(nlostp(j))) then
             if(j.ne.lnapx) then
               do jj=j,lnapx-1
                 jj1=jj+1
                 nlostp(jj)=nlostp(jj1)
                 xv(1,jj)=xv(1,jj1)
                 xv(2,jj)=xv(2,jj1)
                 yv(1,jj)=yv(1,jj1)
                 yv(2,jj)=yv(2,jj1)
+if bnlelens
                 namepart(jj)=namepart(jj1)
+ei
                 dpsv(jj)=dpsv(jj1)
                 sigmv(jj)=sigmv(jj1)
                 ejfv(jj)=ejfv(jj1)
                 ejv(jj)=ejv(jj1)
                 rvv(jj)=rvv(jj1)
+if rvet
                 rvet(jj)=rvet(jj1)
+ei
                 oidpsv(jj)=oidpsv(jj1)
                 dpsv1(jj)=dpsv1(jj1)
                 clo6v(1,jj)=clo6v(1,jj1)
                 clo6v(2,jj)=clo6v(2,jj1)
                 clo6v(3,jj)=clo6v(3,jj1)
                 clop6v(1,jj)=clop6v(1,jj1)
                 clop6v(2,jj)=clop6v(2,jj1)
                 clop6v(3,jj)=clop6v(3,jj1)
!--beam-beam element
                 di0xs(jj)=di0xs(jj1)
                 dip0xs(jj)=dip0xs(jj1)
                 di0zs(jj)=di0zs(jj1)
                 dip0zs(jj)=dip0zs(jj1)
                 do ib2=1,6
                   do ib3=1,6
                     tasau(jj,ib2,ib3)=tasau(jj1,ib2,ib3)
                   end do
                 end do
               end do
+if fluka
               if (fluka_enable) call fluka_lostpart(lnapx, j) ! Inform fluka
+ei
             endif
             lnapx=lnapx-1
           endif
         end do
         napx=lnapx
      endif

+if fluka
      napxo = napx
+ei

      if(napx.eq.0) then
        write(lout,*)
        write(lout,*)
        write(lout,*) '************************'
        write(lout,*) '** ALL PARTICLES LOST **'
        write(lout,*) '**   PROGRAM STOPS    **'
        write(lout,*) '************************'
        write(lout,*)
        write(lout,*)
+if fluka
!skip postpr
        nthinerr = 3000
+ei
+if .not.fluka
        nthinerr = 3001
        nnuml=numl
+ei
        return
      end if

end subroutine lostpart

subroutine roffpos( x, y, xnew, ynew, tlt, xoff, yoff )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     centre/rotate position of particles in case of offcentered/tilted 
!        aperture types
!     always in main code
!  
!     input parameters:
!        x : horizontal particle position [mm]
!        y : vertical   particle position [mm]
!        tlt:  tilt angle of the aperture profile [rad]
!        xoff: horizontal aperture offset [mm]
!        yoff: vertical   aperture offset [mm]
!
!     output parameters:
!        xnew : offcentered/tilted horizontal particle position [mm]
!        ynew : offcentered/tilted vertical   particle position [mm]
!
!-----------------------------------------------------------------------
!
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

!     parameters
      real(kind=fPrec) x, y, xnew, ynew, tlt, xoff, yoff

!     temporary variables
      real(kind=fPrec) theta, radio, xtmp, ytmp, ttmp

      xtmp = x+xoff
      ytmp = y+yoff
      theta = atan2_mb(ytmp, xtmp)
      radio = sqrt(xtmp**two + ytmp**two)
      ttmp = theta-tlt
      xnew = radio * cos_mb(ttmp)
      ynew = radio * sin_mb(ttmp)
      return
end subroutine roffpos

logical function checkRE( x, y, apex, apey )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against REctangle aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      implicit none
!     parameters
      real(kind=fPrec) x, y, apex, apey
      checkRE = ( abs(x).gt.apex ).or.( abs(y).gt.apey )
      return
end function

logical function checkEL( x, y, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against ELlipse aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

!     parameters
      real(kind=fPrec) x, y, apxx, apyy, apxy

      checkEL = x**two*apyy+y**two*apxx .gt. apxy
      return
end function checkEL

logical function checkRL( x, y, apex, apey, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against Rect-Ellipse aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      implicit none

!     parameters
      real(kind=fPrec) x, y, apex, apey, apxx, apyy, apxy

!     temporary variables
      logical checkRE, checkEL

      checkRL = checkRE( x, y, apex, apey ) .or.                        &
     &          checkEL( x, y, apxx, apyy, apxy )
      return
end function checkRL

logical function checkOC( x, y, ap1, ap2, c1, c2, c3 )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against OCtagon aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      implicit none

!     parameters
      real(kind=fPrec) x, y, ap1, ap2, c1, c2, c3

!     checkOC=x.gt.ap1 .or. y.gt.ap2 .or.(ap2*tan_mb(pi/two-ap4)-ap1)*(y-ap1*tan_mb(ap3))-(ap2-ap1*tan_mb(ap3))*(x-ap1).lt.zero

!     0:  x.gt.ap1 .or. y.gt.ap2 .or.
!     c1: (ap2*tan_mb(pi/two-ap4)-ap1)*
!     c2: (y-ap1*tan_mb(ap3))-
!     c3: (ap2-ap1*tan_mb(ap3))*(x-ap1).lt.zero
      checkOC = abs(x).gt.ap1 .or. abs(y).gt.ap2 .or. (c1*(y-c2) - c3*(x-ap1)).lt.zero
      return
end function checkOC

logical function checkRT( x, y, apex, apey, r, r2 )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 19-05-2014
!     check particle position against RaceTrack aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      implicit none

!     parameters
      real(kind=fPrec) x, y, apex, apey, r, r2

!     temporary variables
      logical checkRE

      checkRT = checkRE( x, y, apex+r, apey+r ) .or.                    &
     &          ( ( (abs(x)-apex)**2.+(abs(y)-apey)**2.).gt.r2 )
      return
end function checkRT

logical function checkCR( x, y, radius2 )
!-----------------------------------------------------------------------
!     check particle position against CiRcle aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      implicit none

!     parameters
      real(kind=fPrec) x, y, radius2

      checkCR = (x**2 + y**2) .gt. radius2
      return
end function checkCR

subroutine contour_aperture_markers( itElUp, itElDw, lInsUp )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 20-12-2016
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use crcoall
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca comApeInfo

!     interface variables
      integer itElUp,itElDw
      logical lInsUp
!     run time variables
      integer iElUp, iElDw, ixApeUp, ixApeDw, jj, iuold
      logical lExtremes, lsame
      real(kind=fPrec) aPrec
!     precision on aperture parameters to be identical
      data aPrec / c1m6 / 

!     do not overwrite interface variables
      iElUp=itElUp
      iElDw=itElDw
!     handling extremes of lattice structure?
      lExtremes=iElUp.eq.iu.and.iElDw.eq.1

!     upstream marker 
      iuold=iu
      call contour_aperture_marker( iElUp, lInsUp  )
!     the addition of the upstream aperture marker may have
!        shifted by one the downstream entries
!     NB: if lExtremes, the upstream marker is the last entry
!         in the lattice structure! Hence, no other entry is shifted!
      if ( .not.lExtremes ) then
         if ( iu-iuold.ne.0 ) then
            iElDw=iElDw+(iu-iuold)
            write(lout,*) '...inserted upstream marker - downstream'    &
     &//' entries shifted by',iu-iuold
         else
            write(lout,*) '...no need to insert an upstream marker'
         end if
      end if

!     downstream marker 
      iuold=iu
      call contour_aperture_marker( iElDw, .false. )
!     the addition of the downstream aperture marker may have
!        shifted by one the downstream entries
      if ( iu-iuold.ne.0 ) then
!        NB: if lExtremes, the downstream entry is the first entry
!            in the lattice structure! Hence, if a new entry has been inserted,
!            the upstream entry (at the end of the lattice structure) is
!            shifted by 1
         if ( lExtremes ) then
            iElUp=iElUp+(iu-iuold)
         end if
         write(lout,*) '...inserted downstream marker - downstream'     &
     &//' entries shifted by',iu-iuold
      else
         write(lout,*) '...no need to insert a downstream marker'
      end if

      if ( lExtremes ) then
!        check that the aperture markers at the extremities of accelerator
!           lattice structure are the same
         ixApeUp=ic(iElUp)-nblo
         ixApeDw=ic(iElDw)-nblo
         lsame = ixApeDw.eq.ixApeUp.or.kape(ixApeDw).eq.kape(ixApeUp)
         if ( lsame ) then
            do jj=1,7
               lsame = lsame .and.                                      &
     &           abs(ape(jj,ixApeDw)-ape(jj,ixApeUp)).lt.aPrec
               if ( .not. lsame ) exit
            end do
         end if
         if ( .not.lsame ) then
            write(lout,*)' ERROR - different aperture markers'          &
     &//' at extremeties of accelerator lattice strucure'
            call dump_aperture_header( -1 )
            call dump_aperture_marker( -1, ixApeUp, iElUp )
            call dump_aperture_marker( -1, ixApeDw, iElDw )
            call prror(-1)
         end if 
      end if

      end subroutine contour_aperture_markers

      subroutine contour_aperture_marker( iEl, lInsUp )
!
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 20-12-2016
!     put an aperture marker at iEl
!     NB: it can be either a brand new entry in lattice sequence or
!         updating an existing one
!     interface variables:
!     - iEl: entry in lattice sequence to be checked
!     - lInsUp: if true, the new aperture marker is inserted upstream of
!       iEl
!     always in main code
!-----------------------------------------------------------------------

      use floatPrecision
      use numerical_constants

+if fluka
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka

+ei
      use crcoall
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum
+ca comApeInfo
!     interface variables
      integer iEl
      logical lInsUp
!     temporary variables
      integer i,ix,iSrcUp,iSrcDw,iApeUp,ixApeUp,iApeDw,ixApeDw,jj,      &
     & itmpape,iNew, ixNew,check_SE_unique,INEESE,INEELS,ixApeNewFrom,  &
     & ixEl
      real(kind=fPrec) tmpape(7), ddcum, sPrec, aPrec
      logical lconst,lApeUp,lApeDw,lAupDcum,lAdwDcum,lApe,lAss,lfit
      character(len=16) CrtApeName

!     precision on s-coordinates to be identical
      data sPrec / c1m7 / 
!     precision on aperture parameters to be identical
      data aPrec / c1m6 / 

!     echo of input parameters
      write(lout,*) ''
      write(lout,*)' CALL TO CONTOUR_APERTURE_MARKER...'

!     check upstream element
      ixEl=ic(iEl)-nblo
      if ( iEl.eq.iu ) then
!        end of lattice sequence: a marker might be needed
         if ( ixEl.le.0 ) then
            ix=INEESE()
            iu=INEELS( 0 )
            ic(iu)=ix+nblo
            iEl=iu
            ixEl=ix
            bez(ixEl)='e.latt.aper'
            write(lout,*) ' -> inserted empty marker at end of lattice'
         endif
      elseif ( iEl.eq.1 ) then
!        beginning of lattice sequence: a marker might be needed
         if ( ixEl.le.0 ) then
            ix=INEESE()
            iu=INEELS( 1 )
            ic(1)=ix+nblo
            iEl=1
            ixEl=ix
            bez(ixEl)='s.latt.aper'
            write(lout,*)' -> inserted empty marker at start of lattice'
+if fluka
         elseif ( fluka_type(ixEl).eq.FLUKA_ELEMENT.or.                 &
     &            fluka_type(ixEl).eq.FLUKA_ENTRY   ) then
!           A.Mereghetti
!           last modified: 18-01-2017
!           force aperture marker upstream of FLUKA_ENTRY
!           inserted in main code by the 'fluka' compilation flag
            ix=INEESE()
            iu=INEELS( 1 )
            ic(1)=ix+nblo
            iEl=1
            ixEl=ix
            bez(ixEl)='s.latt.aper'
           write(lout,*) ' -> inserted empty marker at start of lattice'&
     &//' since first entry is a FLUKA element'
+ei
         endif
      elseif ( ixEl.le.0 ) then
         write(lout,*) 'ERROR - lattice element at: i=',iEl
         write(lout,*) 'is NOT a SINGLE ELEMENT!'
         call prror(-1)
      endif
!     echo
      write(lout,*)' look for aperture markers closest to:'
      write(lout,*)' i=',iEl,' - ix=',ixEl,                             &
     &' - name: ',bez(ixEl), ' - s=',dcum(iEl)

!     candidate aperture marker
      if ( lInsUp ) then
         iNew=iEl-1
      else
         iNew=iEl
      end if
      ixNew=ic(iNew)-nblo
      if ( iEl.eq.iu ) then
!        end of lattice sequence
         iSrcUp=iNew
         iSrcDw=1
      else if ( iEl.eq.1 ) then
!        beginning of lattice sequence:
         iSrcUp=iu
         iSrcDw=iEl
      else
         iSrcUp=iNew
         iSrcDw=iEl
      end if

!     - get closest upstream aperture marker
!       NB: no risk of overflow, as first/last element in lattice
!           sequence should be aperture markers (and the first
!           call of this function is meant to verify this assumption)
      iApeUp=-1
      ixApeUp=-1
      lApeUp=.false.
      do i=iSrcUp,1,-1
        ix=ic(i)-nblo
        if(ix.gt.0) then
!         SINGLE ELEMENT 
+if fluka
!         inserted in main code by the 'fluka' compilation flag
!         aperture markers should not coincide with a FLUKA element
          if ( kape(ix).ne.0.and.fluka_type(ix).eq.FLUKA_NONE ) then
+ei
+if .not.fluka
          if ( kape(ix).ne.0 ) then
+ei
             iApeUp=i
             ixApeUp=ix
             exit
          endif
        endif
      enddo
      if ( iApeUp.eq.-1 .and. ixApeUp.eq.-1 ) then
         write(lout,*)' ERROR - could not find upstream marker'
         call prror(-1)
      end if
!     - get closest downstream aperture marker
!       NB: no risk of overflow, as first/last element in lattice
!           sequence should be aperture markers (and the first
!           call of this function is meant to verify this assumption)
      iApeDw=-1
      ixApeDw=-1
      lApeDw=.false.
      do i=iSrcDw,iu
        ix=ic(i)-nblo
        if(ix.gt.0) then
!         SINGLE ELEMENT 
+if fluka
!         inserted in main code by the 'fluka' compilation flag
!         aperture markers should not coincide with a FLUKA element
          if ( kape(ix).ne.0.and.fluka_type(ix).eq.FLUKA_NONE ) then
+ei
+if .not.fluka
          if ( kape(ix).ne.0 ) then
+ei
             iApeDw=i
             ixApeDw=ix
             exit
          endif
        endif
      enddo
      if ( iApeDw.eq.-1 .and. ixApeDw.eq.-1 ) then
         write(lout,*)' ERROR - could not find downstream marker'
         call prror(-1)
      end if
!     - echo found apertures
      call dump_aperture_header( -1 )
      call dump_aperture_marker( -1, ixApeUp, iApeUp )
      call dump_aperture_marker( -1, ixApeDw, iApeDw )
!     - checks:
!       . iNew is iApeUp
      lApeUp=iApeUp.eq.iNew.and.ixApeUp.eq.ixNew
!       . iNew is at the same s as iApeUp (inlcuding ring overvlow)
      lAupDcum=abs(dcum(iNew)-dcum(iApeUp)).lt.sPrec.or.                &
     &         abs(dcum(iNew)-dcum(iApeUp)-tlen).lt.sPrec
!       . iNew is iApeDw
      lApeDw=iApeDw.eq.iNew.and.ixApeDw.eq.ixNew
!       . iNew is at the same s as ApeDw (inlcuding ring overvlow)
      lAdwDcum=abs(dcum(iNew)-dcum(iApeDw)).lt.sPrec.or.                &
     &         abs(dcum(iNew)-dcum(iApeDw)-tlen).lt.sPrec
!       . constant aperture?
      lconst = ixApeDw.eq.ixApeUp.or.kape(ixApeDw).eq.kape(ixApeUp)
      if ( lconst ) then
         do jj=1,7
            lconst = lconst .and.                                       &
     &           abs(ape(jj,ixApeDw)-ape(jj,ixApeUp)).lt.aPrec
            if ( .not. lconst ) exit
         end do
      end if
!       . can iNew be assigned an aperture marker?
!         ie is it a single element and is it used anywhere else?
      lApe=lApeUp.or.lApeDw
      lAss=ixNew.gt.0.and.check_SE_unique(iNew,ixNew).eq.-1

!     some action is needed
      if ( .not.lApe ) then
!        . iNew must be assigned an aperture
         ixApeNewFrom=-1
         lfit=.false.
         itmpape=0
         do jj=1,7
            tmpape(jj)=c1e3
         end do
!        . aperture profile
         if ( lconst.or.lAupDcum ) then
!           constant aperture or upstream aperture marker at the same s-location 
!             -> it is wise to use the upstream aperture
            ixApeNewFrom=ixApeUp
         elseif ( lAdwDcum ) then
!           same s-location as the closest downstream aperture marker
!             -> it is wise to use it!
            ixApeNewFrom=ixApeDw
         else
!           varying aperture -> we need to interpolate
            call interp_aperture( iApeUp,ixApeUp, iApeDw,ixApeDw,       &
     &                            itmpape,tmpape, dcum(iNew) )
            lfit=.true.
         endif
!        . aperture entry
         if ( .not.lAss ) then
!           ixNew cannot be assigned an aperture marker: we have to insert
!                a new entry in the lattice sequence
            if ( lfit ) then
               ixNew=INEESE()
               bez(ixNew)=CrtApeName()
            end if
            iNew=iNew+1
            iu=INEELS( iNew )
         end if
!        . assign aperture profile
         if ( lAss.or.lfit ) then
!           aperture model must be copied
            call copy_aperture( ixNew,ixApeNewFrom,itmpape,tmpape )
            ic(iNew)=ixNew+nblo
         elseif ( ixApeNewFrom.gt.-1 ) then
!           an existing aperture model can be assigned
            ic(iNew)=ixApeNewFrom+nblo
         else
!           this should never happen
            write(lout,*)' ERROR in aperture auto assignment.'
            call prror(-1)
         end if
      end if

!     echo for checking
      write(lout,*) ' ...echo results of assignment:'
      call dump_aperture_header( -1 )
      call dump_aperture_marker( -1, ic(iNew)-nblo, iNew )

!     go home, man
      iEl=iNew
      return

 1982 format (a16,2(1x,a2),8(1x,f15.5))
      end subroutine contour_aperture_marker

      character(len=16) function CrtApeName()
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     Create Aperture Name
!     always in main code
!-----------------------------------------------------------------------
      implicit none
      integer iApe, ii
      data iApe / 0 /
      save iApe
      iApe=iApe+1
      write(CrtApeName, "(A10,I6)") "auto.aper.", iApe
      do ii=11,16
         if ( CrtApeName(ii:ii) .eq. ' ' ) CrtApeName(ii:ii)='0'
      enddo
      end function CrtApeName

      subroutine interp_aperture( iUp,ixUp, iDw,ixDw, oKApe,oApe, spos )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 30-11-2016
!     interpolate aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum
+ca comApeInfo

!     interface variables
      integer iUp, ixUp, iDw, ixDw, oKApe
      real(kind=fPrec) oApe(7), spos
!     temporary variables
      real(kind=fPrec) ddcum, mdcum
      integer jj

      if ( kape(ixDw).gt.4 ) then
!        force constant Racetrack or Octagon profile
         oKApe = kape(ixDw)
         do jj=1,7
            oApe(jj) = ape(jj,ixDw)
         end do
      elseif ( kape(ixUp).gt.4 ) then
!        force constant Racetrack or Octagon profile
         oKApe = kape(ixUp)
         do jj=1,7
            oApe(jj) = ape(jj,ixUp)
         end do
      else
!        force rectellipse aperture and interpolate
         oKApe = 4
         ddcum = spos-dcum(iUp)
         if ( ddcum.lt.zero ) ddcum=tlen+ddcum
         mdcum = dcum(iDw)-dcum(iUp)
         if ( mdcum.lt.zero ) mdcum=tlen+mdcum
! AM ->          write(*,*) ixUp,ixDw,spos,dcum(iUp),dcum(iDw),tlen,ddcum,mdcum
         do jj=1,7
            oApe(jj)=(ape(jj,ixDw)-ape(jj,ixUp))/mdcum*ddcum            &
     &               +ape(jj,ixUp)
! AM ->             write(*,*) jj,ape(jj,ixDw),ape(jj,ixUp)
         end do
      end if
      
      end subroutine interp_aperture

      character(len=2) function get_ape_type( tkape )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 08-12-2016
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      implicit none
+ca parpro
+ca comApeInfo
!     interface variables
      integer tkape
      if (tkape.eq.2) then
         get_ape_type=rect
      elseif (tkape.eq.3) then
         get_ape_type=elli
      elseif (tkape.eq.4) then
         get_ape_type=reel
      elseif (tkape.eq.5) then
         get_ape_type=octa
      elseif (tkape.eq.6) then
         get_ape_type=ratr
      endif
      return
      end function get_ape_type

      subroutine copy_aperture( ixApeTo, ixApeFrom, nKApe, nApe )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 02-12-2016
!     copy aperture, either from an existing one or from the one
!       received on the fly
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum
+ca comApeInfo

!     interface variables
      integer ixApeTo, ixApeFrom, nKApe
      real(kind=fPrec) nApe(7)
!     temporary variables
      integer jj

      if ( ixApeFrom.gt.0 ) then
!        copy aperture marker from existing SINGLE ELEMENT
         kape(ixApeTo)=kape(ixApeFrom)
         do jj=1,7
            ape(jj,ixApeTo)=ape(jj,ixApeFrom)
         end do
      else
!        copy aperture marker from temporary one
         kape(ixApeTo)=nKApe
         do jj=1,7
            ape(jj,ixApeTo)=nApe(jj)
         end do
      end if
      
      end subroutine copy_aperture

      subroutine dump_aperture_model
!
!-----------------------------------------------------------------------
!     by P.Garcia Ortega, for the FLUKA Team, and A.Mereghetti
!     last modified: 08-12-2016
!     dump apertures 
!     always in main code
!-----------------------------------------------------------------------
!
      use floatPrecision
      use numerical_constants
      use crcoall
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca comApeInfo
+ca dbdcum

!     temporary variables
      integer i, ix
      logical lopen
+if backtrk
      integer iOld, ixOld, niter, oKApe,jj
      real(kind=fPrec) aprr,slos,step
      dimension aprr(7)
      character(len=2) aptype, get_ape_type
+ei

      write(lout,*)''
      write(lout,10340)
      write(lout,*)''
      write(lout,*)' DUMP OF APERTURE MODEL'
      write(lout,*)''
        
      inquire( unit=aperunit, opened=lopen )
      if ( .not.lopen ) then
         if ( aperunit.ne.0 ) then
            if ( aper_filename.eq.' ' ) then
               open( aperunit, form='formatted' )
               write(lout,*) 'DUMPED IN UNIT: ',aperunit
            else
               open( aperunit, file=aper_filename, form='formatted' )
               write(lout,*) 'DUMPED IN FILE: ',aper_filename
            endif
         endif
      endif

!     Header
      call dump_aperture_header( aperunit )

+if backtrk
      iOld=1
      ixOld=ic(iOld)-nblo
      if ( kape(ixOld).eq.0 ) then
         write(lout,*) ' ERROR - first element of lattice structure'    &
     &//' is not assigned any aperture type'
         call prror(-1)
      else
         call dump_aperture_marker( aperunit, ixOld, iOld )
      endif
+ei

      do i=2,iu
        ix=ic(i)-nblo
        if(ix.gt.0) then
!         SINGLE ELEMENT 
          if ( kape(ix) .ne. 0 ) then
+if .not.backtrk
            call dump_aperture_marker( aperunit, ix, i )
+ei
+if backtrk

            !Number of iterations 
! AM ->             write(*,*) 'i,ix,kape(ix):',i,ix,kape(ix)
            if ( (dcum(i)-dcum(iOld)).gt.zero) then
               niter = nint((dcum(i)-dcum(iOld))/bktpre+1)
! AM ->                write(*,*) 'niter:',niter
               do jj=1,niter
! AM ->                   write(*,*) 'dcum(iOld),dcum(i),bktpre,jj:',
! AM ->      & dcum(iOld),dcum(i),bktpre,jj
                  slos = int(dcum(iOld)/bktpre+jj)*bktpre
! AM ->                   write(*,*) 'slos:',slos
                  step = (slos-dcum(iOld))/(dcum(i)-dcum(iOld))
! AM ->                   write(*,*) 'step:',step
                  if ( step.lt.zero .or. step.gt.one ) exit
                  call interp_aperture(iOld,ixOld,i,ix,oKApe,aprr,slos)
! AM ->             write(*,*) iOld,ixOld,i,ix,oKApe, aprr(1),
! AM ->      &aprr(2),aprr(3),aprr(4),aprr(5),aprr(6),aprr(7),slos
                  aptype=get_ape_type( oKApe )
! AM ->                   write(*,*) aptype
                  call dump_aperture( aperunit, bez(ix), aptype, slos,  &
     & aprr )
               end do
            end if
! AM ->             write(*,*) 'done'
            iOld=i
            ixOld=ix
+ei
          endif
        endif
      enddo

 1984 format (a16,1x,a2,8(1x,f15.5))
10340 format(131('-'))

      end subroutine dump_aperture_model

      subroutine dumpMe
      use floatPrecision
      use numerical_constants
      use crcoall
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca comApeInfo
+ca dbdcum

!     temporary variables
      integer i, ix

      write(lout,*) 'dumpMe - start'
      do i=1,iu
         ix=ic(i)-nblo
         if ( ix.gt.0 ) then
            write(lout,*) i,bez(ix),dcum(i),kape(ix)
         else
            write(lout,*) i,bezb(ic(i)),dcum(i)
         endif
      enddo
      write(lout,*) 'dumpMe - end'

      end subroutine dumpMe

      subroutine dump_aperture( iunit, name, aptype, spos, ape )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 08-12-2016
!     dump single aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use crcoall
      implicit none


!     interface variables
      integer iunit
      character(len=2) aptype
      character(len=16) name
      real(kind=fPrec) ape(7)
      real(kind=fPrec) spos

!     dump info
      if( iunit.lt.0 ) then
         write(lout,1984) name, aptype, spos, ape(1), ape(2),           &
     &             ape(3), ape(4), ape(5), ape(6), ape(7)
      else
         write(iunit,1984) name, aptype, spos, ape(1),                  &
     & ape(2), ape(3), ape(4), ape(5), ape(6), ape(7)
      endif

      return
 1984 format (1x,a16,1x,a2,8(1x,f15.5))
      end subroutine dump_aperture

      subroutine dump_aperture_marker( iunit, ixEl, iEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 08-12-2016
!     dump single aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum
+ca comApeInfo

!     interface variables
      integer iunit, iEl, ixEl
!     temporary variables
      character(len=2) get_ape_type, aptype

      aptype=get_ape_type( kape(ixEl) )
      call dump_aperture( iunit, bez(ixEl), aptype, dcum(iEl),          &
     & ape(1:7,ixEl) )

      return
      end subroutine dump_aperture_marker

      subroutine dump_aperture_header( iunit )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 30-11-2016
!     dump single aperture
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use crcoall
      implicit none

!     temporary variables
      integer iunit

!     Header of dumped aperture markers
      if( iunit .lt. 0 ) then
         write(lout,1984) '#', 'name', 'aptype', 's[m]', 'aper1[mm]',   &
     & 'aper2[mm]', 'aper3[mm]', 'aper4[mm]', 'angle[rad]', 'xoff[mm]', &
     & 'yoff[mm]'
      else
         write(iunit,1984) '#', 'name', 'aptype', 's[m]', 'aper1[mm]',  &
     & 'aper2[mm]', 'aper3[mm]', 'aper4[mm]', 'angle[rad]', 'xoff[mm]', &
     & 'yoff[mm]'
      endif
      return
 1984 format (a1,a16,1x,a6,1x,a11,7(1x,a15))
      end subroutine dump_aperture_header

      subroutine dist1
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer ia,ib2,ib3,ie
      real(kind=fPrec) dam1
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 20 ia=1,napx,2
        if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.     &
     &(mod(nlostp(ia),2).ne.0)) then
          ie=ia+1
          dam(ia)=zero
          dam(ie)=zero
          xau(1,1)= xv(1,ia)
          xau(1,2)= yv(1,ia)
          xau(1,3)= xv(2,ia)
          xau(1,4)= yv(2,ia)
          xau(1,5)=sigmv(ia)
          xau(1,6)= dpsv(ia)
          xau(2,1)= xv(1,ie)
          xau(2,2)= yv(1,ie)
          xau(2,3)= xv(2,ie)
          xau(2,4)= yv(2,ie)
          xau(2,5)=sigmv(ie)
          xau(2,6)= dpsv(ie)
          cloau(1)= clo6v(1,ia)
          cloau(2)=clop6v(1,ia)
          cloau(3)= clo6v(2,ia)
          cloau(4)=clop6v(2,ia)
          cloau(5)= clo6v(3,ia)
          cloau(6)=clop6v(3,ia)
          di0au(1)= di0xs(ia)
          di0au(2)=dip0xs(ia)
          di0au(3)= di0zs(ia)
          di0au(4)=dip0zs(ia)

          do ib2=1,6
            do ib3=1,6
              tau(ib2,ib3)=tasau(ia,ib2,ib3)
            end do
          end do

          call distance(xau,cloau,di0au,tau,dam1)
          dam(ia)=dam1
          dam(ie)=dam1
        endif
   20 continue
      return
      end subroutine dist1

      subroutine write6(n)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      integer ia,ia2,id,ie,ig,n
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      id=0
      do 10 ia=1,napxo,2
        ig=ia+1
        ia2=ig/2
+if .not.cr
+if .not.bnlelens
        endfile (91-ia2,iostat=ierro)
        backspace (91-ia2,iostat=ierro)
+ei
+ei
!-- PARTICLES STABLE
        if(.not.pstop(ia).and..not.pstop(ig)) then
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),n
          id=id+1
          ie=id+1
          write(lout,10010)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          id=id+1

!-- FIRST PARTICLES LOST
        else if(pstop(ia).and..not.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)

!-- SECOND PARTICLES LOST
        else if(.not.pstop(ia).and.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejv(id),ejvl(ig)

!-- BOTH PARTICLES LOST
        else if(pstop(ia).and.pstop(ig)) then
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejvl(ia),ejvl(ig)
        endif
   10 continue
+if .not.cr
      if(ierro.ne.0) then
         write(lout,*) 'ERROR from write6: fort.12 has ',               &
     &        'corrupted output probably due to lost particles'
+if debug
!        call dumpbin(' write6',0,0)                                     !hr09
+ei
         call prror(-1)
      endif
+ei
      endfile (12,iostat=ierro)
      backspace (12,iostat=ierro)
+if cr
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
+ei
      return
10000 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10010 format(10x,f47.33)
      end subroutine write6


+dk tra_thck
subroutine trauthck(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use dynk, only : ldynk, dynk_isused, dynk_pretrack

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei

      use crcoall
      implicit none

      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      real(kind=fPrec) benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
      dimension nbeaux(nbb)
+if collimat
+ca database
+ei
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
+if collimat
      if (do_coll) then
         write(lout,*) "Error: in trauthck and do_coll is TRUE"
         write(lout,*) "Collimation is not supported for thick tracking"
         call prror(-1)
      endif
+ei

      do 5 i=1,npart
        nlostp(i)=i
   5  continue
      do 10 i=1,nblz
        ktrack(i)=0
        strack(i)=zero
        strackc(i)=zero
        stracks(i)=zero
   10 continue
+ca beams1
      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        !BLOC
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        !Non-linear/NOT BLOC
        goto 290
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
        kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        else if(kzz.eq.12) then
          !Disabled cavity; enabled cavities have kp=6 and are handled above
          ! Note: kz=-12 are transformed into +12 in daten after reading ENDE.
          ktrack(i)=31
          goto 290
        endif
+ca beams21
+ca beamcoo
+ca beamr1
     &goto 42
+ca beamr2
+ca beamr3o
+ca beams22
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4o
+ca beams23
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4o
            else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamcoo
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4o
+ca beams24
+ca wire
+ca elens
+ca acdip1
+ca crab1
+ca crab_mult
+ca trom30
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),   &
     &extalign(i,2),extalign(i,3)
        endif
        if(kzz.lt.0) goto 180
        goto(50,60,70,80,90,100,110,120,130,140,150,290,290,290,        &
     &       290,290,290,290,290,290,290,290,290,145,146),kzz
        ktrack(i)=31
        goto 290
   50   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=11
+ca stra01
        goto 290
   60   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=12
+ca stra02
        goto 290
   70   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=13
+ca stra03
        goto 290
   80   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=14
+ca stra04
        goto 290
   90   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=15
+ca stra05
        goto 290
  100   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=16
+ca stra06
        goto 290
  110   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=17
+ca stra07
        goto 290
  120   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=18
+ca stra08
        goto 290
  130   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=19
+ca stra09
        goto 290
  140   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=20
+ca stra10
        goto 290
!--DIPEDGE ELEMENT
  145   continue 
+ca stra2dpe
        ktrack(i)=55
        goto 290
!--solenoid
  146   continue 
+ca solenoid
        ktrack(i)=56
        goto 290
!--Multipole block (also in initialize_element)
  150   r0=ek(ix)
        nmz=nmu(ix)
        if(abs(r0).le.pieni.or.nmz.eq.0) then
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            if ( dynk_isused(i) ) then
              write(lout,*)                                             &
     &        "ERROR: Element of type 11 (bez=",bez(ix),                &
     &        ") is off in fort.2, but on in DYNK. Not implemented."
              call prror(-1)
            endif
            ktrack(i)=31
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=33
+ca stra11
            else
              ktrack(i)=35
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=37
+ca stra13
            else
              ktrack(i)=39
+ca stra14
            endif
          endif
        else
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=32
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=34
+ca stra11
            else
              ktrack(i)=36
+ca stra12
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=38
+ca stra13
            else
              ktrack(i)=40
+ca stra14
            endif
          endif
        endif
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
        if(mout2.eq.1) then
          benkcc=ed(ix)*benkc(irm(ix))
          r0a=one
          r000=r0*r00(irm(ix))
          do j=1,mmul
            fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
            fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
            r0a=r0a*r000
          end do

          write(9,'(a16)') bez(ix)
          write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
          write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)

          do j=1,20
            fake(1,j)=zero
            fake(2,j)=zero
          end do

        endif
        goto 290
        
        !Negative KZZ
  180   kzz=-kzz
        goto(190,200,210,220,230,240,250,260,270,280),kzz
        ktrack(i)=31
        goto 290
  190   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=21
+ca stra01
        goto 290
  200   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=22
+ca stra02
        goto 290
  210   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=23
+ca stra03
        goto 290
  220   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=24
+ca stra04
        goto 290
  230   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=25
+ca stra05
        goto 290
  240   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=26
+ca stra06
        goto 290
  250   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=27
+ca stra07
        goto 290
  260   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=28
+ca stra08
        goto 290
  270   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=29
+ca stra09
        goto 290
  280   if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=30
+ca stra10
  290 continue
      do 300 j=1,napx
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  300 continue
      nwri=nwr(3)
      if(nwri.eq.0) nwri=numl+numlr+1

!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     save original kicks
!     always in main code
      if (ldynk) call dynk_pretrack

      if(idp.eq.0.or.ition.eq.0) then
        write(lout,*) ''
        write(lout,*) 'Calling thck4d subroutine'
        write(lout,*) ''
        call thck4d(nthinerr)
      else
        hsy(3)=(c1m3*hsy(3))*real(ition,fPrec)                                 !hr01

        do jj=1,nele
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*                    &
     &real(itionc(jj),fPrec)     !hr01
        end do

        if(abs(phas).ge.pieni) then
          write(lout,*) ''
          write(lout,*) 'Calling thck6dua subroutine'
          write(lout,*) ''
          call thck6dua(nthinerr)
        else
          write(lout,*) ''
          write(lout,*) 'Calling thck6d subroutine'
          write(lout,*) ''
          call thck6d(nthinerr)
        endif
      endif
      return
end subroutine trauthck

subroutine thck4d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 4D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      use floatPrecision
      use physical_constants
      use mathlib_bouncer
      use numerical_constants
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, dynk_apply
      use dump, only : dump_linesFirst, dump_lines, ldumpfront
      
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei
      use postprocessing, only : writebin
      use crcoall
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve,puzve,r0,r2b,rb,rho2b,rkb,tkb,xbb,xlvj, &
     &xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) e0fo,e0o,xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1,crabamp,crabfreq
+ca wiretracktmp
      logical llost
+if time
      real(kind=fPrec) expt
+ei
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      logical recompute_linear_matrices
+ei

+ca dbdcum
+ca comApeInfo

      save
!-----------------------------------------------------------------------
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)
+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero

+if fluka

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      recompute_linear_matrices = .false.
+ei

+ca bnlin
!GRDRHIC
!GRD-042008
+ei

+if backtrk
+ca backtrkinit
+ei

+if fluka

!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK4D ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 490 n=numlcr,nnuml
+ei
+if .not.cr
      do 490 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

+if .not.fluka
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
          if ( ldynk ) then
             call dynk_apply(n)
          endif

          call dump_linesFirst(n)

          do 480 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
+if bpm
+ca bpmdata
+ei bpm
      
      if (ldumpfront) then
         write (lout,*)                                                 &
     & "DUMP/FRONT not yet supported on thick elements "//              &
     & "due to lack of test cases. Please contact developers!"
         call prror(-1)
!+ca dumplines
      endif
      
+if time
+ca timefct
+ei
            endif


+if fluka
!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 17-07-2013
!           is the current entry an instance of a FLUKA element?
!           inserted in main code by the 'fluka' compilation flag
            if (fluka_enable) then
              if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                      !      be SINGLE ELEMENTs
                if(fluka_type(ix).ne.FLUKA_NONE) then
                  if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                    call kernel_fluka_element( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 470
                  else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                    fluka_inside = .true.
                    call kernel_fluka_entrance( n, i, ix )
                    goto 475
                  else if(fluka_type(ix).eq.FLUKA_EXIT) then
                    fluka_inside = .false.
                    call kernel_fluka_exit( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 470
                  end if
                end if
              end if
              if(fluka_inside) then
                if(fluka_debug) then
                  write(lout,*) '[Fluka] Skipping lattice element at ',i
                  write(fluka_log_unit,*)                               &
     &'# Skipping lattice element at ', i
                end if
                goto 480
              end if
            endif
+ei

!----------count=43
            goto( 20,480,740,480,480,480,480,480,480,480,               &!1-10
     &            40, 60, 80,100,120,140,160,180,200,220,               &!11-20
     &           270,290,310,330,350,370,390,410,430,450,               &!21-30
     &           470,240,500,520,540,560,580,600,620,640,               &!31-40
     &           680,700,720,480,748,480,480,480,480,480,               &!41-50
     &           745,746,751,752,753,754,480,480,480,480,               &!51-60
     &           480,480,761),ktrack(i)
            goto 480
   20       do 30 j=1,napx
              puxve=xv(1,j)
              puzve=yv(1,j)
              xv(1,j)=bl1v(1,1,j,ix)*puxve+bl1v(2,1,j,ix)*puzve+        &!hr01
     &((real(idz1,fPrec)*bl1v(5,1,j,ix))*dpsv(j))*c1e3                         !hr01
              yv(1,j)=bl1v(3,1,j,ix)*puxve+bl1v(4,1,j,ix)*puzve+        &!hr01
     &((real(idz1,fPrec)*bl1v(6,1,j,ix))*dpsv(j))*c1e3                         !hr01
              puxve=xv(2,j)
              puzve=yv(2,j)
              xv(2,j)=bl1v(1,2,j,ix)*puxve+bl1v(2,2,j,ix)*puzve+        &!hr01
     &((real(idz2,fPrec)*bl1v(5,2,j,ix))*dpsv(j))*c1e3                         !hr01
              yv(2,j)=bl1v(3,2,j,ix)*puxve+bl1v(4,2,j,ix)*puzve+        &!hr01
     &((real(idz2,fPrec)*bl1v(6,2,j,ix))*dpsv(j))*c1e3                         !hr01
   30       continue
            goto 480

+if backtrk
+ca backtrksave
+ei

!--HORIZONTAL DIPOLE
   40       do 50 j=1,napx
+ca kickv01h
   50       continue
            goto 470
!--NORMAL QUADRUPOLE
   60       do 70 j=1,napx
+ca alignva
+ca kickvxxh
   70       continue
            goto 470
!--NORMAL SEXTUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
   90       continue
            goto 470
!--NORMAL OCTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  110       continue
            goto 470
!--NORMAL DECAPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 470
!--NORMAL DODECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 470
!--NORMAL 14-POLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 470
!--NORMAL 16-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 470
!--NORMAL 18-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 470
!--NORMAL 20-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 470
  500     continue
          do 510 j=1,napx
+ca alignvb
+ca mul4v01
  510     continue
          goto 470
  520     continue
          do 530 j=1,napx
+ca alignvb
+ca mul4v01
  530     continue
          goto 240
  540     continue
          do 550 j=1,napx
+ca mul4v02
  550     continue
          goto 470
  560     continue
          do 570 j=1,napx
+ca mul4v02
  570     continue
          goto 240
  580     continue
          do 590 j=1,napx
+ca alignvb
+ca mul4v03
  590     continue
          goto 470
  600     continue
          do 610 j=1,napx
+ca alignvb
+ca mul4v03
  610     continue
          goto 240
  620     continue
          do 630 j=1,napx
+ca mul4v04
  630     continue
          goto 470
  640     continue
          do 650 j=1,napx
+ca mul4v04
  650     continue
  240       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 260 j=1,napx
+ca alignvb
+ca mul4v05
                do 250 k=3,nmz
+ca mul4v06
  250           continue
+ca mul4v07
  260       continue
          else
            do 265 j=1,napx
+ca mul4v08
  265       continue
          endif
            goto 470
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  270       do 280 j=1,napx
+ca kickv01v
  280       continue
            goto 470
!--SKEW QUADRUPOLE
  290       do 300 j=1,napx
+ca alignva
+ca kickvxxv
  300       continue
            goto 470
!--SKEW SEXTUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  320       continue
            goto 470
!--SKEW OCTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  340       continue
            goto 470
!--SKEW DECAPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 470
!--SKEW DODECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 470
!--SKEW 14-POLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 470
!--SKEW 16-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 470
!--SKEW 18-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 470
!--SKEW 20-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
          goto 470
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 470
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 470
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 470
  740     continue
+ca trom40
+ca trom42
          goto 470
  745     continue
          xory=1
+ca acdipkick
          goto 470
  746     continue
          xory=2
+ca acdipkick
          goto 470
  751     continue
          xory=1
+ca crabkick
          goto 470
  752     continue
          xory=2
+ca crabkick
          goto 470
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 470
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
          enddo
          goto 470
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 470

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 470

!----------------------------

  470     continue

+ca lostpart

+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         re-compute transport matrices of linear elements
!         inserted in main code by the 'fluka' compilation flag
          if ( recompute_linear_matrices ) then
!           after a FLUKA element: additional particles may have
!             been generated
            call envarsv(dpsv,oidpsv,rvv,ekv)
            recompute_linear_matrices = .false.
          elseif ( llost ) then
!           after any other element: no additional particles,
!              thus update only momentum-dependent matrix elements
            call synuthck
          else
            goto 475
          endif
!         recompute matrices of BLOCKs
          call blocksv
+ei
+if .not.fluka
  if(llost) then
    call synuthck
  end if
+ei

  475     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

  480     continue
          !call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
+if .not.fluka
          if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
      napxto = napxto + napx
+ei

  490 continue
      return
end subroutine thck4d

subroutine thck6d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 6D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      use floatPrecision
      use physical_constants
      use mathlib_bouncer
      use numerical_constants
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, dynk_apply
      
      use dump, only : dump_linesFirst, dump_lines, ldumpfront
      
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei
      use postprocessing, only : writebin
      use crcoall
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,rb,rho2b,  &
     &rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) e0fo,e0o,xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      real(kind=fPrec) expt
+ei
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
!GRDRHIC
!GRD-042008
+ca rhicelens
+ca bnlio
!GRDRHIC
!GRD-042008
+ei
+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      logical recompute_linear_matrices
+ei

+ca dbdcum
+ca comApeInfo

      save
+if debug
!-----------------------------------------------------------------------
!===================================================================
! Eric beginthck6dstart
!===================================================================
+ei
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      recompute_linear_matrices = .false.
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei

+if backtrk
+ca backtrkinit
+ei
+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

! Now the outer loop over turns
+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,numl)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 510 n=numlcr,nnuml
+ei
+if .not.cr
      do 510 n=1,numl
+ei
! To do a dump and abend
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

+if .not.fluka
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
          if ( ldynk ) then
             call dynk_apply(n)
          endif

          call dump_linesFirst(n)

+if debug
! Now comes the loop over elements do 500/501
          do 501 i=1,iu
+ei
+if .not.debug
          do 500 i=1,iu
+ei
+if bnlelens
+ca bnltwiss
+ei
+if debug
!===================================================================
!===================================================================
! Eric endthck6dstart
! Nothing should be changed in the rest of this loop
!===================================================================
!===================================================================
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
            end if

+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
         write (lout,*)                                                 &
     & "DUMP/FRONT not yet supported on thick elements "//              &
     & "due to lack of test cases. Please contact developers!"
         call prror(-1)
!+ca dumplines
      endif

+if time
+ca timefct
+ei

+if fluka

!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 17-07-2013
!           is the current entry an instance of a FLUKA element?
!           inserted in main code by the 'fluka' compilation flag
            if (fluka_enable) then
              if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                      !      be SINGLE ELEMENTs
                if(fluka_type(ix).ne.FLUKA_NONE) then
                  if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                    call kernel_fluka_element( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 490
                  else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                    fluka_inside = .true.
                    call kernel_fluka_entrance( n, i, ix )
                    goto 495
                  else if(fluka_type(ix).eq.FLUKA_EXIT) then
                    fluka_inside = .false.
                    call kernel_fluka_exit( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 490
                  end if
                end if
              end if
              if(fluka_inside) then
                if(fluka_debug) then
                  write(lout,*) '[Fluka] Skipping lattice element at ',i
                  write(fluka_log_unit,*)                               &
     &'# Skipping lattice element at ', i
                end if
                goto 500
              end if
            endif
+ei

+if debug
!     if (i.ge.673) then
!     call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
!     if (i.eq.676) stop
+ei
!----------count 44
!----------count 54! Eric
            goto( 20, 40,740,500,500,500,500,500,500,500,               &!1-10
     &            60, 80,100,120,140,160,180,200,220,240,               &!11-20
     &           290,310,330,350,370,390,410,430,450,470,               &!21-30
     &           490,260,520,540,560,580,600,620,640,660,               &!31-40
     &           680,700,720,730,748,500,500,500,500,500,               &!41-50
     &           745,746,751,752,753,754,500,500,500,500,               &!51-60
     &           500,500,761),ktrack(i)
            goto 500
   20       jmel=mel(ix)
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 20 j=1 991 before ',               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
            do jb=1,jmel
              jx=mtyp(ix,jb)
              do j=1,napx
+ca thcklin
              end do
            end do

+if backtrk
+ca backtrksave
+ei
            goto 500

   40       do j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
              if(kz(ix).eq.12) then
                ejv(j)=ejv(j)+ed(ix)*sin_mb(hsyc(ix)*sigmv(j)+phasc(ix))
              else
                ejv(j)=ejv(j)+hsy(1)*sin_mb(hsy(3)*sigmv(j))
              endif
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
              yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
            end do

            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 40 j=1 991 after  ',               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endif
+ei
+ei
+if cr
!       write(93,*) 'ERIC loop at 40 calling synuthck!!!'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
            call synuthck
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 40 j=1 991 after synuthck ',       &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
+ca kickv01h
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvxxh
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
+ca alignvb
+ca mul4v05
                do 270 k=3,nmz
+ca mul4v06
  270           continue
+ca mul4v07
  280       continue
          else
            do 275 j=1,napx
+ca mul4v08
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
+ca kickv01v
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvxxv
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 490
  720     continue
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 720 j=1 991 before ',              &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
+if bnlelens
+if debug
!     if (n.eq.991) then
!     write(99,*) 'element statement 720 j=1 991 after  ',              &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
          goto 490
  730     continue
+ca beam6d
          goto 490
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 490
  745     continue
          xory=1
+ca acdipkick
          goto 490
  746     continue
          xory=2
+ca acdipkick
          goto 490
  751     continue
          xory=1
+ca crabkick
          goto 490
  752     continue
          xory=2
+ca crabkick
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 490
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 490

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 490

!----------------------------

  490     continue

+ca lostpart
+if fluka
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         re-compute transport matrices of linear elements
!         inserted in main code by the 'fluka' compilation flag
          if ( recompute_linear_matrices ) then
!           after a FLUKA element: additional particles may have
!             been generated
            call envarsv(dpsv,oidpsv,rvv,ekv)
            recompute_linear_matrices = .false.
          elseif ( llost ) then
!           after any other element: no additional particles,
!              thus update only momentum-dependent matrix elements
            call synuthck
          endif
+ei
+if .not.fluka
  if(llost) then
    call synuthck
  end if
+ei

  495     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

+if debug
  500 continue
!     if (n.ge.990) then
!     write(99,*) 'after element i, ktrack ',i,ktrack(i),               &
!    &xv(1,1),xv(2,1),yv(1,1),yv(2,1),sigmv(1),ejv(1),ejfv(1),          &
!    &rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
  501     continue
+ei
+if .not.debug
  500     continue
+ei
+if debug
! End of loop over elements
!===================================================================
!===================================================================
! Eric beginthck6dend
!===================================================================
!===================================================================
+ei
          !call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
+if .not.fluka
          if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
      napxto = napxto + napx
+ei

  510 continue
+if debug
! end loop over turns
!===================================================================
!===================================================================
! Eric endthck6dend
!===================================================================
!===================================================================
+ei
      return
end subroutine thck6d

subroutine thck6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS  6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      use floatPrecision
      use physical_constants
      use mathlib_bouncer
      use numerical_constants
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, dynk_apply
      
      use dump, only : dump_linesFirst, dump_lines, ldumpfront
      
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
      use mod_fluka
+ei
      use postprocessing, only : writebin
      use crcoall
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,e0fo,e0o,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,  &
     &rb,rho2b,rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
+ca parpro
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      real(kind=fPrec) xv1j,xv2j
      real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
+ca wiretracktmp
      logical llost
+if time
      real(kind=fPrec) expt
+ei
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca beamdim
+if cr
+ca crco
+ei
      dimension dpsv3(npart)
+if bnlelens
+ca rhicelens
+ca bnlio
+ei
+ca comgetfields
+ca elensparam
+ca wireparam
+ca elenstracktmp

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      logical recompute_linear_matrices

!     A.Mereghetti, for the FLUKA Team
!     last modified: 12-01-2016
!     temporary integer variable, for updating ref part
!     inserted in main code by the 'fluka' compilation flag
      integer mtemp
+ei

+ca dbdcum
+ca comApeInfo

      save
!-----------------------------------------------------------------------
      nthinerr=0
      idz1=idz(1)
      idz2=idz(2)

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
      recompute_linear_matrices = .false.
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
      totals=zero
+ca bnlin
!GRDRHIC
!GRD-042008
+ei

+if backtrk
+ca backtrkinit
+ei
+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
      napxto = 0
+ei

+if cr
      if (restart) then
        call crstart
        write(93,*)                                                     &
     &'THCK6DUA ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
      endif
      nnuml=min((numlcr/numlmax+1)*numlmax,nnuml)
      write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
      if (nnuml.ne.numl) then
        do j=1,napx
          if (numxv(j).eq.numl) numxv(j)=nnuml
          if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
        enddo
      endif
      do 510 n=numlcr,nnuml
+ei
+if .not.cr
      do 510 n=1,numl
+ei
+if boinc
!       call boinc_sixtrack_progress(n,numl)
        call boinc_fraction_done(dble(n)/dble(numl))
        continue
!       call graphic_progress(n,numl)
+ei
          numx=n-1

+if .not.fluka
          if(n.le.nde(1)) nwri=nwr(1)
          if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
          if(n.gt.nde(2)) nwri=nwr(3)
          if(nwri.eq.0) nwri=numl+numlr+1
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
+ei

+if cr
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
          if(mod(numx,numlcp).eq.0) call callcrp()
          restart=.false.
+ei

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
          if ( ldynk ) then
             call dynk_apply(n)
          endif

          call dump_linesFirst(n)

          do 500 i=1,iu
+if bnlelens
+ca bnltwiss
+ei
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
+if bpm
+ca bpmdata
+ei bpm

      if (ldumpfront) then
         write (lout,*)                                                 &
     & "DUMP/FRONT not yet supported on thick elements "//              &
     & "due to lack of test cases. Please contact developers!"
         call prror(-1)
      endif

+if time
+ca timefct
+ei
            endif

+if fluka

!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 17-07-2013
!           is the current entry an instance of a FLUKA element?
!           inserted in main code by the 'fluka' compilation flag
            if (fluka_enable) then
              if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                      !      be SINGLE ELEMENTs
                if(fluka_type(ix).ne.FLUKA_NONE) then
                  if(fluka_type(ix).eq.FLUKA_ELEMENT) then
                    call kernel_fluka_element( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 490
                  else if(fluka_type(ix).eq.FLUKA_ENTRY) then
                    fluka_inside = .true.
                    call kernel_fluka_entrance( n, i, ix )
                    goto 495
                  else if(fluka_type(ix).eq.FLUKA_EXIT) then
                    fluka_inside = .false.
                    call kernel_fluka_exit( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
                    recompute_linear_matrices = .true.
+if backtrk
+ca backtrksave
+ei
                    goto 490
                  end if
                end if
              end if
              if(fluka_inside) then
                if(fluka_debug) then
                  write(lout,*) '[Fluka] Skipping lattice element at ',i
                  write(fluka_log_unit,*)                               &
     &'# Skipping lattice element at ', i
                end if
                goto 500
              end if
            endif

+ei

!----------count 56
            goto( 20, 40,740,500,500,500,500,500,500,500,               &!1-10
     &            60, 80,100,120,140,160,180,200,220,240,               &!11-20
     &           290,310,330,350,370,390,410,430,450,470,               &!21-30
     &           490,260,520,540,560,580,600,620,640,660,               &!31-40
     &           680,700,720,730,748,500,500,500,500,500,               &!41-50
     &           745,746,751,752,753,754,500,500,500,500,               &!51-60
     &           500,500,761),ktrack(i)
            goto 500
   20       jmel=mel(ix)
            do jb=1,jmel
              jx=mtyp(ix,jb)
              do j=1,napx
+ca thcklin
              end do
            end do

+if backtrk
+ca backtrksave
+ei

            goto 500
   40       e0o=e0
            e0fo=e0f
            call adia(n,e0f)

+if fluka
!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 18-01-2016
!           update energy/momentum of reference particle in mod_fluka
!              and synch magnetic rigidity with Fluka (for the time being,
!              consider only protons);
!           NB: adia(n,e0f) updates e0 first (contained in common 'syn')
!                 and then e0f
!           inserted in main code by the 'fluka' compilation flag
            if(fluka_enable) then
              write(*,*) '[Fluka] Updating ref particle'
              write(fluka_log_unit,*) '# Updating ref particle'
              mtemp = fluka_set_synch_part( e0, e0f, pma, 1 )
              if (mtemp .lt. 0) then
                write(*,*)'[Fluka] Error: failed to update ref particle'
                write(fluka_log_unit,*)'# failed to update ref particle'
                call prror(-1)
              end if
              write(*,*) '[Fluka] Updating ref particle successful;'
              write(fluka_log_unit,*)                                   &
     & '# Updating ref particle successful;'
            endif
+ei

            do j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01
              if(kz(ix).eq.12) then
                ejv(j)=ejv(j)+ed(ix)*sin_mb((hsyc(ix)*sigmv(j)+phas)+   &!hr01
     &                                      phasc(ix))
              else
                ejv(j)=ejv(j)+hsy(1)*sin_mb(hsy(3)*sigmv(j)+phas)
              endif
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
            if(sigmv(j).gt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01

              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
              yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                         !hr01
            end do

            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
+if cr
+if debug
!       write(93,*) 'ERIC Thck6dua calling synuthck!!!'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
+ei
            call synuthck
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
+ca kickv01h
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
+ca alignva
+ca kickvxxh
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxh
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxh
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxh
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
+ca alignvb
+ca mul4v01
+ca mul6v01
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
+ca alignvb
+ca mul4v02
+ca mul6v01
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
+ca alignvb
+ca mul4v03
+ca mul6v02
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
+ca alignvb
+ca mul4v04
+ca mul6v02
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
+ca alignvb
+ca mul4v05
                do 270 k=3,nmz
+ca mul4v06
  270           continue
+ca mul4v07
  280       continue
          else
            do 275 j=1,napx
+ca mul4v08
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
+ca kickv01v
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
+ca alignva
+ca kickvxxv
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
+ca alignva
+ca kickvho
+ca kickvxxv
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvxxv
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
+ca alignva
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvho
+ca kickvxxv
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
+ca beamco
+ca beamr1
     &goto 690
+ca beamr2
+ca beamr3
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beam12
+ca beama3
+ca beam13
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam11
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf1
+ca beama4
          endif
          goto 490
  720     continue
          if(ibtyp.eq.0) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beam22
+ca beama3
+ca beam23
+ca beama4
          else if(ibtyp.eq.1) then
+ca beam21
+ca beama1
+ca beamco
+ca beama2
+ca beama3
+ca beamwzf2
+ca beama4
          endif
          goto 490
  730     continue
+ca beam6d
          goto 490
  740     continue
+ca trom40
+ca trom41
+ca trom42
          goto 490
  745     continue
          xory=1
+ca acdipkick
          goto 490
  746     continue
          xory=2
+ca acdipkick
          goto 490
  751     continue
          xory=1
+ca crabkick
          goto 490
  752     continue
          xory=2
+ca crabkick
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
+ca alignva
+ca kickvdpe
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
+ca kickvso1
+ca kickvso2
          enddo
          goto 490
!--elens
  761      continue
         do j=1,napx
+ca kickelens
         enddo
         goto 490

!----------------------------

! Wire.

  748     continue
+ca wirekick
  750     continue
          goto 490

!----------------------------

  490     continue

+ca lostpart

+if fluka

!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         re-compute transport matrices of linear elements
!         inserted in main code by the 'fluka' compilation flag
          if ( recompute_linear_matrices ) then
!           after a FLUKA element: additional particles may have
!             been generated
            call envarsv(dpsv,oidpsv,rvv,ekv)
            recompute_linear_matrices = .false.
          elseif ( llost ) then
!           after any other element: no additional particles,
!              thus update only momentum-dependent matrix elements
            call synuthck
          endif
+ei
+if .not.fluka
  if(llost) then
    call synuthck
  end if
+ei

  495     continue

      if (.not. ldumpfront) then
         call dump_lines(n,i,ix)
      endif

  500     continue
          !call lostpart(nthinerr)
          if(nthinerr.ne.0) return
          if(ntwin.ne.2) call dist1
+if .not.fluka
          if(mod(n,nwr(4)).eq.0) call write6(n)
+ei

+if bnlelens
!GRDRHIC
!GRD-042008
      if (lhc.eq.9) then
+ca bnlout
      endif
!GRDRHIC
!GRD-042008
+ei

+if fluka
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
      napxto = napxto + napx
+ei
  510 continue
      return
end subroutine thck6dua

subroutine synuthck
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
+if datamods
      use bigmats
+ei
      use numerical_constants
      implicit none
      integer ih1,ih2,j,kz1,l
      real(kind=fPrec) fokm
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+if bnlelens
+ca rhicelens
+ei
      save
!---------------------------------------  SUBROUTINE 'ENVARS' IN-LINE
+if cr
+if debug
!       write(93,*) 'ERIC synuthck called!!!'
!       write(93,*) 'ERIC il= ',il
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
      sythckcr=.true.
+ei
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
+ca rvet1
   10 continue
      do 160 l=1,il
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
!       goto 160
!Eric
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
        if (kz1.eq.1) then
          goto 20
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
        elseif (kz1.eq.2.or.kz1.eq.5) then
   40     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.2) then
            ih1=1
            ih2=2
          else
!  RECTANGULAR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 50 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            fok1(j)=(tan_mb(fok(j)*half))/rho(j)
            si(j)=sin_mb(fok(j))
            co(j)=cos_mb(fok(j))
            al(2,ih1,j,l)=rho(j)*si(j)
      al(5,ih1,j,l)=((-one*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr01
      al(6,ih1,j,l)=((-one*dpsv(j))*((two*tan_mb(fok(j)*half))/dpsq(j)))&!hr01
     &*c1e3                                                              !hr01
            sm1(j)=cos_mb(fok(j))
            sm2(j)=sin_mb(fok(j))*rho(j)
            sm3(j)=-sin_mb(fok(j))/rho(j)
            sm12(j)=el(l)-sm1(j)*sm2(j)
            sm23(j)=sm2(j)*sm3(j)
         as3(j)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr01
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr01
            as4(j)=((-one*rvv(j))*sm23(j))/c2e3                          !hr01
            as6(j)=((-one*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3            !hr01
+if rvet
            as(1,ih1,j,l)=el(l)*rvet(j)-(c1e3*rvv(j))*((dpsv(j)**2/     &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j)))                     !hr01
+ei
+if .not.rvet
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
+ei
         as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))* &!hr01
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr01
            as(3,ih1,j,l)=as3(j)
            as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                    !hr01
            as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/(c4e3*rho(j)**2)+     &!hr01
     &as6(j)*fok1(j)**2+fok1(j)*as4(j)                                   !hr01
            as(6,ih1,j,l)=as6(j)
!--VERTIKAL
            g(j)=tan_mb(fok(j)*half)/rho(j)
            gl(j)=el(l)*g(j)
            al(1,ih2,j,l)=one-gl(j)
            al(3,ih2,j,l)=(-one*g(j))*(two-gl(j))                        !hr01
            al(4,ih2,j,l)=al(1,ih2,j,l)
            as6(j)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3                    !hr01
            as(4,ih2,j,l)=((-one*two)*as6(j))*fok1(j)                    !hr01
            as(5,ih2,j,l)=(as6(j)*fok1(j))*fok1(j)                       !hr01
            as(6,ih2,j,l)=as6(j)
   50     continue
          goto 160
        elseif (kz1.eq.4.or.kz1.eq.6) then
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.4) then
            ih1=1
            ih2=2
          else
!  SECTOR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 70 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            si(j)=sin_mb(fok(j))
            co(j)=cos_mb(fok(j))
            rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                         !hr01
            siq(j)=si(j)/dpsq(j)
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=rho(j)*si(j)
            al(3,ih1,j,l)=(-one*si(j))/rho(j)                            !hr01
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-one*dpsv(j))*rhoc(j))*c1e3                  !hr01
            al(6,ih1,j,l)=((-one*dpsv(j))*siq(j))*c1e3                   !hr01
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
            as(1,ih1,j,l)=el(l)*rvet(j)-(c1e3*rvv(j))*((dpsv(j)**2/     &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l)))              !hr01
+ei
+if .not.rvet
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
+ei
      as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/(two*rho(j)*dpsq(j)))*      &!hr01
     &sm12(j)-dpd(j)*siq(j))                                             !hr01
      as(3,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*    &!hr01
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr01
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr01
            as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/((c4e3*rho(j))*rho(j)) !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr01
     &c4e3
!--VERTIKAL
            as(6,ih2,j,l)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3             !hr01
   70     continue
          goto 160
        elseif (kz1.eq.3) then
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
            fok(j)=ekv(j,l)*oidpsv(j)
            aek(j)=abs(fok(j))
            hi(j)=sqrt(aek(j))
            fi(j)=el(l)*hi(j)
            if(fok(j).le.zero) then
              al(1,1,j,l)=cos_mb(fi(j))
              hi1(j)=sin_mb(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hi1(j)/hi(j)
              endif
              al(3,1,j,l)=-hi1(j)*hi(j)
              al(4,1,j,l)=al(1,1,j,l)
+if rvet
              as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
+ei
              as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
           as(5,1,j,l)=(((-one*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
       as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3  !hr01
!--DEFOCUSSING
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,2,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hs(j)/hi(j)
              endif
              al(3,2,j,l)=hs(j)*hi(j)
              al(4,2,j,l)=hc(j)
              as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
              as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr01
            else
              al(1,2,j,l)=cos_mb(fi(j))
              hi1(j)=sin_mb(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hi1(j)/hi(j)
              endif
              al(3,2,j,l)=(-one*hi1(j))*hi(j)                            !hr01
              al(4,2,j,l)=al(1,2,j,l)
+if rvet
              as(1,2,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
+ei
              as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
           as(5,2,j,l)=(((-one*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3 !hr01
!--DEFOCUSSING
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,1,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hs(j)/hi(j)
              endif
              al(3,1,j,l)=hs(j)*hi(j)
              al(4,1,j,l)=hc(j)
              as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
              as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3 !hr01
            endif
   90     continue
          goto 160
        elseif (kz1.eq.7.or.kz1.eq.8) then
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100     if(kz1.eq.7) then
            do 110 j=1,napx
              fokqv(j)=ekv(j,l)
  110       continue
            ih1=1
            ih2=2
          else
!  COMBINED FUNCTION MAGNET VERTICAL
            do 120 j=1,napx
              fokqv(j)=-ekv(j,l)
  120       continue
            ih1=2
            ih2=1
          endif
          do 130 j=1,napx
            wf(j)=ed(l)/dpsq(j)
            fok(j)=fokqv(j)/dpd(j)-wf(j)**2                              !hr01
            afok(j)=abs(fok(j))
            hi(j)=sqrt(afok(j))
            fi(j)=hi(j)*el(l)
            if(afok(j).le.pieni) then
              as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                     !hr01
              as(6,2,j,l)=as(6,1,j,l)
+if rvet
              as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
              as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
+ei
            endif
            if(fok(j).lt.(-one*pieni)) then                              !hr06
              si(j)=sin_mb(fi(j))
              co(j)=cos_mb(fi(j))
              wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                      !hr01
              al(1,ih1,j,l)=co(j)
              al(2,ih1,j,l)=si(j)/hi(j)
              al(3,ih1,j,l)=(-one*si(j))*hi(j)                           !hr01
              al(4,ih1,j,l)=co(j)
              al(5,ih1,j,l)=((-one*wfa(j))*dpsv(j))*c1e3                 !hr01
              al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
              as(1,ih1,j,l)=el(l)*rvet(j)-(((c1e3*rvv(j))*((dpsv(j)**2/ &!hr01
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/           &!hr01
     &afok(j))*wf(j)**2                                                  !hr01
+ei
+if .not.rvet
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                                &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3    !hr06
+ei
           as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=(-one*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr01
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr01
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr01
              as(5,ih1,j,l)=(((-one*rvv(j))*sm12(j))*afok(j))/c4e3       !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih2,j,l)=hc(j)
              if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
              al(3,ih2,j,l)=hs(j)*hi(j)
              al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr01
            as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
!--DEFOCUSSING
            if(fok(j).gt.pieni) then
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih1,j,l)=hc(j)
              al(2,ih1,j,l)=hs(j)/hi(j)
              al(3,ih1,j,l)=hs(j)*hi(j)
              al(4,ih1,j,l)=hc(j)
              wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                      !hr01
              al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                       !hr01
              al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
+if rvet
              as(1,ih1,j,l)=el(l)*rvet(j)+(((c1e3*rvv(j))*((dpsv(j)**2/ &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/           &!hr06
     &afok(j))*wf(j)**2                                                  !hr06
+ei
+if .not.rvet
              as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*      &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*  &!hr06
     &(one-rvv(j)))*c1e3                                                 !hr06
+ei
           as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))* ed(l))  &!hr01
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr01
              as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                 !hr01
              as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3              !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              si(j)=sin_mb(fi(j))
              co(j)=cos_mb(fi(j))
              al(1,ih2,j,l)=co(j)
              al(2,ih2,j,l)=si(j)/hi(j)
              al(3,ih2,j,l)=(-one*si(j))*hi(j)                           !hr01
              al(4,ih2,j,l)=co(j)
        as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3 !hr01
      as(5,ih2,j,l)=(((-one*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr01
     &*aek(j))/c4e3                                                      !hr01
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
  130     continue
          goto 160
        elseif (kz1.eq.9) then
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140     do 150 j=1,napx
            rhoi(j)=ed(l)/dpsq(j)
            fok(j)=rhoi(j)*tan_mb((el(l)*rhoi(j))*half)                  !hr01
            al(3,1,j,l)=fok(j)
            al(3,2,j,l)=-fok(j)
  150     continue
          goto 160
        else
!Eric
! Is really an error but old code went to 160
          goto 160
        endif
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                         !hr01
          as(6,2,j,l)=as(6,1,j,l)
+if rvet
          as(1,1,j,l)=el(l)*rvet(j)
+ei
+if .not.rvet
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr01
+ei
   30   continue
  160 continue
!---------------------------------------  END OF 'ENVARS' (2)
      return
      end subroutine synuthck

+dk envarsv
      subroutine envarsv(dpsv,oidpsv,rvv,ekv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!  CAUTION:
!          A SPECIAL VERSION FOR VECTORIZATION - AUGUST   1994
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei

      implicit none
      integer ih1,ih2,j,kz1,l,l1,l2
      real(kind=fPrec) aek,afok,as3,as4,as6,co,dpd,dpsq,dpsv,ekv,fi,    &
     &fok,fok1,fokm,fokqv,g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,rho,rhoc,rhoi, &
     &rvv,si,siq,sm1,sm12,sm2,sm23,sm3,wf,wfa,wfhi
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+if bnlelens
+ca rhicelens
+ei
!-----------------------------------------------------------------------
      save
!-----------------------------------------------------------------------
      dimension ekv(npart,nele),fokqv(npart),dpsv(npart)
      dimension rvv(npart),oidpsv(npart)
      dimension dpd(npart),dpsq(npart),fok(npart),rho(npart)
      dimension fok1(npart),si(npart),co(npart),g(npart),gl(npart)
      dimension sm1(npart),sm2(npart),sm3(npart),sm12(npart)
      dimension as3(npart),as4(npart),as6(npart),sm23(npart)
      dimension rhoc(npart),siq(npart),aek(npart),afok(npart)
      dimension hp(npart),hm(npart),hc(npart),hs(npart),wf(npart)
      dimension wfa(npart),wfhi(npart),rhoi(npart)
      dimension hi(npart),fi(npart),hi1(npart)
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
   10 continue
      do 160 l=1,il
        do l1=1,6
          do j=1,napx
            do l2=1,2
              al(l1,l2,j,l)=zero
              as(l1,l2,j,l)=zero
            enddo
          enddo
        enddo
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 80
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 40
        if (kz1.eq.6) goto 60
        if (kz1.eq.7) goto 100
        if (kz1.eq.8) goto 100
        if (kz1.eq.9) goto 140
        goto 160
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          al(1,1,j,l)=one
          al(1,2,j,l)=one
          al(2,1,j,l)=el(l)
          al(2,2,j,l)=el(l)
          al(3,1,j,l)=zero
          al(3,2,j,l)=zero
          al(4,1,j,l)=one
          al(4,2,j,l)=one
          as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                         !hr06
          as(6,2,j,l)=as(6,1,j,l)
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr06
   30   continue
        goto 160
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.2) then
          ih1=1
          ih2=2
        else
!  RECTANGULAR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 50 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          fok1(j)=(tan_mb(fok(j)*half))/rho(j)
          si(j)=sin_mb(fok(j))
          co(j)=cos_mb(fok(j))
          al(1,ih1,j,l)=one
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=zero
          al(4,ih1,j,l)=one
      al(5,ih1,j,l)=((-one*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr06
      al(6,ih1,j,l)=((-one*dpsv(j))*((two*tan_mb(fok(j)*half))/dpsq(j)))&!hr06
     &*c1e3                                                              !hr06
          sm1(j)=cos_mb(fok(j))
          sm2(j)=sin_mb(fok(j))*rho(j)
          sm3(j)=(-one*sin_mb(fok(j)))/rho(j)                            !hr06
          sm12(j)=el(l)-sm1(j)*sm2(j)
          sm23(j)=sm2(j)*sm3(j)
         as3(j)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr06
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr06
          as4(j)=((-one*rvv(j))*sm23(j))/c2e3                            !hr06
          as6(j)=((-one*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3              !hr06
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/            &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
      as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*    &!hr06
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr06
          as(3,ih1,j,l)=as3(j)
          as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                      !hr06
          as(5,ih1,j,l)=(as6(j)*fok1(j)**2                              &!hr06
     &-(rvv(j)*sm12(j))/(c4e3*rho(j)**2))+fok1(j)*as4(j)                 !hr06
          as(6,ih1,j,l)=as6(j)
!--VERTIKAL
          g(j)=tan_mb(fok(j)*half)/rho(j)
          gl(j)=el(l)*g(j)
          al(1,ih2,j,l)=one-gl(j)
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=(-one*g(j))*(two-gl(j))                          !hr06
          al(4,ih2,j,l)=al(1,ih2,j,l)
          as6(j)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3                      !hr06
          as(4,ih2,j,l)=((-one*two)*as6(j))*fok1(j)                      !hr06
          as(5,ih2,j,l)=as6(j)*fok1(j)**2                                !hr06
          as(6,ih2,j,l)=as6(j)
   50   continue
        goto 160
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.4) then
          ih1=1
          ih2=2
        else
!  SECTOR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 70 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          si(j)=sin_mb(fok(j))
          co(j)=cos_mb(fok(j))
          rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                           !hr06
          siq(j)=si(j)/dpsq(j)
          al(1,ih1,j,l)=co(j)
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=(-one*si(j))/rho(j)                              !hr06
          al(4,ih1,j,l)=co(j)
          al(5,ih1,j,l)=((-one*dpsv(j))*rhoc(j))*c1e3                    !hr06
          al(6,ih1,j,l)=((-one*dpsv(j))*siq(j))*c1e3                     !hr06
          sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
          sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
       as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/           &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
       as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*   &!hr06
     &sm12(j)-dpd(j)*siq(j))                                             !hr06
         as(3,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))* &!hr06
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr06
          as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                     !hr06
          as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/(c4e3*rho(j)**2)         !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr06
     &c4e3                                                               !hr06
!--VERTIKAL
          al(1,ih2,j,l)=one
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=zero
          al(4,ih2,j,l)=one
          as(6,ih2,j,l)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3               !hr06
   70   continue
        goto 160
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
          fok(j)=ekv(j,l)*oidpsv(j)
          aek(j)=abs(fok(j))
          hi(j)=sqrt(aek(j))
          fi(j)=el(l)*hi(j)
          if(fok(j).le.zero) then
            al(1,1,j,l)=cos_mb(fi(j))
            hi1(j)=sin_mb(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hi1(j)/hi(j)
            endif
            al(3,1,j,l)=(-one*hi1(j))*hi(j)                              !hr06
            al(4,1,j,l)=al(1,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=(((-one*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,2,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hs(j)/hi(j)
            endif
            al(3,2,j,l)=hs(j)*hi(j)
            al(4,2,j,l)=hc(j)
            as(4,2,j,l)=((-one*rvv(j))*al(2,2,j,l)*al(3,2,j,l))/c2e3     !hr06
          as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
          else
            al(1,2,j,l)=cos_mb(fi(j))
            hi1(j)=sin_mb(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hi1(j)/hi(j)
            endif
            al(3,2,j,l)=(-one*hi1(j))*hi(j)                              !hr06
            al(4,2,j,l)=al(1,2,j,l)
            as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3   !hr06
          as(5,2,j,l)=(((-one*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,1,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hs(j)/hi(j)
            endif
            al(3,1,j,l)=hs(j)*hi(j)
            al(4,1,j,l)=hc(j)
            as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
          endif
   90   continue
        goto 160
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100   if(kz1.eq.7) then
          do 110 j=1,napx
            fokqv(j)=ekv(j,l)
  110     continue
          ih1=1
          ih2=2
        else
!  COMBINED FUNCTION MAGNET VERTICAL
          do 120 j=1,napx
            fokqv(j)=-one*ekv(j,l)                                       !hr06
  120     continue
          ih1=2
          ih2=1
        endif
        do 130 j=1,napx
          wf(j)=ed(l)/dpsq(j)
          fok(j)=fokqv(j)/dpd(j)-wf(j)**2                                !hr06
          afok(j)=abs(fok(j))
          hi(j)=sqrt(afok(j))
          fi(j)=hi(j)*el(l)
          if(afok(j).le.pieni) then
            al(1,1,j,l)=one
            al(1,2,j,l)=one
            al(2,1,j,l)=el(l)
            al(2,2,j,l)=el(l)
            al(3,1,j,l)=zero
            al(3,2,j,l)=zero
            al(4,1,j,l)=one
            al(4,2,j,l)=one
            as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                       !hr06
            as(6,2,j,l)=as(6,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
          endif
          if(fok(j).lt.(-one*pieni)) then                                !hr06
            si(j)=sin_mb(fi(j))
            co(j)=cos_mb(fi(j))
            wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                        !hr06
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=si(j)/hi(j)
            al(3,ih1,j,l)=(-one*si(j))*hi(j)                             !hr06
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-one*wfa(j))*dpsv(j))*c1e3                   !hr06
            al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                          &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3   !hr06
      as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*     &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
      as(3,ih1,j,l)=(-one*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr06
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr06
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=(((-one*rvv(j))*sm12(j))*afok(j))/c4e3         !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih2,j,l)=hc(j)
            al(2,ih2,j,l)=el(l)
            if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
            al(3,ih2,j,l)=hs(j)*hi(j)
            al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
          as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*  &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
!--DEFOCUSSING
          if(fok(j).gt.pieni) then
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih1,j,l)=hc(j)
            al(2,ih1,j,l)=hs(j)/hi(j)
            al(3,ih1,j,l)=hs(j)*hi(j)
            al(4,ih1,j,l)=hc(j)
            wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                        !hr06
            al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                         !hr06
            al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*sm12(j) &
     &+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*         &
     &(one-rvv(j)))*c1e3
          as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))* &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
        as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))*ed(l)) &!hr06
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr06
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3                !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            si(j)=sin_mb(fi(j))
            co(j)=cos_mb(fi(j))
            al(1,ih2,j,l)=co(j)
            al(2,ih2,j,l)=si(j)/hi(j)
            al(3,ih2,j,l)=(-one*si(j))*hi(j)                             !hr06
            al(4,ih2,j,l)=co(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
      as(5,ih2,j,l)=(((-one*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr06
     &*aek(j))/c4e3                                                      !hr06
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
  130   continue
        goto 160
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140   do 150 j=1,napx
          rhoi(j)=ed(l)/dpsq(j)
          fok(j)=rhoi(j)*tan_mb((el(l)*rhoi(j))*half)                    !hr06
          al(1,1,j,l)=one
          al(2,1,j,l)=zero
          al(3,1,j,l)=fok(j)
          al(4,1,j,l)=one
          al(1,2,j,l)=one
          al(2,2,j,l)=zero
          al(3,2,j,l)=-fok(j)
          al(4,2,j,l)=one
  150   continue
  160 continue
      return
      end

+dk mainda
      program mainda
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use, intrinsic :: iso_fortran_env, only : output_unit
      use crcoall
      implicit none
      integer i,iation,itiono,idate,im,imonth,itime,ix,izu,j,jj,k,kpz,  &
     &kzz,l,ll,ncorruo,ndim,nlino,nlinoo,nmz
      real(kind=fPrec) alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
     &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,clo0,clop0,&
     &dp0,dp10,e0f,eps,epsa,gam0s1,gam0s2,gam0s3,gam0x1,gam0x2,gam0x3,  &
     &gam0z1,gam0z2,gam0z3,phag,qw,qwc,r0,r0a,rv,                       &
+if rvet
     &rvet,                                                             &
+ei
     &tas,tas16,tas26,                                                  &
     &tas36,tas46,tas56,tas61,tas62,tas63,tas64,tas65
!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  DIFFERENTIAL ALGEBRA INCLUDED
!
!  ONE TURN MAP
!
!  NO POSTPROCESSING FORSEEN
!
!
!  DEVELOPPED FROM <RACETRACK> A. WRULICH (DESY 84-026)
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!-----------------------------------------------------------------------
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonc
+ca errout      
!-----------------------------------------------------------------------
      character(len=10) cmonth
      character(len=80) day,runtim
      character(len=8) cdate,ctime !Note: Keep in sync with maincr
                                   !DANGER: If the len changes, CRCHECK will break.
      dimension qw(2),qwc(3),clo0(2),clop0(2)
      dimension eps(2),epsa(2)
      dimension cmonth(12)
      dimension tas(6,6)
!-----------------------------------------------------------------------
      data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
     &'  April   ','   May    ','   June   ','   July   ',' August  ',  &
     &' September',' October  ',' November ',' December '/
!-----------------------------------------------------------------------
+if crlibm
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      real(kind=fPrec) fround
      real(kind=fPrec) round_near
      data lineno /0/
+ei
+ca version

      errout_status = 0         ! Set to nonzero before calling abend in case of error.
                                ! If prror is called, it will be set internally.
      
+if .not.cr
      lout=output_unit
+ei

+ca open
      write(lout,10000) version,moddate
      tlim=1e7
      call timest(tlim)
      time0=0.
      call timex(time0)
      idate=0
      itime=0
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      else
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)// &
     &'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(lout,'(a80)') runtim
      do 10 i=1,2
        eps(i)=zero
        epsa(i)=zero
        qw(i)=zero
        qwc(i)=zero
   10 continue
      qwc(3)=zero
      call comnul
      pi=four*atan_mb(one)
      pi2=pi*half
      pisqrt=sqrt(pi)
      rad=pi/c180e0                                                       !hr08
      call daten
      if(nord.le.0.or.nvar.le.0) call prror(91)
      if(ithick.eq.1) write(lout,10020)
      if(ithick.eq.0) write(lout,10030)
      if(ibidu.eq.2) then
        write(lout,10025)
        goto 550
      endif
      call ord
      call clorb(ded)

      do l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
      end do

      call clorb(zero)

      do l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
      end do

      amp00=amp(1)
      iation=abs(ition)
      call corrorb
      if(irmod2.eq.1) call rmod(dp1)
      if(iqmod.ne.0) call qmod0
      if(ichrom.eq.1.or.ichrom.eq.3) call chroma
      if(iskew.ne.0) call decoup
      dp0=dp1
!--FOR THE MOMENTUM-SCAN THE MOMENTUM IS THE SAME FOR BOTH PARTICLES
      exz(1,6)=dp1
      exz(2,6)=dp1
      if(ilin.eq.1.or.ilin.eq.3) then
        call linopt(dp1)
      endif
      if(isub.eq.1) call subre(dp1)
      if(ise.eq.1) call search(dp1)
      if(napx.eq.0) goto 160
!-----------------------------------------------------------------------
!--beam-beam element
      nlino=nlin
      nlin=0
      if(nbeam.ge.1) then
        do 135 i=1,nele
          if((kz(i).eq.20).or.(kz(i).eq.15)) then
            nlin=nlin+1
            if(nlin.gt.nele) call prror(81)
            bezl(nlin)=bez(i)
          endif
  135   continue
      endif
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
      izu=0
      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(kzz.eq.15) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        smizf(i)=zfz(izu)*ek(ix)
        smi(i)=sm(ix)+smizf(i)
        izu=izu+1
        xsi(i)=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zsi(i)=zpl(ix)+zfz(izu)*zrms(ix)
        if(mout2.eq.1) then
          if(kzz.eq.11) zfz(izu-2)=zero
          if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
          if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
          if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
          write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),             &
     &zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
        endif
        if(kzz.eq.11) then
          !Very similar to block "multini"
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one

          do k=1,nmz
            izu=izu+1
            aai(i,k)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a         !hr08
            izu=izu+1
            bbi(i,k)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a         !hr08
            r0a=r0a*r0
          end do

          izu=izu+2*mmul-2*nmz
        endif
   60 continue
      dp10=dp1
      dp1=zero
      if(ichrom.gt.1) then
        itiono=ition
        ition=0
        call chromda
        ition=itiono
      endif
      dp1=dp10
      if(idp.ne.1.or.iation.ne.1) iclo6=0
      if(iclo6.eq.1.or.iclo6.eq.2) then
+ca clor6
        do 70 i=1,6
          do 70 j=1,6
            tas(i,j)=tasm(i,j)
   70   continue
      else
        ncorruo=ncorru
        ncorru=1
        call clorb(zero)
        call betalf(zero,qw)
        call phasad(zero,qwc)
        call clorb(dp1)
        call betalf(dp1,qw)
        call phasad(dp1,qwc)
        ncorru=ncorruo
        dps(1)=dp1
        if(nvar2.le.5) then
          itiono=ition
          ition=0
        endif
+if debug
!       write(*,*) '3rd call qmodda multipole???'
+ei
        call qmodda(2,qwc)
+if debug 
!     call dumpbin('aqmodda',2,3)
!     call abend('after  qmodda 2 3                                 ')
+ei
        if(nvar2.le.5) ition=itiono
        if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)
        if(ilin.ge.2) then
          nlinoo=nlin
          nlin=nlino
          iqmodc=2
          call mydaini(1,2,5,2,5,1)
          ilinc=1
          call mydaini(2,2,5,2,5,1)
          nlin=nlinoo
        endif
        do 80 i=1,4
          do 80 j=1,4
   80   tas(i,j)=tasm(i,j)
      endif
  550 continue
      tas16=tas(1,6)*c1m3
      tas26=tas(2,6)*c1m3
      tas36=tas(3,6)*c1m3
      tas46=tas(4,6)*c1m3
      tas56=tas(5,6)*c1m3
      tas61=tas(6,1)*c1e3
      tas62=tas(6,2)*c1e3
      tas63=tas(6,3)*c1e3
      tas64=tas(6,4)*c1e3
      tas65=tas(6,5)*c1e3
      bet0(1)=tas(1,1)**2+tas(1,2)**2                                    !hr08
      bet0x2 =tas(1,3)**2+tas(1,4)**2                                    !hr08
      bet0x3 =tas(1,5)**2+tas16**2                                       !hr08
      gam0x1 =tas(2,1)**2+tas(2,2)**2                                    !hr08
      gam0x2 =tas(2,3)**2+tas(2,4)**2                                    !hr08
      gam0x3 =tas(2,5)**2+tas26**2                                       !hr08
      alf0(1)=-one*(tas(1,1)*tas(2,1)+tas(1,2)*tas(2,2))                 !hr08
      alf0x2 =-one*(tas(1,3)*tas(2,3)+tas(1,4)*tas(2,4))                 !hr08
      alf0x3 =-one*(tas(1,5)*tas(2,5)+tas16*tas26)                       !hr08
      bet0(2)=tas(3,3)**2+tas(3,4)**2                                    !hr08
      bet0z2 =tas(3,1)**2+tas(3,2)**2                                    !hr08
      bet0z3 =tas(3,5)**2+tas36**2                                       !hr08
      gam0z1 =tas(4,3)**2+tas(4,4)**2                                    !hr08
      gam0z2 =tas(4,1)**2+tas(4,2)**2                                    !hr08
      gam0z3 =tas(4,5)**2+tas46**2                                       !hr08
      alf0(2)=-one*(tas(3,3)*tas(4,3)+tas(3,4)*tas(4,4))                 !hr08
      alf0z2 =-one*(tas(3,1)*tas(4,1)+tas(3,2)*tas(4,2))                 !hr08
      alf0z3 =-one*(tas(3,5)*tas(4,5)+tas36*tas46)                       !hr08
      bet0s1 =tas(5,5)**2+tas56**2                                       !hr08
      bet0s2 =tas(5,1)**2+tas(5,2)**2                                    !hr08
      bet0s3 =tas(5,3)**2+tas(5,4)**2                                    !hr08
      gam0s1 =tas65**2+tas(6,6)**2                                       !hr08
      gam0s2 =tas61**2+tas62**2                                          !hr08
      gam0s3 =tas63**2+tas64**2                                          !hr08
      alf0s1 =-one*(tas(5,5)*tas65+tas56*tas(6,6))                       !hr08
      alf0s2 =-one*(tas(5,1)*tas61+tas(5,2)*tas62)                       !hr08
      alf0s3 =-one*(tas(5,3)*tas63+tas(5,4)*tas64)                       !hr08
      if(ierro.eq.0) goto 90
      write(lout,10200) dp1
      goto 160
   90 write(lout,10040)
      phag=(phas*c180e0)/pi                                               !hr08
      if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))             &
     &write(lout,10140)                                                 &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
      if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
        if(iclo6.eq.0) then
          write(lout,10120) phag,                                       &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
        else
          write(lout,10130) phag,                                       &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
        endif
      endif
      if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)                &
     &write(lout,10160) phag,                                           &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
      if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
        if(iclo6.eq.0) then
          write(lout,10180)                                             &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
        else
          write(lout,10190)                                             &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
        endif
      endif
      write(lout,10050) dp1
      call anfb(tas)
      if(iclo6.eq.2) then
        x(1,1) = x(1,1) + clo6(1)
        x(1,2) = x(1,2) + clo6(2)
        y(1,1) = y(1,1) + clop6(1)
        y(1,2) = y(1,2) + clop6(2)
        sigm(1) = sigm(1) + clo6(3)
        dps(1) = dps(1) + clop6(3)
        x(2,1) = x(2,1) + clo6(1)
        x(2,2) = x(2,2) + clo6(2)
        y(2,1) = y(2,1) + clop6(1)
        y(2,2) = y(2,2) + clop6(2)
        sigm(2) = sigm(2) + clo6(3)
        dps(2) = dps(2) + clop6(3)
      endif
      do 100 l=1,2
        epsa(l)=amp(l)**2/bet0(l)                                        !hr08
        eps(l)=epsa(l)*c1e6
        x(1,l)=x(1,l)+(clo(l)*real(idz(l),fPrec))*real(1-idfor,fPrec)                !hr08
        y(1,l)=y(1,l)+(clop(l)*real(idz(l),fPrec))*real(1-idfor,fPrec)               !hr08
  100 continue
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      if(iclo6.eq.0) then
        write(lout,10080) clo(1),clop(1),clo(2),clop(2),idz(1),idz(2),iver, idfor,iclo6,ition
      else
        write(lout,10090) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
      endif
      if(idfor.eq.1.and.iclo6.ne.2) goto 110
      ejf(1)=e0f*(one+dps(1))
      ejf(2)=e0f*(one+dps(2))
      ej(1)=sqrt(ejf(1)**2+pma**2)                                       !hr08
      ej(2)=sqrt(ejf(2)**2+pma**2)                                       !hr08
      goto 120
  110 ejf(1)=sqrt(ej(1)**2-pma**2)                                       !hr08
      ejf(2)=sqrt(ej(2)**2-pma**2)                                       !hr08
  120 write(lout,10060) x(1,1),y(1,1),x(1,2),y(1,2),sigm(1),dps(1), x(2,1),y(2,1),x(2,2),y(2,2),sigm(2),dps(2),e0,ej(1),ej(2)
      write(lout,10010) amp,epsa
      write(lout,10170)
      if(e0.gt.pieni) then
+ca rvet2
+if rvet
        if(ithick.eq.1) call envars(1,dps(1),rv,rvet)
+ei
+if .not.rvet
        if(ithick.eq.1) call envars(1,dps(1),rv)
+ei
      else
        call prror(79)
      endif
      if(numl.eq.0.or.numlr.ne.0) then
        write(lout,10070)
        goto 160
      endif
      if(nsix.eq.1.and.nvar2.eq.6) then
        nsix=2
        nvar=nvar-1
        nvar2=5
      endif
      ndim=nvar2/2
      call mydaini(3,nord,nvar,ndim,nvar2,nord1)
      if(inorm.eq.1) call daliesix
      if(icorr.eq.1) then
        if(nctype.eq.0) call coruord
        if(nctype.eq.1) call coruglo
      endif
      if(nsix.eq.2) then
        call umschr(19,18)
        nvar2=6
        nvar=nvar+1
        call mydaini(3,nord,nvar,ndim,nvar2,nord1)
      endif
  160 continue
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      call closeUnits

!     We're done in mainda, no error :)
+if cr
      call abend('                                                  ')
+ei
+if .not.cr
      stop
+ei
+if .not.tilt
10000 format(/t10,'SIXTRACK DA VERSION ',A8,                            &
     &'  --  (last change: ',A10,')'//)
+ei
+if tilt
10000 format(/t10,'SIXTRACK DA VERSION ',A8,' (with tilt)',             &
     &'  --  (last change: ',A10,')'//)
+ei
10010 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y =  ',f15.3, '  PI*MRAD*MM'&
     &)
10020 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10030 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10040 format(/131('-'))
10050 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t10,               &
     &'================================')
10060 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10070 format(/5x,'NON SENSICAL INPUT: NUML = 0 OR NUMLR NOT 0')
10080 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10090 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10120 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10025 format(/t10,'Run started from binary dump file # 32')
10130 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10140 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10150 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10160 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t60,f15.9,1x,f15.10,f15.9/)
10170 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10180 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10190 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'// 15x,       &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10200 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,                &
     &'RELATIVE MOMENTUM DEVIATION')
      end

+dk comnul
subroutine comnul
!-----------------------------------------------------------------------
!  SUBROUTINE TO SET THE ALL COMMON VARIABLES TO ZERO
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
+if datamods
      use bigmats
+ei
      use scatter, only : scatter_comnul
      use dynk, only : dynk_comnul
      use fma,  only : fma_comnul
      use dump, only : dump_comnul
      use zipf, only : zipf_comnul
+if collimat
      use collimation, only : collimation_comnul
+ei
      implicit none
      
      integer i,i1,i2,i3,i4,j
+ca parpro
+ca commonex
+ca common
+ca commons
+ca commont1
+ca commondl
+ca commd1da
+ca commonc
+ca commonxz
+ca commonmn

+if bnlelens
+ca rhicelens
+ei

+ca dbdcum

+ca elensparam
+ca wireparam

+ca parbeam_exp

+ca comApeInfo
      save
!-----------------------------------------------------------------------
!
+if bnlelens
!GRDRHIC
!GRD-042008
! Set all new variables to 0 or ZERO
! Note we do not initialise the checkpoint cr* variables
! nor the my* variables as they should all be read in!
! real(kind=fPrec)
      do i=1,nblz
        tbetax(i)=zero
        tbetay(i)=zero
        talphax(i)=zero
        talphay(i)=zero
        torbx(i)=zero
        torbxp(i)=zero
        torby(i)=zero
        torbyp(i)=zero
        tdispx(i)=zero
        tdispy(i)=zero
        sampl(i)=zero
      enddo
! real(kind=fPrec)
      totals=zero
      limit_twojx=zero
      limit_twojy=zero
      limit_twojr=zero
      twojx=zero
      twojy=zero
      twojr=zero
      sumtwojx=zero
      sumtwojy=zero
      sumsquarex=zero
      sumsquarey=zero
! integers
      n_cut=0
      n_nocut=0
      samplenumber=0
      mynp=0
      do j=1,npart
        namepart(j)=0
      enddo
!GRDRHIC
!GRD-042008
+ei
      ncorru=0
      ncorrep=0
      iexact=0
      ithick=0
      ierro=0
      il=0
      iclo6=0
      iclo6r=0
      mper=0
      mblo=0
      mbloz=0
      kanf=0
      iu=0
      itra=0
      napx=0
      numl=0
      numlr=0
      ird=0
      imc=0
      niu(1)=0
      niu(2)=0
      idp=0
      irew=0
      iorg=0
      itco=0
      itcro=0
      itqv=0
      ichrom=0
      iqmod=0
      iqmod6=0
      ilin=0
      iqmodc=0
      ichromc=0
      ilinc=0
      ntco=0
      nt=0
      iprint=0
      iclo=0
      icoe=0
      ise=0
      mesa=0
      mp=0
      m21=0
      m22=0
      m23=0
      ise1=0
      ise2=0
      ise3=0
      isub=0
      nta=0
      nte=0
      ipt=0
      irmod2=0
      nre=0
      nur=0
      nch=0
      nqc=0
      npp=0
      ipos=0
      iconv=0
      imad=0
      nstart=0
      nstop=0
      iskip=1
      iav=0
      iwg=0
      ivox=0
      ivoz=0
      ires=0
      ifh=0
      idis=0
      icow=0
      istw=0
      iffw=0
      idial=0
      nord=0
      nvar=0
      nvar2=0
      ndimf=0
      nordf=0
      nvarf=0
      nord1=1
      nsix=0
      nvar2=0
      ncor=0
      idptr=0
      nbeam=0
      ibb6d=0
      ibeco=1
      ibtyp=0
      lhc=1
      ibbc=0
      iver=0
      ibidu=0
!-----------------------------------------------------------------------
      inorm=0
      imod1=0
      imod2=0
!-----------------------------------------------------------------------
      icorr=0
      nctype=0
      namp=0
      nmom=0
      nmom1=0
      nmom2=0
      weig1=zero
      weig2=zero
      dpmax=zero
!--DA-------------------------------------------------------------------
      dpda_da=0
      dpda1_da=0
      sigmda_da=0
      ej1_da=0
      ejf1_da=0
      rv_da=0
!-----------------------------------------------------------------------
      pi=zero
      pi2=zero
      pisqrt=zero
      rad=zero
      chi0=zero
      chid=zero
      dp1=zero
      idfor=0
      rat=zero
      qs=zero
      e0=zero
      crad=zero
      dppoff=zero
      tlen=zero
      pma=zero
      phas0=zero
      phas=zero
      ition=0
      dpscor=one
      sigcor=one
      benki=zero
      dma=zero
      dmap=zero
      dkq=zero
      dqq=zero
      de0=zero
      ded=zero
      dsi=zero
      dech=zero
      dsm0=zero
      amp0=zero
      qxt=zero
      qzt=zero
      eui=zero
      euii=zero
      tam1=zero
      tam2=zero
      totl=zero
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      dres=zero
      dfft=zero
      preda=zero
      partnum=zero
      emitx=zero
      emity=zero
      emitz=zero
      gammar=one
      sigz=zero
      sige=zero
      damp=zero
      ampt=zero
!-----------------------------------------------------------------------
      tlim=0.
      time0=0.
      time1=0.
+if backtrk
!-----------------------------------------------------------------------
!       A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!       last modified: 12-06-2014
!       default precision for back-tracking, when computing locations of lost
!          particles
!       inserted in main code by the 'backtrk' compilation flag
       bktpre=c1m1
+ei
!-----------------------------------------------------------------------
      do 10 i=1,2
        nde(i)=0
        is(i)=0
        idz(i)=0
        amp(i)=zero
        bet0(i)=zero
        alf0(i)=zero
        clo(i)=zero
        clop(i)=zero
        aper(i)=c1e3
        di0(i)=zero
        dip0(i)=zero
        cro(i)=zero
        sigma0(i)=zero
        qwsk(i)=zero
        betx(i)=zero
        betz(i)=zero
        alfx(i)=zero
        alfz(i)=zero
   10 continue

      do 20 i=1,3
        iq(i)=0
        hsy(i)=zero
        qw0(i)=zero
        clo6(i)=zero
        clop6(i)=zero
        clon(i)=zero
        wxys(i)=zero
        do i1=1,3
          corr(i,i1)=zero
        enddo
   20 continue

      corr(1,1)=zero
      corr(1,2)=zero
      chromc(1)=9.999999e23_fPrec
      chromc(2)=9.999999e23_fPrec

      do 30 i=1,4
        nwr(i)=0
   30 continue

      do 40 i=1,5
        ipr(i)=0
        nrr(i)=0
        nu(i)=0
        toptit(i)=' '
   40 continue

      do 50 i=1,6
        nskew(i)=0
   50 continue

      do 60 i=1,10
        dtr(i)=zero
        coel(i)=' '
   60 continue

      do 70 i=1,12
        ire(i)=0
   70 continue

      do 80 i=1,nper
        msym(i)=0
   80 continue

      do i=1,6
        do j=1,6
          ta(i,j)=zero
        end do
      end do

      do i=1,2
        do j=1,6
          exz(i,j)=zero
        end do
      end do

      do i1=1,9
        do i2=1,18
          do i3=1,10
            do i4=1,5
              rtc(i1,i2,i3,i4)=zero
              rts(i1,i2,i3,i4)=zero
            end do
          end do
        end do
      end do

!--NUMBER OF PARTICLES--------------------------------------------------
      do i=1,npart
        do i1=1,6
          do i2=1,6
            tasau(i,i1,i2)=zero
          enddo
        enddo
      enddo

!--NUMBER OF ELEMENTS---------------------------------------------------
      do i=1,nele
        kz(i)=0
        kp(i)=0
        irm(i)=0
        imtr(i)=0
        nmu(i)=0
        kpa(i)=0
        isea(i)=0
        ncororb(i)=0
        iratioe(i)=0
        itionc(i)=0
        dki(i,1)=zero
        dki(i,2)=zero
        dki(i,3)=zero
        ed(i)=zero
        el(i)=zero
        ek(i)=zero
        sm(i)=zero
        xpl(i)=zero
        xrms(i)=zero
        zpl(i)=zero
        zrms(i)=zero
        benkc(i)=zero
        r00(i)=zero

! Old aperture type variables
!        apx(i)=c1e3
!        apz(i)=c1e3
!        ape(1,i)=c1e6
!        ape(2,i)=c1e6
!        ape(3,i)=c1e12

        ratioe(i)=one
        hsyc(i)=zero
        phasc(i)=zero
        ptnfac(i)=zero
        acdipph(i)=zero
        crabph(i)=zero
        crabph2(i)=zero
        crabph3(i)=zero
        crabph4(i)=zero
        bez(i)=' '
        bezl(i)=' '
        do i3=1,2
          do i4=1,6
            a(i,i3,i4)=zero
+if .not.vvector
            do i1=1,2
+ei
+if vvector
            do i1=1,npart
+ei
+if .not.datamods
                al(i4,i3,i1,i)=zero
                as(i4,i3,i1,i)=zero
+ei
+if .not.vvector
                at(i4,i3,i1,i)=zero
                a2(i4,i3,i1,i)=zero
+ei
            end do
          end do
        end do

        do 130 i1=1,mmul
          bk0(i,i1)=zero
          ak0(i,i1)=zero
          bka(i,i1)=zero
          aka(i,i1)=zero
  130   continue

        do 140 i1=1,3
          bezr(i1,i)=' '
  140   continue

        do i1=1,18
          parbe(i,i1)=zero
        enddo
      end do

!     From the FLUKA version
      do i=1,nele
         call SELNUL(i)
      end do

!--NUMBER OF BLOCKS-----------------------------------------------------
      do i=1,nblo
        mel(i)=0
        mstr(i)=0
        elbe(i)=zero
        bezb(i)=' '

        do i1=1,2
          do i2=1,6
            bl1(i,i1,i2)=zero
            bl2(i,i1,i2)=zero
          end do
        end do

        do j=1,nelb
          mtyp(i,j)=0
        end do
      end do

!--# OF STRUCTURE ELEMENTS----------------------------------------------
      do i=1,nblz
        ic(i)=0
        mzu(i)=0
        icext(i)=0
+if time
        icext35(i)=0
+ei
        icextal(i)=0
        extalign(i,1)=zero
        extalign(i,2)=zero
        extalign(i,3)=zero
        sigmoff(i)=zero
        tiltc(i)=one
        tilts(i)=zero

!--Beam-Beam------------------------------------------------------------
        imbb(i)=0               !Mapping from a STRUCTURE ELEMENT (here: index i)
                                ! to the beam-beam tables (arrays with size nbb)
!--Other stuff (not beam-beam)...
        do j=1,40
          exterr(i,j)=zero
+if time
          exterr35(i,j)=zero
+ei
          xsi(i)=zero
          zsi(i)=zero
          smi(i)=zero
          smizf(i)=zero

          do i1=1,mmul
            aai(i,i1)=zero
            bbi(i,i1)=zero
          end do

          do i3=1,mmul
            do i2=1,nmac
              aaiv(i3,i2,i)=zero
              bbiv(i3,i2,i)=zero
            end do
          end do

        end do
      end do

!-- BEAM-EXP------------------------------------------------------------
      beam_expflag = 0
      beam_expfile_open = .false.

!-- RANDOM NUMBERS-------------------------------------------------------
      do 200 i=1,nzfz
        zfz(i)=zero
+if time
        zfz35(i)=zero
        tcnst35(i)=zero
+ei
  200 continue
!--# OF TRAJECTORIES----------------------------------------------------
      do 220 i=1,mpa
        rvf(i)=one
        sigm(i)=zero
        dps(i)=zero
        ej(i)=zero
        ejf(i)=zero
        do 210 i1=1,2
          x(i,i1)=zero
          y(i,i1)=zero
  210   continue
  220 continue

!--COMBINATION OF ELEMENTS----------------------------------------------
      do i1=1,20
        icomb0(i1)=0
        do i=1,ncom
          icomb(i,i1)=0
          ratio(i,i1)=zero
        end do
      end do

!--PAW------------------------------------------------------------------
      do i=1,nplo
        hmal(i)=0.0
      end do

!--TROMBONES------------------------------------------------------------
      do i=1,ntr
        do i1=1,6
          cotr(i,i1)=zero
          do i2=1,6
            rrtr(i,i1,i2)=zero
          end do
        end do
      end do

!--Beam-Beam------------------------------------------------------------
      do i=1,nbb
        do j=1,2
          sigman(j,i)=zero
          sigman2(j,i)=zero
          sigmanq(j,i)=zero
        end do

        do j=1,6
          clobeam(j,i)=zero
          beamoff(j,i)=zero
        end do

        do j=1,12
          bbcu(i,j)=zero
        end do

        bbcu(i,11)=one
      end do

!--DA-------------------------------------------------------------------
      do i1=1,2
        xx_da(i1)=0
        yy_da(i1)=0
        do i2=1,6
          alda_da(i1,i2)=0
          asda_da(i1,i2)=0
          aldaq_da(i1,i2)=0
          asdaq_da(i1,i2)=0
        end do
      end do

      do i=1,mcor
        smida_da(i)=0
      enddo

!--CADCUM---------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise common
!     always in main code
      do i=0,nblz+1
         dcum(i)=zero
      end do

!--DUMP BEAM POPULATION-------------------------------------------------
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K.Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     initialise common
!     always in main code
      call dump_comnul
      
!--FMA ANALYSIS---------------------------------------------------------
!     M. Fitterer, FNAL
!     last modified: 2016
      call fma_comnul
      
!combine multiple elments in one loope
!1) --ELEN - ELECTRON LENS---------------------------------------------------------
!2) --WIRE - WIRE ELEMENT---------------------------------------------------------
!     M. Fitterer (FNAL), A. Patapenka (NIU)
!     last modified: 22-12-2016
! 1) single elements
      do i=1,nele
!     elensparam - used for tracking (parameters of single element)
        elens_type(i)          = 0
        elens_theta_max(i)     = 0
        elens_r2(i)            = 0
        elens_r2ovr1(i)        = 0
        elens_offset_x(i)      = 0
        elens_offset_y(i)      = 0
        elens_bend_entrance(i) = 0
        elens_bend_exit(i)     = 0
!     wireparam - used for tracking (parameters of single element)
        wire_flagco(i)  = 0
        wire_current(i) = 0
        wire_lint(i)    = 0
        wire_lphys(i)   = 0
        wire_dispx(i)   = 0
        wire_dispy(i)   = 0
        wire_tiltx(i)   = 0
        wire_tilty(i)   = 0
      end do

! 2) loop over structure elements
      do i=1,nblz
        wire_num(i)=0
      end do

! 3) loop over number of wires
      do i=1,wire_max
        do j=1,6
          wire_clo(j,i)=zero
        end do
      end do

!--APERTURE-------------------------------------------------------------
!     P.G.Ortega, for the FLUKA Team
!     last modified: 04-07-2014
!     initialise common
!     always in main code
      ldmpaper      = .false.
      aperunit      = 0
      aper_filename = ' '
      load_file     = ' '
      limifound     = .false.
!     flag to kill/let live particles at aperture check
      apflag=.false.

!--DYNAMIC KICKS--------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     initialise common
!     always in main code
!     - general-purpose variables
      call dynk_comnul
!--ZIPF----------------------------------------------------------------
      call zipf_comnul
!--SCATTER-------------------------------------------------------------
      call scatter_comnul
!--COLLIMATION----------------------------------------------------------
+if collimat
      call collimation_comnul
+ei
!-----------------------------------------------------------------------
      return
end subroutine comnul

subroutine SELNUL( iel )
!-----------------------------------------------------------------------
!     A.Mereghetti, 2016-03-14
!     initialise a single element to empty
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      implicit none

+ca   parpro
+ca   common
+ca   commons
+ca   comApeInfo

!     local variables
      integer iel, i1, i3, i4

      kz(iel)=0
      kp(iel)=0
      irm(iel)=0
      imtr(iel)=0
      nmu(iel)=0
      kpa(iel)=0
      isea(iel)=0
      ncororb(iel)=0
      iratioe(iel)=0
      itionc(iel)=0
      dki(iel,1)=zero
      dki(iel,2)=zero
      dki(iel,3)=zero
      ed(iel)=zero
      el(iel)=zero
      ek(iel)=zero
      sm(iel)=zero
      xpl(iel)=zero
      xrms(iel)=zero
      zpl(iel)=zero
      zrms(iel)=zero
      benkc(iel)=zero
      r00(iel)=zero
      
      kape(iel)=0
      lapeofftlt(iel)=.false.

      do i1=1,7
         ape(i1,iel)=c1e3
      end do

      ratioe(iel)=one
      hsyc(iel)=zero
      phasc(iel)=zero
      ptnfac(iel)=zero
!      wirel(iel)=zero
      acdipph(iel)=zero
      crabph(iel)=zero
      crabph2(iel)=zero
      crabph3(iel)=zero
      crabph4(iel)=zero
      bez(iel)=' '
      bezl(iel)=' '

      do i3=1,2
        do i4=1,6
          a(iel,i3,i4)=zero
+if .not.vvector
          do i1=1,2
+ei
+if vvector
          do i1=1,npart
+ei
+if .not.datamods
            al(i4,i3,i1,iel)=zero
            as(i4,i3,i1,iel)=zero
+ei
+if .not.vvector
            at(i4,i3,i1,iel)=zero
            a2(i4,i3,i1,iel)=zero
+ei
          end do
        end do
      end do

      do i1=1,mmul
         bk0(iel,i1)=zero
         ak0(iel,i1)=zero
         bka(iel,i1)=zero
         aka(iel,i1)=zero
      end do

      do i1=1,3
         bezr(i1,iel)=' '
      end do

      ! JBG increasing parbe to dimension 5
      do i1=1,5
         parbe(iel,i1)=zero
      end do
      
      return
end subroutine SELNUL

subroutine STRNUL( iel )
!-----------------------------------------------------------------------
!     A.Mereghetti, 2016-03-14
!     initialise an element in lattice structure to empty
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      implicit none
      
+ca parpro
+ca common
+ca commonxz
+ca commonmn

!     local variables
      integer iel, i1, i2, i3, j

      ic(iel)=0
      mzu(iel)=0
      icext(iel)=0
+if time
      icext35(iel)=0
+ei
      icextal(iel)=0
      extalign(iel,1)=zero
      extalign(iel,2)=zero
      extalign(iel,3)=zero
      sigmoff(iel)=zero
      tiltc(iel)=one
      tilts(iel)=zero

!--Beam-Beam------------------------------------------------------------
      imbb(iel)=0
      do j=1,40
         exterr(iel,j)=zero
+if time
         exterr35(iel,j)=zero
+ei
      enddo
      xsi(iel)=zero
      zsi(iel)=zero
      smi(iel)=zero
      smizf(iel)=zero
      do i1=1,mmul
         aai(iel,i1)=zero
         bbi(iel,i1)=zero
      enddo
      do i3=1,mmul
         do i2=1,nmac
            aaiv(i3,i2,iel)=zero
            bbiv(i3,i2,iel)=zero
         enddo
      enddo
      return
end subroutine STRNUL

integer function INEELS( iEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     Insert a New Empty Element in Lattice Structure
!     interface variables:
!     - iEl: index in lattice structure where to insert the element
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use crcoall
      implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum

!     interface variables
      integer iEl

!     temporary variables
      integer i,ii,iInsert

      if ( iu.gt.nblz-3) then
         write(lout,*)'ERROR: not enough space for adding element in lattice structure!'
         write(lout,*)'       please, increase nblz and recompile!'
         call prror(-1)
      end if
      iu=iu+1
      if ( iEl.eq.0 ) then
!        append
         iInsert=iu
      elseif ( iEl .lt. 0 ) then
         iInsert=iu+iEl
      else
         iInsert=iEl
      end if
      if ( iInsert.le.iu ) then
!     shift by one all lattice elements, to make room for the new
!        starting marker
         do i=iu,iInsert+1,-1
            ic(i)=ic(i-1)
            icext(i)=icext(i-1)
            icextal(i)=icextal(i-1)
            extalign(i,1)=extalign(i-1,1)
            extalign(i,2)=extalign(i-1,2)
            extalign(i,3)=extalign(i-1,3)
            do ii=1,40
               exterr(i,ii)=exterr(i-1,ii)
+if time
               exterr35(i,ii)=exterr35(i-1,ii)
+ei
            enddo
+if time
            tcnst35(i)=tcnst35(i-1)
+ei
            dcum(i)=dcum(i-1)
         enddo
      endif

!     initialise element to empty
      call STRNUL(iInsert)
!     update dcum of added element
      dcum(iInsert)=dcum(iInsert-1)
!     return iu
      INEELS=iu
end function INEELS

integer function INEESE()
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     Insert a New Empty Element (empty) in SINGLE ELEMENTS
!     for the moment, it only appends the new single element
!     always in main code
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants
  use crcoall

  implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr

  il=il+1
  if( il.gt.nele ) then
    write(lout,*)'ERROR: not enough space for adding element in list of SINGLE ELEMENTs!'
    write(lout,*)'       please, increase nele and recompile!'
    call prror(-1)
  end if

! initialise element to empty
  call SELNUL(il)

! returned variable
  INEESE=il

end function INEESE

integer function check_SE_unique( iEl, ixEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     check that a given entry in the sequence is unique
!     interface variables:
!     - iEl:  index in lattice structure to be checked
!     - ixEl: index in array of SINGLE ELEMENTs of the element to be checked
!     always in main code
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants

  implicit none

+ca parpro
+ca common
+ca commonmn
+ca commontr
+ca dbdcum

! interface variables
  integer iEl, ixEl

! temporary variables
  integer i,ix

  check_SE_unique=-1

  do i=1,iu
    ix=ic(i)-nblo
    if(ix.gt.0) then
!     SINGLE ELEMENT 
      if( i.ne.iEl .and. ix.eq.ixEl ) then
        check_SE_unique=i
        exit
      end if
    end if
  end do

  return
      
end function check_SE_unique

+dk umschr
subroutine umschr(iu1,iu2)
!-----------------------------------------------------------------------
!           UMSCHR    DIFFERENTIAL ALGEBRA 5 -> 6
!                          AUGUST 1994
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ii,iio,io,ioo,iplus,iu1,iu2,j,jj,nno
      real(kind=fPrec) c,c1
      character(len=80) aaa
      character(len=18) a18
      character(len=58) a58
      dimension jj(100)
      save
!-----------------------------------------------------------------------
      do i=1,100
        jj(i)=0
      enddo
      do 40 j=1,6
        iplus=0
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A18,I4,A58)') a18,nno,a58
        write(iu2,'(A18,I4,A58)') a18,nno,a58
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa
        read(iu1,'(A80)') aaa
        write(iu2,'(A80)') aaa

        if(nno.eq.1) then
          do 10 i=1,5
            read(iu1,'(6X,2X,G20.14,I5)') c,ii
            write(iu2,'(6X,2X,G20.14,I5)') c,ii
   10     continue
          if (j.eq.5) then
            write(iu2,'(6X,2X,G20.14,I5)') one,5
          else
            write(iu2,'(6X,2X,G20.14,I5)') zero,5
          endif
          read(iu1,'(6X,2X,G20.14,I5)') c,ii
          write(iu2,'(6X,2X,G20.14,I5)') c,ii+1
          read(iu1,'(6X,2X,G20.14,I5)') c,ii
          if(ii.ne.0) write(lout,*) ' ERROR IN UMSCHR'
        else
   20     read(iu1,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii,c,io,(jj(i),i=1,5)
          if(ii.eq.0) then
            if(j.eq.5.and.ioo.lt.2) then
              write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') iio+1,one,1, 0,0,0,0,1,0
              write(iu2,*) one
            endif
            goto 30
          endif
          ioo=io
          iio=ii
          read(iu1,*) c1
          if(j.eq.5.and.(io.eq.2.or.jj(5).eq.1).and.iplus.eq.0) then
            iplus=1
            write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii,one,io,0,0,0,0,1,0
            write(iu2,*) one
          endif
          write(iu2,'(I6,2X,G20.14,I5,4X,18(2I2,1X))') ii+iplus,c,io,(jj(i),i=1,4),0,jj(5)
          write(iu2,*) c1
          goto 20
        endif
   30   write(iu2,*)
   40 continue
      rewind iu1
      rewind iu2
      return
end subroutine umschr

+dk daliesix
subroutine daliesix
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,mf1,mf2,mf3,mf4,mf5,mfile,nd2,ndim,ndpt,nis,no,nv,damap,a1,a1i,a2,a2i,f,fc,fs,rot,xy,h,hc,hs,h4,df,bb1,bb2,haux
      real tlim,time0,time1,time
      real(kind=fPrec) angle,coe,rad,x2pi
+ca parpro
+ca commondl
+ca commonas
      dimension damap(6),a1(6),a1i(6),a2(6),a2i(6)
      dimension rot(6),xy(6),df(6)
      dimension angle(3),rad(3)
      save
!-----------------------------------------------------------------------
      tlim=1e7
      call timest(tlim)
      time0=0.
      call timex(time0)
!--Initialization
      x2pi=atan_mb(one)*eight
      coe=(-one*two)/x2pi                                                !hr08
      no=nordf
      if(nord1.gt.no) nord1=no
      ndim=nvar2/2
      if(nvarf/2.lt.ndim) ndim=nvarf/2
      if(ndim.eq.0) call prror(94)
      nv=nvarf
      nd2=2*ndim
      ndpt=idptr
      nis=0
      mfile=18
      mf1=21
      mf2=22
      mf3=23
      mf4=24
      mf5=25
      call idprset(-102)
      call lieinit(no,nv,ndim,ndpt,0,nis)
      call etall(damap,nd2)
      call etall(xy,nd2)
      call etall(bb1,1)
      call etall(bb2,1)
      call etall(haux,1)
      call etallnom(a1,nd2,'A1        ')
      call etallnom(a1i,nd2,'A1I       ')
      call etallnom(a2,nd2,'A2        ')
      call etallnom(a2i,nd2,'A2I       ')
      call etallnom(f,1,'F         ')
      call etallnom(fc,1,'FC        ')
      call etallnom(fs,1,'FS        ')
      call etallnom(rot,nd2,'ROT       ')
      call etallnom(h,1,'H         ')
      call etallnom(h4,1,'H4        ')
      call etallnom(hc,1,'HC        ')
      call etallnom(hs,1,'HS        ')
      call etallnom(df,nd2,'DF        ')
      rewind mfile
!Eric
      rewind 111
      rewind mf1
      rewind mf2
      rewind mf3
      rewind mf4
      rewind mf5
      call daread(damap,nd2,mfile,zero)
!--Normal Form Analysis
      call mapnorm(damap,f,a2,a1,xy,h,nord1)
      call dainv(a1,nv,a1i,nv)
      call dainv(a2,nv,a2i,nv)
      call ctor(f,fc,fs)
      call gettura(angle,rad)
      call taked(xy,1,rot)
      call take(h,2,haux)
      call dasub(h,haux,h4)
      call ctor(h,hc,hs)
      call dhdj(h,df)
!--Printing
      call daprid(a1i,1,nd2,mf1)
      call daprid(a2i,1,nd2,mf1)
      call dapri(f,mf1)
      call daprid(rot,1,nd2,mf1)
      call dapri(h4,mf1)
      call dapri(f,mf1)
      call daprid(a2,1,nd2,mf1)
      call daprid(a1,1,nd2,mf1)
      call dapri(h,mf2)
      call dapri(hc,mf2)
      call dapri(hs,mf2)
      call dapri(fc,mf2)
      call dapri(fs,mf2)
      call daprimax(hc,mf3)
      call daprid(df,ndim+1,nd2,mf4)
      call daprid(df,1,ndim,mf5)
      write(lout,10060)
      if(imod1.eq.0) then
        write(lout,10020) nordf
      else
        write(lout,10010) nordf
      endif
      write(lout,10025) nord1
      if(imod2.eq.0) then
        write(lout,10040) nvarf
      else
        write(lout,10030) nvarf
      endif
      write(lout,10050)
      angle(3)=angle(3)*(-one)
      write(lout,*) (angle(i),i=1,ndim)
!--Clean-Up
      call dadal(damap,nd2)
      call dadal(a1,nd2)
      call dadal(a1i,nd2)
      call dadal(a2,nd2)
      call dadal(a2i,nd2)
      call dadal(f,1)
      call dadal(fc,1)
      call dadal(fs,1)
      call dadal(rot,nd2)
      call dadal(xy,nd2)
      call dadal(h,1)
      call dadal(h4,1)
      call dadal(hc,1)
      call dadal(hs,1)
      call dadal(df,nd2)
      call dadal(bb1,1)
      call dadal(bb2,1)
      call dadal(haux,1)
      time1=0.
      call timex(time1)
      time = time1-time0
      write(lout,10000) no,time
      return
!-----------------------------------------------------------------------
10000 format(/10x,'DA-CALCULATION OF ORDER : ',i7,' TAKES ', f12.3,     &
     &' SECONDS OF CPU TIME'//131('-')//)
10010 format(t10,'THE ORDER IS GREATER THAN THE ONE SPECIFIED IN THE'/  &
     &t10,'DIFFERENTIAL ALGEBRA BLOCK.'// t10,'NEW ORDER---> ',i3)
10020 format(t10,'ORDER FOR THE NORMAL FORM CALCULATIONS---> ',i3/)
10025 format(/t10,'CLOSED ORBIT ORDER OF THE NORMAL FORM ---> ',i3/)
10030 format(t10,'THE NUMBER OF VARIABLES IS GREATER THAN THE ONE ',    &
     &'SPECIFIED IN THE'/ t10,'DIFFERENTIAL ALGEBRA BLOCK.'// t10,      &
     &'NEW NUMBER OF VARIABLES---> ',i3/)
10040 format(t10,'NUMBER OF VARIABLES FOR THE NORMAL FORM ' ,           &
     &'CALCULATIONS---> ',i3//)
10050 format(t10,'LINEAR TUNES USED IN THE NORMAL FORM CALCULATIONS:'//)
10060 format(//131('-')//t10,20('O')/t10,2('O'),16x,2('O')/t10,         &
     &'OO  NORMAL FORMS  OO', /t10,2('O'),16x,2('O')/t10,20('O')//130(  &
     &'-')//)
end subroutine daliesix

+dk distance
subroutine distance(x,clo,di0,t,dam)
!-----------------------------------------------------------------------
!  CALCULATION OF DISTANCE IN PHASE SPACE FOR POST-PROCESSING
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,ii,iq,j,jq
      real(kind=fPrec) clo,cx,dam,di0,phi,pi,sx,t,x,x1
+ca parpro
+ca commonds
      dimension x(2,6),x1(2,6),clo(6),di0(4),t(6,6),phi(3)
      save
!-----------------------------------------------------------------------
      pi=four*atan_mb(one)
      if(icode.ge.4.and.its6d.eq.0) then
        do i=1,2
          do j=1,4
            x(i,j)=x(i,j)-di0(j)*x(i,6)
          end do
        end do
      endif

      do 60 i=1,2
        do 20 j=1,6
          x(i,j)=x(i,j)-clo(j)
   20   continue

        if(its6d.eq.1) then
          x(i,2)=x(i,2)/((one+x(i,6))+clo(6))                            !hr06
          x(i,4)=x(i,4)/((one+x(i,6))+clo(6))                            !hr06
        endif

        do 40 iq=1,6
          x1(i,iq)=zero
          do 30 jq=1,6
            x1(i,iq)=x1(i,iq)+t(jq,iq)*x(i,jq)
   30     continue
   40   continue

        do 50 j=1,6
          x(i,j)=x1(i,j)
   50   continue

   60 continue

      do 70 i=1,2
        x(i,5)=x(i,5)*sigcor
        x(i,6)=x(i,6)*dpscor
   70 continue

      do 80 i=1,3
        ii=2*i
        sx=x(2,ii-1)*x(1,ii)-x(1,ii-1)*x(2,ii)
        cx=x(1,ii-1)*x(2,ii-1)+x(1,ii)*x(2,ii)
        if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
          phi(i)=atan2_mb(sx,cx)
        else
          phi(i)=zero
        endif
   80 continue
      dam=sqrt((phi(1)**2+phi(2)**2+phi(3)**2)/real(idam,fPrec))/pi            !hr06
!-----------------------------------------------------------------------
      return
end subroutine distance

+dk anfb
      subroutine anfb(tas)
!-----------------------------------------------------------------------
!  CALCULATION OF INITIAL COORDINATES
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ii,jj,l,ll
      real(kind=fPrec) bet0s1,bet0x2,bet0z2,chi,co,dchi,dpsic,dsign,si, &
     &tas,tas56,x1,x11,x13,x2
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension tas(6,6),x1(6),x2(6)
      save
!-----------------------------------------------------------------------
      write(lout,10030)
      if(itra.eq.0) goto 60
      tas56=tas(5,6)*c1m3
      bet0x2=tas(1,3)**2+tas(1,4)**2                                     !hr08
      bet0z2=tas(3,1)**2+tas(3,2)**2                                     !hr08
      bet0s1=tas(5,5)**2+tas56**2                                        !hr08
      dsign=one
      if(tas(3,3).lt.-one*pieni) rat=-one*rat                            !hr08
      if(rat.lt.-one*pieni) dsign=-one*one
      x11=amp(1)/(sqrt(bet0(1))+sqrt(abs(rat)*bet0x2))
      x13=(x11*dsign)*sqrt(abs(rat))                                     !hr08
      amp(2)=(dsign*real(1-iver,fPrec))*                                &!hr08
     &(abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt(bet0(2)))                     !hr08
      x1(5)=zero
      if(iclo6.eq.1.or.iclo6.eq.2) then
        x1(6)=(dp1-clop6(3))*sqrt(bet0s1)
      else
        x1(6)=dp1*sqrt(bet0s1)
      endif
      chi=chi0*rad
      dchi=chid*rad
      do 50 i=1,itra
        si=sin_mb(chi)
        co=cos_mb(chi)
        x1(1)=x11*co
        x1(2)=x11*si
        x1(3)=x13*co
        x1(4)=x13*si
        do 20 ii=1,6
          x2(ii)=zero
          do 10 jj=1,6
            x2(ii)=x2(ii)+tas(ii,jj)*x1(jj)
   10     continue
   20   continue
        if(iclo6.eq.1.or.iclo6.eq.2) then
          x2(2)=x2(2)/((one+x2(6))+clop6(3))                             !hr08
          x2(4)=x2(4)/((one+x2(6))+clop6(3))                             !hr08
        endif
        if(abs(bet0s1).le.pieni) x2(6)=dp1
        if(iver.eq.1) then
          x2(3)=zero
          x2(4)=zero
        endif
        do 30 l=1,2
          ll=(l-1)*2
          x(i,l)=x2(1+ll)+exz(i,1+ll)
          y(i,l)=x2(2+ll)+exz(i,2+ll)
   30   continue
        sigm(i)=x2(5)+exz(i,5)
        dps(i)=x2(6)
        dpsic=dps(i)+clop6(3)
        if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
          do 40 l=1,2
            x(i,l)=x(i,l)+di0(l)*dpsic
            y(i,l)=y(i,l)+dip0(l)*dpsic
   40     continue
        endif
        chi=chi+dchi
   50 continue
      write(lout,10000) itra,amp,chi0,chid
      write(lout,10010) x(1,1), y(1,1), x(1,2), y(1,2), sigm(1), dps(1), x(2,1), y(2,1), x(2,2), y(2,2), sigm(2), dps(2)
      return
   60 itra=2
      do 80 i=1,itra
        sigm(i)=exz(i,5)
        dps(i)=exz(i,6)
        do 70 l=1,2
          ll=(l-1)*2
          x(i,l)=exz(i,1+ll)
          y(i,l)=exz(i,2+ll)
   70   continue
   80 continue
      write(lout,10020)
      write(lout,10010) x(1,1), y(1,1), x(1,2), y(1,2), sigm(1), dps(1), x(2,1), y(2,1), x(2,2), y(2,2), sigm(2), dps(2)
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY ANFB ----/ITRA/',i3,' /AMP/ ',f8.3,2x,f8.3, &
     &' /CHI0,CHID/  ',f6.1,2x,f6.1)
10010 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10020 format(t5,'---- ENTRY ANFB ----/COORDINATE-INPUT')
10030 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
      end

+dk betalf
      subroutine betalf(dpp,qw)
!-----------------------------------------------------------------------
!  CALCULATION OF : OPT. PARAMETERS AT THE STARTING POSITION:
!                   BETA-, ALFA-FUNCTIONS, Q-VALUES
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,j
      real(kind=fPrec) am,det,detb,detc,dpp,egwg1,egwg2,f0,f1,f2,fak1,  &
     &fak2,qw,rca1,rca2,rclam1,rclam2,rcw1(4),rcw2(4),rn1,rn2,spa,spd,  &
     &sqrn,yca1,yca2,yclam1,yclam2,ycw1(4),ycw2(4)
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension am(4,4)
      dimension qw(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ierro=0
      call matrix(dpp,am)
!--CALCULATION OF EIGENVALUES
   10 spa=am(1,1)+am(2,2)
      spd=am(3,3)+am(4,4)
      det=(am(1,3)+am(4,2))*(am(2,4)+am(3,1))                           &
     &-(am(1,4)-am(3,2))*(am(2,3)-am(4,1))
      f0=spa-spd
      f1=spa+spd
      f2=f0**2+four*det                                                  !hr06
      if(f2 .lt. zero) goto 160
      f2=sqrt(f2)
      if(f0.lt.zero) goto 30                                              !hr06
      if(f0.ge.zero) goto 20                                              !hr06
   20 egwg1=(f1+f2)*half
      egwg2=(f1-f2)*half
      goto 40
   30 egwg1=(f1-f2)*half
      egwg2=(f1+f2)*half
   40 continue
      f1=egwg1**2-four                                                   !hr06
      f2=egwg2**2-four                                                   !hr06
      rca1=f1
      yca1=zero
      rca2=f2
      yca2=zero
      if (rca1.ge.0) then
        rca1=sqrt(rca1)
      else
        yca1=sqrt(-one*rca1)                                             !hr06
        rca1=zero
      endif
      if (rca2.ge.0) then
        rca2=sqrt(rca2)
      else
        yca2=sqrt(-one*rca2)                                             !hr06
        rca2=zero
      endif
      rclam1=(egwg1+rca1)*half
      yclam1=yca1*half
      rclam2=(egwg2+rca2)*half
      yclam2=yca2*half
      if(egwg1**2 .ge. four) goto 160                                    !hr06
      if(egwg2**2 .ge. four) goto 160                                    !hr06
   50 continue
      detb=am(1,3)*am(2,4)-am(1,4)*am(2,3)
      detc=am(3,1)*am(4,2)-am(3,2)*am(4,1)
      fak1=spd-egwg1
      if(abs(fak1).gt.pieni) then
        rcw1(1)=am(1,2)-(am(1,3)*am(3,2)+am(1,4)*am(4,2))/fak1           !hr06
        ycw1(1)=zero
        rcw1(2)=((am(1,3)*am(3,1)+am(1,4)*am(4,1))+detb)/fak1-(am(1,1)  &!hr06
     &-rclam1)                                                           !hr06
        ycw1(2)=yclam1
      rcw1(3)=-one*((am(3,1)+am(2,4))*rcw1(1)+(am(3,2)-am(1,4))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(3)=-one*((am(3,1)+am(2,4))*ycw1(1)+(am(3,2)-am(1,4))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      rcw1(4)=-one*((am(4,1)-am(2,3))*rcw1(1)+(am(4,2)+am(1,3))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(4)=-one*((am(4,1)-am(2,3))*ycw1(1)+(am(4,2)+am(1,3))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      else
        rcw1(1)=am(1,2)
        ycw1(1)=zero
        rcw1(2)=rclam1-am(1,1)                                           !hr06
        ycw1(2)=yclam1
        rcw1(3)=zero
        ycw1(3)=zero
        rcw1(4)=zero
        ycw1(4)=zero
      endif
      fak2=spa-egwg2
      if(abs(fak2).gt.pieni) then
        rcw2(3)=am(3,4)-(am(3,1)*am(1,4)+am(3,2)*am(2,4))/fak2           !hr06
        ycw2(3)=zero
        rcw2(4)=((am(3,1)*am(1,3)+am(3,2)*am(2,3))+detc)/fak2-(am(3,3)  &!hr06
     &-rclam2)                                                           !hr06
        ycw2(4)=yclam2
      rcw2(1)=-one*((am(1,3)+am(4,2))*rcw2(3)+(am(1,4)-am(3,2))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(1)=-one*((am(1,3)+am(4,2))*ycw2(3)+(am(1,4)-am(3,2))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      rcw2(2)=-one*((am(2,3)-am(4,1))*rcw2(3)+(am(2,4)+am(3,1))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(2)=-one*((am(2,3)-am(4,1))*ycw2(3)+(am(2,4)+am(3,1))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      else
        rcw2(3)=am(3,4)
        ycw2(3)=zero
        rcw2(4)=rclam2-am(3,3)                                           !hr06
        ycw2(4)=yclam2
        rcw2(1)=zero
        ycw2(1)=zero
        rcw2(2)=zero
        ycw2(2)=zero
      endif

!--LEAVING COMPLEX NUMBERS
      do 60 i=1,4
        ta(i,1)=rcw1(i)
        ta(i,3)=rcw2(i)
        ta(i,2)=ycw1(i)
        ta(i,4)=ycw2(i)
   60 continue

!--NORMALISATION OF EIGENVALUES
      rn1=((ta(1,1)*ta(2,2)-ta(2,1)*ta(1,2))                            &!hr06
     &+ta(3,1)*ta(4,2))-ta(4,1)*ta(3,2)                                  !hr06
      if(rn1.lt.zero) goto 70                                             !hr06
      if(rn1.eq.zero) goto 160                                            !hr06
      if(rn1.gt.zero) goto 90                                             !hr06
   70 yclam1=-one*yclam1                                                 !hr06

      do i=1,4
        ta(i,2)=-one*ta(i,2)                                               !hr06
      end do

   90 sqrn=sqrt(abs(rn1))

      do i=1,4
        ta(i,1)=ta(i,1)/sqrn
        ta(i,2)=ta(i,2)/sqrn
      end do

      rn2=((ta(1,3)*ta(2,4)-ta(2,3)*ta(1,4))                            &!hr06
     &+ta(3,3)*ta(4,4))-ta(4,3)*ta(3,4)                                  !hr06
      if(rn2.lt.zero) goto 110                                           !hr06
      if(rn2.eq.zero) goto 160                                           !hr06
      if(rn2.gt.zero) goto 130                                           !hr06
  110 yclam2=-one*yclam2                                                 !hr06

      do i=1,4
        ta(i,4)=-one*ta(i,4)                                               !hr06
      end do

  130 sqrn=sqrt(abs(rn2))

      do i=1,4
        ta(i,3)=ta(i,3)/sqrn
        ta(i,4)=ta(i,4)/sqrn
      end do

      qw(1)= atan_mb(yclam1/(one+rclam1))/pi
      qw(2)= atan_mb(yclam2/(one+rclam2))/pi

!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      betx(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
      alfx(1)=-one*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
      betx(2)=ta(1,3)**2+ta(1,4)**2                                      !hr06
      alfx(2)=-one*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
      betz(1)=ta(3,1)**2+ta(3,2)**2                                      !hr06
      alfz(1)=-one*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
      betz(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
      alfz(2)=-one*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
      bet0(1)=betx(1)
      alf0(1)=alfx(1)
      bet0(2)=betz(2)
      alf0(2)=alfz(2)

      if(ta(1,1).lt.-pieni) then
        do i=1,4
          do j=1,4
            ta(i,j)=-one*ta(i,j)
          end do
        end do
      endif

      return
!-----------------------------------------------------------------------
  160 ierro=1
      return
      end
+dk blocksv
subroutine blocksv
  use floatPrecision
  use numerical_constants

+if datamods
  use bigmats
+ei

  implicit none

+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commonc
      integer n, ia, ikk, j, jm, k, lkk, mkk
      real(kind=fPrec) dpoff
!     integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,&
!    &idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
!    &jm,k,kpz,kzz,l,lkk,ll,m,mkk,napxto,ncorruo,ncrr,nd,nd2,ndafi2,    &
!    &nerror,nlino,nlinoo,nmz,nthinerr
!     double precision alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
!    &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
!    &dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
!    &gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
!    &rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
!    &tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
!    &taus,x11,x13

  save

+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 11-06-2014
!     entirely re-initialise to 0.0 hv(...) and bl1v(...) arrays
!     inserted in main code by the 'fluka' compilation flag
      do ia=1,npart
        do k=1,nblo
          do lkk=1,2
            do mkk=1,6
              hv(mkk,lkk,ia,k)=zero
              bl1v(mkk,lkk,ia,k)=zero
            end do
          end do
        end do
      end do
+ei
      do 440 k=1,mblo
        jm=mel(k)
        ikk=mtyp(k,1)
        do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(mkk,lkk,ia,1)=al(mkk,lkk,ia,ikk)
              if(mkk.eq.5.or.mkk.eq.6) then
                hv(mkk,lkk,ia,1)=hv(mkk,lkk,ia,1)/dpoff
              end if
            end do
          end do
        end do
        if(jm.eq.1) goto 410
        do j=2,jm
          ikk=mtyp(k,j)
          do lkk=1,2
            do ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(1,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(2,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(3,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(4,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
!hr05         hv(5,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(2,lkk,ia,ikk)+al(5,lkk,ia,ikk)/dpoff
              hv(5,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(2,lkk,ia,ikk))+al(5,lkk,ia,ikk)/dpoff               !hr05
!hr05         hv(6,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(4,lkk,ia,ikk)+al(6,lkk,ia,ikk)/dpoff
              hv(6,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(4,lkk,ia,ikk))+al(6,lkk,ia,ikk)/dpoff               !hr05
            end do
          end do
        end do
  410   do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              bl1v(mkk,lkk,ia,k)=hv(mkk,lkk,ia,jm)
            end do
          end do
        end do
  440 continue
      end
+dk block
      subroutine block
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,j,jm,k,l,m,n
      real(kind=fPrec) g,h
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension h(nblo,2,6),g(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)

        do l=1,2
          do m=1,6
            h(1,l,m)=a(i,l,m)
            g(1,l,m)=a(n,l,m)
          end do
        end do

        if(jm.eq.1) goto 40

        do j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do l=1,2
            h(j,l,1)=h(j-1,l,1)*a(i,l,1)+h(j-1,l,3)*a(i,l,2)
            h(j,l,2)=h(j-1,l,2)*a(i,l,1)+h(j-1,l,4)*a(i,l,2)
            h(j,l,3)=h(j-1,l,1)*a(i,l,3)+h(j-1,l,3)*a(i,l,4)
            h(j,l,4)=h(j-1,l,2)*a(i,l,3)+h(j-1,l,4)*a(i,l,4)
            g(j,l,1)=g(j-1,l,1)*a(n,l,1)+g(j-1,l,3)*a(n,l,2)
            g(j,l,2)=g(j-1,l,2)*a(n,l,1)+g(j-1,l,4)*a(n,l,2)
            g(j,l,3)=g(j-1,l,1)*a(n,l,3)+g(j-1,l,3)*a(n,l,4)
            g(j,l,4)=g(j-1,l,2)*a(n,l,3)+g(j-1,l,4)*a(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*a(i,l,1)+h(j-1,l,6)*a(i,l,2))+a(i,l,5)  !hr06
            h(j,l,6)=(h(j-1,l,5)*a(i,l,3)+h(j-1,l,6)*a(i,l,4))+a(i,l,6)  !hr06
            g(j,l,5)=(g(j-1,l,5)*a(n,l,1)+g(j-1,l,6)*a(n,l,2))+a(n,l,5)  !hr06
            g(j,l,6)=(g(j-1,l,5)*a(n,l,3)+g(j-1,l,6)*a(n,l,4))+a(n,l,6)  !hr06
          end do
        end do

   40   do l=1,2
          do m=1,6
            bl1(k,l,m)=h(jm,l,m)
            bl2(k,l,m)=g(jm,l,m)
          end do
        end do

      end do

      return
      end

+dk blockdis
      subroutine blockdis(aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX, USED FOR DISPERSION
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,j,jm,k,l,m,n
      real(kind=fPrec) aeg,bl1eg,bl2eg,g,h
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension h(nblo,2,6),g(nblo,2,6)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)

        do l=1,2
          do m=1,6
            h(1,l,m)=aeg(i,l,m)
            g(1,l,m)=aeg(n,l,m)
          end do
         end do

        if(jm.eq.1) goto 40

        do j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do l=1,2
            h(j,l,1)=h(j-1,l,1)*aeg(i,l,1)+h(j-1,l,3)*aeg(i,l,2)
            h(j,l,2)=h(j-1,l,2)*aeg(i,l,1)+h(j-1,l,4)*aeg(i,l,2)
            h(j,l,3)=h(j-1,l,1)*aeg(i,l,3)+h(j-1,l,3)*aeg(i,l,4)
            h(j,l,4)=h(j-1,l,2)*aeg(i,l,3)+h(j-1,l,4)*aeg(i,l,4)
            g(j,l,1)=g(j-1,l,1)*aeg(n,l,1)+g(j-1,l,3)*aeg(n,l,2)
            g(j,l,2)=g(j-1,l,2)*aeg(n,l,1)+g(j-1,l,4)*aeg(n,l,2)
            g(j,l,3)=g(j-1,l,1)*aeg(n,l,3)+g(j-1,l,3)*aeg(n,l,4)
            g(j,l,4)=g(j-1,l,2)*aeg(n,l,3)+g(j-1,l,4)*aeg(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*aeg(i,l,1)+h(j-1,l,6)*aeg(i,l,2))+aeg  &!hr06
     &(i,l,5)                                                            !hr06
            h(j,l,6)=(h(j-1,l,5)*aeg(i,l,3)+h(j-1,l,6)*aeg(i,l,4))+aeg  &!hr06
     &(i,l,6)                                                            !hr06
            g(j,l,5)=(g(j-1,l,5)*aeg(n,l,1)+g(j-1,l,6)*aeg(n,l,2))+aeg  &!hr06
     &(n,l,5)                                                            !hr06
            g(j,l,6)=(g(j-1,l,5)*aeg(n,l,3)+g(j-1,l,6)*aeg(n,l,4))+aeg  &!hr06
     &(n,l,6)                                                            !hr06
          end do
        end do

   40   do l=1,2
          do m=1,6
            bl1eg(k,l,m)=h(jm,l,m)
            bl2eg(k,l,m)=g(jm,l,m)
          end do
        end do

      end do

      return
      end

+dk chroma
      subroutine chroma
!-----------------------------------------------------------------------
!  CALCULATION OF CHROMATICITY FROM 5 ENERGIE-VALUES
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ii,isl,j,jj,l,n
      real(kind=fPrec) cor,coro,cro0,de2,det,dm,dpp,dsm,ox,oz,qwc,sens, &
     &sm0,su2,suxy,suzy,xi,zi
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commonc
      dimension dsm(2,4),sens(2,4),xi(2),zi(2),dm(2),sm0(2)
      dimension qwc(3),cro0(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      cor=zero
      coro=1.0e38_fPrec

      do i=1,2
        do j=1,4
          dsm(i,j)=zero
          sens(i,j)=zero
        end do
      end do

      do i=1,2
        xi(i)=zero
        zi(i)=zero
        dm(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        cro0(i)=zero
      end do

      qwc(3)=zero
      write(lout,10010)
      dsm(1,2)=dsm0
      dsm(2,3)=dsm0
      de2=de0*half
      do 90 jj=1,itcro
        do 80 ii=1,4
          su2=zero
          suxy=zero
          suzy=zero
          do 30 l=1,2
            isl=is(l)
            if(kz(isl).ne.3) call prror(11)
            ed(isl)=ed(isl)+dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   30     continue
          do 40 n=1,5
            dpp=de2*real(3-n,fPrec)                                            !hr06
            call clorb(dpp)
            if(ierro.gt.0) call prror(12)
            call phasad(dpp,qwc)
            if(ierro.gt.0) call prror(13)
            ox=qwc(1)
            oz=qwc(2)
            su2=su2+dpp**2                                               !hr06
            suxy=suxy+ox*dpp
            suzy=suzy+oz*dpp
   40     continue
          do 50 l=1,2
            isl=is(l)
            ed(isl)=ed(isl)-dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   50     continue
          sens(1,ii)=suxy/su2
          sens(2,ii)=suzy/su2
          if(ii.ne.3) goto 80

!--COMPENSATION OF CHROMATICITY
          do l=1,2
            cro0(l)=sens(l,1)-cro(l)
            xi(l)=(sens(1,l+1)-sens(1,1))/dsm0
            zi(l)=(sens(2,l+1)-sens(2,1))/dsm0
          end do

          cor=sqrt(cro0(1)**2+cro0(2)**2)                                !hr06
          if(jj.eq.1.or.cor.lt.coro) then
            coro=cor
            det=xi(1)*zi(2)-zi(1)*xi(2)
            dm(1)=(cro0(2)*xi(2)-cro0(1)*zi(2))/det                      !hr06
            dm(2)=(cro0(1)*zi(1)-cro0(2)*xi(1))/det                      !hr06

            do l=1,2
              sm0(l)=ed(is(l))
              isl=is(l)
              ed(isl)=ed(isl)+dm(l)
              if(kp(isl).eq.5) call combel(isl)
            end do
          else
            write(lout,10035)
            return
          endif
   80   continue
        write(lout,10020) sens(1,1),sens(1,4),sens(2,1),sens(2,4)
        chromc(1)=sens(1,4)*c1m3
        chromc(2)=sens(2,4)*c1m3
        write(lout,10030) sm0(1),ed(is(1)),bez(is(1)), sm0(2),ed(is(2)),&
     &bez(is(2))
        write(lout,10040) xi,zi
        write(lout,10010)
        if(abs(sens(1,4)-cro(1)).lt.dech.and.abs(sens(2,4)-cro(2))      &
     &.lt.dech) return
   90 continue
      write(lout,10000) itcro
!-----------------------------------------------------------------------
      return
10000 format(/131('-')//t10,'CHROMATICITY CORRECTION'/t10,              &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(/131('-')//t10,'DATA BLOCK CHROMATICITY CORRECTION'/t10,   &
     &'CHROMATICITIES         BEFORE           AFTER CORRECTION'/t10,   &
     &'HORIZONTAL       ',d17.10,7x,d17.10/ t10,'VERTICAL         ',d17.&
     &10,7x,d17.10/)
10040 format(t10,'SEXTUPOLE SENSITIVITIES    XI/M1 XI/M2 YI/M1 YI/M2  ',&
     &4d15.8)
10030 format(t10,'SEXTUP.STRENGTHS ',g17.10,7x,g17.10,'   INDEX   ',a16/&
     &t10,'                 ',g17.10,7x,g17.10,'           ',a16)
10035 format(/t5,'---- NO Improvement in last Step ----'/)
      end

      subroutine chromda
!-----------------------------------------------------------------------
!  CHROMATICITY CORRECTION VIA DA
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer icht,iq1,iq2,ix,ncorr,ncorruo,nd,nd2
      real(kind=fPrec) cor,coro,dps0,dq1,dq2,edcor1,edcor2,qw,qwc
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commonxz
+ca commonc
+ca commondl
      dimension qw(2),qwc(3)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      write(lout,10000)
      nd=2
      nd2=4
      dps(1)=dp1+dppoff
      ncorruo=ncorru
      ncorru=1
      call clorb(dp1)
      call betalf(dp1,qw)
      call phasad(dp1,qwc)
      if(nbeam.ge.1) then
+ca beamcou
+if debug
!     call dumpbin('abeamcou2',3,33)
!     call abend('after beam coupling                               ')
+ei
      endif
      ncorru=ncorruo
      iq1=is(1)
      iq2=is(2)
      edcor(1)=ed(iq1)
      edcor(2)=ed(iq2)
      edcor1=edcor(1)
      edcor2=edcor(2)
      coro=1e38_fPrec
      cor=0
      ncorr=0
      do ncorr=1,itcro+1
        ichromc=2
        call mydaini(1,1,nd2,nd,nd2,1)
        ichromc=1
        call mydaini(2,4,7,2,5,1)
        dq1=corr(1,1)-cro(1)*c1m3
        dq2=corr(1,2)-cro(2)*c1m3
        if(ncorr.eq.1) cor=c1e3*sqrt(dq1**2+dq2**2)                      !hr06
        if(cor.gt.dech) then
          cor=c1e3*sqrt(dq1**2+dq2**2)                                   !hr06
          if(ncorr.eq.1.or.cor.lt.coro) then
            coro=cor
            ed(iq1)=(ed(iq1)-corr(2,1)*dq1)-corr(2,2)*dq2                !hr06
            ed(iq2)=(ed(iq2)-corr(3,1)*dq1)-corr(3,2)*dq2                !hr06
            do icht=1,iu
              ix=ic(icht)
              if(ix.gt.nblo) then
                ix=ix-nblo
                if(ix.eq.iq1.or.iratioe(ix).eq.iq1) then
                  smi(icht)=ed(iq1)*ratioe(ix)+smizf(icht)
                else if(ix.eq.iq2.or.iratioe(ix).eq.iq2) then
                  smi(icht)=ed(iq2)*ratioe(ix)+smizf(icht)
                endif
              endif
            enddo
            edcor(1)=ed(iq1)
            edcor(2)=ed(iq2)
            if(ncorr.eq.1) then
              write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            else
              write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            endif
          else
            write(lout,10040) ncorr-1
            goto 1
          endif
        else
          write(lout,10050) ncorr-1
          goto 1
        endif
      enddo
 1    continue
      chromc(1)=corr(1,1)
      chromc(2)=corr(1,2)
      if(ncorr.eq.itcro+1) write(lout,10060) itcro
      if(ncorr.eq.1) then
        write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),                 &
     &corr(1,2)*c1e3,ncorr-1,cor
      else
        write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),corr(1,2)*c1e3,  &
     &ncorr-1,cor
      endif
      write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),bez(iq2)
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING DA CHROMATICITY CORRECTION'/)
10010 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        BEFORE CORRECTION'/ t10,   &
     &'HORIZONTAL'     ,15x,G21.14,1x,G21.14/ t10,                      &
     &'VERTICAL'       ,17x,G21.14,1x,G21.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10020 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        AFTER CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G21.14,1x,G21.14/ t10,                      &
     &'VERTICAL'       ,17x,G21.14,1x,G21.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10030 format(t10,'SEXTUPOLE STRENGTH',5x,g17.10,2x,g17.10,'   TYP     ',&
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
10040 format(/t5,'---- NO IMPROVEMENT OF DA CHROMATICITY CORRECTION ',  &
     &'IN ITERATION: ',i4/)
10050 format(t5/t10,'DA CHROMATICITY CORRECTION SUCCESSFUL IN ',        &
     &'ITERATION: ',i4/)
10060 format(/t10,'DA CHROMATICITY CORRECTION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
      end

+dk clorb
      subroutine clorb(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT   'CLO(2),CLOP(2)'
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer ierr,ii,l,ll
      real(kind=fPrec) am,cor,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,  &
     &dy,x0,x1,y0,y1
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save ! Saving DPP?
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=c1e6
        dy(l)=c1e6
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) return
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &goto 50

        do l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
         y0(l)=y(1,l)
        end do

        call matrix(dpp,am)
        if(ierro.ne.0) return
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=(two-am(ll-1,ll-1))-am(ll,ll)                              !hr06
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
      if(ncorru.ne.1) write(lout,10000) itco
   50 cor=c1e3*sqrt(dcx**2+dcz**2)                                       !hr06
      if(iout.eq.1.and.ncorru.ne.1) then
        write(lout,10010) dpp,clo(1),clop(1),clo(2),clop(2),ii,cor
+if debug
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('clo(1)',clo(1),0,0,0,0)
!     call warr('clop(1)',clop(1),0,0,0,0)
!     call warr('clo(2)',clo(2),0,0,0,0)
!     call warr('clop(2)',clop(2),0,0,0,0)
!     call warr('ii',0d0,ii,0,0,0)
!     call warr('cor',cor,0,0,0,0)
+ei
      endif
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(t5,'---- ENTRY CLORB ----/DPP=',f8.5,' /CLOX/', 2f10.5,    &
     &' /CLOY/',2f10.5,' /ITERAT.=',i3,'/ ACCURACY=',d13.6)
      end

+dk clor6
      subroutine clorda(nn,idummy,am)
!-----------------------------------------------------------------------
!  CALCULATION OF THE SIX-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,i4,icheck,ii,j,j4,k,l,ll,nd2,nn
      real(kind=fPrec) am,cloc,cor,coro,dc,dd,dlo,xx
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commondl
      integer idummy(nn)
      character(len=6) chp(3),chd(3)
      dimension xx(6),dlo(6),cloc(6),dd(6),dc(6),am(nn,nn)
      integer nerror
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      nd2=2*ndimf
      write(lout,10010) nd2
      do l=1,nd2
        xx(l)=zero
        cloc(l)=zero
        dd(l)=zero
        dc(l)=zero
        dlo(l)=zero
        do i=1,nd2
          am(l,i)=zero
        enddo
      enddo
      chp(1)=' CLOX '
      chp(2)=' CLOY '
      chp(3)=' CLOS '
      chd(1)='  D-X '
      chd(2)='  D-Y '
      chd(3)='  D-S '
      cor=zero
      coro=1e38_fPrec
      ii=0
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          cloc(ll-1)=clo6(l)
          cloc(ll)=clop6(l)
        enddo
        cloc(5)=clo6(3)
        cloc(6)=clop6(3)
        if(abs(dppoff).gt.pieni) cloc(6)=dppoff
      else
        do l=1,ndimf
          ll=2*l
          cloc(ll-1)=clo(l)
          cloc(ll)=clop(l)
        enddo
        do l=ndimf+1,3
          ll=2*l
          cloc(ll-1)=zero
          cloc(ll)=zero
        enddo
        cloc(6)=dps(1)
      endif
      do 80 ii=1,itco
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
+if debug
!       write(*,*) 'Calling UMLAUDA from clorda'
!       call warr('cloc5',cloc(5),0,0,0,0)
!       call warr('cloc6',cloc(6),0,0,0,0)
+ei
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
+if debug
!       call warr('ambef',am(i4,j4),i4,j4,0,0)
+ei
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
+if debug
!       do i4=1,nd2
!         do j4=1,nd2
!     call warr('amaft',am(i4,j4),i4,j4,0,0)
!         enddo
!       enddo
+ei
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dd(l)=cloc(l)-xx(l)
          dc(l)=abs(dd(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
+if debug
!       call warr('ddl',dd(l),l,1,0,0)
!       call warr('dcl',dc(l),l,1,0,0)
+ei
        enddo
        icheck=0
        do l=1,ndimf
          ll=2*l
          if(dc(ll-1).gt.dma) icheck=1
          if(dc(ll).gt.dmap) icheck=1
        enddo
        if(icheck.eq.0) goto 90
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
+if debug
!     call warr('corl ll',cor,l,ll,1,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,1,0)
+ei
          cor=cor+dc(ll-1)**2                                            !hr06
+if debug
!         call warr('acor',cor,l,ll,1,0)
+ei
        enddo
        cor=sqrt(cor)
+if debug
!       call warr('vital',0d0,ii,0,0,0)
!       call warr('corlll',cor,l,ll,1,0)
!       call warr('coro',coro,l,ll,1,0)
+ei
        if(ii.eq.1.or.cor.lt.coro) then
+if debug
!       call warr('cor',cor,2,0,0,0)
!       call warr('coro',coro,2,0,0,0)
+ei
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          if(ii.ne.itco) then
            write(lout,10030)
            do l=1,ndimf
              ll=2*l
              write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
            enddo
            write(lout,10080) ii,cor
          endif
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
 80   continue
      write(lout,10000) itco
      ii=itco
 90   continue
      if(ii.ne.itco) then
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
+if debug
!     call warr('corl ll',cor,l,ll,2,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,2,0)
+ei
          cor=cor+dc(ll-1)**2                                            !hr06
+if debug
!         call warr('acor',cor,l,ll,2,0)
+ei
        enddo
        cor=sqrt(cor)
+if debug
!       call warr('cor',cor,3,0,0,0)
!       call warr('coro',coro,3,0,0,0)
+ei
        if(cor.lt.coro) then
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          write(lout,10030)
          do l=1,ndimf
            ll=2*l
            write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
          enddo
          write(lout,10080) ii,cor
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dc(l)=abs(cloc(l)-xx(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
        enddo
      endif
      write(lout,10050) nd2,ii
      cor=zero
      do l=1,ndimf
        ll=2*l
        write(lout,10070) chp(l),cloc(ll-1),cloc(ll),                   &
     &chd(l),dc(ll-1),dc(ll)
        cor=cor+dc(ll-1)**2                                              !hr06
      enddo
      cor=sqrt(cor)
      write(lout,10080) ii,cor
 91   continue
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          clo6(l)=cloc(ll-1)
          clop6(l)=cloc(ll)
        enddo
        clo6(3)=cloc(5)
        clop6(3)=cloc(6)
      else
        do l=1,ndimf
          ll=2*l
          clo(l)=cloc(ll-1)
          clop(l)=cloc(ll)
        enddo
      endif
+if debug
!     call warr('end clorda',cloc(1),1,0,0,0)
!     call warr('end cloc(2)',cloc(2),2,0,0,0)
!     call warr('end cloc(3)',cloc(3),3,0,0,0)
!     call warr('end cloc(4)',cloc(4),4,0,0,0)
!     call warr('end cloc(5)',cloc(5),5,0,0,0)
!     call warr('end cloc(6)',cloc(6),6,0,0,0)
!     call warr('clo(1)',clo(1),1,0,0,0)
!     call warr('clo(2)',clo(2),2,0,0,0)
!     call warr('clop(1)',clop(1),1,0,0,0)
!     call warr('clop(2)',clop(2),2,0,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
+ei
!-----------------------------------------------------------------------
      return
10000 format(t10,'DA CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-')/t10,'ENTERING ',i1,                              &
     &'-D DA CLOSED ORBIT CALCULATION'/)
10020 format(5x,'---- closed orbit before correction----')
10030 format(5x,'---- after DA correction----')
10040 format(/5x,'NO IMPROVEMENT OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10050 format(t5,'SUCCESSFULL END OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10060 format(5x,a6,1p,2(1x,g16.9))
10070 format(5x,a6,1p,2(1x,g16.9)/5x,a6,1p,2(1x,g16.9))
10080 format(5x,' ITERAT.=',i3,' ACCURACY=',d13.6/)
      end

+dk mydaini
      subroutine mydaini(ncase,nnord,nnvar,nndim,nnvar2,nnord1)
!-----------------------------------------------------------------------
!  CALCULATION OF THE 4-DIMENSIONAL CLOSED ORBIT INCLUDING DELTA
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer idummy,ncase,ndimfo,ndpt,nis,nndim,                       &
     &nnord,nnord1,nnvar,nnvar2,nord1o,nordo,nvar2o,nvaro
      real(kind=fPrec) am
+ca parpro
+ca commondl
+ca commonas
+ca commonc
      dimension am(6,6),idummy(6)
      save
!-----------------------------------------------------------------------
      if(nndim.lt.2.or.nndim.gt.3) call prror(95)
!--------------------
      nordo=nord
      nvaro=nvar
      ndimfo=ndimf
      nvar2o=nvar2
      nord1o=nord1
!--------------------
      nord=nnord
      nvar=nnvar
      ndimf=nndim
      nvar2=nnvar2
      nord1=nnord1
!--------------------
      ndpt=0
      nis=0
!--------------------
      call daeps(preda)
      call idprset(-102)
      call lieinit(nord,nvar,ndimf,ndpt,0,nis)
+if debug
!     call dumpbin('alieinit',1,11)
!     call abend('alieinit in mydaini                               ')
+ei
      write(lout,10000) nord,nvar,ndimf
      call daall(iscrda,100,'$$IS      ',nord,nvar)
!--closed orbit
+if debug
!     write(*,*) 'ncase=',ncase,' if 1 call clorda'
+ei
      if(ncase.eq.1) call clorda(2*ndimf,idummy,am)
+if debug
!     call dumpbin('aclorda',1,11)
!     call abend('aclorda                                           ')
+ei
!--tune variation
+if debug
!     write(*,*) 'ncase=',ncase,' if 2 call umlauda'
+ei
      if(ncase.eq.2) call umlauda
+if debug
!     if(ncase.eq.2) then
!     call dumpbin('aumlauda',7,77)
!     call abend('aumlauda                                          ')
!     endif
+ei
      iqmodc=0
      ichromc=0
      ilinc=0
      call dadal(iscrda,100)
!--------------------
      nord=nordo
      nvar=nvaro
      nvar2=nvar2o
      ndimf=ndimfo
      nord1=nord1o
!-----------------------------------------------------------------------
10000 format(/131('-')/10x,'DA INITIALIZATION: ORDER = ',i2,            &
     &', # of VARIABLES = ',i2,', DIMENSION = ',i2/)
      return
      end

+dk mydainf
      subroutine mydaini(ncase,nnord,nnvar,nndim,nnvar2,nnord1)
!-----------------------------------------------------------------------
!  CALCULATION OF THE 4-DIMENSIONAL CLOSED ORBIT INCLUDING DELTA
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer idummy,ncase,ndimfo,ndpt,nis,nndim,                       &
     &nnord,nnord1,nnvar,nnvar2,nord1o,nordo,nvar2o,nvaro
      real(kind=fPrec) am
+ca parpro
+ca commondl
+ca commonas
+ca commonc
      dimension am(6,6),idummy(6)
      save
!-----------------------------------------------------------------------
      if(nndim.lt.2.or.nndim.gt.3) call prror(95)
!--------------------
      nordo=nord
      nvaro=nvar
      ndimfo=ndimf
      nvar2o=nvar2
      nord1o=nord1
!--------------------
      nord=nnord
      nvar=nnvar
      ndimf=nndim
      nvar2=nnvar2
      nord1=nnord1
!--------------------
      ndpt=0
      nis=0
!--------------------
      call daeps(preda)
      call idprset(-102)
      call lieinit(nord,nvar,ndimf,ndpt,0,nis)
      write(lout,10000) nord,nvar,nndim
      call daall(iscrda,100,'$$IS      ',nord,nvar)
!--closed orbit
      if(ncase.eq.1) call clorda(2*ndimf,idummy,am)
!--tune variation
      if(ncase.eq.2) call umlauda
      rewind 18
!Eric
        rewind 111
!--main map calculation
      if(ncase.eq.3) call runda
!--%*6 map calculation
      if(ncase.eq.4) call runcav
      iqmodc=0
      ichromc=0
      ilinc=0
      call dadal(iscrda,100)
!--------------------
      nord=nordo
      nvar=nvaro
      nvar2=nvar2o
      ndimf=ndimfo
      nord1=nord1o
!-----------------------------------------------------------------------
10000 format(/131('-')/10x,'DA INITIALIZATION: ORDER = ',i2,            &
     &', # of VARIABLES = ',i2,', DIMENSION = ',i2/)
      return
      end

+dk clorb2
      subroutine clorb2(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT - NO WRITEOUT
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer ierr,ii,l,ll
      real(kind=fPrec) am,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,dy,x0,&
     &x1,y0,y1
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=c1e6                                                        !hr06
        dy(l)=c1e6                                                        !hr06
   10 continue

      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) call prror(36)

      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &return

        do l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
          y0(l)=y(1,l)
        end do

        call matrix(dpp,am)

        if(ierro.ne.0) call prror(36)

        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=two-am(ll-1,ll-1)-am(ll,ll)
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue

   40 continue
!-----------------------------------------------------------------------
      return
      end

+dk combel
      subroutine combel(iql)
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer ico,ico0,iql,j,m
+ca parpro
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 20 j=1,icoe
        ico0=icomb0(j)
        if(iql.ne.ico0) goto 20
        do 10 m=1,20
          ico=icomb(j,m)
          if(ico.eq.0) goto 10
          if(kz(ico0).ne.kz(ico)) call prror(14)
          if(abs(el(ico0)).gt.pieni) then
            if(abs(el(ico)).gt.pieni) then
              ek(ico)=ek(ico0)*ratio(j,m)
            else
              ed(ico)=ek(ico0)*ratio(j,m)
            endif
          endif
          if(abs(el(ico0)).le.pieni) then
            if(abs(el(ico)).le.pieni) then
              ed(ico)=ed(ico0)*ratio(j,m)
            else
              ek(ico)=ed(ico0)*ratio(j,m)
            endif
          endif
   10   continue
   20 continue
!-----------------------------------------------------------------------
      return
      end

+dk envar
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!  Rewritten from computed goto to select case 16/11/2017, VKBO
!-----------------------------------------------------------------------
subroutine envar(dpp)
    
    use floatPrecision
    use numerical_constants
    use mathlib_bouncer
    
    implicit none
    integer i,ih,kz1,l,ll
    real(kind=fPrec) afok,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
    
+ca parpro
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
    save
    
    dpd  = one+dpp
    dpsq = sqrt(dpd)
    do i=1,il
        do ll=1,6
            do l=1,2
                a(i,l,ll)=zero
            end do
        end do
        if (abs(el(i)).le.pieni) then ! NONLINEAR INSERTION
            sm(i)=ed(i)
            cycle
        end if
        
        kz1 = kz(i)+1
        select case(kz1)
        case (1) ! DRIFTLENGTH
            do l=1,2
                a(i,l,1) = one
                a(i,l,2) = el(i)
                a(i,l,3) = zero
                a(i,l,4) = one
            end do
            
        case (2, 4, 5, 6)
            ! 2: RECTANGULAR MAGNET 
            ! 4: SEKTORMAGNET
            ! 5: RECTANGULAR MAGNET VERTICAL
            ! 6: SEKTORMAGNET VERTICAL
            fok = el(i)*ed(i)/dpsq
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            rho = (one/ed(i))*dpsq
            si  = sin_mb(fok)
            co  = cos_mb(fok)
            g   = tan_mb(fok*half)/rho
            gl  = el(i)*g
            select case (kz1)
            case (2)
                ! HORIZONTAL
                a(i,1,1) = one
                a(i,1,2) = rho*si
                a(i,1,3) = zero
                a(i,1,4) = one
                a(i,1,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                a(i,1,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                a(i,2,1) = one-gl
                a(i,2,2) = el(i)
                a(i,2,3) = (-one*g)*(two-gl) ! hr06
                a(i,2,4) = a(i,2,1)
            case (4)
                ! HORIZONTAL
                a(i,1,1) = co
                a(i,1,2) = rho*si
                a(i,1,3) = (-one*si)/rho              ! hr06
                a(i,1,4) = co
                a(i,1,5) = ((-one*rho)*(one-co))/dpsq ! hr06
                a(i,1,6) = (-one*si)/dpsq             ! hr06
                ! VERTICAL
                a(i,2,1) = one
                a(i,2,2) = el(i)
                a(i,2,3) = zero
                a(i,2,4) = one
            case (5)
                ! HORIZONTAL
                a(i,2,1) = one
                a(i,2,2) = rho*si
                a(i,2,3) = zero
                a(i,2,4) = one
                a(i,2,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                a(i,2,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTIKAL
                a(i,1,1) = one-gl
                a(i,1,2) = el(i)
                a(i,1,3) = (-one*g)*(two-gl) ! hr06
                a(i,1,4) = a(i,1,1)
            case (6)
                ! HORIZONTAL
                a(i,2,1) = co
                a(i,2,2) = rho*si
                a(i,2,3) = (-one*si)/rho              ! hr06
                a(i,2,4) = co
                a(i,2,5) = ((-one*rho)*(one-co))/dpsq ! hr06
                a(i,2,6) = (-one*si)/dpsq             ! hr06
                ! VERTIKAL
                a(i,1,1) = one
                a(i,1,2) = el(i)
                a(i,1,3) = zero
                a(i,1,4) = one
            end select
            
        case (3) ! QUADRUPOLE
            fok=ek(i)/(one+dpp)
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            ih = 0
            hi = sqrt(abs(fok))
            fi = el(i)*hi
            if(fok.gt.zero) goto 110
    100     ih = ih+1
            a(i,ih,1) = cos_mb(fi)
            hi1 = sin_mb(fi)
            a(i,ih,2) = hi1/hi
            a(i,ih,3) = (-one*hi1)*hi  ! hr06
            a(i,ih,4) = a(i,ih,1)
            if(ih.eq.2) cycle
            !--DEFOCUSSING
    110     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = hs/hi
            a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            if(ih.eq.1) goto 100
            
        case (7, 8)
            ! 7: COMBINED FUNCTION MAGNET HORIZONTAL
            ! 8: COMBINED FUNCTION MAGNET VERTICAL
            if (kz1.eq.7) then
                ih   = 0
                fokq = ek(i)
            else
                ih   = 1
                fokq = -one*ek(i) ! hr06
            end if
            wf  = ed(i)/dpsq
            fok = fokq/dpd-wf**2  ! hr06
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            afok = abs(fok)
            hi   = sqrt(afok)
            fi   = hi*el(i)
            if(fok.gt.zero) goto 160
    140     ih = ih+1
            si = sin_mb(fi)
            co = cos_mb(fi)
            a(i,ih,1) = co
            a(i,ih,2) = si/hi
            a(i,ih,3) = (-one*si)*hi                     ! hr06
            a(i,ih,4) = co
            a(i,ih,5) = (((-one*wf)/afok)*(one-co))/dpsq ! hr06
            a(i,ih,6) = (((-one*wf)/hi)*si)/dpsq         ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = el(i)
            if(abs(hi).le.pieni) goto 150
            a(i,ih,2) = hs/hi
    150     a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            cycle
            ! DEFOCUSSING
    160     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = hs/hi
            a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            a(i,ih,5) = ((wf/afok)*(one-hc))/dpsq ! hr06
            a(i,ih,6) = (((-one*wf)/hi)*hs)/dpsq  ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            si = sin_mb(fi)
            co = cos_mb(fi)
            a(i,ih,1) = co
            a(i,ih,2) = si/hi
            a(i,ih,3) = (-one*si)*hi ! hr06
            a(i,ih,4) = co
            
        case (9) ! EDGE FOCUSSING
            rhoi = ed(i)/dpsq
            fok  = rhoi*tan_mb((el(i)*rhoi)*half) ! hr06
            a(i,1,1) = one
            a(i,1,2) = zero
            a(i,1,3) = fok
            a(i,1,4) = one
            a(i,2,1) = one
            a(i,2,2) = zero
            a(i,2,3) = -one*fok ! hr06
            a(i,2,4) = one
            
        end select
    end do
    call block
    return
    
end subroutine envar

+dk envardis
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!  Rewritten from computed goto to select case 16/11/2017, VKBO
!-----------------------------------------------------------------------
subroutine envardis(dpp,aeg,bl1eg,bl2eg)
    
    use floatPrecision
    use numerical_constants
    use mathlib_bouncer
    
    implicit none
    integer i,ih,kz1,l,ll
    real(kind=fPrec) aeg,afok,bl1eg,bl2eg,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
+ca parpro
+ca common
+ca commons
+ca commont1
    dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
+if bnlelens
+ca rhicelens
+ei
    save
    
    dpd  = one+dpp
    dpsq = sqrt(dpd)
    do i=1,il
        do ll=1,6
            do l=1,2
              aeg(i,l,ll) = zero
            end do
        end do
        if(abs(el(i)).le.pieni) cycle
        kz1 = kz(i)+1
        select case (kz1)
        case (1)
            do l=1,2
                aeg(i,l,1) = one
                aeg(i,l,2) = el(i)
                aeg(i,l,3) = zero
                aeg(i,l,4) = one
            end do
            
        case (2, 4, 5, 6)
            ! 2: RECTANGULAR MAGNET
            ! 4: SEKTORMAGNET
            ! 5: RECTANGULAR MAGNET VERTICAL
            ! 6: SEKTORMAGNET VERTICAL
            fok = el(i)*ed(i)/dpsq
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
            end if
            rho = (one/ed(i))*dpsq
            si  = sin_mb(fok)
            co  = cos_mb(fok)
            select case (kz1)
            case (2)
                ! HORIZONTAL
                aeg(i,1,1) = one
                aeg(i,1,2) = rho*si
                aeg(i,1,3) = zero
                aeg(i,1,4) = one
                aeg(i,1,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                aeg(i,1,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                g  = tan_mb(fok*half)/rho
                gl = el(i)*g
                aeg(i,2,1) = one-gl
                aeg(i,2,2) = el(i)
                aeg(i,2,3) = (-one*g)*(two-gl)                  ! hr06
                aeg(i,2,4) = aeg(i,2,1)
            case (4)
                ! HORIZONTAL
                aeg(i,1,1)=co
                aeg(i,1,2)=rho*si
                aeg(i,1,3)=(-one*si)/rho                        ! hr06
                aeg(i,1,4)=co
                aeg(i,1,5)=((-one*rho)*(one-co))/dpsq           ! hr06
                aeg(i,1,6)=(-one*si)/dpsq                       ! hr06
                ! VERTICAL
                aeg(i,2,1)=one
                aeg(i,2,2)=el(i)
                aeg(i,2,3)=zero
                aeg(i,2,4)=one
            case (5)
                ! HORIZONTAL
                aeg(i,2,1) = one
                aeg(i,2,2) = rho*si
                aeg(i,2,3) = zero
                aeg(i,2,4) = one
                aeg(i,2,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                aeg(i,2,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                g  = tan_mb(fok*half)/rho
                gl = el(i)*g
                aeg(i,1,1) = one-gl
                aeg(i,1,2) = el(i)
                aeg(i,1,3) = (-one*g)*(two-gl)                  ! hr06
                aeg(i,1,4) = aeg(i,1,1)
            case (6)
                ! HORIZONTAL
                aeg(i,2,1)=co
                aeg(i,2,2)=rho*si
                aeg(i,2,3)=(-one*si)/rho                        ! hr06
                aeg(i,2,4)=co
                aeg(i,2,5)=((-one*rho)*(one-co))/dpsq           ! hr06
                aeg(i,2,6)=(-one*si)/dpsq                       ! hr06
                ! VERTICAL
                aeg(i,1,1)=one
                aeg(i,1,2)=el(i)
                aeg(i,1,3)=zero
                aeg(i,1,4)=one
            end select
            
        case (3) ! QUADRUPOLE
            ! FOCUSSING
            fok = ek(i)/(one+dpp)
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
                cycle
            end if
            ih = 0
            hi = sqrt(abs(fok))
            fi = el(i)*hi
            if(fok.gt.zero) goto 110
    100     ih = ih+1
            aeg(i,ih,1) = cos_mb(fi)
            hi1 = sin_mb(fi)
            aeg(i,ih,2) = hi1/hi
            aeg(i,ih,3) = (-one*hi1)*hi ! hr06
            aeg(i,ih,4) = aeg(i,ih,1)
            if(ih.eq.2) cycle
            ! DEFOCUSSING
    110     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = hs/hi
            aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            if(ih.eq.1) goto 100
            
        case (7, 8)
            ! 7: COMBINED FUNCTION MAGNET HORIZONTAL
            ! 8: COMBINED FUNCTION MAGNET VERTICAL
            if (kz1.eq.7) then
                ih   = 0
                fokq = ek(i)
            else
                ih   = 1
                fokq = -one*ek(i)      ! hr06
            end if
            wf  = ed(i)/dpsq
            fok = fokq/dpd-wf**2       ! hr06
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
                cycle
            end if
            afok = abs(fok)
            hi   = sqrt(afok)
            fi   = hi*el(i)
            if(fok.gt.zero) goto 160
    140     ih = ih+1
            si = sin_mb(fi)
            co = cos_mb(fi)
            aeg(i,ih,1) = co
            aeg(i,ih,2) = si/hi
            aeg(i,ih,3) = (-one*si)*hi                      ! hr06
            aeg(i,ih,4) = co
            aeg(i,ih,5) = (((-one*wf)/afok)*(one-co))/dpsq  ! hr06
            aeg(i,ih,6) = (((-one*wf)/hi)*si)/dpsq          ! hr06
            ih = ih+1
            if(ih.gt.2) ih=1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = el(i)
            if(abs(hi).le.pieni) goto 150
            aeg(i,ih,2) = hs/hi
    150     aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            ! DEFOCUSSING
    160     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = hs/hi
            aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            aeg(i,ih,5) = ((wf/afok)*(one-hc))/dpsq ! hr06
            aeg(i,ih,6) = (((-one*wf)/hi)*hs)/dpsq  ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            si = sin_mb(fi)
            co = cos_mb(fi)
            aeg(i,ih,1) = co
            aeg(i,ih,2) = si/hi
            aeg(i,ih,3) = (-one*si)*hi              ! hr06
            aeg(i,ih,4) = co
            
        case (9) ! EDGE FOCUSSING
            rhoi = ed(i)/dpsq
            fok  = rhoi*tan_mb((el(i)*rhoi)*half) ! hr06
            aeg(i,1,1) = one
            aeg(i,1,2) = zero
            aeg(i,1,3) = fok
            aeg(i,1,4) = one
            aeg(i,2,1) = one
            aeg(i,2,2) = zero
            aeg(i,2,3) = -one*fok
            aeg(i,2,4) = one
            
        end select
    end do
    call blockdis(aeg,bl1eg,bl2eg)
    return
    
end subroutine envardis

+dk error
!-----------------------------------------------------------------------
!  ERROR OUTPUT
!-----------------------------------------------------------------------
subroutine prror(ier)
    
    use floatPrecision
    use numerical_constants
    use mathlib_bouncer
    use, intrinsic :: iso_fortran_env, only : error_unit

+if fluka
    ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
    ! last modified: 17-07-2013
    ! import mod_fluka
    ! inserted in main code by the 'fluka' compilation flag
    use mod_fluka
+ei

      use crcoall
      implicit none
      integer ier
+ca parpro
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei

+if fluka
    ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
    ! last modified: 17-07-2013
    ! status of connection
    ! inserted in main code by the 'fluka' compilation flag
    integer fluka_con
+ei

+ca errout
    save

    errout_status = ier
    write(lout,10000)
    select case (ier)
    case (1)
        write(lout,10010)
    case (2)
        write(lout,10020) nele
    case (3)
        write(lout,10030)
    case (4)
        write(lout,10040)
    case (5)
        write(lout,10050)
    case (6)
        write(lout,10060)
    case (7)
        write(lout,10070)
    case (8)
        write(lout,10080)
    case (9)
        write(lout,10090)
    case (10)
        write(lout,10100)
    case (11)
        write(lout,10110)
    case (12)
        write(lout,10120)
    case (13)
        write(lout,10130)
    case (14)
        write(lout,10140)
    case (15)
        write(lout,10150)
    case (16)
        write(lout,10160) nele
    case (17)
        write(lout,10170) nper
    case (18)
        write(lout,10180) nblo
    case (19)
        write(lout,10190) erbez
    case (20)
        write(lout,10200) erbez
    case (21)
        write(lout,10210)
    case (22)
        write(lout,10220)
    case (23)
        write(lout,10230)
    case (24)
        write(lout,10240)
    case (25)
        write(lout,10250)
    case (26)
        write(lout,10260) nelb
    case (27)
        write(lout,10270)
    case (28)
        write(lout,10280)
    case (29)
        write(lout,10290)
    case (30)
        write(lout,10300) nran
    case (31)
        write(lout,10310)
    case (32)
        write(lout,10320)
    case (33)
        write(lout,10330)
    case (34)
        write(lout,10340) mran
    case (35)
        write(lout,10350)
    case (36)
        write(lout,10360)
    case (37)
        write(lout,10370)
    case (38)
        write(lout,10380)
    case (39)
        write(lout,10390)
    case (40)
        write(lout,10400)
    case (41)
        write(lout,10410)
    case (42)
        write(lout,10420)
    case (43)
        write(lout,10430) nzfz
    case (44)
        write(lout,10440)
    case (45)
        write(lout,10450)
    case (46)
        write(lout,10460) nrco
    case (47)
        write(lout,10470)
    case (48)
        write(lout,10480)
    case (49)
        write(lout,10490)
    case (50)
        write(lout,10500)
    case (51)
        write(lout,10510)
    case (52)
        write(lout,10520) nema
    case (53)
        write(lout,10530)
    case (54)
        write(lout,10540) npart
    case (55)
        write(lout,10550) nmac
    case (56)
        write(lout,10560) ierro
    case (57)
        write(lout,10570) ierro
    case (58)
        write(lout,10580) ierro
    case (59)
        write(lout,10590) ierro
    case (60)
        write(lout,10600) ierro
    case (61)
        write(lout,10610) ierro
    case (62)
        write(lout,10620)
    case (63)
        write(lout,10630)
    case (64)
        write(lout,10640)
    case (65)
        write(lout,10650) mcor
    case (66)
        write(lout,10660)
    case (67)
        write(lout,10670)
    case (68)
        write(lout,10680)
    case (69)
        write(lout,10690)
    case (70)
        write(lout,10700)
    case (71)
        write(lout,10710)
    case (72)
        write(lout,10720)
    case (73)
        write(lout,10730)
    case (74)
        write(lout,10740)
    case (75)
        write(lout,10750)
    case (76)
        write(lout,10760)
    case (77)
        write(lout,10770)
    case (78)
        write(lout,10780)
    case (79)
        write(lout,10790)
    case (80)
        write(lout,10800)
    case (81)
        write(lout,10810)
    case (82)
        write(lout,10820)
    case (83)
        write(lout,10830)
    case (84)
        write(lout,10840)
    case (85)
        write(lout,10850) mmul
    case (86)
        write(lout,10860)
    case (87)
        write(lout,10870)
    case (88)
        write(lout,10880)
    case (89)
        write(lout,10890)
    case (90)
        write(lout,10900)
    case (91)
        write(lout,10910)
    case (92)
        write(lout,10920)
    case (93)
        write(lout,10930)
    case (94)
        write(lout,10940)
    case (95)
        write(lout,10950)
    case (96)
        write(lout,10960)
    case (97)
        write(lout,10970)
    case (98)
        write(lout,10980)
    case (99)
        write(lout,10990)
    case (100)
        write(lout,11000) ntr
    case (101)
        write(lout,11010)
    case (102)
        write(lout,11020) nbb
    case (103)
        write(lout,11030)
    case (104)
        write(lout,11040)
    case (105)
        write(lout,11050) mmul
    end select
    
+if fluka
+ca flukaclose
+ei
    call closeUnits
+if cr
    call abend('                                                  ')
+ei
+if .not.cr
    write(error_unit,'(a,i5)') "Stopping, errout_status=",errout_status
    stop 1
+ei

10000 format(5x///t10,'++++++++++++++++++++++++'/t10,'+++++ERROR DETECTED+++++'/&
                  t10,'++++++++++++++++++++++++'/t10,'RUN TERMINATED ABNORMALLY !!!'//)
10010 format(t10,'WRONG MODE DEFINITION')
10020 format(t10,'NOT MORE THAN: ',i4,' POSITIONS FOR RESONANCE-COMPENSATION ALLOWED')
10030 format(t10,'ELEMENT FOR RESONANCE-COMPENSATION IS NOT IN THE ELEMENTLIST')
10040 format(t10,'UNSTABLE CLOSED ORBIT DURING INITIAL DISPERSION CALCULATION'/&
             t10,'INSTABILITY OCCURRED FOR SMALL RELATIVE ENERGY DEVIATION')
10050 format(t10,'UNSTABLE CLOSED ORBIT FOR ZERO ENERGY DEVIATION')
10060 format(t10,'UNSTABLE CLOSED ORBIT DURING DISPERSION CALCULATION AFTER ORBIT SCALING'/&
             t10,'INSTABILITY OCCURRED FOR SMALL RELATIVE ENERGY DEVIATION')
10070 format(t10,'UNSTABLE CLOSED ORBIT AFTER ORBIT SCALING')
10080 format(t10,'ELEMENTS SPECIFIED FOR TUNE VARIATION ARE NOT QUADRUPOLES')
10090 format(t10,'UNSTABLE CLOSED ORBIT DURING TUNE VARIATION')
10100 format(t10,'NO OPTICAL SOLUTION DURING TUNE VARIATION')
10110 format(t10,'ELEMENTS SPECIFIED FOR CHROMATICITY CORRECTION ARE NOT SEXTUPOLES')
10120 format(t10,'UNSTABLE CLOSED ORBIT DURING CHROMATICITY CORRECTION')
10130 format(t10,'NO OPTICAL SOLUTION DURING CHROMATICITY CORRECTION')
10140 format(t10,'ELEMENTS OF DIFFERENT TYPES ARE COMBINED IN DATA BLOCK COMBINATION OF ELEMENTS')
10150 format(t10,'UNKNOWN BLOCK SPECIFICATION')
10160 format(t10,'NO. OF SINGLE ELEMENTS EXCEEDS THE MAXIMUM ALLOWED VALUE: ',i4)
10170 format(t10,'NO. OF SUPER PERIODS LARGER THAN : ',i4)
10180 format(t10,'NO. OF DIFFERENT BLOCKS EXCEEDS THE MAXIMUM ALLOWED VALUE: ',i5)
10190 format(t10,'UNKNOWN SINGLE ELEMENT : ',a16,' IN THE BLOCK DEFINITION')
10200 format(t10,'UNKNOWN BLOCK NAME OR INSERTION NAME : ',a16,' IN THE STRUCTURE INPUT')
10210 format(t10,'MAXIMUM NUMBER OF STRUCTURE ELEMENTS SURPASSED')
10220 format(t10,'NO SOLUTION FOR ORBIT SCALING - POSSIBLE REASONS:'/t10,'--> DIPOLE STRENGTHS OF NON-CORRECTOR ELEMENTS TO HIGH'/&
             t10,'--> NON-LINEARITIES TOO STRONG, TRY TO INCREASE INITIAL'/t10,'    CORRECTOR STRENGTHS'/&
             t10,'--> USE ALL DIPOLE ELEMENTS FOR SCALING'/)
10230 format(t10,'NO OPTICAL SOLUTION')
10240 format(t10,'NO SOLUTION FOR DISPERSION')
10250 format(t10,'--> PLEASE INCLUDE LENGTH OF MACHINE IN THE <SYNCHROTRON>-BLOCK')
10260 format(t10,'ONE BLOCK CAN NOT HAVE MORE THAN ',i4,' ELEMENTS')
10270 format(t10,'KINETIC ENERGY OF THE PARTICLE IS LESS OR EQUAL ZERO')
10280 format(t10,'EITHER YOUR RF-FREQUENCY IS SHIFTED BY 180 DEGREES'/,&
             t10,'THEN CHANGE THE SIGN OF <ITION> IN THE <SYNCHROTRON>-INPUTBLOCK',/&
             t10,'OR YOUR ALFA-P IS WRONGLY INTRODUCED IN THE SAME INPUTBLOCK')
10290 format(t10,'MULTIPOLE COEFFICIENTS CANNOT BE SET EQUAL')
10300 format(t10,'THE RANDOM NUMBER: ',i6,' FOR THE INITIAL STRUCTURE IS TOO SMALL')
10310 format(t10,'ELEMENTS THAT NEED RANDOM NUMBERS HAVE A KZ > 0')
10320 format(t10,'THERE ARE NOT ENOUGH RANDOM NUMBERS FOR THE INSERTED ELEMENTS')
10330 format(t10,'TO USE THE SAME RANDOM NUMBERS FOR 2 ELEMENTS, THE INSERTED ELEMENT ',&
                 'MUST NOT NEED MORE OF SUCH NUMBERS THAN THE REFERENCE ELEMENT')
10340 format(t10,'NOT MORE THAN',i4,' OF EACH TYPE OF INSERTED ELEMENTS CAN BE USED')
10350 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN QMOD')
10360 format(t10,'NO CONVERGENCE IN RMOD')
10370 format(t10,'CHOSEN ORDERS OF RESONANCES CAN NOT BE CALCULATED')
10380 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN RMOD')
10390 format(t10,'WITH THE SPECIFIED ELEMENTS THE RESONANCE CANNOT BE COMPENSATED - ',&
                 'RESONANCEORDER AND ELEMENTTYP # MUST BE THE SAME')
10400 format(t10,'NOT MORE THAN 2 PARTICLES CAN BE TRACKED')
10410 format(t10,'GEOMETRY AND STRENGTH FILE (UNIT 2) IS EMPTY OR DESTROYED')
10420 format(t10,'TRACKING PARAMETER FILE (UNIT 3) IS EMPTY OR NON-EXISTING')
10430 format(t10,'NOT MORE THAN ',i4,' RANDOM NUMBERS CAN BE USED')
10440 format(t10,'FOR THE INPUTBLOCK - ORBIT CORRECTION - ONLY CORRECTORS WITH THE KEYWORDS ( HCOR= ; VCOR= )'/&
             t10,'AND MONITORS WITH THE KEYWORDS ( HMON= ; VMON= ) ARE ALLOWED')
10450 format(t10,'FOR THE INPUTBLOCK - LINEAR OPTICS - ONLY THE KEYWORD ( ELEMENT ) AND ( BLOCK ) ARE ALLOWED')
10460 format(t10,'ORDER OF COMPENSATION CAN NOT BE LARGER THAN : ',i4)
10470 format(t10,'ONLY UP TO 3 RESONANCES CAN BE COMPENSATED')
10480 format(t10,'RESONANCE TYPE IS OUT OF THE RANGE OF THE RESONANCE ORDER')
10490 format(t10,'ONLY UP TO 3 SUB-RESONANCES CAN BE COMPENSATED')
10500 format(t10,'THE MULTIPOLE ORDER FOR THE SUB-RESONANCE COMPENSATION SHOULD NOT EXCEED THE VALUE 9')
10510 format(t10,'PROBLEMS WITH FILE 3 WITH DYNAMIC KICKS')
10520 format(t10,'MAXIMUM ORDER OF THE ONE TURN MAP IS ',i4,/,' NEMA HAS TO BE LARGER THAN NORD')
10530 format(t10,'# OF VARIABLES -NV- OF THE ONE TURN MAP IS NOT IN THE ALLOWED RANGE [2 <= NV <= 5]')
10540 format(t10,'MAXIMUM NUMBER OF PARTICLES FOR VECTORIZATION', ' IS ',i7)
10550 format(t10,'MAXIMUM NUMBER OF DIFFERENT SEEDS FOR VECTORIZATION IS ',i4)
10560 format(t10,'PROBLEMS WITH FILE 13 WITH INITIAL COORDINATES - ERROR CODE : ',i10)
10570 format(t10,'PROBLEMS WITH FILE 2 WITH ACCELERATOR STRUCTURE - ERROR CODE : ',i10)
10580 format(t10,'PROBLEMS WITH FILE 3 WITH TRACKING PARAMETERS - ERROR CODE : ',i10)
10590 format(t10,'PROBLEMS WITH FILE 11 FOR CRAY INPUT - ERROR CODE : ',i10)
10600 format(t10,'PROBLEMS WITH FILE 99 FOR BINARY OUTPUT - ERROR CODE : ',i10)
10610 format(t10,'PROBLEMS WITH FILE 12 FOR END COORDINATES - ERROR CODE : ',i10)
10620 format(t10,'ELEMENTS SPECIFIED FOR DECOUPLING ARE NOT SKEW QUADRUPOLES')
10630 format(t10,'THERE ARE THE APPROPRIATE ELEMENTS FOR THE DECOUPLING OR SIMULTANEOUS TUNE ADJUSTMENT')
10640 format(t10,'PROBLEMS DURING MATRIX-INVERSION IN DECOUP')
10650 format(t10,'MAXIMUM NUMBER OF EXTRA PARAMETERS IS : ',i4)
10660 format(t10,'EXTRA PARAMETERS FOR THE MAP DOES NOT EXIST')
10670 format(t10,'ONLY SINGLE KICK ELEMENTS ALLOWED FOR MAP CALCULATION')
10680 format(t10,'THE ORDER OF THE NORMAL FORM IS TOO HIGH. CHECK THE DIFFERENTIAL ALGEBRA PARAMETERS')
10690 format(t10,'TOO MANY VARIABLES SPECIFIED. CHECK THE DIFFERENTIAL ALGEBRA PARAMETERS')
10700 format(t10,'NO CORRECTORS SPECIFIED')
10710 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE ZERO!')
10720 format(t10,'BOTH AMPLITUDE AND MOMENTUM ORDER ARE DIFFERENT FROM ZERO!')
10730 format(t10,'AMPLITUDE ORDER OUTSIDE RANGE [0,2]')
10740 format(t10,'MOMENTUM ORDER OUTSIDE RANGE [0,3] (ONE EXCLUDED!)')
10750 format(t10,'MINIMUM ORDER OUTSIDE RANGE [2,3]')
10760 format(t10,'MINIMUM ORDER GREATER THAN MAXIMUM!')
10770 format(t10,'MAXIMUM ORDER OUTSIDE RANGE [2,3]')
10780 format(t10,'NORMAL FORMS ANALYSIS IMPOSSIBLE',/,t10,'THE TRANSFER MAP DOES NOT EXIST!')
10790 format(t10,'ZERO OR NEGATIVE ENERGY DOES NOT MAKE MUCH SENSE')
10800 format(t10,'PROBLEM READING EXTERNAL MULTIPOLE ERRORS')
10810 format(t10,'TOO MANY ELEMENTS FOR LINEAR OPTICS WRITE-OUT')
10820 format(t10,'FOR CLOSED ORBIT CORRECTORS ONLY DIPOLES OF LEGTH ZERO OR MULTIPOLE LENSES ALLOWED')
10830 format(t10,'AN ELEMENT FOR CLOSED ORBIT CORRECTION CAN BE ONLY EITHER A HORIZONTAL MONITOR',/,&
             t10,'OR A VERTICAL MONITOR OR A HORIZONTAL CORRECTOR OR A VERTICAL CORRECTOR')
10840 format(t10,'NUMBER OF ORBIT CORRECTORS IS ZERO')
10850 format(t10,'THE ORDER OF MULTIPOLES MMUL: ',i4,' HAS TO BE LARGER THAN 10 BUT SMALLER THAN 20')
10860 format(t10,'PROBLEM READING EXTERNAL MISALIGNMENTS')
10870 format(t10,'PROBLEM READING FROM FILE 30 (SINGLE KICKS AND MISALIGNMENTS')
10880 format(t10,'BEAM_BEAM: EITHER NORMALIZED EMITTANCES OR THE RESULTING SIGMA VALUES EQUAL TO ZERO')
10890 format(t10,'BEAM_BEAM: AT EACH INTERACTION POINT THE BEAM MUST BE EITHER ROUND OR ELLIPTICAL FOR ALL PARTICLES')
10900 format(t10,'QUADRUPOLES ARE NOT SUITED TO ADJUST THE TUNES')
10910 format(t10,'ORDER AND NUMBER OF VARIABLES HAVE TO BE LARGER THAN ZERO TO CALCULATE A DIFFERENTIAL ALGEBRA MAP')
10920 format(t10,'YOU CANNOT COMBINE AN ELEMENT WITH ITSELF')
10930 format(t10,'INVERTED LINEAR BLOCKS NOT ALLOWED')
10940 format(t10,'  NUMBER OF NORMAL FORM VARIABLES HAVE TO BE: 2, 4, 5, 6 + PARAMETERS')
10950 format(t10,'  DA CORRECTIONS IMPLEMENTED FOR 4-D AND 6-D ONLY ')
10960 format(t10,'SEXTUPOLES ARE NOT SUITED TO ADJUST THE CHROMATICITY')
10970 format(t10,'UNSTABLE CLOSED ORBIT IN DA CALCULATION')
10980 format(t10,'TROMBONE ELEMENT NOT IN LIST OF SINGLE ELEMENTS')
10990 format(t10,'INCOMPLETE PARAMETERS FOR TROMBONE ELEMENT')
11000 format(t10,'MAXIMUM NUMBER OF TROMBONES EXCEEDED : NTR = ',i4)
11010 format(t10,'AMPLITUDES EXCEED THE MAXIMUM VALUES IN UMLAUF')
11020 format(t10,'MAXIMUM ELEMENT NUMBER FOR BEAM_BEAM WITH COUPLING EXCEEDED:  NBB = ',i4)
11030 format(t10,'6D BEAM-BEAM WITH TILT NOT POSSIBLE')
11040 format(t10,'SINGLE ELEMENT NAME LONGER THAN 16 CHARACTERS')
11050 format(t10,'THE INPUT ORDER OF MULTIPOLES IS LARGER THAN THE MAXIMUM ALLOWED ORDER MMUL: ',i4)

end subroutine prror

+dk readdis
subroutine dist_readdis( napx, npart, enom, pnom, clight, x, y, xp, yp, s, pc )
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 07-02-2014
!     read a beam distribution
!     always in main code
!
!     Format of the input file:
!       id:         unique identifier of the particle (integer)
!       gen:        parent ID (integer)
!       weight:     statistical weight of the particle (double: >0.0)
!       x,  y,  s:  particle position  [m]
!       xp, yp, zp: particle direction (tangents) []
!       aa, zz:     mass and atomic number
!       m:          rest mass [GeV/c2]
!       pc:         particle momentum [GeV/c]
!       dt:         time delay with respect to the reference particle [s]
!
!     NOTA BENE:
!     - id, gen and weight are assigned by the fluka_mod_init subroutine;
!     - z and zp are actually useless (but we never know);
!     - aa, zz and m are not stored at the moment (safer decision from the code
!       point of view, until a decision about ion tracking is taken);
!       the subroutine fluka_send is then responsible for using the corresponding
!       values for protons through the interface, whereas the subroutine fluka_receive
!       simply ignores the values passed through the FlukaIO interface;
!
!     variables in input to routine:
!     - napx: number of protons to be tracked (from fort.3 file);
!     - npart: max number of protons that can be tracked (array dimensioning);
!     - enom: nominal total energy of the beam (ie of synch particle) [MeV];
!     - pnom: nominal linear momentum of the beam (ie of synch particle) [MeV/c];
!     - clight: speed of light [m/s];
!     NB: in case the file contains less particle than napx, napx is
!         re-assigned 
!
!     output variables:
!       all other variables in the interface (6D tracking variables);
!
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants

      use crcoall
  implicit none

+ca dbreaddis

! interface variables:
  integer napx, npart
  real(kind=fPrec) enom, pnom, clight
  real(kind=fPrec) x, y, xp, yp, s, pc

! temporary variables:
  integer id, gen, aa, zz
  real(kind=fPrec) weight, z, zp, m, dt
  integer jj
  character(240) tmp_line

  character comment_char
  parameter ( comment_char = '*' )

  dimension x ( npart ), y ( npart )
  dimension xp( npart ), yp( npart )
  dimension s ( npart ), pc( npart )
  dimension dt( npart )

  write(lout,*) ''
  write(lout,*) "Reading particles from ", dist_filename

! initialise tracking variables:
  do jj=1,npart
    x (jj) = zero
    y (jj) = zero
    xp(jj) = zero
    yp(jj) = zero
    pc(jj) = zero
    s (jj) = zero
  end do

! initialise particle counter
  jj = 0

  open( unit=dist_read_unit, file=dist_filename )

! cycle on lines in file:
1981 continue
  read(dist_read_unit,'(A)',end=1983,err=1982) tmp_line
  if( tmp_line(1:1).eq.comment_char ) goto 1981
  jj = jj+1

  if( jj.gt.npart ) then
    write(lout,*) 'Error while reading particles'
    write(lout,*) 'not enough memory for all particles in file'
    write(lout,*) 'please increase the npart parameter and recompile'
    write(lout,*) 'present value:', npart
    jj = npart
    goto 1984
  else if( jj.gt.napx ) then
    write(lout,*) ''
    write(lout,*) 'Stopping reading file, as already ', napx
    write(lout,*) ' particles have been read, as requested by the user'
    write(lout,*) ' in fort.3 file'
    write(lout,*) ''
    jj = napx
    goto 1983
  end if

  read( tmp_line, *, err=1982 ) id, gen, weight, x(jj), y(jj), z, xp(jj), yp(jj), zp, aa, zz, m, pc(jj), dt(jj)
  goto 1981

! error while parsing file:
1982 continue
  write(lout,*) 'Error while reading particles at line:'
  write(lout,*) tmp_line
  goto 1984

1983 continue
  if( jj.eq.0 ) then
    write(lout,*) 'Error while reading particles'
    write(lout,*) 'no particles read from file'
    goto 1984
  end if

  close(dist_read_unit)
  write(lout,*) "Number of particles read = ", jj

  if( jj.lt.napx ) then
    write(lout,*) ''
    write(lout,*) 'Warning: read a number of particles'
    write(lout,*) '         LOWER than the one requested for tracking'
    write(lout,*) '         requested:',napx
    write(lout,*) ''
    napx = jj
  end if

! fix units:
  do jj=1,napx
    x (jj) = x(jj)  * c1e3 ! [m]     -> [mm]
    y (jj) = y(jj)  * c1e3 ! [m]     -> [mm]
    xp(jj) = xp(jj) * c1e3 ! []      -> [1.0E-03]
    yp(jj) = yp(jj) * c1e3 ! []      -> [1.0E-03]
    pc(jj) = pc(jj) * c1e3 ! [GeV/c] -> [MeV/c]
    s (jj) = -pnom/enom * dt(jj)*clight * c1e3
  end do

  return

! exit with error
1984 continue
  close(dist_read_unit)
  call prror(-1)
  return
end subroutine dist_readdis

+dk cadcum
      subroutine cadcum
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 13-06-2014
!     calculate dcum, as done in linopt and when parsing BLOCs (daten):
!         lengths of thick lens elements are taken on the curvilinear
!         reference system; thus, no difference between the length
!         of SBENDs and the one of RBENDs, as they are both the ARC one;
!     for future needs:
!                ds=two/ed(ix)*asin(el(ix)*ed(ix)/two)
!     always in main code
!-----------------------------------------------------------------------
!
      use floatPrecision
  use numerical_constants
      use crcoall
      implicit none

+ca parpro
+ca common
+ca dbdcum
      save

!     temporary variables
      real(kind=fPrec) tmpdcum, ds
      integer ientry, jentry, kentry, ix

      write(lout,*)''
      write(lout,10010)
      write(lout,*)''
      write(lout,*)' CALL TO CADCUM'
      write(lout,*)''

!     initialise cumulative length
      tmpdcum=zero

!     loop all over the entries in the accelerator structure
      do ientry=1,iu
        ix=ic(ientry)
        if(ix.gt.nblo) then
!         SINGLE ELEMENT
          ix=ix-nblo
          if ( el(ix).gt.zero ) tmpdcum=tmpdcum+el(ix)
        else
!         BLOC: iterate over elements
          do jentry=1,mel(ix)
            kentry=mtyp(ix,jentry)
            if( el(kentry).gt.zero ) tmpdcum=tmpdcum+el(kentry)
          enddo
        endif
!       assign value of dcum
        dcum(ientry)=tmpdcum
!     go to next entry in the acclerator structure
      enddo

!     assign the last value to the closing MARKER:
      dcum(iu+1)=tmpdcum

      if ( print_dcum ) then
!       a useful printout
        write(lout,10030)'ientry','ix','name            ','dcum [m]'
        write(lout,10020) 0,-1,'START           ',dcum(0)
        do ientry=1,iu
          ix=ic(ientry)
          if(ix.gt.nblo) then
!            SINGLE ELEMENT
             ix=ix-nblo
             write(lout,10020) ientry,ix,bez(ix),dcum(ientry)
          else
!            BLOC
             write(lout,10020) ientry,ix,bezb(ix),dcum(ientry)
          endif
        enddo
        write(lout,10020) iu+1,-1,'END            ',dcum(iu+1)
        write(lout,*)     ''
      else                      ! Anyway print the total machine length
         write(lout,'(1x,a,1x,f17.10,1x,a)')                            &
     &        "Machine length was", dcum(iu+1),"[m]"
      endif

!     au revoir:
      return

10010 format(132('-'))
10020 format(2(1x,i6),1x,a16,1x,f12.5)
10030 format(2(1x,a6),1x,a16,1x,a12)
      end subroutine
!
+dk linopt
      subroutine linopt(dpp)
!-----------------------------------------------------------------------
!  LINEAR PARAMETERS AT THE POSITION OF EVERY ELEMENT OR BLOCK
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,iiii,im,ium,ix,izu,j,jj,jk,jm,k,kpz,kzz,l,l1,ll,        &
     &nmz,nr,dj
      real(kind=fPrec) aa,aeg,alfa,bb,benkr,beta,bexi,bezii,bl1eg,bl2eg,&
     &ci,cikve,clo0,clop0,cr,crkve,crkveuk,di00,dip00,dphi,dpp,dpp1,    &
     &dppi,dpr,dyy1,dyy2,ekk,etl,phi,phibf,pie,puf,qu,qv,qw,qwc,r0,r0a, &
     &t,xl,xs,zl,zs,quz,qvz
+if tilt
      real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
+ei
      character(len=16) idum
+ca parpro
+ca common
+ca commons
+ca commont1
!
+if collimat
+ca collpara
+ca dblinopt
+ei
!
      dimension t(6,4)
      dimension beta(2),alfa(2),phibf(2),phi(2)
      dimension clo0(2),clop0(2),di00(2),dip00(2),qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(6)
      dimension cr(mmul),ci(mmul)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      data dpr/6*zero/
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      nhmoni=0
      nvmoni=0
      nhcorr=0
      nvcorr=0
      ium=6
      pie=two*pi

      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10000)
      endif

      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phibf(i)=zero
        phi(i)=zero
        clo0(i)=zero
        clop0(i)=zero
        di00(i)=zero
        dip00(i)=zero
        qw(i)=zero
        qwc(i)=zero
      end do

      qwc(3)=zero

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      etl=zero
      dpr(1)=dpp*c1e3
      dpr(6)=one
      dpp1=dpp+ded
      call clorb(dpp1)

      do l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
      end do

      call clorb(dpp)

      do l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
        t(6,ll-1)=di0(l)
        t(6,ll)=dip0(l)
      end do

      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10050) (di0(l),dip0(l),l=1,2)
      endif

      call betalf(dpp,qw)
      call phasad(dpp,qwc)

      if(ierro.ne.0) call prror(22+ierro)
      if(ncorru.eq.0) write(lout,10040) dpp,qwc(1),qwc(2)

      call envar(dpp)

      if(ithick.eq.1) call envardis(dpp1,aeg,bl1eg,bl2eg)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

      if(ncorru.eq.0) then
        write(lout,10010)
        if(iprint.eq.1) write(lout,10030)
        write(lout,10020)
        write(lout,10010)
      endif

!--START OF THE MACHINE
      idum='START'
      nr=0
+if .not.collimat.and..not.bnlelens
      call writelin(nr,idum,etl,phi,t,1,.false.)
+ei
+if collimat.or.bnlelens
      call writelin(nr,idum,etl,phi,t,1,.false.,0)
+ei
      if(ntco.ne.0) then
        if(mod(nr,ntco).eq.0) call cpltwis(idum,t,etl,phi)
      endif


!--STRUCTURE ELEMENT LOOP
      if(nt.le.0.or.nt.gt.iu) nt=iu
      izu=0
      
      STRUCTLOOP: do k=1,nt
        ix=ic(k)
        if(ix.gt.nblo) goto 220 !Not a BLOCK
        if(ithick.eq.1.and.iprint.eq.1) goto 160

        jj=0 !initial idx
        dj=1 !step
        
        if (ix.le.0) then
           ix=-1*ix             !hr13
           jj=mel(ix)+1         !initial idx
           dj=-1                !step
        endif
        jm=mel(ix)
!-- Loop over elements inside the block
        do 150 j=1,jm
          jj=jj+dj       ! Subelement index of current sub=element
          jk=mtyp(ix,jj) ! Single-element index of the current sub-element
+if .not.bnlelens
          if(ithick.eq.1.and.kz(jk).ne.0) goto 120
+ei
+if bnlelens
!GRDRHIC
          if(ithick.eq.1.and.kz(jk).ne.0) then
             call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
             goto 120
          endif
!GRDRHIC
+ei

          if(ithick.eq.0.and.kz(jk).ne.0) then
            etl=etl+el(jk)
            
!c$$$            nr=nr+1
!c$$$+if .not.collimat.and..not.bnlelens
!c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
!c$$$+ei
!c$$$+if collimat.or.bnlelens
!c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
!c$$$+ei
!c$$$            if(ntco.ne.0) then
!c$$$              if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl,phi)
!c$$$            endif
            
            write(lout,*) "ERROR in LINOPT:"
            write(lout,*) "In block ", bezb(ix),                        &
     &           "found a thick non-drift element",                     &
     &           bez(jk), "while ithick=1. This should not be possible!"
            call prror(-1)
            cycle STRUCTLOOP
          endif

!--IN BLOCK: PURE DRIFTLENGTH (above: If ITHICK=1 and kz!=0, goto 120->MAGNETELEMENT)
          etl=etl+el(jk)

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
            if((-one*dphi).gt.pieni) dphi=dphi+pi                        !hr06
            phi(l)=phi(l)+dphi/pie
          end do

          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
          
          goto 150

!--IN BLOCK: MAGNETELEMENT
  120     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif

            puf=t(6,ll-1)
         t(6,ll-1)=(((((aeg(jk,l,1)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,2)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,5)*dpp1*c1e3)- a(jk,l,1)*t          &!hr06
     &(1,ll-1))-a(jk,l,2)*t(1,ll))- a(jk,l,5)*dpr(1))/ded                !hr06
           t(6,ll)=(((((aeg(jk,l,3)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,4)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,6)*dpp1*c1e3)- a(jk,l,3)*t          &!hr06
     &(1,ll-1))-a(jk,l,4)*t(1,ll))- a(jk,l,6)*dpr(1))/ded                !hr06

            do i=1,ium-1
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo

          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)                                         !hr06
            endif

            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
          
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
          
  150   continue !End of loop over elements inside block

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif

        cycle STRUCTLOOP

!--BETACALCULATION FOR SERIES OF BLOCKS (ix.ge.nblo.and.ithick.eq.1.and.iprint.eq.1)
  160   continue !if ithick=1 and iprint=1:
        if(ix.le.0) goto 190
!--REGULAR RUN THROUGH BLOCKS
        etl=etl+elbe(ix)

        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif

          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl1eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,5)*dpp1*c1e3)- bl1(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,2)*t(1,ll))- bl1(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl1eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,6)*dpp1*c1e3)- bl1(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,4)*t(1,ll))- bl1(ix,l,6)*dpr(1))/ded            !hr06

          do i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl1(ix,l,1)*puf+bl1(ix,l,2)*t(i,ll))+dpr(i)*bl1  &!hr06
     &(ix,l,5)                                                           !hr06
        t(i,ll)=(bl1(ix,l,3)*puf+bl1(ix,l,4)*t(i,ll))+dpr(i)*bl1(ix,l,6) !hr06
          end do
        end do

        do l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
            dphi=-one*phibf(l)                                           !hr06
          endif
          if(-one*dphi.gt.pieni) dphi=dphi+pi                            !hr06
          phi(l)=phi(l)+dphi/pie
        end do

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
        
        cycle STRUCTLOOP

!--REVERSE RUN THROUGH BLOCKS (ix.le.0)
  190   ix=-ix
        etl=etl+elbe(ix)
        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif

          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl2eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,5)*dpp1*c1e3)- bl2(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,2)*t(1,ll))- bl2(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl2eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,6)*dpp1*c1e3)- bl2(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,4)*t(1,ll))- bl2(ix,l,6)*dpr(1))/ded            !hr06

          do i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl2(ix,l,1)*puf+bl2(ix,l,2)*t(i,ll))+dpr(i)*bl2  &!hr06
     &(ix,l,5)                                                           !hr06
        t(i,ll)=(bl2(ix,l,3)*puf+bl2(ix,l,4)*t(i,ll))+dpr(i)*bl2(ix,l,6) !hr06
          end do
        end do

        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
            dphi=-phibf(l)
          endif

          if(-one*dphi.gt.pieni) dphi=dphi+pi                            !hr06
          phi(l)=phi(l)+dphi/pie
        end do

        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
        
        cycle STRUCTLOOP

!--NOT A BLOCK / Nonlinear insertion
  220   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        kzz=kz(ix)

 ! Cavity
+if .not.collimat.and..not.bnlelens
        if(kpz.eq.6) then
+ei
+if collimat.or.bnlelens
        if(abs(kzz).eq.12) then
+ei
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif

          cycle STRUCTLOOP
        endif
        
        !Beam Beam element .and. fort.3 has BB block
        if(kzz.eq.20.and.nbeam.ge.1) then
          nbeam=k
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          cycle STRUCTLOOP
        endif

+ca trom01 !if kzz==22, starts a do over l; Update t matrix
+ca trom03
+ca trom06 !endif, ends the do over l; (commented out: increase nr, call writelin and cpltwis)

!+if collimat.or.bnlelens
        ! Marker, beam-beam, phase-trombone, crab cavity (incl. multipole), or wire
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22                           &
     &     .or.abs(kzz).eq.23.or.abs(kzz).eq.26                         &
     &     .or.abs(kzz).eq.27.or.abs(kzz).eq.28                         &
     &     .or.abs(kzz).eq.15) then
          
          nr=nr+1
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
          cycle STRUCTLOOP
        endif
!+ei
!+if .not.collimat.and..not.bnlelens
!        ! Marker, beam-beam or phase-trombone -> next element
!        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) then
!           cycle STRUCTLOOP
!        endif
!        ! Wire -> next element
!        if(abs(kzz).eq.15) then
!           cycle STRUCTLOOP
!        endif
!        ! RF CC Multipoles -> next element
!        if (abs(kzz).eq.23.or.abs(kzz).eq.26.or.                        &
!     &       abs(kzz).eq.27.or.abs(kzz).eq.28) then
!           cycle STRUCTLOOP
!        endif
!+ei
      
        ! Update the matrix etc. for supported blocks
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl

      if (kzz .ge. 0) then
        select case(kzz)

        case (1)
!--HORIZONTAL DIPOLE
           ekk=ekk*c1e3
+ca kickl01h
+ca kickq01h
!--NORMAL QUADRUPOLE
        case(2)
+ca kicklxxh
+ca kickq02h
!--   NORMAL SEXTUPOLE
        case(3)
           ekk=ekk*c1m3
+ca kickq03h
+ca kicksho
+ca kicklxxh
!--NORMAL OCTUPOLE
        case(4)
           ekk=ekk*c1m6
+ca kicksho
+ca kickq04h
+ca kicksho
+ca kicklxxh
!--NORMAL DECAPOLE
        case(5)
           ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05h
+ca kicksho
+ca kicklxxh
!--NORMAL DODECAPOLE
        case(6)
           ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06h
+ca kicksho
+ca kicklxxh
!--NORMAL 14-POLE
        case(7)
           ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07h
+ca kicksho
+ca kicklxxh
!--NORMAL 16-POLE
        case(8)
           ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08h
+ca kicksho
+ca kicklxxh
!--NORMAL 18-POLE
        case(9)
           ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09h
+ca kicksho
+ca kicklxxh
!--NORMAL 20-POLE
        case(10)
           ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10h
+ca kicksho
+ca kicklxxh
!--Multipole block
        case(11)
        r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
+ca multl08
            do 340 i=2,ium
+ca multl02
  340       continue
          else
+ca multl03
+ca multl09
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
+ca multl10
            do 350 i=2,ium
+ca multl05
  350       continue
          else
+ca multl06
+ca multl11
          endif
        endif
        if(abs(r0).le.pieni) then
           cycle STRUCTLOOP
        endif
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          
          nr=nr+1
+if .not.collimat.and..not.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif

          cycle STRUCTLOOP
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 360 l=1,nmz
+ca multl07a
  360   continue
        if(nmz.ge.2) then
+ca multl07b
          do 365 l=3,nmz
+ca multl07c
  365     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz

!--Skipped elements
        case(12,13,14,15,16,17,18,19,20,21,22,23)
           cycle STRUCTLOOP
        
!--DIPEDGE ELEMENT
        case(24)
+ca kickldpe
+ca kickqdpe
!--solenoid
        case(25)
+ca kicklso1
+ca kickqso1

!--Skipped elements
        case(26,27,28)
           cycle STRUCTLOOP
           
!--Unrecognized element (incl. cav with kp.ne.6 for non-collimat/bnlelens)
        case default
           nr=nr+1
+if .not.collimat.and..not.bnlelens
           call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
           call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
           if(ntco.ne.0) then
              if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
           endif
           cycle STRUCTLOOP
        end select


!--SKEW ELEMENTS
        else if(kzz .lt. 0) then
           kzz=-kzz             !Make it positive
           select case(kzz)
           case(1)
!--VERTICAL DIPOLE
              ekk=ekk*c1e3
+ca kickl01v
+ca kickq01v
!--SKEW QUADRUPOLE
           case(2)
+ca kicklxxv
+ca kickq02v
!--SKEW SEXTUPOLE
           case(3)
              ekk=ekk*c1m3
+ca kickq03v
+ca kicksho
+ca kicklxxv
!--SKEW OCTUPOLE
           case(4)
              ekk=ekk*c1m6
+ca kicksho
+ca kickq04v
+ca kicksho
+ca kicklxxv
!--SKEW DECAPOLE
           case(5)
              ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05v
+ca kicksho
+ca kicklxxv
!--SKEW DODECAPOLE
           case(6)
              ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06v
+ca kicksho
+ca kicklxxv
!--SKEW 14-POLE
           case(7)
              ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07v
+ca kicksho
+ca kicklxxv
!--SKEW 16-POLE
           case(8)
              ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08v
+ca kicksho
+ca kicklxxv
!--SKEW 18-POLE
           case(9)
              ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09v
+ca kicksho
+ca kicklxxv
!--SKEW 20-POLE
           case(10)
              ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10v
+ca kicksho
+ca kicklxxv

!     Unrecognized skew element (including kzz=-12,kp.ne.6 for non-collimat/bnlelens)
           case default
              nr=nr+1
+if .not.collimat.and..not.bnlelens
              call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
              call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
              if(ntco.ne.0) then
                 if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
              endif
              cycle STRUCTLOOP
           end select
        endif
      
        !Done processing an element: go here!
        t(6,2)=t(6,2)-dyy1/(one+dpp)
        t(6,4)=t(6,4)-dyy2/(one+dpp)
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!Contains elseif statements
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          endif
        end do
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        if(ncorru.eq.0) then
           if(kz(ix).eq.11) then
              if(abs(aa(2)).gt.pieni.and.nmz.gt.1) then
                 write(34,10070) etl,bez(ix),-2,aa(2),bexi,bezii,phi
              endif
              do iiii=3,nmz
                 if(abs(bb(iiii)).gt.pieni) then
                    write(34,10070)                                      &
     &                   etl,bez(ix),iiii,bb(iiii),bexi,bezii,phi
                 endif
                 if(abs(aa(iiii)).gt.pieni) then
                    write(34,10070)                                      &
     &                   etl,bez(ix),-iiii,aa(iiii),bexi,bezii,phi
                 endif
              enddo
           elseif(abs(ekk).gt.pieni.and.abs(kz(ix)).ge.3) then
              write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
           elseif(abs(ekk).gt.pieni.and.kz(ix).eq.-2) then
              write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
           endif
        endif
        
        nr=nr+1
+if .not.collimat.and..not.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
+ei
+if collimat.or.bnlelens
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
+ei
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
        
      end do STRUCTLOOP ! END LOOP OVER ELEMENTS
      
      call clorb(ded)
      do 510 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  510 continue
      call clorb(zero)
      do 520 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  520 continue
      iiii=100
      idum='END'
      bexi=t(2,1)**2+t(3,1)**2                                           !hr06
      bezii=t(4,3)**2+t(5,3)**2                                          !hr06
      if(ncorru.eq.0) write(34,10070) etl,idum,iiii,zero,bexi,bezii,phi
      if(ncorru.eq.0)                                                   &
     &write(lout,10060)
!-----------------------------------------------------------------------
      return
10000 format(t5 ,'---- ENTRY LINOPT ----')
10010 format(132('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
10040 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7/)
10050 format(t8,'  PLANE          DISP(MM)                 DISP(MRAD)'/ &
     &t6,'      X  ',2(f20.12,6x)/t10,'  Y  ',2(f20.12,6x)/)
10060 format(//131('-')//)
10070 format(1x,1pg21.14,1x,a,1x,i4,5(1x,1pg21.14))
      end
+if collimat.or.bnlelens
      subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC,ielem)
+ei
+if .not.collimat.and..not.bnlelens
      subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC)
+ei
!-----------------------------------------------------------------------
!  WRITE OUT LINEAR OPTICS PARAMETERS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,iwrite,ixwl,l,ll,nr
      real(kind=fPrec) al1,al2,b1,b2,c,cp,d,dp,g1,g2,p1,t,tl
      character(len=16) typ
      ! isBLOC.eq.TRUE if ixwl currently refers to a BLOC index, FALSE if it is a SINGLE ELEMENT index
      logical isBLOC
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension p1(2),t(6,4),b1(2),b2(2),al1(2),al2(2),g1(2),g2(2)
      dimension d(2),dp(2),c(2),cp(2)
+if collimat
+ca collpara
+ca dblinopt
      integer ielem
+ei
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        do 20 l=1,2
          ll=2*l
          b1(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                            !hr06
          b2(l)=t(6-ll,ll-1)**2+t(7-ll,ll-1)**2                          !hr06
          al1(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))      !hr06
          al2(l)=-one*(t(6-ll,ll-1)*t(6-ll,ll)+t(7-ll,ll-1)*t(7-ll,ll))  !hr06
          g1(l)=t(ll,ll)**2+t(ll+1,ll)**2                                !hr06
          g2(l)=t(6-ll,ll)**2+t(7-ll,ll)**2                              !hr06
          d(l)=t(6,ll-1)*c1m3
          dp(l)=t(6,ll)*c1m3
          c(l)=t(1,ll-1)
          cp(l)=t(1,ll)
   20   continue

+if collimat.or.bnlelens
+if .not.collimat.and.bnlelens
        if (lhc.eq.9) then
+ei
          tbetax(max(ielem,1))  = b1(1)
          tbetay(max(ielem,1))  = b1(2)
          talphax(max(ielem,1)) = al1(1)
          talphay(max(ielem,1)) = al1(2)
          torbx(max(ielem,1))   = c(1)
          torbxp(max(ielem,1))  = cp(1)
          torby(max(ielem,1))   = c(2)
          torbyp(max(ielem,1))  = cp(2)
          tdispx(max(ielem,1))  = d(1)
          tdispy(max(ielem,1))  = d(2)
+if .not.collimat.and.bnlelens
        endif
+ei
+ei

      if(ncorru.eq.0) then
          write(lout,10000) nr,typ(:8),tl,p1(1),b1(1),al1(1),g1(1),d(1),&
     &dp(1),c(1),cp(1)
          write(lout,10010) b2(1),al2(1),g2(1)
          write(lout,10030) typ(9:16)
          write(lout,10020) p1(2),b1(2),al1(2),g1(2),d(2),dp(2),        &
     &c(2),cp(2)
          write(lout,10010) b2(2),al2(2),g2(2)
          write(lout,10040)
        else
           if(.not.isBLOC) then
              if(kp(ixwl).eq.3) then
                 nhmoni=nhmoni+1
                 betam(nhmoni,1)=b1(1)
                 pam(nhmoni,1)=(p1(1)*two)*pi
                 bclorb(nhmoni,1)=c(1)
              else if(kp(ixwl).eq.4) then
                 nhcorr=nhcorr+1
                 betac(nhcorr,1)=b1(1)
                 pac(nhcorr,1)=(p1(1)*two)*pi
              else if(kp(ixwl).eq.-3) then
                 nvmoni=nvmoni+1
                 betam(nvmoni,2)=b1(2)
                 pam(nvmoni,2)=(p1(2)*two)*pi
                 bclorb(nvmoni,2)=c(2)
              else if(kp(ixwl).eq.-4) then
                 nvcorr=nvcorr+1
                 betac(nvcorr,2)=b1(2)
                 pac(nvcorr,2)=(p1(2)*two)*pi
              endif
           endif
        endif
      endif
!-----------------------------------------------------------------------
      return
10010 format('|',6x,'|',8x,'|',12x,'|',1x,'|',12x,'|',f12.6,'|', f13.7, &
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10020 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f12.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format(132('-'))
10000 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f12.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10030 format('|',6x,'|',a8,'|',12x,'|',102('-'))
      end

      subroutine cpltwis(typ,t,etl,phi)
!-----------------------------------------------------------------------
!  CALCULATES COUPLED TWISS PARAMETERS AROUND THE RING AND ALSO THE
!  ANGLE OF THE MAJOR AXIS OF A ELLIPSE IN THE X-Y PROJECTION WITH
!  THE X-AXIS. THE 4-D ELLIPSOID IS GIVEN BY THE BOUNDARY OF A
!  DISTRIBUTION OF PARTICLES WITH MAXIMUM EMITANCE OF MODE I AND II,
!  EUI AND EUII RESPECTIVELY.
!  BINARY PRINT ON FILE 11 OF 22 VALUES :
!  POSITION [M],
!  BET(1-4), ALF(1-4), GAM(1-4), COOR-PHI(1-4), COOR-PRIME-PHI(1-4),
!  COUUANGL
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,iwrite
      real(kind=fPrec) alxi,alxii,alzi,alzii,bexi,bexii,bezi,bezii,     &
     &couuang,etl,gaxi,gaxii,gazi,gazii,phi,phxi,phxii,phxpi,phxpii,    &
     &phzi,phzii,phzpi,phzpii,t
      character(len=16) typ
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension t(6,4),phi(2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bexii=t(4,1)**2+t(5,1)**2                                        !hr06
        bezi=t(2,3)**2+t(3,3)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        alxi=-one*(t(2,1)*t(2,2)+t(3,1)*t(3,2))                          !hr06
        alxii=-one*(t(4,1)*t(4,2)+t(5,1)*t(5,2))                         !hr06
        alzi=-one*(t(2,3)*t(2,4)+t(3,3)*t(3,4))                          !hr06
        alzii=-one*(t(4,3)*t(4,4)+t(5,3)*t(5,4))                         !hr06
        gaxi=t(2,2)**2+t(3,2)**2                                         !hr06
        gaxii=t(4,2)**2+t(5,2)**2                                        !hr06
        gazi=t(2,4)**2+t(3,4)**2                                         !hr06
        gazii=t(4,4)**2+t(5,4)**2                                        !hr06
        if(abs(t(2,1)).gt.pieni) phxi=atan2_mb(t(3,1),t(2,1))
        if(abs(t(4,1)).gt.pieni) phxii=atan2_mb(t(5,1),t(4,1))
        if(abs(t(4,1)).gt.pieni) phxii=atan2_mb(t(5,1),t(4,1))
        if(abs(t(2,3)).gt.pieni) phzi=atan2_mb(t(3,3),t(2,3))
        if(abs(t(4,3)).gt.pieni) phzii=atan2_mb(t(5,3),t(4,3))
        if(abs(t(2,2)).gt.pieni) phxpi=atan2_mb(t(3,2),t(2,2))
        if(abs(t(4,2)).gt.pieni) phxpii=atan2_mb(t(5,2),t(4,2))
        if(abs(t(2,4)).gt.pieni) phzpi=atan2_mb(t(3,4),t(2,4))
        if(abs(t(4,4)).gt.pieni) phzpii=atan2_mb(t(5,4),t(4,4))
        if(abs(t(2,1)).le.pieni) phxi=pi*half
        if(abs(t(4,1)).le.pieni) then
          if(bexii.gt.pieni) phxii=pi*half
          if(bexii.le.pieni) phxii=zero
        endif
        if(abs(t(2,3)).le.pieni) then
          if(bezi.gt.pieni) phzi=pi*half
          if(bezi.le.pieni) phzi=zero
        endif
        if(abs(t(4,3)).le.pieni) phzii=pi*half
        if(abs(t(2,2)).le.pieni) phxpi=pi*half
        if(abs(t(4,2)).le.pieni) then
          if(gaxii.gt.pieni) phxpii=pi*half
          if(gaxii.le.pieni) phxpii=zero
        endif
        if(abs(t(2,4)).le.pieni) then
          if(gazi.gt.pieni) phzpi=pi*half
          if(gazi.le.pieni) phzpi=zero
        endif
        if(abs(t(4,4)).le.pieni) phzpii=pi*half
        if(abs(eui*(bexi-bezi)+euii*(bexii-bezii)).gt.pieni) then
          couuang=half*atan_mb((two*((eui*sqrt(bexi*bezi))*             &!hr06
     &cos_mb(phxi-phzi)+                                                &!hr06
     &(euii*sqrt(bexii*bezii))*cos_mb(phxii-phzii)))/ (eui*(bexi-bezi)  &!hr06
     &+euii*(bexii-bezii)))                                              !hr06
        else
          couuang=zero
        endif
        write(11,*) typ,etl,phi,bexi,bexii,bezi,bezii, alxi,alxii,alzi, &
     &alzii, gaxi,gaxii,gazi,gazii,phxi,phxii,phzi,phzii, phxpi,        &
     &phxpii,phzpi,phzpii,couuang,t(6,1),t(6,2),t(6,3),t(6,4),t(1,1),   &
     &t(1,2),t(1,3),t(1,4)

      endif
      return
      end

+dk loesd
      subroutine loesd (rmat, vec,dimakt,dimtot,kod)
!-----------------------------------------------------------------------
!  SOLUTION OF A SYSTEM OF LINEAR EQUATIONS
!  VEC1 = VEC2 * RMAT , WITH VEC2 AS RESULT
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer ik,indi,j,jk,jy,k,kk,kod,l,n,n1,dimtot,dimakt
      real(kind=fPrec) emax,eps,r,rmat,vec
+ca parpro
      dimension rmat(dimtot,dimakt),vec(dimakt)
      data eps /1e-20_fPrec/
      save
!-----------------------------------------------------------------------
      kod=1
      do j=1,dimakt
        emax=zero
        do 10 ik=j,dimakt
          if(abs(emax).gt.abs(rmat(j,ik)) .or.emax.ne.emax) goto 10
          emax=rmat(j,ik)
          indi=ik
   10   continue
        if(abs(emax).lt.eps) then
          write(lout,*) '  ****   ERROR IN LOESD   **** '
          return
        endif

   20   do l=j,dimakt
          r=rmat(l,j)
          rmat(l,j)=rmat(l,indi)
          rmat(l,indi)=r
          rmat(l,j)=rmat(l,j)/emax
        end do

        r=vec(indi)
        vec(indi)=vec(j)
        vec(j)=r/emax
        if(j.eq.dimakt) goto 60
        jy=j+1

        do jk=jy,dimakt
          r=rmat(j,jk)

          do kk=jy,dimakt
            rmat(kk,jk)= rmat(kk,jk)-r*rmat(kk,j)
          end do
          vec(jk)=vec(jk)-vec(j)*r
        end do
      end do

   60 n=dimakt
      n1=dimakt-1

      do j=1,n1
        do k=1,j
          vec(n-j)=vec(n-j)-rmat(n-k+1,n-j)*vec(n-k+1)
        end do
      end do

      kod = 0
      return
      end

+dk matrix
      subroutine matrix(dpp,am)
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,ierr,l
      real(kind=fPrec) am,dpp
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension am(4,4)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do i=2,5
        do l=1,2
           x(i,l)=zero
           y(i,l)=zero
        end do
      end do

      x(2,1)=one
      y(3,1)=one
      x(4,2)=one
      y(5,2)=one

      do l=1,2
        x(1,l)=clo(l)
        y(1,l)=clop(l)
      end do

      call umlauf(dpp,5,ierr)
      ierro=ierr

      do i=1,4
        am(1,i)=x(i+1,1)
        am(2,i)=y(i+1,1)
        am(3,i)=x(i+1,2)
        am(4,i)=y(i+1,2)
      end do
!-----------------------------------------------------------------------
      return
      end

+dk orbit
      subroutine corrorb
!-----------------------------------------------------------------------
!  CORRECTION OF CLOSED ORBIT FIRST (MOST EFFECTIV CORRECTOR STRATEGY
!  USING MICADO), THEN
!  SCALING OF DIPOLE-ERRORS FOR RMS-VALUES OF THE CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,icflag,ihflag,ii,ij,im,iprinto,ivflag,j,k,kpz,kzz,l,    &
     &nlino,ntcoo,nto,nx
+ca parpro
      real(kind=fPrec) ar(nmon1,ncor1)
      real(kind=fPrec) b(nmon1),orbr(nmon1),xinc(ncor1)
      real(kind=fPrec) rmsx,ptpx,rmsz,ptpz,rzero,rzero1
      real(kind=fPrec) clo0,clop0,hfac,qwc1,vfac
      character(len=16) bezlo(nele)
+ca common
+ca commons
+ca commont1
      dimension clo0(2),clop0(2)
      dimension qwc1(3),nx(ncor1)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      rzero=zero
      rzero1=zero
      do l=1,2
        clo0(l)=zero
        clop0(l)=zero
        di0(l)=zero
       dip0(l)=zero
      end do

      call clorb(ded)
      if(ierro.gt.0) call prror(4)

      do l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
      end do

      call clorb(zero)
      if(ierro.gt.0) call prror(5)

      do l=1,2
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
      end do

      do l=1,ncor1
        xinc(l)=zero
        nx(l)=0
      end do

      if(iclo.eq.0) return

!-- ORBIT CORRECTION
      ihflag=0
      ivflag=0
      icflag=0

      write(lout,*)
      write(lout,10000)

      if(ncorru.eq.0) then
        call prror(84)
      else
        if(ncorrep.le.0) then
          write(lout,10010) ncorru,sigma0(1),sigma0(2)
        else
          write(lout,10020) ncorru,ncorrep
        endif
      endif

      write(lout,*)

!-- SAVE OLD 'LINOPT' SETTINGS
      iprinto=iprint
      nto=nt
      ntcoo=ntco

      do i=1,nlin
        bezlo(i)=bezl(i)
      end do

      nlino=nlin

!-- PUT MONITORS AND CORRECTORS INTO LINOPT SETTINGS
!-- GET TWISS PARAMETERS AND DISTORTED ORBIT BACK
      iprint=0
      ntco=0
      nlin=0

      do i=1,il
        if(kp(i).eq.3.or.kp(i).eq.4.or. kp(i).eq.-3.or.kp(i).eq.-4) bezl&
     &(i)=bez(i)
        nlin=nlin+1
      end do

      call linopt(zero)
      call phasad(zero,qwc1)

!-- CHECK SOME CONDITIONS
      write(lout,10100) nhmoni,nhcorr,nvmoni,nvcorr
      if(nhmoni.gt.nmon1) then
        write(lout,10070) nhmoni,nmon1
        return
      endif
      if(nvmoni.gt.nmon1) then
        write(lout,10070) nvmoni,nmon1
        return
      endif
      if(nhcorr.gt.ncor1) then
        write(lout,10080) nhcorr,ncor1
        return
      endif
      if(nvcorr.gt.ncor1) then
        write(lout,10080) nvcorr,ncor1
        return
      endif
      if(nhmoni.lt.nhcorr.or.nvmoni.lt.nvcorr) write(lout,10090)

      write(lout,*)
      call orbinit

!-- CORRECT BOTH PLANES
      if(ncorrep.eq.0) then
        icflag=1
        ncorrep=itco
      endif
      do 110 ii=1,ncorrep

!-- HORIZONTAL PLANE FIRST
        do i=1,nhmoni
          b(i)=bclorb(i,1)
          do j=1,nhcorr
      ar(i,j)=((sqrt(betam(i,1)*betac(j,1))*cos_mb(abs(pam(i,1)-pac     &!hr06
     &(j,1))-qwc1(1)*pi))*c1e3)/(two*sin_mb(qwc1(1)*pi))                 !hr06
          end do
        end do

        call calrms(b,nhmoni,rmsx,ptpx)

!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nhmoni,nhcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

!-- VERTICAL PLANE HERE
        do i=1,nvmoni
          b(i)=bclorb(i,2)                                               !hr06
          do j=1,nvcorr
      ar(i,j)=((sqrt(betam(i,2)*betac(j,2))*cos_mb(abs(pam(i,2)-pac     &!hr06
     &(j,2))-qwc1(2)*pi))*c1e3)/(two*sin_mb(qwc1(2)*pi))                 !hr06
          end do
        end do

        call calrms(b,nvmoni,rmsz,ptpz)
        write(lout,10030) ii-1,rmsx,rmsz
        write(lout,10040) ii-1,ptpx,ptpz
        if(icflag.eq.1.and.sigma0(1).gt.rmsx.and.ihflag.eq.0) then
          write(lout,10110)
          ihflag=1
        endif
        if(icflag.eq.1.and.sigma0(2).gt.rmsz.and.ivflag.eq.0) then
          write(lout,10120)
          ivflag=1
        endif

        if(ihflag.eq.0) then
          write(lout,*)

          do ij=1,ncorru/10
            write(lout,10050) (nx(10*(ij-1)+k), k=1,10)
          end do

          if(mod(ncorru,10).gt.0) then
            write(lout,10050) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,1)
        endif

!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nvmoni,nvcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

        if(ivflag.eq.0) then
          write(lout,*)
          do 100 ij=1,ncorru/10
            write(lout,10060) (nx(10*(ij-1)+k), k=1,10)
  100     continue

          if(mod(ncorru,10).gt.0) then
            write(lout,10060) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,2)
        endif

        if(ihflag.eq.1.and.ivflag.eq.1) goto 140
        call linopt(zero)
        call phasad(zero,qwc1)
  110 continue

!-- GET LAST VALUES AFTER CORRECTION
      do 120 i=1,nhmoni
        b(i)=bclorb(i,1)                                                 !hr06
  120 continue

      call calrms(b,nhmoni,rmsx,ptpx)

      do 130 i=1,nvmoni
        b(i)=bclorb(i,2)                                                 !hr06
  130 continue

      call calrms(b,nvmoni,rmsz,ptpz)
      write(lout,10030) ncorrep,rmsx,rmsz
      write(lout,10040) ncorrep,ptpx,ptpz
      write(lout,*)

  140 continue
      if((ii-1).eq.itco) write(lout,10130) itco

!-- SCALE TO DESIRED RMS VALUE IF IT IS GREATER THAN ZERO
      if(sigma0(1).gt.pieni.or.sigma0(2).gt.pieni) then
        do 180 ii=1,itco
          write(lout,10140)
          hfac=sigma0(1)/rmsx                                            !hr06
          vfac=sigma0(2)/rmsz                                            !hr06
          do 150 i=1,il
            kzz=kz(i)
            kpz=kp(i)
            if(kzz.eq.1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*hfac
              ek(i)=ek(i)*hfac
            endif
            if(kzz.eq.-1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*vfac
              ek(i)=ek(i)*vfac
            endif
            if(kzz.eq.11) then
              im=irm(i)
              ak0(im,1)=ak0(im,1)*vfac
              aka(im,1)=aka(im,1)*vfac
              bk0(im,1)=bk0(im,1)*hfac
              bka(im,1)=bka(im,1)*hfac
            endif
  150     continue
          call linopt(zero)

          do 160 i=1,nhmoni
            b(i)=bclorb(i,1)                                             !hr06
  160     continue

          call calrms(b,nhmoni,rmsx,ptpx)

          do 170 i=1,nvmoni
            b(i)=bclorb(i,2)                                             !hr06
  170     continue

          call calrms(b,nvmoni,rmsz,ptpz)

          write(lout,10150) ii,rmsx,rmsz
          write(lout,10160) ii,ptpx,ptpz
          write(lout,*)
          if(abs(real(rmsx,fPrec)-sigma0(1)).lt.dsi.and.                      &!hr06
     &       abs(real(rmsz,fPrec)-sigma0(2)).lt.dsi)                          &!hr06
     &goto 190
  180   continue
      endif

      if((ii-1).eq.itco) write(lout,10130) itco
  190 continue

!-- WRITE OUT ADJUSTED CLOSED ORBIT
      do 200 i=1,nhmoni
        write(28,*) i,bclorb(i,1)
  200 continue

      do 210 i=1,nhmoni
        write(29,*) i,bclorb(i,2)
  210 continue

!-- CHANGE BACK TO OLD 'LINOPT' SETTINGS
      iprint=iprinto
      nt=nto
      ntco=ntcoo
      nlin=nlino

      do 220 i=1,nlin
        bezl(i)=bezlo(i)
  220 continue

      ncorru=0
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ORBIT CORRECTION WITH MOST EFFCTIVE CORRECTOR ',  &
     &'STRATEGY ----')
10010 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS UNTIL',/, &
     &t5,'       HOR. RMS SMALLER THAN ',f6.3,' MM',/, t5,              &
     &'       VER. RMS SMALLER THAN ',f6.3,' MM')
10020 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS AND ',i4, &
     &' ITERATIONS.')
10030 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-RMS: ',f6.3, &
     &' VER.-RMS: ',f6.3)
10040 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-PTP: ',f6.3, &
     &' VER.-PTP: ',f6.3)
10050 format(t5,'     HORIZONTAL CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10060 format(t5,'     VERTICAL   CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10070 format(/,t5,'ERROR: NUMBER OF MONITORS TOO BIG.',/                &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10080 format(/,t5,'ERROR: NUMBER OF CORRECTORS TOO BIG.',/              &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10090 format(/,t5,'WARNING: NUMBER OF MONITORS IS SMALLER THAN NUMBER', &
     &' OF CORRECTORS.',/ '    NUMERICAL PROBLEMS MIGHT BE ENCOUNTERED.'&
     &)
10100 format(/,t5,'NUMBER OF HOR. MONITORS: ',i4,                       &
     &'  NUMBER OF HOR. CORRECTORS: ',i4,/, t5,                         &
     &'NUMBER OF VER. MONITORS: ',i4, '  NUMBER OF VER. CORRECTORS: ',  &
     &i4)
10110 format(t10,'HORIZONTAL RMS GOAL REACHED')
10120 format(t10,'VERTICAL RMS GOAL REACHED')
10130 format(t10,'MAXIMUM NUMBER OF ITERATIONS ACHIVED: ',i4,/ ,t10,    &
     &'INCREASE ITCO TO INCREASE THE NUMBER OF ' ,                      &
     &'CLOSED ORBIT ITERATIONS',/)
10140 format(t5,'---- ORBIT SCALING USING ALL POSSIBLE ELEMENTS ')
10150 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-RMS: ',f6.3,    &
     &' VER.-RMS: ',f6.3)
10160 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-PTP: ',f6.3,    &
     &' VER.-PTP: ',f6.3)
      end

      subroutine putorb(xinc,nx,npflag)
!-----------------------------------------------------------------------
!  PUT ORBIT CHANGES FROM MICADO TO THE GIVEN ORBIT CORRECTORS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none

      integer i,im,ix,izu,j,k,kcorr,kcorru,kpz,kzz,nmz,npflag,nx
+ca parpro
      real(kind=fPrec) xinc(ncor1)
      real(kind=fPrec) ckicknew,ckickold,r0,r0a
+ca common
+ca commons
+ca commont1
      dimension nx(ncor1)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      kcorru=0
      kcorr=0
      izu=0

      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(kzz.eq.15) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if(kpz.eq.4.and.kzz.eq.1.and.npflag.eq.1.or.                    &
     &kpz.eq.-4.and.kzz.eq.-1.and.npflag.eq.2) then
          kcorr=kcorr+1
          do 10 j=1,ncorru
            if(nx(j).eq.kcorr) then
              kcorru=kcorru+1
              ckickold=sm(ix)+zfz(izu)*ek(ix)
              zfz(izu)=zfz(izu)+real(xinc(j),fPrec)/ek(ix)                     !hr06
              ckicknew=sm(ix)+zfz(izu)*ek(ix)
              write(lout,10000) kcorru,kcorr,bez(ix), ckickold*c1e3,    &
     &ckicknew*c1e3
            endif
   10     continue
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one
          do 50 k=1,nmz
            izu=izu+1
            if(kpz.eq.-4.and.npflag.eq.2.and.k.eq.1) then
              kcorr=kcorr+1
              do 30, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k))/r0a
           zfz(izu)=zfz(izu)+(c1e3*(real(xinc(j),fPrec)/(r0a*ed(ix))-ak0&!hr06
     &(im,k)))/aka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   30         continue
            endif
            izu=izu+1
            if(kpz.eq.4.and.npflag.eq.1.and.k.eq.1) then
              kcorr=kcorr+1
              do 40, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
           zfz(izu)=zfz(izu)+(c1e3*(real(xinc(j),fPrec)/(r0a*ed(ix))-bk0&!hr06
     &(im,k)))/bka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   40         continue
            endif
   50     continue
          izu=izu+2*mmul-2*nmz
        endif
   60 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,i4,i4,' ',a16,'  OLD: ',d14.7,' MRAD   NEW: ' ,d14.7,   &
     &' MRAD')
      end

      subroutine orbinit
!-----------------------------------------------------------------------
!  INITIALIZES THE RANDOM NUMBER OF NOT SET CORRCTORS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,im,ix,izu,kpz,kzz,nmz
      real(kind=fPrec) r0
+ca parpro
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      izu=0
      do 10 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 10
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 10
        if(kzz.eq.15) goto 10
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if((kpz.eq.4.and.kzz.eq.1).or.(kpz.eq.-4.and.kzz.eq.-1)) then
          zfz(izu)=zero
          ek(ix)=one
          ncororb(ix)=1
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 10
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 10
          endif
          im=irm(ix)

          izu=izu+1
          if(kpz.eq.-4) then
            zfz(izu)=zero
            aka(im,1)=one
          endif
          izu=izu+1
          if(kpz.eq.4) then
            zfz(izu)=zero
            bka(im,1)=one
          endif
          izu=izu+2*mmul-2
        endif
   10 continue
      return
      end

      subroutine htls(a,b,m,n,x,ipiv,r,iter,rms,ptp)
!*********************************************************************
!     Subroutine HTLS to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     DIMENSION OF ARRAY RHO SHOULD BE 3*NCOR1                       *
!     M    - NUMBER OF AVAILABLE MONITORS                            *
!     N    - NUMBERR OF AVAILABLE INDEPENDENT CORRECTORS             *
!     ITER - NUMBER OF CORRECTORS TO BE USED                         *
!     RMS  - RMS VALUE TO CORRECT FOR                                *
!     PTP  - PEAK TO PEAK VALUE TO CORRECT FOR                       *
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,iii,ij1,ip,ipiv,iter,j,j1,k,k2,k3,ki,kk,kpiv,m,n,ncor1, &
     &nmon1
      real(kind=fPrec) a,b,piv,pivt,ptop,r,rho,rmss,x,xiter,xptp,xrms
      real(kind=fPrec) rms,ptp
      real(kind=fPrec) g,h,sig,beta
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),x(ncor1),ipiv(ncor1),r(nmon1)
      dimension rho(3*ncor1),xiter(ncor1),xrms(ncor1),xptp(ncor1)
      dimension rmss(ncor1),ptop(ncor1)
      save
!-----------------------------------------------------------------------

! --- calcul du premier pivot

!============================
      beta=zero

      do ij1=1,500
        rho(ij1)=zero
      end do

      k2=n + 1
      piv=zero

      do k=1,n
        ipiv(k)=k
        h=zero                                                           !hr06
        g=zero                                                           !hr06

        do i=1,m
          h=h+a(i,k)*a(i,k)
          g=g+a(i,k)*b(i)
        end do

        rho(k)=h
        rho(k2) = g
        pivt = g**2/h                                                    !hr06
        if(pivt-piv.le.0) goto 40
        if(pivt-piv.gt.0) goto 30
   30   piv = pivt

        kpiv=k
        k2 = k2 + 1
   40   continue
      end do

! --- boucle pour chaque iteration

      do 150 k=1,iter
        if(kpiv.eq.k)goto 60

! --- on echange les K et KPIV si KPIV plus grand que K
        h=rho(k)
        rho(k)=rho(kpiv)
        rho(kpiv)=h
        k2=n+k
        k3=n+kpiv
        g = rho(k2)
        rho(k2) = rho(k3)
        rho(k3) = g
        do i=1,m
          h=a(i,k)
          a(i,k)=a(i,kpiv)
          a(i,kpiv)=h
        end do

! --- calcul de beta,sigma et uk dans htul
   60   continue
        call htul(a,m,n,k,sig,beta)

! --- on garde SIGMA dans RHO(N+K)
        j=n+k
        rho(j)=-one*sig                                                  !hr06
        ip=ipiv(kpiv)
        ipiv(kpiv)=ipiv(k)
        ipiv(k)=ip
        if(k.eq.n) goto 70

! --- transformation de A dans HTAL
        call htal(a,m,n,k,beta)

! --- transformation de B dans HTBL
   70   continue
        call htbl(a,b,m,n,k,beta)

! --- recherche du pivot (K+1)
!=============================

        rho(k)=sqrt(piv)
        if(k.eq.n) goto 90
        piv=zero                                                          !hr06
        kpiv = k + 1
        j1 = kpiv
        k2=n + j1

        do j=j1,n
          h=rho(j)-(a(k,j))*(a(k,j))

          if(h.lt.c1m7) then
            write(lout,*)
            write(lout,*) 'CORRECTION PROCESS ABORTED.'
            write(lout,*) 'DIVISION BY ZERO EXPECTED.'
            write(lout,*) 'PROBABLY TWO CORRECTORS TOO CLOSE.'
            write(lout,10000) ' SUSPECTED CORRECTOR: ',j
            write(lout,'(a)') "Error '777' in subroutine htls"
            call prror(-1)
          endif

          rho(j)=h
          g=rho(k2)-(a(k,j))*(b(k))
          rho(k2) = g
          pivt = g**2/h                                                  !hr06
          if(pivt.lt.piv)goto 80
          kpiv=j
          piv=pivt
          k2 = k2 + 1
   80     continue
        end do

! --- calcul des X
   90   x(k)=b(k)/rho(n+k)
        if(k.eq.1)goto 120
        do i=2,k
          kk=k-i+1
          x(kk)=b(kk)
          ki=kk+1
          do j=ki,k
            x(kk)=x(kk)-a(kk,j)*x(j)
          end do
          x(kk)=x(kk)/rho(n+kk)
        end do
  120   continue

! --- save residual orbit and inverse sign of corrections (convention!)
        do iii= 1,m
          r(iii) = b(iii)
        end do
        do iii= 1,k
          x(iii) =-one*x(iii)                                           !hr06
        end do

! --- calcul du vecteur residuel dans HTRL
!=========================================

!     transform orbit R back to "normal space"
        call htrl(a,r,m,n,k,rho)
        call calrms(r,m,rmss(k),ptop(k))
        xiter(k+1) = k
        xrms(k+1) = rmss(k)
        xptp(k+1) = ptop(k)

        if(ptop(k).le.ptp)goto 160
        if(rmss(k).le.rms)goto 160
  150 continue
      return

! --- correction is already good enough:
!=======================================

  160 ptp=ptop(k)
      rms=rmss(k)
10000 format(a,i4)
      end
      subroutine htal(a,m,n,k,beta)
!*********************************************************************
!     Subroutine HTAL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of matrix A
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer j,k,k1,m,n,nc,ncor1,nmon1
      real(kind=fPrec) a,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------

      nc=n-k

      do j=1,nc
        h=zero                                                          !hr06

        do k1=k,m
          h=h+a(k1,k)*a(k1,k+j)
        end do

        h=beta*h
        do k1=k,m
          a(k1,k+j)=a(k1,k+j)-a(k1,k)*h
        end do
      end do

      end
      subroutine htbl(a,b,m,n,k,beta)
!*********************************************************************
!     Subroutine HTBL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of vector B
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer

      implicit none

      integer k,k1,m,n,ncor1,nmon1
      real(kind=fPrec) a,b,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1)
      save
!-----------------------------------------------------------------------

      h=zero                                                           !hr06

      do k1=k,m
        h=h+a(k1,k)*b(k1)
      end do

      h=beta*h

      do k1=k,m
        b(k1)=b(k1)-a(k1,k)*h
      end do

      end

      subroutine htrl(a,b,m,n,k,rho)
!*********************************************************************
!     Subroutine HTRL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate residual orbit vector
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,k,kk,kl,kn,lv,m,n,ncor1,nmon1
      real(kind=fPrec) a,b,beta,rho
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),rho(3*ncor1)
      save
!-----------------------------------------------------------------------

      do i= 1,k,1
        b(i)= zero                                                       !hr06
      end do

      do kk=1,k
        lv=m-k+kk
        kn=n+k-kk+1
        kl=k-kk+1

        beta=-one/(rho(kn)*a(kl,kl))                                     !hr06
        call htbl(a,b,m,n,kl,beta)
      end do

      end

      subroutine htul(a,m,n,k,sig,beta)
!*********************************************************************
!     Subroutine HTUL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate vector U
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,k,m,n,ncor1,nmon1
      real(kind=fPrec) a,beta,h,sig
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------
      sig=zero                                                          !hr06

      do i=k,m
        sig=sig+a(i,k)* a(i,k)
      end do

      sig=sqrt(sig)
!     on choisit le signe correct pour SIG:
      h=a(k,k)
      if(h.lt.zero)sig=-one*sig                                          !hr06
      beta=h + sig
      a(k,k)=beta
      beta=one/(sig*beta)                                                !hr06
      end

      subroutine calrms(r,m,rms,ptp)
!*********************************************************************
!     Subroutine CALRMS to calculate rms                             *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculates rms and p.to.p value of R(1) .... R(M)
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,imax,imin,m,maxmin
      real(kind=fPrec) ave,ptp,r,rms,xave,xrms
      dimension r(m)
      save
!-----------------------------------------------------------------------
      xave = zero
      xrms = zero

      do i=1,m
        xave = xave + r(i)
        xrms = xrms + r(i)**2                                            !hr06
      end do

      ave = xave / real(m,fPrec)
      rms = xrms / real(m,fPrec)

      imax=maxmin(r(1),m,1)
      imin=maxmin(r(1),m,0)
      ptp=r(imax)-r(imin)
      rms=sqrt(rms)
      return
      end

      function maxmin (a,n,m)
!-----------------------------------------------------------------------
!     if M=0, MAXMIN=lowest index of minimum element in A
!     if M=1, MAXMIN=lowest index of maximun element in A
!     if N<1, MAXMIN=1
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      implicit none
      integer i,m,maxmin,n
      real(kind=fPrec) a,curent
      dimension a(n)
      save
!-----------------------------------------------------------------------
      maxmin=1
      if (n.lt.1) return
      curent=a(1)

      do i=2,n
        if ((m.eq.0).and.(a(i).ge.curent)) goto 10
        if ((m.eq.1).and.(a(i).le.curent)) goto 10
        curent=a(i)
        maxmin=i
   10   continue
      end do

      return
      end

+dk ord
      subroutine ord
!-----------------------------------------------------------------------
!  ORGANISATION OF BLOCKS, NONLINEAR ELEMENTS AND RANDOM NUMBERS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,icext1,icextal1,ihi,ii,ilf,ilfr,inz,iran,ix,izu,j,jra,  &
     &jra3,kanf1,kpz,kzz,kzz1,kzz2,nra1
      real(kind=fPrec) extalig1,exterr1
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension ilf(nblz),ilfr(nblz),jra(nele,5),iran(nele),inz(nele)
      dimension exterr1(nblz,40),extalig1(nblz,3),icext1(nblz),         &
     &icextal1(nblz)
+if time
      real(kind=fPrec) exterr2,tcnst2
      dimension exterr2(nblz,40),tcnst2(nblz)
+ei
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do i=1,nblz
        ilf(i)=0
        ilfr(i)=0
      end do

      do i=1,nele
        iran(i)=0
        inz(i)=0
        do j=1,5
          jra(i,j)=0
        end do
      end do

      if(mper.eq.1) goto 40

      do i=2,mper
        do j=1,mbloz
          ii=(i-1)*mbloz+j
          ihi=j
          if(msym(i).lt.0) ihi=mbloz-j+1
          ic(ii)=msym(i)*ic(ihi)
          if(ic(ii).lt.-nblo) ic(ii)=-ic(ii)
        end do
      end do

!--ORGANISATION OF RANDOM NUMBERS
   40 iu=mper*mbloz
      if(niu(1).lt.0) niu(1)=iabs(niu(1))
      if(niu(2).lt.0) niu(2)=iabs(niu(2))
      if(niu(1).eq.0) niu(1)=1
      if(niu(2).eq.0) niu(2)=iu
      if(niu(1).gt.iu) niu(1)=1
      if(niu(2).gt.iu) niu(2)=iu
      izu=0
      nra1=nran
      iorg=iorg-1
      if(iorg.ge.0) then
        if(iorg.eq.0) then !iorg == 0
          do 50 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 50
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 50
            if(kzz.eq.15) goto 50
            mzu(i)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
            if(izu.gt.nzfz) then
              write(lout,*) "ERROR in ORD: nzfz was too small"
              call prror(-1)
            endif
   50     continue
        else ! iorg.gt.0
          do 70 i=1,iorg
            do 60 j=1,il
              if(bez(j).eq.bezr(1,i)) then
                jra(i,1)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)            &
     &               call prror(31)
                jra(i,2)=kz(j)
              endif
              if(bez(j).eq.bezr(2,i)) then
                jra(i,3)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22)            &
     &               call prror(31)
                jra(i,4)=kz(j)
              endif
   60       continue
            kzz1=jra(i,2)
            kzz2=jra(i,4)
            if(kzz1.ne.0.and.kzz2.eq.0) then
              jra(i,5)=nra1
              nra1=nra1+mran*3
              if(kzz1.eq.11.and.abs(ek(jra(i,1))).gt.pieni)             &
     &             nra1=nra1+mran*2*mmul
              if(nra1.gt.nzfz) call prror(32)
            endif
            if(kzz1.eq.11.and.(kzz2.ne.11.and.kzz2.ne.0)) call prror(33)
   70     continue
          do 110 i=1,iu
            ix=ic(i)
            if(ix.le.nblo) goto 110
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 110
            if(kzz.eq.15) goto 110
            do 80 j=1,iorg
              if(bez(ix).eq.bezr(1,j)) goto 90
   80       continue
            goto 100
   90       jra3=jra(j,3)
            if(jra3.ne.0) then
              mzu(i)=iran(jra3)
              iran(ix)=mzu(i)
            else
              inz(j)=inz(j)+1
              if(inz(j).gt.mran) call prror(34)
              mzu(i)=jra(j,5)
              iran(ix)=mzu(i)
              jra(j,5)=jra(j,5)+3
              if(jra(j,2).eq.11) jra(j,5)=jra(j,5)+2*mmul
            endif
            goto 110
  100       mzu(i)=izu
            iran(ix)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
  110     continue
        endif
      else !iorg < 0 (in case of no ORGA block in fort.3)
        do 115 i=1,iu
          ix=ic(i)
          if(ix.le.nblo) goto 115
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 115
          if(kzz.eq.15) goto 115
          izu=izu+3
          if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
          if(izu.gt.nran) call prror(30)
          if(izu.gt.nzfz) then
            write(lout,*) "ERROR in ORD: nzfz was too small"
            call prror(-1)
          endif
  115   continue
      endif
      
      ! "GO" was not the first structure element -> Reshuffle the structure
      if(kanf.ne.1) then
        !--Re-saving of the starting point (UMSPEICHERUNG AUF DEN STARTPUNKT)
        kanf1=kanf-1
        do 130 i=1,kanf1
          if(iorg.ge.0) ilfr(i)=mzu(i)
          ilf(i)=ic(i)
          icext1(i)=icext(i)
          icextal1(i)=icextal(i)
          extalig1(i,1)=extalign(i,1)
          extalig1(i,2)=extalign(i,2)
          extalig1(i,3)=extalign(i,3)
          do 120 ii=1,40
            exterr1(i,ii)=exterr(i,ii)
+if time
            exterr2(i,ii)=exterr35(i,ii)
+ei
  120     continue
+if time
          tcnst2(i)=tcnst35(i)
+ei
  130   continue
        do 150 i=kanf,iu
          if(iorg.ge.0) mzu(i-kanf1)=mzu(i)
          ic(i-kanf1)=ic(i)
          icext(i-kanf1)=icext(i)
          icextal(i-kanf1)=icextal(i)
          extalign(i-kanf1,1)=extalign(i,1)
          extalign(i-kanf1,2)=extalign(i,2)
          extalign(i-kanf1,3)=extalign(i,3)
          do 140 ii=1,40
            exterr(i-kanf1,ii)=exterr(i,ii)
+if time
            exterr35(i-kanf1,ii)=exterr35(i,ii)
+ei
  140     continue
+if time
          tcnst35(i-kanf1)=tcnst2(i)
+ei
  150   continue
        do 170 i=1,kanf1
          if(iorg.ge.0) mzu(iu-kanf1+i)=ilfr(i)
          ic(iu-kanf1+i)=ilf(i)
          icext(iu-kanf1+i)=icext1(i)
          icextal(iu-kanf1+i)=icextal1(i)
          extalign(iu-kanf1+i,1)=extalig1(i,1)
          extalign(iu-kanf1+i,2)=extalig1(i,2)
          extalign(iu-kanf1+i,3)=extalig1(i,3)
          do 160 ii=1,40
            exterr(iu-kanf1+i,ii)=exterr1(i,ii)
+if time
            exterr35(iu-kanf1+i,ii)=exterr2(i,ii)
+ei
  160     continue
+if time
          tcnst35(iu-kanf1+i)=tcnst35(i)
+ei
  170   continue
      endif
      
      izu=0
      do 190 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 190
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 190
        if(kzz.eq.15) goto 190
        if(icextal(i).ne.0) then
          izu=izu+2
          xrms(ix)=one
          zrms(ix)=one
          zfz(izu)=extalign(i,1)
          izu=izu+1
          zfz(izu)=extalign(i,2)
          tiltc(i)=cos_mb(extalign(i,3)*c1m3)
          tilts(i)=sin_mb(extalign(i,3)*c1m3)
        else
          izu=izu+3
        endif
        if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.icext(i).ne.0) then
          do 180 j=1,mmul
            izu=izu+1
            zfz(izu)=exterr(i,20+j)
+if time
            zfz35(izu)=exterr35(i,20+j)
+ei
            izu=izu+1
            zfz(izu)=exterr(i,j)
+if time
            zfz35(izu)=exterr35(i,j)
+ei
  180     continue
        else if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.                 &
     &icext(i).eq.0) then
          izu=izu+2*mmul
        endif
  190 continue
      return
      end

+dk phasad
      subroutine phasad(dpp,qwc)
!-----------------------------------------------------------------------
!  ADDITIONAL ADJUSTMENT OF THE X-PHASEADVANCE BETWEEN 2 POSITIONS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ikpv,im,ium,ix,izu,j,jj,jk,jm,k,kpv,kpz,kzz,l,l1,ll,nmz,&
     &dj
      real(kind=fPrec) aa,alfa,bb,benkr,beta,ci,cikve,cr,crkve,crkveuk, &
     &dphi,dpp,dppi,dpr,dyy1,dyy2,ekk,phi,phibf,pie,puf,qu,qv,qw,qwc,   &
     &qxsa,qxse,r0,r0a,t,xl,xs,zl,zs,quz,qvz
+if tilt
      real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension qw(2),qwc(3)
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
!GRD
      qxsa = zero
      qxse = zero
!GRD
      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        qwc(i)=zero
      end do

      qwc(3)=zero

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      pie=two*pi
      ikpv=0
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aenvarqmod',88,R88
!     call abend('aenvarqmod                                        ')
+ei

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 450 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 140
        jj=0
        dj=1
        if(ix.gt.0) goto 70
        ix=-ix
        jj=mel(ix)+1
        dj=-1
   70   jm=mel(ix)

!--BLOCKELEMENTLOOP
        do 130 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 100
          if(ithick.eq.0.and.kz(jk).ne.0) goto 450

!--PURE DRIFTLENGTH
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif

            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif

            if(-one*dphi.gt.pieni) dphi=dphi+pi                          !hr06
            phi(l)=phi(l)+dphi/pie
          end do

          goto 130
!--MAGNETELEMENT
  100     continue
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)                                         !hr06
            endif
            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
  130   continue
        goto 450
!--NL-INSERTION
  140   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 450
        kzz=kz(ix)
        kpv=kpa(ix)
        if(kpv.ne.1) goto 150
        qxsa=phi(1)
  150   if(kpv.ne.2.or.ikpv.eq.1) goto 160
        qxse=phi(1)
        ikpv=1
  160   continue
+ca trom01
+ca trom02
+ca trom03
+ca trom04
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 450
        if(kzz.eq.15) goto 450
! JBG RF CC Multipoles to 450
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 450
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 310
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('kzz',0d0,kzz,0,0,0)
!     call dumpbin('bkzz      ',77 777)
!     call abend('bkzz                                              ')
+ei
        goto(170,180,190,200,210,220,230,240,250,260,270,450,450,450,   &
     &      450,450,450,450,450,450,450,450,450,265,266,450,450,450),kzz
        goto 450
!--HORIZONTAL DIPOLE
  170   ekk=ekk*c1e3
+ca kickl01h
+ca kickq01h
        goto 420
!--NORMAL QUADRUPOLE
  180   continue
+ca kicklxxh
+ca kickq02h
        goto 420
!--NORMAL SEXTUPOLE
  190   ekk=ekk*c1m3
+ca kickq03h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL OCTUPOLE
  200   ekk=ekk*c1m6
+ca kicksho
+ca kickq04h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL DECAPOLE
  210   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL DODECAPOLE
  220   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 14-POLE
  230   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 16-POLE
  240   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 18-POLE
  250   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09h
+ca kicksho
+ca kicklxxh
        goto 420
!--NORMAL 20-POLE
  260   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10h
+ca kicksho
+ca kicklxxh
        goto 420
!--DIPEDGE ELEMENT
  265   continue    
+ca kickldpe
+ca kickqdpe
        goto 420
!--solenoid
  266   continue    
+ca kicklso1
+ca kickqso1
        goto 420
  270   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 280 i=2,ium
+ca multl02
  280       continue
          else
+ca multl03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 290 i=2,ium
+ca multl05
  290       continue
          else
+ca multl06
          endif
        endif
        if(abs(r0).le.pieni) goto 450
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 450
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 300 l=1,nmz
+ca multl07a
  300   continue
        if(nmz.ge.2) then
+ca multl07b
          do 305 l=3,nmz
+ca multl07c
  305     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        goto 420
!--SKEW ELEMENTS
  310   kzz=-kzz
        goto(320,330,340,350,360,370,380,390,400,410),kzz
        goto 450
!--VERTICAL DIPOLE
  320   ekk=ekk*c1e3
+ca kickl01v
+ca kickq01v
        goto 420
!--SKEW QUADRUPOLE
  330   continue
+ca kicklxxv
+ca kickq02v
        goto 420
!--SKEW SEXTUPOLE
  340   ekk=ekk*c1m3
+ca kickq03v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW OCTUPOLE
  350   ekk=ekk*c1m6
+ca kicksho
+ca kickq04v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW DECAPOLE
  360   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
+ca kickq05v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW DODECAPOLE
  370   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq06v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 14-POLE
  380   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq07v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 16-POLE
  390   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq08v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 18-POLE
  400   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq09v
+ca kicksho
+ca kicklxxv
        goto 420
!--SKEW 20-POLE
  410   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kickq10v
+ca kicksho
+ca kicklxxv
  420   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 430 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  430   continue

        do l=1,2
          ll=2*l
          alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))       !hr06
        end do

  450 continue
      qwc(1)=phi(1)
      qwc(2)=phi(2)
      if(qxse.ge.qxsa) then
        qwc(3)=qxse-qxsa
      else
        qwc(3)=(phi(1)+qxse)-qxsa                                        !hr06
      endif
+if debug
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aphasad',97,997)
!     call abend('aphasad                                           ')
+ei
!-----------------------------------------------------------------------
      return
      end
+dk qmod
      subroutine qmod0
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES PLUS AN ADDITIONAL ADJUSTMENT OF A
!  X-PHASEADVANCE BETWEEN 2 POSITIONS IN THE MACHINE
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ierr,ii,iq1,iq2,iq3,iql,j,l,n,nite
      real(kind=fPrec) a11,a12,a13,a21,a22,a23,a31,a32,a33,aa,aa1,bb,   &
     &dpp,dq1,dq2,dq3,qwc,qx,qz,sens,sm0,sqx,sqxh,sqz
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension sens(3,5),aa(3,3),bb(3),qx(3),qz(3),sm0(3),qwc(3)
      dimension aa1(2,2)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do i=1,3
        bb(i)=zero
        qx(i)=zero
        qz(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        do j=1,3
          aa(i,j)=zero
        end do
      end do

      do i=1,3
        do j=1,5
          sens(i,j)=zero
        end do
      end do

      do i=1,2
        do j=1,2
          aa1(i,j)=zero
        end do
      end do

      write(lout,10010)
      sqx=zero
      sqz=zero
      sqxh=zero
      dpp=zero
      iq1=iq(1)
      iq2=iq(2)
      if(kz(iq1).ne.2.or.kz(iq2).ne.2) call prror(8)

      if (abs(el(iq1)).le.pieni.or.abs(el(iq2)).le.pieni) then
        sm0(1)=ed(iq1)
        sm0(2)=ed(iq2)
      else
        sm0(1)=ek(iq1)
        sm0(2)=ek(iq2)
      endif

      if(kp(iq1).eq.5) call combel(iq1)
      if(kp(iq2).eq.5) call combel(iq2)
      sens(1,1)=qw0(1)
      sens(2,1)=qw0(2)

      if(abs(qw0(3)).gt.pieni) then
        iq3=iq(3)
        if(kz(iq3).ne.2) call prror(8)
        if (abs(el(iq3)).le.pieni) then
          sm0(3)=ed(iq3)
        else
          sm0(3)=ek(iq3)
        endif
        if(kp(iq3).eq.5) call combel(iq3)
        nite=3
      else
        nite=2
      endif

      call clorb(dpp)
      if(ierro.gt.0) call prror(9)
      call phasad(dpp,qwc)
      sens(1,5)=qwc(1)
      sens(2,5)=qwc(2)
      if(nite.eq.3) then
        sens(3,1)=qw0(3)
        sens(3,5)=qwc(3)
        write(lout,10100)
        write(lout,10120) qwc,qw0
      else
        write(lout,10110)
        write(lout,10130) qwc(1),qwc(2),qw0(1),qw0(2)
      endif
      do 60 ii=1,itqv
        do 40 n=1,nite
          iql=iq(n)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)+dkq
          else
            ek(iql)=ek(iql)+dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
          call clorb(dpp)
          if(ierro.gt.0) call prror(9)
          call phasad(dpp,qwc)
          sens(1,n+1)=qwc(1)
          sens(2,n+1)=qwc(2)
          if(nite.eq.3) then
            sens(3,n+1)=qwc(3)
            write(lout,10140) ii,n,qwc
          else
            write(lout,10150) ii,n,qwc(1),qwc(2)
          endif
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-dkq
          else
            ek(iql)=ek(iql)-dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
   40   continue
!--Q-VALUE ADJUSTMENT
        aa1(1,1)=(sens(1,2)-sens(1,5))/dkq
        aa1(1,2)=(sens(2,2)-sens(2,5))/dkq
        aa1(2,1)=(sens(1,3)-sens(1,5))/dkq
        aa1(2,2)=(sens(2,3)-sens(2,5))/dkq
        a11=aa1(1,1)
        a12=aa1(1,2)
        a21=aa1(2,1)
        a22=aa1(2,2)
        bb(1)=sens(1,5)-sens(1,1)
        bb(2)=sens(2,5)-sens(2,1)
        sqx=sqx+abs(bb(1))
        sqz=sqz+abs(bb(2))
        if(nite.eq.3) then
          aa(1,1)=a11
          aa(1,2)=a12
          aa(1,3)=(sens(3,2)-sens(3,5))/dkq
          aa(2,1)=a21
          aa(2,2)=a22
          aa(2,3)=(sens(3,3)-sens(3,5))/dkq
          aa(3,1)=(sens(1,4)-sens(1,5))/dkq
          aa(3,2)=(sens(2,4)-sens(2,5))/dkq
          aa(3,3)=(sens(3,4)-sens(3,5))/dkq
          a13=aa(1,3)
          a23=aa(2,3)
          a31=aa(3,1)
          a32=aa(3,2)
          a33=aa(3,3)
          bb(3)=sens(3,5)-sens(3,1)
          sqxh=sqxh+abs(bb(3))
          call loesd(aa,bb,nite,nite,ierr)
        else
          call loesd(aa1,bb,nite,nite,ierr)
        endif
        if(ierr.eq.1) call prror(35)
        do 50 l=1,nite
          iql=iq(l)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-bb(l)
          else
            ek(iql)=ek(iql)-bb(l)
          endif
          if(kp(iql).eq.5) call combel(iql)
   50   continue
        call clorb(dpp)
        if(ierro.gt.0) call prror(9)
        call phasad(dpp,qwc)
        sens(1,5)=qwc(1)
        sens(2,5)=qwc(2)
        if(nite.eq.3) then
          sens(3,5)=qwc(3)
          write(lout,10020) qw0(1),qwc(1),qw0(2),qwc(2),qw0(3),qwc(3)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10040) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2),sm0(3),ed(iq3),bez(iq3)
          else
            write(lout,10040) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2),sm0(3),ek(iq3),bez(iq3)
          endif
          write(lout,10080) sqx,sqz,sqxh
          write(lout,10060) a11,a12,a13,a21,a22,a23,a31,a32,a33
        else
          write(lout,10030) qw0(1),qwc(1),qw0(2),qwc(2)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10050) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2)
          else
            write(lout,10050) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2)
          endif
          write(lout,10090) sqx,sqz
          write(lout,10070) a11,a12,a21,a22
        endif
        if (abs(el(iq(1))).le.pieni) then
          sm0(1)=ed(iq(1))
          sm0(2)=ed(iq(2))
        else
          sm0(1)=ek(iq(1))
          sm0(2)=ek(iq(2))
        endif
        dq1=abs(qwc(1)-qw0(1))
        dq2=abs(qwc(2)-qw0(2))
        if(nite.eq.3) then
          if (abs(el(iq(3))).le.pieni) then
            sm0(3)=ed(iq(3))
          else
            sm0(3)=ek(iq(3))
          endif
          dq3=abs(qwc(3)-qw0(3))
          if(dq1.lt.dqq.and.dq2.lt.dqq.and.dq3.lt.dqq) return
        else
          if(dq1.lt.dqq.and.dq2.lt.dqq) return
        endif
   60 continue
      write(lout,10000) itqv
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'TUNE ADJUSTMENT'/ t10,                             &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.     AFTER CORRECTION'/ t10,       &
     &'HORIZONTAL'     ,17x,g17.10,2x,g17.10/ t10,                      &
     &'VERTICAL'       ,19x,g17.10,2x,g17.10/ t10,                      &
     &'PART-HORIZONTAL',12x,g17.10,2x,g17.10/)
10030 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.      AFTER CORRECTION'/ t10,      &
     &'HORIZONTAL'     ,17x,g17.10,2x,g17.10/ t10,                      &
     &'VERTICAL'       ,19x,g17.10,2x,g17.10/)
10060 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY',14x,   &
     &'D-QXH'/29x,'QF   ',d15.8,3x,d15.8,3x,d15.8/29x,                  &
     &'QD   ',d15.8,3x,d15.8,3x,d15.8/29x,                              &
     &'QF2  ',d15.8,3x,d15.8,3x,d15.8//131('-')//)
10070 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY', /29x, &
     &'QF   ',d15.8,3x,d15.8/29x,'QD   ',d15.8,3x,d15.8 //131('-')//)
10080 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7,  &
     &'   QXH =',f10.7)
10090 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7)
10100 format(t5,'---- QMOD FOR SPLIT-Q-VALUES ENTRY ---- ',             &
     &'(ZERO MOMENTUM-DEVIATION)')
10110 format(t5,'---- QMOD ENTRY ---- (ZERO MOMENTUM-DEVIATION)')
10120 format(t10,'START-QX-QY-QXH',3f12.7,' END-QX-QY-QXH',3f12.7)
10130 format(t10,'START-QX-QY',2f12.7,' END-QX-QY',2f12.7)
10140 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY-QXH',3f12.7)
10150 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY',2f12.7)
10040 format(t10,'QUADRU.STRENGTHS',7x,g17.10,2x,g17.10,'   TYP     ',  &
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
10050 format(t10,'QUADRU.STRENGTHS',7x,g17.10,2x,g17.10,'   TYP     ',  &
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
      end

      subroutine qmodda(mm,qwc)
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES VIA DA
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,intwq,ix,mm,ncorr,ncorruo,ncrr,nd,nd2,ndh
      real(kind=fPrec) cor,coro,dq1,dq2,dps0,edcor1,edcor2,qwc
+ca parpro
+ca common
+ca commons
+ca commont1
+ca commonl
+ca commonxz
+ca commonc
+ca commondl
      dimension intwq(3),qwc(3)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
+if debug
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
+ei
      ncorruo=ncorru
      ncorru=1
      nd2=2*mm
      ndh=nd2+2
      intwq(1)=int(qwc(1))
      intwq(2)=int(qwc(2))
      intwq(3)=0
+if debug
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!sqmodda
!     write(*,*) 'qmodda called!'
!     call dumpbin('sqmodda',80,800)
!     call abend('sqmodda                                           ')
!     write(*,*) 'mm=',mm
+ei
      dq1=zero
      dq2=zero
      if(iqmod6.eq.1) then
        if(el(iq(1)).le.pieni) then
          edcor(1)=ed(iq(1))
        else
          edcor(1)=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          edcor(2)=ed(iq(2))
        else
          edcor(2)=ek(iq(2))
        endif
        edcor1=edcor(1)
        edcor2=edcor(2)
+if debug
!       call warr('edcor1',edcor1,1,0,0,0)
!       call warr('edcor2',edcor2,2,0,0,0)
+ei
        cor=zero
        coro=1.0e38_fPrec
      endif
      do ncorr=1,itqv+1
        if(nbeam.ge.1) then
          nd=mm
+ca beamcou
        endif
        if(iqmod6.eq.1) write(lout,10080) nd2
        if(iqmod6.ne.1) write(lout,10090) nd2
        if(mm.eq.2) then
          write(lout,10010) clo(1),clop(1)
          write(lout,10010) clo(2),clop(2)
        elseif(mm.eq.3) then
          write(lout,10010) clo6(1),clop6(1)
          write(lout,10010) clo6(2),clop6(2)
          write(lout,10010) clo6(3),clop6(3)
        endif
        iqmodc=2
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('bdaini',96,996)
!     call abend('before daini                                      ')
+ei
        call mydaini(1,1,nd2,mm,nd2,1)
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('adaini',96,996)
!     call abend('after  daini                                      ')
+ei
        if(iqmod6.eq.1) then
          write(lout,10000) nd2
          iqmodc=1
          call mydaini(2,3,ndh,mm,nd2,1)
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',99,999)
!     call abend('after  daini                                      ')
+ei
          do i=1,mm
            qwc(i)=real(intwq(i),fPrec)+corr(1,i)                              !hr06
          enddo
          dq1=qwc(1)-qw0(1)
          dq2=qwc(2)-qw0(2)
          if(ncorr.eq.1) cor=sqrt(dq1**2+dq2**2)                         !hr06
          if(abs(dq1).gt.dqq.or.abs(dq2).gt.dqq) then
            cor=sqrt(dq1**2+dq2**2)                                      !hr06
            if(ncorr.eq.1.or.cor.lt.coro) then
              coro=cor
              if(el(iq(1)).le.pieni) then
                ed(iq(1))=(ed(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              else
                ek(iq(1))=(ek(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              endif
              if(el(iq(2)).le.pieni) then
                ed(iq(2))=(ed(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              else
                ek(iq(2))=(ek(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) then
                  ix=ix-nblo
                  if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                    smi(ncrr)=ed(iq(1))*ratioe(ix)+smizf(ncrr)
                  else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                    smi(ncrr)=ed(iq(2))*ratioe(ix)+smizf(ncrr)
                  endif
                endif
              enddo
              if(el(iq(1)).le.pieni) then
                edcor(1)=ed(iq(1))
              else
                edcor(1)=ek(iq(1))
              endif
              if(el(iq(2)).le.pieni) then
                edcor(2)=ed(iq(2))
              else
                edcor(2)=ek(iq(2))
              endif
              if(ncorr.eq.1) then
                write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              else
                write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              endif
              if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              else
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              endif
            else
              write(lout,10050) nd2,ncorr-1
              goto 1
            endif
          else
            write(lout,10060) nd2,ncorr-1
            goto 1
          endif
        else
          iqmodc=3
          call mydaini(2,2,nd2,mm,nd2,1)
          do i=1,mm
            qwc(i)=real(intwq(i),fPrec)+wxys(i)                                !hr06
          enddo
+if debug 
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',98,998)
!     call abend('after  daini 98                                   ')
+ei
          goto 1
        endif
      enddo
 1    continue
      if(iqmod6.eq.1) then
        do ncrr=1,iu
          ix=ic(ncrr)
          if(ix.le.nblo) then
            if(iratioe(ix).eq.iq(1)) ek(ix)=ek(iq(1))*ratioe(ix)
            if(iratioe(ix).eq.iq(2)) ek(ix)=ek(iq(2))*ratioe(ix)
          endif
        enddo
        iqmodc=3
        call mydaini(2,2,nd2,mm,nd2,1)
        do i=1,mm
          qwc(i)=real(intwq(i),fPrec)+wxys(i)                                  !hr06
        enddo
        if(ncorr.eq.itqv+1) write(lout,10070) nd2,itqv
        if(ncorr.eq.1) then
          write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        else
          write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        endif
        if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        else
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        endif
      endif
      ncorru=ncorruo
+if debug
!     call dumpbin('end qmodda',7,999)
!     call abend('end qmodda 7 999                                  ')
+ei
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING ',i1,'D DA TUNE-VARIATION')
10010 format(1x,f47.33/1x,f47.33)
10020 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       BEFORE CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G21.14,G21.14/ t10,                         &
     &'VERTICAL'       ,17x,G21.14,G21.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10030 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       AFTER CORRECTION'/ t10,     &
     &'HORIZONTAL'     ,15x,G21.14,G21.14/ t10,                         &
     &'VERTICAL'       ,17x,G21.14,G21.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10040 format(t10,'QUADRUPOLE STRENGTH',6x,g17.10,4x,g17.10,'   TYP     '&
     &,a16/t10,                  25x,g17.10,4x,g17.10,'           ',    &
     &a16)
10050 format(/t5,'---- NO IMPROVEMENT OF ',i1,'D DA TUNE-VARIATION ',   &
     &'IN ITERATION: ',i4/)
10060 format(/t10,i1,'D DA TUNE-VARIATION SUCCESSFUL IN ITERATION: ',   &
     &i4/)
10070 format(/t10,i1,'D DA TUNE-VARIATION'/ t10,                        &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10080 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA')
10090 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA (NO ',    &
     &'TUNE ADJUSTEMENT)')
      end

+dk umlauf
      subroutine umlauf(dpp,ium,ierr)
!-----------------------------------------------------------------------
!     ONE TURN-TRANSFORMATION (INCLUDING QUADRUPOLE CONTRIBUTIONS)
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer i,ierr,im,ium,ix,izu,j,k,kpz,kx,kzz,l,ll,l1,nmz
      real(kind=fPrec) aa,bb,benkr,ci,cikve,cr,crkve,crkveuk,dpp,dpr,   &
     &dyy1,dyy2,ekk,puf,qu,qv,quz,qvz,r0,r0a,xl,xs,zl,zs
+if tilt
      real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension aa(mmul),bb(mmul),dpr(5)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do 10 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   10 continue
      do 20 i=1,5
        dpr(i)=zero
   20 continue
      ierr=0
      dpr(1)=dpp*c1e3
      izu=0
      do 350 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 60
        if(ix.le.0) goto 40

        do j=1,ium
          do kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
             x(j,kx)=(bl1(ix,kx,1)*puf+bl1(ix,kx,2)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,5)                                                          !hr06
             y(j,kx)=(bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx))+dpr(j)*bl1 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl1(ix,kx,2)*y(j,kx)
            endif
          end do
        end do

        goto 350
   40   ix=-ix

        do j=1,ium
          do kx=1,2
            if(ithick.eq.1) then
              puf=x(j,kx)
             x(j,kx)=(bl2(ix,kx,1)*puf+bl2(ix,kx,2)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,5)                                                          !hr06
             y(j,kx)=(bl2(ix,kx,3)*puf+bl2(ix,kx,4)*y(j,kx))+dpr(j)*bl2 &!hr06
     &(ix,kx,6)                                                          !hr06
            else
              x(j,kx)=x(j,kx)+bl2(ix,kx,2)*y(j,kx)
            endif
          end do
        end do

        goto 350
   60   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 350
        kzz=kz(ix)
        if(abs(x(1,1)).lt.aper(1).and.abs(x(1,2)).lt.aper(2)) goto 70
        ierr=1
        call prror(101)
        return
 70     continue
+ca trom10
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 350
        if(kzz.eq.15) goto 350
! JBG RF CC Multipoles to 350
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 350
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignu
        if(kzz.lt.0) goto 220
        goto(80,90,100,110,120,130,140,150,160,170,180,350,350,350,     &
     &       350,350,350,350,350,350,350,350,350,175,176,350,350,350),  &
     &kzz
        goto 350
!--HORIZONTAL DIPOLE
   80   ekk=ekk*c1e3
+ca kicku01h
        goto 350
!--NORMAL QUADRUPOLE
   90   continue
+ca kickuxxh
        if(ium.eq.1) goto 350
+ca kickq02h
        goto 330
!--NORMAL SEXTUPOLE
  100   ekk=ekk*c1m3
        if(ium.ne.1) then
+ca kickq03h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL OCTUPOLE
  110   ekk=ekk*c1m6
+ca kicksho
        if(ium.ne.1) then
+ca kickq04h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DECAPOLE
  120   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq05h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL DODECAPOLE
  130   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq06h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 14-POLE
  140   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq07h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 16-POLE
  150   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq08h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 18-POLE
  160   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq09h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--NORMAL 20-POLE
  170   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq10h
        endif
+ca kicksho
+ca kickuxxh
        if(ium.eq.1) goto 350
        goto 330
!--DIPEDGE ELEMENT
  175   continue
+ca kickudpe
        if(ium.eq.1) goto 350
+ca kickqdpe
         goto 330
!--solenoid
  176   continue
+ca kickuso1
        if(ium.eq.1) goto 350
+ca kickqso1
         goto 330
  180   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multu01
            do 190 j=2,ium
+ca multu02
  190       continue
          else
+ca multu03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multu04
            do 200 j=2,ium
+ca multu05
  200       continue
          else
+ca multu06
          endif
        endif
        if(abs(r0).le.pieni) goto 350
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 350
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 210 l=1,nmz
+ca multl07a
  210   continue
        if(nmz.ge.2) then
+ca multl07b
          do 215 l=3,nmz
+ca multl07c
  215     continue
        else
+ca multl07d
        endif
+if tilt
+ca multl07e
+ei
        izu=izu+2*mmul-2*nmz
        y(1,1)=y(1,1)+dyy1
        y(1,2)=y(1,2)+dyy2
        if(ium.eq.1) goto 350
        goto 330
!--SKEW ELEMENTS
  220   kzz=-kzz
        goto(230,240,250,260,270,280,290,300,310,320),kzz
        goto 350
!--VERTICAL DIPOLE
  230   ekk=ekk*c1e3
+ca kicku01v
        goto 350
!--SKEW QUADRUPOLE
  240   continue
+ca kickuxxv
        if(ium.eq.1) goto 350
+ca kickq02v
        goto 330
!--SKEW SEXTUPOLE
  250   ekk=ekk*c1m3
        if(ium.ne.1) then
+ca kickq03v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW OCTUPOLE
  260   ekk=ekk*c1m6
+ca kicksho
        if(ium.ne.1) then
+ca kickq04v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DECAPOLE
  270   ekk=ekk*c1m9
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq05v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW DODECAPOLE
  280   ekk=ekk*c1m12
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq06v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 14-POLE
  290   ekk=ekk*c1m15
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq07v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 16-POLE
  300   ekk=ekk*c1m18
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq08v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 18-POLE
  310   ekk=ekk*c1m21
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq09v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
        goto 330
!--SKEW 20-POLE
  320   ekk=ekk*c1m24
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
+ca kicksho
        if(ium.ne.1) then
+ca kickq10v
        endif
+ca kicksho
+ca kickuxxv
        if(ium.eq.1) goto 350
  330   continue
        do 340 j=2,ium
          if(kzz.eq.24) then
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
            y(j,2)=(y(j,2)-x(j,2)*quz)-qvz*x(j,1)                        !hr06
          elseif(kzz.eq.25) then
            crkve=y(j,1)-(x(j,1)*qu)*qv                                  !hr06
            cikve=y(j,2)-(x(j,2)*qu)*qv                                  !hr06
            y(j,1)=crkve*cos_mb(qv)+cikve*sin_mb(qv)                     !hr09
            y(j,2)=cikve*cos_mb(qv)-crkve*sin_mb(qv)                     !hr09
            crkve=x(j,1)*cos_mb(qv)+x(j,2)*sin_mb(qv)                    !hr09
            cikve=x(j,2)*cos_mb(qv)-x(j,1)*sin_mb(qv)                    !hr09
            x(j,1)=crkve 
            x(j,2)=cikve 
          else
            y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
            y(j,2)=(y(j,2)-x(j,2)*qu)-qv*x(j,1)                          !hr06
          endif
  340   continue
  350 continue
!-----------------------------------------------------------------------
      return
      end

+dk resex
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR RMOD
!-----------------------------------------------------------------------
subroutine resex(dpp)
  ! Modified for Fortran 2015 by V.K.B. Olsen on 19/11/2017
  use floatPrecision
  use numerical_constants
  use mathlib_bouncer
  
  implicit none
  integer i,i1,i2,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jl,jm,k,k1,kpz,kzz,l,l1,l2,ll,lmin,m2,m4,m6,min,&
          mm,mpe,mx,n,n2,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
  real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,chy,ci,cikve,cr,crkve,cxzi,cxzr,&
          cxzyi,cxzyr,cxzyrr,del,dphi,dpp,dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,&
          phy,pie,puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,vdt1,vdt2,vdt3,xl,&
          xs,zl,zs,quz,qvz
+if tilt
  real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,tiltck5,tiltckuk,tiltsk,&
          tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
  dimension t(5,4)
  dimension beta(2),alfa(2),phi(2),phibf(2)
  dimension qw(2)
  dimension aa(mmul),bb(mmul),dpr(5)
  dimension nnf(10),ep(2)
  dimension ab1(10),ab2(10),re(10,18),ip(10,18)
  dimension b(10,10),nz2(9),e(10,10)
  dimension chy(9,18),shy(9,18),min(5)
  dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
      
      ium=5
      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
      end do

      do i=1,10
        nnf(i)=0
        do j=1,18
          ip(i,j)=0
          re(i,j)=zero
        end do
      end do

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      do i=1,9
        nz2(i)=0
        do j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do k=1,10
            do ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
            end do
            do l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
              min(l)=0
            end do
          end do
        end do
      end do
      
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3

      call clorb(dpp)
      call betalf(dpp,qw)

      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
         t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
         end do
      end do

!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 770 k=1,iu

        do k1=1,10
          ab1(k1)=zero
          ab2(k1)=zero
        end do

        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 770
!--PURE DRIFTLENGTH
          etl=etl+el(jk)

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
            if(-one*dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          end do

          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            endif
            if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 770
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 770
        kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 770
        if(kzz.eq.15) goto 770
! JBG RF CC Multipoles to 770
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 770
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 770
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        
        select case (kzz)
        case (1)  ! HORIZONTAL DIPOLE
          ekk=ekk*c1e3
+ca kicka01h
        case (2)  ! NORMAL QUADRUPOLE
+ca kicka02h
        case (3)  ! NORMAL SEXTUPOLE
          ekk=ekk*c1m3
+ca kicka03h
        case (4)  ! NORMAL OCTUPOLE
          ekk=ekk*c1m6
+ca kicka04h
        case (5)  ! NORMAL DECAPOLE
          ekk=ekk*c1m9
+ca kicka05h
        case (6)  ! NORMAL DODECAPOLE
          ekk=ekk*c1m12
+ca kicka06h
        case (7)  ! NORMAL 14-POLE
          ekk=ekk*c1m15
+ca kicka07h
        case (8)  ! NORMAL 16-POLE
          ekk=ekk*c1m18
+ca kicka08h
        case (9)  ! NORMAL 18-POLE
          ekk=ekk*c1m21
+ca kicka09h
        case (10) ! NORMAL 20-POLE
          ekk=ekk*c1m24
+ca kicka10h
        case (11)
          r0 = ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
              do i=2,ium
+ca multl02
              end do
            else
+ca multl03
            end if
          end if
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
              do i=2,ium
+ca multl05
              end do
            else
+ca multl06
            end if
          end if
          mpe = 9
          mx  = 0
          if(abs(r0).le.pieni) goto 770
          nmz = nmu(ix)
          if(nmz.eq.0) then
            izu = izu+2*mmul
            goto 770
          end if
          im    = irm(ix)
          r0a   = one
          benkr = ed(ix)/(one+dpp)
          cr(1) = one
          cr(2) = xl
          ci(2) = zl
          cxzyr = xl
          cxzyi = zl
          cxzr  = cxzyr
          cxzi  = cxzyi
          dyy1  = zero
          dyy2  = zero
          qu    = zero
          qv    = zero
          lmin  = 3
          if(nmz.eq.1) lmin=2
          do l=lmin,mmul
            cr(l)=zero
            ci(l)=zero
          end do
          do l=1,nmz
+ca multl13
          end do
+if tilt
+ca multl07e
+ei
          izu = izu+2*mmul-2*nmz
          goto 480
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 480
        case (24) ! DIPEDGE ELEMENT
+ca kickadpe
        case (25) ! Solenoid
+ca kickaso1
        case (26,27,28)
          goto 480
        
        !-----------------
        !--SKEW ELEMENTS--
        !-----------------
        case (-1)  ! VERTICAL DIPOLE
          ekk=ekk*c1e3
+ca kicka01v
        case (-2)  ! SKEW QUADRUPOLE
+ca kicka02v
        case (-3)  ! SKEW SEXTUPOLE
          ekk=ekk*c1m3
+ca kicka03v
        case (-4)  ! SKEW OCTUPOLE
          ekk=ekk*c1m6
+ca kicka04v
        case (-5)  ! SKEW DECAPOLE
          ekk=ekk*c1m9
+ca kicka05v
        case (-6)  ! SKEW DODECAPOLE
          ekk=ekk*c1m12
+ca kicka06v
        case (-7)  ! SKEW 14-POLE
          ekk=ekk*c1m15
+ca kicka07v
        case (-8)  ! SKEW 16-POLE
          ekk=ekk*c1m18
+ca kicka08v
        case (-9)  ! SKEW 18-POLE
          ekk=ekk*c1m21
+ca kicka09v
        case (-10) ! SKEW 20-POLE
          ekk=ekk*c1m24
+ca kicka10v
        end select
        goto 770
  480   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
        do l=1,2
          ll=2*l
          alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
        end do
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 770
        if(mpe.lt.nta) goto 770
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 520
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 520

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do l=2,nmz
          l1=l-1
          ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
        end do

  520   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 540
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 670
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 540

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  540   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 560
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 670
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 560

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  560   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 580
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 670
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  580   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 600
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 670
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  600   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 620
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 670
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 620

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  620   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 640
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 670
        if(mx.eq.6.or.mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  640   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 670
        if(mx.eq.7) goto 660
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  660   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  670   do 700 np=1,mpe
          n2e=2*np
          do 690 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                   !hr06
            ipt=0

            do ii=1,nre
              if(n2.eq.nrr(ii)) ipt=ipr(ii)
            end do

            ip(np,nv)=int(re1+half)+ipt
            if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-real(ip(np,nv),fPrec)                          !hr06
            res=re(np,nv)/radi
           chy(np,nv)=cos_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*phi(2))-res*etl) !hr06
           shy(np,nv)=sin_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*phi(2))-res*etl) !hr06
  690     continue
  700   continue
        do 760 np=nta,mpe
          np2=np
          nkk=0
  710     nkk=nkk+1
          n2e=2*np2
          do 750 i=1,nkk
            do 740 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=real(nn2,fPrec)*half                                    !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 720
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 730
  720         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  730         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  740       continue
  750     continue
          np2=np2-2
          if(np2.ge.1) goto 710
  760   continue
  770 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 810 np=nta,nte
        vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)                            !hr06
        np2=np
        nkk=0
  780   nkk=nkk+1
        n2e=2*np2
        do 800 i=1,nkk
          do 790 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
      vdt2=(vdt1*e(nv1,nv2))/real(((nnf(nf1)*nnf(i))*nnf(nf3))*nnf(nf4),fPrec) !hr06
            vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                         !hr06
            if(n2.ge.0) vdt3=real(n2*nv21,fPrec)*ea+real(nn1*nv11,fPrec)*eb    !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  790     continue
  800   continue
        np2=np2-2
        if(np2.ge.1) goto 780
  810 continue
      if(nur.eq.0) goto 840

      do 830 j=1,nur
        jk=j*2
        do i=1,nur
          jl=nu(i)-npp-jk
          if(jl.eq.0) min(j)=1
          if(jl.eq.0) goto 830
        end do
  830 continue

  840 m2=npp+2
      m4=npp+4
      m6=npp+6
      do 850 i=1,nre
        i2=2*i
        i1=i2-1
        n=nrr(i)+npp
        dtr(i1)=rtc(npp,n,npp,1)+(min(1)*(rtc(npp,n,m2,2)-              &!hr06
     &rtc(npp,n,m2,1))+min(2)*((rtc(npp,n,m4,1)-rtc(npp,n,m4,2))+rtc    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rtc(npp,n,m6,2)-rtc(npp,n,m6,1))-rtc     &!hr06
     &(npp,n,m6,3))+ rtc(npp,n,m6,4))                                    !hr06
        dtr(i2)=rts(npp,n,npp,1)+(min(1)*(rts(npp,n,m2,2)-              &!hr06
     &rts(npp,n,m2,1))+min(2)*((rts(npp,n,m4,1)-rts(npp,n,m4,2))+rts    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rts(npp,n,m6,2)-rts(npp,n,m6,1))-rts     &!hr06
     &(npp,n,m6,3))+rts(npp,n,m6,4))                                     !hr06
  850 continue
  return
end subroutine resex

+dk rmod
      subroutine rmod(dppr)
!-----------------------------------------------------------------------
!  CALCULATION OF THE STRENGTH OF CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  implicit none
  integer i,i1,i2,ierr,irr,j,j1,j2,j3,j4,jj1,jj2,jjr,k,n,no,ntao,nteo
  real(kind=fPrec) aa,bb,d1,de2,dpp,dppr,dsm,ox,oz,qwc,se11,se12,se2,sen,sen15,sen16,sen17,sen18,sn,ss
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension aa(10,10),bb(10),dsm(10),sn(10),sen(10),ss(10)
      dimension qwc(3),d1(10),irr(12)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=npp
      nte=npp
      dpp=dppr

      do i=1,10
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero

        do j=1,10
          aa(i,j)=zero
        end do
      end do

      do i=1,12
        irr(i)=0
      end do

      do i=1,3
        qwc(i)=zero
      end do

      k=1
      jj1=0
      jj2=0
      jjr=2*nre
      de2=de0*half
      if(nre.eq.0) goto 50
      write(lout,10000)
      write(lout,10010) npp,totl,qxt,qzt,tam1
      call resex(dpp)
      do 40 i=1,nre
        i2=2*i
        i1=i2-1
        irr(i1)=ire(i1)
        irr(i2)=ire(i2)
        sn(i1)=ed(irr(i1))
        sn(i2)=ed(irr(i2))
        dsm(i1)=dsm0
        dsm(i2)=dsm0
        write(lout,10020) i,nrr(i),ipr(i)
        sen(i1)=dtr(i1)
        bb(i1)=sen(i1)
        sen(i2)=dtr(i2)
        bb(i2)=sen(i2)
        ss(i1)=sen(i1)
        ss(i2)=sen(i2)
   40 continue
      j2=jjr
   50 if(nur.eq.0) goto 70
      write(lout,10030) nur
      do 60 i=1,nur
        write(lout,10040) nu(i),i
   60 continue
   70 if(nch.eq.0) goto 90
      write(lout,10050)
      j1=j2+1
      j2=j2+2
      irr(j1)=ire(7)
      irr(j2)=ire(8)
      sn(j1)=ed(irr(j1))
      sn(j2)=ed(irr(j2))
      dsm(j1)=dsm0
      dsm(j2)=dsm0
      se2=zero
      se11=zero
      se12=zero
      do 80 n=1,5
        dpp=de2*real(3-n,fPrec)                                                !hr06
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ox=qwc(1)
        oz=qwc(2)
        se2=se2+dpp*dpp
        se11=se11+ox*dpp
        se12=se12+oz*dpp
   80 continue
      sen(j1)=se11/se2
      sen(j2)=se12/se2
      bb(j1)=sen(j1)
      bb(j2)=sen(j2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
   90 if(nqc.eq.0) goto 100
      write(lout,10060)
      j1=j2+1
      j2=j2+2
      jj1=j1
      jj2=j2
      irr(j1)=ire(9)
      irr(j2)=ire(10)
      if (abs(el(irr(j1))).le.pieni.or.abs(el(irr(j2))).le.pieni) then
        sn(j1)=ed(irr(j1))
        sn(j2)=ed(irr(j2))
      else
        sn(j1)=ek(irr(j1))
        sn(j2)=ek(irr(j2))
      endif
      dsm(j1)=dkq
      dsm(j2)=dkq
      dpp=zero
      call clorb2(dpp)
      call phasad(dpp,qwc)
      sen(j1)=qwc(1)
      sen(j2)=qwc(2)
      bb(j1)=sen(j1)-qw0(1)
      bb(j2)=sen(j2)-qw0(2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
  100 do 330 no=1,itcro
        do 160 i=1,j2
          if(i.ne.jj1.and.i.ne.jj2) ed(irr(i))=ed(irr(i))+dsm(i)
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))+dsm(i)
            else
              ek(irr(i))=ek(irr(i))+dsm(i)
            endif
          endif
          if(kp(irr(i)).eq.5) call combel(irr(i))
          if(nre.eq.0) goto 120
          call resex(dpp)
          do 110 j=1,jjr
            aa(i,j)=(dtr(j)-ss(j))/dsm(i)
  110     continue
  120     if(nch.eq.0) goto 140
          j3=jjr+1
          j4=jjr+2
          se2=zero
          se11=zero
          se12=zero
          do 130 n=1,5
            dpp=de2*real(3-n,fPrec)                                            !hr06
            call clorb2(dpp)
            call phasad(dpp,qwc)
            ox=qwc(1)
            oz=qwc(2)
            se2=se2+dpp*dpp
            se11=se11+ox*dpp
            se12=se12+oz*dpp
  130     continue
          sen15=se11/se2
          sen16=se12/se2
          aa(i,j3)=(sen15-ss(j3))/dsm(i)
          aa(i,j4)=(sen16-ss(j4))/dsm(i)
  140     if(nqc.eq.0) goto 150
          dpp=zero
          call clorb2(dpp)
          call phasad(dpp,qwc)
          sen17=qwc(1)
          sen18=qwc(2)
          aa(i,j1)=(sen17-ss(j1))/dsm(i)
          aa(i,j2)=(sen18-ss(j2))/dsm(i)
  150     continue
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-dsm(i)
            else
              ek(irr(i))=ek(irr(i))-dsm(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-dsm(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  160   continue
        call loesd(aa,bb,j2,10,ierr)
        if(ierr.eq.1) call prror(38)
        do 170 i=1,j2
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-bb(i)
            else
              ek(irr(i))=ek(irr(i))-bb(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-bb(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  170   continue
        if(nre.eq.0) goto 190
        call resex(dpp)

        do i=1,jjr
          ss(i)=dtr(i)
          d1(i)=abs(ss(i))
        end do

  190   if(nch.eq.0) goto 210
        se2=zero
        se11=zero
        se12=zero
        do 200 n=1,5
          dpp=de2*real(3-n,fPrec)                                              !hr06
          call clorb2(dpp)
          call phasad(dpp,qwc)
          ox=qwc(1)
          oz=qwc(2)
          se2=se2+dpp*dpp
          se11=se11+ox*dpp
          se12=se12+oz*dpp
  200   continue
        ss(j3)=se11/se2
        ss(j4)=se12/se2
        d1(j3)=abs(ss(j3))
        d1(j4)=abs(ss(j4))
  210   if(nqc.eq.0) goto 220
        dpp=zero
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ss(j1)=qwc(1)
        ss(j2)=qwc(2)
        d1(j1)=abs(qwc(1)-qw0(1))
        d1(j2)=abs(qwc(2)-qw0(2))
  220   write(lout,10070)
        if(nre.eq.0) goto 270
        write(lout,10080) no,nrr(1),sen(1),ss(1),sen(2),ss(2)
        if(nre.eq.1) goto 240

        do i=2,nre
          i2=2*i
          i1=i2-1
          write(lout,10090) nrr(i),sen(i1),ss(i1),sen(i2),ss(i2)
        end do

  240   write(lout,10100)
        write(lout,10110)bez(irr(1)),sn(1),ed(irr(1)),bez(irr(2)),sn(2),&
     &ed(irr(2))
        if(nre.eq.1) goto 260

        do i=2,nre
          i2=2*i
          i1=i2-1
        write(lout,10110)bez(irr(i1)),sn(i1),ed(irr(i1)),bez(irr(i2)),sn&
     &(i2), ed(irr(i2))
        end do

  260   write(lout,10070)
  270   if(nch.eq.0) goto 280
        write(lout,10120) sen(j3),ss(j3),sen(j4),ss(j4)
        write(lout,10110)bez(irr(j3)),sn(j3),ed(irr(j3)),bez(irr(j4)),sn&
     &(j4), ed(irr(j4))
        write(lout,10070)
  280   if(nqc.eq.0) goto 290
        write(lout,10130) qw0(1),qwc(1),qw0(2),qwc(2)
        if (abs(el(irr(j1))).le.pieni) then
          write(lout,10140) sn(j1),ed(irr(j1)),irr(j1),sn(j2),          &
     &ed(irr(j2)),                                                      &
     &irr(j2)
        else
          write(lout,10140) sn(j1),ek(irr(j1)),irr(j1),sn(j2),          &
     &ek(irr(j2)),                                                      &
     &irr(j2)
        endif

  290   do i=1,j2
          if(d1(i).gt.dsi) goto 310
        end do

        nta=ntao
        nte=nteo
        return

  310   do i=1,j2
          bb(i)=ss(i)
        end do

        if(nqc.eq.1) bb(j1)=bb(j1)-qw0(1)
        if(nqc.eq.1) bb(j2)=bb(j2)-qw0(2)
  330 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY RMOD ----')
10010 format(/10x,'N=',i1,' IS THE ORDER OF RESONACE, THAT WILL BE',    &
     &' COMPENSATED'// 10x,'L=',f15.6,'; QX=',f10.5,'; QY=',f10.5,      &
     &'; AMAX=',f10.5)
10020 format(/10x,i1,' RESONANCE; NY=',i2,';CHANGE OF P=',i2)
10030 format(/10x,'NUMBER OF SUBRESONANCES THAT ARE CONSIDERED IS ',i2)
10040 format(/10x,'NU=',i2,' IS THE ',i1,' SUBRESONANCE-MULTIPOLE-ORDER'&
     &,i2)
10050 format(/10x,'CHROMATICITY IS COMPENSATED')
10060 format(/10x,'Q-VALUES ARE ADJUSTED')
10070 format(131('-'))
10080 format(/10x,'RESONANCE-CORRECTION     ITERATION #',i2// 15x,      &
     &'DRIVING-TERM',13x,'BEFORE         AFTER     COMPENSATION'// 10x, &
     &'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,'SIN-COMPONENT  ',2g15.5/&
     &)
10090 format(10x,'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,              &
     &'SIN-COMPONENT  ',2g15.5/)
10100 format(10x,'  ELEMENT NAME'/)
10130 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10140 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10120 format(10x,'CHROMATICITY-CORRECTION'/ 15x,'CHROMATICITY',13x,     &
     &'BEFORE         AFTER     COMPENSATION'// 19x,'HORIZONTAL   ',2g15&
     &.5/ 19x,'VERTICAL     ',2g15.5/ 10x,'   SEXTUPOLE'/)
10110 format(14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,g17.10)
      end

+dk search
      subroutine search(dpp)
!-----------------------------------------------------------------------
!  FINDING THE BEST POSITIONS FOR CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,id,n21,n22,n23,ntao,nteo
      real(kind=fPrec) b,c,c1,c2,c3,d,dpp,e,f,g,s1,s2,s3
      character(len=16) ref
+ca parpro
+ca common
+ca commons
+ca commont1
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=mp
      nte=mp
      ref='REFERENCE       '
      id=0
      write(lout,10010)
      write(lout,10000)
      write(lout,10010)
      write(lout,10020) mp
      write(lout,10010)
      write(lout,10030) m21,ise1,m22,ise2,m23,ise3
      write(lout,10010)
      write(lout,10040)
      write(lout,10010)
      n21=m21+mp
      n22=m22+mp
      n23=m23+mp
      ipt=ise1
      call subsea(dpp)
      c1=rtc(mp,n21,mp,1)
      s1=rts(mp,n21,mp,1)
      ipt=ise2
      call subsea(dpp)
      c2=rtc(mp,n22,mp,1)
      s2=rts(mp,n22,mp,1)
      ipt=ise3
      call subsea(dpp)
      c3=rtc(mp,n23,mp,1)
      s3=rts(mp,n23,mp,1)
      write(lout,10050) ref,id,c1,s1,c2,s2,c3,s3
      do 10 i=1,mesa
        ed(isea(i))=ed(isea(i))+dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
        ipt=ise1
        call subsea(dpp)
        b=rtc(mp,n21,mp,1)-c1
        c=rts(mp,n21,mp,1)-s1
        ipt=ise2
        call subsea(dpp)
        d=rtc(mp,n22,mp,1)-c2
        e=rts(mp,n22,mp,1)-s2
        ipt=ise3
        call subsea(dpp)
        f=rtc(mp,n23,mp,1)-c3
        g=rts(mp,n23,mp,1)-s3
        write(lout,10050) bez(isea(i)),i,b,c,d,e,f,g
        ed(isea(i))=ed(isea(i))-dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
   10 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY SEARCH ----')
10010 format(1x ,131('-'))
10020 format(10x,///'RESONANCES OF ORDER',i4,'  ARE CONSIDERED'//)
10030 format(24x ,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|',6x,'NY =',i4,    &
     &';D-P= ',i4,7x,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|')
10040 format(1x,'ELEMENT          | POS |',6x,'COS',13x,'SIN',6x,'|',   &
     &6x,'COS',13x,'SIN',6x,'|', 6x,'COS',13x,'SIN',6x,'|')
10050 format(1x,a16,1x,'|',i3,'  |',g15.5,'|',g15.5,'|',g15.5,'|',      &
     &g15.5,'|',g15.5,'|',g15.5,'|')
      end

+dk subre
      subroutine subre(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF RESONANCE- AND SUBRESONANCE-DRIVINGTERMS
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ii,ik,im,ip,ipc,ipcc,ipl,ium,iv,ix,izu,j,jj,jk,jm,k,    &
     &k1,kpz,kzz,l,l1,l2,ll,lmin,min1,min2,mis,mm,mpe,mx,n2,n22,n2e,nf1,&
     &nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,nph,nr,ns,ntx,nv,nv1,nv11,nv2, &
     &nv21,nz2,dj
      real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,cc,&
     &chy,ci,cikve,clo0,clop0,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,&
     &dfac,dphi,dpp,dpp1,dppi,dpr,dt,dtu,dtup,dyy1,dyy2,e,ea,eb,ekk,    &
     &ekko,ep,etl,gerad,gtu1,gtu2,phi,phibf,phy,pie,puf,qu,qv,qw,qwc,r0,&
     &r0a,radi,rc,re,re1,res,rn2,rs,sb1,sb2,sdel,sdel2,sea,seb,shy,ss,t,&
     &vdt1,vdt2,vdt3,vdt4,xl,xs,zl,zs,quz,qvz
+if tilt
      real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltck6,tiltck8,tiltck10,tiltckuk,tiltsk,tiltsk1,tiltsk2, &
     &tiltsk3,tiltsk4,tiltsk5,tiltsk6,tiltsk8,tiltsk10
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension t(6,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension clo0(2),clop0(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),qwc(3),dpr(6)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension dfac(10),dtu(2,5),dtup(2,5,0:4,0:4)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
      ipl=1
      gtu1=zero
      gtu2=zero
      dfac(1)=one
      dfac(2)=one
      dfac(3)=two
      dfac(4)=six                                                        !hr13
      dfac(5)=24.0                                                       !hr13
      dfac(6)=120.0_fPrec                                                !hr13
      dfac(7)=720.0_fPrec                                                !hr13
      dfac(8)=5040.0_fPrec                                               !hr13
      dfac(9)=40320.0_fPrec                                              !hr13
      dfac(10)=362880.0_fPrec                                            !hr13
      if(ipt.eq.1) ipl=3

      do 940 ipcc=1,ipl
        ipc=ipcc-ipl+1
        if(ipt.eq.0) ipc=0
        btc=zero
        bts=zero
        phy=zero
        dt=zero
        del=zero
        ns=0
        ik=0

        do i=1,ium
          dpr(i)=zero
        end do

        do i=1,ium
          do j=1,4
            t(i,j)=zero
          end do
        end do

        do i=1,2
          beta(i)=zero
          alfa(i)=zero
          phi(i)=zero
          phibf(i)=zero
          qw(i)=zero
          qwc(i)=zero
          clo0(i)=zero
          clop0(i)=zero
          ep(i)=zero
        end do

        qwc(3)=zero
        do i=1,10
          nnf(i)=0
          do j=1,18
            re(i,j)=zero
            ip(i,j)=0
          end do
        end do

        do i=1,mmul
          aa(i)=zero
          bb(i)=zero
          cr(i)=zero
          ci(i)=zero
        end do

        do i=1,2
          do j=1,5
            dtu(i,j)=zero
          end do
        end do

        do i=1,5
          do j=0,4
            do k=0,4
              dtup(1,i,j,k)=zero
              dtup(2,i,j,k)=zero
            end do
          end do
        end do

        do 120 i=1,9
          nz2(i)=0
          do 110 j=1,18
            chy(i,j)=zero
            shy(i,j)=zero
            do 100 k=1,10
              do 80 ii=1,10
                e(k,ii)=zero
                b(k,ii)=zero
   80         continue
              do 90 l=1,5
                rtc(i,j,k,l)=zero
                rts(i,j,k,l)=zero
   90         continue
  100       continue
  110     continue
  120   continue

        write(lout,10030)
        write(lout,10020)
        pie=two*pi
        etl=zero
        radi=totl/pie
        nr=0
        dpr(1)=dpp*c1e3
        dpr(6)=c1e3
        dpp1=dpp+ded

        call clorb(dpp1)

        do l=1,2
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        call clorb(dpp)

        do l=1,2
          di0(l)=(clo0(l)-clo(l))/ded
          dip0(l)=(clop0(l)-clop(l))/ded
        end do

        write(lout,10030)
        write(lout,10120) (di0(l),dip0(l),l=1,2)
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        if(ierro.ne.0) call prror(22+ierro)
        write(lout,10070) dpp,qwc(1),qwc(2)
        call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
        do l=1,2
          ll=2*l
          alfa(l)=alf0(l)
          beta(l)=bet0(l)
          t(1,ll-1)=clo(l)
          t(1,ll)=clop(l)
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        do i=1,4
          do j=1,4
            t(i+1,j)=ta(j,i)
            t(i+1,j)=ta(j,i)
          end do
        end do

        write(lout,10030)
        write(lout,10040)
        write(lout,10030)
        write(lout,10010) nr,'START   ',zero,zero,(beta(l),alfa(l),     &
     &phi(l),                                                           &
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)

!--EP=EMITTANCE IN PI*MM*MRAD
        ep(1)=tam1**2/beta(1)                                            !hr06
        ep(2)=tam2**2/beta(2)                                            !hr06
        write(lout,10050) tam1,ep(1),tam2,ep(2)
        write(lout,10030)

!--SINGLE TURN BLOCKLOOP
        izu=0
        do 790 k=1,iu
          do k1=1,10
            ab1(k1)=zero
            ab2(k1)=zero
          end do

          ix=ic(k)
          if(ix.gt.nblo) goto 250
          jj=0
          dj=1
          if(ix.gt.0) goto 180
          ix=-1*ix
          jj=mel(ix)+1
          dj=-1
  180     jm=mel(ix)

!--SINGLE TURN BLOCKLOOP
          do 240 j=1,jm
            jj=jj+dj
            jk=mtyp(ix,jj)
            if(ithick.eq.1.and.kz(jk).ne.0) goto 210
            if(ithick.eq.0.and.kz(jk).ne.0) goto 790

!--PURE DRIFTLENGTH
            etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
              do i=1,ium
                t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
              end do
            end do

            do l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)

              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif

              if(-one*dphi.gt.pieni) dphi=dphi+pi                        !hr06
              phi(l)=phi(l)+dphi/pie
            end do

            nr=nr+1
            goto 240

!--MAGNETELEMENT
  210       continue
            if(kz(jk).ne.8) etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=zero
              endif
              do i=1,ium
                puf=t(i,ll-1)
                t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a    &!hr06
     &(jk,l,5)
              t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6) !hr06
              enddo
            enddo
            do l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=-phibf(l)
              endif
              if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
              phi(l)=phi(l)+dphi/pie
            enddo
            nr=nr+1
  240     continue
          goto 790

!--NL-INSERTION
  250     ix=ix-nblo
          qu=zero
          qv=zero
          kpz=kp(ix)
          if(kpz.eq.6) goto 790
          kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
          clo0(1)=t(1,1)
          clop0(1)=t(1,2)
          clo0(2)=t(2,3)
          clop0(2)=t(2,4)
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 790
          if(kzz.eq.15) goto 790
! JBG RF CC Multipoles to 790
          if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 790
          if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 790
          dyy1=zero
          dyy2=zero
          if(iorg.lt.0) mzu(k)=izu
          izu=mzu(k)+1
          ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
          izu=izu+1
          xs=xpl(ix)+zfz(izu)*xrms(ix)
          izu=izu+1
          zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
          if(kzz.lt.0) goto 400
          goto(260,270,280,290,300,310,320,330,340,350,360,790,790,790, &
     &      790,790,790,790,790,790,790,790,790,355,356,790,790,790),kzz
          goto 790

!--HORIZONTAL DIPOLE
  260     ekk=ekk*c1e3
+ca kicka01h
          goto 510
!--NORMAL QUADRUPOLE
  270     continue
+ca kicka02h
          goto 510
!--NORMAL SEXTUPOLE
  280     ekk=ekk*c1m3
+ca kicka03h
          goto 510
!--NORMAL OCTUPOLE
  290     ekk=ekk*c1m6
+ca kicka04h
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DECAPOLE
  300     ekk=ekk*c1m9
+ca kicka05h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL DODECAPOLE
  310     ekk=ekk*c1m12
+ca kicka06h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 14-POLE
  320     ekk=ekk*c1m15
+ca kicka07h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 16-POLE
  330     ekk=ekk*c1m18
+ca kicka08h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 18-POLE
  340     ekk=ekk*c1m21
+ca kicka09h
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--NORMAL 20-POLE
  350     ekk=ekk*c1m24
+ca kicka10h
+ca kispa10h
          goto 510
!--DIPEDGE ELEMENT
  355     continue
+ca kickadpe
          goto 510
!--solenoid
  356     continue
+ca kickaso1
          goto 510
  360     r0=ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 363 i=2,ium
+ca multl02
  363       continue
            else
+ca multl03
            endif
          endif
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 366 i=2,ium
+ca multl05
  366       continue
            else
+ca multl06
            endif
          endif
          mpe=9
          mx=0
          if(abs(r0).le.pieni) goto 790
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 790
          endif
          im=irm(ix)
          r0a=one
          benkr=ed(ix)/(one+dpp)
          cr(1)=one
          cr(2)=xl
          ci(2)=zl
          cxzyr=xl
          cxzyi=zl
          cxzr=cxzyr
          cxzi=cxzyi
          dyy1=zero
          dyy2=zero
          qu=zero
          qv=zero
          lmin=3
          if(nmz.eq.1) lmin=2

          do l=lmin,mmul
            aa(l)=zero
            bb(l)=zero
            cr(l)=zero
            ci(l)=zero
          end do

          do 380 l=1,nmz
+ca multl13
  380     continue
+if tilt
+ca multl07e
+ei
          izu=izu+2*mmul-2*nmz
          do 390 iv=2,5
+ca multl12
  390     continue
          goto 510
!--SKEW ELEMENTS
  400     kzz=-kzz
          goto(410,420,430,440,450,460,470,480,490,500),kzz
          goto 790
!--VERTICAL DIPOLE
  410     ekk=ekk*c1e3
+ca kicka01v
          goto 510
!--SKEW QUADRUPOLE
  420     continue
+ca kicka02v
          goto 510
!--SKEW SEXTUPOLE
  430     ekk=ekk*c1m3
+ca kicka03v
          goto 510
!--SKEW OCTUPOLE
  440     ekk=ekk*c1m6
+ca kicka04v
          goto 510
!--SKEW DECAPOLE
  450     ekk=ekk*c1m9
+ca kicka05v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW DODECAPOLE
  460     ekk=ekk*c1m12
+ca kicka06v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 14-POLE
  470     ekk=ekk*c1m15
+ca kicka07v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 16-POLE
  480     ekk=ekk*c1m18
+ca kicka08v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 18-POLE
  490     ekk=ekk*c1m21
+ca kicka09v
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
          goto 510
!--SKEW 20-POLE
  500     ekk=ekk*c1m24
+ca kicka10v
+ca kispa10v
  510     continue
          t(1,2)=t(1,2)+dyy1
          t(1,4)=t(1,4)+dyy2
          do 520 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  520     continue

          do l=1,2
            ll=2*l
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            clop0(l)=t(1,ll)
          end do

          if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 790
          if(mpe.lt.nta) goto 790
          if(mpe.gt.nte) mpe=nte
          if(nta.gt.2) goto 550
          if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.  &
     &mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 550

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          do l=2,nmz
            l1=l-1
            ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          end do

  550     b1=beta(1)
          b2=beta(2)
          sb1=sqrt(b1)
          sb2=sqrt(b2)
          b(3,1)=b1
          b(1,3)=b2
          b(2,2)=sb1*sb2
          if(nta.gt.3) goto 570
          if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 700
          if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx &
     &.eq.6.or.mx.eq.7) goto 570

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=3,nmz
            l1=l-2
            ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
            l2=l2*l/l1
          end do

  570     b(4,1)=b1*sb1
          b(1,4)=b2*sb2
          b(3,2)=b1*sb2
          b(2,3)=b2*sb1
          if(nta.gt.4) goto 590
          if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 700
          if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx &
     &.eq.7) goto 590

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=4,nmz
            l1=l-3
            ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))     !hr06
            ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))     !hr06
            l2=l2*l/l1
          end do

  590     b(5,1)=b1**2                                                   !hr06
          b(1,5)=b2**2                                                   !hr06
          b(4,2)=b(3,2)*sb1
          b(2,4)=b(2,3)*sb2
          b(3,3)=b1*b2
          if(nta.gt.5) goto 610
          if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 700
          if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)      &
     &goto 610

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=5,nmz
            l1=l-4
            ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  610     b(6,1)=b(5,1)*sb1
          b(1,6)=b(1,5)*sb2
          b(5,2)=b(4,2)*sb1
          b(2,5)=b(2,4)*sb2
          b(4,3)=b(4,2)*sb2
          b(3,4)=b(2,4)*sb1
          if(nta.gt.6) goto 630
          if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 700
          if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 630

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=6,nmz
            l1=l-5
            ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  630     b(7,1)=b(6,1)*sb1
          b(1,7)=b(1,6)*sb2
          b(6,2)=b(5,2)*sb1
          b(2,6)=b(2,5)*sb2
          b(5,3)=b(5,2)*sb2
          b(3,5)=b(2,5)*sb1
          b(4,4)=b(3,4)*sb1
          if(nta.gt.7) goto 650
          if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 700
          if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 650

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=7,nmz
            l1=l-6
            ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  650     b(8,1)=b(7,1)*sb1
          b(1,8)=b(1,7)*sb2
          b(7,2)=b(7,1)*sb2
          b(2,7)=b(1,7)*sb1
          b(6,3)=b(5,3)*sb1
          b(3,6)=b(3,5)*sb2
          b(5,4)=b(4,4)*sb1
          b(4,5)=b(4,4)*sb2
          if(nta.gt.8) goto 670
          if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 700
          if(mx.eq.6.or.mx.eq.7) goto 670

!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=8,nmz
            l1=l-7
            ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  670     b(9,1)=b(8,1)*sb1
          b(1,9)=b(1,8)*sb2
          b(8,2)=b(8,1)*sb2
          b(2,8)=b(1,8)*sb1
          b(7,3)=b(7,2)*sb2
          b(3,7)=b(2,7)*sb1
          b(6,4)=b(6,3)*sb2
          b(4,6)=b(3,6)*sb1
          b(5,5)=b(4,5)*sb1
          if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 700
          if(mx.eq.7) goto 690

!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
          l2=1
          do l=9,nmz
            l1=l-8
            ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))     !hr06
            ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))     !hr06
            l2=l2*l/l1
          end do

  690     b(10,1)=b(9,1)*sb1
          b(1,10)=b(1,9)*sb2
          b(9,2)=b(9,1)*sb2
          b(2,9)=b(1,9)*sb1
          b(8,3)=b(8,2)*sb2
          b(3,8)=b(2,8)*sb1
          b(4,7)=b(3,7)*sb1
          b(7,4)=b(7,3)*sb2
          b(5,6)=b(4,6)*sb1
          b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  700     do 720 np=1,mpe
            n2e=2*np
            do 710 nv=1,n2e
              n2=nv-np
              nn2=abs(n2)
              nn1=np-nn2
              re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                             !hr06
              ip(np,nv)=int(re1+half)+ipc
              if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipc
!--RE=DISTANCE FROM THE RESONANCE
              re(np,nv)=re1-real(ip(np,nv),fPrec)
              res=re(np,nv)/radi
          chy(np,nv)=cos_mb((real(nn1,fPrec)*pie*phi(1)+real(n2,fPrec)* &
     &pie*phi(2))-res*etl)                                                           !hr06
          shy(np,nv)=sin_mb((real(nn1,fPrec)*pie*phi(1)+real(n2,fPrec)* &
     &pie*phi(2))-res*etl)                                                           !hr06
  710       continue
  720     continue
          do 780 np=nta,mpe
            np2=np
            nkk=0
  730       nkk=nkk+1
            n2e=2*np2
            do 770 i=1,nkk
              do 760 nv=1,n2e
                nn2=abs(nv-np2)
                nv1=np2-nn2+(i-1)*2+1
                nv2=np-nv1+2
                rn2=real(nn2,fPrec)*half                                            !hr06
!--EVENESS OF N2
                mm=0
                gerad=rn2-aint(rn2)
                if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
                if (mm.eq.0) goto 740
                btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
                goto 750
  740           btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
  750           rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
                rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  760         continue
  770       continue
            np2=np2-2
            if(np2.ge.1) goto 730
  780     continue
          nr=nr+1
  790   continue
        nnf(1)=1
        nnf(2)=1
        nnf(3)=2
        nz2(2)=2
        sea=sqrt(ep(1))
        seb=sqrt(ep(2))
        ea=ep(1)
        eb=ep(2)
        e(3,1)=one/eb
        e(1,3)=one/ea
        e(2,2)=(one/seb)/sea                                             !hr06
        nnf(4)=6
        nz2(3)=4
        e(4,1)=sea/eb
        e(1,4)=seb/ea
        e(3,2)=one/seb
        e(2,3)=one/sea
        nnf(5)=24
        nz2(4)=8
        e(5,1)=ea/eb
        e(1,5)=eb/ea
        e(4,2)=sea/seb
        e(2,4)=seb/sea
        e(3,3)=one
        nnf(6)=120
        nz2(5)=16
        e(6,1)=e(5,1)*sea
        e(1,6)=e(1,5)*seb
        e(5,2)=ea/seb
        e(2,5)=eb/sea
        e(4,3)=sea
        e(3,4)=seb
        nnf(7)=720
        nz2(6)=32
        e(7,1)=e(6,1)*sea
        e(1,7)=e(1,6)*seb
        e(6,2)=e(5,2)*sea
        e(2,6)=e(2,5)*seb
        e(5,3)=ea
        e(3,5)=eb
        e(4,4)=sea*seb
        nnf(8)=5040
        nz2(7)=64
        e(8,1)=e(7,1)*sea
        e(1,8)=e(1,7)*seb
        e(7,2)=e(6,2)*sea
        e(2,7)=e(2,6)*seb
        e(6,3)=ea*sea
        e(3,6)=eb*seb
        e(5,4)=ea*seb
        e(4,5)=sea*eb
        nnf(9)=40320
        nz2(8)=128
        e(9,1)=e(8,1)*sea
        e(1,9)=e(1,8)*seb
        e(8,2)=e(7,2)*sea
        e(2,8)=e(2,7)*seb
        e(7,3)=ea**2                                                     !hr06
        e(3,7)=eb**2                                                     !hr06
        e(6,4)=e(5,4)*sea
        e(4,6)=e(4,5)*seb
        e(5,5)=ea*eb
        nnf(10)=362880
        nz2(9)=256
        e(10,1)=e(9,1)*sea
        e(1,10)=e(1,9)*seb
        e(9,2)=e(8,2)*sea
        e(2,9)=e(2,8)*seb
        e(8,3)=e(7,3)*sea
        e(3,8)=e(3,7)*seb
        e(7,4)=e(6,4)*sea
        e(4,7)=e(4,6)*seb
        e(6,5)=e(5,5)*sea
        e(5,6)=e(5,5)*seb
        write(lout,10000)
        write(lout,10030)
        write(lout,10010)nr,'END     ',etl,zero,(beta(l),alfa(l),phi(l),&
     &di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
        write(lout,10030)
        write(lout,10110) etl,qwc(1),qwc(2)
        write(lout,10030)
        do 800 iv=2,5
          gtu1=gtu1+dtu(1,iv)
          gtu2=gtu2+dtu(2,iv)
  800   continue
        write(lout,10150) dtu(1,2),dtu(1,3),dtu(1,4),dtu(1,5),gtu1, dtu &
     &(2,2),dtu(2,3),dtu(2,4),dtu(2,5),gtu2

        do i=1,2
          do j=1,5
            do l=0,4
              do k=0,4
                if(i.eq.2.and.j.eq.1.and.k.eq.1.and.l.eq.1) write       &
     &(lout,10160)
                if(abs(dtup(i,j,k,l)).gt.pieni) write(lout,             &
     &'(10X,G17.10,3X,I2,2X,I2)') dtup(i,j,k,l),k,l
              end do
            end do
          end do
        end do

        write(lout,10060)
        write(lout,10030)
        do 880 np=nta,nte
          write(lout,10080) np
          write(lout,10030)
          vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)               !hr06
          np2=np
          nkk=0
          write(lout,10090) np
          goto 830
  820     write(lout,10100) np,np2
  830     nkk=nkk+1
          n2e=2*np2
          do 850 i=1,nkk
            do 840 nv=1,n2e
              n2=nv-np2
              nn2=abs(n2)
              nn1=np2-nn2
              nv1=(nn1+(i-1)*2)+1                                        !hr06
              nv2=(np-nv1)+2                                             !hr06
              nv11=nv1-1
              nv21=nv2-1
              nf1=nn1+i
              nf3=nkk-i+1
              nf4=nf3+nn2
          vdt2=vdt1*e(nv1,nv2)/                                         &
     &         real(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4),fPrec)             !hr06
              vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                 !hr06
              vdt4=vdt3
              if(n2.ge.0) vdt3=real(n2*nv21,fPrec)*ea+                  &
     &                         real(nn1*nv11,fPrec)*eb                   !hr06
              rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
              rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  840       continue
  850     continue
          do 870 nv=1,n2e
            mis=1
            rc=zero
            rs=zero
            do 860 i=1,nkk
              rc=rc+real(mis,fPrec)*rtc(np2,nv,np,i)                     !hr06
              rs=rs+real(mis,fPrec)*rts(np2,nv,np,i)                     !hr06
              mis=-mis
  860       continue
            sdel2=sqrt(rc**2+rs**2)                                      !hr06
            n22=nv-np2
            write(lout,10140) n22,ip(np2,nv),ipc,rc,rs,re(np2,nv),sdel2
  870     continue
          np2=np2-2
          if(np2.ge.1) goto 820
  880   continue
        ntx=nte-2
        write(lout,10130)
        do 930 np=1,nte
          write(lout,10090) np
          n2e=2*np
          do 920 nv=1,n2e
            n2=nv-np
            nkk=2
            nph=np+2
            min1=-1
  890       min2=min1
            do 900 i=1,nkk
             rtc(np,nv,np,1)=rtc(np,nv,np,1)+real(min2,fPrec)*          &
     &rtc(np,nv,nph,i) !hr06
             rts(np,nv,np,1)=rts(np,nv,np,1)+real(min2,fPrec)*          &
     &rts(np,nv,nph,i) !hr06
              min2=-min2
  900       continue
            nph=nph+2
            if(nph.gt.nte) goto 910
            nkk=nkk+1
            min1=-min1
            goto 890
  910       cc=rtc(np,nv,np,1)
            ss=rts(np,nv,np,1)
            sdel=sqrt(cc**2+ss**2)                                       !hr06
            write(lout,10140) n2,ip(np,nv),ipc,cc,ss,re(np,nv),sdel
  920     continue
  930   continue
  940 continue
      call clorb(ded)
      do 950 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  950 continue
      call clorb(zero)
      do 960 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  960 continue
!-----------------------------------------------------------------------
      return
10000 format(1x,i4,27x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x, &
     &f6.3,1x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x,f6.3)
10020 format(t5,'---- ENTRY SUBRES ----')
10030 format(131('-'))
10040 format('  NR  TYP      L-TOTAL  LENGTH   BETAH  ALFAH  ',         &
     &' PHIH   DISH  DISPH   CLOH  CLOPH',                              &
     &'   BETAV  ALFAV   PHIV   DISV  DISPV   CLOV  CLOPV'/ 1x,         &
     &'                 (M)      (M)     (M)           ',               &
     &'(QE)   (M)   (RAD)   (MM) (MRAD)',                               &
     &'    (M)           (QE)   (M)   (RAD)   (MM) (MRAD)')
10050 format(//7x,'INIT. X-AMPLITUDE=',g15.8,'X-EMITTANCE=',g15.8,/40x, &
     &/7x,'INIT. Y-AMPLITUDE=',g15.8,'Y-EMITTANCE=',g15.8,              &
     &'UNITS ARE (PI X MM X MRAD)'//)
10060 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x)
10070 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7)
10080 format(/10x,'RESONANCE EXCITING MULTIPOLE-ORDER = ',i2)
10090 format(//20x,'RESONANCE-ORDER =',i2/20x,100('-')/ 20x,'| NY |',   &
     &'   P  | D-P |',2x,'DRIVING-COS ',3x,'|', 2x,'DRIVING-SIN ',3x,'|'&
     &, 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10100 format(//20x,'RESONANCE-ORDER =',i2,5x,'SUBRESONANCE-ORDER = ',i2,&
     &/20x,100('-')/ 20x,'| NY |','   P  | D-P |',2x,'DRIVING-COS ',3x, &
     &'|', 2x,'DRIVING-SIN ',3x,'|', 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10110 format(/10x,'PRECISE LENGTH OF THE MACHINE : ',f43.33/ /10x,      &
     &'   PRECISE HORIZONTAL Q-VALUE : ',f43.33/ /10x,                  &
     &'     PRECISE VERTICAL Q-VALUE : ',f43.33/)
10120 format(t8,'  PLANE     DISP(MM)     DISP(MRAD)   '/ t6,'      X  '&
     &,2(f12.3,3x)/t10,'  Y  ',2(f12.3,3x)/)
10130 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x,    &
     &'!!!! ALL SUBRESONANCES ARE INCLUDED !!!! ')
10140 format(20x,'| ',i2,' | ',i4,' | ',i3,' |', g16.8,' |',g16.8,' |', &
     &g16.8,' |',g16.8,' |')
10150 format(/10x,'NONLINEAR DETUNING  '// 10x,'CHANGE IN QX'/ 10x,     &
     &' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ 10x,' 8. ORDER ',f15&
     &.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  ',f15.12/ 10x,       &
     &'CHANGE IN QY'/ 10x,' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ &
     &10x,' 8. ORDER ',f15.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  '&
     &,f15.12// 10x,'DETUNING ORDER BY ORDER'// 10x,                    &
     &'Qx - COEFFICIENT   Ex  EY'/ 10x,'-------------------------')
10160 format(/ 10x,'Qy - COEFFICIENT   Ex  Ey'/ 10x,                    &
     &'-------------------------')
10010 format(1x,i4,1x,a8,1x,f8.2,1x,f7.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.&
     &2,1x,f6.3,1x,f6.2,1x,f6.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6. &
     &3,1x,f6.2,1x,f6.3)
      end

      subroutine detune(iv,ekk,ep,beta,dtu,dtup,dfac)
!-----------------------------------------------------------------------
!  USED FOR SUBRE - CALCULATES DETUNING
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer iv,iv2,iv3,iv4,iv5,iv6
      real(kind=fPrec) beta,dfac,dtu,dtu1,dtu2,dtup,ekk,ep,pi,vor,vtu1, &
     &vtu2
+ca parpro
      dimension dfac(10),dtu(2,5),ep(2),beta(2),dtup(2,5,0:4,0:4)
      save
!-----------------------------------------------------------------------
      if(iv.lt.2) then
        write(lout,*)
        write(lout,*) '       ***** ERROR IN DETUNE *****'
        write(lout,*)
        write(lout,*) '       IV LESS THAN 2, NO DETUNING POSSIBLE'
        write(lout,*)
        return
      endif
      pi=four*atan_mb(one)
      iv2=2*iv
      iv3=iv+1
!      vtu1=(((-one*ekk)*(half**iv2))*dfac(iv2))/pi                       !hr06
      vtu1=(((-one*ekk)*exp_mb(real(iv2,fPrec)*log_mb(half)))*          &
     &dfac(iv2))/pi    !hr13
      dtu1=zero
      dtu2=zero
      do 10 iv4=1,iv3
        iv5=iv4-1
        iv6=iv-iv5
        vor=one
        if(mod(iv6,2).ne.0) vor=-one                                 !hr06
!        vtu2=vor/(dfac(iv5+1)**2)/(dfac(iv6+1)**2)*(beta(1)**iv5)* (beta&
!     &(2)**iv6)
        vtu2=(((vor/(dfac(iv5+1)**2))/(dfac(iv6+1)**2))*                &!hr13
     &exp_mb(real(iv5,fPrec)*log_mb(beta(1))))*                         &!hr13
     &exp_mb(real(iv6,fPrec)*log_mb(beta(2)))                            !hr13
        if(iv5.ne.0) then
!          dtu1=dtu1+((vtu2*dble(iv5))*(ep(1)**(iv5-1)))*(ep(2)**iv6)    !hr06
         dtu1=dtu1+((vtu2*real(iv5,fPrec))*exp_mb(real(iv5-1,fPrec)*    &
     &log_mb(ep(1))))*exp_mb(real(iv6,fPrec)*log_mb(ep(2)))                           !hr13
         dtup(1,iv,iv5-1,iv6)=dtup(1,iv,iv5-1,iv6)+                     &
     &(vtu2*real(iv5,fPrec))*vtu1 !hr06
        endif
        if(iv6.ne.0) then
!          dtu2=dtu2+((vtu2*dble(iv6))*(ep(1)**iv5))*(ep(2)**(iv6-1))     !hr06
          dtu2=dtu2+((vtu2*real(iv6,fPrec))*exp_mb(real(iv5,fPrec)*     &
     &log_mb(ep(1))))*exp_mb(real(iv6-1,fPrec)*log_mb(ep(2)))                  !hr13
         dtup(2,iv,iv5,iv6-1)=dtup(2,iv,iv5,iv6-1)+                     &
     &(vtu2*real(iv6,fPrec))*vtu1 !hr06
        endif
   10 continue
      dtu(1,iv)=dtu(1,iv)+vtu1*dtu1
      dtu(2,iv)=dtu(2,iv)+vtu1*dtu2
      return
      end

+dk subsea
      subroutine subsea(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR SEARCH
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jm,k,k1,kpz,kzz,l,l1,    &
     &l2,ll,lmin,mm,mpe,mx,n2,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,   &
     &np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
      real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,   &
     &chy,ci,cikve,cr,crkve,cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dphi,dpp,  &
     &dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,phy,pie, &
     &puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,    &
     &vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
+if tilt
      real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,&
     &tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
+ei
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension cr(mmul),ci(mmul)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue

      do i=1,10
        nnf(i)=0
        do j=1,18
          ip(i,j)=0
          re(i,j)=zero
        end do
      end do

      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue

      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
   70       continue
   80     continue
   90   continue
  100 continue

      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb2(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 740 k=1,iu
        do k1=1,10
          ab1(k1)=zero
          ab2(k1)=zero
        end do

        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 740

!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif

            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif

            if(-one*dphi.gt.pieni) dphi=dphi+pi                          !hr06
            phi(l)=phi(l)+dphi
          end do

          goto 200

!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-phibf(l)
            endif
            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 740
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 740
        kzz=kz(ix)
+ca trom01
+ca trom02
+ca trom03
+ca trom05
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 740
        if(kzz.eq.15) goto 740
! JBG RF CC Multipoles to 740
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 740
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 740 
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
+ca alignl
        if(kzz.lt.0) goto 350
        goto(220,230,240,250,260,270,280,290,300,310,320,740,740,740,   &
     &      740,740,740,740,740,740,740,740,740,315,316,740,740,740),kzz
        goto 740
!--HORIZONTAL DIPOLE
  220   ekk=ekk*c1e3
+ca kicka01h
        goto 460
!--NORMAL QUADRUPOLE
  230   continue
+ca kicka02h
        goto 460
!--NORMAL SEXTUPOLE
  240   ekk=ekk*c1m3
+ca kicka03h
        goto 460
!--NORMAL OCTUPOLE
  250   ekk=ekk*c1m6
+ca kicka04h
        goto 460
!--NORMAL DECAPOLE
  260   ekk=ekk*c1m9
+ca kicka05h
        goto 460
!--NORMAL DODECAPOLE
  270   ekk=ekk*c1m12
+ca kicka06h
        goto 460
!--NORMAL 14-POLE
  280   ekk=ekk*c1m15
+ca kicka07h
        goto 460
!--NORMAL 16-POLE
  290   ekk=ekk*c1m18
+ca kicka08h
        goto 460
!--NORMAL 18-POLE
  300   ekk=ekk*c1m21
+ca kicka09h
        goto 460
!--NORMAL 20-POLE
  310   ekk=ekk*c1m24
+ca kicka10h
        goto 460
!--DIPEDGE ELEMENT
  315   continue  
+ca kickadpe
        goto 460
!--solenoid
  316   continue  
+ca kickaso1
        goto 460
  320   r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl01
            do 323 i=2,ium
+ca multl02
  323       continue
          else
+ca multl03
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
+ca multl04
            do 326 i=2,ium
+ca multl05
  326       continue
          else
+ca multl06
          endif
        endif
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 740
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 740
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2

        do l=lmin,mmul
          cr(l)=zero
          ci(l)=zero
        end do

        do 340 l=1,nmz
+ca multl13
  340   continue
+if tilt
+ca multl07e
+ei
        izu=(izu+2*mmul)-2*nmz                                           !hr06
        goto 460
!--SKEW ELEMENTS
  350   kzz=-kzz
        goto(360,370,380,390,400,410,420,430,440,450),kzz
        goto 740
!--VERTICAL DIPOLE
  360   ekk=ekk*c1e3
+ca kicka01v
        goto 460
!--SKEW QUADRUPOLE
  370   continue
+ca kicka02v
        goto 460
!--SKEW SEXTUPOLE
  380   ekk=ekk*c1m3
+ca kicka03v
        goto 460
!--SKEW OCTUPOLE
  390   ekk=ekk*c1m6
+ca kicka04v
        goto 460
!--SKEW DECAPOLE
  400   ekk=ekk*c1m9
+ca kicka05v
        goto 460
!--SKEW DODECAPOLE
  410   ekk=ekk*c1m12
+ca kicka06v
        goto 460
!--SKEW 14-POLE
  420   ekk=ekk*c1m15
+ca kicka07v
        goto 460
!--SKEW 16-POLE
  430   ekk=ekk*c1m18
+ca kicka08v
        goto 460
!--SKEW 18-POLE
  440   ekk=ekk*c1m21
+ca kicka09v
        goto 460
!--SKEW 20-POLE
  450   ekk=ekk*c1m24
+ca kicka10v
  460   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 470 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
+ca phas1so1
+ca phas2so1
+ca phas3so1
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  470   continue
        do 480 l=1,2
          ll=2*l
          alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
  480   continue
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 740
        if(mpe.lt.nta) goto 740
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 500
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx  &
     &.eq.5.or.mx.eq.6.or.mx.eq.7) goto 500

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do l=2,nmz
          l1=l-1
          ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
        end do

  500   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 520
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 650
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 520

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  520   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 540
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 650
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 540

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  540   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 560
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 650
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 560

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  560   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 580
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 650
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  580   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 600
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 650
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  600   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 620
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 650
        if(mx.eq.6.or.mx.eq.7) goto 620

!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  620   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 650
        if(mx.eq.7) goto 640

!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
         l2=l2*l/l1
        end do

  640   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  650   do 670 np=1,mpe
          n2e=2*np
          do 660 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                               !hr06
            ip(np,nv)=int(re1+half)+ipt
            if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt      !hr06
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-real(ip(np,nv),fPrec)                          !hr06
            res=re(np,nv)/radi
           chy(np,nv)=cos_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*    &
     &phi(2))-res*etl) !hr06
           shy(np,nv)=sin_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*    &
     &phi(2))-res*etl) !hr06
  660     continue
  670   continue
        do 730 np=nta,mpe
          np2=np
          nkk=0
  680     nkk=nkk+1
          n2e=2*np2
          do 720 i=1,nkk
            do 710 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=real(nn2,fPrec)*half                                   !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 690
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 700
  690         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  700         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  710       continue
  720     continue
          np2=np2-2
          if(np2.ge.1) goto 680
  730   continue
  740 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 780 np=nta,nte
        vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)                            !hr06
        np2=np
        nkk=0
  750   nkk=nkk+1
        n2e=2*np2
        do 770 i=1,nkk
          do 760 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
            vdt2=vdt1*e(nv1,nv2)/                                       &
     &real(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4),fPrec) !hr06
            vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                               !hr06
            if(n2.ge.0) then
              vdt3=real(n2*nv21,fPrec)*ea+real(nn1*nv11,fPrec)*eb          !hr06
            end if
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  760     continue
  770   continue
        np2=np2-2
        if(np2.ge.1) goto 750
  780 continue
      return
      end

+dk decoup
      subroutine decoup
!-----------------------------------------------------------------------
!  DECOUPLING USING MATRIX ELEMENTS
!
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,ierr,j,no
      real(kind=fPrec) aa,bb,d1,dpp,dsm,qw,qwc,sen,sn,ss
+ca parpro
+ca common
+ca commons
+ca commont1
      dimension aa(6,6),bb(6),dsm(6),sn(6),sen(6),ss(6)
      dimension qwc(3),qw(2),d1(6)
+if bnlelens
+ca rhicelens
+ei
      save
!-----------------------------------------------------------------------
      do i=1,6
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero

        do j=1,6
          aa(i,j)=zero
        end do
      end do

      do 20 i=1,3
        qwc(i)=zero
   20 continue
      dpp=zero
      write(lout,10000)
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      sen(1)=ta(3,1)
      sen(2)=ta(3,2)
      sen(3)=ta(4,1)
      sen(4)=ta(4,2)
      if(iskew.eq.1) then
        sen(5)=qwc(1)
        sen(6)=qwc(2)
      endif
      do 30 i=1,6
        if(iskew.eq.2.and.i.gt.4) goto 30
        if(i.le.4) then
          sn(i)=ed(nskew(i))
          dsm(i)=dsm0
          bb(i)=sen(i)
        else
          if (abs(el(nskew(i))).le.pieni) then
            sn(i)=ed(nskew(i))
          else
            sn(i)=ek(nskew(i))
          endif
          dsm(i)=dkq
          bb(i)=sen(i)-qwsk(i-4)
        endif
        ss(i)=sen(i)
   30 continue
      do 100 no=1,itcro
        do 40 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 40
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))+dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))+dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))+dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
          call betalf(dpp,qw)
          call phasad(dpp,qwc)
          aa(i,1)=(ta(3,1)-ss(1))/dsm(i)
          aa(i,2)=(ta(3,2)-ss(2))/dsm(i)
          aa(i,3)=(ta(4,1)-ss(3))/dsm(i)
          aa(i,4)=(ta(4,2)-ss(4))/dsm(i)
          if(iskew.eq.1) then
            aa(i,5)=(qwc(1)-ss(5))/dsm(i)
            aa(i,6)=(qwc(2)-ss(6))/dsm(i)
          endif
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))-dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   40   continue
        if(iskew.eq.1) then
          call loesd(aa,bb,6,6,ierr)
        else if(iskew.eq.2) then
          call loesd(aa,bb,4,4,ierr)
        endif
        if(ierr.eq.1) call prror(64)
        do 50 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 50
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-bb(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-bb(i)
            else
              ek(nskew(i))=ek(nskew(i))-bb(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   50   continue
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        ss(1)=ta(3,1)
        ss(2)=ta(3,2)
        ss(3)=ta(4,1)
        ss(4)=ta(4,2)
        if(iskew.eq.1) then
          ss(5)=qwc(1)
          ss(6)=qwc(2)
        endif
        write(lout,10010)
        write(lout,10020) no,sen(1),ss(1),sen(2),ss(2),sen(3),ss(3), sen&
     &(4),ss(4)
        write(lout,10030) bez(nskew(1)),sn(1),ed(nskew(1)),             &
     &bez(nskew(2)),sn                                                  &
     &(2),ed(nskew(2)),bez(nskew(3)),sn(3),ed(nskew(3)), bez            &
     &(nskew(4)),sn(4),ed(nskew(4))
        if(iskew.eq.1) then
          write(lout,10010)
          write(lout,10040) qwsk(1),qwc(1),qwsk(2),qwc(2)
          if (abs(el(nskew(5))).le.pieni) then
            write(lout,10060) sn(5),ed(nskew(5)),nskew(5),sn(6),ed      &
     &(nskew(6)), nskew(6)
          else
            write(lout,10060) sn(5),ek(nskew(5)),nskew(5),sn(6),ek      &
     &(nskew(6)), nskew(6)
          endif
        else if(iskew.eq.2) then
          write(lout,10010)
          write(lout,10050) qwc(1),qwc(2)
        endif
        do 60 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 60
          if(i.le.4) then
            d1(i)=abs(ss(i))
          else
            d1(i)=abs(ss(i)-qwsk(i-4))
          endif
   60   continue
        do 70 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 70
          if(d1(i).gt.dsi) goto 80
   70   continue
        return
   80   do 90 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 90
          if(i.le.4) then
            bb(i)=ss(i)
          else
            bb(i)=ss(i)-qwsk(i-4)
          endif
   90   continue
  100 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY DECOUP ----')
10010 format(131('-'))
10020 format(/10x,'DECOUPLING ROUTINE  ITERATION #',i2// 30x,           &
     &'BEFORE         AFTER     DECOUPLING'// 17x,'   M(3,1)      ',2g15&
     &.5/ 17x,'   M(3,2)      ',2g15.5/ 17x,'   M(4,1)      ',2g15.5/ 17&
     &x,'   M(4,2)      ',2g15.5// 5x,'SKEW QUDRUPOLE STRENGTHS')
10040 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10050 format(10x,'CURRENT TUNE' / 10x,'Q-VALUE'/ 10x,'HORIZONTAL     ', &
     &g15.7/ 10x,'VERTICAL       ',g15.7/)
10060 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10030 format(14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,          &
     &g17.10/14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,g17.10)
      end

+dk utils ! Various utility functions

      subroutine invert_tas(fma_tas_inv,fma_tas)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: invert the matrix of eigenvecors tas                        *
!           (code copied from postpr only that ta is here fma_tas)      *
!           x(normalized)=fma_tas^-1 x=fma_tas_inv x                    *
!           note: inversion method copied from subroutine postpr        *
!-----------------------------------------------------------------------*
      use floatPrecision
      use numerical_constants
      use crcoall
      implicit none
+ca commonta

      integer :: i,j            !iterators
      real(kind=fPrec), dimension(6,6), intent(inout) :: fma_tas !tas = normalisation matrix
      real(kind=fPrec), dimension(6,6), intent(out) :: fma_tas_inv !inverse of tas
      integer ierro                   !error messages
!     dummy variables
      real(kind=fPrec), dimension(6,6) :: tdummy !dummy variable for transposing the matrix
      integer, dimension(6) :: idummy !for matrix inversion
!     units: [mm,mrad,mm,mrad,mm,1]
!     invert matrix
!     - set values close to 1 equal to 1
      do i=1,6
         do j=1,6
            fma_tas_inv(i,j)=fma_tas(j,i)
         enddo
      enddo
      
      if(abs(fma_tas_inv(1,1)).le.pieni.and.abs(fma_tas_inv(2,2)).le.   &
     &pieni) then
        fma_tas_inv(1,1)=one
        fma_tas_inv(2,2)=one
      endif
      if(abs(fma_tas_inv(3,3)).le.pieni.and.abs(fma_tas_inv(4,4)).le.   &
     &pieni) then
        fma_tas_inv(3,3)=one
        fma_tas_inv(4,4)=one
      endif
      if(abs(fma_tas_inv(5,5)).le.pieni.and.abs(fma_tas_inv(6,6)).le.   &
     &pieni) then
        fma_tas_inv(5,5)=one
        fma_tas_inv(6,6)=one
      endif
      
!     - invert: dinv returns the transposed matrix
      call dinv(6,fma_tas_inv,6,idummy,ierro)
      if (ierro.ne.0) then
         write(lout,*) "Error in INVERT_TAS - Matrix inversion failed!"
         write(lout,*) "Subroutine DINV returned ierro=",ierro
         call prror(-1)
      endif
      
!     - transpose fma_tas_inv
      tdummy=fma_tas_inv
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j)=tdummy(j,i)
        enddo
      enddo
      end subroutine invert_tas

+dk sumpos
      subroutine sumpos
!-----------------------------------------------------------------------
!  SUBROUTINE TO SUMMARIZE THE RESULTS OF THE POSTPROCESSING
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      integer i,ierro,j
      real(kind=fPrec) d,dlost
      character(len=4) ch
+ca parpro
      dimension d(60)
+if crlibm
!     integer nchars
!     parameter (nchars=160)
      character(len=1601) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=60)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      real(kind=fPrec) fround
      data lineno /0/
+ei
      save
!-----------------------------------------------------------------------
      rewind 10
      do 10 i=1,1000
        ch=' '
+if .not.crlibm
        read(10,*,end=20,iostat=ierro) (d(j),j=1,60)
+ei
+if crlibm
        read(10,'(A1600)',end=20,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
!       write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
!       write (*,*) ':'//fields(1)//':'
!       write (*,*) ':'//fields(2)//':'
!       write (*,*) ':'//fields(3)//':'
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
+ei
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
        if(i.eq.1) write(lout,10000)
        if(abs(d(2)).gt.pieni) ch='LOST'
        if(d(22).ge.d(23)) then
          dlost=d(23)
        else
          dlost=d(22)
        endif
        write(lout,10010) nint(dlost),d(3),d(5),d(7),d(9),d(10),d(11),  &
     &d(12),nint(d(16)),nint(d(18)),d(19),d(21),ch,d(4),d(6),d(8),      &
     &d(13),nint(d(17)),d(20),d(25),d(14),d(15)
   10 continue
   20 rewind 10
+if crlibm
      lineno=0
+ei
      write(lout,10020)
      do 30 i=1,1000
+if .not.crlibm
        read(10,*,end=40,iostat=ierro) (d(j),j=1,60)
+ei
+if crlibm
        read(10,'(A1600)',end=40,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
+ei
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
! Now we are using 60 for CPU in seconds
! But note that dnms is now found in word 59.
! and we always print the maximum DMMAC as NMAC
! or zero which should really be OK I think.
! N.B. If particle is lost nms is 0, so we set mmac to zero too 
      d(60)=real(nmac,fPrec)
      if (nint(d(59)).eq.0) d(60)=zero
      write(lout,10030) i,nint(d(59)),nint(d(60)),                      &
     &nint(d(59))*nint(d(24))
   30 continue
   40 continue
      write(lout,10040)
!-----------------------------------------------------------------------
      return
10000 format(/131('-')/t10,'SUMMARY OF THE POSTPROCESSING' //t1,128(    &
     &'-'), /t1,'|',8x,'|',11x,'|',11x,'|',12x,'|',11x,                 &
     &'|NORMALIZED | SLOPE  |',14x,'|',10x,'|',21x,'|', /t1,            &
     &'|  TURN  |   LINEAR  |   BETA-   | AMPLITUDES | MOMENTUM  |',    &
     &'PHASESPACE | OF THE |  NONLINEAR   |  NEAREST |',7x,'SMEAR OF',6x&
     &,'|', /t1,                                                        &
     &'| NUMBER |   TUNES   | FUNCTIONS |            | DEVIATION |',    &
     &' DISTANCE  |DISTANCE|  DETUNING    | RESONANCE|   THE EMITTANCES'&
     &  ,4x,'|',/t1,128('-'), /t1,                                      &
     &'|        |           |     [M]   |     [MM]   |           |',    &
     &'           |        |              |     |ORD.|',                &
     &'    [%]  |      [%]  |'/t1,128('-'))
10010 format(t1,'|',i8,'|X ',f9.5,'|X ',f9.4,'|X ',f10.6,'|',d11.4, '|',&
     &d11.4,'|',f8.4,'|X ',d12.5,'|X ',i3,'| ',i2,' |X ', f7.3,'|X+Y ', &
     &f7.3,'|' /t1,'|  ',a4,'  |Y ',f9.5,'|Y ',f9.4,'|Y ',f10.6,'|',11x,&
     &'|',11x,'|',8x,'|+/- ',d10.3,'|Y ',i3,'|    |Y ', f7.3,'|    ',7x,&
     &'|' /t1,'|',8x,'|QS ',f8.6,'|  ',9x,'|  ',10x,'|',11x, '|',11x,'|'&
     &,8x,'|Y ',d12.5,'|  ',3x,'|    |  ', 7x,'|    ',7x,'|' /t1,'|',8x,&
     &'|  ',9x,'|  ',9x,'|  ',10x,'|',11x, '|',11x,'|',8x,'|+/- ',d10.3,&
     &'|  ',3x,'|    |  ', 7x,'|    ',7x,'|'/t1,128('-'))
10020 format(/131('-')/t10,'RANDOM SETS USED' //                        &
     &'  CASE  |  # OF RANDOM SET  |  MAX. POSSIBLE SETS   |    ',      &
     &' SEED'/65('-'))
10030 format(3x,i2,13x,i2,19x,i2,13x,i8)
10040 format(65('-')//131('-'))
      end
      
+dk beam6d
      subroutine beamint(np,track,param,sigzs,bcu,ibb,ne,ibtyp,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants

      use crcoall
      implicit none

      integer ibb,ibbc,ibtyp,ne,np,nsli
      real(kind=fPrec) alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,tphi,track,star,phi2,cphi2,sphi2,tphi2
+ca parpro
      dimension track(6,npart)
      dimension param(nele,18),bcu(nbb,12)
      dimension star(3,mbea)
+ca parbeam_exp
      save
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         alpha=param(ne,3)
         phi=param(ne,1)
         nsli=param(ne,2)
         !sepax=param(ne,4)     !Not actually used anywhere?
         !sepay=param(ne,5)     !Not actually used anywhere?
         f=param(ne,4)/real(nsli,fPrec)
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beamint"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif

      sphi=sin_mb(phi)
      sphi2=sin_mb(phi2)
      cphi=cos_mb(phi)
      cphi2=cos_mb(phi2)
      tphi=tan_mb(phi)
      tphi2=tan_mb(phi2)
      salpha=sin_mb(alpha)
      calpha=cos_mb(alpha)
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boost(np,sphi,cphi,tphi,salpha,calpha,track)
      call sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
      call boosti(np,sphi,cphi,tphi,salpha,calpha,track)
      return
      end

      subroutine boost(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOST Boost Operation ********************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer i,np
      real(kind=fPrec) calpha,cphi,h,h1x,h1y,h1z,hd1,salpha,sphi,tphi,  &
     &track,x1,y1
+ca parpro
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h=(track(6,i)+one)-sqrt(((one+track(6,i))**2-                   &!hr06
     &track(2,i)**2)-track(4,i)**2)                                      !hr06
        track(6,i)=((track(6,i)-(calpha*tphi)*track(2,i))               &!hr06
     &-(track(4,i)*salpha)*tphi)+h*tphi**2                               !hr06
        track(2,i)=(track(2,i)-(tphi*h)*calpha)/cphi                     !hr06
        track(4,i)=(track(4,i)-(tphi*h)*salpha)/cphi                     !hr06
        hd1=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/hd1
        h1y=track(4,i)/hd1
        h1z=one-(one+track(6,i))/hd1
        x1=((calpha*tphi)*track(5,i)+(one+(calpha*sphi)*h1x)*track(1,i))&!hr06
     &+((track(3,i)*salpha)*sphi)*h1x                                    !hr06
        y1=((salpha*tphi)*track(5,i)+(one+(salpha*sphi)*h1y)*track(3,i))&!hr06
     &+((track(1,i)*calpha)*sphi)*h1y                                    !hr06
        track(5,i)=track(5,i)/cphi+h1z*((sphi*calpha)*track(1,i)        &!hr06
     &+(sphi*salpha)*track(3,i))                                         !hr06
        track(1,i)=x1
        track(3,i)=y1
 1000 continue
      return
      end

      subroutine sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!**SBC ***Synchro-Beam for headon collision**********************
!  call BBF  (table) disabled
!****************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer i,ibb,ibbc,ibbc1,ibtyp,jsli,np,nsli
      real(kind=fPrec) bbf0,bbfx,bbfy,bbgx,bbgy,bcu,costh,costhp,cphi,  &
     &dum,f,s,sepx,sepx0,sepy,sepy0,sfac,sinth,sinthp,sp,star,sx,       &
     &sy,track,cphi2
+ca parpro
      dimension track(6,npart),bcu(nbb,12)
      dimension star(3,mbea),dum(13)
      save
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
        do 1000 i=1,np
          s=(track(5,i)-star(3,jsli))*half
          !write(*,*)'JBG - cphi2',cphi2
          sp=s/cphi2 
          dum(1)=(bcu(ibb,1)+(two*bcu(ibb,4))*sp)+bcu(ibb,6)*sp**2       !hr06
          dum(2)=(bcu(ibb,2)+(two*bcu(ibb,9))*sp)+bcu(ibb,10)*sp**2      !hr06
          dum(3)=(bcu(ibb,3)+(bcu(ibb,5)+bcu(ibb,7))*sp)+               &!hr06
     &bcu(ibb,8)*sp**2                                                   !hr06
          dum(4)=dum(1)-dum(2)
          dum(5)=dum(4)**2+four*dum(3)**2                                !hr06
          if(ibbc.eq.1.and.(abs(dum(4)).gt.pieni.and.                   &
     &abs(dum(5)).gt.pieni)) then
            ibbc1=1
            dum(5)=sqrt(dum(5))
         else
            ibbc1=0
          endif
        !JBG New set of canonical set of variables at the Col point (CP)
          sepx0=(track(1,i)+track(2,i)*s)-star(1,jsli)                   !hr06
          sepy0=(track(3,i)+track(4,i)*s)-star(2,jsli)                   !hr06
          if(ibbc1.eq.1) then
            sfac=one
            if(dum(4).lt.zero) sfac=-one*one                             !hr06
            dum(6)=(sfac*dum(4))/dum(5)                                  !hr06
            dum(7)=dum(1)+dum(2)
            costh=half*(one+dum(6))
            if(abs(costh).gt.pieni) then
              costh=sqrt(costh)
            else
              costh=zero
            endif
            sinth=half*(one-dum(6))
            if(abs(sinth).gt.pieni) then
              sinth=(sfac)*sqrt(sinth)                              !hr06
            else
              sinth=zero
            endif
            if(dum(3).lt.zero) sinth=-one*sinth                          !hr06
            sy=sfac*dum(5)
            sx=(dum(7)+sy)*half
            sy=(dum(7)-sy)*half
            sepx=sepx0*costh+sepy0*sinth
            sepy=sepy0*costh-sepx0*sinth                                 !hr06
          else
            sx=dum(1)
            sy=dum(2)
            sepx=sepx0
            sepy=sepy0
          endif
          if(sx.gt.sy) then
            call bbf(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy,ibtyp)
          else
            call bbf(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx,ibtyp)
          endif
          bbfx=f*bbfx
          bbfy=f*bbfy
          bbgx=f*bbgx
          bbgy=f*bbgy
          if(ibbc1.eq.1) then
            dum(8)=two*((bcu(ibb,4)-bcu(ibb,9))+                        &!hr06
     &(bcu(ibb,6)-bcu(ibb,10))*sp)                                       !hr06
            dum(9)=(bcu(ibb,5)+bcu(ibb,7))+(two*bcu(ibb,8))*sp           !hr06
            dum(10)=(((dum(4)*dum(8)+(four*dum(3))*dum(9))/             &!hr06
     &dum(5))/dum(5))/dum(5)                                             !hr06
            dum(11)=sfac*(dum(8)/dum(5)-dum(4)*dum(10))
            dum(12)=(bcu(ibb,4)+bcu(ibb,9))+(bcu(ibb,6)+bcu(ibb,10))*sp  !hr06
      dum(13)=(sfac*((dum(4)*dum(8))*half+(two*dum(3))*dum(9)))/dum(5)   !hr06
            if(abs(costh).gt.pieni) then
              costhp=(dum(11)/four)/costh                                !hr06
            else
              costhp=zero
            endif
            if(abs(sinth).gt.pieni) then
              sinthp=((-one*dum(11))/four)/sinth                         !hr06
            else
              sinthp=zero
            endif
            track(6,i)=track(6,i)-                                      &!hr06
     &((((bbfx*(costhp*sepx0+sinthp*sepy0)+                             &!hr06
     &bbfy*(costhp*sepy0-sinthp*sepx0))+                                &!hr06
     &bbgx*(dum(12)+dum(13)))+bbgy*(dum(12)-dum(13)))/                  &!hr06
     &cphi)*half                                                         !hr06
            bbf0=bbfx
            bbfx=bbf0*costh-bbfy*sinth
            bbfy=bbf0*sinth+bbfy*costh
          else
            track(6,i)=track(6,i)-                                      &
     &(bbgx*(bcu(ibb,4)+bcu(ibb,6)*sp)+                                 &
     &bbgy*(bcu(ibb,9)+bcu(ibb,10)*sp))/cphi
          endif
          track(6,i)=track(6,i)-(bbfx*(track(2,i)-bbfx*half)+           &
     &bbfy*(track(4,i)-bbfy*half))*half
          track(1,i)=track(1,i)+s*bbfx
          track(2,i)=track(2,i)-bbfx
          track(3,i)=track(3,i)+s*bbfy
          track(4,i)=track(4,i)-bbfy
 1000   continue
 2000 continue
      return
      end

      subroutine boosti(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOSTI **************inverse boost *****************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer i,np
      real(kind=fPrec) calpha,cphi,det,h1,h1d,h1x,h1y,h1z,salpha,sphi,  &
     &tphi,track,x1,y1,z1
+ca parpro
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h1d=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/h1d
        h1y=track(4,i)/h1d
        h1z=one-(one+track(6,i))/h1d
        h1=((track(6,i)+one)-sqrt(((one+track(6,i))**2-                 &!hr06
     &track(2,i)**2)-track(4,i)**2))*cphi**2                             !hr06
        det=one/cphi+tphi*((h1x*calpha+h1y*salpha)-h1z*sphi)             !hr06
        x1= (track(1,i)*(one/cphi+(salpha*(h1y-(h1z*salpha)*sphi))*tphi)&!hr06
     &+((track(3,i)*salpha)*tphi)*((h1z*calpha)*sphi-h1x))              &!hr06
     &-(track(5,i)*((calpha+((h1y*calpha)*salpha)*sphi)                 &!hr06
     &-(h1x*salpha**2)*sphi))*tphi                                       !hr06
        y1= (((track(1,i)*calpha)*tphi)*((h1z*salpha)*sphi-h1y)         &!hr06
     &+track(3,i)*(one/cphi+(calpha*(h1x-(h1z*calpha)*sphi))*tphi))     &!hr06
     &-(track(5,i)*(salpha-(h1y*calpha**2)*sphi                         &!hr06
     &+((h1x*calpha)*salpha)*sphi))*tphi                                 !hr06
        z1= (track(5,i)*((one+(h1x*calpha)*sphi)+(h1y*salpha)*sphi)     &!hr06
     &-((track(1,i)*h1z)*calpha)*sphi)-((track(3,i)*h1z)*salpha)*sphi    !hr06
        track(1,i)=x1/det
        track(3,i)=y1/det
        track(5,i)=z1/det
        track(6,i)=(track(6,i)+(calpha*sphi)*track(2,i))                &!hr06
     &+(salpha*sphi)*track(4,i)                                          !hr06
        track(2,i)=(track(2,i)*cphi+(calpha*tphi)*h1)                    !hr06
        track(4,i)=(track(4,i)*cphi+(salpha*tphi)*h1)                    !hr06
 1000 continue
      return
      end

      subroutine bbf(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy,ibtyp)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**BBF   without using table ******************************************
! gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer ibtyp
      real(kind=fPrec) arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,     &
     &comfac,comfac2,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,sigyy, &
     &sqrpi2,wx1,wx2,wy1,wy2,x,xxyy
+ca parpro
      data sqrpi2/3.544907701811032_fPrec/
      save
!-----------------------------------------------------------------------
      if(sigxx.eq.sigyy) then
        x=sepx**2+sepy**2
        xxyy=sigxx+sigyy
        const=zero
        if(abs(xxyy).gt.pieni) const=x/xxyy
        expfac=exp_mb(-one*const)                                        !hr06
        bbfx=zero
        bbfy=zero
        bbgx=zero
        bbgy=zero
        if(abs(x).gt.pieni) then
          bbfx=((two*sepx)*(one-expfac))/x                             !hr06
          bbfy=((two*sepy)*(one-expfac))/x                             !hr06
          comfac=sepy*bbfy-sepx*bbfx                                     !hr06
          comfac2=(abs(sigxx)+abs(sigyy))**2
          bbgx=(comfac+(((four*sepx**2)*const)/x)*expfac)/(two*x)         !hr06
          bbgy=((((four*sepy**2)*const)/x)*expfac-comfac)/(two*x)         !hr06
        endif
      else
        x=sepx**2/sigxx+sepy**2/sigyy
        fac2=two*abs(sigxx-sigyy)
        fac=sqrt(fac2)
        const=sqrpi2/fac
        sigxy=sqrt(sigxx/sigyy)
        arg1x=abs(sepx/fac)
        arg1y=abs(sepy/fac)
        if(ibtyp.eq.0) call errf(arg1x,arg1y,wy1,wx1)
        if(ibtyp.eq.1) call wzsub(arg1x,arg1y,wy1,wx1)
        if(x.lt.c1e2) then
          expfac=exp_mb(-half*x)                                        !hr06
          arg2x=arg1x/sigxy
          arg2y=arg1y*sigxy
          if(ibtyp.eq.0) call errf(arg2x,arg2y,wy2,wx2)
          if(ibtyp.eq.1) call wzsub(arg2x,arg2y,wy2,wx2)
          bbfx=const*(wx1-expfac*wx2)
          bbfy=const*(wy1-expfac*wy2)
          if(sepx.lt.0) bbfx=-one*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-one*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-one*(comfac+two*(expfac/sigxy -one)))/fac2              !hr06
          bbgy= (comfac+two*(expfac*sigxy -one))/fac2                    !hr06
        else
          bbfx=const*wx1
          bbfy=const*wy1
          if(sepx.lt.0) bbfx=-one*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-one*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-one*(comfac-two))/fac2                                  !hr06
          bbgy= -one*bbgx                                                !hr06
        endif
      endif
      return
      end

      subroutine stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!*******STSLD*********************************************************
!   makes longitudinal position of the strong slice for all slices
!*********************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer i,nsli

      real(kind=fPrec) bord,bord1,border,calpha,cphi,cphi2,gauinv,pi,   &
     &salpha,sigz,sigzs,sphi,sphi2,star,yy
+ca parpro
      dimension star(3,mbea)
!-----------------------------------------------------------------------
      data border /eight/
      save
!-----------------------------------------------------------------------
      pi=four*atan_mb(one)
      sigz=sigzs/cphi2
! DEFINE `STARRED' COORDINATES
!  BORD is longitudinal border star(3,mbea) is the barycenter of region
!  divided two borders.
      bord=+border
      do 101 i=nsli,1,-1
        yy=(one/real(nsli,fPrec))*real(i-1,fPrec)                        !hr06
        if(i.ne.1) bord1=gauinv(yy)                                      !hr06
        if(i.eq.1) bord1=-one*border                                     !hr06
        star(3,i)=(((exp_mb((-one*bord**2)*half)-                       &!hr06
     &exp_mb((-one*bord1**2)*half))/sqrt(two*pi))*real(nsli,fPrec))*sigz !hr06
        bord=bord1
        !JBG When doing slicing phi=0 for crab crossing
        ! star(1,i)=0.
        ! star(2,i)=0. 
        !JBG When doing slicing phi2 different tiltings of the strong beam
        star(1,i)=(star(3,i)*sphi2)*calpha
        star(2,i)=(star(3,i)*sphi2)*salpha  
        !star(1,i)=(star(3,i)*sphi)*calpha                                !hr06
        !star(2,i)=(star(3,i)*sphi)*salpha                                !hr06
 101  continue
      return
      end

      function gauinv(p0)
!GAUINV***********************************************
!  INVERSE OF (INTEGRATED) NORMAL DISTRIBUTION FUNCTION
!              1         X= Y
!     P(Y)=-----------* INTEGRAL EXP(-X**2/2) DX
!          SQRT(2*PI)    X= -INF
!     IF P(Y)=P0, THEN GAUINV(P0)=Y.
!        0 < P0 < 1 ,   -INF < Y < +INF
!  IF THIS ROUTINE IS USED TO CONVERT UNIFORM RANDOM NUMBERS TO
!  GAUSSIAN, MAXIMUM RELATIVE ERROR IN THE DISTRIBUTION FUNCTION
!  DP/DX=EXP(-X**2/2)/SQRT(2*PI) IS LESS THAN 0.640E-3 EVERYWHERE
!  IN THE RANGE  2**(-31) < P0 < 1-2**31.  (MINIMAX APPROXIMATION)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      real(kind=fPrec) a0,a1,a2,a3,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d0,d1, &
     &d2,d3,d4,e0,e1,e2,e3,e4,f0,f1,f2,gauinv,p,p0,p1,p2,pp1,q,qq2,qq3, &
     &qq4,qq5,t
!-----------------------------------------------------------------------
      data pp1/0.334624883253_fPrec/, qq2/0.090230446775_fPrec/,        &
     &qq3/0.049905685242_fPrec/, qq4/0.027852994157_fPrec/,             &
     &qq5/0.015645650215_fPrec/
      data a3/ 4.5585614e+01_fPrec/, a2/ 2.1635544_fPrec/,              &
     &a1/ 2.7724523_fPrec/, a0/ 2.5050240_fPrec/,                       &
     &b4/ 4.0314354e+02_fPrec/, b3/-2.7713713e+02_fPrec/,               &
     &b2/ 7.9731883e+01_fPrec/,                                         &
     &b1/-1.4946512e+01_fPrec/, b0/ 2.2157257_fPrec/,                   &
     &c4/ 4.1394487e+03_fPrec/, c3/-1.5585873e+03_fPrec/,               &
     &c2/ 2.4648581e+02_fPrec/,                                         &
     &c1/-2.4719139e+01_fPrec/, c0/ 2.4335936_fPrec/,                   &
     &d4/ 4.0895693e+04_fPrec/, d3/-8.5400893e+03_fPrec/,               &
     &d2/ 7.4942805e+02_fPrec/,                                         &
     &d1/-4.1028898e+01_fPrec/, d0/ 2.6346872_fPrec/,                   &
     &e4/ 3.9399134e+05_fPrec/, e3/-4.6004775e+04_fPrec/,               &
     &e2/ 2.2566998e+03_fPrec/,                                         &
     &e1/-6.8317697e+01_fPrec/, e0/ 2.8224654_fPrec/
      data f0/-8.1807613e-02_fPrec/, f1/-2.8358733_fPrec/,              &
     &f2/ 1.4902469_fPrec/
      save
!-----------------------------------------------------------------------
      p=p0-half
      p1=abs(p)
      if(p1.ge.pp1) goto 120
      p2=p**2
      gauinv=(((a3*p2+a2)*p2+a1)*p2+a0)*p
      return
 120  q=half-p1
      if(q.le.qq2) goto 140
      gauinv=(((b4*q+b3)*q+b2)*q+b1)*q+b0
      goto 200
 140  if(q.le.qq3) goto 150
      gauinv=(((c4*q+c3)*q+c2)*q+c1)*q+c0
      goto 200
 150  if(q.le.qq4) goto 160
      gauinv=(((d4*q+d3)*q+d2)*q+d1)*q+d0
      goto 200
 160  if(q.le.qq5) goto 170
      gauinv=(((e4*q+e3)*q+e2)*q+e1)*q+e0
      goto 200
 170  if(q.le.zero) goto 900
      t=sqrt(-two*log_mb(q))
      gauinv=(t+f0)+f1/(f2+t)                                            !hr06
 200  if(p.lt.zero) gauinv=-one*gauinv                                    !hr06
      return
 900  write(lout,910) p0
 910  format(' (FUNC.GAUINV) INVALID INPUT ARGUMENT ',1pd20.13)
      call prror(-1)
      end
+dk myrinv
      subroutine kerset(ercode,lgfile,limitm,limitr)
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,kounte,l,lgfile,limitm,limitr,log,logf
      parameter(kounte = 27)
      character(len=6)    ercode,   code(kounte)
      logical             mflag,    rflag
      integer             kntm(kounte),       kntr(kounte)
!-----------------------------------------------------------------------
      data      logf      /  0  /
      data      code(1), kntm(1), kntr(1)  / 'C204.1', 255, 255 /
      data      code(2), kntm(2), kntr(2)  / 'C204.2', 255, 255 /
      data      code(3), kntm(3), kntr(3)  / 'C204.3', 255, 255 /
      data      code(4), kntm(4), kntr(4)  / 'C205.1', 255, 255 /
      data      code(5), kntm(5), kntr(5)  / 'C205.2', 255, 255 /
      data      code(6), kntm(6), kntr(6)  / 'C305.1', 255, 255 /
      data      code(7), kntm(7), kntr(7)  / 'C308.1', 255, 255 /
      data      code(8), kntm(8), kntr(8)  / 'C312.1', 255, 255 /
      data      code(9), kntm(9), kntr(9)  / 'C313.1', 255, 255 /
      data      code(10),kntm(10),kntr(10) / 'C336.1', 255, 255 /
      data      code(11),kntm(11),kntr(11) / 'C337.1', 255, 255 /
      data      code(12),kntm(12),kntr(12) / 'C341.1', 255, 255 /
      data      code(13),kntm(13),kntr(13) / 'D103.1', 255, 255 /
      data      code(14),kntm(14),kntr(14) / 'D106.1', 255, 255 /
      data      code(15),kntm(15),kntr(15) / 'D209.1', 255, 255 /
      data      code(16),kntm(16),kntr(16) / 'D509.1', 255, 255 /
      data      code(17),kntm(17),kntr(17) / 'E100.1', 255, 255 /
      data      code(18),kntm(18),kntr(18) / 'E104.1', 255, 255 /
      data      code(19),kntm(19),kntr(19) / 'E105.1', 255, 255 /
      data      code(20),kntm(20),kntr(20) / 'E208.1', 255, 255 /
      data      code(21),kntm(21),kntr(21) / 'E208.2', 255, 255 /
      data      code(22),kntm(22),kntr(22) / 'F010.1', 255,   0 /
      data      code(23),kntm(23),kntr(23) / 'F011.1', 255,   0 /
      data      code(24),kntm(24),kntr(24) / 'F012.1', 255,   0 /
      data      code(25),kntm(25),kntr(25) / 'F406.1', 255,   0 /
      data      code(26),kntm(26),kntr(26) / 'G100.1', 255, 255 /
      data      code(27),kntm(27),kntr(27) / 'G100.2', 255, 255 /
      save
!-----------------------------------------------------------------------
      logf  =  lgfile
         l  =  0
      if(ercode .ne. ' ')  then
         do 10  l = 1, 6
            if(ercode(1:l) .eq. ercode)  goto 12
  10        continue
  12     continue
      endif
      do 14     i  =  1, kounte
         if(l .eq. 0)  goto 13
         if(code(i)(1:l) .ne. ercode(1:l))  goto 14
  13     if(limitm.ge.0) kntm(i)  =  limitm
         if(limitr.ge.0) kntr(i)  =  limitr
  14     continue
      return
      entry kermtr(ercode,log,mflag,rflag)
      log  =  logf
      do 20     i  =  1, kounte
         if(ercode .eq. code(i))  goto 21
  20     continue
      write(lout,1000)  ercode
      write(lout,*) 'KERNLIB Library Error'
      call prror(-1)
      return
      
  21  rflag  =  kntr(i) .ge. 1
      if(rflag  .and.  (kntr(i) .lt. 255))  kntr(i)  =  kntr(i) - 1
      mflag  =  kntm(i) .ge. 1
      if(mflag  .and.  (kntm(i) .lt. 255))  kntm(i)  =  kntm(i) - 1
      if(.not. rflag)  then
         if(logf .lt. 1)  then
            write(lout,1001)  code(i)
         else
            write(logf,1001)  code(i)
         endif
      endif
      if(mflag .and. rflag)  then
         if(logf .lt. 1)  then
            write(lout,1002)  code(i)
         else
            write(logf,1002)  code(i)
         endif
      endif
      return
1000  format(' KERNLIB LIBRARY ERROR. ' /                               &
     &' ERROR CODE ',a6,' NOT RECOGNIZED BY KERMTR',                    &
     &' ERROR MONITOR. RUN ABORTED.')
1001  format(/' ***** RUN TERMINATED BY CERN LIBRARY ERROR ',           &
     &'CONDITION ',a6)
1002  format(/' ***** CERN LIBRARY ERROR CONDITION ',a6)
      end

      subroutine rinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR REQINV.)
!
!     CALLS ... RFACT, RFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer idim,ifail,ir,jfail,k,kprnt,n
      real(kind=fPrec) t1,t2,t3,a,det,temp,s,                           &
     &c11,c12,c13,c21,c22,c23,c31,c32,c33

      character(len=6) name
      dimension ir(n),a(idim,n)
      data name/'RINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      t1=abs(a(1,1))
      t2=abs(a(2,1))
      t3=abs(a(3,1))
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.zero) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.zero) goto 8
      s=one/det                                                          !hr07
      c11   =s*a(2,2)
      a(1,2)=(-one*s)*a(1,2)                                             !hr07
      a(2,1)=(-one*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.zero) goto 8
      a(1,1)=one/a(1,1)                                                  !hr07
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call rfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call rfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end

      subroutine dinv(n,a,idim,ir,ifail)
!-----------------------------------------------------------------------
!
!     ******************************************************************
!
!     REPLACES A BY ITS INVERSE.
!
!     (PARAMETERS AS FOR DEQINV.)
!
!     CALLS ... DFACT, DFINV, F010PR, ABEND.
!
!     ******************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer idim,ifail,jfail,k,kprnt,n
      integer ir
      real t1,t2,t3
      real(kind=fPrec) a,det,temp,s,c11,c12,c13,c21,c22,c23,c31,c32,c33
      character(len=6) name
      dimension ir(n),a(idim,n)
      data name/'DINV'/,kprnt/0/
      save
!-----------------------------------------------------------------------
!
!  TEST FOR PARAMETER ERRORS.
!
      if((n.lt.1).or.(n.gt.idim)) goto 7
!
!  TEST FOR N.LE.3.
!
      if(n.gt.3) goto 6
      ifail=0
      if(n.lt.3) goto 4
!
!  N=3 CASE.
!
!     COMPUTE COFACTORS.
      c11=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      c12=a(2,3)*a(3,1)-a(2,1)*a(3,3)
      c13=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      c21=a(3,2)*a(1,3)-a(3,3)*a(1,2)
      c22=a(3,3)*a(1,1)-a(3,1)*a(1,3)
      c23=a(3,1)*a(1,2)-a(3,2)*a(1,1)
      c31=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      c32=a(1,3)*a(2,1)-a(1,1)*a(2,3)
      c33=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      t1=abs(a(1,1))                                               !hr07
      t2=abs(a(2,1))                                               !hr07
      t3=abs(a(3,1))                                               !hr07
!
!     (SET TEMP=PIVOT AND DET=PIVOT*DET.)
      if(t1.ge.t2) goto 1
         if(t3.ge.t2) goto 2
!        (PIVOT IS A21)
            temp=a(2,1)
            det=c13*c32-c12*c33
            goto 3
    1 if(t3.ge.t1) goto 2
!     (PIVOT IS A11)
         temp=a(1,1)
         det=c22*c33-c23*c32
         goto 3
!     (PIVOT IS A31)
    2    temp=a(3,1)
         det=c23*c12-c22*c13
!
!     SET ELEMENTS OF INVERSE IN A.
    3 if(det.eq.zero) goto 8
      s=temp/det
      a(1,1)=s*c11
      a(1,2)=s*c21
      a(1,3)=s*c31
      a(2,1)=s*c12
      a(2,2)=s*c22
      a(2,3)=s*c32
      a(3,1)=s*c13
      a(3,2)=s*c23
      a(3,3)=s*c33
      return
!
    4 if(n.lt.2) goto 5
!
!  N=2 CASE BY CRAMERS RULE.
!
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if(det.eq.zero) goto 8
      s=one/det
      c11   =s*a(2,2)
      a(1,2)=(-one*s)*a(1,2)                                             !hr07
      a(2,1)=(-one*s)*a(2,1)                                             !hr07
      a(2,2)=s*a(1,1)
      a(1,1)=c11
      return
!
!  N=1 CASE.
!
    5 if(a(1,1).eq.zero) goto 8
      a(1,1)=one/a(1,1)
      return
!
!  N.GT.3 CASES.  FACTORIZE MATRIX AND INVERT.
!
    6 call dfact(n,a,idim,ir,ifail,det,jfail)
      if(ifail.ne.0) return
      call dfinv(n,a,idim,ir)
      return
!
!  ERROR EXITS.
!
    7 ifail=+1
      call f010pr(name,n,idim,k,kprnt)
      return
!
    8 ifail=-1
      return
!
      end
      subroutine f010pr(name,n,idim,k,kprnt)
!     ******************************************************************
!
!     PRINT ROUTINE FOR PARAMETER ERRORS IN MATRIX SUBROUTINES $EQINV,
!     $EQN, $INV (WHERE $ IS A LETTER SPECIFYING THE ARITHMETIC TYPE).
!
!     NAME         (CHARACTER(6)) NAME OF THE CALLING ROUTINE.
!
!     N,IDIM,K     PARAMETERS OF THE CALLING ROUTINE (WITH K=0 IF K IS
!                  NOT TO BE PRINTED).
!
!     KPRNT        PRINT FLAG FOR K (K IS NOT PRINTED IF KPRNT=0).
!
!     ******************************************************************
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer idim,k,kprnt,lgfile,n
      character(len=6) name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      call kermtr('F010.1',lgfile,mflag,rflag)
      if(mflag) then
         if(lgfile.eq.0)  then
            if(kprnt.eq.0) write(lout,2000) name,n,idim
            if(kprnt.ne.0) write(lout,2001) name,n,idim,k
         else
            if(kprnt.eq.0) write(lgfile,2000) name,n,idim
            if(kprnt.ne.0) write(lgfile,2001) name,n,idim,k
         endif
      endif
      if(.not. rflag) then
         write(lout,*) 'KERNLIB F010PR: '//name
         call prror(-1)
      end if
      return
!
 2000 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim).',                                  &
     &6x,'n =', i4, 6x,'idim =', i4,'.')
 2001 format( 7x, 'subroutine ', a6,' ... parameter',                   &
     &' error (n.lt.1 or n.gt.idim or k.lt.1).',                        &
     &6x,'n =', i4, 6x,'idim =', i4, 6x,'k =', i4,'.')
      end

      subroutine rfact(n,a,idim,ir,ifail,det,jfail)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants

      implicit none

      integer i,idim,ifail,imposs,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch

      real(kind=fPrec) a,det,g1,g2,p,q,t,tf,x,y
      real(kind=fPrec) s11,s12

      character(len=6) hname

      dimension ir(*),a(idim,*)
!      data      g1, g2              /  1.e-37,  1.e37  /
      data      g1, g2              /  1.0e-37_fPrec,  1.0e37_fPrec  /               !hr07
      data      hname               /  ' RFACT'  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------

      if(idim .ge. n  .and.  n .gt. 0)  goto 110
         call tmprnt(hname,n,idim,0)
         return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q = pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. zero)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
            s11  =  -one*a(j,k)                                          !hr07
            s12  =  -one*a(k,j+1)                                        !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
 142        a(j,k)   =  (-one*s11) * a(j,j)                              !hr07
            a(k,j+1) =   -one*dotf(a(j,j+1),a(k,j),s12)                  !hr07
 143        continue
 144     continue
 150  if(mod(nxch,2) .ne. 0)  det  =  -one*det
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return

      contains

        real(kind=fPrec) function dotf(x,y,s11)
          real(kind=fPrec), intent(in) :: x, y, s11
          dotf = x * y + s11
        end function dotf

        integer function ipairf(j,k)
          integer, intent(in) :: j, k
          ipairf = j*2**12 + k
        end function ipairf

        real(kind=fPrec) function pivotf(x)
          real(kind=fPrec), intent(in) :: x
          pivotf = abs(x)
        end function pivotf

        real(kind=fPrec) function sizef(x)
          real(kind=fPrec), intent(in) :: x
          sizef = abs(x)
        end function sizef

      end subroutine rfact

      subroutine dfact(n,a,idim,ir,ifail,det,jfail)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants

      implicit none

      integer i,idim,ifail,imposs,ir,j,jfail,jm1,jover,jp1,      &
     &jrange,junder,k,l,n,normal,nxch
      real(kind=fPrec) g1,g2,p,q,t
      real(kind=fPrec) a,det,s11,s12,x,y,tf
      character(len=6)         hname
      dimension ir(*),a(idim,*)

!      data      g1, g2              /  1.e-37,  1.e37  /
      data      g1, g2              /  1.0e-37_fPrec,  1.0e37_fPrec  /               !hr07
      data      hname               /  ' DFACT'  /
      data      normal, imposs      /  0, -1  /
      data      jrange, jover, junder  /  0, +1, -1  /
      save
!-----------------------------------------------------------------------
      if(idim .ge. n  .and.  n .gt. 0)  goto 110
      call tmprnt(hname,n,idim,0)
      return
 110  ifail  =  normal
      jfail  =  jrange
      nxch   =  0
      det    =  one
      do 144    j  =  1, n
 120     k  =  j
         p  =  pivotf(a(j,j))
         if(j .eq. n)  goto 122
         jp1  =  j+1
         do 121    i  =  jp1, n
            q  =  pivotf(a(i,j))
            if(q .le. p)  goto 121
               k  =  i
               p  =  q
 121        continue
         if(k .ne. j)  goto 123
 122     if(p .gt. 0.)  goto 130
            det    =  zero
            ifail  =  imposs
            jfail  =  jrange
            return
 123     do 124    l  =  1, n
            tf      =  a(j,l)
            a(j,l)  =  a(k,l)
            a(k,l)  =  tf
 124        continue
         nxch      =  nxch + 1
         ir(nxch)  =  ipairf(j,k)
 130     det     =  det * a(j,j)
         a(j,j)  =  one / a(j,j)
         t  =  sizef(det)
         if(t .lt. g1)  then
            det    =  zero
            if(jfail .eq. jrange)  jfail  =  junder
         elseif(t .gt. g2)  then
            det    =  one
            if(jfail .eq. jrange)  jfail  =  jover
         endif
         if(j .eq. n)  goto 144
         jm1  =  j-1
         jp1  =  j+1
         do 143   k  =  jp1, n
            s11  =  -one*a(j,k)                                          !hr07
            s12  =  -one*a(k,j+1)                                        !hr07
            if(j .eq. 1)  goto 142
            do 141  i  =  1, jm1
               s11  =  dotf(a(i,k),a(j,i),s11)
               s12  =  dotf(a(i,j+1),a(k,i),s12)
 141           continue
 142        a(j,k)    =  (-one*s11) * a(j,j)                             !hr07
            a(k,j+1)  =  -one*dotf(a(j,j+1),a(k,j),s12)                  !hr07
 143        continue
 144     continue
 150  if(mod(nxch,2) .ne. 0)  det  =  -one*det                           !hr07
      if(jfail .ne. jrange)   det  =  zero
      ir(n)  =  nxch
      return

      contains

        real(kind=fPrec) function dotf(x,y,s11)
          real(kind=fPrec), intent(in) :: x, y, s11
          dotf = x * y + s11
        end function dotf

        integer function ipairf(j,k)
          integer, intent(in) :: j, k
          ipairf = j*2**12 + k
        end function ipairf

        real(kind=fPrec) function pivotf(x)
          real(kind=fPrec), intent(in) :: x
          pivotf = abs(x)
        end function pivotf

        real(kind=fPrec) function sizef(x)
          real(kind=fPrec), intent(in) :: x
          sizef = abs(x)
        end function sizef

      end subroutine dfact

      subroutine rfeqn(n,a,idim,ir,k,b)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants

      implicit none

      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      real(kind=fPrec) a,b,te,x,y
      real(kind=fPrec) s21,s22
      character(len=6) hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' RFEQN'  /
      save
!-----------------------------------------------------------------------
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
            s21  =  -one*b(i,l)                                          !hr07
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
            b(i,l)  = (-one*a(i,i))*s21                                  !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
            s22  =  -one*b(nmi,l)                                        !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
            b(nmi,l) = -one*s22
 242        continue
 243     continue
 299  continue
      return

      contains

        real(kind=fPrec) function dotf(x,y,s21)
          real(kind=fPrec), intent(in) :: x, y, s21
          dotf = x * y + s21
        end function dotf

      end subroutine rfeqn

      subroutine dfeqn(n,a,idim,ir,k,b)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer i,idim,ij,im1,ir,j,k,l,m,n,nm1,nmi,nmjp1,nxch
      real(kind=fPrec) a,b,x,y,te
      real(kind=fPrec) s21,s22
      character(len=6) hname
      dimension ir(*),a(idim,*),b(idim,*)
      data      hname               /  ' DFEQN'  /
      save
!-----------------------------------------------------------------------
      if(idim .ge. n  .and.  n .gt. 0  .and.  k .gt. 0)  goto 210
      call tmprnt(hname,n,idim,k)
      return
 210  nxch  =  ir(n)
      if(nxch .eq. 0)  goto 220
      do 212    m  =  1, nxch
         ij  =  ir(m)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 211   l  =  1, k
            te      =  b(i,l)
            b(i,l)  =  b(j,l)
            b(j,l)  =  te
 211        continue
 212     continue
 220  do 221    l  =  1, k
         b(1,l)  =  a(1,1)*b(1,l)
 221     continue
      if(n .eq. 1)  goto 299
      do 243    l  =  1, k
         do 232   i  =  2, n
            im1  =  i-1
            s21  =  - b(i,l)
            do 231   j  =  1, im1
               s21  =  dotf(a(i,j),b(j,l),s21)
 231           continue
            b(i,l)  =  (-one*a(i,i))*s21                                 !hr07
 232        continue
         nm1  =  n-1
         do 242   i  =  1, nm1
            nmi  =  n-i
            s22  =  -one*b(nmi,l)                                        !hr07
            do 241   j  =  1, i
               nmjp1  =  n - j+1
               s22    =  dotf(a(nmi,nmjp1),b(nmjp1,l),s22)
 241           continue
            b(nmi,l)  =  -one*s22                                        !hr07
 242        continue
 243     continue
 299  continue
      return

      contains

        real(kind=fPrec) function dotf(x,y,s21)
          real(kind=fPrec), intent(in) :: x, y, s21
          dotf = x * y + s21
        end function dotf

      end subroutine dfeqn

      subroutine rfinv(n,a,idim,ir)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants

      implicit none

      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      real(kind=fPrec) a,ti,x,y
      real(kind=fPrec) s31,s32,s33,s34
      character(len=6) hname
      dimension ir(*),a(idim,*)
      data      hname               /  ' RFINV'  /
      save
!-----------------------------------------------------------------------
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
      a(2,1)  = (-one*a(2,2)) * dotf(a(1,1),a(2,1),zero)     !hr07
      a(1,2)  =  -one*a(1,2)                                             !hr07
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
            s32  =  a(j,i)                                               !hr07
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
            a(i,j) = (-one*a(i,i)) * dotf(a(i-1,j),a(i,i-1),s31)        !hr07
            a(j,i) =  -one*s32                                            !hr07
 312        continue
         a(i,i-1) = (-one*a(i,i))*dotf(a(i-1,i-1),a(i,i-1),zero)         !hr07
         a(i-1,i) =  -one*a(i-1,i)                                       !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
            s33  =  a(i,j)                                               !hr07
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
            a(i,i+j) = s34                                               !hr07
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341 k  = 1, n
            ti     = a(k,i)
            a(k,i) = a(k,j)
            a(k,j) = ti
 341        continue
 342     continue
      return

      contains

        real(kind=fPrec) function dotf(x,y,s31)
          real(kind=fPrec), intent(in) :: x, y, s31
          dotf = x * y + s31
        end function dotf

      end subroutine rfinv

      subroutine dfinv(n,a,idim,ir)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none

      integer i,idim,ij,im2,ir,j,k,m,n,nm1,nmi,nxch
      real(kind=fPrec) a,s31,s32,s33,s34,ti,x,y
      character(len=6) hname
      dimension ir(*),a(idim,*)
      data      hname               /  ' DFINV'  /
      save
!-----------------------------------------------------------------------
      if(idim .ge. n  .and.  n .gt. 0)  goto 310
         call tmprnt(hname,n,idim,0)
         return
 310  if(n .eq. 1)  return
      a(2,1)  =  (-one*a(2,2)) * dotf(a(1,1),a(2,1),zero)                !hr07
      a(1,2)  =  -one*a(1,2)
      if(n .eq. 2)  goto 330
      do 314    i  =  3, n
         im2  =  i-2
         do 312 j  =  1, im2
            s31  =  zero
            s32  =  a(j,i)
            do 311  k  =  j, im2
               s31  =  dotf(a(k,j),a(i,k),s31)
               s32  =  dotf(a(j,k+1),a(k+1,i),s32)
 311           continue
            a(i,j)  =  (-one*a(i,i)) * dotf(a(i-1,j),a(i,i-1),s31)       !hr07
            a(j,i)  =  -one*s32                                          !hr07
 312        continue
         a(i,i-1)  =  (-one*a(i,i)) * dotf(a(i-1,i-1),a(i,i-1),zero)     !hr07
         a(i-1,i)  =  -one*a(i-1,i)                                      !hr07
 314     continue
 330  nm1  =  n-1
      do 335   i  =  1, nm1
         nmi  =  n-i
         do 332   j  =  1, i
            s33  =  a(i,j)
            do 331   k  =  1, nmi
               s33  =  dotf(a(i+k,j),a(i,i+k),s33)
 331           continue
            a(i,j)  =  s33
 332        continue
         do 334   j  =  1, nmi
            s34  =  zero
            do 333   k  =  j, nmi
               s34  =  dotf(a(i+k,i+j),a(i,i+k),s34)
 333           continue
            a(i,i+j)  =  s34
 334        continue
 335     continue
      nxch  =  ir(n)
      if(nxch .eq. 0)  return
        do 342 m  =  1, nxch
         k   =  nxch - m+1
         ij  =  ir(k)
         i   =  ij / 4096
         j   =  mod(ij,4096)
         do 341  k  =  1, n
            ti      =  a(k,i)
            a(k,i)  =  a(k,j)
            a(k,j)  =  ti
 341        continue
 342     continue
      return

      contains

        real(kind=fPrec) function dotf(x,y,s31)
          real(kind=fPrec), intent(in) :: x, y, s31
          dotf = x * y + s31
        end function dotf
      end subroutine dfinv

      subroutine tmprnt(name,n,idim,k)
      use floatPrecision
      use mathlib_bouncer
      use crcoall
      implicit none
      integer idim,k,lgfile,n
      character(len=6) name
      logical mflag,rflag
      save
!-----------------------------------------------------------------------
      if(name(2:2) .eq. 'S') then
         call kermtr('F012.1',lgfile,mflag,rflag)
      else
         call kermtr('F011.1',lgfile,mflag,rflag)
      endif
      if(mflag) then
         if(lgfile .eq. 0) then
            if(name(3:6) .eq. 'FEQN') then
               write(lout,1002) name, n, idim, k
            else
               write(lout,1001) name, n, idim
            endif
         else
            if(name(3:6) .eq. 'FEQN') then
               write(lgfile,1002) name, n, idim, k
            else
               write(lgfile,1001) name, n, idim
            endif
         endif
      endif
      if(.not. rflag) then
         write(lout,*) 'KERNLIB TMPRNT: '//name
         call prror(-1)
      endif
      return
1001  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n).',                                    &
     &5x,'n =', i4, 5x,'idim =', i4,'.')
1002  format(7x,' parameter error in subroutine ', a6,                  &
     &' ... (n.lt.1 or idim.lt.n or k.lt.1).',                          &
     &5x,'n =', i4, 5x,'idim =', i4, 5x,'k =', i4,'.')
      end

      subroutine lfitd(x,y,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO FIT A STRAIGHT LINE    Y=A*X+B    TO L POINTS WITH ERROR E
!     SEE MENZEL , FORMULAS OF PHYSICS P.116
!     POINTS WITH Y=0 ARE IGNOERD IF KEY=0
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      use floatPrecision
      use mathlib_bouncer
      implicit none
      integer j,key,l
      real(kind=fPrec) a,b,count,e,scartx,scarty
      real(kind=fPrec) sumx,sumxx,sumxy,sumy,sumyy,x,xmed,y,ymed
      dimension x(l),y(l)                                                !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l-2.lt.0) goto 25
      if(l-2.ge.0) goto 1
    1 count=0.0
      sumx=0.0
      sumy=0.0
      sumxy=0.0
      sumxx=0.0
      sumyy=0.0
      do 10 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 10
      sumx=sumx+x(j)
      sumy=sumy+y(j)
      count=count+1.0
   10 continue
      if(count.le.1.) goto 25
      ymed=sumy/count
      xmed=sumx/count
      do 20 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 20
      scartx=x(j)-xmed
      scarty=y(j)-ymed
      sumxy=sumxy+scartx   *scarty
      sumxx=sumxx+scartx   *scartx
      sumyy=sumyy+scarty   *scarty
   20 continue
!
!     FIT PARAMETERS
      if(sumxx.eq.0.) goto 25
      a=sumxy/sumxx
      b=ymed-a*xmed
      if(count.lt.3.) goto 101
      e=(sumyy-sumxy*a          )/(count-2.0)
      goto 100
!
!     ISUFFICIENT POINTS
   25 a=0.0
      b=0.0
  101 e=0.0
  100 return
      end
      subroutine lfitwd(x,y,w,l,key,a,b,e)
!-----------------------------------------------------------------------
!
!     TO PERFORM A WEIGHTED STRAIGHT LINE FIT
!
!     FOR FORMULAE USED SEE MENZEL, FORMULAS OF PHYSICS P.116
!
!     FIT IS OF Y=AX+B , WITH S**2 ESTIMATOR E. WEIGHTS ARE IN W.
!     IF KEY=0, POINTS WITH Y=0 ARE IGNORED
!     L IS NO. OF POINTS
!
!-----------------------------------------------------------------------
!Eric made DOUBLE PRECISION
      use floatPrecision
      use mathlib_bouncer
      implicit none
      integer icnt,j,key,l
      real(kind=fPrec) a,b,e,x,y,w
      real(kind=fPrec) w2,w2x,w2x2,w2xy,w2y,w2y2,ww,wwf,wwfi
      dimension x(l),y(l),w(l)                                           !hr07
      save
!-----------------------------------------------------------------------
!
!     CALCULATE SUMS
!
!-----------------------------------------------------------------------
      if(l.le.1) goto 1
      w2=0.
      w2x=0.
      w2y=0.
      w2xy=0.
      w2x2=0.
      w2y2=0.
      icnt=0
      do 2 j=1,l
      if(y(j).eq.0..and.key.eq.0) goto 2
      ww=w(j)**2                                                         !hr07
      w2=ww+w2
      wwf=ww*x(j)
      w2x=wwf+w2x
      w2x2=wwf*x(j)+w2x2
      w2xy=wwf*y(j)+w2xy
      wwfi=ww*y(j)
      w2y=wwfi+w2y
      w2y2=wwfi*y(j)+w2y2
      icnt=icnt+1
    2 continue
!
!     FIT PARAMETERS
      a=(w2xy-(w2x*w2y)/w2)/(w2x2-w2x**2/w2)
      b=(w2y-a*w2x)/w2
      if(icnt.le.2) goto 3
!Eric
      e=((w2y2-w2y**2/w2)-(w2xy-(w2x*w2y)/w2)**2/(w2x2-w2x**2/w2))/     &!hr07
     &real(icnt-2,fPrec)
      goto 4
!
!     ISUFFICIENT POINTS
    1 a=0.
      b=0.
    3 e=0.
    4 return
      end
+dk nwrtbnl
!GRDRHIC
!GRD-042008
      subroutine bnlrdis(ngrd)
!
!     SR, 09-08-2005
!     Format for the input file:
!               x, y   -> [ m ]
!               xp, yp -> [ rad ]
!               s      -> [ mm ]
!               DE     -> [ MeV ]
!
      use floatPrecision
      use crcoall
      implicit none
+ca parpro
!ERIC
+ca common
+ca crco
+ca rhicelens
      integer ngrd
!
!++ Vectors of coordinates
!
      integer i,j
+if crlibm
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      integer errno,l1,l2
      integer dtostr
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=41)
      character(len=maxf) fields(nofields)
!     integer errno,nfields,nunit,nf
      integer nfields,nunit,nf
      real(kind=fPrec) fround
+ei
      save
      write(lout,*) "Reading input bunch from beambeamdist.dat"
      mynp=0
!ERIC napx00???
      do j=1,napx
! Now read data using crlibm stuff.
+if fio
+if crlibm
        call enable_xp()
+ei
        read(54,*,end=10,err=20,round='nearest')                        &
     & myx(j),myxp(j),myy(j),myyp(j),mys(j),myp(j)
+if crlibm
        call disable_xp()
+ei
+ei
+if .not.fio
+if .not.crlibm
        read(54,*,end=10,err=20)                                        &
       &myx(j),myxp(j),myy(j),myyp(j),mys(j),myp(j)
+ei
+if crlibm
        read (54,'(A)',end=10) ch 
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,54,j,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          myx(j)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myxp(j)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myy(j)=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myyp(j)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          mys(j)=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          myp(j)=fround(errno,fields,6)
          nf=nf-1
        endif
+ei
+ei
      enddo
      mynp=1
 10   continue
      if(mynp.eq.0) then
        write(lout,*)
        write(lout,*) '!!!!! WARNING !!!!!'
        write(lout,*)'beambeamdist.dat is either missing or too small'
        write(lout,*)
        write(lout,'(a)') 'bnlelens input file error'
        call prror(-1)
      else
        write(lout,*) "Number of samples in the bunch = ",mynp
      endif
!ERIC napx00???
      do j=1,napx
+if crlibm
! Now use my new dtostr for portability
        l1=1
+if boinc
        ch(l1:l1+10)='checkdist '
        l1=l1+10
+ei
! We return the length of the string (always 24)
        errno=dtostr(myx(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myxp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myy(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myyp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(mys(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
        errno=dtostr(myp(j),ch1)
        ch(l1:l1+errno)=' '//ch1(1:errno)
        l1=l1+errno+1
+ei
+if .not.boinc
+if crlibm
        write(97,'(a)') ch(1:l1-1)
+ei
+if .not.crlibm
        write(97,'(e15.8,4(1x,e15.8),1x,f15.8)')                        &
     &myx(j),myxp(j),myy(j), myyp(j),mys(j),myp(j)
+ei
        endfile (97,iostat=ierro)
        backspace (97,iostat=ierro)
+ei
+if boinc
        if (.not.restart) then
+if crlibm
          write(10,'(a)') ch(1:l1-1)
+ei
+if .not.crlibm
          write(10,'(a10,e15.8,4(1x,e15.8),1x,f15.8)')                  &
     &'checkdist ',                                                     &
     &myx(j),myxp(j),myy(j), myyp(j),mys(j),myp(j)
+ei
          endfile (10,iostat=ierro)
          backspace (10,iostat=ierro)
          bnlrec=bnlrec+1
        endif
+ei
      enddo
      return
 20   continue
      write(lout,*) 'I/O Error on Unit 54'
      call prror(-1)
      end
!GRD-042008
!GRDRHIC
+dk checkpt
      subroutine crcheck
!     Thus subroutine checks if the C/R files fort.95 and fort.96 exists,
!     and if so tries to load them into the cr* variables.
!     This routine also repositions the output files for
!     fort.90..91-napx/2 or STF, DUMP, and DYNK (dynksets.dat).
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crstart.
      use floatPrecision
  use numerical_constants
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, ldynkfiledisable,                         &
     &dynk_crcheck_readdata, dynk_crcheck_positionFiles

      use dump, only : dump_crcheck_readdata, dump_crcheck_positionFiles
      
      use scatter, only : scatter_active, scatter_crcheck_readdata,     &
     &     scatter_crcheck_positionFiles
      
      use, intrinsic :: iso_fortran_env, only : int32

      use crcoall
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc
+if bnlelens
+ca rhicelens
+ei
+ca crco
+ca comgetfields
+ca stringzerotrim      
+ca version
      integer i,j,k,l,m,ia
      integer lstring,myia,mybinrecs,binrecs94

      !DANGER: IF THE LENGTH OF THE RECORDS IN WRITEBIN(_HEADER)CHANGES,
      ! THESE ARRAYS MUST BE UPDATED
      integer(int32) hbuff,tbuff
      dimension hbuff(253),tbuff(35)
      
      logical lopen,lerror


+if boinc
      character(len=256) filename
+ei
      save
      restart=.false.
      read95=.false.
      read96=.false.
!     Some log entries to fort.93
      write(93,*)                                                       &
     &'SIXTRACR CRCHECK CALLED lout=',lout,'restart',restart,           &
     &'rerun',rerun,'checkp',checkp
      flush(93)
+if debug
                   !call system('../crcheck >> crlog')
+ei
!--   We are not checkpoint/restart or we have no restart files
      if (.not.checkp) goto 605
      if (.not.fort95.and..not.fort96) goto 605
!--   If we do we must have a fort.6 as they were created by CRPOINT
! NOT TRUE anymore??? We might be NOT rerun but using a Sixin.zip
+if .not.boinc
      if (.not.rerun) then
        write(lout,*)                                                   &
     &'SIXTRACR CRCHECK *** ERROR *** ',                                &
     &'Found fort.95/fort.96 but NO fort.6'
        write(lout,*) 'SIXTRACR CRCHECK failure'
        call prror(-1)
      endif
+ei
!--   Check at least one restart file is readable
       write(93,*)                                                      &
     &'SIXTRACR CRCHECK checking fort.95/96'
       flush(93)
      if (fort95) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 1 VERSION'
        flush(93)
        
        rewind 95
        
        read(95,err=100,end=100)                                        &
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))   &
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.95 was written by "//    &
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//                            &
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."

           flush(93)

           goto 100
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 2'
        flush(93)
        
        read(95,err=100,end=100)                                        &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 3'
        flush(93)
        read(95,err=100,end=100)                                        &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 4 BNL'
        flush(93)
        read(95,err=100,end=100)                                        &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
     &(crnamepart(j),j=1,crnapxo)
      endif
!GRDRHIC
!GRD-042008
+ei

      write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 5 DUMP'
      flush(93)
      call dump_crcheck_readdata(95,lerror)
      if (lerror) goto 100

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 6 DYNK'
         flush(93)
         call dynk_crcheck_readdata(95,lerror)
         if (lerror) goto 100
      endif

      if(scatter_active) then
         write(93,*) "SIXTRACR CRCHECK reading fort.95 Record 7 SCATTER"
         flush(93)
         call scatter_crcheck_readdata(95,lerror)
         if (lerror) goto 100
      endif
      
!ERIC new extended checkpoint for synuthck
      if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.95
! We will re-read them in crstart to be sure they are restored correctly
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 8 extended vars fort.95',      &
     &' crnapxo=',crnapxo
          flush(93)
          read(95,end=100,err=100,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (95,iostat=ierro)
          write(93,*) 'CRCHECK read fort.95 EXTENDED OK'
          flush(93)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK leaving fort.95 for CRSTART EXTENDED'
          flush(93)
        endif
        read95=.true.
        goto 103
      endif
  100 if (.not.read95) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 95'
        flush(93)
      endif
      if (fort96) then
        write(93,*) 'CRCHECK trying fort.96 instead'
        flush(93)
        
        rewind 96

        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 1 VERSION'
        flush(93)

        read(96,err=101,end=101)                                        &
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))   &
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.96 was written by "//    &
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//                            &
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."
           
           flush(93)
           
           goto 101
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 2'
        flush(93)
        read(96,err=101,end=101,iostat=ierro)                           &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 3'
        flush(93)
      read(96,err=101,end=101,iostat=ierro)                             &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 4 BNL'
        flush(93)
        read(96,err=101,end=101)                                        &
     &crn_cut,                                                          &
     &crn_nocut,                                                        &
     &crsumsquarex,                                                     &
     &crsumsquarey,                                                     &
     &crsumtwojx,                                                       &
     &crsumtwojy,                                                       &
     &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
     &crtotals,                                                         &
     &(crnamepart(j),j=1,crnapxo)
      endif
!GRDRHIC
!GRD-042008
+ei

      write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 5 DUMP'
      flush(93)
      call dump_crcheck_readdata(96,lerror)
      if (lerror) goto 100

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 6 DYNK'
         flush(93)
         call dynk_crcheck_readdata(96,lerror)
         if (lerror) goto 101
      endif

      if(scatter_active) then
         write(93,*) "SIXTRACR CRCHECK reading fort.96 Record 7 SCATTER"
         flush(93)
         call scatter_crcheck_readdata(96,lerror)
         if (lerror) goto 101
      endif

!ERIC new extended checkpoint for synuthck
        if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.96
! We will re-read them in crstart to be sure they are correct
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 8 extended vars fort.96,',     &
     &' crnapxo=',crnapxo
          flush(93)
          write(93,*) 'CRCHECK verifying extended vars fort.96'
          flush(93)
          read(96,end=101,err=101,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (96,iostat=ierro)
          write(93,*) 'SIXTRACR CRCHECK read fort.96 EXTENDED OK'
          flush(93)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK, leaving fort.96 for CRSTART EXTENDED'
          flush(93)
        endif
        read96=.true.
        goto 103
      endif
  101 if (.not.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 96'
        flush(93)
      endif
  103 continue
      
+if debug
+if bnlelens
!     write(99,*) 'crcheck ',
!    &crbnlrec,                                                         &
!    &crbllrec,                                                         &
!    &crn_cut,                                                          &
!    &crn_nocut,                                                        &
!    &crsumsquarex,                                                     &
!    &crsumsquarey,                                                     &
!    &crsumtwojx,                                                       &
!    &crsumtwojy,                                                       &
!    &crlimit_twojx,crlimit_twojy,crlimit_twojr,                        &
!    &crtotals,                                                         &
!    &(crnamepart(j),j=1,crnapxo)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
+ei
!--   If we have successfully read either fort.95 or fort.96
!--   we need to handle lost particles and ntwin .ne. 2
!--   Otherwise we just continue with checkpointing as requested
      if (read95.or.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK read95',read95,'read96',read96,                 &
     &'crnapxo',crnapxo,'crbinrec',crbinrec,'napx',napx,                &
     &'sixrecs',sixrecs,'crsixrecs',crsixrecs,'crbnlrec',crbnlrec,      &
     &'crbllrec',crbllrec
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK crbinrecs ',                                    &
     &(crbinrecs(j),j=1,(crnapxo+1)/2)
        flush(93)
        
!--   First we position fort.6 to last checkpoint
        do j=1,crsixrecs
           read(6,'(a1024)',end=604,err=106,iostat=ierro) arecord
           sixrecs=sixrecs+1
        end do
        !This is not a FLUSH!
        endfile (6,iostat=ierro)
  604   backspace (6,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK found fort.6 sixrecs=',sixrecs
        flush(93)
+if bnlelens
!GRDRHIC
!GRD-042008
        if (lhc.eq.9) then
!--   Now re-position beambeam-output.dat and lostID.dat
!--   or only fort.10 if boinc
!     TODO: Fix positioning in +if bnlelens so that it works when number of cr records = 0
+if .not.boinc
  610     read(52,'(a1024)',end=608,err=108,iostat=ierro) arecord
          bnlrec=bnlrec+1
          if (bnlrec.lt.crbnlrec) goto 610
          !This is not a FLUSH!
          endfile (52,iostat=ierro)
  608     backspace (52,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.52 bnlrec=',bnlrec
          flush(93)
  611     read(53,'(a1024)',end=609,err=109,iostat=ierro) arecord
          bllrec=bllrec+1
          if (bllrec.lt.crbllrec) goto 611
          !This is not a FLUSH!
          endfile (53,iostat=ierro)
  609     backspace (53,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.53 bllrec=',bllrec
          flush(93)
+ei
+if boinc
  610     read(10,'(a1024)',end=608,err=108,iostat=ierro) arecord
          bnlrec=bnlrec+1
          if (bnlrec.lt.crbnlrec) goto 610
          !This is not a FLUSH!
          endfile (10,iostat=ierro)
  608     backspace (10,iostat=ierro)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK found fort.10 bnlrec=',bnlrec
          flush(93)
+ei
        endif
!GRDRHIC
!GRD-042008
+ei !END +if bnlelens

!--   We may be re-running with a DIFFERENT number of turns (numl)
! Eric fix this later by reading numl for fort.90
        if (numl.ne.crnuml) then
          if (numl.lt.crnumlcr) then
            write(lout,*)                                               &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            write(93,*)                                                 &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            flush(93)
            write(lout,*) 'SIXTRACR CRCHECK numl .lt. crnumlcr'
            call prror(-1)
          endif
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-sets numl in binary file headers from ',     &
     &crnuml,' to ',numl
          flush(93)

!--   Reposition binary files fort.90 etc. / singletrackfile.dat
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.ne.9) then
!GRDRHIC
!GRD-042008
+ei
          ! fort.94 = temp file where the data from fort.90 etc. is copied to and then back
+if boinc
          call boincrf('fort.94',filename)
          open(94,file=filename,form='unformatted',status='unknown')
+ei
+if .not.boinc
          open(94,file='fort.94',form='unformatted',status='unknown')
+ei
+if .not.stf
          do ia=1,crnapxo/2,1
            ! First, copy crbinrecs(ia) records of data from fort.91-ia to fort.94
            mybinrecs=0
            binrecs94=0
            myia=91-ia
            !Copy header into integer array hbuff
            read(91-ia,err=105,end=105,iostat=ierro) hbuff
            mybinrecs=mybinrecs+1
            hbuff(51)=numl ! Reset the number of turns (not very elegant)
            write(94,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data
            do j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(91-ia,err=105,end=105,iostat=ierro)                &
     &(tbuff(k),k=1,17)
                write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(91-ia,err=105,end=105,iostat=ierro) tbuff
                write(94,err=105,iostat=ierro) tbuff
              endif
              mybinrecs=mybinrecs+1
            end do ! END "do j=2,crbinrecs(ia)"
            
            ! Second, copy crbinrecs(ia) records of data from fort.94 to fort.91-ia
            rewind 94
            rewind 91-ia
            !Copy header
            read(94,err=105,end=105,iostat=ierro) hbuff
            binrecs94=binrecs94+1
            write(91-ia,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data into integer array tbuff
            do j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(94,err=105,end=105,iostat=ierro)                   &
     &(tbuff(k),k=1,17)
                write(91-ia,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(94,err=105,end=105,iostat=ierro) tbuff
                write(91-ia,err=105,iostat=ierro) tbuff
              endif
              binrecs94=binrecs94+1
            end do ! END "j=2,crbinrecs(ia)"
            !This is not a FLUSH!
            endfile (91-ia,iostat=ierro)
            backspace (91-ia,iostat=ierro)
            rewind 94
         end do ! END "do ia=1,crnapxo/2,1"
+ei ! END +if .not.stf
+if stf
          ! First, copy crbinrecs(ia)*(crnapx/2) records of data from singletrackfile.dat to fort.94
          mybinrecs=0
          !Copy headers
          do ia=1,crnapxo/2,1
             read(90,err=105,end=105,iostat=ierro) hbuff
             mybinrecs=mybinrecs+1
             hbuff(51)=numl ! Reset the number of turns (not very elegant)
             write(94,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(90,err=105,end=105,iostat=ierro)                &
     &                  (tbuff(k),k=1,17)
                   write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(90,err=105,end=105,iostat=ierro) tbuff
                   write(94,err=105,iostat=ierro) tbuff
                endif
                mybinrecs=mybinrecs+1
             end do
          end do
          
          ! Second, copy crbinrecs(ia)*(crnapx/2) records of data from fort.94 to singletrackfile.dat
          rewind 94
          rewind 90
          binrecs94=0
          ! Copy header
          do ia=1,crnapxo/2,1
             read(94,err=105,end=105,iostat=ierro) hbuff
             binrecs94=binrecs94+1
             write(90,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(94,err=105,end=105,iostat=ierro)                &
     &                  (tbuff(k),k=1,17)
                   write(90,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(94,err=105,end=105,iostat=ierro) tbuff
                   write(90,err=105,iostat=ierro) tbuff
                endif
                binrecs94=binrecs94+1
             enddo
          end do
          !This is not a FLUSH!
          endfile   (90,iostat=ierro)
          backspace (90,iostat=ierro)
+ei ! END +if stf
          close(94)
+if bnlelens
!GRDRHIC
!GRD-042008
          endif ! END "if (lhc.ne.9) then"
!GRDRHIC
!GRD-042008
+ei
        else !ELSE for "if(nnuml.ne.crnuml) then" -> here we treat nnuml.eq.crnuml, i.e. the number of turns have not been changed
!--  Now with the new array crbinrecs we can ignore files which are
!--  basically finished because a particle has been lost.......
!--  Just check crbinrecs against crbinrec
+if bnlelens
!GRDRHIC
!GRD-042008
          if (lhc.ne.9) then
!GRDRHIC
!GRD-042008
+ei
+if .not.stf
          ! Binary files have been rewritten; now re-position
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-positioning binary files'
          do ia=1,crnapxo/2,1
            myia=91-ia
            if (crbinrecs(ia).ge.crbinrec) then
              mybinrecs=0
              read(91-ia,err=102,end=102,iostat=ierro) hbuff
              do 11 j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                  read(91-ia,err=102,end=102,iostat=ierro)              &
     &(tbuff(k),k=1,17)
                else
                  read(91-ia,err=102,end=102,iostat=ierro) tbuff
                endif
              mybinrecs=mybinrecs+1
   11         continue
              !This is not a FLUSH!
              endfile (91-ia,iostat=ierro)
              backspace (91-ia,iostat=ierro)
             else ! Number of ecords written to this file < general number of records written
                  ! => Particle has been lost before last checkpoint, no need to reposition.
              write(93,*)                                               &
     &'SIXTRACR CRCHECK ignoring IA ',ia,' Unit ',myia
            endif
         end do ! END "do ia=1,crnapxo/2,1"
+ei ! END +if .not.stf
+if stf
      mybinrecs=0
      ! Reposition headers
      do ia=1,crnapxo/2,1
         read(90,err=102,end=102,iostat=ierro) hbuff
         mybinrecs=mybinrecs+1
      end do
      !Reposition track records
      do ia=1,crnapxo/2,1
         do j=2,crbinrecs(ia)
            if(ntwin.ne.2) then !ntwin=1
               read(90,err=102,end=102,iostat=ierro)                    &
     &              (tbuff(k),k=1,17)
            else                !ntwin=2
               read(90,err=102,end=102,iostat=ierro) tbuff
            endif
            mybinrecs=mybinrecs+1
         end do
      enddo
+ei ! END +if stf
      endif ! END "if (numl.ne.crnuml) then" and END else
+if bnlelens
!GRDRHIC
!GRD-042008
          endif
        if (lhc.eq.9) then
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK skipping binary files for bnlelens'
          flush(93)
        endif
!GRDRHIC
!GRD-042008
+ei
      
      !reposition dynksets.dat
      if (ldynk .and.(.not.ldynkfiledisable) ) then
         write(93,*) "SIXTRACR CRCHECK REPOSITIONING dynksets.dat"
         flush(93)
         call dynk_crcheck_positionFiles
      endif !END if (ldynk .and.(.not.ldynkfiledisable) )
      
      !Reposition files for DUMP
      write(93,*) "SIXTRACR CRCHECK REPOSITIONING DUMP files"
      flush(93)
      call dump_crcheck_positionFiles
      
      if(scatter_active) then
         write(93,*)                                                    &
     &        "SIXTRACR CRCHECK REPOSITIONING scatter_log.txt"
         flush(93)
         call scatter_crcheck_positionFiles
         
      endif
      
!--     Set up flag for tracking routines to call CRSTART
        restart=.true.
        write(lout,'(a80)')                                                   &
     &runtim
        !Flush or truncate?
        endfile (lout,iostat=ierro)
        backspace (lout,iostat=ierro)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK restart=TRUE',' crnumlcr=',crnumlcr
        flush(93)
        return
      endif
      
      goto 605                  !Should not end up here -> checkpoint failed.
                                ! Start simulation over!

!--   Just abort if we cannot re-position/copy the binary files,
+if .not.stf
  102 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING fort.',      &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      write(lout,*) 'SIXTRACR CRCHECK failure positioning binary files'
      call prror(-1)
+ei
+if stf
  102 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING ',           &
     &'singletrackfile.dat for ia=',ia,' IOSTAT=',ierro
      write(lout,*)                                                     &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      write(lout,*)'SIXTRACR CRCHECK failure positioning binary files'
      call prror(-1)
+ei
+if .not.stf
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING fort.',         &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      write(lout,*)'SIXTRACR CRCHECK failure copying binary files'
      call prror(-1)
+ei ! END +if .not.stf
+if stf
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING particle pair', &
     &ia,' IOSTAT=',ierro, ' from/to singletrackfile.dat'
      write(lout,*)                                                     &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      write(lout,*)'SIXTRACR CRCHECK failure copying binary files'
      call prror(-1)
+ei ! END +if stf
!--  We are not checkpointing or we have no checkpoints
!--  or we have no readable checkpoint
!--  If not checkpointing we can just give up on lout and use
!--  fort.6. We don't need to count records at all
  605 write(93,*)                                                       &
     &'SIXTRACR CRCHECK no restart possible checkp=',checkp
      flush(93)
      if (.not.checkp) then
        if (rerun) then
!--   we nevertheless have an existing fort.6
!--   we will just overwrite it for now and delete
!--   92 to avoid abend copying it again
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK overwriting fort.6'
          flush(93)
        endif
!--   and just use fort.6 from now on
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK giving up on LOUT'
        flush(93)
+if debug
                   !call system('../crcheck >> crlog')
+ei
!--   Copy the lout to fort.6 (the file, not output_unit)
!     It seems that FORTRAN will open the file automatically?
!     There are no open(unit=6) etc. calls anywhere...
        rewind lout
    3   read(lout,'(a1024)',end=1,err=107,iostat=ierro) arecord
        lstring=1024
        do i=1024,2,-1
          lstring=i
          if (arecord(i:i).ne.' ')goto 2
          lstring=lstring-1
        enddo
    2   write(6,'(a)') arecord(1:lstring)
        goto 3
        !Not a flush?
    1   endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        !This is not a FLUSH!
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
+if debug
                   !call system('../crcheck >> crlog')
+ei
        lout=6
      endif
      return
 106  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.6, iostat=',ierro
      write(93,*)                                                       &
     &'sixrecs=',sixrecs,' crsixrecs=',crsixrecs
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.6'
      call prror(-1)
 107  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.92, iostat=',ierro
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.92'
      call prror(-1)
+if bnlelens
!GRDRHIC
!GRD-042008
 108  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.52, iostat=',ierro
      write(93,*)                                                       &
     &'bnlrec=',bnlrec,' crbnlrec=',crbnlrec
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.52'
      call prror(-1)
 109  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.53, iostat=',ierro
      write(93,*)                                                       &
     &'bllrec=',bllrec,' crbllrec=',crbllrec
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.53'
      call prror(-1)
!GRDRHIC
!GRD-042008
+ei
      end

      subroutine crpoint
!     This subroutine writes the checkpoint data to fort.95/96,
!     and copies the new output from the temporary (lout/fort.92) output file into fort.6.
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutine crcheck and crstart.
      use floatPrecision
  use numerical_constants
+if datamods
      use bigmats, only : as, al !Only take the variables from common, not from commonmn
+ei

      use dynk, only : ldynk, dynk_getvalue, fsets_dynk_cr,             &
     &csets_unique_dynk, nsets_unique_dynk, dynkfilepos, dynk_crpoint

      use dump, only : dump_crpoint
      
      use scatter, only : scatter_active, scatter_crpoint
      
      use crcoall
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc

+if bnlelens
+ca rhicelens
+ei
+ca version
+ca crco
      integer i,j,l,k,m
      integer lstring,osixrecs,ncalls
      logical lerror
+if boinc
      character(len=256) filename
+ei
      data ncalls /0/
      save
!     call system('echo "CPSTART `date`" >> crtimes')
+if .not.debug
      if (ncalls.le.20.or.numx.ge.nnuml-20) then
+ei
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED numlmax=',numlmax,' numlcp=',numlcp
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED lout=',lout,' numx=',numx,'numl',numl
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED binrec/sixrec ',binrec,sixrecs
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      ncalls=ncalls+1
      if (restart) then
        restart=.false.
        return
      endif
!--   We need to copy fort.92 (lout) to fort.6 (sixrecs)
!--   (if it exists and we are not already using fort.6)
+if debug
                   !call system('../crpoint >> crlog')
+ei
      osixrecs=sixrecs
      rewind lout
    3 read(lout,'(a1024)',end=1,err=101,iostat=ierro) arecord
      lstring=1024
      do i=1024,2,-1
        lstring=i
        if (arecord(i:i).ne.' ') goto 2
        lstring=lstring-1
      enddo
    2 write(6,'(a)',err=102,iostat=ierro) arecord(1:lstring)
      sixrecs=sixrecs+1
      goto 3
    1 if (sixrecs.ne.osixrecs) then
        endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
+if debug
                   !call system('../crpoint >> crlog')
+ei
+if boinc
        call boincrf('fort.92',filename)
        open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
        open(lout,file='fort.92',form='formatted',status='unknown')
+ei
+if .not.debug
        if (ncalls.le.5.or.numx.ge.numl) then
+ei
          write(93,*)                                                   &
     &'SIXTRACR CRPOINT copied lout=',lout,'sixrecs=',sixrecs
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
      else
        rewind lout
      endif
      call timex(time3)
! Hope this is correct
! Maybe not!!!! this should be accumulative over multiple C/Rs
      time3=(time3-time1)+crtime3
      crnumlcr=numx+1

      if (ldynk) then ! Store current settings of elements affected by DYNK
+if .not.debug
         if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT filling fsets_dynk_cr'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
         endif
+ei
         do j=1,nsets_unique_dynk
            fsets_dynk_cr(j) =                                          &
     &           dynk_getvalue(csets_unique_dynk(j,1),                  &
     &                         csets_unique_dynk(j,2))
         end do

!c$$$         write (93,*) "Contents: (nsets_unique_dynk=",
!c$$$     &        nsets_unique_dynk,")"
!c$$$         do j=1,nsets_unique_dynk
!c$$$            write(93,*) csets_unique_dynk(j,1),csets_unique_dynk(j,2),
!c$$$     &                  fsets_dynk_cr(j)
!c$$$         enddo
!c$$$         write(93,*) "DONE"
!c$$$         endfile (93,iostat=ierro)
!c$$$         backspace (93,iostat=ierro)
      end if

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
        write(93,*) 'SIXTRACR CRPOINT writing fort.95'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      rewind 95
      write(95,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(95,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(95,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (95,iostat=ierro)
      backspace (95,iostat=ierro)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing BNL vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        write(95,err=100,iostat=ierro)                                  &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napxo)
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif
!GRDRHIC
!GRD-042008
+ei

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.95'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      call dump_crpoint(95, lerror,ierro)
      if (lerror) then
         goto 100
      endif
      
      if (ldynk) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        call dynk_crpoint(95,lerror,ierro)
        if (lerror) goto 100
      endif
      
      if (scatter_active) then
+if .not.debug
         if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing SCATTER vars fort.95'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
         endif
+ei
         call scatter_crpoint(95,lerror,ierro)
         if (lerror) goto 100
      endif
      
      if (sythckcr) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
!ERIC new extended checkpoint for synuthck
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
+if .not.datamods
        write(95,err=100,iostat=ierro)                                  &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
        if(ithick.eq.1) then
+if .not.debug
          if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//      &
     & ' for DATAMODS to fort.95'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
          endif
+ei
          write(95,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile (95,iostat=ierro)
          backspace (95,iostat=ierro)
        endif
        
        write(95,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif

+if bnlelens
+if debug
!     if (numx.ge.990) then
!     write(99,*) 'Checkpointed bnl numx ',numx
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napxo)
!     write(99,*) 'crpoint xv,yv j=1 ',xv(1,1),xv(2,1),yv(1,1),yv(2,1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
!     endif
+ei
+ei
!--   and finally a second checkpoint copy, or maybe not!
!--   Well, a second copy is indeed required as shown by testing
+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
        write(93,*) 'SIXTRACR CRPOINT writing fort.96'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      rewind 96
      write(96,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(96,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(96,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing Record 3 BNL fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        write(96,err=100,iostat=ierro)                                  &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napxo)
        endfile (96,iostat=ierro)
        backspace (96,iostat=ierro)
      endif
!GRDRHIC
!GRD-042008
+ei

+if .not.debug
      if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.96'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
+if .not.debug
      endif
+ei
      call dump_crpoint(95, lerror,ierro)
      if (lerror) then
         goto 100
      endif

      if (ldynk) then
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
        call dynk_crpoint(96,lerror,ierro)
        if (lerror) goto 100
      endif
      
      if (scatter_active) then
+if .not.debug
         if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing SCATTER vars fort.96'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
         endif
+ei
         call scatter_crpoint(96,lerror,ierro)
         if (lerror) goto 100
      endif
      
      if (sythckcr) then
!ERIC new extended checkpoint for synuthck
+if .not.debug
        if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
+if .not.debug
        endif
+ei
+if .not.datamods
        write(96,err=100,iostat=ierro)                                  &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
        if (ithick.eq.1) then
+if .not.debug
          if (ncalls.le.20.or.numx.ge.numl-20) then
+ei
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//      &
     & ' for DATAMODS to fort.96'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
+if .not.debug
          endif
+ei
          write(96,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile   (96,iostat=ierro)
          backspace (96,iostat=ierro)
        endif
        
        write(96,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
      endif
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)
+if debug
                   !call system('../crpoint >> crlog')
+ei
+if debug
!ERIC
!     call dump('1st Checkpoint',numx,i)
!     call abend('SIXTRACR CHECKPOINT written                       ')
+ei
!     call system('echo "CPEND   `date`" >> crtimes')
  104 return
  100 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing checkpt file,iostat=',    &
     &ierro
      goto 103
  101 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** reading lout fort.92,iostat=',    &
     &ierro
      goto 103
  102 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing fort.6,iostat=',          &
     &ierro
  103 endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      write(lout,*)'SIXTRACR CHECKPOINT I/O Error'
      call prror(-1)
      end

      subroutine crstart
!     If we are restarting (restart is TRUE), this routine is called
!     in the beginning of the tracking loops.
!     It is used to copy the cr* variables to the normal variables,
!     e.g. crnapx -> napx etc.
!
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crcheck.
      use floatPrecision
  use numerical_constants
+if datamods
      use bigmats
+ei
      use dynk, only : ldynk, dynk_crstart

      use scatter, only: scatter_active, scatter_crstart
      
      use crcoall
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonl
+ca commonmn
+ca commonm1
+ca commontr
+ca commonc
+if bnlelens
+ca rhicelens
+ei
+ca crco

      real(kind=fPrec) dynk_newValue

      integer j,l,k,m,i
      character(len=256) filename
      save
      write(93,*)                                                       &
     &'SIXTRACR CRSTART called crnumlcr',crnumlcr
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      numlcr=crnumlcr
!--   We do NOT reset numl so that a run can be extended for
!--   for more turns from the last checkpoint
!--   but we need to worry about numxv, nnumxv
      binrec=crbinrec
      bnlrec=crbnlrec
      bllrec=crbllrec
      sythckcr=crsythck
! the crtime3 is required (crtime0/1 removed)
      napxo=crnapxo
      napx=crnapx
      e0=cre0
      e0f=sqrt(e0**2-pma**2)                                             !hr08
      write(93,*) 'CRSTART doing binrecs'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,(napxo+1)/2
        binrecs(j)=crbinrecs(j)
      enddo
      write(93,*) 'CRSTART doing normal NPART vars'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,napxo
        numxv(j)=crnumxv(j)
        nnumxv(j)=crnnumxv(j)
        nlostp(j)=crnlostp(j)
        pstop(j)=crpstop(j)
        xv(1,j)=crxv(1,j)
        yv(1,j)=cryv(1,j)
        xv(2,j)=crxv(2,j)
        yv(2,j)=cryv(2,j)
        sigmv(j)=crsigmv(j)
        dpsv(j)=crdpsv(j)
        dpsv1(j)=crdpsv1(j)
! TEMPORARY? fix for crabamp/multipole problem
!       oidpsv(j)=croidpsv(j)
        oidpsv(j)=one/(one+dpsv(j))
        ejv(j)=crejv(j)
        ejfv(j)=crejfv(j)
        rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        aperv(j,1)=craperv(j,1)
        aperv(j,2)=craperv(j,2)
        xvl(1,j)=crxvl(1,j)
        xvl(2,j)=crxvl(2,j)
        yvl(1,j)=cryvl(1,j)
        yvl(2,j)=cryvl(2,j)
        dpsvl(j)=crdpsvl(j)
        ejvl(j)=crejvl(j)
        sigmvl(j)=crsigmvl(j)
        if (.not.pstop(j)) then
          numxv(j)=numl
          nnumxv(j)=numl
        endif
+if bnlelens
!GRDRHIC
!GRD-042008
        namepart(j)=crnamepart(j)
!GRDRHIC
!GRD-042008
+ei
      enddo
+if bnlelens
!GRDRHIC
!GRD-042008
      if(lhc.eq.9) then
        write(93,*) 'CRSTART doing BNL vars'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        n_cut=crn_cut
        n_nocut=crn_nocut
        sumsquarex=crsumsquarex
        sumsquarey=crsumsquarey
        sumtwojx=crsumtwojx
        sumtwojy=crsumtwojy
        limit_twojx=crlimit_twojx
        limit_twojy=crlimit_twojy
        limit_twojr=crlimit_twojr
        totals=crtotals
      endif
!GRDRHIC
!GRD-042008
+ei
+if debug
+if bnlelens
!     write(99,*) 'CRSTART bnl numlcr ',numlcr
!     write(99,*)                                                       &
!    &n_cut,                                                            &
!    &n_nocut,                                                          &
!    &sumsquarex,                                                       &
!    &sumsquarey,                                                       &
!    &sumtwojx,                                                         &
!    &sumtwojy,                                                         &
!    &limit_twojx,limit_twojy,limit_twojr,                              &
!    &totals,                                                           &
!    &(namepart(j),j=1,napxo)
!     write(99,*) 'crstart xv,yv j=1 ',xv(1,1),xv(2,1),yv(1,1),yv(2,1)
!     endfile (99,iostat=ierro)
!     backspace (99,iostat=ierro)
+ei
+ei
!ERIC new extended checkpoint for synuthck
      
      if (ldynk) then
         call dynk_crstart
      endif

      if (scatter_active) then
         call scatter_crstart
      endif
      
      if (crsythck) then
!ERICVARS now read the extended vars from fort.95/96.
        if (cril.ne.il) then
          write(lout,*)                                                 &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          write(93,*)                                                   &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          write(lout,*)                                                 &
     &         'SIXTRACR CRSTART Problem wih cril/il extended C/R'
          call prror(-1)
        endif
!ERICVARS now read the extended vars from fort.95/96.
+if debug
! Commented out code for multiple records
!       write(93,*) 'CRSTART DEBUG DUMP'
!       call dump('Before xcrstart',0,0)
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       write(93,*) 'CRSTART reading EXTENDED vars'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       if (read95) then
!         i=1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(aek(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(afok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as4(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as6(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(co(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpd(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpsq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fokqv(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(g(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(gl(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hm(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hp(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hs(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rho(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(si(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(siq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm12(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm2(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm23(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wf(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfa(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfhi(j),j=1,napxo)
!         go to 102
!       endif
+ei
        if (read95) then
+if .not.datamods
          read(95,end=100,err=100,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if .not.datamods
          if (ithick.eq.1) then
            read(95,end=100,err=100,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          
          read(95,end=100,err=100,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
          write(93,*) 'CRSTART read fort.95 EXTENDED OK'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          go to 102
        endif
        if (read96) then
+if .not.datamods
          read(96,end=101,err=101,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
+if datamods
          if (ithick.eq.1) then
            read(96,end=101,err=101,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          read(96,end=101,err=101,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
+ei
      write(93,*) 'CRSTART read fort.96 EXTENDED OK'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
          go to 102
        endif
  100   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 95 (extended)',  &
     &' iostat=',ierro
+if debug
! Multiple record debug code commented out
!       write(93,*) 'CRSTART This was the ith READ, I=',i
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
+ei
        go to 103
  101   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 96 (extended)',  &
     &' iostat=',ierro
  103   endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        write(lout,*)'SIXTRACR CRSTART Problem with extended checkpoint'
        call prror(-1)
      endif
  102 write(93,*)                                                       &
     &'SIXTRACR CRSTART six/crsix/bin recs',sixrecs,crsixrecs,binrec
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
+if debug
                   !call system('../crstart >> crlog')
+ei
!--   Just throw away our fort.92 stuff.
      rewind lout
      endfile (lout,iostat=ierro)
      close(lout)
+if debug
                   !call system('../crstart >> crlog')
+ei
+if boinc
      call boincrf('fort.92',filename)
      open(lout,file=filename,form='formatted',status='unknown')
+ei
+if .not.boinc
      open(lout,file='fort.92',form='formatted',status='unknown')
+ei
! but also add the rerun message
      write(lout,'(a80)')                                                     &
     &runtim
      runtim(1:20)='SIXTRACR restarted: '
      write(lout,'(a80)')                                                     &
     &runtim
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
+if debug
                   !call system('../crstart >> crlog')
+ei
      return
  606 backspace (6,iostat=ierro)
      write(lout,*)                                                     &
     &' SIXTRACR CRSTART Problem re-positioning fort.6: sixrecs',       &
     &sixrecs,'crsixrecs',crsixrecs
      write(lout,*)'SIXTRACR CRSTART Problem fort.6'
      call prror(-1)
      end

+dk aux
!      logical function isnan(arg1,arg2)
      logical function myisnan(arg1,arg2)
      use floatPrecision
      use mathlib_bouncer
      implicit none
      real(kind=fPrec) arg1,arg2
!      isnan=.false.
!      if(arg1.ne.arg2) isnan=.true.
      myisnan=.false.
      if(arg1.ne.arg2) myisnan=.true.
      end

      subroutine datime(nd,nt)
      implicit none
! Fill common slate for usage by hmachi call as per z007 writeup.        !hr08
      common /slate/ isl(40)                                             !hr08

      integer isl                                                        !hr08
!
!-    call datime (nd,nt)   returns integer date   nd = yymmdd
!-                                  integer time   nt =   hhmm
!     integer nd,nt,mm(3),nn(3)
!     call idate (mm(1),mm(2),mm(3))
!     call itime (nn)
      character(len=8) date
      character(len=10) time
      character(len=5) zone
      integer values(8),mm(3),nd,nt
      save
      call date_and_time(date,time,zone,values)
      mm(3)=mod(values(1),100)
!     mm(3) = mod (mm(3),100)
      mm(2)=values(3)
      mm(1)=values(2)
      isl(1)= mm(3)                                                      !hr08
      isl(2)= mm(2)                                                      !hr08
      isl(3)= mm(1)                                                      !hr08
      isl(4)= values(5)                                                  !hr08
      isl(5)= values(6)                                                  !hr08
      isl(6)= 0                                                          !hr08
      nd = (mm(3)*100+mm(1))*100 + mm(2)
!     nt =            nn(1) *100 + nn(2)
      nt=values(5)*100+values(6)
      return
      end

      subroutine timest(r1)
      implicit none
+ca commtim
      logical start
      data start /.false./
      save
      if (.not.start) then
        start=.true.
        call cpu_time(timestart)
      endif
      return
      end

      subroutine timex(r1)
      implicit none
+ca commtim
      save
      call timest(0.0)
      call cpu_time(timenow)
      r1=timenow-timestart
      return
      end
      
      subroutine abend(cstring)
      use floatPrecision
  use numerical_constants
      use, intrinsic :: iso_fortran_env, only : error_unit
      use crcoall
      implicit none
+ca parpro
+ca common
+ca commonxz
+ca crco
+ca version
+ca errout
      integer i,lstring,j
      character(len=*) cstring
      character(len=256) filename
      real(kind=fPrec) sumda(60)
      logical fopen
      character(len=8192) ch
      character(len=25) ch1
      integer errno,l1,l2
      integer dtostr
      integer ich
      save
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND called and closing files'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
! Calling close to be very safe.......96 calls to abend
! Easier than adding the call on every abend
      call closeUnits
! If fort.10 is inexistent (physics error or some other problem)
! we try and write a 0d0 file with a turn number and CPU time
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND checking fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
+if nagfor
+if boinc
      call boincrf('fort.10',filename)
      open(10,file=filename,form='formatted',status='unknown',err=11,   &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+if .not.boinc
      open(10,file='fort.10',form='formatted',status='unknown',err=11,  &
+if fio
     &round='nearest',                                                  &
+ei
     &recl=8195)
+ei
+ei

+if .not.nagfor
+if boinc
      call boincrf('fort.10',filename)
+if fio
      open(10,file=filename,form='formatted',status='unknown',err=11,   &
     &round='nearest')
+ei
+if .not.fio
      open(10,file=filename,form='formatted',status='unknown',err=11)
+ei
+ei
+if .not.boinc
+if fio
      open(10,file='fort.10',form='formatted',status='unknown',err=11,  &
     &round='nearest')
+ei
+if .not.fio
      open(10,file='fort.10',form='formatted',status='unknown',err=11)
+ei
+ei
+ei

! Now we try and read fort.10 i.e. is it empty?
      read(10,'(a1024)',end=11,err=11,iostat=ierro) arecord
! Seems to be OK
      goto 12    
 11   continue
! Now we try and write a fort.10
! We put some CPU for Igor, a version, and turn number 0
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND writing a fort.10'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
!     the version
      itot=0
      ttot=0
      do i=1,8
        if (version(i:i).ne.' ') then
          if (version(i:i).ne.'.') then
            itot=itot*10+ichar(version(i:i))-ichar('0')
          else
            ttot=ttot*10**2+itot
            itot=0
          endif
        endif
      enddo
      ttot=ttot*10**2+itot
      do i=1,60
        sumda(i)=zero
      enddo
      sumda(52)=real(ttot,fPrec)
!     the CPU
      call timex(time1)
      trtime=time1-time0
+if cr
      trtime=trtime+crtime3  
+ei
      sumda(60)=real(trtime,fPrec)
! Note it COULD happen that napxo is 0 for a very very early error
! and even napx!!!
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      write(93,*)                                                       &
     &'SIXTRACR STOP/ABEND writing fort.10, lines',napxo,'/',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      if (napxo.eq.0.and.napx.eq.0) napxo=1
      if (napxo.eq.0) napxo=napx
      do j=1,napxo
+if .not.crlibm
        write(ch,*,iostat=ierro) (sumda(i),i=1,60)
        do ich=8192,1,-1
          if(ch(ich:ich).ne.' ') goto 707
        enddo
 707    write(10,'(a)',iostat=ierro) ch(:ich)
+ei
+if crlibm
! Now use my new dtostr for portability
        l1=1
        do i=1,60
! We return the length of the string (always 24)
          errno=dtostr(sumda(i),ch1)
          ch(l1:l1+errno)=' '//ch1(1:errno)
          l1=l1+errno+1
        enddo        
        write(10,'(a)',iostat=ierro) ch(1:l1-1)
+ei
        if(ierro.ne.0) then
          write(lout,*)
          write(lout,*)                                                 &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE 10 FROM ABEND'
          write(lout,*) 'ERROR CODE : ',ierro
          write(lout,*)
        endif
      enddo
 12   continue
      close (10,iostat=ierro)
+if cr
+if debug
                   !call system('../crend   >> crlog')
+ei
      close(91,err=4)
    4 continue
      close(94,err=5)
    5 continue
      close(95,err=6)
    6 continue
      close(96,err=7)
    7 continue
      if (lout.eq.92) then
        write(93,*)                                                     &
     &'SIXTRACR STOP/ABEND copying fort.92 to fort.6'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        rewind 92
    3   read(92,'(a1024)',end=1,err=8,iostat=ierro) arecord
        lstring=1024
        do i=1024,2,-1
          lstring=i
          if (arecord(i:i).ne.' ') goto 2
          lstring=lstring-1
        enddo
    2   write(6,'(a)',iostat=ierro) arecord(1:lstring)
        goto 3
      endif
    1 write(6,*,iostat=ierro)                                           &
     &'SIXTRACR stop '//cstring
      close(6,iostat=ierro)
!     and get rid of fort.92
      rewind 92
      endfile (92,iostat=ierro)
      close(92)
      write(93,*)                                                       &
     &'SIXTRACR stop '//cstring
      write(93,*)
+if debug
                   !call system('../crend   >> crlog')
+ei
+if boinc
!+if debug
      do i=2,120
        inquire(i,opened=fopen)
        write(93,*) 'UNIT ',i,' opened ',fopen
      enddo 
!+ei
!     call boinc_zipitall()
!     call boinc_finish_graphics()
      if(errout_status.ne.0) then
         close(93)
         call boincrf('fort.93',filename)
         call print_lastlines_to_stderr(93,filename)
         
         call boincrf('fort.6',filename)
         call print_lastlines_to_stderr(6,filename)
      endif
      call boinc_finish(errout_status) !This call does not return
+ei !END +if boinc
+if .not.boinc
      if(errout_status.ne.0) then
         close(93)
         call print_lastlines_to_stderr(93,"fort.93")
         call print_lastlines_to_stderr(6,"fort.6")

         write(error_unit,'(a,i5)') "Stopping, errout_status=",         &
     &        errout_status
         stop 1
      else
         !No error
         stop
      endif
+ei !END +if .not.boinc


!!!!!! In case of errors when copying fort.92 (lout) -> fort.6 !!!!!!!!!

    8 write(93,*)                                                       &
     &'SIXTRACR CR ABEND *** ERROR *** reading fort.92, iostat=',ierro
      close(93)
      write(6,*)                                                        &
     &'SIXTRACR CR ABEND *** ERROR *** reading fort.92, iostat=',ierro
+if debug
                   !call system('../crend   >> crlog')
+ei
+if boinc
      do i=2,120
        inquire(i,opened=fopen)
        write(6,*) 'UNIT ',i,' opened ',fopen
      enddo 
      close(6,err=31)
 31   continue
!     call boinc_zipitall()
!     call boinc_finish_graphics()
      if(errout_status.ne.0) then
         close(93)
         call boincrf('fort.93',filename)
         call print_lastlines_to_stderr(93,filename)
         
         call boincrf('fort.6',filename)
         call print_lastlines_to_stderr(6,filename)
      endif
      call boinc_finish(errout_status) !This call does not return
+ei !END +if boinc
+if .not.boinc
      if(errout_status.ne.0) then
         close(93)
         call print_lastlines_to_stderr(93,"fort.93")
         call print_lastlines_to_stderr(6,"fort.6")
         
         write(error_unit,'(a,i5)') "Stopping, errout_status=",         &
     &        errout_status
         stop 1
      else
         !No error
         stop
      endif
+ei !END +if .not.boinc
+ei !END +if cr

+if .not.cr
      !This one should probably remain as write(*,*) or use output_unit
      write(*,*)                                                        &
     &'SIXTRACK STOP/ABEND '//cstring
+if debug
                   !call system('../crend   >> crlog')
+ei
      ! No fort.6 and 93 if not CR -> don't do print_lastlines_to_stderr()
      if(errout_status.ne.0) then
         write(error_unit,'(a,i5)') "Stopping, errout_status=",         &
     &        errout_status
         stop 1
      else
         !No error
         stop
      endif
+ei !END +if .not.cr
      end subroutine abend

      subroutine print_lastlines_to_stderr(file_unit, file_name)
!     Subroutine to copy the last nlines lines from a file to stderr
!     It is mainly used just before exiting SixTrack in case there was an error.
!     This is useful since STDERR is often returned from batch systems and BOINC.
!     K.Sjobak, June 2017
      use, intrinsic :: iso_fortran_env, only : error_unit
      implicit none

+ca comgetfields
!+ca stringzerotrim
      
      integer,          intent(in) :: file_unit
      character(len=*), intent(in) :: file_name

      integer nlines
      parameter (nlines=40)
      
      character(len=1024) fileBuff (nlines)
      integer fileBuff_idx
      integer i,j
      integer printLines

      logical lopen
      integer ierro

!     Clear the buffer
      do i=1,nlines
         fileBuff(i)=''
      end do
      
!     Open the file
      inquire(unit=file_unit,opened=lopen)
      if (lopen) then
         write(error_unit,'(a,1x,i5,1x,a)')                             &
     &        "Error when opening unit #",                              &
     &        file_unit, ": The file is already open."
         return
      end if
      
      open(file_unit,file=file_name,form="formatted",                   &
     &     status="old",iostat=ierro)
      if (ierro .ne. 0) then
         write(error_unit,'(a,a,a,1x,i5,1x,a,1x,i5)')                   &
     &        "Error when opening file '",                              &
     &        trim(file_name),                                          &
     &        "' on unit #", file_unit, ", iostat =",ierro
         return
      endif
      
!     Read into fileBuff as a ring buffer.
      fileBuff_idx = 1
      j = 0
      
 1    read(file_unit,'(a1024)',end=3,err=2,iostat=ierro)                &
     &     fileBuff(fileBuff_idx)
    ! write(error_unit,*) fileBuff_idx,":",trim(fileBuff(fileBuff_idx))
      fileBuff_idx = fileBuff_idx+1
      if (fileBuff_idx.ge.nlines) fileBuff_idx = 1
      j = j+1
      goto 1
      
 2    continue                  !An error occured
      write(error_unit,'(a,1x,i5)')                                     &
     &     "An error occured while reading the file, iostat=",ierro

      
 3    continue                  !EOF or error; anyway we're done.
      close(file_unit)

!     Print stuff back out from the buffer
      if (j .lt. nlines) then
         printLines = j
         fileBuff_idx=1
      else
         printLines = nlines
      endif
      write(error_unit,'(a,1x,i5,1x,a,a,a)')                            &
     &     "******* Last",printLines,"lines of file '",                 &
     &     trim(file_name),"': *******"
      
      i = fileBuff_idx          !Position in buffer (we have already incremented i)
      j = 0                     !How many have we printed
      
 10   if (i.gt.nlines) i=1      ! i is wrapping
      write(error_unit,'(a)') trim(fileBuff(i))
      i = i+1
      j = j+1                   ! j just counts
      if (j.lt.printLines) goto 10

      write(error_unit,'(a,a,a)')                                       &
     &     "******* Done writing tail of file '",                       &
     &     trim(file_name),                                             &
     &     "' to stderr *******"
      
      end subroutine print_lastlines_to_stderr
      
+dk plotdumy
      subroutine hbook2(i1,c1,i2,r1,r2,i3,r3,r4,r5)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2,i3
      real r1,r2,r3,r4,r5
      character c1
      save
      return
      end

      subroutine hdelet(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end

      subroutine hlimit(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end

      subroutine hplax(c1,c2)
      implicit none
      integer lout
      common /crflags/lout
      character c1,c2
      save
      return
      end

      subroutine hplcap(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end

      subroutine hplend()
      implicit none
      integer lout
      common /crflags/lout
      save
      return
      end

      subroutine hplint(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end

      subroutine hplopt(c1,i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      character c1
      save
      return
      end

      subroutine hplot(i1,c1,c2,i2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2
      character c1,c2
      save
      return
      end

      subroutine hplset(c1,r1)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      real r1
      character c1
      save
      return
      end

      subroutine hplsiz(r1,r2,c1)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      real r1,r2
      character c1
      save
      return
      end

      subroutine hplsof(r1,r2,c1,r3,r4,r5,i1)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1,r2,r3,r4,r5
      character c1
      save
      return
      end

      subroutine htitle(c1)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      character c1
      save
      return
      end

      subroutine ipl(i1,r1,r2)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1(*),r2(*)
      save
      return
      end

      subroutine ipm(i1,r1,r2)
      use floatPrecision
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      real r1,r2
      save
      return
      end

      subroutine iselnt(i1)
      implicit none
      integer lout
      common /crflags/lout
      integer i1
      save
      return
      end

      subroutine igmeta(i1,i2)
      implicit none
      integer lout
      common /crflags/lout
      integer i1,i2
      save
      return
      end

+dk nagdumy
      subroutine e04ucf(n,nclin,ncnln,lda,ldcj,ldr,a,bl,bu,
     +confun,objfun,iter,ierroe,c,cjac,clamda,
     +objf,objgrd,r,x,iwork,liwork,work,lwork,
     +iuser,user,ifail)
      use floatPrecision
      implicit none
      integer n,nclin,ncnln,lda,ldcj,ldr,iter,ierroe,
     +istate(n+nclin+ncnln),liwork,iwork(liwork),lwork,
     +iuser(*),ifail
      real a(lda,*),bl(n+nclin+ncnln),bu(n+nclin+ncnln),
     +c(*),cjac(ldcj,*),clamda(n+nclin+ncnln),objf,
     +objgrd(n),r(ldr,n),x(n),work(lwork),user(*)
      external confun,objfun
      save
      return
      end

      subroutine e04uef(c1)
      implicit none
      character c1
      save
      return
      end

      subroutine e04udm(c1)
      implicit none
      character c1
      save
      return
      end

      subroutine x04abf(n1,n2)
      implicit none
      integer n1,n2
      save
      return
      end

+dk dumps
+if debug
!DUMPS
      subroutine warr(vname,value,i,j,k,l)
      use floatPrecision
      implicit none
      character(len=*) vname
      real(kind=fPrec) value
      integer i,j,k,l
      integer ierro
      character(len=16) myname
      myname=vname
      write(100) myname,value,i,j,k,l
      endfile (100,iostat=ierro)
      backspace (100,iostat=ierro)
      return
      end
      subroutine dumpbl1(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
      integer n,i
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,100) 'bl1 ',bl1
      write(99,100) 'bl2 ',bl2
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
 100  format (a10,(Z20))
      end
      subroutine dumpzfz(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
      integer n,i
      integer j
      character(len=*) dumpname
      character(len=10) mydump,myzfz
      save
      mydump=dumpname
      myzfz='zfz'
      write(101) mydump,n,i
      write(101) myzfz
      do j=1,nzfz
        write(101) zfz(j) 
      enddo
      endfile (101,iostat=ierro)
      backspace (101,iostat=ierro)
      end
      subroutine dumpxy(dumpname,n,i,k)
      use floatPrecision
      implicit none
+ca parpro
+ca common
+ca commonmn
+ca commontr
      integer n,i,j,k
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*)                                                       &
     &(xv(1,j),j=1,k),                                                  &
     &(xv(2,j),j=1,k),                                                  &
     &(yv(1,j),j=1,k),                                                  &
     &(yv(2,j),j=1,k),                                                  &
     &(sigmv(j),j=1,k),                                                 &
     &(ejv(j),j=1,k),                                                   &
     &(ejfv(j),j=1,k),                                                  &
     &(rvv(j),j=1,k),                                                   &
     &(dpsv(j),j=1,k),                                                  &
     &(dpsv1(j),j=1,k),                                                 &
     &(oidpsv(j),j=1,k)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
+if bnlelens
!GRDRHIC
!GRD-042008
      subroutine dumpbnl(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+if bnlelens
+ca rhicelens
+ei
      integer n,i,j
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*)                                                       &
     &n_cut,                                                            &
     &n_nocut,                                                          &
     &sumsquarex,                                                       &
     &sumsquarey,                                                       &
     &sumtwojx,                                                         &
     &sumtwojy,                                                         &
     &limit_twojx,limit_twojy,limit_twojr,                              &
     &totals,                                                           &
     &(namepart(j),j=1,napx)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
!GRDRHIC
!GRD-042008
+ei
      subroutine dumpsynu(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
+ca commons
+ca commonmn
      integer n,i,j,l,m,k
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
      write(99,*) (aek(j),j=1,napxo)
      write(99,*) (afok(j),j=1,napxo)
      write(99,*) (as3(j),j=1,napxo)
      write(99,*) (as4(j),j=1,napxo)
      write(99,*) (as6(j),j=1,napxo)
      write(99,*) (co(j),j=1,napxo)
      write(99,*) (dpd(j),j=1,napxo)
      write(99,*) (dpsq(j),j=1,napxo)
      write(99,*) (fi(j),j=1,napxo)
      write(99,*) (fok(j),j=1,napxo)
      write(99,*) (fok1(j),j=1,napxo)
      write(99,*) (fokqv(j),j=1,napxo)
      write(99,*) (g(j),j=1,napxo)
      write(99,*) (gl(j),j=1,napxo)
      write(99,*) (hc(j),j=1,napxo)
      write(99,*) (hi(j),j=1,napxo)
      write(99,*) (hi1(j),j=1,napxo)
      write(99,*) (hm(j),j=1,napxo)
      write(99,*) (hp(j),j=1,napxo)
      write(99,*) (hs(j),j=1,napxo)
      write(99,*) (rho(j),j=1,napxo)
      write(99,*) (rhoc(j),j=1,napxo)
      write(99,*) (rhoi(j),j=1,napxo)
      write(99,*) (si(j),j=1,napxo)
      write(99,*) (siq(j),j=1,napxo)
      write(99,*) (sm1(j),j=1,napxo)
      write(99,*) (sm12(j),j=1,napxo)
      write(99,*) (sm2(j),j=1,napxo)
      write(99,*) (sm23(j),j=1,napxo)
      write(99,*) (sm3(j),j=1,napxo)
      write(99,*) (wf(j),j=1,napxo)
      write(99,*) (wfa(j),j=1,napxo)
      write(99,*) (wfhi(j),j=1,napxo)
      write(99,*)                                                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
      write(99,*)                                                       &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end

      subroutine dump(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
!     my cr variables
      write(99,*) 'time0 ',time0
      write(99,*) 'time1 ',time1
      write(99,*) 'sixrecs ',sixrecs
      write(99,*) 'binrec ',binrec
      write(99,*) 'binrecs ',binrecs
      write(99,*) 'numlcr ',numlcr
      write(99,*) 'rerun ',rerun
      write(99,*) 'restart ',restart
      write(99,*) 'checkp ',checkp
      write(99,*) 'fort95 ',fort95
      write(99,*) 'fort96 ',fort96
      write(99,*) 'arecord ',arecord
      write(99,*) 'stxt ',stxt
      write(99,*) 'runtim ',runtim
!     mycrio variables
      write(99,*) 'crnumlcr',crnumlcr
      write(99,*) 'crnuml',crnuml
      write(99,*) 'crsixrecs',crsixrecs
      write(99,*) 'crbinrec',crbinrec
      write(99,*) 'crbinrecs',crbinrecs
      write(99,*) 'crsythck',crsythck
      write(99,*) 'crtime3',crtime3
      write(99,*) 'crnapxo',crnapxo
      write(99,*) 'crnapx',crnapx
      write(99,*) 'cre0',cre0
      write(99,*) 'crnumxv(npart)',crnumxv
      write(99,*) 'crnnumxv(npart)',crnnumxv
      write(99,*) 'crnlostp(npart)',crnlostp
      write(99,*) 'crpstop(npart)',crpstop
      write(99,*) 'crxv',crxv
      write(99,*) 'cryv',cryv
      write(99,*) 'crsigmv',crsigmv
      write(99,*) 'crdpsv',crdpsv
      write(99,*) 'crdpsv1',crdpsv1
      write(99,*) 'crejv',crejv
      write(99,*) 'crejfv',crejfv
!     some tracking stuff
      write(99,*) 'nwri',nwri
      write(99,*) 'ktrack',ktrack
      write(99,*) 'strack',strack
      write(99,*) 'strackc',strackc
      write(99,*) 'stracks',stracks
      write(99,*) 'dpsv1',dpsv1
!
      write(99,*) 'ierro ',ierro
      write(99,*) 'erbez ',erbez
      write(99,*) 'pi ',pi
      write(99,*) 'pi2 ',pi2
      write(99,*) 'pisqrt ',pisqrt
      write(99,*) 'rad ',rad
      write(99,*) 'il ',il
      write(99,*) 'mper ',mper
      write(99,*) 'mblo ',mblo
      write(99,*) 'mbloz ',mbloz
      write(99,*) 'msym ',msym
      write(99,*) 'kanf ',kanf
      write(99,*) 'iu ',iu
      write(99,*) 'ic ',ic
      write(99,*) 'ed ',ed
      write(99,*) 'el ',el
      write(99,*) 'ek ',ek
      write(99,*) 'sm ',sm
      write(99,*) 'kz ',kz
      write(99,*) 'kp ',kp
      write(99,*) 'xpl ',xpl
      write(99,*) 'xrms ',xrms
      write(99,*) 'zpl ',zpl
      write(99,*) 'zrms ',zrms
      write(99,*) 'mel ',mel
      write(99,*) 'mtyp ',mtyp
      write(99,*) 'mstr ',mstr
      write(99,*) 'a ',a
      write(99,*) 'bl1 ',bl1
      write(99,*) 'bl2 ',bl2
      write(99,*) 'rvf ',rvf
      write(99,*) 'idfor ',idfor
      write(99,*) 'napx ',napx
      write(99,*) 'napxo ',napxo
      write(99,*) 'numlr ',numlr
      write(99,*) 'nde ',nde
      write(99,*) 'nwr ',nwr
      write(99,*) 'ird ',ird
      write(99,*) 'imc ',imc
      write(99,*) 'irew ',irew
      write(99,*) 'ntwin ',ntwin
      write(99,*) 'iclo6 ',iclo6
      write(99,*) 'iclo6r ',iclo6r
      write(99,*) 'iver ',iver
      write(99,*) 'ibidu ',ibidu
      write(99,*) 'qs ',qs
      write(99,*) 'e0 ',e0
      write(99,*) 'pma ',pma
      write(99,*) 'ej ',ej
      write(99,*) 'ejf ',ejf
      write(99,*) 'phas0 ',phas0
      write(99,*) 'phas ',phas
      write(99,*) 'hsy ',hsy
      write(99,*) 'crad ',crad
      write(99,*) 'hsyc ',hsyc
      write(99,*) 'phasc ',phasc
      write(99,*) 'dppoff ',dppoff
      write(99,*) 'sigmoff ',sigmoff
      write(99,*) 'tlen ',tlen
      write(99,*) 'iicav ',iicav
      write(99,*) 'itionc ',itionc
      write(99,*) 'ition ',ition
      write(99,*) 'idp ',idp
      write(99,*) 'ncy ',ncy
      write(99,*) 'ixcav ',ixcav
      write(99,*) 'dpscor ',dpscor
      write(99,*) 'sigcor ',sigcor
      write(99,*) 'icode ',icode
      write(99,*) 'idam ',idam
      write(99,*) 'its6d ',its6d
      write(99,*) 'bk0 ',bk0
      write(99,*) 'ak0 ',ak0
      write(99,*) 'bka ',bka
      write(99,*) 'aka ',aka
      write(99,*) 'benki ',benki
      write(99,*) 'benkc ',benkc
      write(99,*) 'r00 ',r00
      write(99,*) 'irm ',irm
      write(99,*) 'nmu ',nmu
      write(99,*) 'zfz ',zfz
      write(99,*) 'iorg ',iorg
      write(99,*) 'mzu ',mzu
      write(99,*) 'bezr ',bezr
      write(99,*) 'izu0 ',izu0
      write(99,*) 'mmac ',mmac
      write(99,*) 'mcut ',mcut
      write(99,*) 'exterr ',exterr
      write(99,*) 'extalign ',extalign
      write(99,*) 'tiltc ',tiltc
      write(99,*) 'tilts ',tilts
      write(99,*) 'mout2 ',mout2
      write(99,*) 'icext ',icext
      write(99,*) 'icextal ',icextal
      write(99,*) 'aper ',aper
      write(99,*) 'di0 ',di0
      write(99,*) 'dip0 ',dip0
      write(99,*) 'ta ',ta
      write(99,*) 'dma ',dma
      write(99,*) 'dmap ',dmap
      write(99,*) 'dkq ',dkq
      write(99,*) 'dqq ',dqq
      write(99,*) 'de0 ',de0
      write(99,*) 'ded ',ded
      write(99,*) 'dsi ',dsi
      write(99,*) 'dech ',dech
      write(99,*) 'dsm0 ',dsm0
      write(99,*) 'itco ',itco
      write(99,*) 'itcro ',itcro
      write(99,*) 'itqv ',itqv
      write(99,*) 'iout ',iout
      write(99,*) 'qw0 ',qw0
      write(99,*) 'iq ',iq
      write(99,*) 'iqmod ',iqmod
      write(99,*) 'kpa ',kpa
      write(99,*) 'iqmod6 ',iqmod6
      write(99,*) 'bez ',bez
      write(99,*) 'elbe ',elbe
      write(99,*) 'bezb ',bezb
      write(99,*) 'ilin ',ilin
      write(99,*) 'nt ',nt
      write(99,*) 'iprint ',iprint
      write(99,*) 'ntco ',ntco
      write(99,*) 'eui ',eui
      write(99,*) 'euii ',euii
      write(99,*) 'nlin ',nlin
      write(99,*) 'bezl ',bezl
      write(99,*) 'betam ',betam
      write(99,*) 'pam ',pam
      write(99,*) 'betac ',betac
      write(99,*) 'pac ',pac
      write(99,*) 'bclorb ',bclorb
      write(99,*) 'nhmoni ',nhmoni
      write(99,*) 'nhcorr ',nhcorr
      write(99,*) 'nvmoni ',nvmoni
      write(99,*) 'nvcorr ',nvcorr
      write(99,*) 'ncororb ',ncororb
      write(99,*) 'apx ',apx
      write(99,*) 'apz ',apz
      write(99,*) 'sigma0 ',sigma0
      write(99,*) 'iclo ',iclo
      write(99,*) 'ncorru ',ncorru
      write(99,*) 'ncorrep ',ncorrep
      write(99,*) 'icomb0 ',icomb0
      write(99,*) 'icomb ',icomb
      write(99,*) 'ratio ',ratio
      write(99,*) 'ratioe ',ratioe
      write(99,*) 'iratioe ',iratioe
      write(99,*) 'icoe ',icoe
      write(99,*) 'ise ',ise
      write(99,*) 'mesa ',mesa
      write(99,*) 'mp ',mp
      write(99,*) 'm21 ',m21
      write(99,*) 'm22 ',m22
      write(99,*) 'm23 ',m23
      write(99,*) 'ise1 ',ise1
      write(99,*) 'ise2 ',ise2
      write(99,*) 'ise3 ',ise3
      write(99,*) 'isea ',isea
      write(99,*) 'qxt ',qxt
      write(99,*) 'qzt ',qzt
      write(99,*) 'tam1 ',tam1
      write(99,*) 'tam2 ',tam2
      write(99,*) 'isub ',isub
      write(99,*) 'nta ',nta
      write(99,*) 'nte ',nte
      write(99,*) 'ipt ',ipt
      write(99,*) 'totl ',totl
      write(99,*) 'rtc ',rtc
      write(99,*) 'rts ',rts
      write(99,*) 'ire ',ire
      write(99,*) 'ipr ',ipr
      write(99,*) 'irmod2 ',irmod2
      write(99,*) 'dtr ',dtr
      write(99,*) 'nre ',nre
      write(99,*) 'nur ',nur
      write(99,*) 'nch ',nch
      write(99,*) 'nqc ',nqc
      write(99,*) 'npp ',npp
      write(99,*) 'nrr ',nrr
      write(99,*) 'nu ',nu
      write(99,*) 'dphix ',dphix
      write(99,*) 'dphiz ',dphiz
      write(99,*) 'qx0 ',qx0
      write(99,*) 'qz0 ',qz0
      write(99,*) 'dres ',dres
      write(99,*) 'dfft ',dfft
      write(99,*) 'cma1 ',cma1
      write(99,*) 'cma2 ',cma2
      write(99,*) 'nstart ',nstart
      write(99,*) 'nstop ',nstop
      write(99,*) 'iskip ',iskip
      write(99,*) 'iconv ',iconv
      write(99,*) 'imad ',imad
      write(99,*) 'ipos ',ipos
      write(99,*) 'iav ',iav
      write(99,*) 'iwg ',iwg
      write(99,*) 'ivox ',ivox
      write(99,*) 'ivoz ',ivoz
      write(99,*) 'ires ',ires
      write(99,*) 'ifh ',ifh
      write(99,*) 'toptit ',toptit
      write(99,*) 'kwtype ',kwtype
      write(99,*) 'itf ',itf
      write(99,*) 'icr ',icr
      write(99,*) 'idis ',idis
      write(99,*) 'icow ',icow
      write(99,*) 'istw ',istw
      write(99,*) 'iffw ',iffw
      write(99,*) 'nprint ',nprint
      write(99,*) 'ndafi ',ndafi
      write(99,*) 'qwsk ',qwsk
      write(99,*) 'betx ',betx
      write(99,*) 'betz ',betz
      write(99,*) 'alfx ',alfx
      write(99,*) 'alfz ',alfz
      write(99,*) 'iskew ',iskew
      write(99,*) 'nskew ',nskew
      write(99,*) 'hmal ',hmal
      write(99,*) 'sixtit ',sixtit
      write(99,*) 'commen ',commen
      write(99,*) 'ithick ',ithick
      write(99,*) 'clo6 ',clo6
      write(99,*) 'clop6 ',clop6
      write(99,*) 'dki ',dki
      write(99,*) 'sigman ',sigman
      write(99,*) 'sigman2 ',sigman2
      write(99,*) 'sigmanq ',sigmanq
      write(99,*) 'clobeam ',clobeam
      write(99,*) 'beamoff ',beamoff
      write(99,*) 'parbe ',parbe
      write(99,*) 'track6d ',track6d
      write(99,*) 'ptnfac ',ptnfac
      write(99,*) 'sigz ',sigz
      write(99,*) 'sige ',sige
      write(99,*) 'partnum ',partnum
      write(99,*) 'parbe14 ',parbe14
      write(99,*) 'emitx ',emitx
      write(99,*) 'emity ',emity
      write(99,*) 'emitz ',emitz
      write(99,*) 'gammar ',gammar
      write(99,*) 'nbeam ',nbeam
      write(99,*) 'ibbc ',ibbc
      write(99,*) 'ibeco ',ibeco
      write(99,*) 'ibtyp ',ibtyp
      write(99,*) 'lhc ',lhc
      write(99,*) 'cotr ',cotr
      write(99,*) 'rrtr ',rrtr
      write(99,*) 'imtr ',imtr
      write(99,*) 'bbcu ',bbcu
      write(99,*) 'ibb6d ',ibb6d
      write(99,*) 'imbb ',imbb
      write(99,*) 'as ',as
      write(99,*) 'al ',al
      write(99,*) 'sigm ',sigm
      write(99,*) 'dps ',dps
      write(99,*) 'idz ',idz
      write(99,*) 'dp1 ',dp1
      write(99,*) 'itra ',itra
      write(99,*) 'x ',x
      write(99,*) 'y ',y
      write(99,*) 'bet0 ',bet0
      write(99,*) 'alf0 ',alf0
      write(99,*) 'clo ',clo
      write(99,*) 'clop ',clop
      write(99,*) 'cro ',cro
      write(99,*) 'is ',is
      write(99,*) 'ichrom ',ichrom
      write(99,*) 'nnumxv ',nnumxv
      write(99,*) 'xsi ',xsi
      write(99,*) 'zsi ',zsi
      write(99,*) 'smi ',smi
      write(99,*) 'aai ',aai
      write(99,*) 'bbi ',bbi
      write(99,*) 'ampt ',ampt
      write(99,*) 'tlim ',tlim
      write(99,*) 'tasm ',tasm
      write(99,*) 'preda ',preda
      write(99,*) 'idial ',idial
      write(99,*) 'nord ',nord
      write(99,*) 'nvar ',nvar
      write(99,*) 'nvar2 ',nvar2
      write(99,*) 'nsix ',nsix
      write(99,*) 'ncor ',ncor
      write(99,*) 'ipar ',ipar
      write(99,*) 'nordf ',nordf
      write(99,*) 'nvarf ',nvarf
      write(99,*) 'nord1 ',nord1
      write(99,*) 'ndimf ',ndimf
      write(99,*) 'idptr ',idptr
      write(99,*) 'inorm ',inorm
      write(99,*) 'imod1 ',imod1
      write(99,*) 'imod2 ',imod2
      write(99,*) 'icorr ',icorr
      write(99,*) 'nctype ',nctype
      write(99,*) 'namp ',namp
      write(99,*) 'nmom ',nmom
      write(99,*) 'nmom1 ',nmom1
      write(99,*) 'nmom2 ',nmom2
      write(99,*) 'weig1 ',weig1
      write(99,*) 'weig2 ',weig2
      write(99,*) 'dpmax ',dpmax
      write(99,*) 'coel ',coel
      write(99,*) 'ekv ',ekv
      write(99,*) 'fokqv ',fokqv
      write(99,*) 'aaiv ',aaiv
      write(99,*) 'bbiv ',bbiv
      write(99,*) 'smiv ',smiv
      write(99,*) 'zsiv ',zsiv
      write(99,*) 'xsiv ',xsiv
      write(99,*) 'xsv ',xsv
      write(99,*) 'zsv ',zsv
      write(99,*) 'qw ',qw
      write(99,*) 'qwc ',qwc
      write(99,*) 'clo0 ',clo0
      write(99,*) 'clop0 ',clop0
      write(99,*) 'eps ',eps
      write(99,*) 'epsa ',epsa
      write(99,*) 'ekk ',ekk
      write(99,*) 'cr ',cr
      write(99,*) 'ci ',ci
      write(99,*) 'xv ',xv
      write(99,*) 'yv ',yv
      write(99,*) 'dam ',dam
      write(99,*) 'ekkv ',ekkv
      write(99,*) 'sigmv ',sigmv
      write(99,*) 'dpsv ',dpsv
      write(99,*) 'dp0v ',dp0v
      write(99,*) 'sigmv6 ',sigmv6
      write(99,*) 'dpsv6 ',dpsv6
      write(99,*) 'ejv ',ejv
      write(99,*) 'ejfv ',ejfv
      write(99,*) 'xlv ',xlv
      write(99,*) 'zlv ',zlv
      write(99,*) 'pstop ',pstop
      write(99,*) 'rvv ',rvv
      write(99,*) 'ejf0v ',ejf0v
      write(99,*) 'numxv ',numxv
      write(99,*) 'nms ',nms
      write(99,*) 'nlostp ',nlostp
      write(99,*) 'dpd ',dpd
      write(99,*) 'dpsq ',dpsq
      write(99,*) 'fok ',fok
      write(99,*) 'rho ',rho
      write(99,*) 'fok1 ',fok1
      write(99,*) 'si ',si
      write(99,*) 'co ',co
      write(99,*) 'g ',g
      write(99,*) 'gl ',gl
      write(99,*) 'sm1 ',sm1
      write(99,*) 'sm2 ',sm2
      write(99,*) 'sm3 ',sm3
      write(99,*) 'sm12 ',sm12
      write(99,*) 'as3 ',as3
      write(99,*) 'as4 ',as4
      write(99,*) 'as6 ',as6
      write(99,*) 'sm23 ',sm23
      write(99,*) 'rhoc ',rhoc
      write(99,*) 'siq ',siq
      write(99,*) 'aek ',aek
      write(99,*) 'afok ',afok
      write(99,*) 'hp ',hp
      write(99,*) 'hm ',hm
      write(99,*) 'hc ',hc
      write(99,*) 'hs ',hs
      write(99,*) 'wf ',wf
      write(99,*) 'wfa ',wfa
      write(99,*) 'wfhi ',wfhi
      write(99,*) 'rhoi ',rhoi
      write(99,*) 'hi ',hi
      write(99,*) 'fi ',fi
      write(99,*) 'hi1 ',hi1
      write(99,*) 'xvl ',xvl
      write(99,*) 'yvl ',yvl
      write(99,*) 'ejvl ',ejvl
      write(99,*) 'dpsvl ',dpsvl
      write(99,*) 'oidpsv ',oidpsv
      write(99,*) 'sigmvl ',sigmvl
      write(99,*) 'iv ',iv
      write(99,*) 'aperv ',aperv
      write(99,*) 'ixv ',ixv
      write(99,*) 'clov ',clov
      write(99,*) 'clopv ',clopv
      write(99,*) 'alf0v ',alf0v
      write(99,*) 'bet0v ',bet0v
      write(99,*) 'ampv ',ampv
      write(99,*) 'clo6v ',clo6v
      write(99,*) 'clop6v ',clop6v
      write(99,*) 'hv ',hv
      write(99,*) 'bl1v ',bl1v
      write(99,*) 'tas ',tas
      write(99,*) 'qwcs ',qwcs
      write(99,*) 'di0xs ',di0xs
      write(99,*) 'di0zs ',di0zs
      write(99,*) 'dip0xs ',dip0xs
      write(99,*) 'dip0zs ',dip0zs
      write(99,*) 'xau ',xau
      write(99,*) 'cloau ',cloau
      write(99,*) 'di0au ',di0au
      write(99,*) 'tau ',tau
      write(99,*) 'tasau ',tasau
      write(99,*) 'wx ',wx
      write(99,*) 'x1 ',x1
      write(99,*) 'x2 ',x2
      write(99,*) 'fake ',fake
      
      write(99,*) 'e0f ',e0f
      write(99,*) 'numx ',numx
      write(99,*) 'cotr ',cotr
      write(99,*) 'rrtr ',rrtr
      write(99,*) 'imtr ',imtr
!     these other values???
      write(99,*) 'numl ',numl
      write(99,*) 'niu ',niu
      write(99,*) 'amp0 ',amp0
      write(99,*) 'amp ',amp
      write(99,*) 'damp ',damp
      write(99,*) 'chi0 ',chi0
      write(99,*) 'chid ',chid
      write(99,*) 'rat ',rat
      write(99,*) 'exz ',exz
      write(99,*) 'time0 ',time0
      write(99,*) 'time1 ',time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
      subroutine dumpbin(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character(len=*) dumpname
      character(len=10) mydump
      save
      mydump=dumpname
      write(99) mydump
      write(99) n
      write(99) i
!     my cr variables
      write(99) time0
      write(99) time1
      write(99) sixrecs
      write(99) binrec
      write(99) binrecs
      write(99) numlcr
      write(99) rerun
      write(99) restart
      write(99) checkp
      write(99) fort95
      write(99) fort96
      write(99) arecord
      write(99) stxt
      write(99) runtim
!     mycrio variables
      write(99) crnumlcr
      write(99) crnuml
      write(99) crsixrecs
      write(99) crbinrec
      write(99) crbinrecs
      write(99) crsythck
      write(99) crtime3
      write(99) crnapxo
      write(99) crnapx
      write(99) cre0
      write(99) crnumxv
      write(99) crnnumxv
      write(99) crnlostp
      write(99) crpstop
      write(99) crxv
      write(99) cryv
      write(99) crsigmv
      write(99) crdpsv
      write(99) crdpsv1
      write(99) crejv
      write(99) crejfv
!     some tracking stuff
      write(99) nwri
      write(99) ktrack
      write(99) strack
      write(99) strackc
      write(99) stracks
      write(99) dpsv1
!
      write(99) ierro
      write(99) erbez
      write(99) pi
      write(99) pi2
      write(99) pisqrt
      write(99) rad
      write(99) il
      write(99) mper
      write(99) mblo
      write(99) mbloz
      write(99) msym
      write(99) kanf
      write(99) iu
      write(99) ic
      write(99) ed
      write(99) el
      write(99) ek
      write(99) sm
      write(99) kz
      write(99) kp
      write(99) xpl
      write(99) xrms
      write(99) zpl
      write(99) zrms
      write(99) mel
      write(99) mtyp
      write(99) mstr
      write(99) a
      write(99) bl1
      write(99) bl2
      write(99) rvf
      write(99) idfor
      write(99) napx
      write(99) napxo
      write(99) numlr
      write(99) nde
      write(99) nwr
      write(99) ird
      write(99) imc
      write(99) irew
      write(99) ntwin
      write(99) iclo6
      write(99) iclo6r
      write(99) iver
      write(99) ibidu
      write(99) qs
      write(99) e0
      write(99) pma
      write(99) ej
      write(99) ejf
      write(99) phas0
      write(99) phas
      write(99) hsy
      write(99) crad
      write(99) hsyc
      write(99) phasc
      write(99) dppoff
      write(99) sigmoff
      write(99) tlen
      write(99) iicav
      write(99) itionc
      write(99) ition
      write(99) idp
      write(99) ncy
      write(99) ixcav
      write(99) dpscor
      write(99) sigcor
      write(99) icode
      write(99) idam
      write(99) its6d
      write(99) bk0
      write(99) ak0
      write(99) bka
      write(99) aka
      write(99) benki
      write(99) benkc
      write(99) r00
      write(99) irm
      write(99) nmu
      write(99) zfz
      write(99) iorg
      write(99) mzu
      write(99) bezr
      write(99) izu0
      write(99) mmac
      write(99) mcut
      write(99) exterr
      write(99) extalign
      write(99) tiltc
      write(99) tilts
      write(99) mout2
      write(99) icext
      write(99) icextal
      write(99) aper
      write(99) di0
      write(99) dip0
      write(99) ta
      write(99) dma
      write(99) dmap
      write(99) dkq
      write(99) dqq
      write(99) de0
      write(99) ded
      write(99) dsi
      write(99) dech
      write(99) dsm0
      write(99) itco
      write(99) itcro
      write(99) itqv
      write(99) iout
      write(99) qw0
      write(99) iq
      write(99) iqmod
      write(99) kpa
      write(99) iqmod6
      write(99) bez
      write(99) elbe
      write(99) bezb
      write(99) ilin
      write(99) nt
      write(99) iprint
      write(99) ntco
      write(99) eui
      write(99) euii
      write(99) nlin
      write(99) bezl
      write(99) betam
      write(99) pam
      write(99) betac
      write(99) pac
      write(99) bclorb
      write(99) nhmoni
      write(99) nhcorr
      write(99) nvmoni
      write(99) nvcorr
      write(99) ncororb
      write(99) apx
      write(99) apz
      write(99) sigma0
      write(99) iclo
      write(99) ncorru
      write(99) ncorrep
      write(99) icomb0
      write(99) icomb
      write(99) ratio
      write(99) ratioe
      write(99) iratioe
      write(99) icoe
      write(99) ise
      write(99) mesa
      write(99) mp
      write(99) m21
      write(99) m22
      write(99) m23
      write(99) ise1
      write(99) ise2
      write(99) ise3
      write(99) isea
      write(99) qxt
      write(99) qzt
      write(99) tam1
      write(99) tam2
      write(99) isub
      write(99) nta
      write(99) nte
      write(99) ipt
      write(99) totl
      write(99) rtc
      write(99) rts
      write(99) ire
      write(99) ipr
      write(99) irmod2
      write(99) dtr
      write(99) nre
      write(99) nur
      write(99) nch
      write(99) nqc
      write(99) npp
      write(99) nrr
      write(99) nu
      write(99) dphix
      write(99) dphiz
      write(99) qx0
      write(99) qz0
      write(99) dres
      write(99) dfft
      write(99) cma1
      write(99) cma2
      write(99) nstart
      write(99) nstop
      write(99) iskip
      write(99) iconv
      write(99) imad
      write(99) ipos
      write(99) iav
      write(99) iwg
      write(99) ivox
      write(99) ivoz
      write(99) ires
      write(99) ifh
      write(99) toptit
      write(99) kwtype
      write(99) itf
      write(99) icr
      write(99) idis
      write(99) icow
      write(99) istw
      write(99) iffw
      write(99) nprint
      write(99) ndafi
      write(99) qwsk
      write(99) betx
      write(99) betz
      write(99) alfx
      write(99) alfz
      write(99) iskew
      write(99) nskew
      write(99) hmal
      write(99) sixtit
      write(99) commen
      write(99) ithick
      write(99) clo6
      write(99) clop6
      write(99) dki
      write(99) sigman
      write(99) sigman2
      write(99) sigmanq
      write(99) clobeam
      write(99) beamoff
      write(99) parbe
      write(99) track6d
      write(99) ptnfac
      write(99) sigz
      write(99) sige
      write(99) partnum
      write(99) parbe14
      write(99) emitx
      write(99) emity
      write(99) emitz
      write(99) gammar
      write(99) nbeam
      write(99) ibbc
      write(99) ibeco
      write(99) ibtyp
      write(99) lhc
      write(99) cotr
      write(99) rrtr
      write(99) imtr
      write(99) bbcu
      write(99) ibb6d
      write(99) imbb
      write(99) as
      write(99) al
      write(99) sigm
      write(99) dps
      write(99) idz
      write(99) dp1
      write(99) itra
      write(99) x
      write(99) y
      write(99) bet0
      write(99) alf0
      write(99) clo
      write(99) clop
      write(99) cro
      write(99) is
      write(99) ichrom
      write(99) nnumxv
      write(99) xsi
      write(99) zsi
      write(99) smi
      write(99) aai
      write(99) bbi
      write(99) ampt
      write(99) tlim
      write(99) tasm
      write(99) preda
      write(99) idial
      write(99) nord
      write(99) nvar
      write(99) nvar2
      write(99) nsix
      write(99) ncor
      write(99) ipar
      write(99) nordf
      write(99) nvarf
      write(99) nord1
      write(99) ndimf
      write(99) idptr
      write(99) inorm
      write(99) imod1
      write(99) imod2
      write(99) icorr
      write(99) nctype
      write(99) namp
      write(99) nmom
      write(99) nmom1
      write(99) nmom2
      write(99) weig1
      write(99) weig2
      write(99) dpmax
      write(99) coel
      write(99) ekv
      write(99) fokqv
      write(99) aaiv
      write(99) bbiv
      write(99) smiv
      write(99) zsiv
      write(99) xsiv
      write(99) xsv
      write(99) zsv
      write(99) qw
      write(99) qwc
      write(99) clo0
      write(99) clop0
      write(99) eps
      write(99) epsa
      write(99) ekk
      write(99) cr
      write(99) ci
      write(99) xv
      write(99) yv
      write(99) dam
      write(99) ekkv
      write(99) sigmv
      write(99) dpsv
      write(99) dp0v
      write(99) sigmv6
      write(99) dpsv6
      write(99) ejv
      write(99) ejfv
      write(99) xlv
      write(99) zlv
      write(99) pstop
      write(99) rvv
      write(99) ejf0v
      write(99) numxv
      write(99) nms
      write(99) nlostp
      write(99) dpd
      write(99) dpsq
      write(99) fok
      write(99) rho
      write(99) fok1
      write(99) si
      write(99) co
      write(99) g
      write(99) gl
      write(99) sm1
      write(99) sm2
      write(99) sm3
      write(99) sm12
      write(99) as3
      write(99) as4
      write(99) as6
      write(99) sm23
      write(99) rhoc
      write(99) siq
      write(99) aek
      write(99) afok
      write(99) hp
      write(99) hm
      write(99) hc
      write(99) hs
      write(99) wf
      write(99) wfa
      write(99) wfhi
      write(99) rhoi
      write(99) hi
      write(99) fi
      write(99) hi1
      write(99) xvl
      write(99) yvl
      write(99) ejvl
      write(99) dpsvl
      write(99) oidpsv
      write(99) sigmvl
      write(99) iv
      write(99) aperv
      write(99) ixv
      write(99) clov
      write(99) clopv
      write(99) alf0v
      write(99) bet0v
      write(99) ampv
      write(99) clo6v
      write(99) clop6v
      write(99) hv
      write(99) bl1v
      write(99) tas
      write(99) qwcs
      write(99) di0xs
      write(99) di0zs
      write(99) dip0xs
      write(99) dip0zs
      write(99) xau
      write(99) cloau
      write(99) di0au
      write(99) tau
      write(99) tasau
      write(99) wx
      write(99) x1
      write(99) x2
      write(99) fake
      write(99) e0f
      write(99) numx
      write(99) cotr
      write(99) rrtr
      write(99) imtr
!     these other values???
      write(99) numl
      write(99) niu
      write(99) amp0
      write(99) amp
      write(99) damp
      write(99) chi0
      write(99) chid
      write(99) rat
      write(99) exz
      write(99) time0
      write(99) time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
      end
      subroutine dumphex(dumpname,n,i)
      use floatPrecision
      implicit none
+ca parpro
+ca common
+ca common2
+ca commons
+ca commont1
+ca commondl
+ca commonxz
+ca commonta
+ca commonmn
+ca commonm1
+ca commontr
+ca crco
      integer n,i
      character(len=*) dumpname
      save
      write(99,*) dumpname,'   Turn ',n,' Element ',i
!     my cr variables
      write(99,100) 'time0 ',time0
      write(99,100) 'time1 ',time1
      write(99,100) 'sixrecs ',sixrecs
      write(99,100) 'binrec ',binrec
      write(99,100) 'binrecs ',binrecs
      write(99,100) 'numlcr ',numlcr
      write(99,100) 'rerun ',rerun
      write(99,100) 'restart ',restart
      write(99,100) 'checkp ',checkp
      write(99,100) 'fort95 ',fort95
      write(99,100) 'fort96 ',fort96
      write(99,100) 'arecord ',arecord
      write(99,100) 'stxt ',stxt
      write(99,100) 'runtim ',runtim
!     mycrio variables
      write(99,100) 'crnumlcr',crnumlcr
      write(99,100) 'crnuml',crnuml
      write(99,100) 'crsixrecs',crsixrecs
      write(99,100) 'crbinrec',crbinrec
      write(99,100) 'crbinrecs',crbinrecs
      write(99,100) 'crsythck',crsythck
      write(99,100) 'crtime3',crtime3
      write(99,100) 'crnapxo',crnapxo
      write(99,100) 'crnapx',crnapx
      write(99,100) 'cre0',cre0
      write(99,100) 'crnumxv(npart)',crnumxv
      write(99,100) 'crnnumxv(npart)',crnnumxv
      write(99,100) 'crnlostp(npart)',crnlostp
      write(99,100) 'crpstop(npart)',crpstop
      write(99,100) 'crxv',crxv
      write(99,100) 'cryv',cryv
      write(99,100) 'crsigmv',crsigmv
      write(99,100) 'crdpsv',crdpsv
      write(99,100) 'crdpsv1',crdpsv1
      write(99,100) 'crejv',crejv
      write(99,100) 'crejfv',crejfv
!     some tracking stuff
      write(99,100) 'nwri',nwri
      write(99,100) 'ktrack',ktrack
      write(99,100) 'strack',strack
      write(99,100) 'strackc',strackc
      write(99,100) 'stracks',stracks
      write(99,100) 'dpsv1',dpsv1
!
      write(99,100) 'ierro ',ierro
      write(99,100) 'erbez ',erbez
      write(99,100) 'pi ',pi
      write(99,100) 'pi2 ',pi2
      write(99,100) 'pisqrt ',pisqrt
      write(99,100) 'rad ',rad
      write(99,100) 'il ',il
      write(99,100) 'mper ',mper
      write(99,100) 'mblo ',mblo
      write(99,100) 'mbloz ',mbloz
      write(99,100) 'msym ',msym
      write(99,100) 'kanf ',kanf
      write(99,100) 'iu ',iu
      write(99,100) 'ic ',ic
      write(99,100) 'ed ',ed
      write(99,100) 'el ',el
      write(99,100) 'ek ',ek
      write(99,100) 'sm ',sm
      write(99,100) 'kz ',kz
      write(99,100) 'kp ',kp
      write(99,100) 'xpl ',xpl
      write(99,100) 'xrms ',xrms
      write(99,100) 'zpl ',zpl
      write(99,100) 'zrms ',zrms
      write(99,100) 'mel ',mel
      write(99,100) 'mtyp ',mtyp
      write(99,100) 'mstr ',mstr
      write(99,100) 'a ',a
      write(99,100) 'bl1 ',bl1
      write(99,100) 'bl2 ',bl2
      write(99,100) 'rvf ',rvf
      write(99,100) 'idfor ',idfor
      write(99,100) 'napx ',napx
      write(99,100) 'napxo ',napxo
      write(99,100) 'numlr ',numlr
      write(99,100) 'nde ',nde
      write(99,100) 'nwr ',nwr
      write(99,100) 'ird ',ird
      write(99,100) 'imc ',imc
      write(99,100) 'irew ',irew
      write(99,100) 'ntwin ',ntwin
      write(99,100) 'iclo6 ',iclo6
      write(99,100) 'iclo6r ',iclo6r
      write(99,100) 'iver ',iver
      write(99,100) 'ibidu ',ibidu
      write(99,100) 'qs ',qs
      write(99,100) 'e0 ',e0
      write(99,100) 'pma ',pma
      write(99,100) 'ej ',ej
      write(99,100) 'ejf ',ejf
      write(99,100) 'phas0 ',phas0
      write(99,100) 'phas ',phas
      write(99,100) 'hsy ',hsy
      write(99,100) 'crad ',crad
      write(99,100) 'hsyc ',hsyc
      write(99,100) 'phasc ',phasc
      write(99,100) 'dppoff ',dppoff
      write(99,100) 'sigmoff ',sigmoff
      write(99,100) 'tlen ',tlen
      write(99,100) 'iicav ',iicav
      write(99,100) 'itionc ',itionc
      write(99,100) 'ition ',ition
      write(99,100) 'idp ',idp
      write(99,100) 'ncy ',ncy
      write(99,100) 'ixcav ',ixcav
      write(99,100) 'dpscor ',dpscor
      write(99,100) 'sigcor ',sigcor
      write(99,100) 'icode ',icode
      write(99,100) 'idam ',idam
      write(99,100) 'its6d ',its6d
      write(99,100) 'bk0 ',bk0
      write(99,100) 'ak0 ',ak0
      write(99,100) 'bka ',bka
      write(99,100) 'aka ',aka
      write(99,100) 'benki ',benki
      write(99,100) 'benkc ',benkc
      write(99,100) 'r00 ',r00
      write(99,100) 'irm ',irm
      write(99,100) 'nmu ',nmu
      write(99,100) 'zfz ',zfz
      write(99,100) 'iorg ',iorg
      write(99,100) 'mzu ',mzu
      write(99,100) 'bezr ',bezr
      write(99,100) 'izu0 ',izu0
      write(99,100) 'mmac ',mmac
      write(99,100) 'mcut ',mcut
      write(99,100) 'exterr ',exterr
      write(99,100) 'extalign ',extalign
      write(99,100) 'tiltc ',tiltc
      write(99,100) 'tilts ',tilts
      write(99,100) 'mout2 ',mout2
      write(99,100) 'icext ',icext
      write(99,100) 'icextal ',icextal
      write(99,100) 'aper ',aper
      write(99,100) 'di0 ',di0
      write(99,100) 'dip0 ',dip0
      write(99,100) 'ta ',ta
      write(99,100) 'dma ',dma
      write(99,100) 'dmap ',dmap
      write(99,100) 'dkq ',dkq
      write(99,100) 'dqq ',dqq
      write(99,100) 'de0 ',de0
      write(99,100) 'ded ',ded
      write(99,100) 'dsi ',dsi
      write(99,100) 'dech ',dech
      write(99,100) 'dsm0 ',dsm0
      write(99,100) 'itco ',itco
      write(99,100) 'itcro ',itcro
      write(99,100) 'itqv ',itqv
      write(99,100) 'iout ',iout
      write(99,100) 'qw0 ',qw0
      write(99,100) 'iq ',iq
      write(99,100) 'iqmod ',iqmod
      write(99,100) 'kpa ',kpa
      write(99,100) 'iqmod6 ',iqmod6
      write(99,100) 'bez ',bez
      write(99,100) 'elbe ',elbe
      write(99,100) 'bezb ',bezb
      write(99,100) 'ilin ',ilin
      write(99,100) 'nt ',nt
      write(99,100) 'iprint ',iprint
      write(99,100) 'ntco ',ntco
      write(99,100) 'eui ',eui
      write(99,100) 'euii ',euii
      write(99,100) 'nlin ',nlin
      write(99,100) 'bezl ',bezl
      write(99,100) 'betam ',betam
      write(99,100) 'pam ',pam
      write(99,100) 'betac ',betac
      write(99,100) 'pac ',pac
      write(99,100) 'bclorb ',bclorb
      write(99,100) 'nhmoni ',nhmoni
      write(99,100) 'nhcorr ',nhcorr
      write(99,100) 'nvmoni ',nvmoni
      write(99,100) 'nvcorr ',nvcorr
      write(99,100) 'ncororb ',ncororb
      write(99,100) 'apx ',apx
      write(99,100) 'apz ',apz
      write(99,100) 'sigma0 ',sigma0
      write(99,100) 'iclo ',iclo
      write(99,100) 'ncorru ',ncorru
      write(99,100) 'ncorrep ',ncorrep
      write(99,100) 'icomb0 ',icomb0
      write(99,100) 'icomb ',icomb
      write(99,100) 'ratio ',ratio
      write(99,100) 'ratioe ',ratioe
      write(99,100) 'iratioe ',iratioe
      write(99,100) 'icoe ',icoe
      write(99,100) 'ise ',ise
      write(99,100) 'mesa ',mesa
      write(99,100) 'mp ',mp
      write(99,100) 'm21 ',m21
      write(99,100) 'm22 ',m22
      write(99,100) 'm23 ',m23
      write(99,100) 'ise1 ',ise1
      write(99,100) 'ise2 ',ise2
      write(99,100) 'ise3 ',ise3
      write(99,100) 'isea ',isea
      write(99,100) 'qxt ',qxt
      write(99,100) 'qzt ',qzt
      write(99,100) 'tam1 ',tam1
      write(99,100) 'tam2 ',tam2
      write(99,100) 'isub ',isub
      write(99,100) 'nta ',nta
      write(99,100) 'nte ',nte
      write(99,100) 'ipt ',ipt
      write(99,100) 'totl ',totl
      write(99,100) 'rtc ',rtc
      write(99,100) 'rts ',rts
      write(99,100) 'ire ',ire
      write(99,100) 'ipr ',ipr
      write(99,100) 'irmod2 ',irmod2
      write(99,100) 'dtr ',dtr
      write(99,100) 'nre ',nre
      write(99,100) 'nur ',nur
      write(99,100) 'nch ',nch
      write(99,100) 'nqc ',nqc
      write(99,100) 'npp ',npp
      write(99,100) 'nrr ',nrr
      write(99,100) 'nu ',nu
      write(99,100) 'dphix ',dphix
      write(99,100) 'dphiz ',dphiz
      write(99,100) 'qx0 ',qx0
      write(99,100) 'qz0 ',qz0
      write(99,100) 'dres ',dres
      write(99,100) 'dfft ',dfft
      write(99,100) 'cma1 ',cma1
      write(99,100) 'cma2 ',cma2
      write(99,100) 'nstart ',nstart
      write(99,100) 'nstop ',nstop
      write(99,100) 'iskip ',iskip
      write(99,100) 'iconv ',iconv
      write(99,100) 'imad ',imad
      write(99,100) 'ipos ',ipos
      write(99,100) 'iav ',iav
      write(99,100) 'iwg ',iwg
      write(99,100) 'ivox ',ivox
      write(99,100) 'ivoz ',ivoz
      write(99,100) 'ires ',ires
      write(99,100) 'ifh ',ifh
      write(99,100) 'toptit ',toptit
      write(99,100) 'kwtype ',kwtype
      write(99,100) 'itf ',itf
      write(99,100) 'icr ',icr
      write(99,100) 'idis ',idis
      write(99,100) 'icow ',icow
      write(99,100) 'istw ',istw
      write(99,100) 'iffw ',iffw
      write(99,100) 'nprint ',nprint
      write(99,100) 'ndafi ',ndafi
      write(99,100) 'qwsk ',qwsk
      write(99,100) 'betx ',betx
      write(99,100) 'betz ',betz
      write(99,100) 'alfx ',alfx
      write(99,100) 'alfz ',alfz
      write(99,100) 'iskew ',iskew
      write(99,100) 'nskew ',nskew
      write(99,100) 'hmal ',hmal
      write(99,100) 'sixtit ',sixtit
      write(99,100) 'commen ',commen
      write(99,100) 'ithick ',ithick
      write(99,100) 'clo6 ',clo6
      write(99,100) 'clop6 ',clop6
      write(99,100) 'dki ',dki
      write(99,100) 'sigman ',sigman
      write(99,100) 'sigman2 ',sigman2
      write(99,100) 'sigmanq ',sigmanq
      write(99,100) 'clobeam ',clobeam
      write(99,100) 'beamoff ',beamoff
      write(99,100) 'parbe ',parbe
      write(99,100) 'track6d ',track6d
      write(99,100) 'ptnfac ',ptnfac
      write(99,100) 'sigz ',sigz
      write(99,100) 'sige ',sige
      write(99,100) 'partnum ',partnum
      write(99,100) 'parbe14 ',parbe14
      write(99,100) 'emitx ',emitx
      write(99,100) 'emity ',emity
      write(99,100) 'emitz ',emitz
      write(99,100) 'gammar ',gammar
      write(99,100) 'nbeam ',nbeam
      write(99,100) 'ibbc ',ibbc
      write(99,100) 'ibeco ',ibeco
      write(99,100) 'ibtyp ',ibtyp
      write(99,100) 'lhc ',lhc
      write(99,100) 'cotr ',cotr
      write(99,100) 'rrtr ',rrtr
      write(99,100) 'imtr ',imtr
      write(99,100) 'bbcu ',bbcu
      write(99,100) 'ibb6d ',ibb6d
      write(99,100) 'imbb ',imbb
      write(99,100) 'as ',as
      write(99,100) 'al ',al
      write(99,100) 'sigm ',sigm
      write(99,100) 'dps ',dps
      write(99,100) 'idz ',idz
      write(99,100) 'dp1 ',dp1
      write(99,100) 'itra ',itra
      write(99,100) 'x ',x
      write(99,100) 'y ',y
      write(99,100) 'bet0 ',bet0
      write(99,100) 'alf0 ',alf0
      write(99,100) 'clo ',clo
      write(99,100) 'clop ',clop
      write(99,100) 'cro ',cro
      write(99,100) 'is ',is
      write(99,100) 'ichrom ',ichrom
      write(99,100) 'nnumxv ',nnumxv
      write(99,100) 'xsi ',xsi
      write(99,100) 'zsi ',zsi
      write(99,100) 'smi ',smi
      write(99,100) 'aai ',aai
      write(99,100) 'bbi ',bbi
      write(99,100) 'ampt ',ampt
      write(99,100) 'tlim ',tlim
      write(99,100) 'tasm ',tasm
      write(99,100) 'preda ',preda
      write(99,100) 'idial ',idial
      write(99,100) 'nord ',nord
      write(99,100) 'nvar ',nvar
      write(99,100) 'nvar2 ',nvar2
      write(99,100) 'nsix ',nsix
      write(99,100) 'ncor ',ncor
      write(99,100) 'ipar ',ipar
      write(99,100) 'nordf ',nordf
      write(99,100) 'nvarf ',nvarf
      write(99,100) 'nord1 ',nord1
      write(99,100) 'ndimf ',ndimf
      write(99,100) 'idptr ',idptr
      write(99,100) 'inorm ',inorm
      write(99,100) 'imod1 ',imod1
      write(99,100) 'imod2 ',imod2
      write(99,100) 'icorr ',icorr
      write(99,100) 'nctype ',nctype
      write(99,100) 'namp ',namp
      write(99,100) 'nmom ',nmom
      write(99,100) 'nmom1 ',nmom1
      write(99,100) 'nmom2 ',nmom2
      write(99,100) 'weig1 ',weig1
      write(99,100) 'weig2 ',weig2
      write(99,100) 'dpmax ',dpmax
      write(99,100) 'coel ',coel
      write(99,100) 'ekv ',ekv
      write(99,100) 'fokqv ',fokqv
      write(99,100) 'aaiv ',aaiv
      write(99,100) 'bbiv ',bbiv
      write(99,100) 'smiv ',smiv
      write(99,100) 'zsiv ',zsiv
      write(99,100) 'xsiv ',xsiv
      write(99,100) 'xsv ',xsv
      write(99,100) 'zsv ',zsv
      write(99,100) 'qw ',qw
      write(99,100) 'qwc ',qwc
      write(99,100) 'clo0 ',clo0
      write(99,100) 'clop0 ',clop0
      write(99,100) 'eps ',eps
      write(99,100) 'epsa ',epsa
      write(99,100) 'ekk ',ekk
      write(99,100) 'cr ',cr
      write(99,100) 'ci ',ci
      write(99,100) 'xv ',xv
      write(99,100) 'yv ',yv
      write(99,100) 'dam ',dam
      write(99,100) 'ekkv ',ekkv
      write(99,100) 'sigmv ',sigmv
      write(99,100) 'dpsv ',dpsv
      write(99,100) 'dp0v ',dp0v
      write(99,100) 'sigmv6 ',sigmv6
      write(99,100) 'dpsv6 ',dpsv6
      write(99,100) 'ejv ',ejv
      write(99,100) 'ejfv ',ejfv
      write(99,100) 'xlv ',xlv
      write(99,100) 'zlv ',zlv
      write(99,100) 'pstop ',pstop
      write(99,100) 'rvv ',rvv
      write(99,100) 'ejf0v ',ejf0v
      write(99,100) 'numxv ',numxv
      write(99,100) 'nms ',nms
      write(99,100) 'nlostp ',nlostp
      write(99,100) 'dpd ',dpd
      write(99,100) 'dpsq ',dpsq
      write(99,100) 'fok ',fok
      write(99,100) 'rho ',rho
      write(99,100) 'fok1 ',fok1
      write(99,100) 'si ',si
      write(99,100) 'co ',co
      write(99,100) 'g ',g
      write(99,100) 'gl ',gl
      write(99,100) 'sm1 ',sm1
      write(99,100) 'sm2 ',sm2
      write(99,100) 'sm3 ',sm3
      write(99,100) 'sm12 ',sm12
      write(99,100) 'as3 ',as3
      write(99,100) 'as4 ',as4
      write(99,100) 'as6 ',as6
      write(99,100) 'sm23 ',sm23
      write(99,100) 'rhoc ',rhoc
      write(99,100) 'siq ',siq
      write(99,100) 'aek ',aek
      write(99,100) 'afok ',afok
      write(99,100) 'hp ',hp
      write(99,100) 'hm ',hm
      write(99,100) 'hc ',hc
      write(99,100) 'hs ',hs
      write(99,100) 'wf ',wf
      write(99,100) 'wfa ',wfa
      write(99,100) 'wfhi ',wfhi
      write(99,100) 'rhoi ',rhoi
      write(99,100) 'hi ',hi
      write(99,100) 'fi ',fi
      write(99,100) 'hi1 ',hi1
      write(99,100) 'xvl ',xvl
      write(99,100) 'yvl ',yvl
      write(99,100) 'ejvl ',ejvl
      write(99,100) 'dpsvl ',dpsvl
      write(99,100) 'oidpsv ',oidpsv
      write(99,100) 'sigmvl ',sigmvl
      write(99,100) 'iv ',iv
      write(99,100) 'aperv ',aperv
      write(99,100) 'ixv ',ixv
      write(99,100) 'clov ',clov
      write(99,100) 'clopv ',clopv
      write(99,100) 'alf0v ',alf0v
      write(99,100) 'bet0v ',bet0v
      write(99,100) 'ampv ',ampv
      write(99,100) 'clo6v ',clo6v
      write(99,100) 'clop6v ',clop6v
      write(99,100) 'hv ',hv
      write(99,100) 'bl1v ',bl1v
      write(99,100) 'tas ',tas
      write(99,100) 'qwcs ',qwcs
      write(99,100) 'di0xs ',di0xs
      write(99,100) 'di0zs ',di0zs
      write(99,100) 'dip0xs ',dip0xs
      write(99,100) 'dip0zs ',dip0zs
      write(99,100) 'xau ',xau
      write(99,100) 'cloau ',cloau
      write(99,100) 'di0au ',di0au
      write(99,100) 'tau ',tau
      write(99,100) 'tasau ',tasau
      write(99,100) 'wx ',wx
      write(99,100) 'x1 ',x1
      write(99,100) 'x2 ',x2
      write(99,100) 'fake ',fake
      write(99,100) 'e0f ',e0f
      write(99,100) 'numx ',numx
      write(99,100) 'cotr ',cotr
      write(99,100) 'rrtr ',rrtr
      write(99,100) 'imtr ',imtr
!     these other values???
      write(99,100) 'numl ',numl
      write(99,100) 'niu ',niu
      write(99,100) 'amp0 ',amp0
      write(99,100) 'amp ',amp
      write(99,100) 'damp ',damp
      write(99,100) 'chi0 ',chi0
      write(99,100) 'chid ',chid
      write(99,100) 'rat ',rat
      write(99,100) 'exz ',exz
      write(99,100) 'time0 ',time0
      write(99,100) 'time1 ',time1
      endfile (99,iostat=ierro)
      backspace (99,iostat=ierro)
 100  format (a10,(Z20))
      end
!DUMPS
+ei
