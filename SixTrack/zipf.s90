+dk zipf

module zipf
  implicit none

+ca comgetfields
+ca stringzerotrim
  
  integer zipf_maxfiles,zipf_numfiles
  parameter(zipf_maxfiles=256)
  
  character(len=stringzerotrim_maxlen) zipf_outfile                  !Name of output file (Default: Sixout.zip)
  character(len=stringzerotrim_maxlen) zipf_filenames(zipf_maxfiles) !Name of files to pack into the zip file.
  
  save zipf_numfiles, zipf_outfile, zipf_filenames
    
contains

  subroutine zipf_parseInputline(ch)
      use crcoall
    implicit none


    character(len=*), intent(in) :: ch

    !Read filenames
    call getfields_split( ch, getfields_fields, getfields_lfields,    &
         getfields_nfields, getfields_lerr )
    if ( getfields_lerr ) call prror(-1)
    
    if (getfields_nfields .ne. 1) then
       write(lout,'(a)')         "ERROR in ZIPF:"
       write(lout,'(a,1x,i3,a)') "Expected 1 filename per line, got", &
            getfields_nfields, ", line=",ch
       call prror(-1)
    end if

    zipf_numfiles = zipf_numfiles + 1
    if (zipf_numfiles .ge. zipf_maxfiles) then
       write(lout,'(a)')       "ERROR in ZIPF:"
       write(lout,'(a,1x,i5)') " Too many files, max=", zipf_maxfiles
       call prror(-1)
    endif
    
    zipf_filenames(zipf_numfiles)(1:getfields_lfields(1)) =           &
              getfields_fields(1)(1:getfields_lfields(1))
    
  end subroutine zipf_parseInputline
  
  subroutine zipf_parseInputDone
      use crcoall
    implicit none


+ca comgetfields
+ca stringzerotrim

    integer ii
    
    zipf_outfile(1:10) = "Sixout.zip" ! Output name fixed for now
    write(lout,'(a)')       "**** ZIPF ****"
    write(lout,'(a,a,a)')   " Output file name = '",            &
         trim(stringzerotrim(zipf_outfile)),"'"
    write(lout,'(a,1x,i5)') " Number of files to pack=",        &
         zipf_numfiles
    write(lout,'(a)')       " Files:"
    do ii=1,zipf_numfiles
       write(lout,'(1x,i5,a,1x,a)') ii,":",                        &
            trim(stringzerotrim(zipf_filenames(ii)))
    end do
    
    if (.not.(zipf_numfiles.gt.0)) then
       write(lout,'(a)') "ERROR in ZIPF:"
       write(lout,'(a)') " ZIPF block was empty;"
       write(lout,'(a)') " no files specified!"
       call prror(-1)
    endif

+if .not.libarchive
    write(lout,'(a)') "ERROR in ZIPF:"
    write(lout,'(a)') " ZIPF needs LIBARCHIVE to work,"
    write(lout,'(a)') " but this SixTrack was "//                  &
         "compiled without it."
    call prror(-1)
+ei
  end subroutine zipf_parseInputDone

  subroutine zipf_comnul
    implicit none
    integer i,j
    
    zipf_numfiles = 0
    
    do j=1, stringzerotrim_maxlen
       zipf_outfile(j:j)=char(0)
    enddo
    
    do i=1, zipf_maxfiles
       do j=1, stringzerotrim_maxlen
          zipf_filenames(i)(j:j)=char(0)
       enddo
    enddo
    
  end subroutine zipf_comnul

  subroutine zipf_dozip
!-----------------------------------------------------------------------*
!     ZIPF                                                              *
!     COMPRESS SELECTED OUTPUT FILES INTO .ZIP FILE                     *
!     AT THE END OF THE SIMULATION                                      *
!     K.SJOBAK, 7/02/2016                                               *
!-----------------------------------------------------------------------*
      use crcoall
    implicit none
+ca comgetfields
+ca stringzerotrim

+if boinc
    character(stringzerotrim_maxlen) zipf_outfile_boinc
    character(stringzerotrim_maxlen) zipf_filenames_boinc(zipf_maxfiles)
    integer ii
+ei

!+if libarchive
! Having an actual explicit interface would be nice - this is 90% there,
! however some logic should probably be changed (here, in libArchive_Fwrapper.c,
! and in the test program). For now, if it passes CTEST, we think it works...
!    interface
!       subroutine f_write_archive(outname,filenames,numfiles,outname_len,filenames_len) &
!            bind(C,name="f_write_archive_")
!         use, intrinsic :: iso_c_binding, only : c_int
!         implicit none
!+ca comgetfields
!+ca stringzerotrim  
!         character(len=1), intent(in) :: outname
!         character(len=1), intent(in) :: filenames(*)
!         integer(kind=c_int), intent(in) :: numfiles
!         integer(kind=c_int), intent(in), VALUE :: outname_len
!         integer(kind=c_int), intent(in), VALUE :: filenames_len
!       end subroutine f_write_archive
!    end interface
!+ei


    write(lout,'(a,a,a)') "ZIPF: Compressing file '", trim(stringzerotrim(zipf_outfile)),"'..."

+if libarchive
+if boinc
    !For BOINC, we may need to translate the filenames.
    call boincrf(trim(stringzerotrim(zipf_outfile)), zipf_outfile_boinc )
    
    do ii=1,zipf_numfiles
       call boincrf(trim(stringzerotrim(zipf_filenames(ii))), zipf_filenames_boinc(ii) )
       zipf_filenames_boinc(ii) = trim(zipf_filenames_boinc(ii))
    end do
    
    !The f_write_archive function will handle the conversion from Fortran to C-style strings
    call f_write_archive(trim(zipf_outfile_boinc),zipf_filenames_boinc,zipf_numfiles)
+ei

+if .not.boinc
    call f_write_archive(zipf_outfile,zipf_filenames,zipf_numfiles)
+ei
+ei

+if .not.libarchive
    ! If not libarchive, the zipf subroutine shall just be a stub.
    ! And anyway daten should not accept the block, so this is somewhat redundant.
    write(lout,'(a)') " *** No libArchive in this SixTrack *** "
+ei

    write(lout,'(a)') "Done!"

  end subroutine zipf_dozip
  
end module zipf
