! ================================================================================================ !
!  
!  SixTrack
!  
!  The code contains the SixTrack particle simulation code written by:
!    F. Schmidt, DESY, CERN
!    E. Mcintosh, H. Ranshall, H. Grote, F. James,
!    K. Koelbig, K. Heinemann, M. Vaenttinen,
!    R. Assman, C. Bracco, R. Bruce, D. Mirarchi, V. Previtali,
!    S. Redaelli, G. Robert-Demolaize, E. Quaranta
!    A. Rossi, C. Tambasco, T. Weiler,
!    J. Barranco, Y. Sun, Y. Levinsen, M. Fjellstrom,
!    A. Santamaria, R. Kwee-Hinzmann, A. Mereghetti, K. Sjobak,
!    M. Fiascaris, J.F. Wagner, J. Wretborn, V.K. Berglyd Olsen, CERN
!    M. Fitterer, FNAL, CERN
!    A. Patapenka,  NIU, CERN
!    G. Robert-Demolaize, BNL
!    V. Gupta, Google Summer of Code (GSoC)
!    J. Molson UMAN, LAL, CERN
!    S. Kostoglou, NTUA, CERN
!    
!  Copyright 2014 CERN. This software is distributed under the terms of the GNU
!  Lesser General Public License version 2.1, copied verbatim in the file ``COPYING''.
!  
!  In applying this licence, CERN does not waive the privileges and immunities
!  granted to it by virtue of its status as an Intergovernmental Organization or
!  submit itself to any jurisdiction.
!  
! ================================================================================================ !

+cd crco
      integer sixrecs,binrec,binrecs,bnlrec,bllrec,numlcr
      logical rerun,start,restart,checkp,fort95,fort96,read95,read96
      character(len=1024) arecord
      character(len=20) stxt
      character(len=80) runtim
! Note order of placement in COMMON crdata is important
! for the alignment of the data
      common /crdata/                                                   &
     &sixrecs,binrec,binrecs((npart+1)/2),bnlrec,bllrec,                &
     &numlcr,rerun,start,restart,checkp,                                &
     &fort95,fort96,read95,read96,arecord,stxt,runtim
      integer crnumlcr,crnuml,crnapxo,crnapx,crnumxv,crnnumxv,crnlostp, &
     &crsixrecs,crbinrec,crbinrecs,crbnlrec,crbllrec,cril
      logical crpstop,crsythck
      real crtime3
      real(kind=fPrec) cre0,crxv,cryv,crsigmv,crdpsv,crdpsv1,crejv,     &
     &crejfv,craperv,crxvl,cryvl,crdpsvl,crejvl,crsigmvl

      character(len=8)  cr_version !Keep data type in sync with 'version'
      character(len=10) cr_moddate !Keep data type in sync with 'moddate'
      common/crio/                                                      &
     &cre0,crxv(2,npart),cryv(2,npart),                                 &
     &crsigmv(npart),crdpsv(npart),crdpsv1(npart),crejv(npart),         &
     &crejfv(npart),craperv(npart,2),crxvl(2,npart),cryvl(2,npart),     &
     &crdpsvl(npart),crejvl(npart),crsigmvl(npart),                     &
     &            crsixrecs,crbinrec,crbinrecs((npart+1)/2),crbnlrec,   &
     &crbllrec,cril,                                                    &
     &crnumlcr,crnuml,crsythck,                                         &
     &                crtime3,                                          &
     &crnapxo,crnapx,                                                   &
     &crnumxv(npart),crnnumxv(npart),crnlostp(npart),crpstop(npart)

+cd beamdim
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
+cd commond1
  ! This and the next block just have different variable names, and seem to be FOX related?
  ! Could in principle go into mod_commont where the DA / non-DA copy logic lives
  common/daele/alda,asda,aldaq,asdaq,smida,xx,yy,dpda,dpda1,sigmda,ej1,ejf1,rv
+cd commd1da
  integer alda_da,asda_da,aldaq_da,asdaq_da,smida_da,xx_da,yy_da,dpda_da,dpda1_da,sigmda_da,ej1_da,ejf1_da,rv_da
  common/daele/alda_da(2,6),asda_da(2,6),aldaq_da(2,6),asdaq_da(2,6),smida_da(mcor),xx_da(2), &
    yy_da(2),dpda_da,dpda1_da,sigmda_da,ej1_da,ejf1_da,rv_da
!
+dk errf
      subroutine errf(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! purpose:                                                             *
!   modification of wwerf, real(kind=fPrec) complex error function,    *
!   written at cern by k. koelbig.                                     *
!   taken from mad8                                                    *
! input:                                                               *
!   xx, yy    (real)    argument to cerf.                              *
! output:                                                              *
!   wx, wy    (real)    function result.                               *
!----------------------------------------------------------------------*
!---- real(kind=fPrec) version.
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use mod_common, only : cc,xlim,ylim
      implicit none

      integer n,nc,nu
      real(kind=fPrec) h,q,rx,ry,saux,sx,sy,tn,tx,ty,wx,wy,x,        &
     &xh,xl,xx,y,yh,yy
      dimension rx(33),ry(33)
      save
!-----------------------------------------------------------------------
      x=abs(xx)
      y=abs(yy)
      if(y.lt.ylim.and.x.lt.xlim) then
        q=(one-y/ylim)*sqrt(one-(x/xlim)**2)
        h=one/(3.2_fPrec*q)
        nc=7+int(23.0_fPrec*q)                                               !hr05
!       xl=h**(1-nc)
        xl=exp_mb((1-nc)*log_mb(h))                                      !yil11
#ifdef DEBUG
!       call wda('errfq',q,nc,0,0,0)
!       call wda('errfh',h,nc,0,0,0)
!       call wda('errfxl',xl,nc,0,0,0)
#endif
#ifdef DEBUG
!       call wda('errfxlrn',xl,nc,0,0,0)
#endif
        xh=y+half/h
        yh=x
        nu=10+int(21.0_fPrec*q)
#ifdef DEBUG
!       call wda('errfxh',xh,nu,0,0,0)
!       call wda('errfyh',yh,nu,0,0,0)
#endif
        rx(nu+1)=zero
        ry(nu+1)=zero
        do 10 n=nu,1,-1
          tx=xh+real(n,fPrec)*rx(n+1)                                          !hr05
          ty=yh-real(n,fPrec)*ry(n+1)                                          !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(n)=(half*tx)/tn                                            !hr05
          ry(n)=(half*ty)/tn                                            !hr05
   10   continue
        sx=zero
        sy=zero
        do 20 n=nc,1,-1
          saux=sx+xl
          sx=rx(n)*saux-ry(n)*sy
          sy=rx(n)*sy+ry(n)*saux
          xl=h*xl
   20   continue
        wx=cc*sx
        wy=cc*sy
      else
        xh=y
        yh=x
        rx(1)=zero
        ry(1)=zero
        do 30 n=9,1,-1
          tx=xh+real(n,fPrec)*rx(1)                                            !hr05
          ty=yh-real(n,fPrec)*ry(1)                                            !hr05
          tn=tx**2+ty**2                                                 !hr05
          rx(1)=(half*tx)/tn                                            !hr05
          ry(1)=(half*ty)/tn                                            !hr05
   30   continue
        wx=cc*rx(1)
        wy=cc*ry(1)
      endif
!      if(y.eq.0.) wx=exp(-x**2)
      if(yy.lt.zero) then
        wx=(two*exp_mb(y**2-x**2))*cos_mb((two*x)*y)-wx                  !hr05
        wy=((-one*two)*exp_mb(y**2-x**2))*sin_mb((two*x)*y)-wy           !hr05
        if(xx.gt.zero) wy=-one*wy                                        !hr05
      else
        if(xx.lt.zero) wy=-one*wy
      endif
      end
      subroutine wzsubv(n,vx,vy,vu,vv)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!  Vectorised for up to 64 argument values by E.McIntosh, 30.10.1997.
!  Much impoved using short vector buffers Eric 1st May, 2014.
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
!  *********************************************************************
      use floatPrecision
      use numerical_constants
      implicit none

      dimension vx(*),vy(*),vu(*),vv(*)
      integer i,j,k,n,vmu,vnu
      real(kind=fPrec) a1,a2,b1,b2,vd12i,vd12r,vd23i,vd23r,             &
     &vd34i,vd34r,vp,vq,vqsq,vr,vsimag,vsreal,vt,vtdd13i,vtdd13r,       &
     &vtdd24i,vtdd24r,vtdddi,vtdddr,vti,vtr,vu,vusum,vusum3,vv,         &
     &vvsum,vvsum3,vw1i,vw1r,vw2i,vw2r,vw3i,vw3r,vw4i,vw4r,vx,          &
     &vxh,vxhrel,vy,vyh,vyhrel
      integer npart
#if !defined(BIGNPART) && !defined(HUGENPART)
      parameter(npart = 64)
#endif
#if defined(BIGNPART) && !defined(HUGENPART)
! See also module parpro
      parameter(npart = 2048)
#endif
#if !defined(BIGNPART) && defined(HUGENPART)
! See also module parpro
      parameter(npart = 65536)
#endif
      integer idim,kstep,nx,ny
      real(kind=fPrec) h,hrecip,wtimag,wtreal,xcut,ycut
      parameter ( xcut = 7.77_fPrec, ycut = 7.46_fPrec )
      parameter ( h = one/63.0_fPrec )
      parameter ( nx = 490, ny = 470 )
      parameter ( idim = (nx+2)*(ny+2) )
      common /wzcom1/ hrecip, kstep
      common /wzcom2/ wtreal(idim), wtimag(idim)
      parameter ( a1 = 0.5124242248_fPrec, a2 = 0.0517653588_fPrec )
      parameter ( b1 = 0.2752551286_fPrec, b2 = 2.7247448714_fPrec )
      real(kind=fPrec) xm,xx,yy
      parameter (xm=1e16_fPrec)
!     temporary arrays to facilitate vectorisation
      integer in,out,ins,outs
      dimension ins(npart),outs(npart)
!-----------------------------------------------------------------------
      save
      in=0
      out=0
      do i=1,n
        if (vx(i).ge.xcut.or.vy(i).ge.ycut) then
          out=out+1
          outs(out)=i
          if (out.eq.npart) then
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
            do j=1,out
              xx=vx(outs(j))
              yy=vy(outs(j))
              if (xx.ge.xm) xx=xm
              if (yy.ge.xm) yy=xm
              vp=xx**2-yy**2
              vq=(two*xx)*yy
              vqsq=vq**2
!  First term.
              vt=vp-b1
              vr=a1/(vt**2+vqsq)
              vsreal=vr*vt
              vsimag=-vr*vq                              
!  Second term
              vt=vp-b2
              vr=a2/(vt**2+vqsq)
              vsreal=vsreal+vr*vt
              vsimag=vsimag-vr*vq
!  Multiply by i*z.
              vu(outs(j))=-(yy*vsreal+xx*vsimag)
              vv(outs(j))=xx*vsreal-yy*vsimag
            enddo
            out=0
          endif
        else
          in=in+1
          ins(in)=i
          if (in.eq.npart) then
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
            do j=1,in
              vxh = hrecip*vx(ins(j))
              vyh = hrecip*vy(ins(j))
              vmu = int(vxh)
              vnu = int(vyh)
!  Compute divided differences.
              k = 2 + vmu + vnu*kstep
              vw4r = wtreal(k)
              vw4i = wtimag(k)
              k = k - 1
              vw3r = wtreal(k)
              vw3i = wtimag(k)
              vd34r = vw4r - vw3r
              vd34i = vw4i - vw3i
              k = k + kstep
              vw2r = wtreal(k)
              vw2i = wtimag(k)
              vd23r = vw2i - vw3i
              vd23i = vw3r - vw2r
              vtr = vd23r - vd34r
              vti = vd23i - vd34i
              vtdd24r = vti - vtr
              vtdd24i = -one* ( vtr + vti )                             !hr05
              k = k + 1
              vw1r = wtreal(k)
              vw1i = wtimag(k)
              vd12r = vw1r - vw2r
              vd12i = vw1i - vw2i
              vtr = vd12r - vd23r
              vti = vd12i - vd23i
              vtdd13r = vtr + vti
              vtdd13i = vti - vtr
              vtdddr = vtdd13i - vtdd24i
              vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
              vxhrel = vxh - real(vmu,fPrec)
              vyhrel = vyh - real(vnu,fPrec)
              vusum3=half*(vtdd13r+                                     &
     &       (vxhrel*vtdddr-vyhrel*vtdddi))
              vvsum3=half*(vtdd13i+                                     &
     &       (vxhrel*vtdddi+vyhrel*vtdddr))
              vyhrel = vyhrel - one
              vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
              vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
              vxhrel = vxhrel - one
              vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
              vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
            enddo
            in=0
          endif
        endif
      enddo
!     everything outside the rectangle so approximate
!     write (*,*) 'ALL outside'
!     write (*,*) 'i=',i
      do j=1,out
        xx=vx(outs(j))
        yy=vy(outs(j))
        if (xx.ge.xm) xx=xm
        if (yy.ge.xm) yy=xm
        vp=xx**2-yy**2
        vq=(two*xx)*yy
        vqsq=vq**2
!  First term.
        vt=vp-b1
        vr=a1/(vt**2+vqsq)
        vsreal=vr*vt
        vsimag=-vr*vq                              
!  Second term
        vt=vp-b2
        vr=a2/(vt**2+vqsq)
        vsreal=vsreal+vr*vt
        vsimag=vsimag-vr*vq
!  Multiply by i*z.
        vu(outs(j))=-(yy*vsreal+xx*vsimag)
        vv(outs(j))=xx*vsreal-yy*vsimag
      enddo
!     everything inside the square, so interpolate
!     write (*,*) 'ALL inside'
      do j=1,in
        vxh = hrecip*vx(ins(j))
        vyh = hrecip*vy(ins(j))
        vmu = int(vxh)
        vnu = int(vyh)
!  Compute divided differences.
        k = 2 + vmu + vnu*kstep
        vw4r = wtreal(k)
        vw4i = wtimag(k)
        k = k - 1
        vw3r = wtreal(k)
        vw3i = wtimag(k)
        vd34r = vw4r - vw3r
        vd34i = vw4i - vw3i
        k = k + kstep
        vw2r = wtreal(k)
        vw2i = wtimag(k)
        vd23r = vw2i - vw3i
        vd23i = vw3r - vw2r
        vtr = vd23r - vd34r
        vti = vd23i - vd34i
        vtdd24r = vti - vtr
        vtdd24i = -one* ( vtr + vti )                             !hr05
        k = k + 1
        vw1r = wtreal(k)
        vw1i = wtimag(k)
        vd12r = vw1r - vw2r
        vd12i = vw1i - vw2i
        vtr = vd12r - vd23r
        vti = vd12i - vd23i
        vtdd13r = vtr + vti
        vtdd13i = vti - vtr
        vtdddr = vtdd13i - vtdd24i
        vtdddi = vtdd24r - vtdd13r
!  Evaluate polynomial.
        vxhrel = vxh - real(vmu,fPrec)
        vyhrel = vyh - real(vnu,fPrec)
        vusum3=half*(vtdd13r+                                           &
     & (vxhrel*vtdddr-vyhrel*vtdddi))
        vvsum3=half*(vtdd13i+                                           &
     & (vxhrel*vtdddi+vyhrel*vtdddr))
        vyhrel = vyhrel - one
        vusum=vd12r+(vxhrel*vusum3-vyhrel*vvsum3)
        vvsum=vd12i+(vxhrel*vvsum3+vyhrel*vusum3)
        vxhrel = vxhrel - one
        vu(ins(j))=vw1r+(vxhrel*vusum-vyhrel*vvsum)
        vv(ins(j))=vw1i+(vxhrel*vvsum+vyhrel*vusum)
      enddo
      return
      end
      subroutine wzsub(x,y,u,v)
!  *********************************************************************
!
!  This subroutine sets u=real(w(z)) and v=imag(w(z)), where z=x+i*y and
!  where w(z) is the complex error function defined by formula 7.1.3 in
!  "Handbook of Mathematical functions [eds. M.Abramowitz & I.A.Stegun,
!  Washington, 1966].  The absolute error of the computed value is less
!  than 1E-8.
!
!  *** Note.  Subroutine WZSET must have been called before this sub-
!  routine can be used.
!
!  For (x,y) inside the rectangle with opposite corners (xcut,0) and
!  (0,ycut), where xcut and ycut have been set by WZSET, an interpo-
!  lation formula is used.  For (x,y) outside this rectangle, a two-
!  term rational approximation is used.
!
!  (G.A.Erskine, 29.09.1997)
!
!
!  Third-order divided-difference interpolation over the corners of a
!  square [e.g. formula (2.5.1) in "Introduction to Numerical Analysis"
!  (F.B.Hildebrand New York, 1957), but with complex nodes and
!  function values].
!
!  In the interpolation formula the corners of the grid square contain-
!  ing (x,y) are numbered (0,0)=3, (h,0)=4, (h,h)=1, (0,h)=2.
!  Identifiers d, dd and ddd denote divided-differences of orders 1, 2
!  and 3 respectively, and a preceding 't' indicates twice the value.
!
!  *********************************************************************
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use parbeam
      implicit none
      integer k,mu,nu
      real(kind=fPrec) a1,a2,b1,b2,d12i,d12r,d23i,d23r,d34i,d34r,p,     &
     &q,qsq,r,simag,sreal,t,tdd13i,tdd13r,tdd24i,tdd24r,tdddi,tdddr,ti, &
     &tr,u,usum,usum3,v,vsum,vsum3,w1i,w1r,w2i,w2r,w3i,w3r,w4i,w4r,x,xh,&
     &xhrel,y,yh,yhrel
      parameter ( a1 = 0.5124242248_fPrec, a2 = 0.0517653588_fPrec )
      parameter ( b1 = 0.2752551286_fPrec, b2 = 2.7247448714_fPrec )
      save
!-----------------------------------------------------------------------
      if ( x.ge.xcut .or. y.ge.ycut ) goto 1000
      xh = hrecip*x
      yh = hrecip*y
      mu = int(xh)
      nu = int(yh)
!  Compute divided differences.
      k = 2 + mu + nu*kstep
      w4r = wtreal(k)
      w4i = wtimag(k)
      k = k - 1
      w3r = wtreal(k)
      w3i = wtimag(k)
      d34r = w4r - w3r
      d34i = w4i - w3i
      k = k + kstep
      w2r = wtreal(k)
      w2i = wtimag(k)
      d23r = w2i - w3i
      d23i = w3r - w2r
      tr = d23r - d34r
      ti = d23i - d34i
      tdd24r = ti - tr
      tdd24i = -one* ( tr + ti )                                         !hr05
      k = k + 1
      w1r = wtreal(k)
      w1i = wtimag(k)
      d12r = w1r - w2r
      d12i = w1i - w2i
      tr = d12r - d23r
      ti = d12i - d23i
      tdd13r = tr + ti
      tdd13i = ti - tr
      tdddr = tdd13i - tdd24i
      tdddi = tdd24r - tdd13r
!  Evaluate polynomial.
      xhrel = xh - real(mu,fPrec)
      yhrel = yh - real(nu,fPrec)
      usum3 = half*( tdd13r + ( xhrel*tdddr - yhrel*tdddi ) )
      vsum3 = half*( tdd13i + ( xhrel*tdddi + yhrel*tdddr ) )
      yhrel = yhrel - one
      usum = d12r + ( xhrel*usum3 - yhrel*vsum3 )
      vsum = d12i + ( xhrel*vsum3 + yhrel*usum3 )
      xhrel = xhrel - one
      u = w1r + ( xhrel*usum - yhrel*vsum )
      v = w1i + ( xhrel*vsum + yhrel*usum )
      return
!
!  Two-term rational approximation to w(z) [Footnote to Table 7.9
!  in "Handbook of Mathematical Functions (eds. M.Abramowitz &
!  I.A.Stegun, Washington, 1966), but with additional digits in
!  the constants]:
!              u+i*v = i*z*( a1/(z**2-b1) + a2/(z**2-b2) ).
!  Maximum absolute error:
!        <1.E-6  for  x>=4.9  or  y>=4.4
!        <1.E-7  for  x>=6.1  or  y>=5.7
!        <1.E-8  for  x>=7.8  or  y>=7.5
!
 1000 p=x**2-y**2
      q=(2.d0*x)*y                                                       !hr05
      qsq=q**2
!  First term.
      t=p-b1
      r=a1/(t**2+qsq)
      sreal=r*t
      simag=(-one*r)*q                                                   !hr05
!  Second term
      t=p-b2
      r=a2/(t**2+qsq)
      sreal=sreal+r*t
      simag=simag-r*q
!  Multiply by i*z.
      u=-one*(y*sreal+x*simag)                                           !hr05
      v=x*sreal-y*simag
      return
!
      end

+dk daten
! ================================================================================================ !
!  READS INPUT DATA FROM FILE FORT.3 AND/OR FORT.2
! ================================================================================================ !
subroutine daten
  
  use floatPrecision
  use end_sixtrack
  use mathlib_bouncer
  use sixtrack_input
  
  use scatter, only : scatter_active, scatter_debug, scatter_seed1, scatter_seed2, scatter_dumpdata, &
    scatter_parseInputLine, scatter_allocate
  use dynk, only : ldynk,ldynkdebug,ldynkfiledisable,dynk_dumpdata,dynk_inputsanitycheck,dynk_allocate,dynk_parseInputLine
  use fma, only : fma_fname,fma_method,fma_numfiles,fma_norm_flag,fma_first,fma_last,&
    fma_max,fma_flag,fma_writeNormDUMP,fma_parseInputLine
  use dump, only : dump_parseInputLine, dump_parseInputDone
  use zipf, only : zipf_parseInputDone, zipf_parseInputline
  use bdex, only : bdex_debug,bdex_parseElem,bdex_parseChan,bdex_parseInputDone
  use aperture
  
  use physical_constants
  use numerical_constants
  use string_tools
  use strings
  
#ifdef FLUKA
  use mod_fluka
#endif
#ifdef HDF5
  use hdf5_output
#endif
#ifdef ROOT
  use root_output
#endif
  
  use mod_ranecu
  
  use crcoall
  use parpro
  use parpro_scale
  use parbeam, only : beam_expflag,beam_expfile_open
  use mod_common
  use mod_commons
  use mod_commont
  use mod_commond
  
  use mod_hions
  use mod_alloc
  use mod_dist
  
  use elens
  use wire

#ifdef COLLIMAT
  use collimation
#endif

  implicit none
  
  integer i,i1,i2,i3,ia,icc,ichrom0,iclr,ico,idi,iexnum,iexread,    &
    ifiend16,ifiend8,ii,il1,ilin0,im,imo,imod,imtr0,irecuin,iw,iw0,ix,  &
    izu,j,j0,j1,j2,jj,k,k0,k10,k11,ka,ke,ki,kk,kpz,kzz,l,l1,l2,l3,l4,   &
    ll,m,mblozz,mout,mout1,mout3,mout4,nac,nbidu,ncy2,ndum,nfb,nft,i4,i5
    
  real(kind=fPrec) ak0d,akad,alc,alignx,alignz,bk0d,bkad,cosy,dummy,    &
    emitnx,emitny,extaux,halc,halc2,halc3,harm,phag,pmat,qbet,qigam,    &
    r0,r0a,rdev,rmean,rsqsum,rsum,tilt,u0,xang,xstr,xpl0,xplane,xrms0,  &
    zpl0,zrms0
    
  ! For BEAM-EXP
  real(kind=fPrec) separx,separy
  real(kind=fPrec) mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11
  
  character(len=max_name_len) sing,stru,prin,quie,trac,diff,sync,ende,bloc,comm
  character(len=max_name_len) fluc,chro,tune,iter,limi,orbi,deco
  character(len=max_name_len) beze,go,comb,sear,subr
  character(len=max_name_len) free,geom,cavi,disp,reso,bezext
  character(len=max_name_len) idat,idat2,next,mult,line,init,ic0,imn,icel,irel
  character(len=max_name_len) iss,iqq,iele,ilm0,idum,norm
  character(len=max_name_len) kl,kr,orga,post,ripp,beam,trom
  character(len=max_name_len) coll
  character(len=60) ihead
  integer nchars
  parameter (nchars=160)
  character(len=nchars) ch
  character(len=nchars+nchars) ch1
  logical   beam_xstr
  
  ! Variables for input line fields
  ! These  should eventually be replaced by the string_tools->str_split subroutine
  character getfields_fields(getfields_n_max_fields)*(getfields_l_max_string) ! Array of fields
  integer   getfields_nfields                                                 ! Number of identified fields
  integer   getfields_lfields(getfields_n_max_fields)                         ! Length of each what:
  logical   getfields_lerr                                                    ! An error flag
  
#ifdef CRLIBM
  ! MAXF be kept in sync with value in function fround
  integer maxf,nofields
  parameter (maxf=30)
  parameter (nofields=41)
  character(len=maxf) fields(nofields)
  integer errno,nfields,nunit,nf
  real(kind=fPrec) fround
#else
  integer nunit
#endif
  integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
  data lineno2 /0/
  data lineno3 /0/
  data lineno8 /0/
  data lineno16 /0/
  data lineno30 /0/
  data lineno35 /0/
  
#ifdef COLLIMAT
!+ca collpara
!+ca dbdaten
+ca dbpencil
+ca database
+ca dbcolcom
  logical has_coll
#else
  logical do_coll
#endif
  
  ! Fluka related, might be best to lock to real64
  real(kind=fPrec) tmpamplfact, tmplen
  
  ! some temp vars for parsing block lines
  logical tmpl
  character(len=nchars) tmpch
  integer tmpi1,tmpi2,tmpi3
  real(kind=fPrec) tmpflt
  real(kind=fPrec) tmpflts(9)
  
  ! Elens: online calculation of theta@r2
  real(kind=fPrec) eLensTheta
  
  dimension icel(ncom,20),iss(2),iqq(5)
  dimension ilm0(40),ic0(10)
  dimension extaux(40),bezext(nblz)
  data sync,ende,next,comm /'SYNC','ENDE','NEXT','COMM'/
  data fluc,mult,chro,iter,tune,line,diff /'FLUC','MULT','CHRO','ITER','TUNE','LINE','DIFF'/
  data limi,orbi,go,sear,subr,reso,post,ripp,deco /'LIMI','ORBI','GO','SEAR','SUBR','RESO','POST','RIPP','DECO'/
  data comb,cavi,beam,trom /'COMB','CAV','BEAM','TROM'/
  data idum,kl,kr,orga,norm /' ','(',')','ORGA','NORM'/
  ! data corr,sing,stru,prin,quie,bloc,init,trac,disp /'CORR','SING','STRU','PRIN','QUIE','BLOC','INIT','TRAC','DISP'/
  ! data free,geom /'FREE','GEOM'/
  data coll /'COLL'/
  character(len=4) fluk
  data fluk /'FLUK'/
  
#ifdef CRLIBM
  real(kind=fPrec) round_near
#endif
  
  logical lapefound
  logical lerr1
  logical lexist
  
  ! New variables for sixtrack_input module
  logical inErr
  character(len=4) currBlock
  logical blockOpened, blockClosed
  logical openBlock, closeBlock
  integer blockLine, iElem
  
  logical parseFort2
  integer nGeom
  
  logical newParsing, oneLine
  
  save
  
! ================================================================================================ !

      if(mmul.lt.10.or.mmul.gt.20) call prror(85)
      irecuin=0
      iss(1)=' '
      iss(2)=' '

      do i=1,5
        iqq(i)=' '
      end do


      do i=1,40
        ilm0(i)=' '
        extaux(i)=zero
      end do

      do i=1,10
        coel(i)=' '
      end do

      do i=1,ncom
        do j=1,20
          icel(i,j)=' '
        end do
      end do

      do i=1,10
        ic0(i)=' '
      end do

      emitnx=zero
      emitny=zero
      ihead=' '
      sixtit=' '
      nbidu=0
      iclo6=0
      iclo6r=0
      iclr=0
      ncy=0
      ! ncy2=0
      ndum=0
        
!  Initialise new input parameters
      idial=0
      harm=one
      alc=c1m3
      phag=zero
      tlen=one
      pma=pmap
      ition=0
      dpscor=one
      sigcor=one
      iconv=0
      imad=0
      iskip=1
      cma1=one
      cma2=one
      qs=zero
      itra=0
      chi0=zero
      chid=zero
      rat=zero
      ipos=0
      iav=1
      iwg=1
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      ivox=1
      ivoz=1
      ires=1
      dres=one
      ifh=0
      dfft=one
      idis=0
      icow=0
      istw=0
      iffw=0
      nprint=1
      ndafi=1
      itco=500
      dma=c1m12
      dmap=c1m15
      itcro=10
      dech=c1m10
      de0=c1m9
      ded=c1m9
      dsi=c1m9
      dsm0=c1m10
      itqv=10
      dkq=c1m10
      dqq=c1m10
      ichrom=0
      iqmod=0
      im=0
      imtr0=0
      ilin=0
      nlin=0
      iout=0
      iquiet=0
      idp=0
      izu0=0
      mmac=1
      mcut=0
      mout=0
      mout1=0
      mout2=0
      mout3=0
      mout4=0
      kanf=1
      isub=0
      irmod2=0
      iorg=0
      ise=0
      iskew=0
      preda=c1m38
  
! ================================================================================================ !
!  SET DEFAULT MODULE VALUES
! ================================================================================================ !
  
  ! TRACKING PARAMETERS
  numl      = 1
  napx      = 0
  amp0      = zero
  amp(1)    = c1m3
  ird       = 0
  imc       = 0
  numlcp    = 1000
  numlmax   = 1000000000

  idz(:)    = 1
  idfor     = 0
  irew      = 0
  iclo      = 0

  nde(:)    = 0
  nwr(:)    = 1
  nwr(4)    = 10000
  ntwin     = 1
  
  ! HIONS MODULE
  zz0       = 1
  aa0       = 1
  nucm0     = pmap
  has_hion  = .false.
  
  ! COLLIMATION MODULE
#ifdef COLLIMAT
  has_coll  = .false.
#else
  do_coll   = .false.
#endif
  
! ================================================================================================ !
!  SET DEFAULT INPUT PARSING VALUES
! ================================================================================================ !
  
  ! SIXTRACK INPUT MODULE
  inErr       = .false.
  oneLine     = .false.
  sixin_ncy2  = 0
  sixin_icy   = 0
  sixin_debug = .false.
  
  call alloc(sixin_bez0, max_name_len, nele, repeat(char(0),max_name_len), "sixin_bez0")
  
  ! DATEB INTERNAL
  nGeom       = 0
  
! ================================================================================================ !
!  READ FORT.3 HEADER
! ================================================================================================ !
  
90 continue
  read(3,10010,end=1530,iostat=ierro) idat,ihead
  if(ierro > 0) call prror(58)
  lineNo3 = lineNo3+1
  if(idat(1:1) == "/") goto 90
  if(idat(1:1) == "!") goto 90
  
  select case(idat)
  case("FREE") ! Mode FREE. Elements in fort.3
    iMod       = 1
    parseFort2 = .false.
  case("GEOM") ! Mode GEOM. Elements in fort.2
    iMod       = 2
    parseFort2 = .true.
  case default
    call prror(1)
  end select
  
  write(lout,10130)
  write(lout,10030)
  write(lout,10180) ihead
  sixtit(1:60)=ihead
  if(imod.eq.1) write(lout,10190)
  if(imod.eq.2) write(lout,10200)
  write(lout,10130)
  
! ================================================================================================ !
!  BEGIN PARSING FORT.2 AND FORT.3
! ================================================================================================ !
  
  currBlock   = "NONE"  ! The current block being parsed
  openBlock   = .false. ! Whether the current block was opened on this pass
  blockOpened = .false. ! Whether the current block is open
  closeBlock  = .false. ! Whether the current block should be closed after the pass
  blockClosed = .false. ! Whether the current block is now closed, and should not be opened again
  
100 continue ! fort.2 loop
110 continue ! fort.3 loop
  
  ! We have our three geometry blocks, stop parsing fort.2
  if(nGeom >= 3) parseFort2 = .false.
  
  ! Select unit, and increment line number for error output
  if(parseFort2) then
    nUnit   = 2
    lineNo2 = lineNo2 + 1
  else
    nUnit   = 3
    lineNo3 = lineNo3 + 1
  end if
  
  read(nUnit, 10020, end=1530, iostat=iErro) ch
  if(iErro > 0) then
    write(lout,"(a,i0)") "INPUT> ERROR Could not read from fort.",nUnit
    call prror(-1)
  end if
  
  if(len(ch) == 0)   goto 110 ! Empty line, ignore
  if(ch(1:1) == "/") goto 110 ! Comment line, ignore
  if(ch(1:1) == "!") goto 110 ! Comment line, ignore
  if(len(ch) >= 4)   idat = ch(1:4)
  
  ! Parse non-block flags
  select case(idat)
  case("PRIN") ! Enable the PRINT flag
    iOut    = 1
    oneLine = .true.
    goto 110
  case("QUIE") ! Enable the QUIET flag
    iQuiet  = 1
    oneLine = .true.
    goto 110
  case("NEXT") ! Close the current block
    if(newParsing .and. .not. oneLine) then
      ! Actual close check is done after a last pass so
      ! each block can finalise any necessary initialisation
      closeBlock = .true.
    else
      ! Most old block parsing code handles NEXT locally, but
      ! some end up here. Send them back to start.
      goto 110
    end if
  case("ENDE") ! End of fort.3 input
    call sixin_blockReport
    goto 771
  end select
  
  oneLine = .false.
  
  ! Old style block parsing
  newParsing = .false.
  select case(idat)
  case("TUNE")
    goto 600
  case("SYNC")
    goto 710
  case("ITER")
    goto 940
  case("FLUC")
    goto 790
  case("MULT")
    goto 740
  case("CHRO")
    goto 560
  case("LINE")
    goto 660
  case("LIMI")
    goto 950
  case("ORBI")
    goto 980
  case("COMB")
    goto 1030
  case("SUBR")
    goto 1110
  case("RESO")
    goto 1120
  case("SEAR")
    goto 1200
  case("ORGA")
    goto 880
  case("POST")
    goto 1280
  case("RIPP")
    goto 1290
  case("DECO")
    goto 1320
  case("NORM")
    goto 1400
  case("CORR")
    goto 1410
  case("BEAM")
    goto 1600
  case("TROM")
    goto 1700
  case("COLL")
    goto 1285
  case("FLUK")
    goto 1800
  case("DUMP")
    goto 2000
  case("BDEX")
    goto 2250
  case("FMA")
    goto 2300
  case("ELEN")
    goto 2400
  case("WIRE")
    goto 2500
  end select
  
  ! If we've reached this point, the old style block parsing has not been executed.
  ! Switch to new type of parsing.
  newParsing = .true.
  
  ! Check if no block is active. If so, there should be a new one if input is sane.
  if(currBlock == "NONE") then
    currBlock = idat
    openBlock = .true.
  end if
  
  ! Check the status of the current block
  call sixin_checkBlock(currBlock, blockOpened, blockClosed, blockLine)
  ! if(nUnit == 2) then
  !   write(lout,"(a,i4,2(a,l1),a,i0)") "INPUT> fort.2 : ",lineNo2," = '"//ch//"', "// &
  !     "B:'"//currBlock//"', O:",blockOpened,", C:",blockClosed,", L:",blockLine
  ! else
  !   write(lout,"(a,i4,2(a,l1),a,i0)") "INPUT> fort.3 : ",lineNo3," = '"//ch//"', "// &
  !     "B:'"//currBlock//"', O:",blockOpened,", C:",blockClosed,", L:",blockLine
  ! end if
  
  ! Check if the current block has already been seen and closed.
  ! If so, the block exists more than once in the input files. It shouldn't.
  if(blockClosed) then
    write(lout,"(a)") "INPUT> ERROR Block '"//currBlock//"' encountered more than once."
    goto 9999
  end if
  
  ! Block-Wise Parsing Code
  !=========================
  ! These are parsed one line at a time, including the block declaration and the NEXT.
  ! When the block is first encountered, the 'openBlock' flag is .true. for one pass.
  ! When the block is closed, the 'closeBlock' flag is .true. for the final pass.
  ! Otherwise, we have an input line that should be parsed by a single subroutine call.
  ! The in-block line number is available as the variable 'blockLine' if needed.
  
  select case(currBlock)
  
  case("INFO") ! Information Block
    if(openBlock) then
      continue
    elseif(closeBlock) then
      continue
    else
      call sixin_parseInputLineINFO(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("COMM")
    if(openBlock) then
      continue
    elseif(closeBlock) then
      continue
    else
      if(len(ch) > 80) then
        commen = ch(1:80)
      else
        commen = ch
      end if
    end if
    
  case("SING") ! Single Elements Block
    if(openBlock) then
      sixin_nSing = 1
    elseif(closeBlock) then
      nGeom = nGeom + 1
    else
      call sixin_parseInputLineSING(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("BLOC") ! Block Definitions
    if(openBlock) then
      sixin_nBloc = 0
    elseif(closeBlock) then
      nGeom = nGeom + 1
    else
      call sixin_parseInputLineBLOC(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("STRU") ! Structure Input
    if(openBlock) then
      sixin_nStru = 0
    elseif(closeBlock) then
      nGeom = nGeom + 1
    else
      call sixin_parseInputLineSTRU(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("DISP") ! Displacement of Elements Block
    if(openBlock) then
      continue
    elseif(closeBlock) then
      continue
    else
      call sixin_parseInputLineDISP(ch,inErr)
      if(inErr) goto 9999
    end if
    
  case("INIT") ! Initial Coordinates
    if(openBlock) then
      continue
    elseif(closeBlock) then
      dp1   = exz(1,6)
      iclr  = 0
      nbidu = 1
    else
      call sixin_parseInputLineINIT(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
  
  case("TRAC") ! Tracking Parameters
    if(openBlock) then
      continue
    elseif(closeBlock) then
      nbidu = 1
    else
      call sixin_parseInputLineTRAC(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("DIFF") ! Differential Algebra
    if(openBlock) then
      continue
    elseif(closeBlock) then
      continue
    else
      call sixin_parseInputLineDIFF(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("DIST") ! Beam Distribution
    if(openBlock) then
      continue
    elseif(closeBlock) then
      continue
    else
      call dist_parseInputLine(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("DYNK") ! Dynamic Kick Block
    if(openBlock) then
      call dynk_allocate
    elseif(closeBlock) then
      if(ldynkdebug) call dynk_dumpdata
      ldynk = .true.
      call dynk_inputsanitycheck
    else
      call dynk_parseInputLine(ch,inErr)
      if(inErr) goto 9999
    end if
    
  case("HION") ! Heavy Ion Input Block
    if(openBlock) then
      continue
    elseif(closeBlock) then
      has_hion = .true.
    else
      call hions_parseInputLine(ch,blockLine,inErr)
      if(inErr) goto 9999
    end if
    
  case("ZIPF") ! ZIPF Input Block
    if(openBlock) then
      continue
    elseif(closeBlock) then
      call zipf_parseInputDone
    else
      call zipf_parseInputline(ch)
    end if
  
  case("SCAT") ! SCATTER Input Block
    if(openBlock) then
      scatter_active = .true.
      call scatter_allocate
    elseif(closeBlock) then
      if(scatter_debug) call scatter_dumpData
    else
      call scatter_parseInputLine(string(adjustl(ch)))
    end if
  
  case("HDF5") ! HDF5 Input Block
#ifndef HDF5
    write(lout,"(a)") "INPUT> ERROR SixTrack was not compiled with the HDF5 flag."
    goto 9999
#else
    if(openBlock) then
      h5_isActive = .true.
    elseif(closeBlock) then
      continue
    else
      call h5_parseInputLine(string(ch))
    end if
#endif
  
  case("ROOT") ! ROOT Input Block
#ifndef ROOT
    write(lout,"(a)") "INPUT> ERROR ROOT output requested but this exe does not have ROOT support compiled in"
    goto 9999
#else
  if(openBlock) then
    continue
  elseif(closeBlock) then
    call root_parseInputDone
  else
    call daten_root(ch)
  end if
#endif
  
  case default ! Unknown Block, Time to Panic
    write(lout,"(a)") "INPUT> ERROR Unknown block '"//currBlock//"' encountered. Check your input file."
    goto 9999
  
  end select
  
  ! Some cleanup and record keeping
  
  if(openBlock) then
    ! Nothing to do other than switch off the flag
    openBlock = .false.
  end if
  
  if(closeBlock) then
    ! Close the block and check that everything is normal.
    if(blockClosed) then
      write(lout,"(a)") "INPUT> Trying to close block '"//currBlock//"', which is already closed."
      goto 9999
    end if
    call sixin_closeBlock(currBlock)
    currBlock  = "NONE"  ! No active blocks
    closeBlock = .false. ! Switch off the flag
  end if
  
  goto 110 ! Get next line
  
! ================================================================================================ !
!  DONE PARSING FORT.2 AND FORT.3
! ================================================================================================ !

!-----------------------------------------------------------------------
!  CHROMATCITY ADJUSTMENT
!-----------------------------------------------------------------------
  560 ichrom=1
      ichrom0=0
      do 580 l=1,2
  570 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 570
      call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(l.eq.1) read(ch1,*,round='nearest') iss(1),cro(1),ichrom0
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(l.eq.1) read(ch1,*) iss(1),cro(1),ichrom0
#endif
#ifdef CRLIBM
      if(l.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read (fields(1),*) iss(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read (fields(3),*) ichrom0
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iss(2),cro(2)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(l.eq.2) read(ch1,*) iss(2),cro(2)
#endif
#ifdef CRLIBM
      if (l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iss(2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cro(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
#endif
#endif
  580 continue

      do j=1,il
        if(iss(1).eq.bez(j)) is(1)=j
        if(iss(2).eq.bez(j)) is(2)=j
      end do

      if(ichrom0.ge.1.and.ichrom0.le.3) ichrom=ichrom0
      goto 110

!-----------------------------------------------------------------------
!  TUNE ADJUSTMENT
!-----------------------------------------------------------------------
  600 iqmod=1
      do 630 l=1,3
  610 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 610
      if(ch(:4).eq.next) then
        if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni) then

          do j=1,il
            if(iqq(1).eq.bez(j)) iq(1)=j
            if(iqq(2).eq.bez(j)) iq(2)=j
          end do

          goto 110
        else
          write(lout,10370)
          iqmod=0
          iqmod6=0
          goto 110
        endif
      endif
      call intepr(1,1,ch,ch1)
      if(l.eq.1) then
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
        read(ch1,*,round='nearest')                                     &
     & iqq(1),qw0(1),iqmod6
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
        read(ch1,*) iqq(1),qw0(1),iqmod6
#endif
#ifdef CRLIBM
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) iqmod6
          nf=nf-1
        endif
#endif
#endif
        if(iqmod6.eq.1) then
          iqmod6=0
        elseif(iqmod6.eq.2) then
          iqmod6=1
          iqmod=0
        elseif(iqmod6.eq.3) then
          iqmod6=1
        endif
      endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(l.eq.2) read(ch1,*,round='nearest')                            &
     & iqq(2),qw0(2)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(l.eq.2) read(ch1,*) iqq(2),qw0(2)
#endif
#ifdef CRLIBM
      if(l.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(2)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(l.eq.3) read(ch1,*,round='nearest')                            &
     & iqq(3),qw0(3)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(l.eq.3) read(ch1,*) iqq(3),qw0(3)
#endif
#ifdef CRLIBM
      if(l.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iqq(3)
        nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(3)=fround(errno,fields,2)
        nf=nf-1
        endif
      endif
#endif
#endif
  630 continue
  640 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 640
      call intepr(4,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & iqq(4),iqq(5)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
      read(ch1,*) iqq(4),iqq(5)
#endif
      if(abs(qw0(1)).gt.pieni.and.abs(qw0(2)).gt.pieni                  &
     &.and.abs(qw0(3)).gt.pieni) then
        do 650 j=1,il
          if(iqq(1).eq.bez(j)) iq(1)=j
          if(iqq(2).eq.bez(j)) iq(2)=j
          if(iqq(3).eq.bez(j)) iq(3)=j
          if(iqq(4).eq.bez(j)) kpa(j)=1
          if(iqq(5).eq.bez(j)) kpa(j)=2
 650    continue
        goto 110
      else
        write(lout,10370)
        iqmod=0
        iqmod6=0
        write(lout,*) 'TUNE ADJUSTED'
        goto 110
      endif
!-----------------------------------------------------------------------
!  LINEAR OPTICS CALCULATION
!  - in the 4D case (ilin=1) the subroutine linopt is called
!  - in the 6d case (ilin=2) the optics parameters are calculated and 
!    printed in the subroutine umlauda (calculated in the common block
!    umlalid)
!-----------------------------------------------------------------------
 660  continue
      ilin0=1
      read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 660
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & idat,nt,ilin0,ntco,eui,euii
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) idat,nt,ilin0,ntco,eui,euii
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nt
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ilin0
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(4),*) ntco
        nf=nf-1
      endif
      if (nf.gt.0) then
        eui=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        euii=fround(errno,fields,6)
        nf=nf-1
      endif
#endif
#endif
      iprint=0
      if(idat.ne.'BLOCK'.and.idat.ne.'ELEMENT') call prror(45)
      if(idat.eq.'BLOCK') iprint=1
      ilin=1
      if(ilin0.ge.1.and.ilin0.le.3) ilin=ilin0

  670 do m=1,40
        ilm0(m)=idum
      end do

  690 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 690
      if(ch(:4).eq.next) goto 110
      call intepr(2,1,ch,ch1)
! ilm0 are character strings, should be OK
      read(ch1,*) (ilm0(m),m=1,40)
      do 700 m=1,40
      if(ilm0(m).eq.idum) goto 700
      nlin=nlin+1
      if(nlin.gt.nele) call prror(81)
      bezl(nlin)=ilm0(m)
  700 continue
      goto 670

!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!-----------------------------------------------------------------------
  710 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 710
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & harm,alc,u0,phag,tlen,pma,ition,dppoff
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.1) read(ch1,*) harm,alc,u0,phag,tlen,pma,ition,dppoff
#endif
#ifdef CRLIBM
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          harm=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          alc=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          u0=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          phag=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          tlen=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          pma=real(fround(errno,fields,6),fPrec)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ition
          nf=nf-1
        endif
        if (nf.gt.0) then
          dppoff=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & dpscor,sigcor
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.2) read(ch1,*) dpscor,sigcor
#endif
#ifdef CRLIBM
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          dpscor=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          sigcor=fround(errno,fields,2)
          nf=nf-1
        endif
      endif
#endif
#endif
      if(iclr.ne.2) goto 710
      iclr=0
      if(abs(pma-pmap).le.c1m1) pmat=pmap
      if(abs(pma-pmae).le.c1m1) pmat=pmae
      if(pmat.ne.pmap.and.pmat.ne.pmae) then
        write(lout,*)
        write(lout,*) 'Warning: Particle is neither proton nor electron'
        write(lout,*) 'pma:  ', pma
        write(lout,*) 'pmap: ', pmap
        write(lout,*)
      endif
      if(pma.lt.pieni) call prror(27)
      !nucm0=pma
      crad=(crade*pmae)/pma                                              !hr05
      if(abs(tlen).le.pieni) call prror(25)
      if(sixin_ncy2.eq.0) then
        ncy=sixin_icy*mper
        idp=1
        if(ncy.ne.0) goto 720
        idp=0
        write(lout,10130)
        write(lout,10340)
  720   phas=phag*rad
        if(ncy.ne.0) then
          hsy(1)=u0/real(ncy,fPrec)
        else
          hsy(1)=u0
        endif
        if(nvar.eq.5) then
          idp=1
          ition=1
          hsy(1)=zero
        endif
        halc=harm*alc
        halc2=harm/tlen
        hsy(3)=(two*pi)*halc2                                            !hr05
        cosy=cos_mb(phas)
        qigam=(pma**2/e0)/e0                                             !hr05
        qbet=one-qigam
        halc3=((((((-one*(qigam-alc))*real(ition,fPrec))*harm)*u0)/e0)  &
     &*cosy)/((two*pi)*qbet)                                             !hr05
        if(halc3.lt.zero) call prror(28)
        qs=sqrt(halc3)
      else
        idp=1
        ncy=0
        do 725 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(abs(kz(ix)).eq.12) ncy=ncy+1
          endif
  725   continue
        do 730 j=1,il
          if(abs(kz(j)).eq.12) then
            hsyc(j)=((two*pi)*ek(j))/tlen                                !hr05
            if(nvar.eq.5) then
              ition=1
              ed(j)=zero
            endif
          endif
  730   continue
      endif
      goto 110
!-----------------------------------------------------------------------
!  MULTIPOLE COEFFICIENTS  FOR KZ = 11
!-----------------------------------------------------------------------
  740 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 740
      ! Get first data line: name, R_0, \delta_0
      call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & imn,r0,benki
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) imn,r0,benki
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) imn
        nf=nf-1
      endif
      if (nf.gt.0) then
        r0=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        benki=fround(errno,fields,3)
        nf=nf-1
      endif
#endif
#endif
      ! Renaming variables?
      i=1
      r0a=one
      im=im+1
      benkc(im)=benki
      r00(im)=r0
      ! Find single element which matches the name, set its
      ! irm from the MULT block counter im.
      do 750 j=1,il
      if(imn.eq.bez(j)) then
        irm(j)=im
        goto 760
      endif
  750 continue
  760 write(lout,10130)
      write(lout,10210) imn,r0,benki
      ! Read data lines: B_n rms-B_n A_n rms-A_n
  770 bk0d=zero
      bkad=zero
      ak0d=zero
      akad=zero
  780 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 780
      if(ch(:4).eq.next) goto 110
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & bk0d,bkad,ak0d,akad
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) bk0d,bkad,ak0d,akad
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        bk0d=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        bkad=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        ak0d=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        akad=fround(errno,fields,4)
        nf=nf-1
      endif
#endif
#endif
      ! Set nmu for the current single element (j)
      ! to the currently highest multipole seen (i)
      if(abs(bk0d).gt.pieni.or.abs(bkad).gt.pieni                       &
     &.or.abs(ak0d).gt.pieni.or.abs(akad).gt.pieni) nmu(j)=i
      write(lout,10220) i,bk0d,bkad,ak0d,akad
      bk0(im,i)=(benki*bk0d)/r0a                                         !hr05
      ak0(im,i)=(benki*ak0d)/r0a                                         !hr05
      bka(im,i)=(benki*bkad)/r0a                                         !hr05
      aka(im,i)=(benki*akad)/r0a                                         !hr05
      i=i+1
      r0a=r0a*r0
      if(i.gt.mmul+1) call prror(105)
      if(ch(:4).ne.next) goto 770 ! loop
      write(lout,10380)
      write (lout,*) 'BENKI done'
      goto 770
!-----------------------------------------------------------------------
!  FLUCTUATION RANDOM STARTING NUMBER
!-----------------------------------------------------------------------
  790 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 790
      ! Read izu0, mmac, mout, mcut
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & izu0, mmac, mout, mcut
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
      read(ch1,*) izu0, mmac, mout, mcut
#endif
      mcut=iabs(mcut)
      if(mmac.gt.nmac) call prror(55)
      !Generate normal distributed random numbers into zfz
      call recuin(izu0,irecuin)
      call ranecu(zfz,nzfz,mcut)
      rsum=zero

      do i=1,nzfz
        rsum=rsum+zfz(i)
      end do

      rmean=rsum/real(nzfz,fPrec)                                              !hr05
      rsqsum=zero

      do i=1,nzfz
        rsqsum=rsqsum+(zfz(i)-rmean)**2                                    !hr05
      end do

      rdev=sqrt(rsqsum/real(nzfz,fPrec))                                       !hr05
      write(lout,10410) izu0,nzfz,rmean,rdev
      if(mcut.eq.0) write(lout,10430)
      if(mcut.gt.0) write(lout,10440) mcut
      write(lout,10130)
      ! Set flags mout1, mout2, mount3, mout4 depending on mout
      ! Enables/disables different functionality
      if(mout.ge.8) mout4=1
      if(mout.eq.7.or.mout.eq.15) then
        mout1=1
        mout2=1
        mout3=1
      else if(mout.eq.6.or.mout.eq.14) then
        mout2=1
        mout3=1
      else if(mout.eq.5.or.mout.eq.13) then
        mout1=1
        mout3=1
      else if(mout.eq.4.or.mout.eq.12) then
        mout3=1
      else if(mout.eq.3.or.mout.eq.11) then
        mout1=1
        mout2=1
      else if(mout.eq.2.or.mout.eq.10) then
        mout2=1
      else if(mout.eq.1.or.mout.eq.9) then
        mout1=1
      endif
      
      ! Reads from fort.16 IF mout1==1
      if(mout1.eq.1) then
        write(lout,*)
        write(lout,*) '          Multipole errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0 ! Reading regular multipoles(1) or skew components (2)
        ifiend16=0
        iexnum=0
        read(16,10020,end=861)
        rewind 16

        do 860 i=1,mper*mbloz ! Loop over all structure elements
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN REGULAR MULTIPOLES FIRST AND THEN THE SKEW COMPONENTS
              if(ifiend16.eq.0) then
                read(16,10020,end=820,iostat=ierro) ch
                lineno16=lineno16+1
              else
                goto 820
              endif
              call intepr(3,1,ch,ch1) ! Read the name of element
! ilm0 are character strings, should be OK
              read(ch1,*) ilm0(1)
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)

              
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
! if fio is selected fort.16 is opened with round='nearest'
              read(16,*,end=870,iostat=ierro) extaux(1),extaux(2),      &
     &extaux(3)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(4),extaux(5),      &
     &extaux(6)
               lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(7),extaux(8),      &
     &extaux(9)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(10),extaux(11),    &
     &extaux(12)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(13),extaux(14),    &
     &extaux(15)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(16),extaux(17),    &
     &extaux(18)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(19),extaux(20)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(21),extaux(22),    &
     &extaux(23)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(24),extaux(25),    &
     &extaux(26)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(27),extaux(28),    &
     &extaux(29)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(30),extaux(31),    &
     &extaux(32)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(33),extaux(34),    &
     &extaux(35)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(36),extaux(37),    &
     &extaux(38)
              lineno16=lineno16+1
              read(16,*,end=870,iostat=ierro) extaux(39),extaux(40)
#endif
#ifdef CRLIBM
! Now my new loops for splitfld and fround (round_near)
      do k=1,16,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(19)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(20)=fround(errno,fields,2)
        nf=nf-1
      endif
      do k=21,36,3
        read(16,10020,end=870,iostat=ierro) ch
        lineno16=lineno16+1
        ch1(:nchars+3)=ch(:nchars)//' / '
        call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          extaux(k)=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+1)=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          extaux(k+2)=fround(errno,fields,3)
          nf=nf-1
        endif
      enddo
      read(16,10020,end=870,iostat=ierro) ch
      lineno16=lineno16+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call splitfld(errno,16,lineno16,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        extaux(39)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        extaux(40)=fround(errno,fields,2)
        nf=nf-1
      endif
#endif
#endif
              if(ierro.gt.0) call prror(80)
              iexread=1
              goto 840
  820         ifiend16=1
              if(iexnum.eq.0) call prror(80)
              do 830 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(80)
  830         continue
  840         continue
            endif ! closing if(iexread.eq.0) then
            if(ilm0(1).eq.bez(ix)) then
#ifdef DEBUG
!             call warr('ilm0(1)',0d0,1,i,0,0)
#endif
              icext(i)=ix
              do 850 k=1,40
                exterr(i,k)=extaux(k)
#ifdef DEBUG
!     call warr('extaux',extaux(k),i,k,0,0)
#endif
  850         continue
              iexread=0
              goto 860
            endif
          endif
  860   continue
  861   continue
        write(lout,*) '        From file fort.16 :',iexnum,             &
     &' values read in.'
        write(lout,*)
      endif
      if(mout3.eq.1) then
        write(lout,*)
        write(lout,*) '          Alignment errors read in ' ,           &
     &'from external file'
        write(lout,*)
        iexread=0
        ifiend8=0
        iexnum=0
        read(8,10020,end=1581)
        rewind 8
        do 1580 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
              ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(8,10020,end=1550,iostat=ierro) ch
                if(ierro.gt.0) call prror(86)
                lineno8=lineno8+1
              else
                goto 1550
              endif
              call intepr(1,1,ch,ch1)
!             write (*,*) 'ch:'//ch//':'
!             write (*,*) 'ch1:'//ch1//':'
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
              read(ch1,*,round='nearest')                               &
     & ilm0(1),alignx,alignz,tilt
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
              read(ch1,*) ilm0(1),alignx,alignz,tilt
#endif
#ifdef CRLIBM
              call splitfld(errno,8,lineno8,nofields,nf,ch1,fields)
              if (nf.gt.0) then
                read(fields(1),*) ilm0(1)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignx=fround(errno,fields,2)
                nf=nf-1
              endif
              if (nf.gt.0) then
                alignz=fround(errno,fields,3)
                nf=nf-1
              endif
              if (nf.gt.0) then
                tilt=fround(errno,fields,4)
                nf=nf-1
              endif
!             alignx=DBLE(SNGL(alignx))
!             alignz=DBLE(SNGL(alignz))
!             tilt=DBLE(SNGL(tilt))
!             call roundnulp(alignx,1024)
!             call roundnulp(alignz,1024)
!             call roundnulp(tilt,1024)
#endif
#endif
#ifdef DEBUG
!     call warr('ilm0(1)',0d0,1,0,0,0)
!     call warr('alignx',alignx,I,1,0,0)
!     call warr('alignz',alignz,I,2,0,0)
!     call warr('tilt',tilt,I,3,0,0)
#endif
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1570
 1550         ifiend8=1
              if(iexnum.eq.0) call prror(86)
              do 1560 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(86)
 1560         continue
 1570         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1580
            endif
          endif
 1580   continue
 1581   continue
        write(lout,*) '        From file fort.8 :',iexnum,              &
     &' values read in.'
        write(lout,*)
      endif
      izu=0
      iexnum=0
      if(mout4.eq.1) then
        read(30,10020,end=1591)
        rewind 30
        do 1590 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 1590
            if(kzz.eq.15) goto 1590
            izu=izu+3
            read(30,10020,end=1591,iostat=ierro) ch
            if(ierro.gt.0) call prror(87)
            lineno30=lineno30+1
            call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
            read(ch1,*,round='nearest')                                 &
     & ilm0(1),zfz(izu-2)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
            read(ch1,*) ilm0(1),zfz(izu-2)
#endif
            iexnum=iexnum+1
            if(kz(ix).eq.11) izu=izu+2*mmul
          endif
 1590   continue
        if(iexnum.gt.0) then
          write(lout,*)
          write(lout,*)'          Single (random) kick errors read in ',&
     &'from external file'
          write(lout,*)
          write(lout,*) '        From file fort.30 :',iexnum,           &
     &' values read in.'
          write(lout,*)
        endif
        iexread=0
        ifiend8=0
        iexnum=0
        rewind 30
        do 1593 i=1,mper*mbloz
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
            if(iexread.eq.0) then
 1595         ilm0(1)=' '
! READ IN HORIZONTAL AND VERTICAL MISALIGNMENT AND TILT
              if(ifiend8.eq.0) then
                read(30,10020,end=1594,iostat=ierro) ch
                if(ierro.gt.0) call prror(87)
                lineno30=lineno30+1
              else
                goto 1594
              endif
              call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
              read(ch1,*,round='nearest')                               &
     & ilm0(1),dummy,alignx,alignz,tilt
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
              read(ch1,*) ilm0(1),dummy,alignx,alignz,tilt
#endif
              if(((abs(alignx)+abs(alignz))+abs(tilt)).le.pieni)        &!hr05
     &goto 1595
              iexnum=iexnum+1
              bezext(iexnum)=ilm0(1)
              iexread=1
              goto 1596
 1594         ifiend8=1
              do 1597 j=1,iexnum
                if(bez(ix).eq.bezext(j)) call prror(87)
 1597         continue
 1596         continue
            endif
            if(ilm0(1).eq.bez(ix)) then
              icextal(i)=ix
              extalign(i,1)=alignx
              extalign(i,2)=alignz
              extalign(i,3)=tilt
              iexread=0
              goto 1593
            endif
          endif
 1593   continue
 1591   continue
      endif
      goto 110
  870 call prror(80)

!-----------------------------------------------------------------------
!  ORGANISATION OF RANDOM NUMBERS
!-----------------------------------------------------------------------
  880 write(lout,10130)
      write(lout,10350)

      do i=1,3
        do j=1,nele
          bezr(i,j)=idum !Initialize all bezr to idum=' '
        end do
      end do
      
  900 iorg=iorg+1
  910 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 910
      if(ch(:4).eq.next) goto 110
      call intepr(3,1,ch,ch1)
      ! bezr are character strings, should be OK
      read(ch1,*) idat,bezr(2,iorg),bezr(3,iorg)
      if(idat.ne.next) then !Isn't this already checked for above?
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).eq.idum)     &
     &        write(lout,10360) idat
         if(idat.ne.mult.and.idat.ne.idum.and.bezr(2,iorg).ne.idum)     &
     &        write(lout,10390) idat,bezr(2,iorg)
         if(idat.ne.mult)                                               &
     &        bezr(1,iorg)=idat
         if(idat.eq.mult.and.                                           &
     &        bezr(2,iorg).ne.idum.and.bezr(3,iorg).ne.idum) then
            write(lout,10400) bezr(2,iorg),bezr(3,iorg)
            im=im+1
            j0=0
            j1=0

            do i=1,il
               if(bez(i).eq.bezr(2,iorg)) j1=i
               if(bez(i).eq.bezr(3,iorg)) j0=i
            end do

            if(j0.eq.0.or.j1.eq.0.or.kz(j0).ne.11.or.kz(j1).ne.11)      &
     &              call prror(29)

            irm(j0)=im
            benkc(j0)=benkc(j1)
            r00(j0)=r00(j1)
            imo=irm(j1)
            nmu(j0)=nmu(j1)

            do i1=1,nmu(j0)
               bk0(im,i1)=bk0(imo,i1)
               bka(im,i1)=bka(imo,i1)
               ak0(im,i1)=ak0(imo,i1)
               aka(im,i1)=aka(imo,i1)
            end do

         endif
         goto 900
      endif
      write(lout,10130)
      goto 110
!-----------------------------------------------------------------------
!  ITERATION ERRORS FOR CLOSED ORBIT ,TUNE ADJUSTMENT AND CHROMATICITY
!-----------------------------------------------------------------------
  940 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 940
      endif
      if(ch(:4).eq.next) then
      iclr=0
      goto 110
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.1) read(ch1,*,round='nearest')                         &
     & itco,dma,dmap
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.1) read(ch1,*) itco,dma,dmap
#endif
#ifdef CRLIBM
      if(iclr.eq.1) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itco
        endif
        if (nf.gt.0) then
          dma=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dmap=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & itqv,dkq,dqq
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.2) read(ch1,*) itqv,dkq,dqq
#endif
#ifdef CRLIBM
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itqv
          nf=nf-1
        endif
        if (nf.gt.0) then
          dkq=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dqq=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & itcro,dsm0,dech
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.3) read(ch1,*) itcro,dsm0,dech
#endif
#ifdef CRLIBM
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) itcro
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsm0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dech=fround(errno,fields,3)
          nf=nf-1
        endif
      endif
#endif
#endif
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & de0,ded,dsi,aper(1),aper(2)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.4) read(ch1,*) de0,ded,dsi,aper(1),aper(2)
#endif
#ifdef CRLIBM
      if(iclr.eq.4) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          de0=fround(errno,fields,1)
        nf=nf-1
        endif
        if (nf.gt.0) then
          ded=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dsi=fround(errno,fields,3)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          aper(2)=fround(errno,fields,5)
          nf=nf-1
        endif
      endif
#endif
#endif
      if(iclr.ne.4) goto 940
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  APERTURE LIMITATIONS
!  A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!  JMolson (CERN, BE-ABP-HSS)
!  last modified: 02-03-2018
!  original LIMI block extended to deal with RectEllipse, Octagon and
!     RaceTrack aperture types, and with offset/tilting of profile
!  Possibility to read the apertures from external file with LOAD keyword
!-----------------------------------------------------------------------
  950 continue
!     LIMI block naturally activates backtracking, unless explicitly
!       requested by user
      lbacktracking=.true.
      loadunit=3 ! stream to fort.3
  951 continue
!     loadunit is initialised to 3 in aperture_comnul
      read(loadunit,10020,end=952,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 951 ! skip comment lines

      ! We don't support FIO, since it's not supported by any compilers...
#ifdef FIO
      write(lout,*)'ERROR in LIMI block: fortran IO format currently not supported!'
      call prror(-1)
#endif
      
!     P.G.Ortega and A.Mereghetti, 02-03-2018
!     'next': echo aperture profiles
      if(ch(:4).eq.next) then
        if ( limifound ) then
          write(lout,10320)
          call dump_aperture_header(lout)
          do ii=1,il
            if ( kape(ii).ne.0 ) call dump_aperture_marker( lout, ii, 1 )
          enddo
!         A.Mereghetti and P.Garcia Ortega, 12-06-2014
!         echo precision for back-tracking
          if (lbacktracking) then
            write(lout,*)' --> back-tracking at aperture LIMIs is on, with precision [m]:',bktpre
          else
            write(lout,*)' --> no back-tracking, only checks at aperture LIMIs'
          endif
        else
          write(lout,'(t10,"NO SINGLE ELEMENT IS ASSIGNED AN APETURE MODEL!")')
          lbacktracking=.false.
        endif
        if (mxsec.gt.0) then
           do i=1,mxsec
              if (sLocDel(i).eq.zero) sLocDel(i)=bktpre
           enddo
        endif
        goto 110

      else

        call getfields_split( ch, getfields_fields, getfields_lfields,getfields_nfields, getfields_lerr )
        if ( getfields_lerr ) then
          write(lout,*) 'ERROR in LIMI block: getfields_lerr=', getfields_lerr, ' at line: ',ch
          call prror(-1)
        endif

        if(ch(:4).eq.'LOAD') then
          ! P.G.Ortega and A.Mereghetti, 02-03-2018
          ! reading apertures from external file
          if(getfields_nfields.lt.3) then
            write(lout,*) 'ERROR in LIMI block: wrong number of input parameters for keyword LOAD: ninput = ', &
                          getfields_nfields, ' != 3 (min)'
            call prror(-1)
          endif
          read (getfields_fields(2)(1:getfields_lfields(2)),*) loadunit
          read (getfields_fields(3)(1:getfields_lfields(3)),*) load_file
          inquire( file=load_file, exist=lexist )
          if (.not.lexist ) then
             write(lout,*) "APERTURE LOAD FILE ",load_file," NOT FOUND IN THE RUNNING FOLDER"
             call prror(-1)
          endif
          open(loadunit,file=load_file,form='formatted') 
          write(lout,*) 'APERTURES READ FROM FILE: ',load_file,' - UNIT: ',loadunit

        elseif(ch(:4).eq.'PRIN') then
          ! P.G.Ortega and A.Mereghetti, 02-03-2018
          ! flag for dumping the aperture model
          if(getfields_nfields.lt.3) then
            write(lout,*)'ERROR in LIMI block: wrong number of input ',   &
     &         'parameters for keyword PRIN: ninput = ', getfields_nfields, ' != 3 (min)'
            call prror(-1)
          endif
          read (getfields_fields(2)(1:getfields_lfields(2)),*) aperunit
          read (getfields_fields(3)(1:getfields_lfields(3)),*) aper_filename
          ldmpaper  = .true.
          if(getfields_nfields.ge.4) then
             if (getfields_fields(4)(1:getfields_lfields(4)).eq.'MEM') then
                ldmpaperMem=.true.
             end if
          endif

        elseif(ch(:4).eq.'SAVE') then
          ! P.G.Ortega and A.Mereghetti, 02-03-2018
          ! flag for saving particles at aperture check
          apflag  = .true.

        elseif(ch(:10).eq.'BACKTRKOFF') then
          ! A.Mereghetti, 07-03-2018
          ! switch off back tracking
          lbacktracking=.false.

        elseif(ch(:4).eq.'PREC') then
          ! A.Mereghetti and P.Garcia Ortega, 02-03-2018
          ! set precision for back-tracking
          if(getfields_nfields.lt.2) then
            write(lout,*)'ERROR in LIMI block: wrong number of input ',   &
     &         'parameters for keyword PREC: ninput = ', getfields_nfields, ' != 2 (min)'
            call prror(-1)
          endif
#ifndef CRLIBM
          read (getfields_fields(2)(1:getfields_lfields(2)),*) tmplen
#endif
#ifdef CRLIBM
          tmplen=round_near (errno,getfields_lfields(2)+1, getfields_fields(2))
          if (errno.ne.0) call rounderr(errno,getfields_fields,2,tmplen)
#endif
          if ( tmplen.le.zero ) then
            write(lout,*) 'WARNING: Wrong precision value: ', tmplen
            write(lout,*) '  in LIMI input block, ignoring...'
            write(lout,*) '  Using default [m]: ', bktpre
          else
            bktpre = tmplen
          endif

        elseif(ch(:4).eq.'XSEC') then
          ! A.Mereghetti, 22-03-2018
          ! ask for xsec at specific locations
          ! example input line:        XSEC 155 myCrossSec.dat 12355.78 12356.78 0.1 180
          if(getfields_nfields.lt.4) then
            write(lout,*)'ERROR in LIMI block: wrong number of input ',   &
     &         'parameters for keyword XSEC: ninput = ', getfields_nfields, ' != 4 (min)'
            call prror(-1)
          endif
          mxsec=mxsec+1
          if (mxsec.gt.nxsec) then
            write(lout,*)'ERROR in LIMI block: too many xsecs! asked:',mxsec,' - max:',nxsec
            call prror(-1)
          end if
          read (getfields_fields(2)(1:getfields_lfields(2)),*) xsecunit(mxsec)
          read (getfields_fields(3)(1:getfields_lfields(3)),*) xsec_filename(mxsec)
#ifndef CRLIBM
          read (getfields_fields(4)(1:getfields_lfields(4)),*) sLocMin(mxsec)
#endif
#ifdef CRLIBM
          sLocMin(mxsec)=round_near (errno,getfields_lfields(4)+1, getfields_fields(4))
          if (errno.ne.0) call rounderr(errno,getfields_fields,4,sLocMin(mxsec))
#endif
          if (sLocMin(mxsec).lt.zero) then
             write(lout,*)'ERROR in LIMI block: negative min s-value for xsecs!'
             call prror(-1)
          endif
   
          if(getfields_nfields.ge.5) then
#ifndef CRLIBM
             read (getfields_fields(5)(1:getfields_lfields(5)),*) sLocMax(mxsec)
#endif
#ifdef CRLIBM
             sLocMax(mxsec)=round_near (errno,getfields_lfields(5)+1, getfields_fields(5))
             if (errno.ne.0) call rounderr(errno,getfields_fields,5,sLocMax(mxsec))
#endif
             if (sLocMax(mxsec).lt.zero) then
                write(lout,*)'ERROR in LIMI block: negative max s-value for xsecs!'
                call prror(-1)
             endif
          endif
          if(getfields_nfields.ge.6) then
#ifndef CRLIBM
             read (getfields_fields(6)(1:getfields_lfields(6)),*) sLocDel(mxsec)
#endif
#ifdef CRLIBM
             sLocDel(mxsec)=round_near (errno,getfields_lfields(6)+1, getfields_fields(6))
             if (errno.ne.0) call rounderr(errno,getfields_fields,6,sLocDel(mxsec))
#endif
             if (sLocDel(mxsec).lt.zero) sLocDel(mxsec)=-sLocDel(mxsec) ! increasing s-val
          endif
          if (sLocMax(mxsec).eq.zero) sLocMax(mxsec)=sLocMin(mxsec)
          if (sLocMax(mxsec).lt.sLocMin(mxsec)) then
             ! swap sMin and sMax
             tmpflts(1)=sLocMax(mxsec)
             sLocMax(mxsec)=sLocMin(mxsec)
             sLocMin(mxsec)=tmpflts(1)
          endif
          if(getfields_nfields.ge.7) read (getfields_fields(7)(1:getfields_lfields(7)),*) nAzimuts(mxsec)

        else

          read (getfields_fields(1)(1:getfields_lfields(1)),*) idat
          lapefound=.false.
          do j=1,il
            if(idat.eq.bez(j)) then
              lapefound=.true.
              read (getfields_fields(2)(1:getfields_lfields(2)),*) irel
              select case(irel)

              case (apeName(1)) !Circle
                if(getfields_nfields.lt.3) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(1)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 3 (min)'
                  call prror(-1)
                endif
                do i=1,1
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initCR( j, tmpflts(1) )
                
              case (apeName(2)) !Rectangle
                if(getfields_nfields.lt.4) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(2)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 4 (min)'
                  call prror(-1)
                endif
                do i=1,2
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initRE( j, tmpflts(1), tmpflts(2) )
                
              case (apeName(3)) !Ellipse
                if(getfields_nfields.lt.4) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(3)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 4 (min)'
                  call prror(-1)
                endif
                do i=1,2
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initEL( j, tmpflts(1), tmpflts(2) )
                
              case (apeName(4)) !Rectellipse
                if(getfields_nfields.lt.6) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(4)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 6 (min)'
                  call prror(-1)
                endif
                ! parse the float descriptors
                do i=1,4
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initRL( j, tmpflts(1), tmpflts(2), tmpflts(3), tmpflts(4) )
                
              case (apeName(5)) !Octagon  
                if(getfields_nfields.lt.6) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(5)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 6 (min)'
                  call prror(-1)
                endif
                do i=1,4
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initOC( j, tmpflts(1), tmpflts(2), tmpflts(3), tmpflts(4) )
                
              case (apeName(6)) !Racetrack
                if(getfields_nfields.lt.5) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(6)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 5 (min)'
                  call prror(-1)
                endif
                do i=1,3
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initRT( j, tmpflts(1), tmpflts(2), tmpflts(3) )
                
              case (apeName(-1)) !Transition
                if(getfields_nfields.lt.8) then
                  write(lout,*)'ERROR in LIMI block: wrong number of input parameters '//   &
           &        'for declaring a '//apeName(-1)//' aperture marker: ninput = ',          &
           &        getfields_nfields, ' != 8 (min)'
                  call prror(-1)
                endif
                do i=1,6
#ifndef CRLIBM
                  read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                  tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                  if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                enddo
                call aperture_initTR( j, tmpflts(1), tmpflts(2), tmpflts(3), tmpflts(4), tmpflts(5), tmpflts(6) )
                
              case default
                write(lout,*) 'Aperture profile not identified for element ',idat
                write(lout,*) '  value:', irel
                call prror(-1)
              end select

              if(kape(j).eq.-1)then
                do i=7,9
                  tmpflts(i)=zero
                  if(getfields_nfields.ge.i+2) then
#ifndef CRLIBM
                    read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i)
#endif
#ifdef CRLIBM
                    tmpflts(i)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                    if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i))
#endif
                  endif
                end do
              else 
                do i=5,7
                  tmpflts(i+2)=zero
                  if(getfields_nfields.ge.i+2) then
#ifndef CRLIBM
                    read (getfields_fields(i+2)(1:getfields_lfields(i+2)),*) tmpflts(i+2)
#endif
#ifdef CRLIBM
                    tmpflts(i+2)=round_near (errno,getfields_lfields(i+2)+1, getfields_fields(i+2))
                    if (errno.ne.0) call rounderr(errno,getfields_fields,i+2,tmpflts(i+2))
#endif
                  endif
                end do
              end if
              call aperture_initroffpos( j, tmpflts(7), tmpflts(8), tmpflts(9) )
              limifound=.true.
              exit
            end if
          end do

          if(.not.lapefound) then
            write(lout,*) 'WARNING: Unidentified element ', idat
            write(lout,*) '  in LIMI input block, ignoring...'
          end if
        end if ! specific non-NEXT keywords
      end if ! any non-NEXT keywords
      goto 951 ! go to next line to be parsed

  952 continue
      if ( loadunit.ne.3 ) then
        close(loadunit)
        goto 951
      endif
      goto 1530

!-----------------------------------------------------------------------
!  ORBIT CORRECTION
!-----------------------------------------------------------------------
  980 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 980
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & sigma0,ncorru,ncorrep
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) sigma0,ncorru,ncorrep
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        sigma0(1)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        sigma0(2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) ncorru 
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(3),*) ncorrep
        nf=nf-1
      endif
#endif
#endif
      iclo=1
  990 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 990
      iele=idum
      call intepr(4,1,ch,ch1)
! integers so should be OK
      read(ch1,*) idat,iele
      if(idat.eq.next) goto 110
      if(idat.ne.'HMON='.and.idat.ne.'HCOR='.and. idat.ne.'VMON='.and.  &
     &idat.ne.'VCOR=') call prror(44)
      if(idat.eq.'HMON='.or.idat.eq.'VMON=') goto 1010
      do 1000 j=1,il
      if(iele.ne.bez(j)) goto 1000
      if(idat.eq.'HCOR=') then
        if(kp(j).eq.-4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.1.and.kz(j).ne.11) call prror(82)
        kp(j)=4
      endif
      if(idat.eq.'VCOR=') then
        if(kp(j).eq.4.or.kp(j).eq.3.or.kp(j).eq.-3) call prror(83)
        if(kz(j).ne.-1.and.kz(j).ne.11) call prror(82)
        kp(j)=-4
      endif
 1000 continue
      goto 990
 1010 do 1020 j=1,il
      if(iele.ne.bez(j)) goto 1020
      if(idat.eq.'HMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.-3) call prror(83)
        kp(j)=3
      endif
      if(idat.eq.'VMON=') then
        if(kp(j).eq.4.or.kp(j).eq.-4.or.kp(j).eq.3) call prror(83)
        kp(j)=-3
      endif
 1020 continue
      goto 990

!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
 1030 ii=0

      do jj=1,ncom
        do ll=1,20
          icel(jj,ll)=idum
        end do
      end do 

      write(lout,10130)
      write(lout,10300)
 1050 ii=ii+1
      if(ii.gt.ncom) goto 1100
 1060 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1060
      if(ch(:4).eq.next) goto 110
      icoe=ii
      call intepr(5,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & idat,(ratio(ii,l),icel(ii,l),l=1,20)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) idat,(ratio(ii,l),icel(ii,l),l=1,20)
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

      if (nf.gt.0) then
        read(fields(1),*) idat
        nf=nf-1
      endif

      do l=1,20
        if (nf.gt.0) then
          ratio(ii,l)=fround(errno,fields,l*2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(l*2+1),*) icel(ii,l)
          nf=nf-1
        endif
      end do
#endif
#endif
      do j=1,il
        if(idat.ne.bez(j)) goto 1070
        kp(j)=5
        icomb0(ii)=j
        ratioe(j)=one

 1070   do l=1,20
          if(bez(j).eq.icel(ii,l)) then
            icomb(ii,l)=j
            ratioe(j)=ratio(ii,l)
          endif
        end do
      end do


      jj=icomb0(ii)
      if(jj.eq.0) goto 1050
      do 1090 m=1,20
        ico=icomb(ii,m)
        if(ico.eq.jj) call prror(92)
        if(ico.eq.0) goto 1090
        write(lout,10310) bez(jj),bez(ico),ratio(ii,m)
        iratioe(ico)=jj
        if(el(jj).le.pieni) then
          if(el(ico).le.pieni) then
            ed(ico)=ed(jj)*ratio(ii,m)
          else
            ek(ico)=ed(jj)*ratio(ii,m)
          endif
        else
          if(el(ico).le.pieni) then
            ed(ico)=ek(jj)*ratio(ii,m)
          else
            ek(ico)=ek(jj)*ratio(ii,m)
          endif
        endif
 1090 continue
      goto 1050
 1100 write(lout,10290) ncom
      goto 110
!-----------------------------------------------------------------------
!  SUBRESONANCE CALCULATION
!-----------------------------------------------------------------------
 1110 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1110
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & nta,nte,qxt,qzt,tam1,tam2,ipt,totl
#ifdef CRLIBM
      call enable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) nta,nte,qxt,qzt,tam1,tam2,ipt,totl
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nta
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nte
        qxt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,5)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,6)
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(7),*) ipt
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,8)
        nf=nf-1
      endif
#endif
#endif
      if(nta.lt.2) call prror(37)
      if(nte.lt.nta.or.nte.gt.9) call prror(37)
      isub=1
      goto 110

!-----------------------------------------------------------------------
!  RESONANCE-COMPENSATION
!-----------------------------------------------------------------------
 1120 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1120
      ch1(:nchars+3)=ch(:nchars)//' / '
! all integers so should be OK
      read(ch1,*) nre
      if(nre.ne.0) read(ch1,*) nre,npp,nrr(1),nrr(2),nrr(3),            &
     &ipr(1),ipr(2),ipr(3)
      if(nre.ne.0.and.(npp.lt.2.or.npp.gt.nrco)) call prror(46)
      if(nre.lt.0.or.nre.gt.3) call prror(47)
      if(abs(nrr(1)).gt.npp.or.abs(nrr(2)).gt.npp                       &
     &.or.abs(nrr(3)).gt.npp) call prror(48)
 1130 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1130
      ch1(:nchars+3)=ch(:nchars)//' / '
      read(ch1,*) nur
      if(nur.ne.0) read(ch1,*) nur,nu(1),nu(2),nu(3)
      if(nur.lt.0.or.nur.gt.3) call prror(49)
      if(nu(1).gt.9.or.nu(2).gt.9.or.nu(3).gt.9                         &
     &.or.nu(1).lt.0.or.nu(2).lt.0.or.nu(3).lt.0) call prror(50)
 1140 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1140
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & totl,qxt,qzt,tam1,tam2
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) totl,qxt,qzt,tam1,tam2
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        totl=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qxt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam2=fround(errno,fields,5)
        nf=nf-1
      endif
#endif
#endif
 1150 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1150
      call intepr(3,1,ch,ch1)
! ilm0 are character strings so should be OK
      read(ch1,*) (ilm0(i),i=1,6)
 1160 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1160
      call intepr(6,1,ch,ch1)
      read(ch1,*) nch
      if(nch.ne.0) read(ch1,*) nch,ilm0(7),ilm0(8)
 1170 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1170
      call intepr(7,1,ch,ch1)
      read(ch1,*) nqc
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(nqc.ne.0) read(ch1,*,round='nearest')                          &
     & nqc,ilm0(9),ilm0(10),qw0
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(nqc.ne.0) read(ch1,*) nqc,ilm0(9),ilm0(10),qw0
#endif
#ifdef CRLIBM
      if(nqc.ne.0) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) nqc
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) ilm0(9)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ilm0(10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(1)=fround(errno,fields,4)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qw0(2)=fround(errno,fields,4)
          nf=nf-1
        endif
      endif
#endif
#endif
      do 1190 k=1,10
      do 1180 j=1,il
        if(ilm0(k).ne.bez(j)) goto 1180
        ire(k)=j
        if(nre.eq.1.and.k.lt.3.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.2.and.k.lt.5.and.abs(kz(j)).ne.npp) call prror(39)
        if(nre.eq.3.and.k.lt.7.and.abs(kz(j)).ne.npp) call prror(39)
        if(nch.eq.1.and.(k.eq.7.or.k.eq.8).and.kz(j).ne.3) call prror   &
     &(11)
        if(nqc.eq.1.and.(k.eq.9.or.k.eq.10).and.kz(j).ne.2) call prror  &
     &(8)
        goto 1190
 1180 continue
      if((nre.eq.1.and.k.lt.3).or.(nre.eq.2.and.k.lt.5).or.             &
     &(nre.eq.3.and.k.lt.7).or.(nch.eq.1.and.(k.eq.7.or.k.eq.8)).or.    &
     &(nqc.eq.1.and.(k.eq.9.or.k.eq.10))) call prror(3)
 1190 continue
      irmod2=1
      goto 110

!-----------------------------------------------------------------------
!  SEARCH FOR OPTIMUM PLACES TO COMPENSATE RESONANCES
!-----------------------------------------------------------------------
 1200 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1200
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & qxt,qzt,tam1,tam2,totl
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) qxt,qzt,tam1,tam2,totl
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        qxt=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qzt=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        tam1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
          tam2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        totl=fround(errno,fields,5)
        nf=nf-1
      endif
#endif
#endif
 1210 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1210
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & mesa,mp,m21,m22,m23,ise1,ise2,ise3
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
      read(ch1,*) mesa,mp,m21,m22,m23,ise1,ise2,ise3
#endif
      if(mp.lt.2.or.mp.gt.9) call prror(37)
      if(abs(m21).gt.mp.or.abs(m22).gt.mp                               &
     &.or.abs(m23).gt.mp) call prror(48)
      ise=1
      k0=0

 1220 do m=1,40
        ilm0(m)=idum
      end do

 1240 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      lineno3=lineno3+1

      if(ch(1:1).eq.'/') goto 1240
      call intepr(3,1,ch,ch1)

! character strings so should be OK
      read(ch1,*) idat,(ilm0(m),m=2,40)
      if(idat.eq.next) goto 110
      ilm0(1)=idat
      ka=k0+1
      ke=k0+40
      do 1260 k=ka,ke
      if(k.gt.nele) call prror(2)
      if(k.gt.mesa) goto 110
      ki=k-k0
      if(ilm0(ki).eq.idum) goto 1270
      do 1250 j=1,il
        if(ilm0(ki).ne.bez(j)) goto 1250
        isea(k)=j
        if(abs(kz(j)).ne.mp) call prror(39)
        goto 1260
 1250 continue
      call prror(3)
 1260 continue
 1270 k0=k-1
      goto 1220

!-----------------------------------------------------------------------
!  POSTPROCESSING
!-----------------------------------------------------------------------
 1280 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 
      if(ch(1:1).ne.'/') then
      iclr=iclr+1
      else
      goto 1280
      endif
      ch1(:83)=ch(:80)//' / '

      !Line 1
      if(iclr.eq.1) toptit(1)=ch
      
      
      !Line 2
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.2) read(ch1,*,round='nearest')                         &
     & iav,nstart,nstop,iwg,dphix,dphiz,                                &
     &iskip,iconv,imad,cma1,cma2
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.2) read(ch1,*) iav,nstart,nstop,iwg,dphix,dphiz,       &
     &iskip,iconv,imad,cma1,cma2
#endif
#ifdef CRLIBM
      if(iclr.eq.2) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          read(fields(1),*) iav
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(2),*) nstart
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) nstop
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) iwg
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphix=fround(errno,fields,5)
          nf=nf-1
        endif
        if (nf.gt.0) then
          dphiz=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(8),*) iconv
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(9),*) imad
        nf=nf-1
        endif
        if (nf.gt.0) then
          cma1=fround(errno,fields,10)
          nf=nf-1
        endif
        if (nf.gt.0) then
          cma2=fround(errno,fields,11)
          nf=nf-1
        endif
      endif
#endif
#endif

      !Line 3
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.3) read(ch1,*,round='nearest')                         &
     & qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      if(iclr.eq.3) read(ch1,*) qx0,qz0,ivox,ivoz,ires,dres,ifh,dfft
#endif
#ifdef CRLIBM
      if(iclr.eq.3) then
        call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
        if (nf.gt.0) then
          qx0=fround(errno,fields,1)
          nf=nf-1
        endif
        if (nf.gt.0) then
          qz0=fround(errno,fields,2)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(3),*) ivox
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(4),*) ivoz
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(5),*) ires
          nf=nf-1
        endif
        if (nf.gt.0) then
          dres=fround(errno,fields,6)
          nf=nf-1
        endif
        if (nf.gt.0) then
          read(fields(7),*) ifh
          nf=nf-1
        endif
        if (nf.gt.0) then
          dfft=fround(errno,fields,8)
          nf=nf-1
        endif
      endif
#endif
#endif

      !Line 4
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & kwtype,itf,icr,idis,icow,istw,iffw,                              &
     &nprint,ndafi
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
      if(iclr.eq.4) read(ch1,*) kwtype,itf,icr,idis,icow,istw,iffw,     &
     &nprint,ndafi
#endif

#ifdef STF
      if (imad.eq.1) then
         write(lout,*) "ERROR in daten::POST:"
         write(lout,*) "imad not supported for STF version."
         call prror(-1)
      endif
#endif
      
      kwtype=0
      icr=0
      if(iskip.le.0) iskip=1
      if(iclr.ne.4) goto 1280
      if(nprint.ne.1) nprint=0
      iclr=0
      if(nstart.lt.0) nstart=0
      if(nstop.lt.0) nstop=0
      if(nstop.lt.nstart) then
         nstart=0
         nstop=0
      endif
      if(iconv.ne.1) iconv=0
      if(abs(cma1).le.pieni) cma1=one
      cma1=cma1*c1e3
      if(abs(cma2).le.pieni) cma2=one
      ipos=1
      goto 110
!-----------------------------------------------------------------------
!  POWER SUPPLY RIPPLE
!-----------------------------------------------------------------------
 1290 continue
      write(lout,*)
      write(lout,*) "ERROR: old RIPP module is no longer supported"
      write(lout,*) "Please convert your RIPP block (in fort.3) to DYNK"
      write(lout,*) "The script rippconvert.py (in the pytools folder)"
      write(lout,*) " can be used to automatically convert the fort.3!"
      write(lout,*)
      call prror(-1)

!Code for just skipping over the RIPP block, which runs the simulation without RIPP:
 1300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)

      write(lout,*) 'ignoring line:'
      write(lout,*) ch
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1300
      if(ch(:4).eq.next) goto 110
      goto 1300
!-----------------------------------------------------------------------
!  DECOUPLING ROUTINE
!-----------------------------------------------------------------------
 1320 iskew=1
 1330 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1330
      call intepr(3,1,ch,ch1)
! character strings again
      read(ch1,*) idat,(ilm0(m),m=2,4)
      if(idat.eq.next) then
      iskew=0
      goto 110
      endif
      ilm0(1)=idat
      do 1350 i=1,2
 1340 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1340
      if(ch(:4).eq.next) then
        iskew=2
        goto 1360
      endif
      call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & ilm0(4+i),qwsk(i)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) ilm0(4+i),qwsk(i)
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) ilm0(4+i)
        nf=nf-1
      endif
      if (nf.gt.0) then
        qwsk(i)=fround(errno,fields,2)
        nf=nf-1
      endif
#endif
#endif
 1350 continue
 1360 continue

      do i=1,6
      do j=1,il
        if(iskew.eq.2.and.i.gt.4) goto 1380
        if(ilm0(i).eq.bez(j)) then
          if(i.le.4) then
            if(kz(j).ne.-2) call prror(62)
          else
            if(kz(j).ne.2) call prror(8)
          endif
          nskew(i)=j
          do i2=1,6
            if(nskew(i2).ne.0.and.(nskew(i2).eq.nskew(i)) .and.(i2.ne.i)&
     &) call prror(63)
          end do
        endif
      end do
      end do
 1380 continue
      goto 110

!GRD-----------------------------------------------------------------------
!  COLLIMATION INPUT BLOCK
!GRD-----------------------------------------------------------------------
 1285 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1

#ifdef COLLIMAT
      has_coll = .true. !We have a collimation block.
      if (ilin.ne.1) then
         write(lout,*) "ERROR DETECTED:"
         write(lout,*) "Incompatible flag with collimation version"
         write(lout,*) "detected in the LINEAR OPTICS block."
         write(lout,*) ""
         write(lout,*) "You have not chosen ilin=1 (4D mode),"
         write(lout,*) "which is required for the collimation version."
         write(lout,*) ""
         write(lout,*) "Note that the ilin=2 (6D mode) is not"
         write(lout,*) "compatible with the collimation version."
         write(lout,*) ""
         write(lout,*) "Current setting ilin=",ilin
         call prror(-1)
      endif
#endif

      if(ch(1:1).ne.'/') then
         iclr=iclr+1
      else
         goto 1285
      endif
      ch1(:nchars+3)=ch(:nchars)//' / '
      
#ifndef COLLIMAT
      if (iclr.eq.1) then
         read(ch1,*) do_coll
         if (do_coll) then
           write(lout,*)
           write(lout,*) "ERR> Collimation not forseen in this version;"
           write(lout,*) "ERR> Please use proper version"
           write(lout,*) "ERR> or set do_coll to .FALSE."
           write(lout,*)
           call prror(-1)
         endif
      endif
#endif

#ifdef COLLIMAT
!APRIL2005
#ifdef FIO
      if(iclr.eq.1) read(ch1,*,round='nearest') do_coll !Does not make sense with round=nearest: do_coll is a logical...
#endif
#ifndef FIO
      if(iclr.eq.1) read(ch1,*) do_coll
#endif
      
#ifdef FIO
      if(iclr.eq.2) read(ch1,*,round='nearest') nloop, myenom
#endif
#ifndef FIO
      if(iclr.eq.2) read(ch1,*) nloop, myenom
#endif
      if(nloop.ne.1) then
        write(lout,*) "The number of samples/(loops) is now limited to 1. Please use 1 sample and more particles per sample!"
        call prror(-1)
      end if

      !Note: After daten, napx = napx*2; in daten napx is the number of particle pairs.
      if(iclr.eq.2 .and. nloop*napx*2.gt.maxn) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "nloop =", nloop
         write(lout,*) "napx  =", napx,"(-> napx*2=",napx*2,"particles)"
         write(lout,*) "maxn  =", maxn
         write(lout,*) "mynp  = nloop*napx*2 =",nloop*napx*2,"> maxn"
         write(lout,*) "Please reduce the number of particles or loops"
         write(lout,*) ""
         
         call prror(-1)
      endif

      if(iclr.eq.2 .and. napx*2.ge.100 .and. nloop.gt.1) then
         write(lout,*) ""
         write(lout,*) "Error when parsing COLL block in fort.3"
         write(lout,*) "If nloop > 1 then you must have napx*2 < 100"
         write(lout,*) " or else the particle numbers in the"
         write(lout,*) " output gets confused."
         write(lout,*) "napx  = ", napx
         write(lout,*) "nloop = ", nloop
         
         call prror(-1)
      endif
      
#ifdef FIO
      if(iclr.eq.3) read(ch1,*,round='nearest') do_thisdis,mynex,mdex,myney,mdey,&
#endif
#ifndef FIO
      if(iclr.eq.3) read(ch1,*) do_thisdis,mynex,mdex,myney,mdey,       &
#endif
     &filename_dis,enerror,bunchlength
!JUNE2005
!UPGRADE JANUARY 2005
#ifdef FIO
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        &
!     & NSIG_PRIM,NSIG_SEC
#endif
#ifndef FIO
!      if(iclr.eq.4) read(ch1,*) NSIG_PRIM,NSIG_SEC
#endif
#ifdef FIO
!      if(iclr.eq.4) read(ch1,*,round='nearest')                        
!     & nsig_prim,nsig_sec,nsig_ter
#endif
#ifndef FIO
!      if(iclr.eq.4) read(ch1,*) nsig_prim,nsig_sec,nsig_ter
#endif
#ifdef FIO
      if(iclr.eq.4) read(ch1,*,round='nearest')                         &
     & do_nsig,                                                         &
#endif
#ifndef FIO
      if(iclr.eq.4) read(ch1,*) do_nsig,                                &
#endif
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,             &
     &nsig_tcli,                                                        &
!     &nsig_tcth,nsig_tctv,                                              &
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi
#ifdef FIO
      if(iclr.eq.5) read(ch1,*,round='nearest')                         &
#endif
#ifndef FIO
      if(iclr.eq.5) read(ch1,*)                                         &
#endif
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
     &nsig_tcxrp,nsig_tcryo
#ifdef FIO
      if(iclr.eq.6) read(ch1,*,round='nearest')                         &
     & n_slices,smin_slices,smax_slices,                                &
#endif
#ifndef FIO
      if(iclr.eq.6) read(ch1,*) n_slices,smin_slices,smax_slices,       &
#endif
     &recenter1,recenter2
#ifdef FIO
      if(iclr.eq.7) read(ch1,*,round='nearest')                         &
#endif
#ifndef FIO
      if(iclr.eq.7) read(ch1,*)                                         &
#endif
     & fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1
#ifdef FIO
      if(iclr.eq.8) read(ch1,*,round='nearest')                         &
#endif
#ifndef FIO
      if(iclr.eq.8) read(ch1,*)                                         &
#endif
     & fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2
!
#ifdef FIO
      if(iclr.eq.9) read(ch1,*,round='nearest')                         &
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
#endif
#ifndef FIO
      if(iclr.eq.9) read(ch1,*)                                         &
     & emitnx0_dist,emitny0_dist,emitnx0_collgap,emitny0_collgap
#endif
#ifdef FIO
      if(iclr.eq.10) read(ch1,*,round='nearest')                        &
     & do_select,do_nominal,                  &
#endif
#ifndef FIO
      if(iclr.eq.10) read(ch1,*) do_select,do_nominal,                  &
#endif
     &rnd_seed,dowrite_dist,name_sel,do_oneside,                        &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude
#ifdef FIO
      if(iclr.eq.11) read(ch1,*,round='nearest')                        &
     & xbeat,xbeatphase,ybeat,                                          &
#endif
#ifndef FIO
      if(iclr.eq.11) read(ch1,*) xbeat,xbeatphase,ybeat,                &
#endif
     &ybeatphase
!AUGUST2006 ADDED offset variables for mechanical errors    ---- TW
!JANUAR2007 added rms error for gap and switch to min gap   ---- TW
#ifdef FIO
      if(iclr.eq.12) read(ch1,*,round='nearest')                        &
     & c_rmstilt_prim,c_rmstilt_sec,                                    &
#endif
#ifndef FIO
      if(iclr.eq.12) read(ch1,*) c_rmstilt_prim,c_rmstilt_sec,          &
#endif
     &c_systilt_prim,c_systilt_sec,c_rmsoffset_prim,c_rmsoffset_sec,    &
     &c_sysoffset_prim,c_sysoffset_sec,c_offsettilt_seed,               &
     &c_rmserror_gap,do_mingap
#ifdef FIO
      if(iclr.eq.13) read(ch1,*,round='nearest')                        &
     & radial,nr,ndr
#endif
#ifndef FIO
      if(iclr.eq.13) read(ch1,*) radial,nr,ndr
#endif
#ifdef FIO
      if(iclr.eq.14) read(ch1,*,round='nearest')                        &
     & driftsx,driftsy,cut_input,                                       &
#endif
#ifndef FIO
      if(iclr.eq.14) read(ch1,*) driftsx,driftsy,cut_input,             &
#endif
     &systilt_antisymm
!AUGUST2006 ADDED rmsx, rmsy and distr. type for pencil beam ---- TW
#ifdef FIO
      if(iclr.eq.15) read(ch1,*,round='nearest')                        &
     &                                                                  &
#endif
#ifndef FIO
      if(iclr.eq.15) read(ch1,*)                                        &
#endif
     &ipencil,pencil_offset,pencil_rmsx,pencil_rmsy,pencil_distr
!APRIL2005
#ifdef G4COLLIMAT
      if(ipencil.gt.0) then
        write(lout,*) 'pencil distribution not supported with geant4'
        call prror(-1)
      endif
#endif
#ifdef FIO
      if(iclr.eq.16) read(ch1,*,round='nearest')                        &
     & coll_db,ibeam
#endif
#ifndef FIO
      if(iclr.eq.16) read(ch1,*) coll_db,ibeam
#endif
!APRIL2005
#ifdef FIO
      if(iclr.eq.17) read(ch1,*,round='nearest')                        &
     & dowritetracks, cern, castordir,                                  &
#endif
#ifndef FIO
      if(iclr.eq.17) read(ch1,*) dowritetracks, cern, castordir,        &
#endif
     &jobnumber, sigsecut2, sigsecut3
!
#endif

!     Use this code for both collimat and non-collimat
      if(iclr.ne.17) goto 1285
 1287 continue
      iclr=0
      goto 110
!-----------------------------------------------------------------------
!  NORMAL FORMS
!-----------------------------------------------------------------------
 1400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1400
      if(ch(:4).eq.next) then
      goto 110
      else
      if(idial.eq.0.and.numl.ne.0) then
        write(lout,10130)
        write(lout,*)
        call prror(78)
      endif
      inorm=1
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
      read(ch1,*,round='nearest')                                       &
     & nordf,nvarf,nord1,idptr
#endif
#ifndef FIO
      read(ch1,*) nordf,nvarf,nord1,idptr
#endif
      if(nord.ne.0.and.nordf.gt.nord+1) imod1=1
      if(nvar.ne.0.and.nvarf.gt.nvar) then
        nvarf=nvar
        imod2=1
      endif
      if(idptr.lt.0.or.idptr.gt.6) idptr=0
      endif
!-----------------------------------------------------------------------
!  TUNESHIFT CORRECTIONS
!-----------------------------------------------------------------------
 1410 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1410
      if(ch(:4).eq.next) goto 110
      icorr=1
      ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
      read(ch1,*,round='nearest') nctype,ncor
#endif
#ifndef FIO
      read(ch1,*) nctype,ncor
#endif
      if(ncor.gt.mcor) call prror(65)
      if(ncor.gt.0) then
      read(3,10020,end=1530,iostat=ierro) ch
      lineno3=lineno3+1
      ch1(:nchars+3)=ch(:nchars)//' / '
      call intepr(3,1,ch,ch1)
! coel are character strings so should be OK
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest') (coel(i),i=1,ncor)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
      read(ch1,*) (coel(i),i=1,ncor)
#endif
      do 1430 j1=1,ncor
        do 1420 j2=1,il
          if(coel(j1).eq.bez(j2)) then
            if(el(j2).ne.zero.or.kz(j2).gt.10) call prror(67)
            ipar(j1)=j2
            goto 1430
          endif
 1420   continue
        call prror(66)
 1430 continue
      else
      call prror(70)
      endif
      if(nctype.eq.0) then
      read(3,*) namp,nmom,dummy,dummy,dummy
      lineno3=lineno3+1
      if(namp+nmom.eq.0) call prror(71)
      if(namp*nmom.ne.0) call prror(72)
      if(namp.lt.0.or.namp.gt.2) call prror(73)
      if(nmom.lt.0.or.nmom.eq.1.or.nmom.gt.3) call prror(74)
      if(namp.eq.1.or.nmom.eq.2) then
        nord=6
      else
        nord=7
      endif
      else
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(3,*, round='nearest') nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(3,*) nmom1,nmom2,weig1,weig2,dpmax
      lineno3=lineno3+1
#endif
#ifdef CRLIBM
      read(3,*) ch1
      lineno3=lineno3+1
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        read(fields(1),*) nmom1
        nf=nf-1
      endif
      if (nf.gt.0) then
        read(fields(2),*) nmom2
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig1=fround(errno,fields,3)
        nf=nf-1
      endif
      if (nf.gt.0) then
        weig2=fround(errno,fields,4)
        nf=nf-1
      endif
      if (nf.gt.0) then
        dpmax=fround(errno,fields,5)
        nf=nf-1
      endif
#endif
#endif
      if(nmom1.lt.2.or.nmom1.gt.3) call prror(75)
      if(nmom1.gt.nmom2) call prror(76)
      if(nmom2.lt.2.or.nmom2.gt.3) call prror(77)
      nord=2*(nmom2+1)
      endif
!-----------------------------------------------------------------------
      idial=1
      numlr=0
      napx=1
      imc=1
      preda=1.d-38
      nsix=1
      nvar=5
      nvar2=nvar
      nvar=nvar2+ncor
!-----------------------------------------------------------------------
      inorm=1
      nordf=nord+1
      nvarf=nvar
!-----------------------------------------------------------------------
      goto 1410
!-----------------------------------------------------------------------
!  Beam-Beam Element
!-----------------------------------------------------------------------
      ! ! ! Read 1st line of BEAM block ! ! !
 1600 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1600
      if(ch(:4).eq.next) goto 110

      if (nbeam.ge.1) then
         write(lout,*)                                                  &
     &        "ERROR: There can only be one BEAM block in fort.3"
         call prror(-1)
      endif
      
      if (ch(:6) .eq."EXPERT") then
         beam_expflag = 1
         
 1601    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1601
         if(ch(:4).eq.next) goto 110
         ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
         call enable_xp()
#endif
         read(ch1,*,round='nearest')                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
#ifdef CRLIBM
         call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
         read(ch1,*)                                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
#endif
#ifdef CRLIBM
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')                                        &
     &           "First line should have 9 fields, got", nf
            call prror(-1)
         endif
         
         partnum = fround(errno,fields,1)
         emitnx  = fround(errno,fields,2)
         emitny  = fround(errno,fields,3)
         sigz    = fround(errno,fields,4)
         sige    = fround(errno,fields,5)
         read(fields(6),*) ibeco
         read(fields(7),*) ibtyp
         read(fields(8),*) lhc
         read(fields(9),*) ibbc
#endif
#endif
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset !Initialize complex error function for FAST BB kick

         ! ! ! Read other lines of BEAM block ! ! !
 1660    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1660
         if(ch(:4).eq.next) goto 110

#ifdef FIO
!+if crlibm
!         call enable_xp()
!+ei
!         read(ch1,*,round='nearest')                                       &
!     &      idat,i,xang,xplane,separx,separy,
!     &      mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8, &
!     &      mm9,mm10,mm11
!+if crlibm
!         call disable_xp()
!+ei
        write(lout,*)                                                   &
     &       'ERROR in BEAM block (EXPERT mode): '//                    &
     &       'fortran IO currently not supported.'
        call prror(-1)
#endif
#ifndef FIO
#ifndef CRLIBM
         call intepr(1,1,ch,ch1)
         read(ch1,*) idat,i

         if (i.gt.0) then !6D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            read(ch,*) mm1,mm2,mm3,mm4,mm5
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            read(ch,*) mm6,mm7,mm8,mm9,mm10,mm11
            
         else if (i.eq.0) then  !4D
            call intepr(1,1,ch,ch1)
            read(ch1,*) idat,i,xang,xplane,separx,separy
         else
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')                                  &
     &           "Expected number of slices >= 0; but got",             &
     &           i, " in element ",idat
            call prror(-1)
         endif
#endif
#ifdef CRLIBM
         call intepr(1,1,ch,ch1)
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (.not.(nf.eq.6 .or. nf.eq.7)) then
            write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
            write(lout,'(a,I3)')                                        &
     &           "First line of an element definition should "//        &
     &           "have 6 or 7 fields, got", nf
            call prror(-1)
         endif
         
         read(fields(2),*) i !read number of slices
         
         if (i.gt.0) then  !6D
            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "First line of a 6D element definition should "//   &
     &              "have 6 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat !Name
            read(fields(2),*) i    !slices (ibsix)
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            
 1661       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1661
            ch1(:nchars+3)=ch(:nchars)//' / '
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.5) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "Second line of a 6D element definition should "//  &
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm1=fround(errno,fields,1)
            mm2=fround(errno,fields,2)
            mm3=fround(errno,fields,3)
            mm4=fround(errno,fields,4)
            mm5=fround(errno,fields,5)
            
 1662       read(3,10020,end=1530,iostat=ierro) ch
            if(ierro.gt.0) call prror(58)
            ch1(:nchars+3)=ch(:nchars)//' / '
            lineno3=lineno3+1
            if(ch(1:1).eq.'/') goto 1662
            call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)

            if (nf.ne.6) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "Third line of a 6D element definition should "//   &
     &              "have 5 fields, got", nf
               call prror(-1)
            endif
            
            mm6=fround(errno,fields,1)
            mm7=fround(errno,fields,2)
            mm8=fround(errno,fields,3)
            mm9=fround(errno,fields,4)
            mm10=fround(errno,fields,5)
            mm11=fround(errno,fields,6)
            
         else if(i.eq.0) then ! 4D
            if (nf.ne.7) then
               write(lout,'(a)') "ERROR in DATEN reading BEAM::EXPERT"
               write(lout,'(a,I3)')                                     &
     &              "First line of a 6D element definition should "//   &
     &              "have 7 fields, got", nf
               call prror(-1)
            endif
            
            read(fields(1),*) idat
            xang=fround(errno,fields,3)
            xplane=fround(errno,fields,4)
            separx=fround(errno,fields,5)
            separy=fround(errno,fields,6)
            mm1=fround(errno,fields,7)
         else
            read(fields(1),*) idat
            write(lout,'(a)') "ERROR when reading BEAM block:"
            write(lout,'(a,i5,a,a16)')                                  &
     &           "Expected number of slices >= 0; but got",             &
     &           i, " in element ",idat
            call prror(-1)
         endif
#endif
#endif
         
         do j=1,il !loop over single lements
            if(idat.eq.bez(j)) then
               if(kz(j).ne.20) then
                  write(lout,'(a)') "ERROR when reading BEAM block:"
                  write(lout,'(a,a16,a,i5,a)')                          &
     &                 "Found element named ",bez(j),                   &
     &                 " but type is",kz(j), ", expected type 20!"
                  call prror(-1)
               else
                  
                  if(parbe(j,5).ne.zero .or. parbe(j,6).ne.zero         &
     &                 .or. ptnfac(j).ne.zero                           &
     &                 .or. bbbx(j).ne.zero .or. bbby(j).ne.zero        &
     &                 .or. bbbs(j).ne.zero ) then
                     !Note: Data moved from ed/ek/el to parbe/ptnfac in initialize_element
                     write(lout,'(a)') "ERROR when reading BEAM block:"
                     write(lout,'(a,a16,a)')                            &
     &                    "Using EXPERT mode, but element ", bez(j),    &
     &                    " does not have ed=ek=el=bbbx=bbby=bbbs=0.0"//&
     &                    " in the SINGLE ELEMENTS list."
                     call prror(-1)
                  endif
                  if (i.gt.0) then ! 6D, allow 1 or more slices
                     parbe(j,17)=1      ! Is 6D
                     parbe(j,2)=real(i,fPrec) ! Number of slices
                     parbe(j,1)=xang
                     parbe(j,3)=xplane
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     parbe(j,7)=mm1
                     parbe(j,8)=mm2
                     parbe(j,9)=mm3
                     parbe(j,10)=mm4
                     parbe(j,11)=mm5
                     parbe(j,12)=mm6
                     parbe(j,13)=mm7
                     parbe(j,14)=mm8
                     parbe(j,15)=mm9
                     parbe(j,16)=mm10
                     ptnfac(j)=mm11
                     goto 1660
                  else if(i.eq.0) then ! 4D, single slice only
                     parbe(j,17)=0      ! Type is 4D
                     parbe(j,2)=real(i,fPrec) ! Number of slices is always 0
                     parbe(j,1)=xang    ! not the crossing angle but sigmaxx
                     parbe(j,3)=xplane  ! not the xplane but sigmayy
                     parbe(j,5)=separx
                     parbe(j,6)=separy
                     ptnfac(j)=mm1
                     goto 1660
                  endif
               endif
            endif
         end do
         goto 1660
         
      else ! Old-style BEAM block
         write (lout,'(a)') "READING OLD-STYLE BEAM BLOCK"
         write (lout,'(a)') " Check the file 'beam_expert.txt'"//       &
     &        " for conversion to the new 'EXPERT' format."
         write (lout,'(a)') " To convert to the new format,"//          &
     &        " copy-paste these lines into the BEAM"//                 &
     &        " block in fort.3, replacing line 2 onwards."
         write (lout,'(a)') " Then write EXPERT on the first line"//    &
     &        " of the BEAM block, above the current first line."
         write(lout,'(a)') " Finally, in the SINGLE ELEMENTS list"//    &
     &        " (normally in fort.2) set the parameters of all"//       &
     &        " beam-beam lenses (type 20) to 0.0."
         write(lout,'(a)') " "
         write(lout,'(a)') " This procedure produces a new"//           &
     &        " set of input files that should have bit-for-bit"//      &
     &        " identical results to this one."
         write(lout,'(a)') " The easiest way to check this is"//        &
     &        " to run both simulations side-by-side and compare"//     &
     &        " the standard output in a text diff tool like meld."
         write(lout,'(a)') " If the results are not identical,"//       &
     &        " this is a bug; please report it to the developers!"
#ifndef CRLIBM
         write(lout,'(a)') " "
         write(lout,'(a)') "NOTE: THIS SIXTRACK BINARY WAS"//           &
     &        " NOT COMPILED WITH CRLIBM, CONVERSION WILL NOT BE EXACT."
#endif
         write(lout,'(a)') " "
         
         ch1(:nchars+3)=ch(:nchars)//' / '
#ifdef FIO
#ifdef CRLIBM
         call enable_xp()
#endif
         read(ch1,*,round='nearest')                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
#ifdef CRLIBM
         call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
         read(ch1,*)                                                    &
     &      partnum,emitnx,emitny,sigz,sige,ibeco,ibtyp,lhc,ibbc
#endif
#ifdef CRLIBM
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.ne.9) then
            write(lout,'(a)')                                           &
     &           "WARNING in DATEN reading BEAM (not EXPERT)"
            write(lout,'(a,i4)') "First line should have 9 fields,"//   &
     &           " got ", nf
            !Treating this as a warning, or else we would invalidate
            !lots of working input files
            !call prror(-1)
         endif
         
         if (nf.gt.0) then
            partnum=fround(errno,fields,1)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitnx=fround(errno,fields,2)
            nf=nf-1
         endif
         if (nf.gt.0) then
            emitny=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sigz=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            sige=fround(errno,fields,5)
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(6),*) ibeco
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(7),*) ibtyp
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(8),*) lhc
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(9),*) ibbc
            nf=nf-1
         endif
#endif
#endif
         if(emitnx.le.pieni.or.emitny.le.pieni) call prror(88)
         if(ibeco.ne.0.and.ibeco.ne.1) ibeco=1
         if(ibtyp.ne.0.and.ibtyp.ne.1) ibtyp=0
         if((lhc.ne.0).and.(lhc.ne.1).and.(lhc.ne.2)) lhc=1
         if(ibbc.ne.0.and.ibbc.ne.1) ibbc=0
         nbeam=1
         if(ibtyp.eq.1) call wzset
         
         ! ! ! Read other lines of BEAM block ! ! !
 1610    read(3,10020,end=1530,iostat=ierro) ch
         if(ierro.gt.0) call prror(58)
         lineno3=lineno3+1
         if(ch(1:1).eq.'/') goto 1610
         if(ch(:4).eq.next) goto 110  ! Done yet?

         !Check number of arguments gotten
         call getfields_split( ch, getfields_fields, getfields_lfields, &
     &        getfields_nfields, getfields_lerr )
         if ( getfields_lerr ) call prror(-1)
         beam_xstr = .false.
         if (getfields_nfields .eq. 5) then
            beam_xstr=.true.
         elseif (getfields_nfields .eq. 4) then
            beam_xstr=.false.
         else
            write(lout,*) "ERROR in parsing BEAM block"
            write(lout,*) "Number of arguments in data line 2,..."
            write(lout,*) " is expected to be 4 or 5"
            call prror(-1)
         end if
         call intepr(1,1,ch,ch1)
#ifdef FIO
#ifdef CRLIBM
         call enable_xp()
#endif
         read(ch1,*,round='nearest')                                       &
     &      idat,i,xang,xplane,xstr
#ifdef CRLIBM
         call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
         read(ch1,*) idat,i,xang,xplane,xstr
#endif
#ifdef CRLIBM
         call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
         if (nf.gt.0) then
            read(fields(1),*) idat
            nf=nf-1
         endif
         if (nf.gt.0) then
            read(fields(2),*) i
            nf=nf-1
         endif
         if (nf.gt.0) then
            xang=fround(errno,fields,3)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xplane=fround(errno,fields,4)
            nf=nf-1
         endif
         if (nf.gt.0) then
            xstr=fround(errno,fields,5)
            nf=nf-1
         endif
#endif
#endif
         if ( .not. beam_xstr ) then
            write(lout,*) "WARNING in parsing BEAM block"
            write(lout,*) "No xstr present, assuming xstr=xang"
            xstr = xang
         endif
      
         if(i.lt.0) i=0
         do 1620 j=1,il
            if(idat.eq.bez(j).and.kz(j).eq.20) then
               ibb6d=1
               parbe(j,2)=real(i,fPrec) !hr12
               parbe(j,1)=xang
               parbe(j,3)=xplane
               parbe(j,18)=xstr
               goto 1610
            endif
 1620    continue
         goto 1610
      endif
!-----------------------------------------------------------------------
!  TROMBONE ELEMENT KZ=22
!-----------------------------------------------------------------------
 1700 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1700
      if(ch(:4).eq.next) goto 110
      call intepr(1,1,ch,ch1)
#ifdef FIO
      read(ch1,*,round='nearest')                                       &
     & imn
#endif
#ifndef FIO
      read(ch1,*) imn
#endif
      imtr0=imtr0+1
      if(imtr0.gt.ntr) call prror(100)
      do 1710 j=1,il
        if(imn.eq.bez(j)) then
          imtr(j)=imtr0
          goto 1720
        endif
 1710 continue
      call prror(98)
 1720 j1=0
      if(imtr0.eq.1) write(lout,10130)
      if(imtr0.eq.1) write(lout,10700)
      write(lout,10710) imtr0,imn
 1730 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1
      if(ch(1:1).eq.'/') goto 1730
      if(ch(:4).eq.next) call prror(99)
      ch1(:nchars+3)=ch(:nchars)//' / '
      j1=j1+3
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
      read(ch1,*,round='nearest')                                       &
     & cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
      read(ch1,*) cotr(imtr0,j1-2),cotr(imtr0,j1-1),cotr(imtr0,j1)
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        cotr(imtr0,j1-2)=fround(errno,fields,1) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1-1)=fround(errno,fields,2) 
        nf=nf-1
      endif
      if (nf.gt.0) then
        cotr(imtr0,j1)=fround(errno,fields,3) 
        nf=nf-1
      endif
#endif
#endif
      if(j1.lt.6) goto 1730
      do j=1,6
        j1=0
 1740   read(3,10020,end=1530,iostat=ierro) ch
        if(ierro.gt.0) call prror(58)
        lineno3=lineno3+1
        if(ch(1:1).eq.'/') goto 1740
        if(ch(:4).eq.next) call prror(99)
        ch1(:nchars+3)=ch(:nchars)//' / '
        j1=j1+3
#ifdef FIO
#ifdef CRLIBM
      call enable_xp()
#endif
        read(ch1,*,round='nearest')                                     &
     & rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),                           &
     &rrtr(imtr0,j,j1)
#ifdef CRLIBM
      call disable_xp()
#endif
#endif
#ifndef FIO
#ifndef CRLIBM
        read(ch1,*) rrtr(imtr0,j,j1-2),rrtr(imtr0,j,j1-1),              &
     &rrtr(imtr0,j,j1)
#endif
#ifdef CRLIBM
      call splitfld(errno,3,lineno3,nofields,nf,ch1,fields)
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-2)=fround(errno,fields,1)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1-1)=fround(errno,fields,2)
        nf=nf-1
      endif
      if (nf.gt.0) then
        rrtr(imtr0,j,j1)=fround(errno,fields,3)
        nf=nf-1
      endif
#endif
#endif
        if(j1.lt.6) goto 1740
      enddo
      goto 1700
!-----------------------------------------------------------------------
!  COUPLING WITH FLUKA
!  A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!  last modified: 17-07-2013
!-----------------------------------------------------------------------
 1800 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
#ifndef FLUKA

!     inserted in main code if the 'fluka' compilation flag is NOT issued

      write(lout,*)
      write(lout,*) "     FLUKA coupling not supported in this version"
      write(lout,*) "     please recompile with proper flags"
      write(lout,*)
      call prror(-1)

#endif
#ifdef FLUKA

!     inserted in main code by the 'fluka' compilation flag

      if(ch(1:1).eq.'/') goto 1800
      if(ch(:4).eq.next) then
        write(lout,10520) fluk
        if ( fluka_enable ) then
!         dump all elements found:
          do ii=1,il
             if(fluka_type(ii).ne.FLUKA_NONE) then
               write(lout,10510) bez(ii), fluka_type(ii),fluka_geo_index(ii),fluka_synch_length(ii)
             endif
          enddo
          write(lout,*) ''
          write(lout,*) '        keys to FLUKA types:'
          write(lout,*) FLUKA_ELEMENT,' --> simple element'
          write(lout,*) FLUKA_ENTRY,' --> entrance point'
          write(lout,*) FLUKA_EXIT,' --> exit point'
          write(lout,*) ''
          if ( fluka_debug  ) write(lout,*) "        --> DEBUG enabled!"
        else
          write(lout,*) ''
          write(lout,*) ' !! no element flagged for coupling !!'
          write(lout,*) '    --> disabling coupling flags/labelling'
          write(lout,*) ''
          fluka_enable = .false.
          fluka_debug  = .false.
          do ii=1,il
             fluka_type(ii) = FLUKA_NONE
          enddo
        endif
        goto 110
      endif

      lineno3=lineno3+1
      ch1(:83)=ch(:80)//' / '
      if(ch1(:4).eq.'DEBU') then
        fluka_debug = .true.
        goto 1800
      elseif(ch1(:4).eq.'LOGU') then
        read(ch1,*) idat, ii
        if ( ii.gt.0 ) then
          fluka_log_unit = ii
        else
          write(lout,*) ' no valid unit for logging coupling messages'
          write(lout,*) '   in block ',fluk
          write(lout,*) '   parsed line:'
          write(lout,*) ch(:80)
          write(lout,*) ''
          call prror(-1)
        endif
      endif

!     parse line:
      read(ch1,*) idat, idat2, ii, tmplen

!     1. find idat (ie name of entrance element) in the list of SINGLE ELEMENTs:
      do i1=1,il
         if(bez(i1).eq.idat) goto 1801
      enddo
!     failing research:
      write(lout,*) ''
      write(lout,*) ' Un-identified SINGLE ELEMENT ', idat
      write(lout,*) '   in block ',fluk
      write(lout,*) '   parsed line:'
      write(lout,*) ch(:80)
      write(lout,*) ''
      call prror(-1)

!     2. find idat2 (ie name of exit element) in the list of SINGLE ELEMENTs:
 1801 do i2=1,il
         if(bez(i2).eq.idat2) goto 1802
      enddo
!     failing research:
      write(lout,*) ''
      write(lout,*) ' Un-identified SINGLE ELEMENT ', idat2
      write(lout,*) '   in block ',fluk
      write(lout,*) '   parsed line:'
      write(lout,*) ch(:80)
      write(lout,*) ''
      call prror(-1)

 1802 continue

!     3. check that the current markers have not been already flagged
      if ( fluka_type(i1).ne.FLUKA_NONE ) then
        write(lout,*) ''
        write(lout,*) ' SINGLE ELEMENT ', bez(i1)
        write(lout,*) '   in block ',fluk
        write(lout,*) '   was alredy labelled as fluka marker:'
        write(lout,*) '     you cannot overwrite'
        write(lout,*) '   parsed line:'
        write(lout,*) ch(:80)
        write(lout,*) ''
        write(lout,*) 'fluka_type(entrance) = ', fluka_type(i1)
        write(lout,*) 'at position = ', i1
        call prror(-1)
      endif
      if ( fluka_type(i2).ne.FLUKA_NONE ) then
        write(lout,*) ''
        write(lout,*) ' SINGLE ELEMENT ', bez(i2)
        write(lout,*) '   in block ',fluk
        write(lout,*) '   was alredy labelled as fluka marker:'
        write(lout,*) '     you cannot overwrite'
        write(lout,*) '   parsed line:'
        write(lout,*) ch(:80)
        write(lout,*) ''
        write(lout,*) 'fluka_type(exit) = ', fluka_type(i2)
        write(lout,*) 'at position = ', i2
        call prror(-1)
      endif

!     4. disentangle between just a simple element or an interval of elements
!        in the accelerator structure, labelled as Fluka insertion:
      if ( i1.eq.i2 ) then
        fluka_type(i1) = FLUKA_ELEMENT
        fluka_geo_index(i1)  = ii
        fluka_synch_length(i1) = tmplen
        write(fluka_log_unit,*)                                         &
     &'# Found         Fluka element as SING EL num',i1
      else
        fluka_type(i1) = FLUKA_ENTRY
        fluka_geo_index(i1)  = ii
        fluka_type(i2) = FLUKA_EXIT
        fluka_geo_index(i2)  = ii
        fluka_synch_length(i2) = tmplen
        write(fluka_log_unit,*)                                         &
     &'# Found entrance Fluka element as SING EL num',i1
        write(fluka_log_unit,*)                                         &
     &'# Found exit     Fluka element as SING EL num',i2
      endif
!     wait to find at least one FLUKA insertion before actually enabling
!       the coupling
      if(.not.fluka_enable) fluka_enable = .true.

#endif
      goto 1800

!-----------------------------------------------------------------------
!  DUMP BEAM POPULATION
!  A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!  K.Sjobak, BE-ABP/HSS, BE-ABP/LAT
!  last modified: 03-09-2015
!  always in main code
!-----------------------------------------------------------------------
 2000 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3=lineno3+1 ! Line number used for some crash output
      if(ch(1:1).eq.'/') goto 2000 !Skip comment line
      
      !Done with DUMP, write out!
      if(ch(:4).eq.next) then
         call dump_parseInputDone
         goto 110
      endif !END writeout when finished reading
      
      call dump_parseInputLine(ch)
      
      ! Go to next line
      goto 2000

!-----------------------------------------------------------------------
!  BDEX = Beam Distribution EXchange
!  K.Sjobak, BE/ABP-HSS 2016
!  Based on FLUKA coupling version by
!  A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team, 2014.
!-----------------------------------------------------------------------
 2250 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(51)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2250 ! skip comment line

#ifdef CR
      write(lout,*) "BDEX not supported in CR version."
      write(lout,*) "Sorry :("
      call prror(-1)
#endif
!+if collimat
!      write(*,*) "BDEX not supported in COLLIMAT version."
!      write(*,*) "Sorry :("
!      call prror(-1)
!+ei

      ! Which type of block? Look at start of string (no leading blanks allowed)
      if (ch(:4).eq."DEBU") then
         bdex_debug = .true.
         write (lout,*) "BDEX> BDEX block debugging is ON"
         goto 2250 !loop BDEX

      else if (ch(:4).eq."ELEM") then
         call bdex_parseElem(ch)
         goto 2250 !loop BDEX
         
      else if (ch(:4).eq."CHAN") then
         call bdex_parseChan(ch)
         goto 2250 !Loop BDEX
         
      else if (ch(:4).eq.next) then
         call bdex_parseInputDone
         goto 110 ! loop BLOCK
         
      else
         write (lout,*)
         write (lout,*) "*******************************************"
         write (lout,*) "ERROR while parsing BDEX block in fort.3"
         write (lout,*) "Expected keywords DEBU, NEXT, ELEM, or CHAN"
         write (lout,*) "Got ch:"
         write (lout,*) "'"//ch//"'"
         write (lout,*) "*******************************************"
         call prror(-1)
         
      endif

      ! Should never arrive here
      write (lout,*) "*****************************"
      write (lout,*) "*LOGIC ERROR IN PARSING BDEX*"
      write (lout,*) "*****************************"
      call prror(-1)
      
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!  FMA
!  M. Fitterer, R. De Maria, K. Sjobak, BE/ABP-HSS
!  last modified: 07-01-2016
!  always in main code
!-----------------------------------------------------------------------
 2300 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2300 ! skip comment lines

      if (ch(:4).eq.next) then
         goto 110 ! loop to next BLOCK in fort.3
      endif

      call fma_parseInputLine(ch)
      
      goto 2300
!-----------------------------------------------------------------------
!  Electron Lense, kz=29,ktrack=63
!  M. Fitterer,  FNAL
!  last modified: 20-06-2016
!-----------------------------------------------------------------------
 2400 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2400 ! skip comment lines

      if (ch(:4).eq.next) then
         if(melens.ne.0) then
!          loop only if at least an elens has been read
!       4) loop over single elements to check that they have been defined in the fort.3 block
            do j=1,nele
               if(kz(j).eq.29) then
                  if(elens_type(ielens(j)).eq.0) then
                     write(lout,*)                                      &
     &'ERROR: elens ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '// &
     &'not defined in fort.3. You must define every elens in the '//    &
     &'ELEN block in fort.3!'
                     call prror(-1)
                  endif
               endif
            enddo
         endif
         goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
#ifdef FIO
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: fortran IO format currently not ',   &
     &       'supported!'
        call prror(-1)
#endif

!     1) read in elens parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,    &
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check (min) number of arguments
!     If a new type of elens is implemented, may need to modify this!
      if(getfields_nfields.lt.7) then
        write(lout,*)                                                   &
     &       'ERROR in ELEN block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 7 (min)'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)                                                  &
     &        "ERROR in ELEN block: Element name max 16 characters;"//  &
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))&
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of elens
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_elens=29)
            if(kz(j).ne.29) then
               write(lout,*)                                            &
     &              'ERROR: element type mismatch for ELEN!'//          &
     &              'Element type is kz(',j,') = ',kz(j),'!= 29'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_elens=29)
               write(lout,*)                                            &
     &'ERROR: length el(j) (elens is treated as thin element), '//      &
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//&
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,      &
     &')=',ek(j),'. Please check your input in the single element '//   &
     &'definition of your ELEN. All values except for the type need '// &
     &'to be zero.'
               call prror(-1)
            endif
!           acquire new elens
            melens=melens+1
            if (melens.gt.nelens) then
               write(lout,*) "ERROR in ELEN block:"//                   &
     &              "Too many elenses: ",melens," - max:",nelens
               call prror(-1)
            end if
            ielens(j)=melens
            if (elens_type(ielens(j)).ne.0) then
               write(lout,*) "ERROR in ELEN block:"//                   &
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            select case ( getfields_fields(2)(1:getfields_lfields(2)) )
            case ("UNIFORM")
               ! Read in this case
               elens_type(ielens(j)) = 1
            case ("GAUSSIAN")
               ! Read in this case
               elens_type(ielens(j)) = 2
               if(getfields_nfields.lt.8) then
                  write(lout,*)                                         &
     &       'ERROR in ELEN block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 8 (GAUSSIAN)'
                  call prror(-1)
               endif
            case ("CHEBYSHEV")
               ! Read in this case
               elens_type(ielens(j)) = 3
               if(getfields_nfields.lt.8) then
                  write(lout,*)                                         &
     &       'ERROR in ELEN block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 8 (CHEBYSHEV)'
                  call prror(-1)
               endif
            case default
               write(lout,*) "ERROR in ELEN: "//                        &
     &              "Elens type '"//                                    &
     &              getfields_fields(2)(1:getfields_lfields(2))//       &
     &              "' not recognized. Remember to use all UPPER CASE!"
               call prror(-1)
            end select
            
#ifndef CRLIBM
            read (getfields_fields(3)(1:getfields_lfields(3)),*)     &
     &              elens_theta_r2(ielens(j))
            read (getfields_fields(4)(1:getfields_lfields(4)),*)     &
     &              elens_r2(ielens(j))
            read (getfields_fields(5)(1:getfields_lfields(5)),*)     &
     &              elens_r1(ielens(j))
            read (getfields_fields(6)(1:getfields_lfields(6)),*)     &
     &              elens_offset_x(ielens(j))
            read (getfields_fields(7)(1:getfields_lfields(7)),*)     &
     &              elens_offset_y(ielens(j))
#endif
#ifdef CRLIBM
            elens_theta_r2(ielens(j))= round_near (                  &
     &              errno,getfields_lfields(3)+1, getfields_fields(3) )
            if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,3,elens_theta_r2(ielens(j)) )
            elens_r2(ielens(j))       = round_near (                 &
     &              errno,getfields_lfields(4)+1, getfields_fields(4) )
            if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,4,elens_r2(ielens(j)) )
            elens_r1(ielens(j)) = round_near (                       &
     &              errno,getfields_lfields(5)+1, getfields_fields(5) )
            if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,5,elens_r1(ielens(j)) )
            elens_offset_x(ielens(j)) = round_near (                 &
     &              errno,getfields_lfields(6)+1, getfields_fields(6) )
            if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,6,elens_offset_x(ielens(j)) )
            elens_offset_y(ielens(j)) = round_near (                 &
     &              errno,getfields_lfields(7)+1, getfields_fields(7) )
            if (errno.ne.0) call rounderr (                          &
     &              errno,getfields_fields,7,elens_offset_y(ielens(j)) )
#endif

            if ( elens_type(ielens(j)).eq.2 ) then
!               GAUSSIAN profile of electrons: need also sigma of e-beam
#ifndef CRLIBM
                read (getfields_fields(8)(1:getfields_lfields(8)),*) &
     &              elens_sig(ielens(j))
#endif
#ifdef CRLIBM
                elens_sig(ielens(j))= round_near (                   &
     &              errno,getfields_lfields(8)+1, getfields_fields(8) )
                if (errno.ne.0) call rounderr (                      &
     &              errno,getfields_fields,8,elens_sig(ielens(j)) )
#endif
            elseif ( elens_type(ielens(j)).eq.3 ) then
!               profile of electrons given by Chebyshev polynomials: need also
!                  name of file where coefficients are stored and angle
                read (getfields_fields(8)(1:getfields_lfields(8)),*) tmpch
#ifndef CRLIBM
                read (getfields_fields(9)(1:getfields_lfields(9)),*) &
     &              elens_cheby_angle(ielens(j))
#endif
#ifdef CRLIBM
                elens_cheby_angle(ielens(j))= round_near (           &
     &              errno,getfields_lfields(9)+1, getfields_fields(9) )
                if (errno.ne.0) call rounderr (                      &
     &              errno,getfields_fields,9,elens_cheby_angle(ielens(j)) )
#endif
!               check if table of coefficients has already been requested:
                do tmpi1=1,melens_cheby_tables
                   if ( tmpch.eq.elens_cheby_filename(tmpi1) ) then
                      elens_iCheby(ielens(j))=tmpi1
                      goto 1972
                   end if
                end do
!               un-successful search
                melens_cheby_tables=melens_cheby_tables+1
                if (melens_cheby_tables.gt.nelens_cheby_tables) then
                   write(lout,*) "ERROR in ELEN block: Too many tables"//&
     &" for Chebyshev coefficients: ",melens_cheby_tables," - max:",nelens_cheby_tables
                   call prror(-1)
                end if
                elens_iCheby(ielens(j))=melens_cheby_tables
                elens_cheby_filename(tmpi1)=tmpch
 1972           continue
            end if
!           additional geometrical infos:
!           depending on profile, the position of these parameters change            
            tmpi1=0
            tmpi2=0
            tmpi3=0
            if ( elens_type(ielens(j)).eq.1.and.getfields_nfields.ge.10 ) then
               tmpi1=8
               tmpi2=9
               tmpi3=10
               elens_lThetaR2(ielens(j)) = .true.
            elseif ( elens_type(ielens(j)).eq.2.and.getfields_nfields.ge.11 ) then
               tmpi1=9
               tmpi2=10
               tmpi3=11
               elens_lThetaR2(ielens(j)) = .true.
            elseif ( elens_type(ielens(j)).eq.3.and.getfields_nfields.ge.12 ) then
               tmpi1=10
               tmpi2=11
               tmpi3=12
               elens_lThetaR2(ielens(j)) = .true.
            end if
            if ( elens_lThetaR2(ielens(j)) ) then
#ifndef CRLIBM
               read (getfields_fields(tmpi1)(1:getfields_lfields(tmpi1)),*)  &
     &              elens_len(ielens(j))
               read (getfields_fields(tmpi2)(1:getfields_lfields(tmpi2)),*)  &
     &              elens_I(ielens(j))
               read (getfields_fields(tmpi3)(1:getfields_lfields(tmpi3)),*)&
     &              elens_Ek(ielens(j))
#endif
#ifdef CRLIBM
               elens_len(ielens(j))= round_near (                    &
     &              errno,getfields_lfields(tmpi1)+1, getfields_fields(tmpi1) )
               if (errno.ne.0) call rounderr (                       &
     &              errno,getfields_fields,tmpi1,elens_len(ielens(j)) )
               elens_I(ielens(j))       = round_near (               &
     &              errno,getfields_lfields(tmpi2)+1, getfields_fields(tmpi2) )
               if (errno.ne.0) call rounderr (                       &
     &              errno,getfields_fields,tmpi2,elens_I(ielens(j)) )
               elens_Ek(ielens(j)) = round_near (                    &
     &              errno,getfields_lfields(tmpi3)+1, getfields_fields(tmpi3) )
               if (errno.ne.0) call rounderr (                       &
     &              errno,getfields_fields,tmpi3,elens_Ek(ielens(j)) )
#endif
            end if
            
            ! Make checks for this case
            if( elens_r2(ielens(j)).lt.elens_r1(ielens(j)) ) then
               write(lout,*) 'WARNING: ELEN R2<R1 -> inverting'
               tmpflt=elens_r2(ielens(j))
               elens_r2(ielens(j))=elens_r1(ielens(j))
               elens_r1(ielens(j))=tmpflt
            elseif ( elens_r2(ielens(j)).eq.elens_r1(ielens(j)) ) then
               write(lout,*) 'ERROR: ELEN R2=R1 -> ELEN does not exist'
               call prror(-1)
            end if
            if( elens_r2(ielens(j)).lt.zero ) then
               write(lout,*) 'WARNING: ELEN R2<0!!'
               call prror(-1)
            end if
            if( elens_r1(ielens(j)).lt.zero ) then
               write(lout,*) 'WARNING: ELEN R1<0!!'
               call prror(-1)
            end if
            if ( elens_lThetaR2(j) ) then
               if( elens_len(ielens(j)).lt.zero ) then
                  write(lout,*) 'WARNING: ELEN L<0!!'
                  call prror(-1)
               end if
               if( elens_Ek(ielens(j)).lt.zero ) then
                  write(lout,*) 'WARNING: ELEN Ek<0!! (e-beam)'
                  call prror(-1)
               end if
            end if
            ! proper normalisation
            if (elens_type(ielens(j)).eq.1) then
!              uniform distribution
               elens_geo_norm(ielens(j))=(elens_r2(ielens(j))+elens_r1(ielens(j)))* &
     &                                   (elens_r2(ielens(j))-elens_r1(ielens(j)))
            elseif (elens_type(ielens(j)).eq.2) then
!              Gaussian distribution
               elens_geo_norm(ielens(j))=exp_mb(-0.5*(elens_r1(ielens(j))/elens_sig(ielens(j)))**2) &
     &                                  -exp_mb(-0.5*(elens_r2(ielens(j))/elens_sig(ielens(j)))**2)
            end if

            ! print a summary of elens parameters
            write(lout,                                                 &
     &fmt='((/,/,A),(/,A,A),(/,A,A,A,I4),5(/,A,1PE10.3,A))')            &
     &'ELENS found in list of single elements with: ',                  &
     &'name     = ',bez(j),                                             &
     &'type     = ',getfields_fields(2)(1:getfields_lfields(2)),        &
     &        ' = ',elens_type(ielens(j)),                              &
     &'theta_r2 = ',elens_theta_r2(ielens(j)),' mrad',                  &
     &'r1       = ',elens_r1(ielens(j)),' mm',                          &
     &'r2       = ',elens_r2(ielens(j)),' mm',                          &
     &'offset_x = ',elens_offset_x(ielens(j)),' mm',                    &
     &'offset_y = ',elens_offset_y(ielens(j)),' mm'

            if (elens_type(ielens(j)).eq.2) write(lout,fmt='(A,1PE10.3,A)') &
     &'sig      = ',elens_sig(ielens(j)),' mm'
            if (elens_lThetaR2(ielens(j))) then
               write(lout,fmt='((A),4(/,A,1PE10.3,A))')                 &
     &'ELENS theta_r2 will be recomputed after input parsing based on:',&
     &'  L  =',elens_len(ielens(j)),' m',                               &
     &'  I  =',elens_I(ielens(j)),' A',                                 &
     &'  Ek =',elens_Ek(ielens(j)),' keV'
            end if
            goto 2401           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in ELEN: "//                                 &
     &     "Un-identified SINGLE ELEMENT '",                            &
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2401 continue
      
      goto 2400 ! at NEXT statement -> check that all single elements with kz(j) = 29 (elens) have been defined in ELEN block

!-----------------------------------------------------------------------
!  Wire, kz=+/-15,ktrack=45
!  A. Patapenka (NIU), M. Fitterer,  FNAL
!  last modified: 22-12-2016
!-----------------------------------------------------------------------
 2500 read(3,10020,end=1530,iostat=ierro) ch
      if(ierro.gt.0) call prror(58)
      lineno3 = lineno3+1 ! Line number used for some crash output

      if(ch(1:1).eq.'/') goto 2500 ! skip comment lines
     
      if (ch(:4).eq.next) then
!       4) loop over single elements to check that they have been defined in the fort.3 block
        do j=1,nele
          if(kz(j).eq.15) then
            if(wire_flagco(j).eq.0) then
              write(lout,*)                                             &
     &'ERROR: wire ',trim(bez(j)),' with kz(',j,') = ',kz(j), ' is '//  &
     &'not defined in fort.3. You must define every wire in the '//     &
     &'WIRE block in fort.3!'
               call prror(-1)
            endif
          endif
        enddo
        goto 110 ! go to next BLOCK in fort.3 - we're done here!
      endif

      ! We don't support FIO, since it's not supported by any compilers...
#ifdef FIO
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: fortran IO format currently not ',   &
     &       'supported!'
        call prror(-1)
#endif

!     1) read in wire parameters
      call getfields_split( ch, getfields_fields, getfields_lfields,    &
     &        getfields_nfields, getfields_lerr )
      if ( getfields_lerr ) then
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: getfields_lerr=', getfields_lerr
        call prror(-1)
      endif

!     Check number of arguments
      if(getfields_nfields.ne.9) then
        write(lout,*)                                                   &
     &       'ERROR in WIRE block: wrong number of input ',             &
     &       'parameters: ninput = ', getfields_nfields, ' != 9'
        call prror(-1)
      endif

!     Find the element, and check that we're not double-defining
      if (getfields_lfields(1) .gt. 16) then
         write(lout,*)                                                  &
     &        "ERROR in WIRE block: Element name max 16 characters;"//  &
     &        "The name '" //getfields_fields(1)(1:getfields_lfields(1))&
     &        //"' is too long."
         call prror(-1)
      endif
      
      do j=1,nele               !loop over single elements and set parameters of wire
         if(bez(j).eq.getfields_fields(1)(1:getfields_lfields(1))) then
            ! check the element type (kz(j)_wire=15)
            if(kz(j).ne.15) then
               write(lout,*)                                            &
     &              'ERROR: element type mismatch for WIRE! '//         &
     &'Element type is kz(',j,') = ',kz(j),'!= +15'
               call prror(-1)
            endif
            if(el(j).ne.0 .or. ek(j).ne.0 .or. ed(j).ne.0) then ! check the element type (kz(j)_wire=+/-15)
               write(lout,*)                                            &
     &'ERROR: length el(j) (wire is treated as thin element), '//       &
     &' and first and second field have to be zero: el(j)=ed(j)=ek(j)'//&
     &'=0, while el(',j,')=',el(j),', ed(',j,')=',ed(j),', ek(',j,      &
     &')=',ek(j),'. Please check your input in the single element '//   &
     &'definition of your WIRE. All values except for the type need '// &
     &'to be zero.'
               call prror(-1)
            endif
            if (wire_flagco(j).ne.0) then
               write(lout,*) "ERROR in WIRE block:"//                   &
     &              "The element '"//bez(j)//"' was defined twice!"
               call prror(-1)
            endif

            ! Parse the element
            read(getfields_fields(2)(1:getfields_lfields(2)),'(I10)')   &
     &           wire_flagco(j)
#ifndef CRLIBM
            read (getfields_fields(3)(1:getfields_lfields(3)),*)        &
     &           wire_current(j)
            read (getfields_fields(4)(1:getfields_lfields(4)),*)        &
     &           wire_lint(j)
            read (getfields_fields(5)(1:getfields_lfields(5)),*)        &
     &           wire_lphys(j)
            read (getfields_fields(6)(1:getfields_lfields(6)),*)        &
     &           wire_dispx(j)
            read (getfields_fields(7)(1:getfields_lfields(7)),*)        &
     &           wire_dispy(j)
            read (getfields_fields(8)(1:getfields_lfields(8)),*)        &
     &           wire_tiltx(j)
            read (getfields_fields(9)(1:getfields_lfields(9)),*)        &
     &           wire_tilty(j)
#endif
#ifdef CRLIBM
            wire_current(j)= round_near (                               &
     &           errno,getfields_lfields(3)+1, getfields_fields(3) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,3,wire_current(j) )
            wire_lint(j)       = round_near (                           &
     &           errno,getfields_lfields(4)+1, getfields_fields(4) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,4,wire_lint(j) )
            wire_lphys(j)   = round_near (                              &
     &           errno,getfields_lfields(5)+1, getfields_fields(5) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,5,wire_lphys(j) )
            wire_dispx(j) = round_near (                                &
     &           errno,getfields_lfields(6)+1, getfields_fields(6) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,6,wire_dispx(j) )
            wire_dispy(j) = round_near (                                &
     &           errno,getfields_lfields(7)+1, getfields_fields(7) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,7,wire_dispy(j) )
            wire_tiltx(j) = round_near (                                &
     &           errno,getfields_lfields(8)+1, getfields_fields(8) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,8,wire_tiltx(j) )
            wire_tilty(j) = round_near (                                &
     &           errno,getfields_lfields(9)+1, getfields_fields(9) )
            if (errno.ne.0) call rounderr (                             &
     &           errno,getfields_fields,9,wire_tilty(j) )
#endif
            
            ! Make checks for the wire parameters
            if(wire_flagco(j).ne. 1 .and. wire_flagco(j).ne.-1) then
               write(lout,*)                                            &
     &"ERROR: WIRE flag for defining the wire separation "//            &
     &"must be -1 (disp* = distance closed orbit and beam)"//           &
     &"or 1 (disp* = distance from x=y=0 <-> beam), but "//             &
     &"wire_flagco = ",wire_flagco(j)
               call prror(-1)
            end if
            if((wire_lint(j).lt.0) .or. (wire_lphys(j).lt.0)) then
              write(lout,*)                                             &
     &'ERROR: WIRE integrated and physical length must larger than 0! ' &
     &// 'wire_lint = ',wire_lint(j),', wire_lphys = ',wire_lphys(j)
              call prror(-1)
            end if
            if((abs(wire_tiltx(j)) .ge. 90) .or.                        &
     &         (abs(wire_tilty(j)) .ge. 90)) then
              write(lout,*)                                             &
     &'ERROR: WIRE tilt angle must be within [-90,90] degrees! '        &
     &//'wire_tiltx = ',wire_tiltx(j),', wire_tilty = ',wire_tilty(j)
              call prror(-1)
            end if

! print a summary of the wire parameters
            write(lout,                                                 &
     &fmt='((A,/),(A,A,/),(A,I4,/),7(A,D10.3,A,/))')                    &
     &'WIRE found in list of single elements with: ',                   &
     &'name               = ',bez(j),                                   &
     &'flagco             = ',wire_flagco(j),                           &
     &'current            = ',wire_current(j),' A',                     &
     &'integrated length  = ',wire_lint(j),' m',                        &
     &'physical length    = ',wire_lphys(j),' m',                       &
     &'hor. displacement  = ',wire_dispx(j),' mm',                      &
     &'vert. displacement = ',wire_dispy(j),' mm',                      &
     &'hor. tilt          = ',wire_tiltx(j),' degrees',                 &
     &'vert. tilt         = ',wire_tilty(j),' degrees'
! ignore wire if current, length or displacment are 0 or
! wire_flagco not set (case wire_flagco = 0)
! for displacement only ignore if wire_dispx = wire_dispy = 0
            if( abs(wire_flagco(j)*(wire_current(j)*(wire_lint(j)       &
     &*(wire_lphys(j)*(wire_dispx(j)+wire_dispy(j)))))).le.pieni ) then
              kz(j) = 0 ! treat element as marker

              write(lout,                                               &
     &fmt='((A,A,A,/),(A,A,/),4(A,I0,A,D10.3,/))')                      &
     &'WARNING: WIRE element ',bez(j),'ignored!',                       &
     &'Elements are ignored if current, displacment, integrated ',      &
     &'or physical length are 0! ',                                     &
     &'wire_dispx(',j,') = ',wire_dispx(j),                             &
     &'wire_dispy(',j,') = ',wire_dispy(j),                             &
     &'wire_lint(',j,') = ',wire_lint(j),                               &
     &'wire_lphys(',j,') = ',wire_lphys(j)
            end if

            goto 2501           !Search success :)
            
         endif
      enddo

!     Search for element failed!
      write(lout,*) "ERROR in WIRE: "//                                 &
     &     "Un-identified SINGLE ELEMENT '",                            &
     &     getfields_fields(1)(1:getfields_lfields(1)), "'"
      call prror(-1)
      
!     element search was a success :)
 2501 continue
      
      goto 2500 ! at NEXT statement -> check that all single elements with kz(j) = 15 (wire) have been defined in WIRE block


! ================================================================================================ !
!  ENDE was reached; we're done parsing fort.3, now do some postprocessing.
! ================================================================================================ !
771 if(napx.ge.1) then
        if(e0.lt.pieni.or.e0.le.pma) call prror(27)
        if(nbeam.ge.1) parbe14=                                         &!hr05
     &(((((-one*crad)*partnum)/four)/pi)/emitnx)*c1e6                    !hr05
        gammar=pma/e0
        crad=(((two*crad)*partnum)*gammar)*c1e6                          !hr05
        emitx=emitnx*gammar
        emity=emitny*gammar
#ifdef COLLIMAT
        remitx_dist=emitnx0_dist*gammar
        remity_dist=emitny0_dist*gammar
        remitx_collgap=emitnx0_collgap*gammar
        remity_collgap=emitny0_collgap*gammar
#endif
      endif
#ifdef COLLIMAT
      if (.not.has_coll) then
         !Breaks at least DUMP (negative particle IDs) and DYNK (1-pass actions).
         write(lout,*) ""
         write(lout,*) "ERROR in parsing fort.3:"
         write(lout,*) "This is the collimation version of SixTrack,"
         write(lout,*) " but no COLL block was found,"
         write(lout,*) " not even one with do_coll = .false."
         write(lout,*) "Please use the non-collimation version!"
         call prror(-1)
      endif
#endif
! If we don't have the HION block, we need to set some variables - default to the proton values
      if(has_hion .eqv. .false.) then
        zz0 = 1
        aa0 = 1
        nucm0 = pma
        write(lout,*) 'No HION block found, will default to the proton values: [Z,A,M]', zz0, aa0, nucm0
      end if

      if(idp.eq.0.or.ition.eq.0.or.nbeam.lt.1) then
        do j=1,il   ! converting 6D lenses to 4D
          if (beam_expflag .eq. 1) then
             if (parbe(j,2) .gt. 0) then
               parbe(j,2)=zero
               parbe(j,1)=parbe(j,7)
               parbe(j,3)=parbe(j,10)
             endif
          else
             parbe(j,2)=zero
          endif
        enddo
      else
        do j=1,il
          if(parbe(j,2).gt.real(mbea,fPrec)) then
             write(lout,'(a,i5,a,i5,a,a16,a,i5)')                       &
     &            'ERROR: Requested ',                                  &
     &            int(parbe(j,2)), " slices for 6D beam-beam element"// &
     &            ' #',j, " named ", bez(j), ", maximum is mbea =",mbea
            parbe(j,2)=real(mbea,fPrec)
            call prror(-1) !Treat this warning as an error
         endif
        enddo
      endif
      if(iout.eq.0) return
      write(lout,10050)
      write(lout,10060)
      il1=il
      if(sixin_ncy2.eq.0) il1=il-1
      do 1435 k=1,il1
      if(abs(kz(k)).eq.12) then
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),phasc(k),xpl(k),   &
     &xrms(k),zpl(k),zrms(k)
        kz(k)=abs(kz(k))
        phasc(k)=phasc(k)*rad
      else
        write(lout,10070) k,bez(k),kz(k),ed(k),ek(k),el(k),xpl(k),      &
     &xrms(k),                                                          &
     &zpl(k),zrms(k)
      endif
 1435 continue
      write(lout,10130)
      write(lout,10080)
      write(lout,10090) mper,(msym(k),k=1,mper)
      write(lout,10250) mblo,mbloz
      write(lout,10100)
      do 1450 l=1,mblo
      kk=mel(l)
      ll=kk/6
      if(ll.ne.0) then
        do 1440 l1=1,ll
          l2=(l1-1)*6+1
          l3=l2+5
          if(l2.eq.1) then
            write(lout,10260) l,bezb(l),kk,(sixin_beze(l,k),k=1,6)
          else
            write(lout,10270) (sixin_beze(l,k),k=l2,l3)
          endif
 1440   continue
        if(mod(kk,6).ne.0) then
          l4=ll*6+1
          write(lout,10270) (sixin_beze(l,k),k=l4,kk)
        endif
      else
        write(lout,10260) l,bezb(l),kk,(sixin_beze(l,k),k=1,kk)
      endif
 1450 continue
      write(lout,10120)
      mblozz=mbloz/5+1
      do 1480 k=1,mblozz
      k10=(k-1)*5
      if((mbloz-k10).eq.0) goto 1480
      do 1470 l=1,5
        if((k10+l).gt.mbloz) ic0(l)=' '
        if((k10+l).gt.mbloz) goto 1470
        icc=ic(k10+l)
        if(icc.gt.nblo) goto 1460
        ic0(l)=bezb(icc)
        goto 1470
 1460   ic0(l)=sixin_bez0(icc-nblo)
 1470 continue
      k11=k10+1
      write(lout,10280) k11,(ic0(l),l=1,5)
 1480 continue
      write(lout,10130)
 1490 if(idp.eq.0) goto 1500
      if(nbeam.ge.1) then !Write out with BB parameters
         if(beam_expflag .eq. 0) then  !The old BEAM format
            if(partnum.gt.zero) then !Beams have same charge
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,            &
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Hirata 6D (1 => on/0 => off)  : ',t76,i4/                    &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,       &
     &              ibeco,ibtyp,ibb6d,ibbc,sigz,sige,emitnx,emitny,e0
            endif
            
         elseif (beam_expflag .eq. 1) then ! The new BEAM-EXPERT format
            if(partnum.gt.zero) then !Beams have same charge
               ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE SAME CHARGE'/                                     &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,partnum,parbe14,            &
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            else !Beams have opposite charge
               ! Almost the same format as the old BEAM, except no 'Hirata 6D'.
               write(lout,                                              &
     &"(t30,'SYNCHROTRON OSCILLATIONS AND BEAM-BEAM'//                  &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'PARTICLE NUMBER ',t66,1pe14.7/                               &
     &t10,'BEAMS HAVE OPPOSITE CHARGE'/                                 &
     &t10,'BEAM-BEAM PARAMETER ',t66,1pe14.7,0p/                        &
     &t10,'CLOSED ORBIT DUE TO BEAM-BEAM KICK (0=LEFT,1=SUBTRACTED) : ',&
     &t79,i1/                                                           &
     &t10,'FAST BEAM-BEAM KICK SWITCH (0=OFF,1=ON) : ',t79,i1/          &
     &t10,'Consider linear coupling for BB (1=on,0=off): ',t76,i4/      &
     &t10,'BUNCH LENGTH               ',t66,f14.9/                      &
     &t10,'ENERGY SPREAD              ',t66,f14.9/                      &
     &t10,'NORMALIZED HORIZONTAL EMMITTANCE (mu-meter rad)',t64,G20.12/ &
     &t10,'NORMALIZED VERTICAL EMMITTANCE (mu-meter rad)',t64,G20.12/   &
     &t10,'ENERGY IN (MEV)',t66,f14.3)")                                &
     &              ncy,dp1,dppoff,tlen,pma,abs(partnum),parbe14,       &
     &              ibeco,ibtyp,ibbc,sigz,sige,emitnx,emitny,e0
            endif
         else
            write(lout,'(a)') "ERROR in subroutine daten"
            write(lout,'(a)') "beam_expflag was", beam_expflag
            write(lout,'(a)') " expected 0 or 1. This is a BUG!"
            call prror(-1)
         endif
      else !No beam beam
        write(lout,10142) ncy,dp1,dppoff,tlen,pma,e0
      endif
      if(sixin_ncy2.eq.0) then
        write(lout,10143) harm,u0,phag,qs,alc
      else
        write(lout,*)
      endif
      if(beam_expflag .eq. 0) then
         if(ibb6d.eq.1) then
            write(lout,                                                 &
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    CROSSING_ANGLE',            &
     &'     CROSSING_PLANE     COUPLING_ANGLE'/t10,85('-')/)")
            do j=1,il
               if(parbe(j,2).gt.zero)                                   &
     &              write(lout,"(t10,a16,5x,i4,7x,d17.10,2x,d17.10)")   &
     &              bez(j),int(parbe(j,2)),parbe(j,1),parbe(j,3)
            enddo
         endif
         
      elseif(beam_expflag .eq. 1) then
         write(lout,                                                    &
     &"(t30,'HIRATA''s 6D BEAM-BEAM ELEMENTS'/t30,30('-')//             &
     &t10,'ELEMENT           #_OF_SLICES    XING_ANGLE',                &
     &'  XING_PLANE   HOR_SEP     VER_SEP        S11        S12      ', &
     &'  S22         S33         S34         S44         S13         ', &
     &'S14         S23         S24'/t10,200('-')/)")
         do j=1,il
            if(kz(j).eq.20.and.parbe(j,17).eq.1)then
               write(lout,                                              &
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,      &
     &2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,        &
     &1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")            &
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6),      &
     &parbe(j,7),parbe(j,8),parbe(j,9),parbe(j,10),parbe(j,11),         &
     &parbe(j,12),parbe(j,13),parbe(j,14),parbe(j,15),parbe(j,16)
            endif
         enddo
         write(lout,                                                    &
     &"(//,t30,'4D BEAM-BEAM ELEMENTS'/t30,24('-')//                    &
     &t10,'ELEMENT           #_OF_SLICES        S11   ',                &
     &'     S22       HOR_SEP     VER_SEP'/t10,80('-')/)")
         do j=1,il
            if (kz(j).eq.20.and.parbe(j,17).eq.0) then
               write(lout,                                              &
     &"(t10,a16,5x,i4,7x,1pe10.3,2x,1pe10.3,2x,1pe10.3,2x,1pe10.3)")    &
     &bez(j),                                                           &
     &int(parbe(j,2)),parbe(j,1),parbe(j,3),parbe(j,5),parbe(j,6)
            endif
         enddo
         
      else
         write(lout,'(a)') "ERROR in subroutine daten"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
      write(lout,10130)
 1500 continue
      write(lout,10150)
      nfb=nde(1)
      nac=nde(2)
      nft=numl-nde(2)
      if(numl.le.nde(2)) nft=0
      if(numl.le.nde(2)) nac=numl
      if(numl.le.nde(1)) nac=0
      if(numl.le.nde(1)) nfb=numl
      write(lout,10160) numl,numlr,nwr(4),nfb,nwr(1),nac,nwr(2),nft,    &
     &nwr(3),                                                           &
     &kanf,amp(1),rat,itco,dma,dmap,itqv,dkq,dqq
      write(lout,10170) itcro,dsm0,dech,de0,ded,dsi
      write(lout,10130)
      write(lout,10040)
      write(lout,10130)
      goto 1540
 1520 call prror(41)
 1530 call prror(42)
 1540 continue
      !Check that the number of particles is OK
      if(((2*mmac)*imc)*napx.gt.npart) call prror(54)                    !hr05
!     compute elens theta at R2, if requested by user
      do j=1,melens
         if ( elens_lThetaR2(j) ) then
            elens_theta_r2(j)=eLensTheta( elens_len(ielens(j)), elens_I(ielens(j)), &
     &   elens_Ek(ielens(j)), e0, elens_r2(ielens(j)) )
            write(lout,fmt='((A),4(/,A,1PE10.3,A))')                    &
     &   'ELENS new theta at r2 for ',bez(j),':',elens_theta_r2(j)
         end if
      end do
!     parse files with coefficients for chekyshev polynomials:
      do tmpi1=1,melens_cheby_tables
         inquire( file=elens_cheby_filename(tmpi1), exist=tmpl )
         if ( .not. tmpl ) then
            write(lout,*) "ERROR: ELENS problems with file with "//&
     &"coefficients for Chebyshev polynominals:",elens_cheby_filename(tmpi1)
            call prror(-1)
         endif
         call parseChebyFile(tmpi1)
      end do

      call dealloc(sixin_bez0,max_name_len,'sixin_bez0')

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  return
  
9999 continue
  ! Error handling for sixtrack_input module
  if(nUnit == 2) then
    write(lout,"(a,i0)") "DATEN> ERROR in fort.2 line ",lineNo2
  else
    write(lout,"(a,i0)") "DATEN> ERROR in fort.3 line ",lineNo3
  end if
  call prror(-1)
  return
      
10000 format(11(a4,1x))
10010 format(a4,8x,a60)
10020 format(a)
10030 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
     &'OO  SIXTRACK-INPUT  OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10040 format(t10,21('O')/t10,2('O'),17x,2('O')/t10,                     &
     &'OO  PREPROCESSING  OO', /t10,2('O'),17x,2('O')/t10,21('O'))
10050 format(//131('-')//t43,'*** RING PARAMETERS ***'/)
10060 format(t30,'SINGLE ELEMENTS:'/'  NO   NAME  TYP      ',           &
     &' 1/RHO          STRENGTH          LENGTH           X-POS     ',  &
     &'     X-RMS            Y-PO          Y-RMS     ' /131('-'))
10080 format(/t30,'RINGSTRUCTURE:'//)
10090 format(t10,'NO. OF SUPERPERIODS AND SYMMETRY ' ,t50,i3,'   ',15i4,&
     &'   ')
10100 format(//131('-')//t30,'BLOCKSTRUCTURE:'/ t30,                    &
     &'(BLOCKTYP--NO. OF SINGLE ELEMENTS--SINGLE ELEMENT TYPES)'//)
!10110 format(t10,i3,' ---',i3,' --- ',30i3)
10120 format(//131('-')//t30,'BLOCKSTRUCTURE OF SUPERPERIOD:'//)
10130 format(/131('-')/)
10142 format(t30,'SYNCHROTRON OSCILLATIONS'//                           &
     &t10,'NUMBER OF CAVITIES    ', t76,i4/                             &
     &t10,'MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                         &
     &t10,'OFFSET MOMENTUM AMPLITUDE DP/P ',t66,f14.9/                  &
     &t10,'MACHINE LENGTH IN (M) ', t63,f17.9/                          &
     &t10,'PARTICLE MASS (MEV) ', t66,f14.9/                            &
     &t10,'ENERGY IN (MEV)',t66,f14.3)
10143 format(                                                           &
     &t10,'HARMONIC NUMBER',t74,f6.0/                                   &
     &t10,'CIRCUMF. VOLTAGE   (MV)',t66,f14.9/                          &
     &t10,'EQUILIBRIUM PHASE     (DEG)',t66,f14.9/                      &
     &t10,'FREQUENCY (IN UNITS OF REVOLUTION-FREQ.) QS-LINEAR',         &
     &t66 ,f14.9/                                                       &
     &t10,'MOMENTUM COMPACTION',t66,f14.9/)
10150 format(//t43,'*** TRACKING PARAMETERS ***'/)
10160 format(t10,'NUMBER OF REVOLUTIONS  ',t48,i8/ t10,                 &
     &'NUMBER OF REVERSE-REVOLUTIONS',t48,i8/ t10,                      &
     &'TURNS PER COOR.-PRINTOUT',t48,i8/ t10,'FLAT BOTTOM UP TO TURN ', &
     &t48,i8/ t10,'TURNS PER PRINT ON DATASET',t48,i8/ t10,             &
     &'ACCELERATION UP TO TURN',t48,i8/ t10,'TURNS PER PRINT ON DATASET'&
     &,t48,i8/ t10,'FLAT TOP NUMBER OF TURNS',t48,i8/ t10,              &
     &'TURNS PER PRINT ON DATASET',t48,i8/ t10,                         &
     &'TRACKING START AT ELEMENT NO.',t48,i8/ t10,                      &
     &'INITIAL AMPLITUDE-H IN (MM)',t49,f7.3/ t10,                      &
     &'COUPLING  EPS-Y/EPS-X',t49,f7.3/ t10,                            &
     &'NUMBER OF C.-O. ITERATIONS ',t48,i8/ t10,                        &
     &'PRECISION OF C.-O. DEVIATION',t47,d10.3/ t10,                    &
     &'PRECISION OF C.-O. SLOPE   ',t47,d10.3/ t10,                     &
     &'NUMBER OF Q-ADJ. ITERATIONS',t48,i8/ t10,                        &
     &'CHANGE IN K-STRENGTH BY',t47,d10.3/ t10,                         &
     &'PRECISION OF Q-ADJUSTEMENT',t47,d10.3)
10170 format(t10,'NUMBER OF CHROMAT.-ADJ. ITER.',t48,i8/ t10,           &
     &'CHANGE IN SEX.-STRENGTH BY',t47,d10.3/ t10,                      &
     &'PRECISION OF CHROMAT.-ADJ.',t47,d10.3/ t10,                      &
     &'DP-INTERVAL F. CROMAT.-ADJ.',t47,d10.3/ t10,                     &
     &'DP-INTERVAL FOR DISPERSION',t47,d10.3/ t10,                      &
     &'PRECISION FOR C.-O. RMS',t47,d10.3/)
10180 format(t5/t10,a60)
10190 format(t10,'PROGRAM MODE : FREE FORMAT INPUT')
10200 format(t10,'PROGRAM MODE : FREE FORMAT INPUT --READ FROM ',       &
     &'EXTRA GEOMETRY STRENGTH FILE--')
10220 format(t10,i4,2(' ',d15.8),5x,2(' ',d15.8))
10250 format(t10,'NUMBER OF DIFFERENT BLOCKS',t50,i5/ t10,              &
     &'BLOCKS PER PERIOD',t49,i5//)
10290 format(t10,'MORE THAN ',i5,' COMBINATIONS SPECIFIED'/)
10300 format(//131('-')//t10,'DATA BLOCK COMBINATION OF ELEMENTS',      &
     &'  THE FOLLOWING ELEMENTS ARE RELATED IN STRENGTHS--->'/ t10,     &
     &'ELEMENT RELATED TO ELEMENT BY THE RATIO'/)
10320 format(//131('-')//t10,'DATA BLOCK APERTURE LIMITATIONS'/ /t10)
10340 format(t10,'NO CAVITIES SPECIFIED'/)
10350 format(//131('-')//t10,'DATA BLOCK ORGANISATION OF RANDOM NUMBERS'&
     &/5x,'|          |      OWN RANDOM NUMBERS      |      SAME RAN' , &
     &'DOM NUMBERS      |   SAME MULTIPOLECOEFFICIENTS  |'/131('-'))
10370 format(t10,'DESIRED TUNE TO ADJUST IS ZERO'/ t10,                 &
     &'DATA BLOCK TUNE ADJUSTMENT  IGNORED')
10380 format(t10,'HIGHER MULTIPOLES THAN 20-POLES ARE NOT ALLOWED' ,    &
     &' AND THEREFORE IGNORED')
10410 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
!10420 format(t10,22('O')/t10,2('O'),18x,2('O')/t10,                     &
!     &'OO   NORMAL FORMS   OO', /t10,2('O'),18x,2('O')/t10,22('O'))
10430 format(/5x,'No cut on random distribution'//)
10440 format(/5x,'Random distribution has been cut to: ',i4,' sigma.'//)
10500 format(//131('-')//t10,'SUMMARY OF DATA BLOCK ',a4,' INFOs')
10520 format(//131('-')//t10,'DATA BLOCK ',a4,' INFOs'/ /t10,           &
     &'NAME',20x,'TYPE',5x,'INSERTION POINT',4x,'SYNCH LENGTH [m]')
10070 format(1x,i5,1x,a16,1x,i3,1x,d17.10,1x,d17.10,1x,d17.10,1x,d14.7, &
     &1x,d13.6,1x,d14.7,1x,d13.6)
10210 format(t10,'DATA BLOCK MULTIPOLE COEFFICIENTS'/ t10,              &
     &'MULTIPOLE                    ',a16/t10,'RADIUS IN MM            '&
     &,f15.7/ t10,'BENDING STRENGTH IN MRAD',f15.7// t10,19x,'NORMAL',25&
     &x,'      SKEW '// t10,'      MEAN            RMS-VALUE     ',     &
     &'       MEAN            RMS-VALUE'/)
!10240 format(t10,a16,3(2x,d16.10),2x,i10)
10260 format(t4,i4,1x,a16,1x,i2,1x,6(1x,a16))
10270 format(t28,6(1x,a16))
10280 format(t3,i6,1x,5(a16,1x))
10310 format(t10,a16,10x,a16,6x,f20.15)
10360 format(5x,'| ELEMENT  |           ',a16,'           |           ',&
     &'    |               |               |               |')
10390 format(5x,'| ELEMENTS |                              |    ',a16,  &
     &'   |    ',a16,'   |               |               |')
10400 format(5x,'| ELEMENTS |                              |          ' &
     &,'     |               |    ',a16,'   |    ',a16,'   |')
10490 format(t10,a16,4x,a40,2x,1pe16.9)
10510 format(t10,a16,4x,i8,12x,i8,4x,1pe16.9)
10700 format(t10,'DATA BLOCK TROMBONE ELEMENT'/                         &
     &t10,'TROMBONE #      NAME'/)
10710 format(t22,i4,5x,a16)
10890 format(1x,'--> function ',i2,' of combo # ',i4,' of element',a16, &
     &'does not exist!')
10891 format(1x,'--> single element ',a16,' is a thick lens one!')
end subroutine daten

      real(kind=fPrec) function eLensTheta( len, Int, Ekin, Etot, r2 )
!-----------------------------------------------------------------------
!     compute eLens theta at r2
!     input variables:
!     - length of eLens [m];
!     - current intensity of e-beam [A]
!     - kinetic energy of electrons [keV]
!     - total beam energy [MeV]
!     - outer radius [mm]
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use physical_constants
      use crcoall
      use mod_common
      implicit none
      real(kind=fPrec) gamma, beta_e, beta_b, brho, len, Int, Ekin, Etot, r2
      gamma=Ekin*c1m3/pmae+1 ! from kinetic energy
      beta_e=sqrt((gamma+one)*(gamma-one))/(gamma)
      gamma=Etot/pma ! from total energy
      beta_b=sqrt((gamma+one)*(gamma-one))/(gamma)
      brho=Etot/(clight*c1m6)
!     r2: from mm to m
!     theta: from rad to mrad
      eLensTheta=len*abs(Int)/(2*pi*eps0*brho*clight**2*r2*c1m3)*c1e3
      if ( Int.lt.zero ) then
         eLensTheta=eLensTheta*(one/(beta_e*beta_b)+one)
      else
         eLensTheta=eLensTheta*(one/(beta_e*beta_b)-one)
      end if
      end function eLensTheta

subroutine parseChebyFile(ifile)
!-----------------------------------------------------------------------
!     read file with coefficients for chebyshev polynomials
!     ifile is index of file in table of chebyshev files        
!     file is structured as:
!        keyword : value
!     keywords:
!     - I: reference current intensity of e-beam [A]
!     - Ek: reference kinetic energy of electrons [keV]
!     - rad: reference radius [mm]
!     comment line is headed by '#'
!     coefficients are give with the following syntax:
!     i j : value
!     where i->x and j->y
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use physical_constants
      use crcoall
      use mod_common
      use elens
      use string_tools
      
      implicit none
      
      character(len=160) tmpstr
      character getfields_fields(getfields_n_max_fields)*(getfields_l_max_string) ! Array of fields
      integer   getfields_nfields                                                 ! Number of identified fields
      integer   getfields_lfields(getfields_n_max_fields)                         ! Length of each what:
      logical   getfields_lerr                                                    ! An error flag
      integer ierr, ii, jj, ifile, errno
      real(kind=fPrec) tmpflt, beta, gamma, round_near

      ierr=0
      write(lout,*)' Parsing file with coefficients for Chebyshev polynomials ' &
     &   //elens_cheby_filename(ifile)
      open(elens_cheby_unit,file=elens_cheby_filename(ifile),status='old')
      do while (.true.)
         read(elens_cheby_unit,'(A)',end=1982,err=1983) tmpstr
         if (tmpstr(1:1).ne.'#') then
            call getfields_split( tmpstr, getfields_fields, getfields_lfields, &
     &        getfields_nfields, getfields_lerr )
            if ( getfields_lerr ) then
               ierr=1
               goto 1983
            end if
            if (tmpstr(1:1).eq.'I') then
!              read reference current of e-beam in e-lens
               if (getfields_nfields.lt.3) then
                  ierr=2
                  goto 1983
               end if
#ifndef CRLIBM
               read (getfields_fields(3)(1:getfields_lfields(3)),*) tmpflt
#endif
#ifdef CRLIBM
               tmpflt=round_near(errno,getfields_lfields(3)+1,getfields_fields(3))
               if (errno.ne.0) call rounderr (errno,getfields_fields,3,tmpflt)
#endif
               elens_cheby_refCurr(ifile)=tmpflt
               
            elseif (tmpstr(1:2).eq.'Ek') then
!              read reference kinetic energy of e-beam in e-lens
               if (getfields_nfields.lt.3) then
                  ierr=3
                  goto 1983
               end if
#ifndef CRLIBM
               read (getfields_fields(3)(1:getfields_lfields(3)),*) tmpflt
#endif
#ifdef CRLIBM
               tmpflt=round_near(errno,getfields_lfields(3)+1,getfields_fields(3))
               if (errno.ne.0) call rounderr (errno,getfields_fields,3,tmpflt)
#endif
               gamma=tmpflt*c1m3/pmae+1 ! from kinetic energy
               elens_cheby_refBeta(ifile)=sqrt((gamma+one)*(gamma-one))/(gamma)
               
            elseif (tmpstr(1:3).eq.'rad') then
!              read reference radius e-beam in e-lens
               if (getfields_nfields.lt.3) then
                  ierr=4
                  goto 1983
               end if
#ifndef CRLIBM
               read (getfields_fields(3)(1:getfields_lfields(3)),*) tmpflt
#endif
#ifdef CRLIBM
               tmpflt=round_near(errno,getfields_lfields(3)+1,getfields_fields(3))
               if (errno.ne.0) call rounderr (errno,getfields_fields,3,tmpflt)
#endif
               elens_cheby_refRadius(ifile)=tmpflt
               
            else
!              read chebyshev coefficients
               if (getfields_nfields.ne.4) then
                  ierr=5
                  goto 1983
               end if
               read (getfields_fields(1)(1:getfields_lfields(1)),*) ii
               if (ii.gt.elens_cheby_order) then
                  ierr=6
                  goto 1983
               end if
               read (getfields_fields(2)(1:getfields_lfields(2)),*) jj
               if (jj.gt.elens_cheby_order) then
                  ierr=7
                  goto 1983
               end if
#ifndef CRLIBM
               read (getfields_fields(4)(1:getfields_lfields(4)),*) tmpflt
#endif
#ifdef CRLIBM
               tmpflt=round_near(errno,getfields_lfields(4)+1,getfields_fields(4))
               if (errno.ne.0) call rounderr (errno,getfields_fields,4,tmpflt)
#endif
               elens_cheby_coeffs(ii,jj,ifile)=tmpflt
            end if ! close if for keyword identification
         end if ! close if for non-comment chars
      end do
1983  write(lout,*) 'ERROR ',ierr,' while parsing file '//elens_cheby_filename(ifile)
      call prror(-1)
1982  close(elens_cheby_unit)

      ! echo parsed data
      write(lout,fmt='(/,A,1X,I4)') ' Coefficients for Chebyshev polynomials as from file ' &
     &//elens_cheby_filename(ifile)//' - #',ifile
      write(lout,fmt='(A,1X,1PE10.3)') ' - reference current [A]:',elens_cheby_refCurr(ifile)
      write(lout,fmt='(A,1X,1PE10.3)') ' - reference beta     []:',elens_cheby_refBeta(ifile)
      write(lout,fmt='(A,1X,1PE10.3)') ' - reference radius [mm]:',elens_cheby_refRadius(ifile)
      do ii=0,elens_cheby_order
         do jj=0,elens_cheby_order
            if (elens_cheby_coeffs(ii,jj,ifile).ne.zero) then
               write(lout,fmt='(2(1X,I4)," : ",1PE10.3)') ii,jj,elens_cheby_coeffs(ii,jj,ifile)
            end if
         end do
      end do
      
end subroutine parseChebyFile
      
subroutine write4
!-----------------------------------------------------------------------
!     WRITE MODIFIED GEOMETRY FILE ON UNIT 4
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_common
      implicit none
      integer ii,ikz
      real(kind=fPrec) rdum1,rdum2,rel1
      character(len=160)  ch
      character(len=320) ch1
      character(len=max_name_len) idat
      integer lineno2,lineno3,lineno8,lineno16,lineno30,lineno35
      data lineno2 /0/
      data lineno3 /0/
      data lineno8 /0/
      data lineno16 /0/
      data lineno30 /0/
      data lineno35 /0/ 
      save
!-----------------------------------------------------------------------
      ii=0
      rewind 2
 1    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
        goto 1
      elseif(ch(:4).eq.'SING') then
        write(4,*) ch
      else
        return
      endif
 2    read(2,*,end=90) ch
      lineno2=lineno2+1
      if(ch(:1).eq.'/') then
        write(4,*) ch
      else
        ii=ii+1
        if(ch(:4).ne.'NEXT') then
          call intepr(1,1,ch,ch1)
#ifdef FIO
          read(ch1,*,round='nearest')                                   &
     & idat,ikz,rdum1,rdum2,rel1
#endif
#ifndef FIO
          read(ch1,*) idat,ikz,rdum1,rdum2,rel1
#endif
          if(ikz.eq.11) then
            write(4,10000) idat,ikz,rdum1,rdum2,rel1
          else
            if(abs(rel1).le.pieni) then
              if(ncororb(ii).eq.0) then
                write(4,10000) idat,ikz,sm(ii),rdum2,rel1
              else
                write(4,10000) idat,ikz,sm(ii),ek(ii),rel1
              endif
            else
              write(4,10000) idat,ikz,rdum1,ek(ii),rel1
            endif
          endif
        else
          write(4,*) ch
          goto 3
        endif
      endif
      goto 2
 3    read(2,*,end=90) ch
      lineno2=lineno2+1
      write(4,*) ch
      goto 3
 90   continue
10000 format(a16,1x,i2,1x,d22.15,1x,d22.15,1x,d17.10)
end subroutine write4

subroutine intepr(i,j,ch,ch1)
!-----------------------------------------------------------------------
!     SUBROUTINE TO INTEPRET INPUT WITH CHARACTERS AND NUMBERS MIXED
!
!     I ... TYPE OF COMBINATION
!
!         1  LINE WITH 1 CHARACTERSTRING FOLLOWED BY NUMBERS
!         2  LINE WITH CHARACTERSTRINGS, IF THE FIRST 5 CHARACTERS
!            ARE BLANKS THIS IS INTERPRETED AS A BLANK CHARACTER
!         3  LINE WITH CHARACTERSTRINGS
!         4  LINE WITH 2 CHARACTERSTRINGS
!         5  LINE WITH 1 CHARACTERSTRING AND N*(NUMBER,CHA.STRING)
!         6  LINE WITH 1 NUMBER AND 2 CHARACTERSTRINGS
!         7  LINE WITH 1 NUMBER, 2 CHARACTERSTRINGS AND NUMBERS
!         8  LINE WITH 2 CHARACTERSTRINGS AND NUMBERS
!
!     J ... SKIP THE FIRST (J-1) CHARACTERS OF CHARACTERSTRING CH
!    CH ... INPUT CHARACTERSTRING
!   CH1 ... OUTPUT CHARACTERSTRING
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      implicit none
!ERIC
      integer i,i0,i1,i2,i3,i4,iev,ii,j
      integer nchars
      parameter (nchars=160)
      character(len=nchars) ch
      character(len=nchars+nchars) ch1
      save
!-----------------------------------------------------------------------
      i0=0
      i1=j
      i2=1
      i4=0
      do 10 ii=j,nchars
        if(i0.eq.0.and.ch(ii:ii).eq.' ') then
          if(i.eq.2.and.ii.eq.5.and.ch(:5).eq.'     ') then
            ch1(:4)=''' '' '
            i2=5
          endif
          i1=ii+1
          goto 10
        endif
        i0=1
        if(ch(ii:ii).eq.' ') then
          i4=i4+1
          iev=1
          if(mod(i4,2).eq.0) iev=0
          if(i.eq.1) goto 20
          if(i.eq.2.or.i.eq.3.or.i.eq.4.or. (i.eq.5.and.iev.eq.1.).or.  &
     &(i.eq.6.and.i4.ge.2).or. (i.eq.7.and.(i4.eq.2.or.i4.eq.3)).or.    &
     &(i.eq.8.and.i4.lt.3)) then
            i3=((i2+ii)-i1)+2                                            !hr05
            ch1(i2:i3)=''''//ch(i1:ii-1)//''' '
            if(i.eq.4.and.i4.eq.2) goto 30
            i2=i3+1
          endif
          if((i.eq.5.and.iev.eq.0).or. (i4.eq.1.and.(i.eq.6.or.i.eq.7)))&
     &then
            i3=(i2+ii)-i1                                                !hr05
            ch1(i2:i3)=ch(i1:ii)
            i2=i3+1
          endif
          if((i.eq.7.and.i4.gt.3).or.(i.eq.8.and.i4.eq.3)) goto 40
          i0=0
          i1=ii+1
        endif
   10 continue
      goto 30
   20 ch1(1:nchars+nchars)=''''//ch(i1:ii-1)//''''//ch(ii:nchars)//' / '
      return
   30 i3=i3+1
      ch1(i3:i3+2)=' / '
      return
   40 i3=i2+nchars+3-i1
      ch1(i2:i3)=ch(i1:nchars)//' / '
      return
      end
      
subroutine initialize_element(ix,lfirst)
!-----------------------------------------------------------------------
!     K.Sjobak & A.Santamaria, BE-ABP/HSS
!     last modified: 23-12-2016
!     Initialize a lattice element with index elIdx,
!     such as done when reading fort.2 (GEOM) and in DYNK.
!     
!     Never delete an element from the lattice, even if it is not making a kick.
!     If the element is not recognized, do nothing (for now).
!     If trying to initialize an element (not lfirst) which is disabled,
!     print an error and exit.
!-----------------------------------------------------------------------

      use floatPrecision
      use end_sixtrack
      use dynk, only : dynk_elemdata
      use numerical_constants
      use crcoall
      use string_tools
      use parpro !Needed for common
      use mod_common
      use mod_commont
      use mod_commonmn
      use elens
      use wire
      implicit none
      
      integer, intent(in) :: ix
      logical, intent(in) :: lfirst

      integer im, izu, k, m, nmz, r0, r0a !needed to use multini

      !Temp variables
      integer i

!--Nonlinear Elements
! TODO: Merge these cases into 1 + subcases?
      if(abs(kz(ix)).eq.1) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)             ! Also done in envar() which is called from clorb()
                 smiv(1,i)=sm(ix)+smizf(i) ! Also done in program maincr
                 smi(i)=smiv(1,i)          ! Also done in program maincr
#include "include/stra01.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.2) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra02.f90"
               endif
            enddo
         endif
      elseif(abs(kz(ix)).eq.3) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra03.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.4) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra04.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.5) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra05.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.6) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra06.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.7) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra07.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.8) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra08.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.9) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra09.f90"
               endif
            enddo
         endif

      elseif(abs(kz(ix)).eq.10) then
         if(.not.lfirst) then
            do i=1,iu
               if ( ic(i)-nblo.eq.ix ) then
                 if(ktrack(i).eq.31) goto 100 !ERROR
                 sm(ix)=ed(ix)
                 smiv(1,i)=sm(ix)+smizf(i)
                 smi(i)=smiv(1,i)
#include "include/stra10.f90"
               endif
            enddo
         endif

!--Multipoles
      elseif(kz(ix).eq.11) then
         
         !MULT support removed until we have a proper use case.
!c$$$         if (lfirst) then
!c$$$            dynk_elemdata(ix,1) = el(ix) !Flag for type
!c$$$            dynk_elemdata(ix,2) = ed(ix) !Bending strenght
!c$$$            dynk_elemdata(ix,3) = ek(ix) !Radius
!c$$$         else
!c$$$            el(ix) = dynk_elemdata(ix,1)
!c$$$            dynk_elemdata(ii,2) = ed(ii) !Updated in dynk_setvalue
!c$$$            ek(ii) = dynk_elemdata(ix,3)
!c$$$         end if
         
         ! Moved from daten():
         if (abs(el(ix)+one).le.pieni) then
            dki(ix,1) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         else if(abs(el(ix)+two).le.pieni) then
            dki(ix,2) = ed(ix)
            dki(ix,3) = ek(ix)
            ed(ix) = one
            ek(ix) = one
            el(ix) = zero
         endif
         !Otherwise, i.e. when el=0, dki(:,1) = dki(:,2) = dki(:,3) = 0.0

         !MULT support removed until we have a proper use case.
!c$$$         !All multipoles:
!c$$$         if(.not.lfirst) then
!c$$$            do i=1,iu
!c$$$               if ( ic(i)-nblo.eq.ix ) then
!c$$$                  if(ktrack(i).eq.31) goto 100 !ERROR
!c$$$                  !--Initialize smiv as usual
!c$$$                  sm(ix)=ed(ix)
!c$$$                  smiv(m,i)=sm(ix)+smizf(i)
!c$$$                  smi(i)=smiv(m,i)
!c$$$
!c$$$                  !--Using the right izu & setting aaiv, bbiv (see multini)
!c$$$                  izu = dynk_izuIndex(ix)
!c$$$+ca multini !Also in program maincr()
!c$$$ 150              continue ! needs to be after a multini block
!c$$$
!c$$$                  ! From trauthin()&trauthck() (they are identical)
!c$$$                  r0=ek(ix)
!c$$$                  nmz=nmu(ix)
!c$$$                  if(abs(r0).le.pieni.or.nmz.eq.0) then
!c$$$                     if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                    abs(dki(ix,2)).le.pieni) then
!c$$$C                       ktrack(i)=31
!c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
!c$$$     &                       abs(dki(ix,2)).le.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                          ktrack(i)=33
!c$$$+ca stra11
!c$$$                        else
!c$$$C                          ktrack(i)=35
!c$$$+ca stra12
!c$$$                        endif
!c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                       abs(dki(ix,2)).gt.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=37
!c$$$+ca stra13
!c$$$                        else
!c$$$C                            ktrack(i)=39
!c$$$+ca stra14
!c$$$                        endif
!c$$$                     endif
!c$$$                  else
!c$$$                     if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                    abs(dki(ix,2)).le.pieni) then
!c$$$C                        ktrack(i)=32
!c$$$                     else if(abs(dki(ix,1)).gt.pieni .and.
!c$$$     &                       abs(dki(ix,2)).le.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=34
!c$$$+ca stra11
!c$$$                        else
!c$$$C                           ktrack(i)=36
!c$$$+ca stra12
!c$$$                        endif
!c$$$                     else if(abs(dki(ix,1)).le.pieni .and.
!c$$$     &                       abs(dki(ix,2)).gt.pieni) then
!c$$$                        if(abs(dki(ix,3)).gt.pieni) then
!c$$$C                           ktrack(i)=38
!c$$$+ca stra13
!c$$$                        else
!c$$$C                           ktrack(i)=40
!c$$$+ca stra14
!c$$$                        endif
!c$$$                     endif
!c$$$                  endif
!c$$$               endif
!c$$$            enddo
!c$$$         endif

!--Cavities (ktrack = 2 for thin)
      elseif(abs(kz(ix)).eq.12) then
         !Moved from daten
         phasc(ix) = el(ix)
         el(ix) = zero
         dynk_elemdata(ix,3) = phasc(ix)
         if (.not.lfirst) then

            ! Doesn't work, as i is not initialized here.
            !if (.not.ktrack(i).eq.2) goto 100 !ERROR
            
            phasc(ix) = phasc(ix)*rad
            
            hsyc(ix) = ((two*pi)*ek(ix))/tlen         ! daten SYNC block
            hsyc(ix)=(c1m3*hsyc(ix))*real(itionc(ix),fPrec) ! trauthin/trauthck
         endif
!--BEAM-BEAM
      elseif(kz(ix).eq.20) then
         if (lfirst) then
            ! Only for old-style BEAM-BEAM lenses
            ! if DYNK-ified, there needs to be checks for parbeam_exp as well,
            ! as in this case modifying ed/ek/el and then calling initialize_element
            ! would be neccessary...
            ! Note that the BEAM::EXPERT block input checker relies on the data from
            ! ed/ek/el has been moved to parbe/ptnfac.
            ! For DYNKification of BEAM, I think lots of the code from
            ! trauthin/trauthck needs to be copied here?
            ptnfac(ix)=el(ix)
            el(ix)=zero

            parbe(ix,5) = ed(ix)
            ed(ix)=zero
            parbe(ix,6) = ek(ix)
            ek(ix)=zero
         endif
!--Crab Cavities
!   Note: If setting something else than el(),
!   DON'T call initialize_element on a crab, it will reset the phase to 0.
      elseif(abs(kz(ix)).eq.23) then
         !Moved from daten()
         crabph(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 2
      elseif(abs(kz(ix)).eq.26) then
         !Moved from daten()
         crabph2(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 3
      elseif(abs(kz(ix)).eq.27) then
         !Moved from daten()
         crabph3(ix)=el(ix)
         el(ix)=zero
!--CC Mult kick order 4
      else if(abs(kz(ix)).eq.28) then
         !Moved from daten()
         crabph4(ix)=el(ix)
         el(ix)=zero
!--Wire
      else if(kz(ix).eq.15) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
!--e-lens
      else if(kz(ix).eq.29) then
         ed(ix)=zero
         ek(ix)=zero
         el(ix)=zero
      endif

      return

      !Error handlers
 100  continue
      write (lout,*) "ERROR in initialize_element, tried to set"
      write (lout,*) "the strength of an element which is disabled."
      write (lout,*) "bez = ", bez(ix)
      call prror(-1)

end subroutine initialize_element

#ifdef CRLIBM
      
subroutine splitfld(errno,nunit,lineno,nfields,nf,chars,fields)
      use floatPrecision
      use crcoall
      implicit none
      integer errno,nunit,lineno,nfields,nf,i,j,k,l,lf
      character(len=*) chars
      character(len=*) fields(*)
      character(len=999) localstr
!     This routine splits the chars input into space separated
!     fields, up to nfields maximum. It returns the no of
!     fields in nf. All spaces are ignored but treated as separators.
!     A / is a line terminator as provided in ch1 typically.
!     This corresponds to Fortran treatment with an * format spec.
            
      j=0
      nf=0
      do i=1,nfields
        fields(i)=' '
         
        ! Get the length we can use to store a field,
        ! should be equal to maxf in the calling function
        lf=len(fields(i))

 8889   k=0   !Index into the current field; goto label for new field or no field yet
 8888   j=j+1 !Index into the input array; goto label for reading another character
        ! Check that we stay within the given length of chars
        if (j.gt.len(chars)) then
          errno=1
          go to 8887
        endif

        !Don't start a new field before we hit a non-space
        if (k.eq.0.and.chars(j:j).eq.' ') go to 8888

        if (chars(j:j).ne.' '.and.chars(j:j).ne.'/') then
          !We have a field
          k=k+1
          if (k.ge.lf) then
            !Field is too long;
            ! remember that the last position (#lf in FORTRAN, lf-1 in C)
            ! is reseved for a \0, to be used in the C code.
            do j=1,nf
              l=len(fields(j))
              localstr=fields(j)(1:l)
              write(lout,*) 'splitfld:'//localstr(1:lf)//':'
            enddo
            errno=2
            call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
          endif
          fields(i)(k:k)=chars(j:j)
          go to 8888
        else
          if (chars(j:j).eq.'/') then
! we are all through but may have a field
            if (k.ne.0) nf=nf+1
! Eric for debug
!     do j=1,nf
!       l=len(fields(j)
!       localstr=fields(j)(1:l)
!       write(*,*) 'splitfld:'//localstr)//':'
!     enddo
            return
          else
! Must have a space, field separator
            nf=nf+1
          endif
        endif
      enddo
      
 8890 continue
! If we get here we have a problem unless there
! is nothing left but ' '*/
 8886 j=j+1
      if (j.gt.len(chars)) go to 8887
      if (chars(j:j).eq.'/') return
      if (chars(j:j).eq.' ') go to 8886
      errno=3
 8887 continue
! Eric for debug
      do j=1,nf
        l=len(fields(j)) 
        localstr=fields(j)(1:l)
        write(lout,*) 'splitfld:'//localstr//':'
      enddo
      call spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
end subroutine splitfld

real(kind=fPrec) function fround(errno,fields,f)
  ! This is also implemented in module string_tools
  !   as functions str_toReal and chr_toReal
  use floatPrecision
  implicit none
  integer maxf
  ! MAXF be kept in sync with maxf in various routines
  ! We maybe should use len(field(f)) here, like is done in splitfld...
  parameter (maxf=30)
  integer errno,f
  character(len=*) fields(*)
  real(kind=real64) round_near,value
  real(kind=real64) ftemp
  ftemp=round_near(errno,maxf,fields(f))
  fround=real(ftemp,fPrec)

  if (errno.ne.0) then
    value=fround
    call rounderr(errno,fields,f,value)
  endif
  return
end function fround
      
subroutine rounderr(errno,fields,f,value)
  use floatPrecision
  use end_sixtrack
  use crcoall
  implicit none
  integer nchars,nofields
  integer errno,nfields,f,l
  character(len=*) fields(*)
  character(len=999) localstr
  real(kind=fPrec) value

  write (lout,10000)
  write (lout,*) 'Data Input Error (probably in subroutine daten)'
  write (lout,*) 'Overfow/Underflow in strtod()'
  write (lout,*) 'Errno: ',errno
  l=len(fields(f))
  localstr=fields(f)(1:l)
  write (lout,*) 'f:fieldf:',f,':'//localstr
  write (lout,*) 'Function fround (rounderr) returning:',value
  
  call prror(-1)
      
10000 format(5x//&
             /t10,'++++++++++++++++++++++++'&
             /t10,'+++++ERROR DETECTED+++++'&
             /t10,'++++++++++++++++++++++++'/)
end subroutine rounderr
      
subroutine spliterr(errno,nunit,lineno,nfields,nf,lf,chars)
  
      use end_sixtrack
      use crcoall
      implicit none
      integer errno,nunit,lineno,nfields,nf,lf,l
      character(len=*) chars
      character(len=999) localstr
      write (lout,10000)
      write (lout,*) 'Data Input Error (probably in subroutine daten)'
      write (lout,*) 'Reading unit no (fort.)',nunit,' Line',lineno
      l=len(chars)
      localstr=chars(1:l)
      write (lout,*) 'Input line:'//localstr//':'
      if (errno.eq.1) then
        write (lout,*)                                                     &
     &  'Input string too long, exceeds',len(chars),' characters'
      endif
      if (errno.eq.2) then
        write (lout,*)                                                     &
     &  'Field too long, exceeds',lf,' characters'
      endif
      if (errno.eq.3) then
        write (lout,*)                                                     &
     &  'Too many input fields, maximum of',nfields,' exceeded'
      endif
      
      call prror(-1)
      
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
end subroutine spliterr
      
integer function dtostr(x,results)
! Uses the dtoa_c.c version of dtoa via the dtoaf.c interface in
! crlibm
      use floatPrecision
      use end_sixtrack
      use crcoall
      implicit none
      real(kind=fPrec) x
      character(len=24) results
      integer dtoaf 
      integer ilen,mode,ndigits,decpoint,mysign
      integer i,l,d,e
      character(len=1) str(17)
      character(len=24) lstr
      character(len=3) e3
      
      mode=2
      ndigits=17
      ilen=dtoaf(x,mode,ndigits,decpoint,mysign,str(1),1)
      if (ilen.le.0.or.ilen.gt.17) then
! Always returns 17 or less characters as requested
      write (lout,10000)
      write (lout,*) 'Routine dtoa[f] returned string length ',ilen
      write (lout,*) 'Error from dtostr, string length not 17'
      call prror(-1)
      
10000 format(5x///t10,'++++++++++++++++++++++++'/ t10,                  &
     &'+++++ERROR DETECTED+++++'/ t10,'++++++++++++++++++++++++'/ t10)
! Never returns
      endif
      lstr=' '
      do i=1,ilen
        lstr(i:i)=str(i)
      enddo
! Now try my formatting
      d=decpoint
      e=0
      l=1
      lstr=' '
      if (mysign.ne.0) then
        lstr(l:l)='-'
      endif
      if (decpoint.eq.9999) then
! Infinity or Nan
        do i=1,ilen
          lstr(l+i:l+i)=str(i)
        enddo
      else
! Pad with zeros
        do i=ilen+1,17
          str(i)='0'
        enddo
        if (decpoint.le.0) then
          e=decpoint-1
          d=1
        else
! I am using 17 as decision point to avoid dddd.e+eee
! but rather d.ddde+eee
          if (decpoint.ge.17) then
            e=decpoint-1
            d=1
          else
            d=decpoint
          endif
        endif
! and copy with the decimal point
        do i=1,17
          lstr(l+i:l+i)=str(i)
          if (i.eq.d) then
            l=l+1
            lstr(l+i:l+i)='.'
          endif
        enddo
! and add exponent e+/-nnn
        l=20
        lstr(l:l)='e'
        l=21
        lstr(l:l)='+'
        if (e.lt.0) then
          lstr(l:l)='-'
          e=-e
        endif
        l=22
        write (e3,'(I3.3)') e
        lstr(l:l+2)=e3(1:3)
      endif  
      results=lstr(1:24)
      dtostr=24
      return
end function dtostr
      
#endif
      
      subroutine wzset
!  *********************************************************************
!
!  This subroutine must be called before subroutine WZSUB can be used to
!  compute values of the complex error function w(z).
!
!  Parameters xcut and ycut specify the opposite corners (xcut,0) and
!  (0,ycut) of the rectangle inside which interpolation is to be used
!  by subroutine WZSUB.
!
!  Parameter h is the side of the squares of the interpolation grid.
!
!  Parameters nx and ny must be set to the nearest integers to xcut/h
!  and ycut/h respectively (or to larger values).
!
!  Calls MYWWERF new version of (CERN library) WWERF (C335)
!
!  (G.A.Erskine, 29.09.1995)
!
!  *********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use parbeam
      implicit none
      integer i,j,k
      real(kind=fPrec) wi,wr,x,y
      save
!-----------------------------------------------------------------------
      hrecip = one/h
      kstep = nx+2
      k = 0
      do 2 j=0,ny+1
         do 1 i=0,nx+1
            k = k+1
            x=real(i,fPrec)*h                                                  !hr05
            y=real(j,fPrec)*h                                                  !hr05
            call mywwerf(x,y,wr,wi)
            wtreal(k)=wr
            wtimag(k)=wi
 1       continue
 2    continue
      end subroutine wzset

      subroutine mywwerf(x,y,wr,wi)
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      implicit none
      integer n
      real(kind=fPrec) c,c1,c2,c3,c4,hf,p,rr,ri,sr0,sr,si,tr,ti,vi,vr,  &
     &wi,wr,x,xa,xl,y,ya,zhi,zhr,z1,z10
      parameter (z1=one,hf=z1/two,z10=c1e1)
      parameter (c1=74.0_fPrec/z10,c2=83.0_fPrec/z10)
      parameter (c3=z10/32.0_fPrec,c4=16.0_fPrec/z10)
!     parameter (c=1.12837916709551257d0,p=(2d0*c4)**33)
      parameter (c=1.12837916709551257_fPrec)
      parameter (p=46768052394588893.3825_fPrec)
      dimension rr(37),ri(37)
      save
!-----------------------------------------------------------------------
      xa=abs(x)
      ya=abs(y)
      if(ya.lt.c1.and.xa.lt.c2) then
!        zh=dcmplx(ya+c4,xa)
        zhr=ya+c4
        zhi=xa
        rr(37)=zero
        ri(37)=zero
        do n=36,1,-1
!          t=zh+n*dconjg(r(n+1))
          tr=zhr+real(n,fPrec)*rr(n+1)                                         !hr05
          ti=zhi-real(n,fPrec)*ri(n+1)                                         !hr05
!          r(n)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(n)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(n)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
        xl=p
        sr=zero
        si=zero
        do n=33,1,-1
          xl=c3*xl
!          s=r(n)*(s+xl)
          sr0=rr(n)*(sr+xl)-ri(n)*si
          si=rr(n)*si+ri(n)*(sr+xl)
          sr=sr0
        enddo
!        v=c*s
        vr=c*sr
        vi=c*si
      else
        zhr=ya
        zhi=xa
        rr(1)=zero
        ri(1)=zero
        do n=9,1,-1
!          t=zh+n*dconjg(r(1))
          tr=zhr+real(n,fPrec)*rr(1)                                           !hr05
          ti=zhi-real(n,fPrec)*ri(1)                                           !hr05
!          r(1)=hf*t/(dreal(t)**2+dimag(t)**2)
          rr(1)=(hf*tr)/(tr**2+ti**2)                                    !hr05
          ri(1)=(hf*ti)/(tr**2+ti**2)                                    !hr05
        enddo
!        v=c*r(1)
        vr=c*rr(1)
        vi=c*ri(1)
      endif
      if(ya.eq.zero) then                                                 !hr05
!        v=dcmplx(exp(-xa**2),dimag(v))
        vr=exp_mb(-one*xa**2)                                            !hr05
      endif
      if(y.lt.zero) then
!        v=2*exp(-dcmplx(xa,ya)**2)-v
        vr=(two*exp_mb(ya**2-xa**2))*cos_mb((two*xa)*ya)-vr              !hr05
        vi=(-two*exp_mb(ya**2-xa**2))*sin_mb((two*xa)*ya)-vi             !hr05
        if(x.gt.zero) vi=-one*vi                                          !hr05
      else
        if(x.lt.zero) vi=-one*vi                                          !hr05
      endif
      wr=vr
      wi=vi
      return
      end

+dk envars
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!-----------------------------------------------------------------------
subroutine envars(j,dpp,rv)
  
  use floatPrecision
  use mathlib_bouncer
  use numerical_constants
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  use mod_commond
  implicit none
  integer i,ih,j,kz1,l,ll
  real(kind=fPrec) aek,afok,as3,as4,as6,co,dpd,dpp,dpsq,fi,fok,fok1,fokq,g,gl,hc,hi,hi1,hm,&
                   hp,hs,rho,rhoc,rhoi,rv,si,siq,sm1,sm12,sm2,sm23,sm3,sm5,sm6,wf,wfa,wfhi
#ifdef SIXDA
  integer jm,k,m,na,ne
#endif
  save
  
  dpd  = one+dpp
  dpsq = sqrt(dpd)
  do i=1,il
    do ll=1,6
      do l=1,2
        al(ll,l,j,i) = zero
        as(ll,l,j,i) = zero
#ifdef SIXDA
        at(ll,l,j,i) = zero
        a2(ll,l,j,i) = zero
#endif
      end do
    end do
    
    if(abs(el(i)).le.pieni) cycle
    kz1 = kz(i)+1
    select case (kz1)
    case (1) ! DRIFTLENGTH
      do l=1,2
        al(1,l,j,i) = one
        al(2,l,j,i) = el(i)
        al(3,l,j,i) = zero
        al(4,l,j,i) = one
        as(6,l,j,i) = ((-one*rv)*al(2,l,j,i))/c2e3 ! hr05
      end do
      as(1,1,j,i) = (el(i)*(one-rv))*c1e3          ! hr05
      
    case (2,5)
      ! 2: RECTANGULAR MAGNET HORIZONTAL
      ! 5: RECTANGULAR MAGNET VERTICAL
      if (kz1.eq.2) then
        ih = 1
      else
        ih = 2
      end if
      fok=(el(i)*ed(i))/dpsq                                           !hr05
      if(abs(fok).le.pieni) then
        do l=1,2
          al(1,l,j,i) = one
          al(2,l,j,i) = el(i)
          al(3,l,j,i) = zero
          al(4,l,j,i) = one
          as(6,l,j,i) = ((-one*rv)*al(2,l,j,i))/c2e3 ! hr05
        end do
        as(1,1,j,i) = (el(i)*(one-rv))*c1e3          ! hr05
        cycle
      end if
      rho=(one/ed(i))*dpsq
      fok1=(tan_mb(fok*half))/rho
      si=sin_mb(fok)
      co=cos_mb(fok)
      al(1,ih,j,i)=one
      al(2,ih,j,i)=rho*si
      al(3,ih,j,i)=zero
      al(4,ih,j,i)=one
      al(5,ih,j,i)=((-one*dpp)*((rho*(one-co))/dpsq))*c1e3             !hr05
      al(6,ih,j,i)=((-one*dpp)*((two*tan_mb(fok*half))/dpsq))*c1e3     !hr05
      sm1=cos_mb(fok)
      sm2=sin_mb(fok)*rho
      sm3=(-one*sin_mb(fok))/rho                                       !hr05
      sm5=((-one*rho)*dpsq)*(one-sm1)                                  !hr05
      sm6=((-one*sm2)*dpsq)/rho                                        !hr05
      sm12=el(i)-sm1*sm2
      sm23=sm2*sm3
      as3=(-one*rv)*(((dpp*rho)/(two*dpsq))*sm23+sm5)                  !hr05
      as4=((-one*rv)*sm23)/c2e3                                        !hr05
      as6=((-one*rv)*(el(i)+sm1*sm2))/c4e3                             !hr05
      as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-sm2)))*c1e3 !hr05
      as(2,ih,j,i)=fok1*as3-rv*((dpp/((two*rho)*dpsq))*sm12+sm6)       !hr05
      as(3,ih,j,i)=as3
      as(4,ih,j,i)=as4+(two*as6)*fok1                                  !hr05
      as(5,ih,j,i)=(as6*fok1*2+fok1*as4)-(rv*sm12)/(c4e3*rho**2)       !hr05
      as(6,ih,j,i)=as6
      ! VERTIKAL
      ih=ih+1
      if(ih.gt.2) ih=1
      g=tan_mb(fok*half)/rho
      gl=el(i)*g
      al(1,ih,j,i)=one-gl
      al(2,ih,j,i)=el(i)
      al(3,ih,j,i)=(-one*g)*(two-gl)                                   !hr05
      al(4,ih,j,i)=al(1,ih,j,i)
      as6=((-one*rv)*al(2,ih,j,i))/c2e3                                !hr05
      as(4,ih,j,i)=((-one*two)*as6)*fok1                               !hr05
      as(5,ih,j,i)=as6*fok1**2                                         !hr05
      as(6,ih,j,i)=as6
      
    case (3)
      ! QUADRUPOLE
      ! FOCUSSING
      fok=ek(i)/(one+dpp)
      aek=abs(fok)
      if(abs(fok).le.pieni) then
        do l=1,2
          al(1,l,j,i) = one
          al(2,l,j,i) = el(i)
          al(3,l,j,i) = zero
          al(4,l,j,i) = one
          as(6,l,j,i) = ((-one*rv)*al(2,l,j,i))/c2e3 ! hr05
        end do
        as(1,1,j,i) = (el(i)*(one-rv))*c1e3          ! hr05
        cycle
      end if
      ih=0
      hi=sqrt(aek)
      fi=el(i)*hi
      if(fok.gt.zero) goto 110
100   ih=ih+1
      al(1,ih,j,i)=cos_mb(fi)
      hi1=sin_mb(fi)
      al(2,ih,j,i)=hi1/hi
      al(3,ih,j,i)=(-one*hi1)*hi                                       !hr05
      al(4,ih,j,i)=al(1,ih,j,i)
      as(1,ih,j,i)=(el(i)*(one-rv))*c1e3                               !hr05
      as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-one*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3 !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      if(ih.eq.2) cycle
      !--DEFOCUSSING
110   ih=ih+1
      hp=exp_mb(fi)
      hm=one/hp
      hc=(hp+hm)*half
      hs=(hp-hm)*half
      al(1,ih,j,i)=hc
      al(2,ih,j,i)=hs/hi
      al(3,ih,j,i)=hs*hi
      al(4,ih,j,i)=hc
      as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      if(ih.eq.1) goto 100
    
    case (4)
      ! 4: SEKTORMAGNET HORIZONTAL
      ! 6: SEKTORMAGNET VERTICAL
      if (kz1.eq.4) then
        ih = 1
      else
        ih = 2
      end if
      fok=(el(i)*ed(i))/dpsq                                           !hr05
      if(abs(fok).le.pieni) then
        do l=1,2
          al(1,l,j,i) = one
          al(2,l,j,i) = el(i)
          al(3,l,j,i) = zero
          al(4,l,j,i) = one
          as(6,l,j,i) = ((-one*rv)*al(2,l,j,i))/c2e3 ! hr05
        end do
        as(1,1,j,i) = (el(i)*(one-rv))*c1e3          ! hr05
        cycle
      end if
      rho=(one/ed(i))*dpsq
      si=sin_mb(fok)
      co=cos_mb(fok)
      rhoc=(rho*(one-co))/dpsq                                         !hr05
      siq=si/dpsq
      al(1,ih,j,i)=co
      al(2,ih,j,i)=rho*si
      al(3,ih,j,i)=(-one*si)/rho                                       !hr05
      al(4,ih,j,i)=co
      al(5,ih,j,i)=((-one*dpp)*rhoc)*c1e3                              !hr05
      al(6,ih,j,i)=((-one*dpp)*siq)*c1e3                               !hr05
      sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
      sm23=al(2,ih,j,i)*al(3,ih,j,i)
      as(1,ih,j,i)=(el(i)*(one-rv)-rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-al(2,ih,j,i))))*c1e3 !hr05
      as(2,ih,j,i)=(-one*rv)*((dpp/((two*rho)*dpsq))*sm12-dpd*siq)     !hr05
      as(3,ih,j,i)=(-one*rv)*(((dpp*rho)/(two*dpsq))*sm23-dpd*rhoc)    !hr05
      as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
      as(5,ih,j,i)=((-one*rv)*sm12)/(c4e3*rho**2)                      !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      ! VERTIKAL
      ih=ih+1
      if(ih.gt.2) ih=1
      al(1,ih,j,i)=one
      al(2,ih,j,i)=el(i)
      al(3,ih,j,i)=zero
      al(4,ih,j,i)=one
      as(6,ih,j,i)=((-one*rv)*al(2,ih,j,i))/c2e3                       !hr05
      
    case (7,8)
      ! 7: COMBINED FUNCTION MAGNET HORIZONTAL
      ! 8: COMBINED FUNCTION MAGNET VERTICAL
      if (kz1.eq.7) then
        ih   = 0
        fokq = ek(i)
      else
        ih   = 1
        fokq = -one*ek(i) ! hr05
      end if
      ! FOCUSSING
      wf=ed(i)/dpsq
      fok=fokq/(dpd)-wf**2                                             !hr05
      if(abs(fok).le.pieni) then
        do l=1,2
          al(1,l,j,i) = one
          al(2,l,j,i) = el(i)
          al(3,l,j,i) = zero
          al(4,l,j,i) = one
          as(6,l,j,i) = ((-one*rv)*al(2,l,j,i))/c2e3 ! hr05
        end do
        as(1,1,j,i) = (el(i)*(one-rv))*c1e3          ! hr05
        cycle
      end if
      afok=abs(fok)
      hi=sqrt(afok)
      fi=hi*el(i)
      if(fok.gt.zero) goto 160
140   ih=ih+1
      si=sin_mb(fi)
      co=cos_mb(fi)
      wfa=((wf/afok)*(one-co))/dpsq                                    !hr05
      wfhi=((wf/hi)*si)/dpsq                                           !hr05
      al(1,ih,j,i)=co
      al(2,ih,j,i)=si/hi
      al(3,ih,j,i)=(-one*si)*hi                                        !hr05
      al(4,ih,j,i)=co
      al(5,ih,j,i)=((-one*wfa)*dpp)*c1e3                               !hr05
      al(6,ih,j,i)=((-one*wfhi)*dpp)*c1e3                              !hr05
      sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
      sm23=al(2,ih,j,i)*al(3,ih,j,i)
      as(1,ih,j,i)=(el(i)*(one-rv)-((rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-al(2,ih,j,i))))/afok)*wf**2)*c1e3 !hr05
      as(2,ih,j,i)=(-one*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
      as(3,ih,j,i)=(-one*rv)*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-dpd*wfa) !hr05
      as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
      as(5,ih,j,i)=(((-one*rv)*sm12)*afok)/c4e3                        !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      ih=ih+1
      if(ih.gt.2) ih=1
      aek=abs(ek(i)/dpd)
      hi=sqrt(aek)
      fi=hi*el(i)
      hp=exp_mb(fi)
      hm=one/hp
      hc=(hp+hm)*half
      hs=(hp-hm)*half
      al(1,ih,j,i)=hc
      al(2,ih,j,i)=el(i)
      if(abs(hi).le.pieni) goto 150
      al(2,ih,j,i)=hs/hi
150   al(3,ih,j,i)=hs*hi
      al(4,ih,j,i)=hc
      as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=((rv*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3   !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      cycle
      ! DEFOCUSSING
160   ih=ih+1
      hp=exp_mb(fi)
      hm=one/hp
      hc=(hp+hm)*half
      hs=(hp-hm)*half
      al(1,ih,j,i)=hc
      al(2,ih,j,i)=hs/hi
      al(3,ih,j,i)=hs*hi
      al(4,ih,j,i)=hc
      wfa=((wf/afok)*(one-hc))/dpsq                                    !hr05
      wfhi=((wf/hi)*hs)/dpsq                                           !hr05
      al(5,ih,j,i)= (wfa*dpp)*c1e3                                     !hr05
      al(6,ih,j,i)=((-one*wfhi)*dpp)*c1e3                              !hr05
      sm12=el(i)-al(1,ih,j,i)*al(2,ih,j,i)
      sm23=al(2,ih,j,i)*al(3,ih,j,i)
      as(1,ih,j,i)=(((rv*((dpp**2/(four*dpd))*sm12+dpp*(el(i)-al(2,ih,j,i))))/afok)*wf**2+el(i)*(one-rv))*c1e3 !hr05
      as(2,ih,j,i)=(-one*rv)*(((dpp*wf)/(two*dpsq))*sm12-dpd*wfhi)     !hr05
      as(3,ih,j,i)=rv*(((((dpp*half)/afok)/dpd)*ed(i))*sm23-dpd*wfa)   !hr05
      as(4,ih,j,i)=((-one*rv)*sm23)/c2e3                               !hr05
      as(5,ih,j,i)=((rv*sm12)*afok)/c4e3                               !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      ih=ih+1
      if(ih.gt.2) ih=1
      aek=abs(ek(i)/dpd)
      hi=sqrt(aek)
      fi=hi*el(i)
      si=sin_mb(fi)
      co=cos_mb(fi)
      al(1,ih,j,i)=co
      al(2,ih,j,i)=si/hi
      al(3,ih,j,i)=(-one*si)*hi                                        !hr05
      al(4,ih,j,i)=co
      as(4,ih,j,i)=(((-one*rv)*al(2,ih,j,i))*al(3,ih,j,i))/c2e3        !hr05
      as(5,ih,j,i)=(((-one*rv)*(el(i)-al(1,ih,j,i)*al(2,ih,j,i)))*aek)/c4e3 !hr05
      as(6,ih,j,i)=((-one*rv)*(el(i)+al(1,ih,j,i)*al(2,ih,j,i)))/c4e3  !hr05
      
    case (9)
      ! EDGE FOCUSSING
      rhoi=ed(i)/dpsq
      fok=rhoi*tan_mb((el(i)*rhoi)*half)                               !hr05
      al(1,1,j,i)=one
      al(2,1,j,i)=zero
      al(3,1,j,i)=fok
      al(4,1,j,i)=one
      al(1,2,j,i)=one
      al(2,2,j,i)=zero
      al(3,2,j,i)=-one*fok                                             !hr05
      al(4,2,j,i)=one
      
    end select
  end do
  
#ifdef SIXDA
  do k=1,mblo
    jm=mel(k)
    do m=1,jm
      na=mtyp(k,m)
      ne=mtyp(k,jm-m+1)
      do l=1,2
        at(1,l,j,na)=as(1,l,j,ne)
        at(2,l,j,na)=as(2,l,j,ne)
        at(3,l,j,na)=as(3,l,j,ne)
        at(4,l,j,na)=as(4,l,j,ne)
        at(5,l,j,na)=as(5,l,j,ne)
        at(6,l,j,na)=as(6,l,j,ne)
        a2(1,l,j,na)=al(1,l,j,ne)
        a2(2,l,j,na)=al(2,l,j,ne)
        a2(3,l,j,na)=al(3,l,j,ne)
        a2(4,l,j,na)=al(4,l,j,ne)
        a2(5,l,j,na)=al(5,l,j,ne)
        a2(6,l,j,na)=al(6,l,j,ne)
      end do
    end do
  end do
#endif
  return
  
end subroutine envars

+dk envada
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
subroutine envada
  ! Replaced computed goto with select case, VKBO 27/11/2017
  use floatPrecision
  use mathlib_bouncer
  use numerical_constants
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  use mod_commond
  use mod_commond2
  use mod_lie_dab, only : idao,rscrri,iscrda
  implicit none
  integer i,ien,ih,ip,kz1,l,idaa
  real(kind=fPrec) dare,result
+ca commond1
  save
!FOX  B D ;
#include "include/dainicom.f90"
!FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
!FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
!FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
!FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
!FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
!FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
!FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
!FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
!FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
!FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
!FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
!FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
!FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
!FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
!FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
!FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
!FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
!FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
!FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
!FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
!FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
!FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
!FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
!FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX  DPD=ONE+DPDA ;
!FOX  DPSQ=SQRT(DPD) ;
  do i=1,il
    do ih=1,2
      do ip=1,6
!FOX  ALDA(IH,IP)=ZERO ;
!FOX  ASDA(IH,IP)=ZERO ;
      end do
    end do
    
    !-----------------------------------------------------------------------
    if(abs(el(i)).le.pieni) goto 190
    select case (kz(i))
    case (0)
      goto 20
      
    !-----------------------------------------------------------------------
    !  RECTANGULAR MAGNET
    !-----------------------------------------------------------------------
    case (1,4)
      if (kz(i) == 1) then
        ih = 1
      else
        ih = 2
      end if
      ! HORIZONTAL
      if(abs(ed(i)).le.pieni) goto 20
!FOX  FOK=EL(I)*ED(I)/DPSQ ;
!FOX  RHO=ONE/ED(I)*DPSQ ;
!FOX  FOK1=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
!FOX  SI=SIN(FOK) ;
!FOX  CO=COS(FOK) ;
!FOX  ALDA(IH,1)=ONE ;
!FOX  ALDA(IH,2)=RHO*SI ;
!FOX  ALDA(IH,3)=ZERO ;
!FOX  ALDA(IH,4)=ONE ;
!FOX  ALDA(IH,5)=-DPDA*RHO*(ONE-CO)/DPSQ*C1E3 ;
!FOX  ALDA(IH,6)=-DPDA*TWO*SIN(FOK*HALF)/COS(FOK*HALF)/DPSQ*C1E3 ;
!FOX  SM1=COS(FOK) ;
!FOX  SM2=SIN(FOK)*RHO ;
!FOX  SM3=-SIN(FOK)/RHO ;
!FOX  SM5=-RHO*DPSQ*(ONE-SM1) ;
!FOX  SM6=-SM2*DPSQ/RHO ;
!FOX  SM12=EL(I)-SM1*SM2 ;
!FOX  SM23=SM2*SM3 ;
!FOX  AS3=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23+SM5) ;
!FOX  AS4=-RV*SM23/C2E3 ;
!FOX  AS6=-RV*(EL(I)+SM1*SM2)/C4E3 ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA*(EL(I)-SM2))
!FOX  +EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12+SM6)+FOK1*AS3 ;
!FOX  ASDA(IH,3)=AS3 ;
!FOX  ASDA(IH,4)=AS4+TWO*AS6*FOK1 ;
!FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO)+AS6*FOK1*FOK1+FOK1*AS4  ;
!FOX  ASDA(IH,6)=AS6 ;
      ! VERTIKAL
      ih=ih+1
      if(ih.gt.2) ih=1
!FOX  G=SIN(FOK*HALF)/COS(FOK*HALF)/RHO ;
!FOX  GL=EL(I)*G ;
!FOX  ALDA(IH,1)=ONE-GL ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,3)=-G*(TWO-GL) ;
!FOX  ALDA(IH,4)=ALDA(IH,1) ;
!FOX  AS6=-RV*ALDA(IH,2)/C2E3 ;
!FOX  ASDA(IH,4)=-TWO*AS6*FOK1 ;
!FOX  ASDA(IH,5)=AS6*FOK1*FOK1 ;
!FOX  ASDA(IH,6)=AS6 ;
      goto 190
    case (2)
      goto 100
      
    !-----------------------------------------------------------------------
    !  SEKTORMAGNET
    !-----------------------------------------------------------------------
    case (3,5)
      if (kz(i) == 3) then
        ih = 1
      else
        ih = 2
      end if
      goto 70
      
    !-----------------------------------------------------------------------
    !  COMBINED FUNCTION MAGNET
    !-----------------------------------------------------------------------
    case (6,7)
      if (kz(i) == 6) then
        ih = 0
!FOX  FOKQ=EK(I) ;
      else
        ih=1
!FOX  FOKQ=-EK(I) ;
      end if
      if(abs(ek(i)).le.pieni) then
        ih=2
        goto 70
      end if
      if(abs(ed(i)).le.pieni) goto 100
      if(abs(ek(i)-ed(i)**2).le.pieni) goto 20                         !hr08
!FOX  WF=ED(I)/DPSQ ;
!FOX  FOK=FOKQ/DPD-WF*WF ;
!FOX  AFOK=FOK ;
    if(dare(afok).lt.zero) then
!FOX  AFOK=-AFOK ;
    end if
!FOX  HI=SQRT(AFOK) ;
!FOX  FI=HI*EL(I) ;
    if(dare(fok).gt.zero) then
      ! DEFOCUSSING
      ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  WFA=WF/AFOK*(ONE-HC)/DPSQ ;
!FOX  WFHI=WF/HI*HS/DPSQ ;
!FOX  ALDA(IH,5)= WFA*DPDA*C1E3 ;
!FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(RV*(DPDA*DPDA/(FOUR*DPD)*SM12
!FOX  +DPDA*(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
!FOX  ASDA(IH,3)=RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=+RV*SM12*AFOK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  AEK=EK(I)/DPD ;
        if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
        end if
!FOX  HI=SQRT(AEK) ;
!FOX  FI=HI*EL(I) ;
!FOX  SI=SIN(FI) ;
!FOX  CO=COS(FI) ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=SI/HI ;
!FOX  ALDA(IH,3)=-SI*HI ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
      else
        ih=ih+1
!FOX  SI=SIN(FI) ;
!FOX  CO=COS(FI) ;
!FOX  WFA=WF/AFOK*(ONE-CO)/DPSQ ;
!FOX  WFHI=WF/HI*SI/DPSQ ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=SI/HI ;
!FOX  ALDA(IH,3)=-SI*HI ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ALDA(IH,5)=-WFA*DPDA*C1E3 ;
!FOX  ALDA(IH,6)=-WFHI*DPDA*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12+DPDA
!FOX  *(EL(I)-ALDA(IH,2)))/AFOK*WF*WF+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA*WF/(TWO*DPSQ)*SM12-DPD*WFHI) ;
!FOX  ASDA(IH,3)=-RV*(DPDA*HALF/AFOK/DPD*ED(I)*SM23-DPD*WFA) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=-RV*SM12*AFOK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  AEK=EK(I)/DPD ;
        if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
        end if
!FOX  HI=SQRT(AEK) ;
!FOX  FI=HI*EL(I) ;
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
      end if
      goto 190
      
    !-----------------------------------------------------------------------
    !  EDGE FOCUSSING
    !-----------------------------------------------------------------------
    case (8)
!FOX  RHOI=ED(I)/DPSQ ;
!FOX  FOK=RHOI*SIN(EL(I)*RHOI*HALF)/COS(EL(I)*RHOI*HALF) ;
!FOX  ALDA(1,1)=ONE ;
!FOX  ALDA(1,2)=ZERO ;
!FOX  ALDA(1,3)=FOK ;
!FOX  ALDA(1,4)=ONE ;
!FOX  ALDA(2,1)=ONE ;
!FOX  ALDA(2,2)=ZERO ;
!FOX  ALDA(2,3)=-FOK ;
!FOX  ALDA(2,4)=ONE ;
      goto 190
    end select
    !-----------------------------------------------------------------------
    cycle
    
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 l=1,2
!FOX  ALDA(L,1)=ONE  ;
!FOX  ALDA(L,2)=EL(I) ;
!FOX  ALDA(L,3)=ZERO ;
!FOX  ALDA(L,4)=ONE ;
!FOX  ASDA(L,6)=-RV*ALDA(L,2)/C2E3 ;
   30   continue
!FOX  ASDA(1,1)=EL(I)*(ONE-RV)*C1E3 ;
        goto 190
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   70   continue
        if(abs(ed(i)).le.pieni) goto 20
!FOX  FOK=EL(I)*ED(I)/DPSQ ;
!FOX  RHO=(ONE/ED(I))*DPSQ ;
!FOX  SI=SIN(FOK) ;
!FOX  CO=COS(FOK) ;
!FOX  RHOC=RHO*(ONE-CO)/DPSQ ;
!FOX  SIQ=SI/DPSQ ;
!FOX  ALDA(IH,1)=CO ;
!FOX  ALDA(IH,2)=RHO*SI ;
!FOX  ALDA(IH,3)=-SI/RHO ;
!FOX  ALDA(IH,4)=CO ;
!FOX  ALDA(IH,5)=-DPDA*RHOC*C1E3 ;
!FOX  ALDA(IH,6)=-DPDA*SIQ*C1E3 ;
!FOX  SM12=EL(I)-ALDA(IH,1)*ALDA(IH,2) ;
!FOX  SM23=ALDA(IH,2)*ALDA(IH,3) ;
!FOX  ASDA(IH,1)=(-RV*(DPDA*DPDA/(FOUR*DPD)*SM12
!FOX  +DPDA*(EL(I)-ALDA(IH,2)))+EL(I)*(ONE-RV))*C1E3 ;
!FOX  ASDA(IH,2)=-RV*(DPDA/(TWO*RHO*DPSQ)*SM12-DPD*SIQ) ;
!FOX  ASDA(IH,3)=-RV*(DPDA*RHO/(TWO*DPSQ)*SM23-DPD*RHOC) ;
!FOX  ASDA(IH,4)=-RV*SM23/C2E3 ;
!FOX  ASDA(IH,5)=-RV*SM12/(C4E3*RHO*RHO) ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
!--VERTIKAL
        ih=ih+1
        if(ih.gt.2) ih=1
!FOX  ALDA(IH,1)=ONE ;
!FOX  ALDA(IH,2)=EL(I) ;
!FOX  ALDA(IH,3)=ZERO ;
!FOX  ALDA(IH,4)=ONE ;
!FOX  ASDA(IH,6)=-RV*ALDA(IH,2)/C2E3 ;
        goto 190
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
  100   continue
        if(abs(ek(i)).le.pieni) goto 20
!FOX  FOK=EK(I)*MTCDA/(ONE+DPDA) ;
!FOX  AEK=FOK ;
        if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
        endif
        ih=0
!FOX  HI=SQRT(AEK) ;
!FOX  FI=EL(I)*HI ;
        if(ek(i).gt.zero) goto 120
  110   ih=ih+1
!FOX  ALDA(IH,1)=COS(FI) ;
!FOX  HI1=SIN(FI) ;
!FOX  ALDA(IH,2)=HI1/HI ;
!FOX  ALDA(IH,3)=-HI1*HI ;
!FOX  ALDA(IH,4)=ALDA(IH,1) ;
!FOX  ASDA(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=-RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.2) goto 190
!--DEFOCUSSING
  120   ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDA(IH,1)=HC ;
!FOX  ALDA(IH,2)=HS/HI ;
!FOX  ALDA(IH,3)=HS*HI ;
!FOX  ALDA(IH,4)=HC ;
!FOX  ASDA(IH,4)=-RV*ALDA(IH,2)*ALDA(IH,3)/C2E3 ;
!FOX  ASDA(IH,5)=+RV*(EL(I)-ALDA(IH,1)*ALDA(IH,2))*AEK/C4E3 ;
!FOX  ASDA(IH,6)=-RV*(EL(I)+ALDA(IH,1)*ALDA(IH,2))/C4E3 ;
        if(ih.eq.1) goto 110
        goto 190
!-----------------------------------------------------------------------
!   NONLINEAR INSERTION
!-----------------------------------------------------------------------
  190 continue
      do ih=1,2
        do ip=1,6
          do ien=1,nord+1
            if (nvar2.eq.5) then
              call dapri6(alda(ih,ip),result,ien,5)
              ald6(i,ih,ip,ien) = result
              call dapri6(asda(ih,ip),result,ien,5)
              asd6(i,ih,ip,ien) = result
            else if (nvar2.eq.6) then
              call dapri6(alda(ih,ip),result,ien,6)
              ald6(i,ih,ip,ien) = result
              call dapri6(asda(ih,ip),result,ien,6)
              asd6(i,ih,ip,ien) = result
            else if (nvar2.eq.4) then
              call dapri6(alda(ih,ip),result,ien,4)
              ald6(i,ih,ip,ien) = result
              call dapri6(asda(ih,ip),result,ien,4)
              asd6(i,ih,ip,ien) = result
            endif
          end do
        end do
      end do
    end do
    ! DADAL AUTOMATIC INCLUSION
    
  return
  
end subroutine envada

      subroutine envquad(i,ipch)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!      SPECIALLY PREPARED FOR NEW D.A. (SIX-DIMENSIONAL VERSION)
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_common
      use mod_commond
      use mod_lie_dab, only : idao,rscrri,iscrda
      implicit none
      integer i,ih,ipch,idaa
      real(kind=fPrec) dare
+ca commond1
      save
!-----------------------------------------------------------------------
!FOX  B D ;
#include "include/dainicom.f90"
!FOX  D V DA INT FOKQ NORD NVAR ; D V DA INT WFHI NORD NVAR ;
!FOX  D V DA INT DPD NORD NVAR ; D V DA INT DPSQ NORD NVAR ;
!FOX  D V DA INT FOK NORD NVAR ; D V DA INT RHO NORD NVAR ;
!FOX  D V DA INT FOK1 NORD NVAR ; D V DA INT SM1 NORD NVAR ;
!FOX  D V DA INT SM2 NORD NVAR ; D V DA INT SM3 NORD NVAR ;
!FOX  D V DA INT SM4 NORD NVAR ; D V DA INT SM5 NORD NVAR ;
!FOX  D V DA INT SM6 NORD NVAR ; D V DA INT SM12 NORD NVAR ;
!FOX  D V DA INT SM23 NORD NVAR ; D V DA INT AS3 NORD NVAR ;
!FOX  D V DA INT AS4 NORD NVAR ; D V DA INT AS6 NORD NVAR ;
!FOX  D V DA INT SI NORD NVAR ; D V DA INT CO NORD NVAR ;
!FOX  D V DA INT G NORD NVAR ; D V DA INT GL NORD NVAR ;
!FOX  D V DA INT SIQ NORD NVAR ; D V DA INT RHOC NORD NVAR ;
!FOX  D V DA INT HI NORD NVAR ; D V DA INT FI NORD NVAR ;
!FOX  D V DA INT AEK NORD NVAR ; D V DA INT HI1 NORD NVAR ;
!FOX  D V DA INT HP NORD NVAR ; D V DA INT HM NORD NVAR ;
!FOX  D V DA INT HC NORD NVAR ; D V DA INT HS NORD NVAR ;
!FOX  D V DA INT FOKC NORD NVAR ; D V DA INT WF NORD NVAR ;
!FOX  D V DA INT AFOK NORD NVAR ; D V DA INT RHOI NORD NVAR ;
!FOX  D V DA INT WFA NORD NVAR ; D V RE INT RATIOE NELE ;
!FOX  D V RE INT EL NELE ; D V RE INT EK NELE ; D V RE INT ED NELE ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT TWO ;
!FOX  D V RE INT HALF ; D V RE INT FOUR ; D V RE INT C1E3 ;
!FOX  D V RE INT C2E3 ; D V RE INT C4E3 ;
!FOX  D V IN INT I ; D V IN INT L ; D V IN INT IH ; D V IN INT NE ;
!FOX  D V IN INT NA ; D V IN INT IP ; D V IN INT IPCH ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX  DPD=ONE+DPDA ;
!FOX  DPSQ=SQRT(DPD) ;
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
      if(abs(ek(i)).le.pieni) goto 100
!FOX  FOK=(SMIDA(IPCH)*RATIOE(I))*MTCDA/(ONE+DPDA) ;
!FOX  AEK=FOK ;
      if(dare(aek).lt.zero) then
!FOX  AEK=-AEK ;
      endif
      ih=0
!FOX  HI=SQRT(AEK) ;
!FOX  FI=EL(I)*HI ;
      if(ek(i).gt.zero) goto 30
   20 ih=ih+1
!FOX  ALDAQ(IH,1)=COS(FI) ;
!FOX  HI1=SIN(FI) ;
!FOX  ALDAQ(IH,2)=HI1/HI ;
!FOX  ALDAQ(IH,3)=-HI1*HI ;
!FOX  ALDAQ(IH,4)=ALDAQ(IH,1) ;
!FOX  ASDAQ(IH,1)=EL(I)*(ONE-RV)*C1E3 ;
!FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
!FOX  ASDAQ(IH,5)=-RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
!FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.2) goto 100
!--DEFOCUSSING
   30 ih=ih+1
!FOX  HP=EXP(FI) ;
!FOX  HM=ONE/HP ;
!FOX  HC=(HP+HM)*HALF ;
!FOX  HS=(HP-HM)*HALF ;
!FOX  ALDAQ(IH,1)=HC ;
!FOX  ALDAQ(IH,2)=HS/HI ;
!FOX  ALDAQ(IH,3)=HS*HI ;
!FOX  ALDAQ(IH,4)=HC ;
!FOX  ASDAQ(IH,4)=-RV*ALDAQ(IH,2)*ALDAQ(IH,3)/C2E3 ;
!FOX  ASDAQ(IH,5)=+RV*(EL(I)-ALDAQ(IH,1)*ALDAQ(IH,2))*AEK/C4E3 ;
!FOX  ASDAQ(IH,6)=-RV*(EL(I)+ALDAQ(IH,1)*ALDAQ(IH,2))/C4E3 ;
      if(ih.eq.1) goto 20
  100 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end
      
+dk runda
subroutine runda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR NORMAL FORWARD-TRACKING
!        SPECIALLY PREPARED FOR NEW D.A.
!        5 --> 6  AND  ASD6 / ALD6
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use physical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commonmn, only : e0f,numx
      use mod_commons
      use mod_commont, only : xxtr,yytr,issss,comt_daStart,comt_daEnd
      use mod_commond
      use mod_commond2
      use mod_hions
      use mod_lie_dab, only : idao,iscrri,rscrri,iscrda
      implicit none
      integer i,ich,i11,i480,icav,ien,ifam,iflag,iflag1,iflag2,ii,ip,   &
     &ipch,irrtr,iverg,ix,j,jb,jj,jmel,jx,k,kk,kkk,kpz,kzz,n,ncyo,nmz,  &
     &nsta,nsto,idaa
      real(kind=fPrec) beamoff1,beamoff2, beamoff3, beamoff4,beamoff5,  &
     &beamoff6,benkcc,betr0,c5m4,cbxb,cbzb,cik,crk,crxb,crzb,dare,dpdav,&
     &dpdav2,dummy,fake,ox,oxp,oz,ozp,r0,r000,r0a,r2b,r2bf,rb,rbf,rho2b,&
     &rkb,rkbf,scikveb,scrkveb,sigmdac,startco,tkb,xbb,xrb,xs,zbb,      &
     &zfeld1,zfeld2,zrb,zs, crabfreq, crabpht, crabpht2, crabpht3,      &
     &crabpht4
      character(len=300) ch
+ca commond1
      dimension zfeld1(100),zfeld2(100)
      dimension iverg(mcor)
      dimension fake(2,20),dpdav2(6),jj(100)
      save
!-----------------------------------------------------------------------
#include "include/daini.f90"
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      call comt_daStart
#ifdef FAST
      c5m4=5.0e-4_fPrec
#endif
      if(mout2.eq.1) then
#ifdef NAGFOR
#ifdef BOINC
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown',recl=303)
#endif
#ifndef BOINC
      open(99,file='fort.99',form='formatted',status='unknown',recl=303)
#endif
#endif
#ifndef NAGFOR
#ifdef BOINC
      call boincrf('fort.99',filename)
      open(99,file=filename,form='formatted',status='unknown')
#endif
#ifndef BOINC
      open(99,file='fort.99',form='formatted',status='unknown')
#endif
#endif
      endif
      do i=1,100
        jj(i)=0
      enddo

      if(mout2.eq.1) write(7,*) e0,nucm0
      e0f=sqrt(e0**2-nucm0**2)                                             !hr08
      betr0=sqrt(one-(nucm0/e0)**2)
      do i=1,mcor
        iverg(i)=0
      end do
      do i=1,20

        fake(1,i)=zero
        fake(2,i)=zero
      end do
      time1=0.
      call timex(time1)
      if(niu(1).gt.1) then
        do i=1,2
          ii=2*i
          xxtr(1,i)=clon(ii-1)
          yytr(1,i)=clon(ii)
        enddo
        sigm(1)=clon(5)
        dps(1)=clon(6)
      endif
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      if(nvar2.ge.1) call davar(x(1),zero,1)
!FOX  X(1)=X(1)+OX ;
      if(nvar2.ge.2) call davar(yp(1),zero,2)
!FOX  YP(1)=YP(1)+OXP*(ONE+DPS(1)) ;
      if(nvar2.ge.3) call davar(x(2),zero,3)
!FOX  X(2)=X(2)+OZ ;
      if(nvar2.ge.4) call davar(yp(2),zero,4)
!FOX  YP(2)=YP(2)+OZP*(ONE+DPS(1)) ;
      if(nvar2.lt.5) then
!FOX  DPDA1=DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.5) then
        call davar(dpda1,zero,5)
!FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;
      endif
      if(nvar2.eq.6) then
        call davar(deltas,zero,5)
        call davar(dpda1,zero,6)


!FOX  DPDA1=DPDA1+DPS(1)*C1E3 ;        
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCM0*NUCM0) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DELTAS=DELTAS+SIGM(1)/RV ;

      else
!FOX  DELTAS=SIGM(1) ;
      endif
!FOX  CORROLD(1)=X(1) ;
!FOX  CORROLD(2)=YP(1) ;
!FOX  CORROLD(3)=X(2) ;
!FOX  CORROLD(4)=YP(2) ;
!FOX  CORROLD(5)=DELTAS ;
!FOX  CORROLD(6)=DPDA1 ;
      do kkk=1,6
        dpdav=dare(corrold(kkk))
!FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
      end do
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
!FOX  SIGMDA=DELTAS*RV ;
      write(lout,*) ' ENTERING MAP '
      write(lout,*) 'INITIAL COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      if(ncor.gt.0) then
        do i=1,ncor
          do ii=1,iu
            if(ipar(i).eq.(ic(ii)-nblo).and.iverg(i).eq.0) then
              iverg(i)=1
              call davar(smida(i),ed(ic(ii)-nblo),nvar2+i)
            endif
          end do
        end do
      endif
      nsta=niu(1)
      nsto=niu(2)
      if(niu(2).lt.niu(1)) nsto=nsto+iu
      do 490 n=1,numl
        numx=n-1
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
        ncyo=ncy
        if(ncy.eq.0) ncy=1
        if(ithick.eq.1) call envada
        ncy=ncyo
        iflag=0
        iflag1=0
        iflag2=0
        icav=0
        do 480 i480=nsta,nsto
          if(i480.gt.iu) then
            i=i480-iu
          else
            i=i480
          endif
          if(mout2.eq.1.and.i480.eq.nsta.and.n.eq.1) call write4
          if(iflag.eq.1) then
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DELTAS=SIGMDA/RV ;
            if(ithick.eq.1) then
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
              if(icav.eq.0) then
!FOX  CORRNEW(1)=X(1) ;
!FOX  CORRNEW(2)=YP(1) ;
!FOX  CORRNEW(3)=X(2) ;
!FOX  CORRNEW(4)=YP(2) ;
!FOX  CORRNEW(5)=DELTAS ;
!FOX  CORRNEW(6)=DPDA1 ;
                do 24 kkk=1,6
                  dpdav=dare(corrnew(kkk))
!FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24           continue
              else
!FOX  CORRAU2(1)=X(1) ;
!FOX  CORRAU2(2)=YP(1) ;
!FOX  CORRAU2(3)=X(2) ;
!FOX  CORRAU2(4)=YP(2) ;
!FOX  CORRAU2(5)=DELTAS ;
!FOX  CORRAU2(6)=DPDA1 ;
                do 25 kkk=1,6
!FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                  dpdav=dare(corrau2(kkk))
!FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25           continue
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
!FOX  CORRAU2(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
!FOX  CORRAU1(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
              endif
              dpdav=dare(x(1))
!FOX  X(1)=CORROLD(1)+DPDAV ;
              dpdav=dare(yp(1))
!FOX  YP(1)=CORROLD(2)+DPDAV ;
              dpdav=dare(x(2))
!FOX  X(2)=CORROLD(3)+DPDAV ;
              dpdav=dare(yp(2))
!FOX  YP(2)=CORROLD(4)+DPDAV ;
              dpdav=dare(deltas)
!FOX  DELTAS=CORROLD(5)+DPDAV ;
              dpdav=dare(dpda1)
!FOX  DPDA1=CORROLD(6)+DPDAV ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  SIGMDA=DELTAS*RV ;
              icav=icav+1
              call envada
            endif
            iflag=0
          endif
          ix=ic(i)
          if(mout2.eq.1) then
            if(i480.eq.nsta.and.n.eq.1) then
              write(ch,*) 'START ',dare(x(1)),dare(y(1)),dare(x(2)),    &
     &dare(y(2)),dare(sigmda),dare(dpda)
              do ich=300,1,-1
                if(ch(ich:ich).ne.' ') goto 700
              enddo
 700          write(99,'(a)') ch(:ich)
            else
              if(ic(i-1).le.nblo) then
                write(ch,*) bez(mtyp(ic(i-1),mel(ic(i-1)))),dare(x(1)), &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 701
                enddo
 701            write(99,'(a)') ch(:ich)
              else
                write(ch,*) bez(ic(i-1)-nblo),dare(x(1)),               &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 702
                enddo
 702            write(99,'(a)') ch(:ich)
              endif
            endif
          endif
          if(ix.gt.nblo) goto 70
          if(mout2.eq.1.and.n.eq.1) then
            jmel=mel(ix)
            do jb=1,jmel
              jx=mtyp(ix,jb)
              if(el(jx).eq.zero) then
                write(7,*) '0'
                write(7,*) bez(jx)
              else
                if(ithick.eq.1) then
                  ifam=0
                  do ip=1,il
                    if(kz(ip).eq.kz(jx).and.el(ip).ne.zero) then
                      if((ed(jx).ne.zero.and.ed(ip).ne.zero).or.        &
     &(ek(jx).ne.zero.and.ek(ip).ne.zero)) then
                        ifam=ifam+1
                        if(bez(ip).eq.bez(jx)) goto 35
                      endif
                    endif
                  enddo
 35               continue
                  write(7,*) '1'
                  write(7,*) bez(jx)
                  if(kz(jx).eq.1.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.3.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.4.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.5.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.8.and.abs(ed(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif(kz(jx).eq.2.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &abs(ed(jx)).le.pieni.and.abs(ek(jx)).le.pieni) then
                    write(7,*) '0 ',ifam
                    write(7,*) zero,zero,el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).le.pieni.and.abs(ek(jx)).gt.pieni)) then
                    write(7,*) '2 ',ifam
                    write(7,*) zero,ek(jx),el(jx)
                  elseif((kz(jx).eq.6.or.kz(jx).eq.7).and.              &
     &(abs(ed(jx)).gt.pieni.and.abs(ek(jx)).le.pieni)) then
                    write(7,*) '3 ',ifam
                    write(7,*) ed(jx),zero,el(jx)
                  else
                    write(7,*) kz(jx),ifam
                    write(7,*) ed(jx),ek(jx),el(jx)
                  endif
                else
                  write(7,*) '2'
                  write(7,*) bez(jx)
                  write(7,*) el(jx)
                endif
              endif
            enddo
          endif
          if(ix.le.0) then
            call prror(93)
          endif
#include "include/dalin1.f90"
#include "include/dalin2.f90"
#include "include/dalin3.f90"
#include "include/dalin4.f90"
#include "include/dalin5.f90"
#include "include/dalin6.f90"
!FOX  SIGMDA=SIGMDA+
#include "include/sqrtfox.f90"
              endif
            enddo
          endif
          goto 480
   70     ix=ix-nblo
          if(abs(dare(x(1))).gt.aint(aper(1)).or.abs(dare(x(2))).gt.aint(aper(2))) then
            write(lout,10000) j,numx,i,dare(x(1)),aper(1),dare(x(2)),aper(2),ix, kz(ix),bez(ix)
            goto 520
          endif
          kpz=abs(kp(ix))
          if (kpz.ge.0.and.kpz.le.5) goto 110
          if (kpz.eq.6) goto 90
          goto 480
   90     if(nvar2.le.4.or.(nvar2.eq.5.and.nsix.ne.2)) goto 480
          ixcav=ix
          iicav=i
          if(nsix.eq.2) then
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  DELTAS=SIGMDA*RV ;
            call dapri(x(1),19)
            call dapri(yp(1),19)
            call dapri(x(2),19)
            call dapri(yp(2),19)
            call dapri(deltas,19)
            call dapri(dpda1,19)
            if(ncor.gt.0) then
              write(lout,*) ' WARNING: in the 5*6 mode no extra parameters allowed'
            endif
            rewind 19
!     DADAL AUTOMATIC INCLUSION
            return
          endif
          if(ition.ne.0) then
!FOX  EJF0=EJF1 ;
            if(abs(dppoff).gt.pieni) then
              sigmdac=sigmoff(i)
!FOX  SIGMDA=SIGMDA-SIGMDAC ;
            endif
            call synoda
            if(mout2.eq.1.and.n.eq.1) then
              write(7,*) '5'
              if(kz(ix).eq.12) then
                write(7,*) bez(ix)
                write(ch,*) ed(ix),hsyc(ix),itionc(ix),phasc(ix)
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 703
                enddo
 703            write(7,'(a)') ch(:ich)
              else
                write(7,*) 'CAV'
                write(ch,*) hsy(1),hsy(3),ition,phas
                do ich=300,1,-1
                  if(ch(ich:ich).ne.' ') goto 704
                enddo
 704            write(7,'(a)') ch(:ich)
              endif
            endif
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;

          endif
          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
          goto 480
  110     kzz=kz(ix)
          if(mout2.eq.1.and.n.eq.1) then
            if(kzz.eq.0) then
              write(7,*) '0'
              write(7,*) bez(ix)
            elseif((kzz.ge.1.and.kzz.le.10).or.                         &
     &(kzz.le.-1.and.kzz.ge.-10)) then
              write(7,*) '3'
              write(7,*) bez(ix)
#ifdef TILT
              write(7,*) xsi(i),zsi(i),atan2_mb(tilts(i),tiltc(i))
#endif
#ifndef TILT
              write(7,*) xsi(i),zsi(i),zero
#endif
              write(7,*) kzz,smi(i)
            elseif(kzz.eq.11) then
              nmz=nmu(ix)
              write(7,*) '4'
              write(7,*) bez(ix)
#ifdef TILT
              write(7,*) xsi(i),zsi(i),atan2_mb(tilts(i),tiltc(i))
#endif
#ifndef TILT
              write(7,*) xsi(i),zsi(i),zero
#endif
              if(abs(dki(ix,1)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 1',' 1'
                  write(7,*) dki(ix,1),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 1',' 0'
                  write(7,*) dki(ix,1),dki(ix,3)
                endif
              elseif(abs(dki(ix,2)).gt.pieni) then
                if(abs(dki(ix,3)).gt.pieni) then
                  write(7,*) nmz,' 1',' 0',' 1'
                  write(7,*) dki(ix,2),dki(ix,3)
                else
                  write(7,*) nmz,' 1',' 0',' 0'
                  write(7,*) dki(ix,2),dki(ix,3)
                endif
              else
                write(7,*) nmz,' 0',' 0',' 0'
              endif
              if(nmz.ge.1) then
                do ip=1,nmz
                  write(7,*) bbi(i,ip),aai(i,ip)
                enddo
              endif
            endif
          endif
          if(kzz.eq.15) then
!FOX  XX(1)=X(1) ;
!FOX  XX(2)=X(2) ;
!FOX  YY(1)=Y(1) ;
!FOX  YY(2)=Y(2) ;
          call wireda(ix,i)
!FOX  Y(1)=YY(1) ;
!FOX  Y(2)=YY(2) ;
             goto 480
          endif

          if(kzz.eq.20.and.parbe(ix,2).eq.zero) then                      !hr08
            if(nbeam.ge.1) then
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
                  if(ibbc.eq.0) then
                    crk=parbe(ix,5)
                    cik=parbe(ix,6)
                  else
                    crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                    cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                  endif
                  rho2b=crk**2+cik**2                                          !hr03
                  if(rho2b.gt.pieni) then
                    if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
                    tkb=rho2b/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))        !hr03
                    beamoff4=(((crad*ptnfac(ix))*crk)/rho2b)*(one-exp_mb(-one*tkb)) !hr03
                    beamoff5=(((crad*ptnfac(ix))*cik)/rho2b)*(one-exp_mb(-one*tkb)) !hr03
                  endif
                endif
#include "include/beamcof.f90"
!FOX  RHO2BF=CRKVEBF*CRKVEBF+CIKVEBF*CIKVEBF ;
                if(abs(dare(rho2bf)).gt.pieni) then
                  if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=RHO2BF/(TWO*SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I))) ;
                  if(ibbc.eq.0) then
!FOX   Y(1)=Y(1)+(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX   Y(2)=Y(2)+(CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                  else
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                  endif
                endif
              else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
                  if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                  r2b=two*(sigman(1,imbb(i))**2-sigman(2,imbb(i))**2) !hr08
                  rb=sqrt(r2b)
                  rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
                  if(ibbc.eq.0) then
                    crk=parbe(ix,5)
                    cik=parbe(ix,6)
                  else
                    crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                    cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                  endif
                  xrb=abs(crk)/rb
                  zrb=abs(cik)/rb
                  call errf(xrb,zrb,crxb,crzb)
                  if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                  tkb=(crk**2/sigman(1,imbb(i))**2+cik**2/sigman(2,imbb(i))**2)*half  !hr03
                  xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
                  zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
                  call errf(xbb,zbb,cbxb,cbzb)
                  beamoff4=(rkb*(crzb-exp_mb(-one*tkb)*cbzb))*sign(one,crk)
                  beamoff5=(rkb*(crxb-exp_mb(-one*tkb)*cbxb))*sign(one,cik)
                endif
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                r2bf=two*(sigman(1,imbb(i))**2-sigman(2,imbb(i))**2) !hr08
                rbf=sqrt(r2bf)
                rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
#include "include/beamcof.f90"
!FOX  XRBF=CRKVEBF/RBF ;
                if(dare(xrbf).lt.zero) then
!FOX  XRBF=-XRBF ;
                endif
!FOX  ZRBF=CIKVEBF/RBF ;
                if(dare(zrbf).lt.zero) then
!FOX  ZRBF=-ZRBF ;
                endif
                call errff(xrbf,zrbf,crxbf,crzbf)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
!FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
!FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
!FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
                call errff(xbbf,zbbf,cbxbf,cbzbf)
                scrkveb=sign(one,dare(crkvebf))
                scikveb=sign(one,dare(cikvebf))
                if(ibbc.eq.0) then
!FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                else
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                endif
              else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(ibeco.eq.1) then
                  if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                  r2b=two*(sigman(2,imbb(i))**2-sigman(1,imbb(i))**2)   !hr08
                  rb=sqrt(r2b)
                  rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
                  if(ibbc.eq.0) then
                    crk=parbe(ix,5)
                    cik=parbe(ix,6)
                  else
                    crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                    cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                  endif
                  xrb=abs(crk)/rb
                  zrb=abs(cik)/rb
                  call errf(zrb,xrb,crzb,crxb)
                  if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                  tkb=(crk**2/sigman(1,imbb(i))**2+cik**2/sigman(2,imbb(i))**2)*half  !hr03
                  xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
                  zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
                  call errf(zbb,xbb,cbzb,cbxb)
                  beamoff4=(rkb*(crzb-exp_mb(-one*tkb)*cbzb))*sign(one,crk)
                  beamoff5=(rkb*(crxb-exp_mb(-one*tkb)*cbxb))*sign(one,cik)
                endif
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                r2bf=two*(sigman(2,imbb(i))**2-sigman(1,imbb(i))**2) !hr08
                rbf=sqrt(r2bf)
                rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
#include "include/beamcof.f90"
!FOX  XRBF=CRKVEBF/RBF ;
                if(dare(xrbf).lt.zero) then
!FOX  XRBF=-XRBF ;
                endif
!FOX  ZRBF=CIKVEBF/RBF ;
                if(dare(zrbf).lt.zero) then
!FOX  ZRBF=-ZRBF ;
                endif
                call errff(zrbf,xrbf,crzbf,crxbf)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
!FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
!FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
!FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
                call errff(zbbf,xbbf,cbzbf,cbxbf)
                scrkveb=sign(one,dare(crkvebf))
                scikveb=sign(one,dare(cikvebf))
                if(ibbc.eq.0) then
!FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                else
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                endif
              endif
              goto 480
            endif
            goto 480
          endif
          if(kzz.eq.20.and.parbe(ix,2).gt.zero) then                      !hr08
#include "include/beam6dfi.f90"
            goto 480
          endif
          if(kzz.eq.22) then
            irrtr=imtr(ix)
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  PUSIG=((EJ1-E0)/E0F)*C1E3*(E0/E0F) ;
!FOX  TEMPI(1) = X(1) ;
!FOX  TEMPI(2) = YP(1) ;
!FOX  TEMPI(3) = X(2) ;
!FOX  TEMPI(4) = YP(2) ;
!FOX  TEMPI(5) = SIGMDA ;
!FOX  TEMPI(6) = PUSIG ;
!FOX  X(1)=COTR(IRRTR,1) +
!FOX  RRTR(IRRTR,1,1)*TEMPI(1)+RRTR(IRRTR,1,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,1,3)*TEMPI(3)+RRTR(IRRTR,1,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,1,5)*TEMPI(5)+RRTR(IRRTR,1,6)*TEMPI(6) ;
!FOX  YP(1)=COTR(IRRTR,2) +
!FOX  RRTR(IRRTR,2,1)*TEMPI(1)+RRTR(IRRTR,2,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,2,3)*TEMPI(3)+RRTR(IRRTR,2,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,2,5)*TEMPI(5)+RRTR(IRRTR,2,6)*TEMPI(6) ;
!FOX  X(2)=COTR(IRRTR,3) +
!FOX  RRTR(IRRTR,3,1)*TEMPI(1)+RRTR(IRRTR,3,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,3,3)*TEMPI(3)+RRTR(IRRTR,3,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,3,5)*TEMPI(5)+RRTR(IRRTR,3,6)*TEMPI(6) ;
!FOX  YP(2)=COTR(IRRTR,4) +
!FOX  RRTR(IRRTR,4,1)*TEMPI(1)+RRTR(IRRTR,4,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,4,3)*TEMPI(3)+RRTR(IRRTR,4,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,4,5)*TEMPI(5)+RRTR(IRRTR,4,6)*TEMPI(6) ;
!FOX  SIGMDA=COTR(IRRTR,5)+ 
!FOX  RRTR(IRRTR,5,1)*TEMPI(1)+RRTR(IRRTR,5,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,5,3)*TEMPI(3)+RRTR(IRRTR,5,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,5,5)*TEMPI(5)+RRTR(IRRTR,5,6)*TEMPI(6) ;
!FOX  PUSIG=COTR(IRRTR,6)+ 
!FOX  RRTR(IRRTR,6,1)*TEMPI(1)+RRTR(IRRTR,6,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,6,3)*TEMPI(3)+RRTR(IRRTR,6,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,6,5)*TEMPI(5)+RRTR(IRRTR,6,6)*TEMPI(6) ;
!FOX  EJ1 = E0F*PUSIG/(C1E3*(E0/E0F))+E0 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ; 
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
            end if
            if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) then
            if(bez(ix).eq.'DAMAP') then
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  DELTAS=SIGMDA/RV ;
              if(icav.eq.0.or.ithick.ne.1) then
                if(nvar2.ge.1) call dapri(x(1),17)
                if(nvar2.ge.2) call dapri(yp(1),17)
                if(nvar2.ge.3) call dapri(x(2),17)
                if(nvar2.ge.4) call dapri(yp(2),17)
                if(nvar2.eq.5.and.nsix.ne.2) call dapri(dpda1,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(deltas,17)
                if(nvar2.eq.6.or.nsix.eq.2) call dapri(dpda1,17)
              else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=DELTAS ;
!FOX  CORRAU1(6)=DPDA1 ;
                do kkk=1,6
                  dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
                end do
                if(ncor.gt.0) then
                  do kkk=1,ncor
                    kk=6+kkk
!FOX  CORRAU1(KK)=SMIDA(KKK) ;
                    dpdav=dare(smida(kkk))
!FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
                  enddo
                endif
                call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
                do kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
                end do
                call dapri(corrau2(1),17)
                call dapri(corrau2(2),17)
                call dapri(corrau2(3),17)
                call dapri(corrau2(4),17)
                call dapri(corrau2(5),17)
                call dapri(corrau2(6),17)
              endif
              if(ncor.gt.0) then
                do i11=1,ncor
                  call dapri(smida(i11),17)
                end do
              endif
            endif
            goto 480
          endif
          pi=four*atan_mb(one)

        if(kzz.eq.23) then
!FOX  CRABAMP=ED(IX)*ZZ0 ;

           crabfreq=ek(ix)*c1e3
           crabpht=crabph(ix)

!FOX  Y(1)=Y(1) - CRABAMP*C1E3/E0F*
!FOX  SIN((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT))*MTCDA/(ONE+DPDA) ;

!FOX  EJ1=EJ1-CRABAMP
!FOX  *CRABFREQ*2D0*PI/(CLIGHT)*X(1)*
!FOX  COS((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT)) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;

!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;

          goto 440
      endif
        if(kzz.eq.-23) then
!FOX  CRABAMP=ED(IX)*ZZ0 ;
           crabfreq=ek(ix)*c1e3
           crabpht=crabph(ix)
!FOX  Y(2)=Y(2) - CRABAMP*C1E3/E0F*
!FOX  SIN((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT))*MTCDA/(ONE+DPDA) ;

!FOX  EJ1=EJ1-CRABAMP
!FOX  *CRABFREQ*2D0*PI/(CLIGHT)*X(2)*
!FOX  COS((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT)) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;

!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif

! JBG RF CC Multipoles
        if(kzz.eq.26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP2=ED(IX)*ZZ0 ;

        crabfreq=ek(ix)*c1e3 !JBG Input in MHz changed to kHz
        crabpht2=crabph2(ix)
!FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI 
!FOX  + CRABPHT2)*MTCDA/(ONE+DPDA);
!FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI
!FOX  + CRABPHT2)*MTCDA/(ONE+DPDA);
!FOX  EJ1=EJ1 - (0.5D0)*(CRABAMP2)*(CRKVE*CRKVE-
!FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*C1M3*
!FOX  SIN(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI+CRABPHT2) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;

!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
          if(kzz.eq.-26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP2=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
!FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT2)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT2)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  EJ1=EJ1 - (0.5D0)*(CRABAMP2)*(CIKVE*CRKVE)
!FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*C1M3*
!FOX  SIN(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI+CRABPHT2) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP3=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(1)=Y(1) + 2D0*(1D0/2D0)*CRABAMP3*((CRKVE*CRKVE)-
!FOX  (CIKVE*CIKVE))*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(2)=Y(2) - 2D0*CRABAMP3*(CRKVE*CIKVE)*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  EJ1=EJ1 - 2D0*(1/6D0)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
!FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*E0F*
!FOX  SIN(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI+CRABPHT3);

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP3=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  Y(2)=Y(2) - CRABAMP3*((CIKVE*CIKVE)-
!FOX  (CRKVE*CRKVE))*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  Y(1)=Y(1) + 2D0*CRABAMP3*(CRKVE*CIKVE)*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT3);
!FOX  EJ1=EJ1 + 2D0*(1D0/6D0)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
!FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*E0F*
!FOX  SIN(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI+CRABPHT3);

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP4=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  Y(1)=Y(1) + (CRABAMP4)*
!FOX  (CRKVE*CRKVE*CRKVE-(3D0*CRKVE*CIKVE*CIKVE))*C1M6*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT4)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2) - (CRABAMP4)*
!FOX  (3D0*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M6*
!FOX  COS(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI + CRABPHT4)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  EJ1=EJ1-6D0*(1D0/24D0)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
!FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*
!FOX  SIN(SIGMDA/(CLIGHT*(E0F/E0))*CRABFREQ*2D0*PI+CRABPHT4) ;


!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;

          endif
          ipch=0
          if(ncor.gt.0) then
            do i11=1,ncor
              if(ipar(i11).eq.ix) ipch=i11
            end do
          end if
          if(ipch.ne.0) then
!FOX  EKK=(SMIDA(IPCH)+SMIZF(I))*MTCDA/(ONE+DPDA) ;
          else
!FOX  EKK=SMI(I)*MTCDA/(ONE+DPDA) ;
          end if
          xs=xsi(i)
          zs=zsi(i)
          if(mout2.eq.1.and.n.eq.1.and.icextal(i).ne.0) then
            write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),               &
     &extalign(i,1),extalign(i,2),extalign(i,3)
          end if
#include "include/alignf.f90"
          select case (kzz)
          case (1)  ! HORIZONTAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
#include "include/kickf01h.f90"
          case (2)  ! NORMAL QUADRUPOLE
#include "include/kickfxxh.f90"
          case (3)  ! NORMAL SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (4)  ! NORMAL OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (5)  ! NORMAL DECAPOLE
!FOX  EKK=EKK*C1M9 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (6)  ! NORMAL DODECAPOL
!FOX  EKK=EKK*C1M12 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (7)  ! NORMAL 14-POL
!FOX  EKK=EKK*C1M15 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (8)  ! NORMAL 16-POL
!FOX  EKK=EKK*C1M18 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (9)  ! NORMAL 18-POL
!FOX  EKK=EKK*C1M21 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (10) ! NORMAL 20-POL
!FOX  EKK=EKK*C1M24 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
          case (11)
            r0  = ek(ix)
            nmz = nmu(ix)
#include "include/multf01.f90"
            if (abs(r0).le.pieni.or.nmz.eq.0) goto 480
            if(mout2.eq.1.and.n.eq.1) then
              benkcc = ed(ix)*benkc(irm(ix))
              r0a    = one
              r000   = r0*r00(irm(ix))
              do j=1,mmul
                fake(1,j)=(bbi(i,j)*r0a)/benkcc                            !hr08
                fake(2,j)=(aai(i,j)*r0a)/benkcc                            !hr08
                r0a=r0a*r000
              end do
              
              write(9,'(a16)') bez(ix)
              write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
              write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
              write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
              write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
              write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
              write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
              write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
              write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
              write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
              write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
              write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
              write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
              write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
              write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
              
              do j=1,20
                fake(1,j)=zero
                fake(2,j)=zero
              end do
            end if
            if(nmz.ge.2) then
#include "include/multf02.f90"
              do k=3,nmz
#include "include/multf03.f90"
              end do
#include "include/multf04.f90"
            else
#include "include/multf05.f90"
            end if
          case (12,13,14,15,16,17,18,19,20,21,22,23)
            goto 480
          case (24) ! DIPEDGE ELEMENT
#include "include/kickfdpe.f90"
          case (25) ! Solenoid
#include "include/kickfso1.f90"
          
          !-----------------
          !--SKEW ELEMENTS--
          !-----------------
          case (-1)  ! VERTICAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
#include "include/kickf01v.f90"
          case (-2)  ! SKEW QUADRUPOLE
#include "include/kickfxxv.f90"
          case (-3)  ! SKEW SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-4)  ! SKEW OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-5)  ! SKEW DECAPOLE
!FOX  EKK=EKK*C1M9 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-6)  ! SKEW DODECAPOL
!FOX  EKK=EKK*C1M12 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-7)  ! SKEW 14-POL
!FOX  EKK=EKK*C1M15 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-8)  ! SKEW 16-POL
!FOX  EKK=EKK*C1M18 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-9)  ! SKEW 18-POL
!FOX  EKK=EKK*C1M21 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          case (-10) ! SKEW 20-POL
!FOX  EKK=EKK*C1M24 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
          end select
! ----------------------------------------------------------------------
! This is a repeat of the case for SKEW 14-POL because it is called by
! a number of gotos in the DA version
  440   continue
!FOX  EKK=EKK*C1M15 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
! ----------------------------------------------------------------------
  480   continue
        if(mout2.eq.1) then
          if(ic(iu).le.nblo) then
            write(ch,*) bez(mtyp(ic(iu),mel(ic(iu)))),dare(x(1)),       &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 705
            enddo
 705        write(99,'(a)') ch(:ich)
          else
            write(ch,*) bez(ic(iu)-nblo),dare(x(1)),                    &
     &dare(y(1)),dare(x(2)),dare(y(2)),dare(sigmda),dare(dpda)
            do ich=300,1,-1
              if(ch(ich:ich).ne.' ') goto 706
            enddo
 706        write(99,'(a)') ch(:ich)
          endif
        endif
  490 continue
  500 continue
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  DELTAS=SIGMDA/RV ;
      if(nsix.eq.2) nsix=0
      if(icav.eq.0.or.ithick.ne.1) then
        if(nvar2.ge.1) call dapri(x(1),18)
        if(nvar2.ge.2) call dapri(yp(1),18)
        if(nvar2.ge.3) call dapri(x(2),18)
        if(nvar2.ge.4) call dapri(yp(2),18)
        if(nvar2.eq.5) call dapri(dpda1,18)
        if(nvar2.eq.6) call dapri(deltas,18)
        if(nvar2.eq.6) call dapri(dpda1,18)
      else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=DELTAS ;
!FOX  CORRAU1(6)=DPDA1 ;
        do 505 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  505   continue
        if(ncor.gt.0) then
          do kkk=1,ncor
            kk=6+kkk
!FOX  CORRAU1(KK)=SMIDA(KKK) ;
            dpdav=dare(smida(kkk))
!FOX  CORRNEW(KK)=SMIDA(KKK)-DPDAV ;
          enddo
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
        do 506 kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  506   continue
!FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
!FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
!FOX  X(1)=CORRAU2(1) ;
!FOX  Y(1)=CORRAU1(2) ;
!FOX  X(2)=CORRAU2(3) ;
!FOX  Y(2)=CORRAU1(4) ;
!FOX  SIGMDA=CORRAU2(5)*RV ;
!FOX  DPDA1=CORRAU2(6) ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
        call dapri(corrau2(1),18)
        call dapri(corrau2(2),18)
        call dapri(corrau2(3),18)
        call dapri(corrau2(4),18)
        call dapri(corrau2(5),18)
        call dapri(corrau2(6),18)
      endif
      if(ncor.gt.0) then
        do i11=1,ncor
          call dapri(smida(i11),18)
        end do
      endif
      write(lout,*) 'END COORDINATES'
      write(lout,*) dare(x(1)),dare(y(1))
      write(lout,*) dare(x(2)),dare(y(2))
      write(lout,*) dare(sigmda),dare(dpda)
      
      write(12,'(E22.15)') dare(x(1))
      write(12,'(E22.15)') dare(y(1))
      write(12,'(E22.15)') dare(x(2))
      write(12,'(E22.15)') dare(y(2))
      write(12,'(E22.15)') dare(sigmda)
      write(12,'(E22.15)') dare(dpda)

      write(lout,10010)
      
  520 continue
!     DADAL AUTOMATIC INCLUSION
      time2=0.
      call timex(time2)
!     time=time2-time1
      write(lout,10020) time1-time0
      write(lout,10030) nord,time2-time1
!-----------------------------------------------------------------------
call comt_daEnd
      return
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. ',     &
     &i7,' LOST IN REVOLUTION ',i8,' AT ELEMENT ',i4/ t10,              &
     &'HORIZ:  AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,       &
     &'VERT:   AMPLITUDE = ',ES23.16,'   APERTURE = ',f15.3/ t10,       &
     &'ELEMENT - LIST NUMBER ',i4,' TYP NUMBER ',i4,' NAME ',a16/)
10010 format(//t10,30('*')/t10,'**** ONE TURN COMPLETED ****'/ t10,30(  &
     &'*')/)
10020 format(/10x,'The Preparating Calculations took',f12.3,' second(s)'&
     &,' of Computing Time')
10030 format(/10x,'DA-Calculation of Order : ',i7,' took ', f12.3,      &
     &' second(s) of CPU Time'//131('-')//)
end subroutine runda

+dk umlau6
subroutine umlauda
!-----------------------------------------------------------------------
!  CENTRAL LOOP FOR 6-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use physical_constants
      use numerical_constants
      use mathlib_bouncer
      use dump, only : dumpclo, dumptas, dumptasinv, ldump
      use crcoall
      use string_tools
      use parpro
      use parbeam, only : beam_expflag,beam_expfile_open
      use mod_common
      use mod_commonmn, only : e0f
      use mod_commons
      use mod_commont, only : xxtr,yytr,issss,tasm,comt_daStart,comt_daEnd
      use mod_commond
      use mod_commond2
      use wire
      use mod_hions
      use mod_lie_dab, only : idao,iscrri,rscrri,iscrda
      
      implicit none
      
      integer i,ibb,iii,i2,i3,i4,icav,icoonly,ien,iflag,iflag1,iflag2,  &
     &ii,ii2,ip,ipch,irrtr,ivar,ivar1,iwrite,ix,j,j1,jb,jj,jmel,jx,k,   &
     &kkk,kpz,kzz,mfile,nd2,nmz,idaa,angno,damap,damapi,damap1,f,aa2,   &
     &aa2r,a1,a1r,xy,h,df
      real(kind=fPrec) al1,al2,al3,angp,angnoe,au,aui,b1,b2,b3,beamoff1,&
     &beamoff2,beamoff3,beamoff4,beamoff5,beamoff6,betr0,c,c5m4,cbxb,cbzb,coefh1,&
     &cik,coefh2,coefv1,coefv2,cp,crk,crxb,crzb,cx,d,dicu,dare,det1,dp, &
     &dpdav,dpdav2,dphi,dps1,dps11,dummy,ed1,ed2,g1,g2,g3,ox,oxp,oxp1,  &
     &oz,ozp,ozp1,phi,r0,r2b,r2bf,rb,rbf,rdd,rho2b,rkb,rkbf,rrad,       &
     &scikveb,scrkveb,sfac1,sfac2,sfac2s,sfac3,sfac4,sfac5,sigm1,       &
     &sigmdac,startco,sx,tas,tkb,tl,x2pi,xbb,xrb,xs,zbb,zfeld1,zfeld2,  &
     &zrb,zs,  crabfreq, crabpht, crabpht2, crabpht3, crabpht4
      character(len=max_name_len) typ
+ca commond1
      dimension damap(6),damapi(6),damap1(6)
      dimension aa2(6),aa2r(6),a1(6),a1r(6),xy(6),df(6)
      dimension zfeld1(100),zfeld2(100)
      dimension jj(100),dpdav2(6),rrad(3),rdd(6,6),dicu(20)
      dimension angnoe(3),angp(2,6),phi(3),dphi(3)
      dimension b1(3),b2(3),b3(3),al1(3),al2(3),al3(3),g1(3),g2(3),g3(3)
      dimension d(3),dp(3),c(3),cp(3),au(6,6),aui(2)
      dimension i4(10,2)
!     for FMA analysis
!+ca fma
! END for FMA analysis
#ifdef DEBUG
!     integer umcalls,dapcalls,dokcalls,dumpl
!     common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
#endif

! For treatment and/or conversion of BEAM parameters in/to the new format
#ifdef CRLIBM
      character(len=1000) ch
      character(len=25) ch1
      integer errno,l1
      integer dtostr
#endif
      logical lopen
      character(len=256) filename
      integer wire_num_aux ! auxiliary variable to count number of wires
      save
!-----------------------------------------------------------------------
#include "include/daini.f90"
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      call comt_daStart
#ifdef DEBUG
!     umcalls=umcalls+1
!     call wda('umcalls',0d0,1,umcalls,0,0)
#endif
      nd2=ndimf*2
      call etall(damap,6)
      call etall(damapi,6)
      call etall(damap1,6)
      call etall(angno,1)
      call etall(f,1)
      call etall(aa2,6)
      call etall(aa2r,6)
      call etall(a1,6)
      call etall(a1r,6)
      call etall(xy,6)
      call etall(h,1)
      call etall(df,6)
#ifdef DEBUG
!     call wda('uml2',0d0,2,0,0,0)
#endif
      if(iqmodc.eq.1) call danot(2)
      if(iqmodc.eq.3) call danot(1)
      if(ichromc.eq.1) call danot(3)
#ifdef DEBUG
!     call wda('uml3',0d0,3,0,0,0)
#endif
      icoonly=0
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ichromc.eq.2) icoonly=1
#ifdef FAST
      c5m4=5.0d-4
#endif
      do j=1,2
        angnoe(j)=zero
        do i=1,6
          angp(j,i)=zero
        enddo
      enddo
      do i=1,100
        jj(i)=0
      enddo
      x2pi=atan_mb(one)*eight
      i4(1,1)=1
      i4(1,2)=1
      i4(2,1)=3
      i4(2,2)=3
      i4(3,1)=1
      i4(3,2)=3
      i4(4,1)=1
      i4(4,2)=2
      i4(5,1)=1
      i4(5,2)=4
      i4(6,1)=2
      i4(6,2)=2
      i4(7,1)=2
      i4(7,2)=3
      i4(8,1)=2
      i4(8,2)=4
      i4(9,1)=3
      i4(9,2)=4
      i4(10,1)=4
      i4(10,2)=4
      e0f=sqrt(e0**2-nucm0**2)                                             !hr05
      betr0=sqrt(one-(nucm0/e0)**2)
      ox=xxtr(1,1)
      oxp=yytr(1,1)
      oz=xxtr(1,2)
      ozp=yytr(1,2)
      sigm1=sigm(1)
      dps1=dps(1)
      nucmda=nucm0 ! this is doen like this in case we want to change so we can run Ions designed for different optics. 
      !mtc     (j) = (nzz(j)*nucm0)/(zz0*nucm(j)) Again we keep this variable in case we want to change the implementation later. 
      mtcda = one  


      if(iqmodc.eq.1) then
        if(el(iq(1)).le.pieni) then
          ed1=ed(iq(1))
        else
          ed1=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          ed2=ed(iq(2))
        else
          ed2=ek(iq(2))
        endif
      endif
      if(ichromc.eq.1) then
        ed1=ed(issss(1))
        ed2=ed(issss(2))
      endif
#ifdef DEBUG
!     call wda('uml4',0d0,4,0,0,0)
#endif
      call davar(x(1),ox,1)
      oxp1=oxp*(one+dps1)
      call davar(yp(1),oxp1,2)
      ivar=2
      if(nvar2.ge.4) then
        call davar(x(2),oz,3)
        ozp1=ozp*(one+dps1)
        call davar(yp(2),ozp1,4)
        ivar=4
      else
!FOX  X(2)=OZ ;
!FOX  YP(2)=OZP*(ONE+DPS1) ;
      endif
      dps11=dps1*c1e3
      if(nvar2.eq.3) then
        call davar(dpda1,dps11,3)
        ivar=ivar+1
      elseif(nvar2.eq.5) then
        call davar(dpda1,dps11,5)
        ivar=ivar+1
      elseif(nvar2.eq.6) then
        call davar(deltas,zero,5)
        call davar(dpda1,zero,6)

!FOX  DPDA1=DPDA1+DPS1*C1E3 ;        
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCM0*NUCM0) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DELTAS=DELTAS+SIGM1/RV ;
!FOX  SIGMDA=DELTAS*RV ;

        ivar=ivar+2
      else
!FOX  DELTAS=SIGM1 ;
!FOX  DPDA1=DPS1*C1E3 ;
      endif
      ivar1=ivar
      if(iqmodc.eq.1.or.ichromc.eq.1) then
        call davar(smida(1),ed1,ivar+1)
        call davar(smida(2),ed2,ivar+2)
        ivar=ivar+2
      endif
!--Normal Form Analysis for calculation of linear lattice functions
#ifdef DEBUG
!     call wda('uml5',0d0,5,ilinc,0,0)
#endif
      if(ilinc.eq.1.or.ilinc.eq.2) then
        mfile=18
!Eric
        rewind mfile
        rewind 111
!ERIC HERE
        call daread(damap,nvar,mfile,one)
#ifdef DEBUG
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml6',0d0,6,0,0,0)
#endif
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
        do j=1,nvar
          call dacop(damap(j),damap1(j))
          dummy=dare(damap1(j))
          call dacsu(damap1(j),dummy,damap1(j))
        enddo
        if(ndimf.eq.3) then
          call damul(damap1(5),damap1(5),angno)
          call averaged(angno,damap1,.true.,angno, rv)
          jj(5)=1
          jj(6)=1
#ifdef DEBUG
!     call warr('emitz',emitz,0,0,0,0)
!     call wda('uml7',0d0,7,0,0,0)
#endif
          call dapek(angno,jj,emitz)
#ifdef DEBUG
!     call warr('emitz',emitz,1,0,0,0)
!     call wda('uml8',0d0,8,0,0,0)
#endif
          jj(5)=0
          jj(6)=0
          if(abs(emitz).le.pieni) then
            emitz=zero
          else
            emitz=((sigz**2/emitz)*half)*c1e6                            !hr05
          endif
        endif
#ifdef DEBUG
!     call warr('emitz',emitz,2,0,0,0)
!     call wda('uml9',0d0,9,0,0,0)
#endif
#ifdef DEBUG
!     call dumpbin('emitz',1,1)
!     call dumpda('emitz',1,0)
!     call abend('          emitz                                   ')
#endif
        jj(5)=1
        do j=1,nd2
          call dapek(a1(j),jj,dicu(j))
        enddo
        jj(5)=0
      endif
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  CORROLD(1)=X(1) ;
!FOX  CORROLD(2)=YP(1) ;
!FOX  CORROLD(3)=X(2) ;
!FOX  CORROLD(4)=YP(2) ;
!FOX  CORROLD(5)=DELTAS ;
!FOX  CORROLD(6)=DPDA1 ;
            do 5 kkk=1,6
              dpdav=dare(corrold(kkk))
!FOX  CORROLD(KKK)=CORROLD(KKK)-DPDAV ;
    5       continue
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;

      iflag=0
      iflag1=0
      iflag2=0
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  SIGMDA=DELTAS*RV ;
      if(ithick.eq.1) call envada
      icav=0
      typ='START'
      phi(1)=zero
      phi(2)=zero
      phi(3)=zero
      ibb=0
      wire_num_aux=0
#ifdef DEBUG
!     call wda('biu',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('biu',0,0)
!     call abend('biu                                               ')
!     endif
#endif
!     start loop over single elements
      do 430 i=1,iu
        if(iqmodc.eq.2.or.iqmodc.eq.4) then
          if(i.eq.niu(1)) then
            do ii=1,2
              ii2=2*ii
              clon(ii2-1)=dare(x(ii))
              clon(ii2)=dare(y(ii))
            enddo
            clon(5)=dare(sigmda)
            clon(6)=dare(dpda)
          endif
        endif
#ifdef DEBUG
!     call wda('aclon',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aclon',0,0)
!     call abend('aclon                                             ')
!     endif
#endif
        if(ilinc.eq.1.and.i.eq.1) then
          write(lout,10000) nd2
          if(iprint.eq.1) write(lout,10130)
          write(lout,10010)
          write(lout,10020)
          write(lout,10010)
          tl=zero
#include "include/umlalid.f90"
        endif
#ifdef DEBUG
!     call wda('biflag',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call wda('biflag',0d0,iflag,0,0,0)
!       call dumpda('biflag',0,0)
!     call abend('biflag                                            ')
!     endif
#endif
        if(iflag.eq.1) then
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DELTAS=SIGMDA/RV ;
          if(ithick.eq.1) then
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
            if(icav.eq.0) then
!FOX  CORRNEW(1)=X(1) ;
!FOX  CORRNEW(2)=YP(1) ;
!FOX  CORRNEW(3)=X(2) ;
!FOX  CORRNEW(4)=YP(2) ;
!FOX  CORRNEW(5)=DELTAS ;
!FOX  CORRNEW(6)=DPDA1 ;
              do 24 kkk=1,6
                dpdav=dare(corrnew(kkk))
!FOX  CORRNEW(KKK)=CORRNEW(KKK)-DPDAV ;
   24         continue
            else
!FOX  CORRAU2(1)=X(1) ;
!FOX  CORRAU2(2)=YP(1) ;
!FOX  CORRAU2(3)=X(2) ;
!FOX  CORRAU2(4)=YP(2) ;
!FOX  CORRAU2(5)=DELTAS ;
!FOX  CORRAU2(6)=DPDA1 ;
              do 25 kkk=1,6
!FOX  CORRAU1(KKK)=CORRNEW(KKK) ;
                dpdav=dare(corrau2(kkk))
!FOX  CORRAU2(KKK)=CORRAU2(KKK)-DPDAV ;
   25         continue
              if(ivar.gt.ivar1) then
!FOX  CORRAU2(7)=SMIDA(1) ;
!FOX  CORRAU2(8)=SMIDA(2) ;
                dpdav=dare(smida(1))
!FOX  CORRAU1(7)=SMIDA(1)-DPDAV ;
                dpdav=dare(smida(2))
!FOX  CORRAU1(8)=SMIDA(2)-DPDAV ;
              endif
#ifdef DEBUG
!     call wda('dacct',0d0,1,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('bdacct',0,0)
!     call abend('bdaccct                                           ')
!     endif
#endif
              call dacct(corrau2,nvar,corrau1,nvar,corrnew,nvar)
            endif
#ifdef DEBUG
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
#endif
            dpdav=dare(x(1))
!FOX  X(1)=CORROLD(1)+DPDAV ;
            dpdav=dare(yp(1))
!FOX  YP(1)=CORROLD(2)+DPDAV ;
            dpdav=dare(x(2))
!FOX  X(2)=CORROLD(3)+DPDAV ;
            dpdav=dare(yp(2))
!FOX  YP(2)=CORROLD(4)+DPDAV ;
            dpdav=dare(deltas)
!FOX  DELTAS=CORROLD(5)+DPDAV ;
            dpdav=dare(dpda1)
!FOX  DPDA1=CORROLD(6)+DPDAV ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;

!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
!FOX  EJF1=E0F*(ONE+DPDA)/(NUCM0/NUCMDA) ;
!FOX  EJ1=SQRT(EJF1*EJF1+NUCMDA*NUCMDA) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  SIGMDA=DELTAS*RV ;


            icav=icav+1
            call envada
          endif
          iflag=0
        endif
        ix=ic(i)
        if(ix.gt.nblo) goto 50
        if(ix.le.0) then
          call prror(93)
        endif
#include "include/dalin1.f90"
#ifdef DEBUG
!     call wda('adlin1',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adlin1',0,0)
!     call abend('adlin1                                            ')
!     endif
#endif
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
#ifdef DEBUG
!     call wda('aenvquad',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('aenvquad',0,0)
!     call abend('aenvquad                                          ')
!     endif
#endif
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
#include "include/dalin2.f90"
              endif
#include "include/dalin3.f90"
          if(ilinc.eq.1) then
            do jb=1,jmel
              jx=mtyp(ix,jb)
              typ=bez(jx)
              tl=tl+el(jx)
#include "include/umlalid.f90"
              if(i.eq.nt) goto 470
            enddo
          endif
#include "include/dalin4.f90"
              ipch=0
              if(iqmodc.eq.1.and.kz(jx).eq.2) then
                if(jx.eq.iq(1).or.iratioe(jx).eq.iq(1)) then
                  ipch=1
                else if(jx.eq.iq(2).or.iratioe(jx).eq.iq(2)) then
                  ipch=2
                endif
              endif
              if(ipch.ne.0) then
                call envquad(jx,ipch)
!FOX  PUX=X(1) ;
!FOX  PUZ=Y(1) ;
!FOX  SIGMDA=SIGMDA+ASDAQ(1,1)+ASDAQ(1,2)*PUX+
!FOX  ASDAQ(1,3)*PUZ+ASDAQ(1,4)*PUX*PUZ+ASDAQ(1,5)*PUX*PUX+
!FOX  ASDAQ(1,6)*PUZ*PUZ ;
!FOX  X(1)=ALDAQ(1,1)*PUX+ALDAQ(1,2)*PUZ+ALDAQ(1,5)*IDZ(1) ;
!FOX  Y(1)=ALDAQ(1,3)*PUX+ALDAQ(1,4)*PUZ+ALDAQ(1,6)*IDZ(1) ;
!FOX  PUX=X(2) ;
!FOX  PUZ=Y(2) ;
!FOX  SIGMDA=SIGMDA+ASDAQ(2,1)+ASDAQ(2,2)*PUX+
!FOX  ASDAQ(2,3)*PUZ+ASDAQ(2,4)*PUX*PUZ+ASDAQ(2,5)*PUX*PUX+
!FOX  ASDAQ(2,6)*PUZ*PUZ ;
!FOX  X(2)=ALDAQ(2,1)*PUX+ALDAQ(2,2)*PUZ+ALDAQ(2,5)*IDZ(2) ;
!FOX  Y(2)=ALDAQ(2,3)*PUX+ALDAQ(2,4)*PUZ+ALDAQ(2,6)*IDZ(2) ;
              else
#include "include/dalin5.f90"
              endif
            else
              if(iexact.eq.1) then
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
!FOX  X(1)=X(1)*C1M3 ;
!FOX  X(2)=X(2)*C1M3 ;
!FOX  Y(1)=Y(1)*C1M3 ;
!FOX  Y(2)=Y(2)*C1M3 ;
!FOX  SIGMDA=SIGMDA*C1M3 ;
!FOX  PZ=SQRT(ONE-Y(1)*Y(1)-Y(2)*Y(2)) ;
!FOX  X(1)=X(1)+EL(JX)*(Y(1)/PZ) ;
!FOX  X(2)=X(2)+EL(JX)*(Y(2)/PZ) ;
!FOX  SIGMDA=SIGMDA+(ONE-(RV/PZ))*EL(JX) ;
!FOX  X(1)=X(1)*C1E3 ;
!FOX  X(2)=X(2)*C1E3 ;
!FOX  Y(1)=Y(1)*C1E3 ;
!FOX  Y(2)=Y(2)*C1E3 ;
!FOX  SIGMDA=SIGMDA*C1E3 ;
!-----------------------------------------------------------------------
              else
! Regular drift
#include "include/dalin6.f90"
!FOX  SIGMDA=SIGMDA+
#include "include/sqrtfox.f90"
              endif
            endif
            if(ilinc.eq.1) then
              typ=bez(jx)
              tl=tl+el(jx)
#include "include/umlalid.f90"
              if(i.eq.nt) goto 470
            endif
          enddo
        endif
#ifdef DEBUG
!     if (umcalls.eq.8) then
!     call wda('bgoto430',0d0,2,0,0,0)
!       call dumpda('bgoto430',0,0)
!     call abend('bgoto430                                          ')
!     endif
#endif
        goto 430
   50   ix=ix-nblo
#ifdef DEBUG
!     if (umcalls.eq.8) then
!     call wda('a50',0d0,ix,nblo,ix-nblo,0)
!       call dumpda('a50',0,0)
!     call abend('a50                                               ')
!     endif
#endif
        if(abs(dare(x(1))).gt.aint(aper(1)).or. abs(dare(x(2))).gt.aint(aper(2))) then
          write(lout,10120)j,i,dare(x(1)),aper(1),dare(x(2)),aper(2),ix,kz(ix),bez(ix)
          call prror(97)
        endif
        kpz=abs(kp(ix))
        if(kpz.ge.0 .and. kpz.lt.6) goto 80
        if(kpz.eq.6) goto 70
        goto 430
   70   continue
        if(ition.ne.0) then
!FOX  EJF0=EJF1 ;
          ixcav=ix
          if(abs(dppoff).gt.pieni) then
            sigmdac=dare(sigmda)
            sigmoff(i)=sigmdac
!FOX  SIGMDA=SIGMDA-SIGMDAC ;
          endif
          call synoda

!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;

          if(nvar2.eq.6.and.nsix.ne.2) then
            iflag=1
            iflag1=1
            iflag2=1
          endif
        endif
        goto 440
   80   kzz=kz(ix)
        if(kzz.eq.15) then
! the same as in umlalid1
          wire_num_aux = wire_num_aux+1
! is the error number correct?
          if(wire_num_aux.gt.wire_max) then
               write(lout,                                              &
     &*) 'ERROR: maximum number of wires exceeded! Number of wires ='// &
     &'wire_num_aux = ',wire_num_aux,' > ',wire_max,' = wire_max'
            call prror(-1)
          endif
          wire_num(i) = wire_num_aux
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  DELTAS=SIGMDA/RV ;
!FOX  DPDA1=DPDA*C1E3 ;
          call dacop(x(1),damap(1))
          call dacop(yp(1),damap(2))
          call dacop(x(2),damap(3))
          call dacop(yp(2),damap(4))
          do j=1,2
            ii=2*j
            call dapek(damap(ii-1),jj,c(j))
            call dapek(damap(ii),jj,cp(j))
          enddo
          call dacsu(damap(1),c(1),damap(1))
          call dacsu(damap(2),cp(1),damap(2))
          call dacsu(damap(3),c(2),damap(3))
          call dacsu(damap(4),cp(2),damap(4))
          if(ndimf.eq.3) then
            call dacop(deltas,damap(5))
            call dacop(dpda1,damap(6))
            call dapek(damap(5),jj,c(3))
            call dapek(damap(6),jj,cp(3))
            call dacsu(damap(5),c(3),damap(5))
            call dacsu(damap(6),cp(3),damap(6))
            if(iflag2.eq.1.and.ithick.eq.1) then
              call dacct(damap,nvar,corrnew,nvar,damap,nvar)
            endif
          endif
          call dainv(damap,nvar,damapi,nvar)
          call dacct(damap,nvar,aa2,nvar,aa2r,nvar)
          call dacct(damap,nvar,damap1,nvar,damap,nvar)
          call dacct(damap,nvar,damapi,nvar,damap,nvar)
! the same as in umlalid1
      
!FOX  XX(1)=X(1) ;
!FOX  XX(2)=X(2) ;
!FOX  YY(1)=Y(1) ;
!FOX  YY(2)=Y(2) ;
      wire_clo(1,wire_num(i))=dare(x(1))
      wire_clo(2,wire_num(i))=dare(x(2))
      wire_clo(4,wire_num(i))=dare(y(1))*(one+dare(DPDA))
      wire_clo(5,wire_num(i))=dare(y(2))*(one+dare(DPDA))
      if(ndimf.eq.3) then
         wire_clo(3,wire_num(i))=dare(SIGMDA)
         wire_clo(6,wire_num(i))=dare(DPDA)
      endif

      call wireda(ix,i)


!FOX  Y(1)=YY(1) ;
!FOX  Y(2)=YY(2) ;
          goto 440
        endif
        if(ilinc.eq.2.and.kzz.eq.20) then
          if(nbeam.ge.1) then
#include "include/umlalid1.f90"
          endif
          goto 440
        endif
        if(kzz.eq.20.and.iqmodc.eq.4) goto 440
        if(kzz.eq.20.and.parbe(ix,2).eq.zero) then                        !hr12
          if(nbeam.ge.1) then
            if(ilinc.eq.0) then
              clobeam(1,imbb(i))=dare(x(1))
              clobeam(2,imbb(i))=dare(x(2))
              clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
              clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
              if(ndimf.eq.3) then
                clobeam(3,imbb(i))=dare(sigmda)
                clobeam(6,imbb(i))=dare(dpda)
              endif
            endif
            if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
                if(ibbc.eq.0) then
                  crk=parbe(ix,5)
                  cik=parbe(ix,6)
                else
                  crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                  cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                endif
                rho2b=crk**2+cik**2                                          !hr03
                if(rho2b.gt.pieni) then
                  if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
                  tkb=rho2b/((two*sigman(1,imbb(i)))*sigman(1,imbb(i)))        !hr03
                  beamoff4=(((crad*ptnfac(ix))*crk)/rho2b)*(one-exp_mb(-one*tkb)) !hr03
                  beamoff5=(((crad*ptnfac(ix))*cik)/rho2b)*(one-exp_mb(-one*tkb)) !hr03
                endif
              endif
#include "include/beamcof.f90"
!FOX  RHO2BF=CRKVEBF*CRKVEBF+CIKVEBF*CIKVEBF ;
              if(abs(dare(rho2bf)).gt.pieni) then
                if(abs(sigman(1,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=RHO2BF/(TWO*SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I))) ;
                if(ibbc.eq.0) then
!FOX   Y(1)=Y(1)+(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX   Y(2)=Y(2)+(CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                else
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX   CCCC=(CRAD*CRKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX   (CRAD*CIKVEBF/RHO2BF*
!FOX   PTNFAC(IX)*(ONE-EXP(-TKBF))-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                endif
              endif
            else if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                r2b=two*(sigman(1,imbb(i))**2-sigman(2,imbb(i))**2) !hr08
                rb=sqrt(r2b)
                rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
                if(ibbc.eq.0) then
                  crk=parbe(ix,5)
                  cik=parbe(ix,6)
                else
                  crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                  cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                endif
                xrb=abs(crk)/rb
                zrb=abs(cik)/rb
                call errf(xrb,zrb,crxb,crzb)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                tkb=(crk**2/sigman(1,imbb(i))**2+cik**2/sigman(2,imbb(i))**2)*half  !hr03
                xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
                zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
                call errf(xbb,zbb,cbxb,cbzb)
                beamoff4=(rkb*(crzb-exp_mb(-one*tkb)*cbzb))*sign(one,crk)
                beamoff5=(rkb*(crxb-exp_mb(-one*tkb)*cbxb))*sign(one,cik)
              endif
              if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
              r2bf=two*(sigman(1,imbb(i))**2-sigman(2,imbb(i))**2) !hr08
              rbf=sqrt(r2bf)
              rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
#include "include/beamcof.f90"
!FOX  XRBF=CRKVEBF/RBF ;
                if(dare(xrbf).lt.zero) then
!FOX  XRBF=-XRBF ;
                endif
!FOX  ZRBF=CIKVEBF/RBF ;
                if(dare(zrbf).lt.zero) then
!FOX  ZRBF=-ZRBF ;
                endif
                call errff(xrbf,zrbf,crxbf,crzbf)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
!FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
!FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
!FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
                call errff(xbbf,zbbf,cbxbf,cbzbf)
                scrkveb=sign(one,dare(crkvebf))
                scikveb=sign(one,dare(cikvebf))
                if(ibbc.eq.0) then
!FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                else
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                endif
            else if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
              if(ibeco.eq.1) then
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                r2b=two*(sigman(2,imbb(i))**2-sigman(1,imbb(i))**2)   !hr08
                rb=sqrt(r2b)
                rkb=((crad*ptnfac(ix))*pisqrt)/rb                            !hr03
                if(ibbc.eq.0) then
                  crk=parbe(ix,5)
                  cik=parbe(ix,6)
                else
                  crk=parbe(ix,5)*bbcu(imbb(i),11) + parbe(ix,6)*bbcu(imbb(i),12)
                  cik=parbe(ix,6)*bbcu(imbb(i),11) - parbe(ix,5)*bbcu(imbb(i),12)
                endif
                xrb=abs(crk)/rb
                zrb=abs(cik)/rb
                call errf(zrb,xrb,crzb,crxb)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
                tkb=(crk**2/sigman(1,imbb(i))**2+cik**2/sigman(2,imbb(i))**2)*half  !hr03
                xbb=(sigman(2,imbb(i))/sigman(1,imbb(i)))*xrb                !hr03
                zbb=(sigman(1,imbb(i))/sigman(2,imbb(i)))*zrb                !hr03
                call errf(zbb,xbb,cbzb,cbxb)
                beamoff4=(rkb*(crzb-exp_mb(-one*tkb)*cbzb))*sign(one,crk)
                beamoff5=(rkb*(crxb-exp_mb(-one*tkb)*cbxb))*sign(one,cik)
              endif
              if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
              r2bf=two*(sigman(2,imbb(i))**2-sigman(1,imbb(i))**2) !hr08
              rbf=sqrt(r2bf)
              rkbf=((crad*ptnfac(ix))*pisqrt)/rbf                          !hr03
#include "include/beamcof.f90"
!FOX  XRBF=CRKVEBF/RBF ;
                if(dare(xrbf).lt.zero) then
!FOX  XRBF=-XRBF ;
                endif
!FOX  ZRBF=CIKVEBF/RBF ;
                if(dare(zrbf).lt.zero) then
!FOX  ZRBF=-ZRBF ;
                endif
                call errff(zrbf,xrbf,crzbf,crxbf)
                if(abs(sigman(1,imbb(i))).lt.pieni.or.abs(sigman(2,imbb(i))).lt.pieni) call prror(88)
!FOX  TKBF=(CRKVEBF*CRKVEBF/(SIGMAN(1,IMBB(I))*SIGMAN(1,IMBB(I)))+
!FOX  CIKVEBF*CIKVEBF/(SIGMAN(2,IMBB(I))*SIGMAN(2,IMBB(I))))*HALF ;
!FOX  XBBF=SIGMAN(2,IMBB(I))/SIGMAN(1,IMBB(I))*XRBF ;
!FOX  ZBBF=SIGMAN(1,IMBB(I))/SIGMAN(2,IMBB(I))*ZRBF ;
                call errff(zbbf,xbbf,cbzbf,cbxbf)
                scrkveb=sign(one,dare(crkvebf))
                scikveb=sign(one,dare(cikvebf))
                if(ibbc.eq.0) then
!FOX  Y(1)=Y(1)+(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2)+(RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*MTCDA/(ONE+DPDA) ;
                else
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),11)-
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),12) ;
!FOX   Y(1)=Y(1)+CCCC*MTCDA/(ONE+DPDA) ;
!FOX  CCCC=(RKBF*(CRZBF-EXP(-TKBF)*
!FOX  CBZBF)*SCRKVEB-BEAMOFF4)*BBCU(IMBB(I),12)+
!FOX  (RKBF*(CRXBF-EXP(-TKBF)*
!FOX  CBXBF)*SCIKVEB-BEAMOFF5)*BBCU(IMBB(I),11) ;
!FOX   Y(2)=Y(2)+CCCC*MTCDA/(ONE+DPDA) ;
                endif
            endif
            goto 440
          endif
          goto 440
        endif
        if(kzz.eq.20.and.parbe(ix,2).gt.zero) then                        !hr12
          if(ilinc.eq.0)then
            clobeam(1,imbb(i))=dare(x(1))
            clobeam(2,imbb(i))=dare(x(2))
            clobeam(4,imbb(i))=dare(y(1))*(one+dare(dpda))
            clobeam(5,imbb(i))=dare(y(2))*(one+dare(dpda))
            if(ndimf.eq.3)then
              clobeam(3,imbb(i))=dare(sigmda)
              clobeam(6,imbb(i))=dare(dpda)
            endif
          endif
#include "include/beam6dfi.f90"
          goto 440
        endif
          pi=four*atan_mb(one)
        if(kzz.eq.23) then
!FOX  CRABAMP=ED(IX)*ZZ0 ;
          
          crabfreq=ek(ix)*c1e3
          crabpht=crabph(ix)


!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;
                
!FOX  Y(1)=Y(1) - CRABAMP*C1E3/E0F*
!FOX  SIN((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT))/(1+DPDA) ;

!FOX  EJ1=EJ1-CRABAMP
!FOX  *CRABFREQ*2D0*PI/(CLIGHT)*X(1)*
!FOX  COS((SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT)) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1=(EJF1-E0F)/E0F*C1E3 ;

!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;

          goto 440
      endif
        if(kzz.eq.-23) then
!FOX  CRABAMP=ED(IX)*ZZ0 ;
           crabfreq=ek(ix)*c1e3
           crabpht=crabph(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;
               
!FOX  Y(2)=Y(2) - CRABAMP*C1E3/E0F*
!FOX  SIN(KCRABDA)*MTCDA/(ONE+DPDA) ;

!FOX  EJ1=EJ1-CRABAMP
!FOX  *CRABFREQ*2D0*PI/(CLIGHT)*X(2)*
!FOX  COS(KCRABDA) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;

!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif

! JBG RF CC Multipoles
        if(kzz.eq.26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP2=ED(IX)*ZZ0 ;

!       write(*,*) crabamp, EJF1, EJF0,clight, "HELLO"
        crabfreq=ek(ix)*c1e3 !JBG Input in MHz changed to kHz
        crabpht2=crabph2(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(1)=Y(1) + (CRABAMP2*CRKVE)*
!FOX  COS(KCRABDA);
!FOX  Y(2)=Y(2) - (CRABAMP2*CIKVE)*
!FOX  COS(KCRABDA)*MTCDA/(ONE+DPDA);
!FOX  EJ1=EJ1 - (0.5D0)*(CRABAMP2)*(CRKVE*CRKVE-
!FOX  CIKVE*CIKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*C1M3*
!FOX  SIN(KCRABDA) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;

!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
      endif
          if(kzz.eq.-26) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i) ! JBG change of variables for misal calculations
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP2=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht2=crabph2(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(2)=Y(2) + (CRABAMP2*CRKVE)*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=Y(1) + (CRABAMP2*CIKVE)*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  EJ1=EJ1 - (0.5D0)*(CRABAMP2)*(CIKVE*CRKVE)
!FOX  *(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*C1M3*
!FOX  SIN(KCRABDA) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP3=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(1)=Y(1) + 2*(0.5D0)*CRABAMP3*((CRKVE*CRKVE)-
!FOX  (CIKVE*CIKVE))*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(KCRABDA);
!FOX  Y(2)=Y(2) - 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(KCRABDA);
!FOX  EJ1=EJ1 - 2*(1/6.)*(CRABAMP3)*(CRKVE*CRKVE*CRKVE-
!FOX  3*CIKVE*CIKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*E0F*
!FOX  SIN(KCRABDA);

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA*MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-27) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif 
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP3=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht3=crabph3(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(2)=Y(2) - 2*(0.5D0)*CRABAMP3*((CIKVE*CIKVE)-
!FOX  (CRKVE*CRKVE))*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(KCRABDA);
!FOX  Y(1)=Y(1) + 2*CRABAMP3*(CRKVE*CIKVE)*C1M3*MTCDA/(ONE+DPDA)*
!FOX  COS(KCRABDA);
!FOX  EJ1=EJ1 + 2*(1D0/6D0)*(CRABAMP3)*(CIKVE*CIKVE*CIKVE-
!FOX  3*CIKVE*CRKVE*CRKVE)*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  C1M6*E0F*
!FOX  SIN(KCRABDA);

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP4=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(1)=Y(1) + 6*(1D0/6D0)*(CRABAMP4)*
!FOX  (CRKVE*CRKVE*CRKVE-(3*CRKVE*CIKVE*CIKVE))*C1M6*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2) - 6*(1D0/6D0)*(CRABAMP4)*
!FOX  (3*CIKVE*CRKVE*CRKVE-CIKVE*CIKVE*CIKVE)*C1M6*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  EJ1=EJ1-6*(1D0/24D0)*(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CRKVE-
!FOX  6*CRKVE*CRKVE*CIKVE*CIKVE+CIKVE*CIKVE*CIKVE*CIKVE)*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*E0F*
!FOX  SIN(KCRABDA) ;


!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          goto 440
          endif
          if(kzz.eq.-28) then
            ! JBG bypass this element if 4D/5D case
            if(iclo6.eq.0) then
!                write(*,*)'Bypassing RF mult 4D or 5D case' 
                goto 440
            endif
          xs=xsi(i)
          zs=zsi(i)
#include "include/alignf.f90"
!FOX  CRABAMP4=ED(IX)*ZZ0 ;
             crabfreq=ek(ix)*c1e3
             crabpht4=crabph4(ix)
!FOX  KCRABDA=(SIGMDA/(CLIGHT*(E0F/E0))
!FOX  *CRABFREQ*2D0*PI + CRABPHT) ;

!FOX  Y(1)=Y(1) + (CRABAMP4)*
!FOX  (CIKVE*CIKVE*CIKVE-(3*CIKVE*CRKVE*CRKVE))*C1M6*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=Y(2) + (CRABAMP4)*
!FOX  (3*CRKVE*CIKVE*CIKVE-CRKVE*CRKVE*CRKVE)*C1M6*
!FOX  COS(KCRABDA)
!FOX  *MTCDA/(ONE+DPDA) ;
!FOX  EJ1=EJ1+(CRABAMP4)*(CRKVE*CRKVE*CRKVE*CIKVE-
!FOX  CIKVE*CIKVE*CIKVE*CRKVE)*E0F*
!FOX  C1M9*(((CRABFREQ*2D0)*PI)/CLIGHT)*
!FOX  SIN(KCRABDA) ;

!FOX  EJF0=EJF1 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=EJF0/EJF1*Y(1) ;
!FOX  Y(2)=EJF0/EJF1*Y(2) ;
          endif
          if(kzz.eq.22) then
            irrtr=imtr(ix)
!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  PUSIG=((EJ1-E0)/E0F)*C1E3*(E0/E0F) ;
!FOX  TEMPI(1) = X(1) ;
!FOX  TEMPI(2) = YP(1) ;
!FOX  TEMPI(3) = X(2) ;
!FOX  TEMPI(4) = YP(2) ;
!FOX  TEMPI(5) = SIGMDA ;
!FOX  TEMPI(6) = PUSIG ;
!FOX  X(1)=COTR(IRRTR,1) +
!FOX  RRTR(IRRTR,1,1)*TEMPI(1)+RRTR(IRRTR,1,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,1,3)*TEMPI(3)+RRTR(IRRTR,1,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,1,5)*TEMPI(5)+RRTR(IRRTR,1,6)*TEMPI(6) ;
!FOX  YP(1)=COTR(IRRTR,2) +
!FOX  RRTR(IRRTR,2,1)*TEMPI(1)+RRTR(IRRTR,2,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,2,3)*TEMPI(3)+RRTR(IRRTR,2,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,2,5)*TEMPI(5)+RRTR(IRRTR,2,6)*TEMPI(6) ;
!FOX  X(2)=COTR(IRRTR,3) +
!FOX  RRTR(IRRTR,3,1)*TEMPI(1)+RRTR(IRRTR,3,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,3,3)*TEMPI(3)+RRTR(IRRTR,3,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,3,5)*TEMPI(5)+RRTR(IRRTR,3,6)*TEMPI(6) ;
!FOX  YP(2)=COTR(IRRTR,4) +
!FOX  RRTR(IRRTR,4,1)*TEMPI(1)+RRTR(IRRTR,4,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,4,3)*TEMPI(3)+RRTR(IRRTR,4,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,4,5)*TEMPI(5)+RRTR(IRRTR,4,6)*TEMPI(6) ;
!FOX  SIGMDA=COTR(IRRTR,5)+ 
!FOX  RRTR(IRRTR,5,1)*TEMPI(1)+RRTR(IRRTR,5,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,5,3)*TEMPI(3)+RRTR(IRRTR,5,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,5,5)*TEMPI(5)+RRTR(IRRTR,5,6)*TEMPI(6) ;
!FOX  PUSIG=COTR(IRRTR,6)+ 
!FOX  RRTR(IRRTR,6,1)*TEMPI(1)+RRTR(IRRTR,6,2)*TEMPI(2)+
!FOX  RRTR(IRRTR,6,3)*TEMPI(3)+RRTR(IRRTR,6,4)*TEMPI(4)+
!FOX  RRTR(IRRTR,6,5)*TEMPI(5)+RRTR(IRRTR,6,6)*TEMPI(6) ;
!FOX  EJ1 = E0F*PUSIG/(C1E3*(E0/E0F))+E0 ;
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1 = (EJF1-E0F)/E0F*C1E3 ;
!FOX  RV=EJ1/E0*E0F/EJF1 ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ; 
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
        end if
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 440
        if(kzz.eq.15) goto 440
        ipch=0
        if(iqmodc.eq.1) then
          if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
            ipch=1
          else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
            ipch=2
          endif
        endif
        if(ichromc.eq.1) then
          if(ix.eq.issss(1).or.iratioe(ix).eq.issss(1)) then
            ipch=1
          else if(ix.eq.issss(2).or.iratioe(ix).eq.issss(2)) then
            ipch=2
          endif
        endif
        if(ipch.ne.0) then
!FOX  EKK=(SMIDA(IPCH)*RATIOE(IX)+SMIZF(I))*MTCDA/(ONE+DPDA) ;
        else
!FOX  EKK=SMI(I)*MTCDA/(ONE+DPDA) ;
        endif
        xs=xsi(i)
        zs=zsi(i)
#include "include/alignf.f90"
        
        select case (kzz)
        case (1)  ! HORIZONTAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
#include "include/kickf01h.f90"
        case (2)  ! NORMAL QUADRUPOLE
#include "include/kickfxxh.f90"
        case (3)  ! NORMAL SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (4)  ! NORMAL OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (5)  ! NORMAL DECAPOLE
!FOX  EKK=EKK*C1M9 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (6)  ! NORMAL DODECAPOL
!FOX  EKK=EKK*C1M12 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (7)  ! NORMAL 14-POL
!FOX  EKK=EKK*C1M15 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (8)  ! NORMAL 16-POL
!FOX  EKK=EKK*C1M18 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (9)  ! NORMAL 18-POL
!FOX  EKK=EKK*C1M21 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (10) ! NORMAL 20-POL
!FOX  EKK=EKK*C1M24 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxh.f90"
        case (11)
          r0  = ek(ix)
          nmz = nmu(ix)
#include "include/multf01.f90"
          if(abs(r0).le.pieni.or.nmz.eq.0) goto 440
          if(nmz.ge.2) then
#include "include/multf02.f90"
            do k=3,nmz
#include "include/multf03.f90"
            end do
#include "include/multf04.f90"
          else
#include "include/multf05.f90"
          end if
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 440
        case (24) ! DIPEDGE ELEMENT
#include "include/kickfdpe.f90"
        case (25) ! Solenoid
#include "include/kickfso1.f90"

        !-----------------
        !--SKEW ELEMENTS--
        !-----------------
        case (-1)  ! VERTICAL DIPOLE
!FOX  EKK=EKK*C1E3 ;
#include "include/kickf01v.f90"
        case (-2)  ! SKEW QUADRUPOLE
#include "include/kickfxxv.f90"
        case (-3)  ! SKEW SEXTUPOLE
!FOX  EKK=EKK*C1M3 ;
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-4)  ! SKEW OCTUPOLE
!FOX  EKK=EKK*C1M6 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-5)  ! SKEW DECAPOLE
!FOX  EKK=EKK*C1M9 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-6)  ! SKEW DODECAPOL
!FOX  EKK=EKK*C1M12 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-7)  ! SKEW 14-POL
!FOX  EKK=EKK*C1M15 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-8)  ! SKEW 16-POL
!FOX  EKK=EKK*C1M18 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-9)  ! SKEW 18-POL
!FOX  EKK=EKK*C1M21 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        case (-10) ! SKEW 20-POL
!FOX  EKK=EKK*C1M24 ;
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfho.f90"
#include "include/kickfxxv.f90"
        end select
        
 440  continue
#ifdef DEBUG
!     if (umcalls.eq.8) then
!     call wda('a440   ',0d0,2,0,0,0)
!       call dumpda('a440   ',0,0)
!     call abend('a440                                              ')
!     endif
#endif
      if(ilinc.eq.1) then
        typ=bez(ix)
#include "include/umlalid.f90"
        if(i.eq.nt) goto 470
      endif
 430  continue ! END LOOP OVER SINGLE ELEMENTS IN UMLAUDA

!FOX  YP(1)=Y(1)*(ONE+DPDA)/MTCDA ;
!FOX  YP(2)=Y(2)*(ONE+DPDA)/MTCDA ;
!FOX  DELTAS=SIGMDA/RV ;
#ifdef DEBUG
!     call wda('afox   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('afox   ',0,0)
!     call abend('afox                                              ')
!     endif
#endif
      if(icav.eq.0.or.ithick.ne.1) then
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      else
!FOX  CORRAU1(1)=X(1) ;
!FOX  CORRAU1(2)=YP(1) ;
!FOX  CORRAU1(3)=X(2) ;
!FOX  CORRAU1(4)=YP(2) ;
!FOX  CORRAU1(5)=DELTAS ;
!FOX  CORRAU1(6)=DPDA1 ;
#ifdef DEBUG
!     call wda('b435   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b435   ',0,0)
!     call abend('b435                                              ')
!     endif
#endif
        do 435 kkk=1,6
          dpdav2(kkk)=dare(corrau1(kkk))
!FOX  CORRAU1(KKK)=CORRAU1(KKK)-DPDAV2(KKK) ;
  435   continue
        if(ivar.gt.ivar1) then
!FOX  CORRAU1(7)=SMIDA(1) ;
!FOX  CORRAU1(8)=SMIDA(2) ;
          dpdav=dare(smida(1))
!FOX  CORRNEW(7)=SMIDA(1)-DPDAV ;
          dpdav=dare(smida(2))
!FOX  CORRNEW(8)=SMIDA(2)-DPDAV ;
        endif
        call dacct(corrau1,nvar,corrnew,nvar,corrau2,nvar)
#ifdef DEBUG
!     call wda('b436   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('b436   ',0,0)
!     call abend('b436                                              ')
!     endif
#endif
        do 436 kkk=1,6
!FOX  CORRAU2(KKK)=CORRAU2(KKK)+DPDAV2(KKK) ;
  436   continue
!FOX  CORRAU1(2)=CORRAU2(2)/(ONE+CORRAU2(6)) ;
!FOX  CORRAU1(4)=CORRAU2(4)/(ONE+CORRAU2(6)) ;
!FOX  X(1)=CORRAU2(1) ;
!FOX  YP(1)=CORRAU2(2) ;
!FOX  X(2)=CORRAU2(3) ;
!FOX  YP(2)=CORRAU2(4) ;
!FOX  DELTAS=CORRAU2(5) ;
!FOX  DPDA1=CORRAU2(6) ;
!FOX  DPDA=DPDA1*C1M3 ;
!FOX  MOIDA=MTCDA/(ONE+DPDA) ;
!FOX  Y(1)=YP(1)*MTCDA/(ONE+DPDA) ;
!FOX  Y(2)=YP(2)*MTCDA/(ONE+DPDA) ;
!FOX  SIGMDA=DELTAS*RV;
        if(icoonly.eq.1) then
          xxtr(1,1) = dare(x(1))
          yytr(1,1) = dare(y(1))
          xxtr(1,2) = dare(x(2))
          yytr(1,2) = dare(y(2))
          sigm(1) = dare(sigmda)
          dps(1) = dare(dpda)
        endif
      endif
      call dacop(x(1),damap(1))
      call dacop(x(2),damap(3))
      if(ndimf.eq.3) call dacop(sigmda,damap(5))
      if(icoonly.eq.1.or.iqmodc.eq.3) then
        call dacop(y(1),damap(2))
        call dacop(y(2),damap(4))
        if(ndimf.eq.3) call dacop(dpda,damap(6))
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(damap(ii),jj,aml6(ii,i))
            if(i.eq.6) aml6(ii,i)=aml6(ii,i)*c1e3
          enddo
          jj(i)=0
        enddo
        do i=1,nd2
          aml6(i,i)=aml6(i,i)-one
        enddo
      endif
#ifdef DEBUG
!     call wda('adacct?',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('adacct?',0,0)
!     call abend('adacct?                                           ')
!     endif
#endif
      call dacop(yp(1),damap(2))
      call dacop(yp(2),damap(4))
      if(ndimf.eq.3) then
        call dacop(deltas,damap(5))
        call dacop(dpda1,damap(6))
      else
        call dacop(dpda1,damap(5))
      endif
      if(iqmodc.eq.2.or.iqmodc.eq.4.or.ilin.ge.2) then
        rewind 18
!Eric
        rewind 111
        call daprid(damap,1,nvar,18)
      endif
#ifdef DEBUG
!     call wda('boutput',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('boutput',0,0)
!     call abend('boutput                                           ')
!     endif
#endif
!--now do the output
      if(iqmodc.eq.1) call danot(3)
      if(iqmodc.eq.3) call danot(2)
      if(ichromc.eq.1) call danot(4)
      if(ilinc.eq.1.or.ilinc.eq.2.or.iqmodc.eq.1.or.iqmodc.eq.3.or.     &
     &ichromc.eq.1) then
        call mapnorm(damap,f,aa2,a1,xy,h,nord1)
      endif
      if(iqmodc.eq.1.or.iqmodc.eq.3) then
        call gettura(wxys,rrad)
        wxys(3)=abs(wxys(3))
        write(lout,*) (wxys(i),i=1,ndimf)
        do i=1,nd2
          jj(i)=1
          do ii=1,nd2
            call dapek(aa2(ii),jj,tas)
            if(i.eq.6.and.ii.ne.6) tas=tas*c1e3
            if(ii.eq.6.and.i.ne.6) tas=tas*c1m3
            tasm(ii,i)=tas
          enddo
          jj(i)=0
        enddo
      endif
      if(iqmodc.eq.1) then
        call dhdj(h,df)
        do i=1,ndimf
          call dapek(df(ndimf+i),jj,corr(1,i))
        enddo
        corr(1,3)=abs(corr(1,3))
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+1)=0
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+2)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(90)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-one*coefh2)/det1                                     !hr05
        corr(3,1)=(-one*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
      if(ichromc.eq.1) then
        call dhdj(h,df)
        jj(nd2+1)=1
        call dapek(df(ndimf+1),jj,corr(1,1))
        call dapek(df(ndimf+2),jj,corr(1,2))
        jj(nd2+2)=1
        call dapek(df(ndimf+1),jj,coefh1)
        call dapek(df(ndimf+2),jj,coefv1)
        jj(nd2+2)=0
        jj(nd2+3)=1
        call dapek(df(ndimf+1),jj,coefh2)
        call dapek(df(ndimf+2),jj,coefv2)
        jj(nd2+3)=0
        jj(nd2+1)=0
        det1=coefh1*coefv2-coefv1*coefh2
        if(abs(det1).le.pieni) call prror(96)
        corr(2,1)=coefv2/det1
        corr(2,2)=(-one*coefh2)/det1                                     !hr05
        corr(3,1)=(-one*coefv1)/det1                                     !hr05
        corr(3,2)=coefh1/det1
      endif
 470  continue
#ifdef DEBUG
!     call wda('a470   ',0d0,2,0,0,0)
!     if (umcalls.eq.8) then
!       call dumpda('a470   ',0,0)
!     call abend('a470                                              ')
!     endif
#endif

      call dadal(damap,6)
      call dadal(damapi,6)
      call dadal(damap1,6)
      call dadal(angno,1)
      call dadal(f,1)
      call dadal(aa2,6)
      call dadal(aa2r,6)
      call dadal(a1,6)
      call dadal(a1r,6)
      call dadal(xy,6)
      call dadal(h,1)
      call dadal(df,6)
!     DADAL AUTOMATIC INCLUSION
      call comt_daEnd
      return
!-----------------------------------------------------------------------
10000 format(/t5 ,'---- ENTRY ',i1,'D LINOPT ----')
10010 format(133('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f13.6,'|',   &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format('|',6x,'|',8x,'|',12x,'|','Y','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10050 format('|',6x,'|',a8,'|',12x,'|','S','|',12x,'|',f13.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10055 format('|',6x,'|',a8,'|',12x,'|','Y','|',12x,'|',f13.6,'|', f13.  &
     &7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10060 format('|',6x,'|',8x,'|',12x,'|',103('-'))
10070 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f13.6,'|', f13.&
     &7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10080 format('|',6x,'|',8x,'|',12x,'|','X','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10090 format('|',6x,'|',8x,'|',12x,'|','S','|',12x,'|',f13.6,'|', f13.7,&
     &'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10100 format('|',6x,'|',8x,'|',12x,'|','S','|',f12.7,'|',ES13.6,'|',    &
     &f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10110 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,        &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10120 format(/t10,'CO-TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE NO. '   &
     &,i7,' AT ELEMENT ',i4/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,        &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/ t10,'ELEMENT - LIST NUMBER ',i4,          &
     &' TYP NUMBER ',i4,' NAME ',a16/)
10130 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
end subroutine umlauda
!
!-----------------------------------------------------------------------
! WIRE DIFFERENTIAL ALGEBRA
+dk wireda
subroutine wireda(ix,i)
! MODEL OF STRAIGHT CURRENT WIRE
!
!     The model provides a transfer map of a straight current wire. 
!     Description:
!     1. Infinitly thin wire with arbitrary orientation.
!     2. Thin element in SixTrack (L)=0
!     3. Parameters: 
!     dx, dy: horizontal and vertical distances between wire midpoint
!     and closed orbit [mm] 
!     (parameters are given by dx and dy in WIRE block)
!     tx, ty: tilt of the wire w.r.t the closed orbit in the
!     horizontal and vertical planes (in degrees) 
!     (parameters are given by tiltx and tilty in WIRE block)
!     L - physical length of the wire element [m]
!     cur - current of the wire [Amperes]
!     embl - embedding drift (integrated length or integration interval) [m] 
!     4. The transport map is given for canonical variables (x,px...)
!
! The MAP is constructed out of the following steps:
!     1. Declaration of shifted canonical variables: 
!          rx = x+dx; ry = y+dy  in the same way as for the BEAM-BEAM element
!     2. Symplectic Rotation by the tilt angles tx, ty (in 4D space: px, rx, py, ry)
!     3. Wire kick for a longitudinally aligned wire (= kick for tx=ty=0)
!     4. Symplectic Rotation back by the tilt angles -ty, -yx (in 4D space: ...taking only PX, PY)
!--------------------------------------------------------------
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I

      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use physical_constants
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont, only : xxtr,yytr,issss,comt_daStart,comt_daEnd
      use mod_commond
      use wire
      use mod_hions
      use mod_lie_dab, only : idao,rscrri,iscrda
      implicit none
      integer ix,idaa,i
      real(kind=fPrec) NNORM_, XCLO, YCLO
      real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi
+ca commond1
      save
!-----------------------------------------------------------------------
!FOX  B D ;
#include "include/dainicom.f90"
!FOX  D V DA INT XI NORD NVAR ; D V DA INT YI NORD NVAR ;
!FOX  D V DA INT DXI NORD NVAR ; D V DA INT DYI NORD NVAR ;
!FOX  D V RE INT EMBL ; D V RE INT TX ; D V RE INT TY ;
!FOX  D V RE INT DX ; D V RE INT DY ;
!FOX  D V RE INT XCLO ; D V RE INT YCLO ;
!FOX  D V RE INT CHI ;
!FOX  D V RE INT CUR ;
!FOX  D V RE INT L ; D V RE INT ONE ; D V RE INT TWO ;
!FOX  D V RE INT C1M7 ;
!FOX  D V RE INT C1E3 ; D V RE INT C1M3 ;
!FOX  D V DA INT RTWO_ NORD NVAR ; 
!FOX  D V RE INT NNORM_ ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
call comt_daStart
!-----------------------------------------------------------------------
!-- WIRE
!     Normalization factor (in SI) NNORM = (mu0*I*e)/(4*Pi*P0)
!     e -> 1; m0/4Pi -> 1.0e-7; N -> 1.0e-7*I
!     magnetic rigidity

      CHI = (sqrt(e0**2-nucm0**2)*c1e6)/clight
      TX = wire_tiltx(ix) !tilt x [degrees] 
      TY = wire_tilty(ix) !tilt y [degrees]
      TX = TX*(pi/c180e0) ![rad]
      TY = TY*(pi/c180e0) ![rad]
      DX = wire_dispx(ix) !displacement x [mm]
      DY = wire_dispy(ix) !displacement y [mm]
      EMBL = wire_lint(ix) !integrated length [m]
      L = wire_lphys(ix) !physical length [m]
      CUR = wire_current(ix)
      XCLO = wire_clo(1,wire_num(i))
      YCLO = wire_clo(2,wire_num(i))
      NNORM_=c1m7/chi

      if (abs(wire_flagco(ix)).ne.1) then
        write(lout,                                                     &
     &fmt='((A,A,/),(A,I0,A,A,/),(A,I0,A,I0,/))')                       &
     &'ERROR: in wirekick -  wire_flagco defined in WIRE block must ',  &
     &'be either 1 or -1!','bez(',ix,') = ',bez(ix),                    &
     &'wire_flagco(',ix,') = ',wire_flagco(ix)
        call prror(-1)
      endif

!FOX  YY(1)=YY(1)*C1M3;
!FOX  YY(2)=YY(2)*C1M3;

!!FOX  DXI=DX*C1M3;
!!FOX  DYI=DY*C1M3;
      IF (wire_flagco(ix).eq.1) THEN
!FOX  DXI=(DX+XCLO)*C1M3;
!FOX  DYI=(DY+YCLO)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
!FOX  DXI=DX*C1M3;
!FOX  DYI=DY*C1M3;
      END IF



!-----------------------------------------------------------------------
! X' -> PX'; Y' -> PY
!FOX  YY(1)=YY(1)*(ONE+DPDA)/MTCDA ;
!FOX  YY(2)=YY(2)*(ONE+DPDA)/MTCDA ;

! 1 SHIFT - see the part of the code were wireda is called ....

      IF (wire_flagco(ix).eq.1) THEN
!FOX  XI=(XX(1)+DX)*C1M3;
!FOX  YI=(XX(2)+DY)*C1M3;
      ELSE IF (wire_flagco(ix).eq.-1) THEN
!FOX  XI=(XX(1)+(DX-XCLO))*C1M3;
!FOX  YI=(XX(2)+(DY-YCLO))*C1M3;
      END IF

! ibeco = 0
      if(ibeco.eq.0) then
! 2 symplectic rotation of coordinate system (tx, ty)
!FOX  YI=YI-((XI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

!FOX  XI=XI-((YI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
!FOX  RTWO_=XI*XI+YI*YI;
!FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;

! ibeco =1
      elseif(ibeco.eq.1) then

!FOX  DYI=DYI-((DXI*SIN(TX))*YY(2))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  DXI=DXI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YI=YI-XI*SIN(TX)*YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(2)*YY(2))/COS(ATAN(YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;
!FOX  XI=XI*(COS(TX)-SIN(TX)*TAN(ATAN(YY(1)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX)) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TX) ;

!FOX  DXI=DXI-((DYI*SIN(TY))*YY(1))/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  DYI=DYI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  XI=XI-YI*SIN(TY)*YY(1)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1))/COS(ATAN(YY(2)/SQRT((ONE+DPDA)*(ONE+DPDA)-
!FOX  YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;
!FOX  YI=YI*(COS(TY)-SIN(TY)*TAN(ATAN(YY(2)/SQRT((ONE+DPDA)*
!FOX  (ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY)) ;
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))-TY) ;

! 3 apply wire kick
!FOX  RTWO_=XI*XI+YI*YI;
!FOX  YY(1)=YY(1)-(((CUR*NNORM_)*XI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)-(((CUR*NNORM_)*YI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
! subtract closed orbit kick
! wire kick is negative px -> px - wirekick - (-closed orbit kick)
!FOX  RTWO_=DXI*DXI+DYI*DYI;
!FOX  YY(1)=YY(1)+(((CUR*NNORM_)*DXI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
!FOX  YY(2)=YY(2)+(((CUR*NNORM_)*DYI)
!FOX  *(SQRT((EMBL+L)*(EMBL+L)+TWO*TWO*RTWO_)
!FOX  -SQRT((EMBL-L)*(EMBL-L)+TWO*TWO*RTWO_)) )/RTWO_;
      endif

! 4 symplectic backward rotation of coordinate system (-ty, -tx)
!FOX  YY(2)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1))*SIN(ATAN(YY(2)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TY) ;
!FOX  YY(1)=SQRT((ONE+DPDA)*(ONE+DPDA)-YY(2)*YY(2))*SIN(ATAN(YY(1)/
!FOX  SQRT((ONE+DPDA)*(ONE+DPDA)-YY(1)*YY(1)-YY(2)*YY(2)))+TX) ;

! PX -> X'; PY -> Y'
!FOX  YY(1)=YY(1)*MTCDA/(ONE+DPDA) ;
!FOX  YY(2)=YY(2)*MTCDA/(ONE+DPDA) ;

!FOX  YY(1)=YY(1)*C1E3;
!FOX  YY(2)=YY(2)*C1E3;

!     DADAL AUTOMATIC INCLUSION
      call comt_daEnd
end subroutine wireda

+dk synoda
      subroutine synoda
!-----------------------------------------------------------------------
!  SYNCHROTRON OSCILLATIONS
!        SPECIALLY PREPARED FOR NEW D.A.
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_common
      use mod_commonmn, only : e0f
      use mod_commons
      use mod_commont
      use mod_commond
      use mod_hions
      use mod_lie_dab, only : idao,iscrri,rscrri,iscrda
      implicit none
      integer ix,idaa
+ca commond1
      save
!-----------------------------------------------------------------------
!FOX  B D ;
#include "include/dainicom.f90"
!FOX  D V RE INT E0 ; D V RE EXT E0F ;
!FOX  D V RE INT HSY 3 ; D V RE INT PHAS ;
!FOX  D V RE EXT ED NELE ; D V RE EXT HSYC NELE ;
!FOX  D V RE EXT PHASC NELE ;  D V RE INT NUCMDA ; 
!FOX  D V RE INT C1E3 ; D V RE INT ONE ;
!FOX  D V IN EXT ITIONC NELE ; D V IN INT ITION ; D V IN INT IX ;
!FOX  E D ; D V RE INT NUCM0 ; D V RE INT MTCDA ; D V RE INT ZZ0 ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      ix=ixcav

      if(kz(ix).eq.12) then
!FOX  EJ1=EJ1+ED(IX)*ZZ0*SIN(HSYC(IX)*SIGMDA/C1E3*
!FOX  ITIONC(IX)+PHASC(IX)) ;
      else
!FOX  EJ1=EJ1+HSY(1)*ZZ0*SIN(HSY(3)*SIGMDA/C1E3*ITION+PHAS) ;
      endif
!FOX  EJF1=SQRT(EJ1*EJ1-NUCMDA*NUCMDA) ;
!FOX  DPDA1=(EJF1-E0F)/E0F*C1E3 ;

      return
      end

+dk errff
      subroutine errff(xx,yy,wx,wy)
!----------------------------------------------------------------------*
! PURPOSE:                                                             *
!   MODIFICATION OF WWERF, DOUBLE PRECISION COMPLEX ERROR FUNCTION,    *
!   WRITTEN AT CERN BY K. KOELBIG.                                     *
!   TAKEN FROM MAD8                                                    *
!   VERSION FOR MAP PRODUCTION USING BERZ'S DA PACKAGE                 *
! INPUT:                                                               *
!   XX, YY    (REAL)    ARGUMENT TO CERF.                              *
! OUTPUT:                                                              *
!   WX, WY    (REAL)    FUNCTION RESULT.                               *
!----------------------------------------------------------------------*
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont, only : xxtr,yytr,issss,comt_daStart,comt_daEnd
      use mod_commond
      use mod_lie_dab, only : idao,iscrri,rscrri,iscrda
      implicit none
      integer n,n1,nc,nuu,nuu1,idaa
      real(kind=fPrec) dare,dum
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT XX NORD NVAR ; D V DA EXT YY NORD NVAR ;
!FOX  D V DA EXT WX NORD NVAR ; D V DA EXT WY NORD NVAR ;
!FOX  D V DA INT X NORD NVAR ; D V DA INT Y NORD NVAR ;
!FOX  D V DA INT Q NORD NVAR ; D V DA INT H NORD NVAR ;
!FOX  D V DA INT XH NORD NVAR ; D V DA INT YH NORD NVAR ;
!FOX  D V DA INT RX NORD NVAR 33 ; D V DA INT RY NORD NVAR 33 ;
!FOX  D V DA INT TX NORD NVAR ; D V DA INT TN NORD NVAR ;
!FOX  D V DA INT TY NORD NVAR ;D V DA INT SAUX NORD NVAR ;
!FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
!FOX  D V DA INT XL NORD NVAR ;
!FOX  D V RE INT XLIM ; D V RE INT YLIM ; D V RE INT TWO ;
!FOX  D V RE INT ONE ; D V RE INT ZERO ; D V RE INT HALF ;
!FOX  D V RE INT CC ; D V RE INT DUM ;
!FOX  D V IN INT NC ; D V IN INT N ; D V IN INT N1 ; D V IN INT NUU ;
!FOX  D V IN INT NUU1 ; D V IN INT NCC ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
call comt_daStart
!-----------------------------------------------------------------------
!FOX  X=XX ;
!FOX  Y=YY ;
      if(dare(x).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(x) < 0'
!FOX    X=-X ;
      endif
      if(dare(y).lt.zero) then
        write(lout,*)                                                   &
     &' Problem in DA complex error function: dare(y) < 0'
!FOX    Y=-Y ;
      endif
      if(dare(y).lt.ylim.and.dare(x).lt.xlim) then
!FOX    Q=(ONE-Y/YLIM)*SQRT(ONE-X*X/XLIM/XLIM) ;
!FOX    DUM=3.2D0 ;
!FOX    H=ONE/(DUM*Q) ;
        nc=7+int(23.0_fPrec*dare(q))
!FOX    XL=EXP((1-NC)*LOG(H)) ;
!FOX    XH=Y+HALF/H ;
!FOX    YH=X ;
        nuu=10+int(21.0_fPrec*dare(q))
        nuu1=nuu+1
!FOX    RX(NUU1)=ZERO ;
!FOX    RY(NUU1)=ZERO ;
        do 10 n=nuu,1,-1
          n1=n+1
!FOX      TX=XH+N*RX(N1) ;
!FOX      TY=YH-N*RY(N1) ;
!FOX      TN=TX*TX+TY*TY ;
!FOX      RX(N)=HALF*TX/TN ;
!FOX      RY(N)=HALF*TY/TN ;
   10   continue
!FOX    SX=ZERO ;
!FOX    SY=ZERO ;
        do 20 n=nc,1,-1
!FOX      SAUX=SX+XL ;
!FOX      SX=RX(N)*SAUX-RY(N)*SY ;
!FOX      SY=RX(N)*SY+RY(N)*SAUX ;
!FOX      XL=H*XL ;
   20   continue
!FOX    WX=CC*SX ;
!FOX    WY=CC*SY ;
      else
!FOX    XH=Y ;
!FOX    YH=X ;
!FOX    RX(1)=ZERO ;
!FOX    RY(1)=ZERO ;
        do 30 n=9,1,-1
!FOX      TX=XH+N*RX(1) ;
!FOX      TY=YH-N*RY(1) ;
!FOX      TN=TX*TX+TY*TY ;
!FOX      RX(1)=HALF*TX/TN ;
!FOX      RY(1)=HALF*TY/TN ;
   30   continue
!FOX    WX=CC*RX(1) ;
!FOX    WY=CC*RY(1) ;
      endif
!      if(dare(y).eq.0.) then
!!FOX    WX=EXP(-X*X) ;
!      endif
      if(dare(yy).lt.0.d0) then                                          !hr05
!FOX    WX=TWO*EXP(Y*Y-X*X)*COS(TWO*X*Y)-WX ;
!FOX    WY=-TWO*EXP(Y*Y-X*X)*SIN(TWO*X*Y)-WY ;
        if(dare(xx).gt.0.d0) then                                        !hr05
!FOX      WY=-WY ;
        endif
      else
        if(dare(xx).lt.0.d0) then                                        !hr05
!FOX      WY=-WY ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      call comt_daEnd
      return
      end

+dk beam6df
subroutine beaminf(track,param,sigzs,bcu,ibb,ne,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999         
!
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use mod_commond
      use crcoall
      use parpro
      use parbeam, only : beam_expflag,beam_expfile_open
      use mod_lie_dab, only : idao
      implicit none
      integer ibb,ibbc,ne,nsli,idaa
      real(kind=fPrec) alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,sphi,star,tphi,phi2,cphi2,sphi2,tphi2
      dimension param(nele,18),bcu(nbb,12),star(3,mbea)
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         !sepax=param(ne,5)     !Not actually used anywhere?
         !sepay=param(ne,6)     !Not actually used anywhere?
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beaminf"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif
      sphi=sin_mb(phi)
      sphi2=sin_mb(phi2)
      cphi=cos_mb(phi)
      cphi2=cos_mb(phi2)
      tphi=tan_mb(phi)
      tphi2=tan_mb(phi2)
      salpha=sin_mb(alpha)
      calpha=cos_mb(alpha)
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boostf(sphi,cphi,tphi,salpha,calpha,track)
      call sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
      call boostif(sphi,cphi,tphi,salpha,calpha,track)
!     DADAL AUTOMATIC INCLUSION
      return
end subroutine beaminf

      subroutine boostf(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
! BOOSTF Boost Operation *******************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_commond
      use mod_lie_dab, only : idao,rscrri,iscrda
      implicit none
      integer idaa
      real(kind=fPrec) calpha,cphi,salpha,sphi,tphi,cphi2,sphi2,tphi2
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A NORD NVAR ;
!FOX  D V DA INT H NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
!FOX  D V DA INT A1 NORD NVAR ; D V DA INT HD1 NORD NVAR ;
!FOX  D V DA INT H1X NORD NVAR ; D V DA INT H1Y NORD NVAR ;
!FOX  D V DA INT H1Z NORD NVAR ; D V DA INT X1 NORD NVAR ;
!FOX  D V DA INT Y1 NORD NVAR ;
!FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
!FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
!FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
!FOX  D V RE INT ONE ; D V RE INT C1E3 ;
!FOX  D V DA INT DET NORD NVAR ; D V DA INT H1 NORD NVAR ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX    H=TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
!FOX    TRACK(6)=TRACK(6)-CALPHA*TPHI*TRACK(2)
!FOX              -TRACK(4)*SALPHA*TPHI+H*TPHI*TPHI ;
!FOX    TRACK(2)=(TRACK(2)-TPHI*H*CALPHA)/CPHI ;
!FOX    TRACK(4)=(TRACK(4)-TPHI*H*SALPHA)/CPHI ;
!FOX    HD1=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-TRACK(2)*TRACK(2)-
!FOX    TRACK(4)*TRACK(4)) ;
!FOX    H1X=TRACK(2)/HD1 ;
!FOX    H1Y=TRACK(4)/HD1 ;
!FOX    H1Z=ONE-(ONE+TRACK(6))/HD1 ;
!FOX    X1=CALPHA*TPHI*TRACK(5)+(ONE+CALPHA*SPHI*H1X)*TRACK(1)
!FOX       +TRACK(3)*SALPHA*SPHI*H1X ;
!FOX    Y1=SALPHA*TPHI*TRACK(5)+(ONE+SALPHA*SPHI*H1Y)*TRACK(3)
!FOX       +TRACK(1)*CALPHA*SPHI*H1Y ;
!FOX    TRACK(5)=TRACK(5)/CPHI+H1Z*(SPHI*CALPHA*TRACK(1)
!FOX       +SPHI*SALPHA*TRACK(3)) ;
!FOX    TRACK(1)=X1 ;
!FOX    TRACK(3)=Y1 ;
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine sbcf(star,cphi,cphi2,nsli,f,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**SBCF ***Synchro-Beam for headon collision*********************
!****************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_commond
      use mod_lie_dab, only : idao,rscrri,iscrda
      implicit none
      integer ibb,ibbc,ibbc1,jsli,nsli,idaa
      real(kind=fPrec) bcu,cphi,cphi2,dare,f,sfac,star
      dimension star(3,mbea),bcu(nbb,12)
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ;
!FOX  D V DA INT S NORD NVAR ; D V DA INT SP NORD NVAR ;
!FOX  D V DA INT DD NORD NVAR ;
!FOX  D V DA INT DUM NORD NVAR 13 ;
!FOX  D V DA INT SX NORD NVAR ; D V DA INT SY NORD NVAR ;
!FOX  D V DA INT SEPX NORD NVAR ; D V DA INT SEPY NORD NVAR ;
!FOX  D V DA INT SEPX0 NORD NVAR ; D V DA INT SEPY0 NORD NVAR ;
!FOX  D V DA INT COSTH NORD NVAR ; D V DA INT SINTH NORD NVAR ;
!FOX  D V DA INT COSTHP NORD NVAR ; D V DA INT SINTHP NORD NVAR ;
!FOX  D V DA INT BBFX NORD NVAR ; D V DA INT BBFY NORD NVAR ;
!FOX  D V DA INT BBF0 NORD NVAR ; D V DA INT BBGX NORD NVAR ;
!FOX  D V DA INT BBGY NORD NVAR ;
!FOX  D V RE EXT STAR 3 MBEA ; D V RE EXT F ; D V RE EXT BCU NBB 12 ;
!FOX  D V IN EXT IBB ;
!FOX  D V RE INT HALF ; D V RE INT TWO ; D V RE INT FOUR ;
!FOX  D V RE INT ZERO ; D V RE INT ONE ; D V RE INT C1E3 ;
!FOX  D V RE INT SFAC ; D V RE INT CPHI ; D V RE INT CPHI2 ;
!FOX  D V IN INT JSLI ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
!FOX    S=(TRACK(5)-STAR(3,JSLI))*HALF ;
!FOX    SP=S/CPHI2 ;
!FOX    DUM(1)=BCU(IBB,1)+TWO*BCU(IBB,4)*SP+BCU(IBB,6)*SP*SP ;
!FOX    DUM(2)=BCU(IBB,2)+TWO*BCU(IBB,9)*SP+BCU(IBB,10)*SP*SP ;
!FOX    DUM(3)=BCU(IBB,3)+(BCU(IBB,5)+BCU(IBB,7))*SP+
!FOX    BCU(IBB,8)*SP*SP ;
!FOX    DUM(4)=DUM(1)-DUM(2) ;
!FOX    DUM(5)=DUM(4)*DUM(4)+FOUR*DUM(3)*DUM(3) ;
        if(ibbc.eq.1.and.(abs(dare(dum(4))).gt.pieni.and.               &
     &abs(dare(dum(5))).gt.pieni)) then
          ibbc1=1
!FOX    DUM(5)=SQRT(DUM(5)) ;
        else
          ibbc1=0
        endif
!FOX    SEPX0=TRACK(1)+TRACK(2)*S-STAR(1,JSLI) ;
!FOX    SEPY0=TRACK(3)+TRACK(4)*S-STAR(2,JSLI) ;
        if(ibbc1.eq.1) then
          sfac=one
          if(dare(dum(4)).lt.zero) sfac=(-one*one)                       !hr05
!FOX    DUM(6)=SFAC*DUM(4)/DUM(5) ;
!FOX    DUM(7)=DUM(1)+DUM(2) ;
!FOX    COSTH=HALF*(ONE+DUM(6)) ;
          if(abs(dare(costh)).gt.pieni) then
!FOX    COSTH=SQRT(COSTH) ;
          else
!FOX    COSTH=ZERO ;
          endif
!FOX    SINTH=HALF*(ONE-DUM(6)) ;
          if(abs(dare(sinth)).gt.pieni) then
!FOX    SINTH=SFAC*SQRT(SINTH) ;
          else
!FOX    SINTH=ZERO ;
          endif
          if(dare(dum(3)).lt.zero) then
!FOX    SINTH=-SINTH ;
          endif
!FOX    SY=SFAC*DUM(5) ;
!FOX    SX=(DUM(7)+SY)*HALF ;
!FOX    SY=(DUM(7)-SY)*HALF ;
!FOX    SEPX=SEPX0*COSTH+SEPY0*SINTH ;
!FOX    SEPY=-SEPX0*SINTH+SEPY0*COSTH ;
        else
!FOX    SX=DUM(1) ;
!FOX    SY=DUM(2) ;
!FOX    SEPX=SEPX0 ;
!FOX    SEPY=SEPY0 ;
        endif
        if(dare(sx).gt.dare(sy)) then
          call bbff(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy)
        else
          call bbff(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx)
        endif
!FOX    BBFX=F*BBFX ;
!FOX    BBFY=F*BBFY ;
!FOX    BBGX=F*BBGX ;
!FOX    BBGY=F*BBGY ;
        if(ibbc1.eq.1) then
!FOX    DUM(8)=TWO*(BCU(IBB,4)-BCU(IBB,9)+(BCU(IBB,6)-BCU(IBB,10))*SP) ;
!FOX    DUM(9)=BCU(IBB,5)+BCU(IBB,7)+TWO*BCU(IBB,8)*SP ;
!FOX    DUM(10)=(DUM(4)*DUM(8)+FOUR*DUM(3)*DUM(9))/
!FOX    DUM(5)/DUM(5)/DUM(5) ;
!FOX    DUM(11)=SFAC*(DUM(8)/DUM(5)-DUM(4)*DUM(10)) ;
!FOX    DUM(12)=BCU(IBB,4)+BCU(IBB,9)+(BCU(IBB,6)+BCU(IBB,10))*SP ;
!FOX    DUM(13)=SFAC*(DUM(4)*DUM(8)*HALF+TWO*DUM(3)*DUM(9))/DUM(5) ;
          if(abs(dare(costh)).gt.pieni) then
!FOX    COSTHP=DUM(11)/FOUR/COSTH ;
          else
!FOX    COSTHP=ZERO ;
          endif
          if(abs(dare(sinth)).gt.pieni) then
!FOX    SINTHP=-DUM(11)/FOUR/SINTH ;
          else
!FOX    SINTHP=ZERO ;
          endif
!FOX    TRACK(6)=TRACK(6)-
!FOX    (BBFX*(COSTHP*SEPX0+SINTHP*SEPY0)+
!FOX    BBFY*(-SINTHP*SEPX0+COSTHP*SEPY0)+
!FOX    BBGX*(DUM(12)+DUM(13))+BBGY*(DUM(12)-DUM(13)))/
!FOX    CPHI*HALF ;
!FOX    BBF0=BBFX ;
!FOX    BBFX=BBF0*COSTH-BBFY*SINTH ;
!FOX    BBFY=BBF0*SINTH+BBFY*COSTH ;
        else
!FOX    TRACK(6)=TRACK(6)-
!FOX    (BBGX*(BCU(IBB,4)+BCU(IBB,6)*SP)+
!FOX    BBGY*(BCU(IBB,9)+BCU(IBB,10)*SP))/CPHI ;
        endif
!FOX    TRACK(6)=TRACK(6)-(BBFX*(TRACK(2)-BBFX*HALF)+
!FOX    BBFY*(TRACK(4)-BBFY*HALF))*HALF ;
!FOX    TRACK(1)=TRACK(1)+S*BBFX ;
!FOX    TRACK(2)=TRACK(2)-BBFX ;
!FOX    TRACK(3)=TRACK(3)+S*BBFY ;
!FOX    TRACK(4)=TRACK(4)-BBFY ;
 2000 continue
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine boostif(sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
! BOOSTIF **************inverse boost ****************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_commond
      use mod_lie_dab, only : idao,rscrri,iscrda
      implicit none
      integer idaa
      real(kind=fPrec) calpha,cphi,salpha,sphi,tphi
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT TRACK NORD NVAR 6 ; D V DA INT A1 NORD NVAR ;
!FOX  D V DA INT H1 NORD NVAR ; D V DA INT SQR1A NORD NVAR ;
!FOX  D V DA INT H1D NORD NVAR ; D V DA INT H1X NORD NVAR ;
!FOX  D V DA INT H1Y NORD NVAR ; D V DA INT H1Z NORD NVAR ;
!FOX  D V DA INT DET NORD NVAR ; D V DA INT X1 NORD NVAR ;
!FOX  D V DA INT Y1 NORD NVAR ; D V DA INT Z1 NORD NVAR ;
!FOX  D V RE INT ONE ; D V RE INT TWO ;
!FOX  D V RE EXT SPHI ; D V RE EXT CPHI ; D V RE EXT TPHI ;
!FOX  D V RE EXT SPHI2 ; D V RE EXT CPHI2 ; D V RE EXT TPHI2 ;
!FOX  D V RE EXT SALPHA ; D V RE EXT CALPHA ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
!FOX    H1D=SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)) ;
!FOX    H1X=TRACK(2)/H1D ;
!FOX    H1Y=TRACK(4)/H1D ;
!FOX    H1Z=ONE-(ONE+TRACK(6))/H1D ;
!FOX    H1=(TRACK(6)+ONE-SQRT((ONE+TRACK(6))*(ONE+TRACK(6))-
!FOX    TRACK(2)*TRACK(2)-TRACK(4)*TRACK(4)))*CPHI*CPHI ;
!FOX    DET=ONE/CPHI+TPHI*(H1X*CALPHA+H1Y*SALPHA-H1Z*SPHI) ;
!FOX    X1= TRACK(1)*(ONE/CPHI+SALPHA*(H1Y-H1Z*SALPHA*SPHI)*TPHI)
!FOX       +TRACK(3)*SALPHA*TPHI*(-H1X+H1Z*CALPHA*SPHI)
!FOX       -TRACK(5)*(CALPHA+H1Y*CALPHA*SALPHA*SPHI
!FOX       -H1X*SALPHA*SALPHA*SPHI)*TPHI ;
!FOX    Y1= TRACK(1)*CALPHA*TPHI*(-H1Y+H1Z*SALPHA*SPHI)
!FOX       +TRACK(3)*(ONE/CPHI+CALPHA*(H1X-H1Z*CALPHA*SPHI)*TPHI)
!FOX       -TRACK(5)*(SALPHA-H1Y*CALPHA*CALPHA*SPHI
!FOX       +H1X*CALPHA*SALPHA*SPHI)*TPHI ;
!FOX    Z1=-TRACK(1)*H1Z*CALPHA*SPHI
!FOX       -TRACK(3)*H1Z*SALPHA*SPHI
!FOX       +TRACK(5)*(ONE+H1X*CALPHA*SPHI+H1Y*SALPHA*SPHI) ;
!FOX    TRACK(1)=X1/DET ;
!FOX    TRACK(3)=Y1/DET ;
!FOX    TRACK(5)=Z1/DET ;
!FOX    TRACK(6)=TRACK(6)+CALPHA*SPHI*TRACK(2)
!FOX            +SALPHA*SPHI*TRACK(4) ;
!FOX    TRACK(2)=(TRACK(2)*CPHI+CALPHA*TPHI*H1) ;
!FOX    TRACK(4)=(TRACK(4)*CPHI+SALPHA*TPHI*H1) ;
!     DADAL AUTOMATIC INCLUSION
      return
      end

      subroutine bbff(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   DA VERSION for SIXTRACK courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**********************************************************************
! BBFF gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_commond
      use mod_ranecu
      use mod_lie_dab, only : idao,rscrri,iscrda

      implicit none
      integer idaa
      real(kind=fPrec) dare,hundred,sqrpi2
      parameter(sqrpi2 = 3.544907701811032_fPrec,hundred = c1e2)
      save
!-----------------------------------------------------------------------
!FOX  B D ;
!FOX  D V DA EXT SEPX NORD NVAR ; D V DA EXT SEPY NORD NVAR ;
!FOX  D V DA EXT SIGXX NORD NVAR ; D V DA EXT SIGYY NORD NVAR ;
!FOX  D V DA EXT BBFX NORD NVAR ; D V DA EXT BBFY NORD NVAR ;
!FOX  D V DA EXT BBGX NORD NVAR ; D V DA EXT BBGY NORD NVAR ;
!FOX  D V DA INT SIGXY NORD NVAR ; D V DA INT EXPFAC NORD NVAR ;
!FOX  D V DA INT X NORD NVAR ; D V DA INT FAC NORD NVAR ;
!FOX  D V DA INT FAC2 NORD NVAR ; D V DA INT CONST NORD NVAR ;
!FOX  D V DA INT ARG1X NORD NVAR ; D V DA INT ARG1Y NORD NVAR ;
!FOX  D V DA INT ARG2X NORD NVAR ; D V DA INT ARG2Y NORD NVAR ;
!FOX  D V DA INT WX1 NORD NVAR ; D V DA INT WY1 NORD NVAR ;
!FOX  D V DA INT WX2 NORD NVAR ; D V DA INT WY2 NORD NVAR ;
!FOX  D V DA INT COMFAC NORD NVAR ; D V DA INT COMFAC2 NORD NVAR ;
!FOX  D V RE INT ZERO ; D V RE INT HALF ; D V RE INT ONE ;
!FOX  D V RE INT TWO ; D V RE INT FOUR ; D V RE INT HUNDRED ;
!FOX  D V RE INT SQRPI2 ;
!FOX  D F RE DARE 1 ;
!FOX  E D ;
!FOX  1 if(1.eq.1) then
!-----------------------------------------------------------------------
      if(dare(sigxx).eq.dare(sigyy)) then
!FOX    X=SEPX*SEPX+SEPY*SEPY ;
        if(abs(dare(sigxx)+dare(sigyy)).gt.pieni) then
!FOX      CONST=X/(SIGXX+SIGYY) ;
        else
!FOX      CONST=ZERO ;
        endif
!FOX    EXPFAC=EXP(-CONST) ;
        if(abs(dare(x)).gt.pieni) then
!FOX      BBFX=TWO*SEPX*(ONE-EXPFAC)/X ;
!FOX      BBFY=TWO*SEPY*(ONE-EXPFAC)/X ;
!FOX      COMFAC=-SEPX*BBFX+SEPY*BBFY ;
          if(dare(sigxx).lt.zero) then
!FOX        SIGXX=-SIGXX ;
          endif
          if(dare(sigyy).lt.zero) then
!FOX        SIGYY=-SIGYY ;
          endif
!FOX      COMFAC2=(SIGXX+SIGYY)*(SIGXX+SIGYY) ;
!FOX      BBGX=(COMFAC+FOUR*SEPX*SEPX*CONST/X*EXPFAC)/(TWO*X) ;
!FOX      BBGY=(-COMFAC+FOUR*SEPY*SEPY*CONST/X*EXPFAC)/(TWO*X) ;
        else
!FOX      BBFX=ZERO ;
!FOX      BBFY=ZERO ;
!FOX      BBGX=ZERO ;
!FOX      BBGY=ZERO ;
        endif
      else
!FOX    X=SEPX*SEPX/SIGXX+SEPY*SEPY/SIGYY ;
!FOX    FAC2=TWO*(SIGXX-SIGYY) ;
        if(dare(sigxx).lt.dare(sigyy)) then
!FOX      FAC2=TWO*(SIGYY-SIGXX) ;
        endif
!FOX    FAC=SQRT(FAC2) ;
!FOX    CONST=SQRPI2/FAC ;
!FOX    SIGXY=SQRT(SIGXX/SIGYY) ;
!FOX    ARG1X=(SEPX/FAC) ;
        if(dare(sepx).lt.zero) then
!FOX      ARG1X=-(SEPX/FAC) ;
        endif
!FOX    ARG1Y=(SEPY/FAC) ;
        if(dare(sepy).lt.zero) then
!FOX      ARG1Y=-(SEPY/FAC) ;
        endif
        call errff(arg1x,arg1y,wy1,wx1)
        if(dare(x).lt.hundred) then
!FOX      EXPFAC=EXP(-X*HALF) ;
!FOX      ARG2X=ARG1X/SIGXY ;
!FOX      ARG2Y=ARG1Y*SIGXY ;
          call errff(arg2x,arg2y,wy2,wx2)
!FOX      BBFX=CONST*(WX1-EXPFAC*WX2) ;
!FOX      BBFY=CONST*(WY1-EXPFAC*WY2) ;
          if(dare(sepx).lt.zero) then
!FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
!FOX        BBFY=-BBFY ;
          endif
!FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
!FOX      BBGX=-(COMFAC+TWO*(EXPFAC/SIGXY-ONE))/FAC2 ;
!FOX      BBGY= (COMFAC+TWO*(EXPFAC*SIGXY-ONE))/FAC2 ;
        else
!FOX      BBFX=CONST*WX1 ;
!FOX      BBFY=CONST*WY1 ;
          if(dare(sepx).lt.zero) then
!FOX        BBFX=-BBFX ;
          endif
          if(dare(sepy).lt.zero) then
!FOX        BBFY=-BBFY ;
          endif
!FOX      COMFAC=SEPX*BBFX+SEPY*BBFY ;
!FOX      BBGX=-(COMFAC-TWO)/FAC2 ;
!FOX      BBGY= -BBGX ;
        endif
      endif
!     DADAL AUTOMATIC INCLUSION
      return
      end

+dk maincr
program maincr
  
  use floatPrecision
  use end_sixtrack
  use file_units
  use string_tools
  use mathlib_bouncer
  use physical_constants
  use numerical_constants
  
  use scatter, only : scatter_active, scatter_initialise
  use dynk,    only : dynk_izuIndex
  use fma,     only : fma_postpr, fma_flag
  use dump,    only : dump_initialise, dumpclo,dumptas,dumptasinv
  use zipf,    only : zipf_numfiles, zipf_dozip
  
  use, intrinsic :: iso_fortran_env, only : output_unit
  use mod_units
  use aperture
  use mod_ranecu
  use postprocessing, only : postpr, writebin_header, writebin

#ifdef FLUKA
  use mod_fluka
#endif
#ifdef HDF5
  use hdf5_output
#endif
#ifdef ROOT
  use root_output
#endif

  use crcoall
  use parpro
  use parpro_scale
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  
  use mod_hions
  use mod_dist
  use matrix_inv
  use aperture
  use wire
  
  implicit none
  
interface
  
  subroutine envarsv(dpsv,oidpsv,rvv,ekv)
      
    use floatPrecision
    use parpro
    use parpro_scale
    use mod_commond
    
    implicit none

    real(kind=fPrec) :: dpsv(npart)
    real(kind=fPrec) :: oidpsv(npart)
    real(kind=fPrec) :: rvv(npart)
    real(kind=fPrec), allocatable, intent(inout) :: ekv(:,:) 
  end subroutine envarsv
  
end interface

!-----------------------------------------------------------------------
!
!  SIXTRACK
!
!  SIXDIMENSIONAL PARTICLE-TRACKING
!
!-----------------------------------------------------------------------
!
!  F. SCHMIDT, M. VANTTINEN
!
!  COLLIMATION VERSION, NOVEMBER 2004
!
!  G. ROBERT-DEMOLAIZE
!
!  COLLIMATION UPGRADE, JUNE 2005
!
!  G. ROBERT-DEMOLAIZE, S. REDAELLI
!
!  UPGRADED FOR COUPLING TO FLUKA, JULY 2013
!
!  A. MEREGHETTI, D. SINUELA PASTOR
!
!  FURTHER UPGRADE FOR COUPLING TO FLUKA, MAY-JUNE 2014
!
!  A. MEREGHETTI, P. GARCIA ORTEGA
!
!-----------------------------------------------------------------------
!  SIXTRACR CHECKPOINT/RESTART and CRLIBM (ENS Lyon)
!
!  E. MCINTOSH FEBRUARY 2005
!-----------------------------------------------------------------------
!  USED DISKS:
!
!  GEOMETRY AND STRENGTH OF THE ACCELERATOR : UNIT  2
!  TRACKING PARAMETER                       : UNIT  3
!  NORMAL PRINTOUT                          : UNIT  6
!  TRACKING DATA                            : UNIT  8
!  DATA FOR SUMMARY OF THE POSTPROCESSING   : UNIT 10
!  AUXILIARY FILE FOR THE INPUT             : UNIT 11
!  ASCII FILE WITH THE HORIZONTAL FFT DATA  : UNIT 14
!  ASCII FILE WITH THE VERTICAL FFT DATA    : UNIT 15
!  METAFILE FOR PLOTTING WITH GKS           : UNIT 20
!
#ifdef CR
!  CHECKPOINT/RESTART FILES                 : UNIT 95,96
!  OPTIONAL DUMP.DEBUG FILE                 : UNIT 99
!  PROGRESS FILE                            : UNIT 91
!  INTERMEDIATE OUTPUT FILE (LOUT)          : UNIT 92
!  CHECKPOINT/RESTART LOGFILE               : UNIT 93
!  TEMPORARY SCRATCH FILE for C/R           : UNIT 94
#endif
!-----------------------------------------------------------------------
! Eric needs nwri (clean up new variables and common blocks!)
#ifdef CR
+ca crco
#endif

  integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,  &
    idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
    jm,k,kpz,kzz,l,lkk,ll,m,mkk,ncorruo,ncrr,nd,nd2,ndafi2,           &
    nerror,nlino,nlinoo,nmz,nthinerr
  real(kind=fPrec) alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,  &
    amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
    dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
    gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
    rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
    tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
    taus,x11,x13
  integer idummy(6)
  logical isOpen
  character(len=10) cmonth
  character(len=4) cpto
  character(len=7) tmpFile
#ifdef CR
  character(len=80) day
#else
  character(len=80) day,runtim
#endif
  character(len=8) cdate,ctime,progrm !Note: Keep in sync with writebin_header and more
                                      !DANGER: If the len changes, CRCHECK will break.
#ifdef BOINC
  character(len=256) filename
#endif
#ifdef CRLIBM
  integer nchars
  parameter (nchars=160)
  character(len=nchars) ch
  character(len=nchars+nchars) ch1
  ! MAXF be kept in sync with value in function fround
  integer maxf,nofields
  parameter (maxf=30)
  parameter (nofields=41)
  character(len=maxf) fields(nofields)
  integer errno,nfields,nunit,lineno,nf
  real(kind=fPrec) fround
  real(kind=fPrec) round_near
  data lineno /0/
#endif
#ifdef DEBUG
!  integer umcalls,dapcalls,dokcalls,dumpl
!  common /mycalls/ umcalls,dapcalls,dokcalls,dumpl
#endif
#ifdef FLUKA
  integer fluka_con
#endif
  logical lopen
  dimension cmonth(12)
  data (cmonth(i),i=1,12)/' January ',' February ','  March   ',    &
    '  April   ','   May    ','   June   ','   July   ',' August  ',  &
    ' September',' October  ',' November ',' December '/
#include "version.f90"
!-----------------------------------------------------------------------
  errout_status = 0         ! Set to nonzero before calling abend in case of error.
                            ! If prror is called, it will be set internally.
  lout=92
#ifndef CR
  lout=output_unit
#endif
  call allocate_arrays      ! Initial allocation of memory
#ifdef CRLIBM
! Removed the call to disable_xp for Laurent
! but re-instated it
  call disable_xp()
#endif
#ifdef DEBUG
!     umcalls=0
!     dapcalls=0
!     dokcalls=0
!     dumpl=0
#endif
! Set napx,napxo,trtime for error handling
  napx=0
  napxo=0
  trtime=0.0
  napxto=0
  runtim=''
#ifdef CR
      stxt=''
#endif
#ifdef HDF5
  call h5_initHDF5()
#endif
#ifdef BOINC
  call boinc_init()
!  call boinc_init_graphics()
#endif
#ifdef CR
! Main start for Checkpoint/Restart
      sythckcr=.false.
      numlcr=1
      rerun=.false.
      start=.true.
      restart=.false.
      checkp=.false.
      fort95=.false.
      fort96=.false.
      sixrecs=0
      binrec=0
      bnlrec=0
      bllrec=0
      do i=1,(npart+1)/2
        binrecs(i)=0
      enddo
      crtime3=0.
#ifdef DEBUG
                   !call system('../crmain  >> crlog')
#endif
#ifdef BOINC
 611  continue
#endif
!--   Very first get rid of any previous partial output
      inquire(unit=lout, opened=isOpen)
      if(isOpen) close(lout)
#ifdef BOINC
      call boincrf('fort.92',filename)
#ifdef FIO
      open(lout,file=filename,form='formatted',status='replace',round='nearest')
#else
      open(lout,file=filename,form='formatted',status='replace')
#endif
#else
#ifdef FIO
      open(lout,file='fort.92',form='formatted',status='replace',round='nearest')
#else
      open(lout,file='fort.92',form='formatted',status='replace')
#endif
#endif
!--   Now position the checkpoint/restart logfile=93
#ifdef BOINC
      call boincrf('fort.93',filename)
#ifdef FIO
      open(93,file=filename,form='formatted',status='unknown', round='nearest')
#else
      open(93,file=filename,form='formatted',status='unknown')
#endif
#else
#ifdef FIO
      open(93,file='fort.93',form='formatted',status='unknown', round='nearest')
#else
      open(93,file='fort.93',form='formatted',status='unknown')
#endif
#endif
  606 read(93,'(a1024)',end=607) arecord
      goto 606
  607 backspace (93,iostat=ierro)
! and if BOINC issue an informatory message
#ifdef BOINC
      if (start) then
        write(93,*) 'SIXTRACR starts very first time'
      else
        write(93,*) 'SIXTRACR retry after unzip of Sixin.zip'
      endif
#endif
! Now we see if we have a fort.6 which implies
! that we can perhaps just restart using all exisiting files
! including the last checkpoints
! if not, we just do a start (with an unzip for BOINC)
#ifdef BOINC
      call boincrf('fort.6',filename)
#ifdef FIO
      open(output_unit,file=filename,form='formatted',status='old',err=602,round='nearest')
#else
      open(output_unit,file=filename,form='formatted',status='old',err=602)
#endif
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
#else
#ifdef FIO
      open(output_unit,file='fort.6',form='formatted',status='old',err=602,round='nearest')
#else
      open(output_unit,file='fort.6',form='formatted',status='old',err=602)
#endif
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR reruns on: '
#endif
      rerun=.true.
      goto 605
#ifdef BOINC
  602 continue
! No fort.6 so we do an unzip of Sixin.zip
! BUT ONLY IF WE HAVE NOT DONE IT ALREADY
! and CLOSE 92 and 93
      if (start) then
        start=.false.
        close(92)
        close(93)
! Now, if BOINC, after no fort.6, call UNZIP Sixin.zip
! name hard-wired in our boinc_unzip_.
! Either it is only the fort.* input data or it is a restart.
! Removed temporarily??? because of problems.
! Re-instated and REQUIRED version 4516
        !call boinc_unzip()
        !call system('unzip Sixin.zip')
        
        call boincrf("Sixin.zip",filename)
        ! This function expects a normal, trimmed fortran string; it will do the zero-padding internally.
        call f_read_archive(trim(filename),".")
        go to 611
      endif
#ifdef FIO
      open(output_unit,file=filename,form='formatted',status='unknown',round='nearest')
#else
      open(output_unit,file=filename,form='formatted',status='unknown')
#endif
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
#else
#ifdef FIO
 602  open(output_unit,file='fort.6',form='formatted',status='new',round='nearest')
#else
 602  open(output_unit,file='fort.6',form='formatted',status='new')
#endif
!--   Set up start message depending on fort.6 or not
      stxt='SIXTRACR starts on: '
#endif
!--   Now check for restart files fort.95/96 and OPEN them
#ifdef BOINC
  605 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='old',err=600)
#else
  605 open(95,file='fort.95',form='unformatted',status='old',err=600)
#endif
      fort95=.true.
      goto 608
#ifdef BOINC
  600 call boincrf('fort.95',filename)
      open(95,file=filename,form='unformatted',status='new')
#else
  600 open(95,file='fort.95',form='unformatted',status='new')
#endif
#ifdef BOINC
  608 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='old',err=601)
#else
  608 open(96,file='fort.96',form='unformatted',status='old',err=601)
#endif
      fort96=.true.
      goto 609
#ifdef BOINC
  601 call boincrf('fort.96',filename)
      open(96,file=filename,form='unformatted',status='new')
#else
  601 open(96,file='fort.96',form='unformatted',status='new')
#endif
#ifdef BOINC
  609 call boincrf('fort.91',filename)
#ifdef FIO
      open(91,file=filename,form='formatted',status='unknown',round='nearest')
#else
      open(91,file=filename,form='formatted',status='unknown')
#endif
#else
#ifdef FIO
  609 open(91,file='fort.91',form='formatted',status='unknown',round='nearest')
#else
  609 open(91,file='fort.91',form='formatted',status='unknown')
#endif
#endif
! END +if cr -- END of Main start for Checkpoint/Restart
#else
      lout=output_unit
#endif
      
#ifdef DEBUG
                   !call system('../crmain  >> crlog')
#endif
!-----------------------------------------------------------------------
  call units_initUnits
  
  call units_openUnits(unit=2, fileName="fort.2", formatted=.true., boinc=.true.,fio=.true.) ! Should be opened in DATEN
  call units_openUnits(unit=3, fileName="fort.3", formatted=.true., boinc=.true.,fio=.true.) ! Should be opened in DATEN
  call units_openUnits(unit=4, fileName="fort.4", formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=7, fileName="fort.7", formatted=.true., boinc=.true.,fio=.true.,recl=303)
  call units_openUnits(unit=8, fileName="fort.8", formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=9, fileName="fort.9", formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=11,fileName="fort.11",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=12,fileName="fort.12",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=13,fileName="fort.13",formatted=.true., boinc=.true.,fio=.true.) ! Should only be opened when reading
  call units_openUnits(unit=14,fileName="fort.14",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=15,fileName="fort.15",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=16,fileName="fort.16",formatted=.true., boinc=.true.,fio=.true.)
! call units_openUnits(unit=17,fileName="fort.17",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  call units_openUnits(unit=18,fileName="fort.18",formatted=.true., boinc=.true.,fio=.true.)
! call units_openUnits(unit=19,fileName="fort.19",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  call units_openUnits(unit=20,fileName="fort.20",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=21,fileName="fort.21",formatted=.true., boinc=.true.,fio=.true.)
! call units_openUnits(unit=22,fileName="fort.22",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
! call units_openUnits(unit=23,fileName="fort.23",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
! call units_openUnits(unit=24,fileName="fort.24",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
! call units_openUnits(unit=25,fileName="fort.25",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
! call units_openUnits(unit=26,fileName="fort.26",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  call units_openUnits(unit=27,fileName="fort.27",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=28,fileName="fort.28",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=29,fileName="fort.29",formatted=.true., boinc=.true.,fio=.true.)
! call units_openUnits(unit=30,fileName="fort.30",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  call units_openUnits(unit=31,fileName="fort.31",formatted=.true., boinc=.true.,fio=.true.)
  call units_openUnits(unit=32,fileName="fort.32",formatted=.false.,boinc=.true.)
! call units_openUnits(unit=33,fileName="fort.33",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  call units_openUnits(unit=34,fileName="fort.34",formatted=.true., boinc=.true.,fio=.true.)
! call units_openUnits(unit=35,fileName="fort.35",formatted=.true., boinc=.true.,fio=.true.) ! Not in use?
  
#ifdef STF
  ! Open Single Track File
  call units_openUnits(unit=90,fileName="singletrackfile.dat",formatted=.false.,boinc=.true.)
#else
  ! Open binary files 59 to 90 for particle pair 1 to 32
  do i=59,90
    write(tmpFile,"(a5,i2)") "fort.",i
    call units_openUnits(unit=i,fileName=tmpFile,formatted=.false.,boinc=.true.)
  end do
#endif
  
  call units_openUnits(unit=98,fileName="fort.98",formatted=.true.,boinc=.true.,fio=.true.)
  
  ! Eric for the DA coefficients in BINARY
  call units_openUnits(unit=110,fileName="fort.110",formatted=.false.,boinc=.false.)
  call units_openUnits(unit=111,fileName="fort.111",formatted=.false.,boinc=.false.)
  
#ifdef DEBUG
  call units_openUnits(unit=99 ,fileName="dump",  formatted=.false.,boinc=.true.)
  call units_openUnits(unit=100,fileName="arrays",formatted=.false.,boinc=.true.)
#endif
  
  ! Heavy Ion Output
  call units_openUnits(unit=208,fileName="fort.208",formatted=.false.,boinc=.true.) ! collimator losses (energy)
  call units_openUnits(unit=209,fileName="fort.209",formatted=.false.,boinc=.true.) ! collimator losses in function of particle i
  call units_openUnits(unit=210,fileName="fort.210",formatted=.false.,boinc=.true.) ! mtc after each collimator interaction

  write(lout,10010) version,moddate
      tlim=1e7
      call timest(tlim)
      call datime(idate,itime)
      write(cdate,'(I6.6)') idate
      write(ctime,'(I4.4)') itime
      read(cdate(3:4),'(I2)') imonth
      if(cdate(6:6).eq.'1'.and.cdate(5:5).ne.'1') then
#ifdef CR
        day=stxt//cdate(5:6)//'st of' //cmonth(imonth)                  &
#else
        day='SIXTRACK starts on: '//cdate(5:6)//'st of' //cmonth(imonth)&
#endif
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'2'.and.cdate(5:5).ne.'1') then
#ifdef CR
        day=stxt//cdate(5:6)//'nd of' //cmonth(imonth)                  &
#else
        day='SIXTRACK starts on: '//cdate(5:6)//'nd of' //cmonth(imonth)&
#endif
     &//' 20'//cdate(1:2)//', '
      else if(cdate(6:6).eq.'3'.and.cdate(5:5).ne.'1') then
#ifdef CR
        day=stxt//cdate(5:6)//'rd of' //cmonth(imonth)                  &
#else
        day='SIXTRACK starts on: '//cdate(5:6)//'rd of' //cmonth(imonth)&
#endif
     &//' 20'//cdate(1:2)//', '
      else
#ifdef CR
        day=stxt//cdate(5:6)//'th of' //cmonth(imonth)                  &
#else
        day='SIXTRACK starts on: '//cdate(5:6)//'th of' //cmonth(imonth)&
#endif
     &//' 20'//cdate(1:2)//', '
      endif
      if(ctime(1:2).ne.'  ') then
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at '//ctime(1:2)//'.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after '//ctime(1:2)//'.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after '//ctime(1:2)//'.'
        endif
      else
        if(ctime(3:4).eq.'  ') then
          runtim=day(1:44)//' at midnight.'
        else if(ctime(3:4).eq.'01') then
          runtim=day(1:44)//' one minute after midnight.'
        else
          runtim=day(1:44)//ctime(3:4)//' minutes after midnight.'
        endif
      endif
      write(lout,'(a80)') runtim
#ifdef CR
!     Log start messages
      write(93,*)
      write(93,*) 'SIXTRACR MAINCR ',runtim
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
#endif
#ifdef DEBUG
                   !call system('../crmain  >> crlog')
#endif
!     A normal start, time0 is beginning
      pretime=0.0
      trtime=0.0
      posttime=0.0
      tottime=0.0
      time0=0.0
      time1=0.0
      time2=0.0
      time3=0.0
      tlim=1e7
      call timest(tlim)
      call timex(time0)
      do 10 i=1,nblz
        xsi(i)=zero
        zsi(i)=zero
        smi(i)=zero
   10 continue
      do 20 i=1,mmul
        cr(i)=zero
        ci(i)=zero
   20 continue
      do 30 i=1,2
        eps(i)=zero
        epsa(i)=zero
        ekk(i)=zero
        qw(i)=zero
        qwc(i)=zero
   30 continue
      do 60 i=1,npart
        nnumxv(i)=0
        xv(1,i)=zero
        xv(2,i)=zero
        yv(1,i)=zero
        yv(2,i)=zero
        dam(i)=zero
        ekkv(i)=zero
        sigmv(i)=zero
        dpsv(i)=zero
        dp0v(i)=zero
        ejv(i)=zero
        ejfv(i)=zero
        xlv(i)=zero
        zlv(i)=zero
        rvv(i)=one
!Heavy ion variables
! P. HERMES for hiSix
        mtc(i) = one
        naa(i) = 1
        nzz(i) = 1
        nucm(i)= pmap
        moidpsv(i) = one
        omoidpsv(i) = zero
        ejf0v(i)=zero
        dpd(i)=zero
        dpsq(i)=zero
        fok(i)=zero
        rho(i)=zero
        fok1(i)=zero
        si(i)=zero
        co(i)=zero
        g(i)=zero
        gl(i)=zero
        sm1(i)=zero
        sm2(i)=zero
        sm3(i)=zero
        sm12(i)=zero
        as3(i)=zero
        as4(i)=zero
        as6(i)=zero
        sm23(i)=zero
        rhoc(i)=zero
        siq(i)=zero
        aek(i)=zero
        afok(i)=zero
        hp(i)=zero
        hm(i)=zero
        hc(i)=zero
        hs(i)=zero
        wf(i)=zero
        wfa(i)=zero
        wfhi(i)=zero
        rhoi(i)=zero
        hi(i)=zero
        fi(i)=zero
        hi1(i)=zero
        xvl(1,i)=zero
        xvl(2,i)=zero
        yvl(1,i)=zero
        yvl(2,i)=zero
        ejvl(i)=zero
        dpsvl(i)=zero
        oidpsv(i)=one
        sigmvl(i)=zero
        iv(i)=0
        aperv(i,1)=zero
        aperv(i,2)=zero
        ixv(i)=0
        clov(1,i)=zero
        clov(2,i)=zero
        clo6v(1,i)=zero
        clo6v(2,i)=zero
        clo6v(3,i)=zero
        clopv(1,i)=zero
        clopv(2,i)=zero
        clop6v(1,i)=zero
        clop6v(2,i)=zero
        clop6v(3,i)=zero
        alf0v(i,1)=zero
        alf0v(i,2)=zero
        bet0v(i,1)=zero
        bet0v(i,2)=zero
        ampv(i)=zero
        do i1=1,6
          do i2=1,6
            tas(i,i1,i2)=zero
          end do
        end do

        qwcs(i,1)=zero
        qwcs(i,2)=zero
        qwcs(i,3)=zero
        di0xs(i)=zero
        di0zs(i)=zero
        dip0xs(i)=zero
        dip0zs(i)=zero
   60 continue
      qwc(3)=zero
      call comnul
      commen=' '
      progrm='SIXTRACK'
      pi=four*atan_mb(one)
      pi2=pi*half
      pisqrt=sqrt(pi)
      rad=pi/c180e0                                                       !hr05

#ifdef FLUKA

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise fluka module
!     inserted in main code by the 'fluka' compilation flag
      call fluka_mod_init(npart, nele, clight)
#endif

#ifdef ROOT
      call SixTrackRootFortranInit
#endif
  
  call daten
  
#ifdef HDF5
  if(h5_isActive) then
    call h5_openFile()
    call h5_writeSimInfo()
  end if
#endif
  call aperture_init

  if (ithick.eq.1) call allocate_thickarrays
      
#ifdef DEBUG
!     call dumpbin('adaten',999,9999)
!     call abend('after  daten                                      ')
#endif
#if defined(DEBUG) && defined(CR)
!     write(93,*) 'ERIC IL= ',il
!     endfile (93,iostat=ierro)
!     backspace (93,iostat=ierro)
#endif
#ifdef CR
      checkp=.true.
#ifdef DEBUG
                   !call system('../crmain  >> crlog')
#endif
      call crcheck
#endif
      if(ithick.eq.1) write(lout,10030)
      if(ithick.eq.0) write(lout,10040)
      if(ibidu.eq.2) then
        write(lout,10025)
        goto 550
      endif

#ifndef FLUKA
!--SETTING UP THE PLOTTING
      if(ipos.eq.1.and.(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call hlimit(nplo)
        call hplint(kwtype)
        call igmeta(-20,-111)
        cpto='NPTO'
        if(icr.eq.1) cpto='PTO '
        call hplopt(cpto,1)
        call hplopt('DATE',1)
        call hplset('DATE',1.)
        call hplset('CSIZ',.15)
      endif

      !Postprocessing is on, but there are no particles
      if(ipos.eq.1.and.napx.eq.0) then
! and now we open fort.10 unless already opened for
! BOINC

#ifdef NAGFOR
#ifdef BOINC
  call boincrf('fort.10',filename)
#ifdef FIO
  open(10,file=filename,form='formatted',status='unknown',round='nearest',recl=8195)
#else
  open(10,file=filename,form='formatted',status='unknown',recl=8195)
#endif
#else
#ifdef FIO
  open(10,file='fort.10',form='formatted',status='unknown',round='nearest',recl=8195)
#else
  open(10,file='fort.10',form='formatted',status='unknown',recl=8195)
#endif
#endif
#else
#ifdef BOINC
  call boincrf('fort.10',filename)
#ifdef FIO
  open(10,file=filename,form='formatted',status='unknown',round='nearest')
#else
  open(10,file=filename,form='formatted',status='unknown')
#endif
#else
#ifdef FIO
  open(10,file='fort.10',form='formatted',status='unknown',round='nearest')
#else
  open(10,file='fort.10',form='formatted',status='unknown')
#endif
#endif
#endif

#ifndef STF
      do i=1,ndafi !ndafi = number of files to postprocess (set by fort.3)
#ifndef CR
         call postpr(91-i)
#else
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(91-i,nnuml)
#endif
      end do
#else
!--   ndafi normally set in fort.3 to be "number of files to postprocess"
!--   Inside the postpr subroutine ndafi is modified as:
!--   ndafi=itopa(total particles) if once particle per header i.e ntwin=1,
!--   ndafi=itopa/2 if 2 particle per header i.e ntwin=2
      do i=1,(2*ndafi),2
#ifndef CR
         call postpr(i)
#else
         write(93,*) 'Calling POSTPR nnuml=',nnuml
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
         call postpr(i,nnuml)
#endif
      end do
#endif
! END ifndef STF

      call sumpos
      goto 520 !Jump to after particle&optics initialization,
               ! and also after tracking.
      endif !if(ipos.eq.1.and.napx.eq.0)
#endif
! END ifndef FLUKA

      do i=1,20
        fake(1,i)=zero
        fake(2,i)=zero
      end do

      itra=2
      amp00=amp(1)
      if(napx.ne.1) damp=((amp00-amp0)/real(napx-1,fPrec))/two                 !hr05
      napx=2*napx
      aperture_napxStart=napx
      iation=abs(ition)
      ib0=0
      dp00=dp1
      if(napx.le.0.or.imc.le.0) goto 490
      do 260 m=1,mmac
#ifdef DEBUG
!       call warr('mmac and m',0d0,nmac,m,0,0)
!       write(*,*) 'do 260 mmac/m',mmac,m
#endif
!--MULTIPOLE WITH THEIR RANDOM VALUES ADDED
        if(m.ge.2) then
          call recuin(m*izu0,irecuin)
          call ranecu(zfz,nzfz,mcut)
          rsum=zero

          do i=1,nzfz
            rsum=rsum+zfz(i)
          end do

          rmean=rsum/real(nzfz,fPrec)                                          !hr05
          rsqsum=zero

          do i=1,nzfz
            rsqsum=rsqsum+(zfz(i)-rmean)*(zfz(i)-rmean)
          end do

          rdev=sqrt(rsqsum/real(nzfz,fPrec))                                   !hr05
          write(lout,10320) m*izu0,nzfz,rmean,rdev
          write(lout,10070)
        endif
        ! A.Mereghetti (CERN, BE-ABP-HSS), 06-03-2018
        ! possible to re-shuffle lattice structure
        if(m.eq.1) call orglat

        ! A.Mereghetti, P. G. Ortega and D.Sinuela Pastor, for the FLUKA Team
        ! last modified: 01-07-2014
        ! call routine for calculating dcum, necessary for the online
        !    aperture check and in case of dumping particle population
        !    or statistics or beam matrix
        ! always in main code
        call cadcum
        if(idp.ne.0.and.ition.ne.0) then !6D tracking
           if ( abs( dcum(iu+1) - tlen ) .gt. eps_dcum ) then
              write(lout,'(1x,a)') "WARNING: Problem with SYNC block detected"
              write(lout,'(1x,a,f17.10)') "TLEN in sync block =",tlen
              write(lout,'(1x,a,f17.10)') "Length from DCUM   =",dcum(iu+1)
              write(lout,'(1x,a,f17.10)') "Difference         =",dcum(iu+1)-tlen
              write(lout,'(1x,a,e27.16,a)') "Relative error     =", 2 * (dcum(iu+1)-tlen) / (dcum(iu+1)+tlen), " [m]"
              write(lout,'(1x,a,f17.10,a)') "Tolerance eps_dcum =", eps_dcum, " [m]"
              write(lout,'(1x,a)') "Please fix the TLEN parameter in your SYNC block"
              write(lout,'(1x,a)') "so that it matches the calculated machine length from DCUM."
              write(lout,'(1x,a)') "If incorrect, the RF frequency may be (slightly) wrong."
        
              !It's a warning not an error, and the consequences seem relatively small.
              !Ideally, tlen should be calculated automatically based on the sequence.
              !call prror(-1)
           endif
        else
           tlen=dcum(iu+1)
        endif

        ! A.Mereghetti (CERN, BE-ABP-HSS), 16-12-2016
        ! initialise aperture of first and last elements of sequence
        if (limifound) then
           write(lout,*) ' check that beginning/end of lattice structure is assigned aperture markers...'
           call contour_aperture_markers( iu, 1, .false. )
        end if

#ifdef FLUKA
        ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
        ! last modified: 01-12-2016
        ! check integrity of coupling markers
        ! inserted in main code by the 'fluka' compilation flag
        if (fluka_enable) call check_coupling_integrity
#endif

        ! P. G. Ortega, for the FLUKA Team
        ! last modified: 01-07-2014
        ! dump aperture model
        ! always in main code
        if (ldmpaper) call dump_aperture_model

        ! A.Mereghetti (CERN, BE/ABP-HSS), 22-03-2018
        ! dump x-sections at specific locations
        if (mxsec.gt.0) call dump_aperture_xsecs

        ! A.Mereghetti (CERN, BE-ABP-HSS), 06-03-2018
        ! map errors, now that the sequence is no longer going to change
        if(m.eq.1) call ord

        call clorb(ded)

#ifdef ROOT
        call SixTrackRootInit()
        call ConfigurationOutputRootSet_npart(napx)
        call ConfigurationOutputRootSet_nturns(nnuml)
        call ConfigurationRootWrite()

!Dump the accelerator lattice
! read(ch1,*) idat,kz(i),ed(i),ek(i),el(i),bbbx(i),bbby(i),bbbs(i)
        if(root_flag .and. root_Accelerator.eq.1) then
!!     loop all over the entries in the accelerator structure
          do i=1,iu
            ix=ic(i)
            if(ix.gt.nblo) then
              ix=ix-nblo
              call AcceleratorRootWrite(trim(adjustl(bez(ix))) // C_NULL_CHAR, len_trim(trim(adjustl(bez(ix))) // C_NULL_CHAR), &
                                        kz(ix), ed(ix), ek(ix), el(ix))
            else
              do j=1,mel(ix)
               k=mtyp(ix,j)
                call AcceleratorRootWrite(trim(adjustl(bez(k))) // C_NULL_CHAR, len_trim(trim(adjustl(bez(k))) // C_NULL_CHAR), &
                                          kz(k), ed(k), ek(k), el(k))
              end do
            end if
          end do
        end if
#endif
#ifdef DEBUG
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
#endif
        do l=1,2
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        call clorb(zero)
#ifdef DEBUG
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
#endif
        do l=1,2
          ll=2*l
          di0(l)=(clo0(l)-clo(l))/ded
          dip0(l)=(clop0(l)-clop(l))/ded
        end do

        call corrorb

        if(irmod2.eq.1) call rmod(dp1)
        if(iqmod.ne.0) call qmod0
        if(ichrom.eq.1.or.ichrom.eq.3) call chroma
        if(iskew.ne.0) call decoup
        if(ilin.eq.1.or.ilin.eq.3) then
          call linopt(dp1)
        endif
#ifdef DEBUG
!     call dumpbin('bbb',96,996)
!     call abend('bbb                                               ')
#endif
!--beam-beam element
        nlino=nlin
        nlin=0
        if(nbeam.ge.1) then
          do 135 i=1,nele
            if(kz(i).eq.20) then
              nlin=nlin+1
              if(nlin.gt.nele) call prror(81)
              bezl(nlin)=bez(i)
            endif
  135     continue
        endif
        if(isub.eq.1) call subre(dp1)
        if(ise.eq.1) call search(dp1)
#ifdef DEBUG
!     call dumpbin('asearch',95,995)
!     call abend('asearch                                           ')
#endif

        !! Initialize kicks
        izu=0
        do 150 i=1,iu
#ifdef DEBUG
!       call warr('i/iu',0d0,i,iu,0,0)
!       write(*,*) 'do 150 i/iu',i,iu
#endif
          ix=ic(i)
          if(ix.le.nblo) goto 150
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 150
          if(kzz.eq.15) goto 150
          if(iorg.lt.0) mzu(i)=izu
          izu=mzu(i)+1
          smizf(i)=zfz(izu)*ek(ix)
          smiv(m,i)=sm(ix)+smizf(i) ! Also in initalize_element!
          smi(i)=smiv(m,i)          ! Also in initalize_element!
#ifdef DEBUG
!         call warr('smizf(i)',smizf(i),i,0,0,0)
!         call warr('smiv(m,i)',smiv(m,i),m,i,0,0)
!         call warr('smi(i)',smi(i),i,0,0,0)
#endif
          izu=izu+1
          xsiv(m,i)=xpl(ix)+zfz(izu)*xrms(ix)
          xsi(i)=xsiv(m,i)
          izu=izu+1
          zsiv(m,i)=zpl(ix)+zfz(izu)*zrms(ix)
          zsi(i)=zsiv(m,i)
          if(mout2.eq.1) then
            if(kzz.eq.11) zfz(izu-2)=zero
            if(abs(ek(ix)).le.pieni) zfz(izu-2)=zero
            if(abs(xrms(ix)).le.pieni) zfz(izu-1)=zero
            if(abs(zrms(ix)).le.pieni) zfz(izu)=zero
            write(31,'(a16,1p,d19.11,2d14.6,d17.9)') bez(ix),zfz(izu-2),zfz(izu-1),zfz(izu),extalign(i,3)
          endif
         
!-- MULTIPOLE BLOCK
          if(kzz.eq.11) then
             dynk_izuIndex(ix)=izu
!-- Initialize multipoles, combining settings from fort.2 with
!-- coefficients from MULT and random values from FLUC.
!-- Used in program maincr and from initialize_element.
             r0=ek(ix)
             if(abs(r0).le.pieni) goto 150 ! label 150 - just after this code
             nmz=nmu(ix)
             if(nmz.eq.0) then
                izu=izu+2*mmul
                goto 150
             endif
             im=irm(ix)
             r0a=one
             do k=1,nmz
                izu=izu+1
                aaiv(k,m,i)=(ed(ix)*(ak0(im,k)+zfz(izu)*aka(im,k)))/r0a !hr05
                aai(i,k)=aaiv(k,m,i)
                izu=izu+1
                bbiv(k,m,i)=(ed(ix)*(bk0(im,k)+zfz(izu)*bka(im,k)))/r0a !hr05
                bbi(i,k)=bbiv(k,m,i)
                
                r0a=r0a*r0
             enddo
             
             izu=izu+2*mmul-2*nmz
       !------------------------------------------------------------------------------------
          endif
 150   continue
#ifdef DEBUG
!     call dumpbin('ado 150',150,150)
!     call abend('ado 150                                           ')
#endif
        dp1=zero
        if(ichrom.gt.1) then
          itiono=ition
          ition=0
          call chromda
          ition=itiono
          do ncrr=1,iu
            ix=ic(ncrr)
            if(ix.gt.nblo) ix=ix-nblo
            if(ix.eq.is(1).or.iratioe(ix).eq.is(1)) then
              smiv(m,ncrr)=smi(ncrr)
            else if(ix.eq.is(2).or.iratioe(ix).eq.is(2)) then
              smiv(m,ncrr)=smi(ncrr)
            endif
          enddo
        endif
        dp1=dp00
        dp0=dp00
        if(imc.gt.1) then
          ddp1=(two*dp0)/(real(imc,fPrec)-one)                                 !hr05
        endif
        do 250 ib=1,imc
          if(imc.gt.1) then
            dp1=dp0-(real(ib,fPrec)-one)*ddp1                                  !hr05
          endif
          dp10=dp1
!-----------------------------------------------------------------------
          if(idp.ne.1.or.iation.ne.1) iclo6=0
          if (iclo6.eq.1.or.iclo6.eq.2) then
            if(ib.eq.1) then
              if(iclo6r.eq.0) then
                clo6(1)=clo(1)
                clop6(1)=clop(1)
                clo6(2)=clo(2)
                clop6(2)=clop(2)
                clo6(3)=zero
                clop6(3)=zero
              else
#ifdef FIO
#ifdef CRLIBM
              call enable_xp()
#endif
              read(33,*,round='nearest') (clo6(l),clop6(l), l=1,3)
#ifdef CRLIBM
              call disable_xp()
#endif
#else
#ifndef CRLIBM
              read(33,*) (clo6(l),clop6(l), l=1,3)
#else
              read(33,*) ch 
              lineno=lineno+1
              ch1(:nchars+3)=ch(:nchars)//' / '
              call splitfld(errno,33,lineno,nofields,nf,ch1,fields)
              do l=1,3
                if (nf.gt.0) then
                  clo6(l)=fround(errno,fields,l*2-1)
                  nf=nf-1
                endif
                if (nf.gt.0) then
                  clop6(l)=fround(errno,fields,l*2)
                  nf=nf-1
                endif
              enddo
#endif
#endif
            endif
            call clorb(zero)
            call betalf(zero,qw)
            call phasad(zero,qwc)
            sigm(1)=clo6(3)
            dps(1)=clop6(3)
#ifdef DEBUG
!     call dumpbin('bqmodda',1,3)
!     call abend('before qmodda 1 3                                 ')
!     write(*,*) '1st call qmodda'
#endif
            call qmodda(3,qwc)
#ifdef DEBUG
!     call dumpbin('aqmodda',1,3)
!     call abend('after  qmodda 1 3                                 ')
#endif
            if(ilin.ge.2) then
              nlinoo=nlin
              nlin=nlino
              ilinc=1
              call mydaini(2,2,6,3,6,1)
              nlin=nlinoo
            endif
            dp1=dp10+clop6(3)
#ifdef DEBUG
!     call dumpbin('ecdclor6',1,3)
!     call abend('end cd clor6                                      ')
#endif
            endif
            if(iqmod6.eq.1) then
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif

            do 190 ib1=1,napx
              ib3=ib1+(m+ib-2)*napx
!--beam-beam element
              clo6v(1,ib3)=clo6(1)
              clo6v(2,ib3)=clo6(2)
              clo6v(3,ib3)=clo6(3)
              clop6v(1,ib3)=clop6(1)
              clop6v(2,ib3)=clop6(2)
              clop6v(3,ib3)=clop6(3)
              di0xs(ib3)=di0(1)
              di0zs(ib3)=di0(2)
              dip0xs(ib3)=dip0(1)
              dip0zs(ib3)=dip0(2)
              qwcs(ib3,1)=qwc(1)
              qwcs(ib3,2)=qwc(2)
              qwcs(ib3,3)=qwc(3)

              do i2=1,6
                do j2=1,6
                  tas(ib3,i2,j2)=tasm(i2,j2)
                end do
              end do

  190       continue
          else
            if(idp.eq.1.and.iation.eq.1) then
              ncorruo=ncorru
              ncorru=1
              call clorb(zero)
#ifdef DEBUG
!     call dumpbin('aclorb',1,1)
!     call abend('after  clorb                                      ')
#endif
              call betalf(zero,qw)
              call phasad(zero,qwc)
#ifdef DEBUG
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
#endif
!--beam-beam element
              if(nbeam.ge.1) then
              nd=3
              nd2=6
#include "include/beamcou.f90"
              endif
              ncorru=ncorruo
              iqmodc=3
              call mydaini(2,2,6,3,6,1)
#ifdef DEBUG
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
#endif
              do i=1,2
                qwc(i)=real(int(qwc(i)),fPrec)+wxys(i)
              enddo
              if(ilin.ge.2) then
#ifdef DEBUG
!     call dumpbin('bmydaini',999,9999)
!     call abend('before mydaini                                    ')
#endif
                nlinoo=nlin
                nlin=nlino
                ilinc=1
                call mydaini(2,2,6,3,6,1)
#ifdef DEBUG
!     call dumpbin('amydaini',999,9999)
!     call abend('after  mydaini                                    ')
#endif
                nlin=nlinoo
              endif
            else
              dps(1)=dp1
              ncorruo=ncorru
              ncorru=1
              call clorb(dp1)
              call betalf(dp1,qw)
              call phasad(dp1,qwc)
#ifdef DEBUG
!     call dumpbin('abetphas',1,1)
!     call abend('after  abetphas                                   ')
#endif
              dp1=zero
!--beam-beam element
#ifdef DEBUG
!     call dumpbin('bbeam',1,1)
!     call abend('after bbeam                                       ')
!     write(*,*) 'call qmodda at beam-beam'
#endif
              dp1=dps(1)
              ncorru=ncorruo
              if(nvar2.le.5) then
                itiono=ition
                ition=0
              endif
              call qmodda(2,qwc)
#ifdef DEBUG
!     call dumpbin('aqmodda',3,2)
!     call abend('after  qmodda 3 2                                 ')
#endif
              if(nvar2.le.5) ition=itiono
              if(nvar2.le.4.and.ithick.eq.1) call envar(dp1)

              if(ilin.ge.2) then
                nlinoo=nlin
                nlin=nlino
                iqmodc=2
                call mydaini(1,2,5,2,5,1)
                ilinc=1
                call mydaini(2,2,5,2,5,1)
                nlin=nlinoo
              endif

              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) ix=ix-nblo
                if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                  smiv(m,ncrr)=smi(ncrr)
                else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                  smiv(m,ncrr)=smi(ncrr)
                endif
              enddo
            endif

            do 170 i=1,napx
              iar=(m+ib-2)*napx+i
              clo6v(1,iar)=clo(1)
              clop6v(1,iar)=clop(1)
              clo6v(2,iar)=clo(2)
              clop6v(2,iar)=clop(2)
              di0xs(iar)=di0(1)
              di0zs(iar)=di0(2)
              dip0xs(iar)=dip0(1)
              dip0zs(iar)=dip0(2)
              qwcs(iar,1)=qwc(1)
              qwcs(iar,2)=qwc(2)
              qwcs(iar,3)=zero

              do i2=1,4
                do j2=1,4
                  tas(iar,i2,j2)=tasm(i2,j2)
                end do
              end do

  170       continue
          endif
          iar=(m+ib-2)*napx+1

! save tas matrix and closed orbit for later dumping of the beam 
! distribution at the first element (i=-1)
! dumptas(*,*) [mm,mrad,mm,mrad,1] canonical variables
! tas(iar,*,*) [mm,mrad,mm,mrad,1] canonical variables
! clo6v,clop6v [mm,mrad,mm,mrad,1] canonical variables (x' or px?)
! for the initialization of the particles. Only in 5D thick the ta
! matrix is different for each particle.
! -> implement a check for this!
! In 4d,6d thin+thick and 5d thin we have:
!   tas(ia,*,*) = tas(1,*,*) for all particles ia
          if (iar .eq. 1) then
             do i3=1,3
                dumpclo(-1,i3*2-1) = clo6v(i3,1)
                dumpclo(-1,i3*2)   = clop6v(i3,1)
             enddo
             dumptas(-1,:,:) = tas(1,:,:)
!     invert the tas matrix
             call invert_tas(dumptasinv(-1,:,:),dumptas(-1,:,:))
!     dumptas and dumptasinv are now in units [mm,mrad,mm,mrad,1]
          endif
!     tas(iar,*,*) [mm,mrad,mm,mrad,1]
          
! convert to [mm,mrad,mm,mrad,1.e-3] for optics calculation
          tasiar16=tas(iar,1,6)*c1m3
          tasiar26=tas(iar,2,6)*c1m3
          tasiar36=tas(iar,3,6)*c1m3
          tasiar46=tas(iar,4,6)*c1m3
          tasiar56=tas(iar,5,6)*c1m3
          tasiar61=tas(iar,6,1)*c1e3
          tasiar62=tas(iar,6,2)*c1e3
          tasiar63=tas(iar,6,3)*c1e3
          tasiar64=tas(iar,6,4)*c1e3
          tasiar65=tas(iar,6,5)*c1e3
          bet0(1)=tas(iar,1,1)**2+tas(iar,1,2)**2                        !hr05
          bet0x2 =tas(iar,1,3)**2+tas(iar,1,4)**2                        !hr05
          bet0x3 =tas(iar,1,5)**2+tasiar16**2                            !hr05
          gam0x1 =tas(iar,2,1)**2+tas(iar,2,2)**2                        !hr05
          gam0x2 =tas(iar,2,3)**2+tas(iar,2,4)**2                        !hr05
          gam0x3 =tas(iar,2,5)**2+tasiar26**2                            !hr05
      alf0(1)=-one*(tas(iar,1,1)*tas(iar,2,1)+tas(iar,1,2)*tas(iar,2,2)) !hr05
      alf0x2 =-one*(tas(iar,1,3)*tas(iar,2,3)+tas(iar,1,4)*tas(iar,2,4)) !hr05
      alf0x3 =-one*(tas(iar,1,5)*tas(iar,2,5)+tasiar16*tasiar26)         !hr05
          bet0(2)=tas(iar,3,3)**2+tas(iar,3,4)**2                        !hr05
          bet0z2 =tas(iar,3,1)**2+tas(iar,3,2)**2                        !hr05
          bet0z3 =tas(iar,3,5)**2+tasiar36**2                            !hr05
          gam0z1 =tas(iar,4,3)**2+tas(iar,4,4)**2                        !hr05
          gam0z2 =tas(iar,4,1)**2+tas(iar,4,2)**2                        !hr05
          gam0z3 =tas(iar,4,5)**2+tasiar46**2                            !hr05
      alf0(2)=-one*(tas(iar,3,3)*tas(iar,4,3)+tas(iar,3,4)*tas(iar,4,4)) !hr05
      alf0z2 =-one*(tas(iar,3,1)*tas(iar,4,1)+tas(iar,3,2)*tas(iar,4,2)) !hr05
      alf0z3 =-one*(tas(iar,3,5)*tas(iar,4,5)+tasiar36*tasiar46)         !hr05
          bet0s1 =tas(iar,5,5)**2+tasiar56**2                            !hr05
          bet0s2 =tas(iar,5,1)**2+tas(iar,5,2)**2                        !hr05
          bet0s3 =tas(iar,5,3)**2+tas(iar,5,4)**2                        !hr05
          gam0s1 =tasiar65**2+tas(iar,6,6)**2                            !hr05
          gam0s2 =tasiar61**2+tasiar62**2                                !hr05
          gam0s3 =tasiar63**2+tasiar64**2                                !hr05
          alf0s1 =-one*(tas(iar,5,5)*tasiar65+tasiar56*tas(iar,6,6))     !hr05
          alf0s2 =-one*(tas(iar,5,1)*tasiar61+tas(iar,5,2)*tasiar62)     !hr05
          alf0s3 =-one*(tas(iar,5,3)*tasiar63+tas(iar,5,4)*tasiar64)     !hr05
#ifdef DEBUG
!     call dumpbin('abib1',1,1)
!     call abend('after bib1                                        ')
#endif
          do 220 ib1=1,napx
            iar=ib1+(m+ib-2)*napx

            do ib2=1,6
              do ib3=1,6
                tau(ib2,ib3)=tas(iar,ib3,ib2)
              end do
            end do

            if(abs(tau(1,1)).le.pieni.and.abs(tau(2,2)).le.pieni) then
              tau(1,1)=one
              tau(2,2)=one
            endif
            if(abs(tau(3,3)).le.pieni.and.abs(tau(4,4)).le.pieni) then
              tau(3,3)=one
              tau(4,4)=one
            endif
            if(abs(tau(5,5)).le.pieni.and.abs(tau(6,6)).le.pieni) then
              tau(5,5)=one
              tau(6,6)=one
              call dinv(6,tau,6,idummy,nerror)
              its6d=0
              if(ntwin.ne.2) then
                taus=(((((((((((((((((((                                &!hr05
     &abs(tau(5,1))+abs(tau(5,2)))+abs(tau(5,3)))+abs                   &!hr05
     &(tau(5,4)))+abs(tau(5,5)))+abs(tau(5,6)))+abs(tau(6,1)))          &!hr05
     &+abs(tau(6,2)))+abs(tau(6,3)))+abs(tau(6,4)))+abs                 &!hr05
     &(tau(6,5)))+abs(tau(6,6)))+abs(tau(1,5)))+abs(tau(2,5)))          &!hr05
     &+abs(tau(3,5)))+abs(tau(4,5)))+abs(tau(1,6)))+abs                 &!hr05
     &(tau(2,6)))+abs(tau(3,6)))+abs(tau(4,6)))-two                      !hr05
                if(abs(taus).ge.pieni) its6d=1
              endif
              do ib2=1,6
                do ib3=1,6
                  tasau(iar,ib2,ib3)=tau(ib2,ib3)
                end do
              end do
            endif
  220     continue
          if(ierro.ne.0) then
            write(lout,10230) dp1
            goto 520
          endif
          write(lout,10070)
          phag=(phas*c180e0)/pi                                           !hr05
          if((idp.eq.0).or.(abs(phas).le.pieni.and.ition.eq.0))         &
     &write(lout,10170)                                                 &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.iation.eq.1.and.abs(phas).gt.pieni) then
            if(iclo6.eq.0) then
              write(lout,10150) phag,                                   &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10160) phag,                                   &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          if(idp.eq.1.and.ition.eq.0.and.abs(phas).gt.pieni)            &
     &write(lout,10190) phag,                                           &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
          if(idp.eq.1.and.abs(phas).le.pieni.and.iation.eq.1) then
            if(iclo6.eq.0) then
              write(lout,10210)                                         &
     &qwc(1),clo(1),clop(1),                                            &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &qwc(2),clo(2),clop(2),                                            &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2
            else
              write(lout,10220)                                         &
     &qwc(1),clo6(1),clop6(1),                                          &
     &bet0(1),alf0(1),gam0x1,bet0x2,alf0x2,gam0x2,                      &
     &bet0x3,alf0x3,gam0x3,                                             &
     &qwc(2),clo6(2),clop6(2),                                          &
     &bet0(2),alf0(2),gam0z1,bet0z2,alf0z2,gam0z2,                      &
     &bet0z3,alf0z3,gam0z3,                                             &
     &qwc(3),clo6(3),clop6(3),                                          &
     &bet0s1,alf0s1,gam0s1,bet0s2,alf0s2,gam0s2,                        &
     &bet0s3,alf0s3,gam0s3
            endif
          endif
          write(lout,10080) dp1
          e0f=sqrt(e0**2-nucm0**2)                                         !hr05
          if(iclo6.eq.0) then
            write(lout,10110) clo(1),clop(1),clo(2),clop(2),idz(1),     &
     &idz(2),                                                           &
     &iver, idfor,iclo6,ition
          else
            write(lout,10120) clo6(1),clop6(1),clo6(2),clop6(2),clo6(3),&
     &clop6(3), idz(1),idz(2),iver,idfor,iclo6,ition
          endif

          do ib1=1,napx
            !Loop over all particles (not pairs) with the same
            ! ib (momentum variation, 1..imc ) and
            !  m (seed,               1..mmac).
            !It appears that only the odd (1,3,5,..) indices are actually used?
            ib2=ib0+ib1        ! ib0 is fixed to 0 => ib2 equals ib1
            clov(1,ib2)=clo(1)
            clov(2,ib2)=clo(2)
            clopv(1,ib2)=clop(1)
            clopv(2,ib2)=clop(2)
            bet0v(ib2,1)=bet0(1)
            bet0v(ib2,2)=bet0(2)
            alf0v(ib2,1)=alf0(1)
            alf0v(ib2,2)=alf0(2)
            ampv(ib2)=amp(1)-damp*real(ib1-1,fPrec) !hr05

            if(ib1.eq.napx-1 .and. ib1.ne.1) then
              !Make sure that last amplitude EXACTLY corresponds to the end amplitude amp0
              ! This is helpfull when doing DA studies and checking the "overlap"
              ampv(ib2)=amp0
            end if

            dp0v(ib2)=dp10
            dpsv(ib2)=dp10
            oidpsv(ib2)=one/(one+dp1)
! Heavy ion variable
            moidpsv(ib2)=mtc(ib2)/(one+dp1)
            nms(ib2)=m

            if(ithick.eq.1) then
              do i=1,nele
                ekv(ib2,i)=ek(i)
              end do
            end if

          end do

          ib0=ib0+napx
  250   continue
  260 continue
#ifdef DEBUG
!     call dumpbin('ado 260',260,260)
!     call abend('ado 260                                           ')
#endif

      napx=(napx*imc)*mmac                                               !hr05

#ifdef FLUKA

!     A.Mereghetti, P. Garcia Ortega, D.Sinuela Pastor, V. Vlachoudis 
!             for the FLUKA Team
!     last modified: 11-06-2014
!     start connection to FLUKA and initialise max ID
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        fluka_con = fluka_is_running()
        if(fluka_con.eq.-1) then
          write(lout,*) '[Fluka] Error: Fluka is expected to run but it is'
           write(lout,*) '               NOT actually the case'
          write(fluka_log_unit,*) '# Fluka is expected to run but it is'
          write(fluka_log_unit,*) '               NOT actually the case'
          call prror(-1)
        endif
        write(lout,*) '[Fluka] Initializing FlukaIO interface...'
        write(fluka_log_unit,*) '# Initializing FlukaIO interface...'
        fluka_con = fluka_connect()
        if(fluka_con.eq.-1) then
          write(lout,*) '[Fluka] Error connecting to Fluka server'
          write(fluka_log_unit,*) '# Error connecting to Fluka server'
          call prror(-1)
        endif
        write(lout,*) '[Fluka] Successfully connected to Fluka server'
        write(fluka_log_unit,*) '# Successfully connected to Fluka server'
        fluka_connected = .true.
      endif

#endif

#ifdef CR
      write(93,*) 'MAINCR setting napxo=',napx
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
#endif
      napxo=napx
      if(ibidu.eq.1) then
        ! Note: Keep in sync with read(32) below
        write(32) &
        ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
        ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
        idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
        iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
        hsyc,phasc,dppoff,sigmoff,tlen,                                   &
        iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
        sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
        zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
        mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
        dech,dsm0,itco,itcro,itqv,iout,iquiet,qw0,iq,iqmod,kpa,iqmod6,bez,&
        elbe,bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac, &
        pac,bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,sigma0,iclo,       &
        ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
        icoe,ise,mesa,mp,m21,m22,m23,                                     &
        ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
        rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
        qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
        iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
        nprint,ndafi,qwsk,betx,betz,pttemp,temptr,kxxa,                   &
        alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
        sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
        sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
        ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,wire_num,          &
        as,al,sigm,dps,idz,dp1,itra,                                      &
#ifdef SIXDA
        at,a2,                                                            &
#endif
        x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
        bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
        nvar2,nsix,ncor,ipar,nordf,                                       &
        nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
        icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
        ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
        clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
        dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
        ejf0v,numxv,nms,nlostp,dpd,                                       &
        dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
        rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
        ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
        clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
        di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr

      endif
  550 continue
      
      
      if (idp.eq.0.or.ition.eq.0) then
         !4D tracking
         if (iclo6 .ne. 0) then
            write(lout,*) "ERROR: Doing 4D tracking but iclo6=",iclo6
            write(lout,*) "Expected iclo6.eq.0. for 4D tracking."
            call prror(-1)
         endif
      else
         !6D tracking
         if (iclo6 .eq. 0) then
            write(lout,*) "ERROR: Doing 6D tracking but iclo6=",iclo6
            write(lout,*) "Expected iclo6.ne.0. for 6D tracking."
            call prror(-1)
         endif
      endif
      
      
!!!   GENERATE THE INITIAL DISTRIBUTION
      if(ibidu.eq.2) then
        ! Note: Keep in sync with write(32) above
        read(32) &
        ierro,erbez,pi,pi2,pisqrt,rad,il,mper,mblo,mbloz,msym,kanf,iu,ic, &
        ed,el,ek,sm,kz,kp,xpl,xrms,zpl,zrms,mel,mtyp,mstr,a,bl1,bl2,rvf,  &
        idfor,napx,napxo,numlr,nde,nwr,ird,imc,irew,ntwin,iclo6,iclo6r,   &
        iver,ibidu,qs,e0,pma,ej,ejf,phas0,phas,hsy,crad,                  &
        hsyc,phasc,dppoff,sigmoff,tlen,                                   &
        iicav,itionc,ition,idp,ncy,ixcav,dpscor,                          &
        sigcor,icode,idam,its6d,bk0,ak0,bka,aka,benki,benkc,r00,irm,nmu,  &
        zfz,iorg,mzu,bezr,izu0,mmac,mcut,exterr,extalign,tiltc,tilts,     &
        mout2,icext,icextal,aper,di0,dip0,ta,dma,dmap,dkq,dqq,de0,ded,dsi,&
        dech,dsm0,itco,itcro,itqv,iout,iquiet,qw0,iq,iqmod,kpa,iqmod6,bez,&
        elbe,bezb,ilin,nt,iprint,ntco,eui,euii,nlin,bezl,betam,pam,betac, &
        pac,bclorb,nhmoni,nhcorr,nvmoni,nvcorr,ncororb,sigma0,iclo,       &
        ncorru,ncorrep,icomb0,icomb,ratio,ratioe,iratioe,                 &
        icoe,ise,mesa,mp,m21,m22,m23,                                     &
        ise1,ise2,ise3,isea,qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl,rtc,  &
        rts,ire,ipr,irmod2,dtr,nre,nur,nch,nqc,npp,nrr,nu,dphix,dphiz,qx0,&
        qz0,dres,dfft,cma1,cma2,nstart,nstop,iskip,iconv,imad,ipos,iav,   &
        iwg,ivox,ivoz,ires,ifh,toptit,kwtype,itf,icr,idis,icow,istw,iffw, &
        nprint,ndafi,qwsk,betx,betz,pttemp,temptr,kxxa,                   &
        alfx,alfz,iskew,nskew,hmal,sixtit,commen,ithick,clo6,clop6,dki,   &
        sigman,sigman2,sigmanq,clobeam,beamoff,parbe,track6d,ptnfac,      &
        sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,nbeam,ibbc,    &
        ibeco,ibtyp,lhc,cotr,rrtr,imtr,bbcu,ibb6d,imbb,wire_num,          &
        as,al,sigm,dps,idz,dp1,itra,                                      &
#ifdef SIXDA
        at,a2,                                                            &
#endif
        x,y,bet0,alf0,clo,clop,cro,is,ichrom,nnumxv,xsi,zsi,smi,aai,      &
        bbi,ampt,tlim,tasm,preda,idial,nord,nvar,                         &
        nvar2,nsix,ncor,ipar,nordf,                                       &
        nvarf,nord1,ndimf,idptr,inorm,imod1,imod2,                        &
        icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,coel,        &
        ekv,fokqv,aaiv,bbiv,smiv,zsiv,xsiv,xsv,zsv,qw,qwc,clo0,           &
        clop0,eps,epsa,ekk,cr,ci,xv,yv,dam,ekkv,sigmv,dpsv,dp0v,sigmv6,   &
        dpsv6,ejv,ejfv,xlv,zlv,pstop,rvv,                                 &
        ejf0v,numxv,nms,nlostp,dpd,                                       &
        dpsq,fok,rho,fok1,si,co,g,gl,sm1,sm2,sm3,sm12,as3,as4,as6,sm23,   &
        rhoc,siq,aek,afok,hp,hm,hc,hs,wf,wfa,wfhi,rhoi,hi,fi,hi1,xvl,yvl, &
        ejvl,dpsvl,oidpsv,sigmvl,iv,aperv,ixv,clov,clopv,alf0v,bet0v,ampv,&
        clo6v,clop6v,hv,bl1v,tas,qwcs,di0xs,di0zs,dip0xs,dip0zs,xau,cloau,&
        di0au,tau,tasau,wx,x1,x2,fake,e0f,numx,cotr,rrtr,imtr
        
        damp=((amp(1)-amp0)/real(napx/2-1,fPrec))/two                          !hr05
      endif

      do i=1,npart
        pstop(i)=.false.
        nnumxv(i)=numl
        numxv(i)=numl
      end do

      rat0=rat


!----- Initial distribution creation

!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     acquisition of initial distribution moved out of loop
!     always in main code

      if ( idfor.eq.3 ) then
!       A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!       last modified: 17-07-2013
!       initialize particle distribution, read from file
!       always in main code

        if(.not. dist_enable) then
          write(lout,*) 'idfor set to 3 but DIST block not present'
          call prror(-1)
        endif


        e0f=sqrt(e0**2-nucm0**2)       ! hisix

        call dist_readdis( napx, npart, e0, e0f, clight, xv(1,:), xv(2,:), yv(1,:), yv(2,:), sigmv(:), ejfv(:) &
& ,naa(:), nzz(:), nucm(:) )      ! hisix

!       finalise beam distribution creation
        do j=1, napx
!         values related to losses
          nlostp(j) = j
          pstop (j) = .false.

!         values related to momentum
!         old proton only terms:
!          ejv   (j) = sqrt(ejfv(j)**2+pma**2)
!          dpsv  (j) = (ejfv(j)-e0f)/e0f
!          oidpsv(j) = one/(one+dpsv(j))

          ejv   (j)   = sqrt(ejfv(j)**2+nucm(j)**2)              ! hiSix
          dpsv  (j)   = (ejfv(j)*(nucm0/nucm(j))-e0f)/e0f         ! hiSix
          oidpsv(j)   = one/(one+dpsv(j))
          mtc     (j) = (nzz(j)*nucm0)/(zz0*nucm(j))  
          moidpsv (j) = mtc(j)*oidpsv(j)
          omoidpsv(j) = c1e3*((one-mtc(j))*oidpsv(j))

!         check existence of on-momentum particles in the distribution
          if ( abs(dpsv(j)).lt.c1m15 .or.  abs( (ejv(j)-e0)/e0 ) .lt.c1m15 ) then

!           warning with old infos:
            write(lout,*)''
            write(lout,'(5X,A22)') 'on-momentum particle!!'
            write(lout,'(5X,10X,4(1X,A25))') "momentum [MeV/c]","total energy [MeV]","Dp/p","1/(1+Dp/p)"
            write(lout,'(5X,"ORIGINAL: ",4(1X,1PE25.18))') ejfv(j), ejv(j), dpsv(j), oidpsv(j)

!            ejfv(j)   = e0f
!            ejv(j)    = e0
            ejfv(j)   = e0f*(nucm(j)/nucm0)          ! P. HERMES for hiSix
            ejv(j)    = sqrt(ejfv(j)**2+nucm(j)**2)  ! P. HERMES for hiSix
            dpsv(j)   = zero
            oidpsv(j) = one

!           warning with new infos:
            write(lout,'(5X,"CORRECTED:",4(1X,1PE25.18))') ejfv(j), ejv(j), dpsv(j), oidpsv(j)
            write(lout,*)''
          endif
        end do

! hisix
        write(lout,*) 'Heavy-Ion SixTrack'
        write(lout,*) '------------------'
        write(lout,*) 'Reference ion species: [A,Z,M]', aa0, zz0, nucm0
        write(lout,*) 'Reference energy [Z TeV]: ', c1m6*e0/zz0

! hisix - debugging
!        write(lout,*) 'Properties of tracked ion bunch [A,Z,E(MeV)], etc'
!        do j=1,napx
!          write(lout,*) naa(j),nzz(j),e0f*(nucm(j)/nucm0), ejfv(j), mtc(j), dpsv(j), ejv(j)
!        end do

!       A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!       last modified: 07-02-2014
!       in principle there is no need to fill in the unused places:
!       - nlostp(j) = j        with j=1,npart    filled in trauthin/trauthck
!       - pstop (j) = .false.  with j=1,npart    filled in maincr
!       - ejv   (j) = zero     with j=1,npart    filled in maincr
!       - dpsv  (j) = zero     with j=1,npart    filled in maincr
!       - oidpsv(j) = one      with j=1,npart    filled in maincr
!       nevertheless, let's do it, to be fully sure:
        do j=napx+1,npart
!         values related to losses
          nlostp(j) = j
          pstop (j) = .true.
!         values related to momentum
          ejv   (j) = zero
          dpsv  (j) = zero
          oidpsv(j) = one

          mtc   (j) = one         ! P. HERMES for hiSix
          naa   (j) = aa0
          nzz   (j) = zz0
          nucm  (j) = nucm0
          moidpsv (j) = one
          omoidpsv(j) = zero      ! P. HERMES for hiSix
        enddo

!       add closed orbit
        if(iclo6.eq.2) then
          do j=1, napx
            xv(1,j)=xv(1,j)+clo6v(1,j)
            yv(1,j)=yv(1,j)+clop6v(1,j)
            xv(2,j)=xv(2,j)+clo6v(2,j)
            yv(2,j)=yv(2,j)+clop6v(2,j)
            sigmv(j)=sigmv(j)+clo6v(3,j)
            dpsv(j)=dpsv(j)+clop6v(3,j)
            oidpsv(j)=one/(one+dpsv(j))
            moidpsv(j)=mtc(j)/(one+dpsv(j))
            omoidpsv(j) = c1e3*((one-mtc(j))*oidpsv(j))
          end do
        end if

!       echo
        if ( dist_echo ) then
           open(unit=dist_echo_unit)
           rewind(dist_echo_unit)
           write(dist_echo_unit,'(" # ",A40,1PE25.18)') " total energy of synch part [MeV]: ", e0
           write(dist_echo_unit,'(" # ",A40,1PE25.18)') " momentum of synch part [MeV/c]: ", e0f
           write(dist_echo_unit,*) '#'
           write(dist_echo_unit,*) '# for every particle (j)'
           write(dist_echo_unit,*) '# xv(1), yv(1), xv(2), yv(2), sigmv, ejfv'
           do j = 1, napx
             write(dist_echo_unit,'(6(1X,1PE25.18))') xv(1, j), yv(1, j), xv(2,j), yv(2,j), sigmv(j), ejfv(j)
           end do
           close(dist_echo_unit)
        endif

      endif

      do 340 ia=1,napx,2
        if(idfor.ne.2.and.idfor.ne.3) then
!---------------------------------------  SUBROUTINE 'ANFB' IN-LINE
          if(iquiet==0) write(lout,10050)
          tasia56=tas(ia,5,6)*c1m3
          bet0x2=tas(ia,1,3)**2+tas(ia,1,4)**2                           !hr05
          bet0z2=tas(ia,3,1)**2+tas(ia,3,2)**2                           !hr05
          bet0s1=tas(ia,5,5)**2+tasia56**2                               !hr05
          dsign=one
          rat=rat0
          if(tas(ia,3,3).lt.(-one*pieni)) rat=-one*rat                   !hr05
          if(rat.lt.(-one*pieni)) dsign=-one*one                         !hr05
          x11=ampv(ia)/(sqrt(bet0v(ia,1))+sqrt(abs(rat)*bet0x2))
          x13=(x11*dsign)*sqrt(abs(rat))                                 !hr05
          amp(2)=(dsign*real(1-iver,fPrec))*(abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt(bet0v(ia,2)))                 !hr05
          x1(5)=zero
          x1(6)=dpsv(ia)*sqrt(bet0s1)
          chi=chi0*rad
          dchi=chid*rad
          do 320 i2=1,2
            i3=ia+i2-1
            sic=sin_mb(chi)
            coc=cos_mb(chi)
            x1(1)=x11*coc
            x1(2)=x11*sic
            x1(3)=x13*coc
            x1(4)=x13*sic
            do 300 ii=1,6
              x2(ii)=zero
              do 290 jj=1,6
                x2(ii)=x2(ii)+tas(ia,ii,jj)*x1(jj)
  290         continue
  300       continue
            if(iclo6.eq.1.or.iclo6.eq.2) then
              x2(2)=x2(2)/((one+x2(6))+clop6v(3,ia))                     !hr05
              x2(4)=x2(4)/((one+x2(6))+clop6v(3,ia))                     !hr05
            endif
            if(abs(bet0s1).le.pieni) x2(6)=dpsv(ia)
            if(iver.eq.1) then
              x2(3)=zero
              x2(4)=zero
            endif
            do 310 l=1,2
              ll=(l-1)*2
              xv(l,i3)=x2(1+ll)+exz(i2,1+ll)
              yv(l,i3)=x2(2+ll)+exz(i2,2+ll)
  310       continue
            sigmv(i3)=x2(5)+exz(i2,5)
            dpsv(i3)=x2(6)
            dpsic=dpsv(i3)+clop6v(3,ia)
            if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
              xv(1,i3)=xv(1,i3)+di0xs(ia)*dpsic
              xv(2,i3)=xv(2,i3)+di0zs(ia)*dpsic
              yv(1,i3)=yv(1,i3)+dip0xs(ia)*dpsic
              yv(2,i3)=yv(2,i3)+dip0zs(ia)*dpsic
            endif
            chi=chi+dchi
  320     continue
          if(iquiet==0) write(lout,10260) ia,nms(ia)*izu0,dpsv(ia)
          if(iquiet == 0) then
            write(lout,10060) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia), &
                              xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv(2,ia+1),sigmv(ia+1),dpsv(ia+1)
          end if
!---------------------------------------  END OF 'ANFB'
          if(iclo6.eq.2) then
            xv(1,ia)=xv(1,ia)+clo6v(1,ia)
            yv(1,ia)=yv(1,ia)+clop6v(1,ia)
            xv(2,ia)=xv(2,ia)+clo6v(2,ia)
            yv(2,ia)=yv(2,ia)+clop6v(2,ia)
            sigmv(ia)=sigmv(ia)+clo6v(3,ia)
            dpsv(ia)=dpsv(ia)+clop6v(3,ia)
            xv(1,ia+1)=xv(1,ia+1)+clo6v(1,ia)
            yv(1,ia+1)=yv(1,ia+1)+clop6v(1,ia)
            xv(2,ia+1)=xv(2,ia+1)+clo6v(2,ia)
            yv(2,ia+1)=yv(2,ia+1)+clop6v(2,ia)
            sigmv(ia+1)=sigmv(ia+1)+clo6v(3,ia)
            dpsv(ia+1)=dpsv(ia+1)+clop6v(3,ia)
            oidpsv(ia)=one/(one+dpsv(ia))
            oidpsv(ia+1)=one/(one+dpsv(ia+1))
          else
            xv(1,ia)=xv(1,ia)+(clov(1,ia)*real(idz(1),fPrec))*          &
     &real(1-idfor,fPrec)    !hr05
            yv(1,ia)=yv(1,ia)+(clopv(1,ia)*real(idz(1),fPrec))*         &
     &real(1-idfor,fPrec)   !hr05
            xv(2,ia)=xv(2,ia)+(clov(2,ia)*real(idz(2),fPrec))*          &
     &real(1-idfor,fPrec)    !hr05
            yv(2,ia)=yv(2,ia)+(clopv(2,ia)*real(idz(2),fPrec))*         &
     &real(1-idfor,fPrec)   !hr05
            xv(1,ia+1)=xv(1,ia+1)+(clov(1,ia)*real(idz(1),fPrec))*      &
     &real(1-idfor,fPrec)  !hr05
            yv(1,ia+1)=yv(1,ia+1)+(clopv(1,ia)*real(idz(1),fPrec))*     &
     &real(1-idfor,fPrec) !hr05
            xv(2,ia+1)=xv(2,ia+1)+(clov(2,ia)*real(idz(2),fPrec))*      &
     &real(1-idfor,fPrec)  !hr05
            yv(2,ia+1)=yv(2,ia+1)+(clopv(2,ia)*real(idz(2),fPrec))*     &
     &real(1-idfor,fPrec) !hr05
          endif
          ejfv(ia)=e0f*(one+dpsv(ia))
          ejfv(ia+1)=e0f*(one+dpsv(ia+1))
          ejv(ia)=sqrt(ejfv(ia)**2+nucm0**2)                               !hr05
          ejv(ia+1)=sqrt(ejfv(ia+1)**2+nucm0**2)                           !hr05
          epsa(1)=(ampv(ia)**2/bet0v(ia,1))                              !hr05
          epsa(2)=(amp(2)**2/bet0v(ia,2))                                !hr05

          moidpsv(ia)=mtc(ia)/(one+dpsv(ia))
          moidpsv(ia+1)=mtc(ia+1)/(one+dpsv(ia+1))
          omoidpsv(ia)=c1e3*((one-mtc(ia))*oidpsv(ia))
          omoidpsv(ia+1)=c1e3*((one-mtc(ia+1))*oidpsv(ia+1))
          nucm(ia)=nucm0
          nucm(ia+1)=nucm0

          if(iquiet==0) write(lout,10020) ampv(ia),amp(2),epsa
        else if(idfor.eq.2) then
#ifndef CRLIBM
          read(13,*,iostat=ierro) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),  &
     &sigmv(ia),dpsv(ia),xv(1,ia+1),yv(1,ia+1),xv(2,ia+1),yv            &
     &(2,ia+1), sigmv(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
#endif
#ifdef CRLIBM
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(1,ia)]"
             call prror(-1)
          endif
          xv(1,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(1,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(1,ia)]"
             call prror(-1)
          endif
          yv(1,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(1,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(2,ia)]"
             call prror(-1)
          endif
          xv(2,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(2,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(2,ia)]"
             call prror(-1)
          endif
          yv(2,ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(2,ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ sigmv(ia)]"
             call prror(-1)
          endif
          sigmv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV sigmv(ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ dpsv(ia)]"
             call prror(-1)
          endif
          dpsv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV dpsv(ia)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(1,ia+1)]"
             call prror(-1)
          endif
          xv(1,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(1,ia+1)]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(1,ia+1)]"
             call prror(-1)
          endif
          yv(1,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(1,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ xv(2,ia+1)]"
             call prror(-1)
          endif
          xv(2,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV xv(2,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ yv(2,ia+1)]"
             call prror(-1)
          endif
          yv(2,ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV yv(2,ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [READ sigmv(ia+1)]"
             call prror(-1)
          endif
          sigmv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [CONV sigmv(ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [READ dpsv(ia+1)]"
             call prror(-1)
          endif
          dpsv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)                                              &
     &            "Error when reading fort.13 [CONV dpsv(ia+1)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ e0]"
             call prror(-1)
          endif
          e0 = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV e0]"
             call prror(-1)
          endif
          
          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ ejv(ia)]"
             call prror(-1)
          endif
          ejv(ia) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV ejv(ia)]"
             call prror(-1)
          endif

          read(13,'(a)', iostat=ierro) ch
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [READ ejv(ia+1)]"
             call prror(-1)
          endif
          ejv(ia+1) = round_near(ierro,nchars,ch)
          if(ierro.gt.0) then
             write(lout,*)"Error when reading fort.13 [CONV ejv(ia+1)]"
             call prror(-1)
          endif

#endif
          if(ierro.ne.0) call prror(56)
          mtc(ia)=one
          mtc(ia+1)=one
          nucm(ia)=nucm0
          nucm(ia+1)=nucm0
          e0f=sqrt(e0**2-nucm0**2)                                         !hr05
          ejfv(ia)=sqrt(ejv(ia)**2-nucm(ia)**2)                               !hr05
          ejfv(ia+1)=sqrt(ejv(ia+1)**2-nucm(ia+1)**2)                           !hr05
          oidpsv(ia)=one/(one+dpsv(ia))
          oidpsv(ia+1)=one/(one+dpsv(ia+1))
          moidpsv(ia)=mtc(ia)/(one+dpsv(ia))
          moidpsv(ia+1)=mtc(ia+1)/(one+dpsv(ia+1))
          omoidpsv(ia)=c1e3*((one-mtc(ia))*oidpsv(ia))
          omoidpsv(ia+1)=c1e3*((one-mtc(ia+1))*oidpsv(ia+1))
        endif
        if (idfor /= 3 .and. iquiet == 0) then
          write(lout,10090) xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),xv(1,ia+1),&
                            yv(1,ia+1),xv(2,ia+1),yv(2,ia+1),sigmv(ia+1),dpsv(ia+1),e0,ejv(ia),ejv(ia+1)
        end if
        idam=3
        icode=0
        if(abs(xv(1,ia)).le.pieni.and.abs(yv(1,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+1
        endif
        if(abs(xv(2,ia)).le.pieni.and.abs(yv(2,ia)).le.pieni) then
          idam=idam-1
        else
          icode=icode+2
        endif
        if(idp.eq.0.or.abs(ition).eq.0) then
          idam=idam-1
        else
          icode=icode+4
        endif
        if(idam.le.0) idam=1
        if(icode.le.0) icode=1
        ia2=(ia+1)/2
        if(ntwin.ne.2) then
          if(mod(ia+1,2).eq.0) then
            xau(1,1)= xv(1,ia)
            xau(1,2)= yv(1,ia)
            xau(1,3)= xv(2,ia)
            xau(1,4)= yv(2,ia)
            xau(1,5)=sigmv(ia)
            xau(1,6)= dpsv(ia)
            xau(2,1)= xv(1,ia+1)
            xau(2,2)= yv(1,ia+1)
            xau(2,3)= xv(2,ia+1)
            xau(2,4)= yv(2,ia+1)
            xau(2,5)=sigmv(ia+1)
            xau(2,6)= dpsv(ia+1)
            cloau(1)= clo6v(1,ia)
            cloau(2)=clop6v(1,ia)
            cloau(3)= clo6v(2,ia)
            cloau(4)=clop6v(2,ia)
            cloau(5)= clo6v(3,ia)
            cloau(6)=clop6v(3,ia)
            di0au(1)= di0xs(ia)
            di0au(2)=dip0xs(ia)
            di0au(3)= di0zs(ia)
            di0au(4)=dip0zs(ia)

            do ib2=1,6
              do ib3=1,6
                tau(ib2,ib3)=tasau(ia,ib2,ib3)
              end do
            end do

            call distance(xau,cloau,di0au,tau,dam1)
            dam(ia)=dam1
            dam(ia+1)=dam1
          endif !endif(mod(ia+1,2).eq.0)


!     Write header of track output file(s) used by postprocessing
!     for case ntwin.ne.2
#ifdef CR
          if (.not.restart) then
#endif
#ifndef STF
            call writebin_header(ia,ia,91-ia2,ierro,                    &
     &        cdate,ctime,progrm)
#ifdef CR
            flush(91-ia2)
            binrecs(ia2)=1
          endif
#endif
#endif
#ifdef STF
            call writebin_header(ia,ia,90,ierro,                        &
     &        cdate,ctime,progrm)
#ifdef CR
            flush(90)
            binrecs(ia2)=1
          endif
#endif
#endif
        else !ELSE for "if(ntwin.ne.2)"

!     Write header of track output file(s) used by postprocessing
!     for case ntwin.eq.2

#ifdef CR
          if (.not.restart) then
#endif
#ifndef STF
            call writebin_header(ia,ia+1,91-ia2,ierro,                  &
     &        cdate,ctime,progrm)
#ifdef CR
            flush(91-ia2)
            binrecs(ia2)=1
          endif
#endif
#endif
#ifdef STF
            call writebin_header(ia,ia+1,90,ierro,                      &
     &        cdate,ctime,progrm)
#ifdef CR
            flush(90)
            binrecs(ia2)=1
          endif
#endif
#endif
        endif !ENDIF (ntwin.ne.2)
        if(ierro.ne.0) then
          write(lout,*)
          write(lout,*) '*** ERROR ***,PROBLEMS WRITING TO FILE # : ',91&
     &-ia2
          write(lout,*) 'ERROR CODE : ',ierro
          write(lout,*)
          goto 520
        endif
  340 continue
#ifdef CR
      if (lhc.ne.9) binrec=1    ! binrec:
                                ! The maximum number of reccords writen for all tracking data files
                                ! Thus crbinrecs(:) .le. binrec
#endif
      if(e0.gt.pieni) then
        do j=1,napx
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        end do
      else
        call prror(79)
      endif

!-----/ End of initial distribution

  if(ithick.eq.1) then
!------ Compute matrices for linear tracking
    call envarsv(dpsv,moidpsv,rvv,ekv)
    if(idp.eq.0 .or. ition.eq.0) then
! ------- Only in case of thck4d
      call blocksv
    end if
  end if

#ifdef FLUKA
!     P.Garcia Ortega, A.Mereghetti and V.Vlachoudis, for the FLUKA Team
!     last modified: 26-08-2014
!     send napx to fluka
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        write(lout,*) '[Fluka] Sending napx: ', napx
        write(fluka_log_unit,*) '# Sending napx: ', napx
        fluka_con = fluka_init_max_uid( napx )

        if (fluka_con .lt. 0) then
           write(lout,*) '[Fluka] Error: failed to send napx to fluka ',&
     &  napx
           write(fluka_log_unit, *) '# failed to send napx to fluka ',  &
     &  napx
           call prror(-1)
        end if

        write(lout,*) '[Fluka] Sending napx successful;'
        write(fluka_log_unit,*) '# Sending napx successful;'
        flush(lout)
        flush(fluka_log_unit)
      endif

!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 18-01-2016
!     initialise energy/momentum/rest mass of reference particle in mod_fluka
!         and synch magnetic rigidity with Fluka (for the time being, consider
!         only protons);
!     inserted in main code by the 'fluka' compilation flag
      if(fluka_enable) then
        write(lout,*) '[Fluka] Updating ref particle'
        write(fluka_log_unit,*) '# Updating ref particle'
        flush(lout)
        flush(fluka_log_unit)

        fluka_con = fluka_set_synch_part( e0, e0f, nucm0, aa0, zz0 )

        if (fluka_con .lt. 0) then
          write(lout, *) '[Fluka] Error: failed to update ref particle'
          write(fluka_log_unit, *) '# failed to update ref particle'
          call prror(-1)
        end if

        write(lout,*) '[Fluka] Updating ref successful;'
        write(fluka_log_unit,*) '# Updating ref particle successful;'
        flush(lout)
        flush(fluka_log_unit)
      endif

#endif

!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     K. Sjobak, for BE/ABP-HSS
!     M. Fitterer, for FNAL
!     last modified: 21/02-2016
!     open units for dumping particle population or statistics
!     always in main code

      ! Initialise DUMP
      call dump_initialise

      ! ! ! Initialize SCATTER ! ! !
      if (scatter_active) then
         call scatter_initialise
      endif

#ifdef ROOT
! flush the root file
!  call SixTrackRootWrite()
#endif

!                                !
!     ****** TRACKING ******     !
!                                !
      write(lout,10200)
#ifdef DEBUG
!     call dumpbin('btrack',1,1)
!     call abend('btrack                                            ')
#endif
#ifdef DEBUG
                   !call system('../crmain  >> crlog')
#endif
      time1=0.
      call timex(time1)
! time1 is now pre-processing CPU
! note that this will be reset evry restart as we redo pre-processing
      pretime=time1-time0
!---------------------------------------  LOOP OVER TURNS TO BE TRACKED
      if(ithick.eq.0) call trauthin(nthinerr)
      if(ithick.eq.1) call trauthck(nthinerr)
#ifdef DEBUG
!     call dumpbin('atrack',1,1)
!     call abend('atrack                                            ')
#endif
      time2=0.
      call timex(time2)
! trtime is now the tracking time, BUT we must add other time for C/R
      trtime=time2-time1
#ifdef CR
! because now crpoint will write tracking time
! using time3 as a temp
! and crcheck/crstart will reset crtime3
      trtime=trtime+crtime3
#endif
      if(nthinerr.eq.3000) goto 520
      if(nthinerr.eq.3001) goto 460
!---------------------------------------  END OF LOOP OVER TURNS
  460 continue
#ifndef FLUKA
      napxto=0
#endif
! and set numx=nnuml (for writebin) NOT for LOST particles
! because all lost set nnuml=numl
      numx=nnuml
      id=0

#ifndef FLUKA
#ifdef CR
      if (.not.restart) then  
! If restart is true , we haven't done any tracking
! and must be running from very last checkpoint
        write(93,*) 'Very last call to WRITEBIN?'
        write(93,*) 'numlmax,nnuml,numl',numlmax,nnuml,numl
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        if (nnuml.eq.numl) then
! We REALLY have finished (or all particles lost)
! When all lost, nthinerr=3001, we set nnuml=numl
! and make sure we do the last WRITEBIN
          write(93,*) 'Very last call to WRITEBIN'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          call writebin(nthinerr)
          if(nthinerr.eq.3000) goto 520
        else
! I assume we are stopping because we have done nnuml turns
! which should be numlmax and do a writebin only if time
          write(93,*) 'Very last call to WRITEBIN?'
          write(93,*) 'numlmax,nnuml,nwri',numlmax,nnuml,nwri
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          if(mod(nnuml,nwri).eq.0) then
            write(93,*) 'Very last call to WRITEBIN'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call writebin(nthinerr)
            if(nthinerr.eq.3000) goto 520
          endif
        endif
! and do the very last checkpoint
        call callcrp()
      endif
#endif
#ifndef CR
      call writebin(nthinerr)
      if(nthinerr.eq.3000) goto 520
#endif
      ! If CR we have to worry about turns printed in fort.6
      ! If lost should be OK, otherwise we need to use nnuml instead
      ! of the numl in numxv/nnumxv???? Eric.
      ! where we reset [n]numxv to nnuml UNLESS particle lost
      ! Now we shall try using that fix at start of tracking
      do ia=1,napxo,2
        ie=ia+1
        ia2=(ie)/2
        napxto=(napxto+numxv(ia))+numxv(ie)                              !hr05
        
        if(pstop(ia).and.pstop(ie)) then !-- BOTH PARTICLES LOST
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          if(iquiet==0) write(lout,10280) xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia), &
            xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),e0,ejvl(ia),ejvl(ie)
          write(12,10280,iostat=ierro) xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia), &
            xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),e0,ejvl(ia),ejvl(ie)
          if(ierro.ne.0) write(lout,*) 'Warning from maincr: fort.12 has ',&
            'corrupted output probably due to lost particle: ',ia,' or: ',ie
        end if
        
        if(.not.pstop(ia).and.pstop(ie)) then !-- SECOND PARTICLE LOST
          id=id+1
          if(iquiet==0) then
            write(lout,10240) ia,nms(ia)*izu0,dp0v(ia),numxv(ia)
          else
            write(lout,10241) ia,nms(ia)*izu0,dp0v(ia),numxv(ia)
          end if
          write(lout,10000) ie,nms(ia)*izu0,dp0v(ia),numxv(ie),abs(xvl(1,ie)),aperv(ie,1),abs(xvl(2,ie)),aperv(ie,2)
          if(iquiet==0) write(lout,10280) xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id), &
            xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),e0,ejv(id),ejvl(ie)
          write(12,10280,iostat=ierro) xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id), &
            xvl(1,ie),yvl(1,ie),xvl(2,ie),yvl(2,ie),sigmvl(ie),dpsvl(ie),e0,ejv(id),ejvl(ie)
          if(ierro.ne.0) write(lout,*) 'Warning from maincr: fort.12 has corrupted output probably due to lost particle: ',ie
        end if
        
        if(pstop(ia).and..not.pstop(ie)) then !-- FIRST PARTICLE LOST
          id=id+1
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),numxv(ia),abs(xvl(1,ia)),aperv(ia,1),abs(xvl(2,ia)),aperv(ia,2)
          if(iquiet==0) then
            write(lout,10240) ie,nms(ia)*izu0,dp0v(ia),numxv(ie)
          else
            write(lout,10241) ie,nms(ia)*izu0,dp0v(ia),numxv(ie)
          end if
          if(iquiet==0) write(lout,10280) xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia), &
            xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),e0,ejvl(ia),ejv(id)
          write(12,10280,iostat=ierro) xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia), &
            xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),e0,ejvl(ia),ejv(id)
          if(ierro.ne.0) write(lout,*) 'Warning from maincr: fort.12 has corrupted output probably due to lost particle: ',ia
        end if
        
        if(.not.pstop(ia).and..not.pstop(ie)) then !-- BOTH PARTICLES STABLE
          id=id+1
          ig=id+1
          if(iquiet==0) then
            write(lout,10270) ia,ie,nms(ia)*izu0,dp0v(ia),numxv(ia)
          else
            write(lout,10271) ia,ie,nms(ia)*izu0,dp0v(ia),numxv(ia)
          end if
          if(iquiet==0) write(lout,10280) xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id), &
            xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),e0,ejv(id),ejv(ig)
          write(12,10280,iostat=ierro) xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id), &
            xv(1,ig),yv(1,ig),xv(2,ig),yv(2,ig),sigmv(ig),dpsv(ig),e0,ejv(id),ejv(ig)
          if(ierro.ne.0) write(lout,*) 'Warning from maincr: fort.12 has corrupted output although particles stable'
          id=ig
        end if
      end do
#endif
#ifdef FLUKA
      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! print stable particles only
      ! inserted in main code by the 'fluka' compilation flag
      write(lout,*)
      write(lout,10340)
      if ( napxo .gt. 0 ) then
        write(lout,*)
        write(lout,10350) napxo
        write(lout,*)
        write(lout,10360) 'ID', 'GEN', 'WEIGHT', 'X [m]', 'XP []', 'Y [m]', 'YP[]', 'PC [GeV]', 'DE [eV]', 'DT [s]'
        write(lout,*)
        do ia=1,napxo
          if(.not.pstop(ia)) then
            write(lout,10370) fluka_uid(ia),fluka_gen(ia),fluka_weight(ia), &
              xv(1,ia)*c1m3, yv(1,ia)*c1m3, xv(2,ia)*c1m3, yv(2,ia)*c1m3, &
              ejfv(ia)*c1m3,(ejv(ia)-e0)*c1e6,-c1m3*(sigmv(ia)/clight)*(e0/e0f)
          end if
        end do
      end if
#endif

! POSTPROCESSING (POSTPR)

! and we need to open fort.10 unless already opened for BOINC
#ifdef NAGFOR
#ifdef BOINC
  call boincrf('fort.10',filename)
#ifdef FIO
  open(10,file=filename,form='formatted',status='unknown',round='nearest',recl=8195)
#else
  open(10,file=filename,form='formatted',status='unknown',recl=8195)
#endif
#else
#ifdef FIO
  open(10,file='fort.10',form='formatted',status='unknown',round='nearest',recl=8195)
#else
  open(10,file='fort.10',form='formatted',status='unknown',recl=8195)
#endif
#endif
#else
#ifdef BOINC
  call boincrf('fort.10',filename)
#ifdef FIO
  open(10,file=filename,form='formatted',status='unknown',round='nearest')
#else
  open(10,file=filename,form='formatted',status='unknown')
#endif
#else
#ifdef FIO
  open(10,file='fort.10',form='formatted',status='unknown',round='nearest')
#else
  open(10,file='fort.10',form='formatted',status='unknown')
#endif
#endif
#endif

#ifndef FLUKA
#ifndef STF
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
          do 480 ia=1,napxo,2
            ia2=(ia+1)/2
            iposc=iposc+1
#ifndef CR
            call postpr(91-ia2) !Postprocess file "fort.(91-ia2)"
#endif
#ifdef CR
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia2,nnuml)
#endif
  480     continue
          if(iposc.ge.1) call sumpos
        endif !END if(ipos.eq.1)
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,ndafi2
            if(ia.gt.ndafi) goto 510
#ifndef CR
            call postpr(91-ia)
#endif
#ifdef CR
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(91-ia,nnuml)
#endif
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
#endif
#ifdef STF
        iposc=0
        if(ipos.eq.1) then !Variable IPOS=1 -> postprocessing block present in fort.3
           do 480 ia=1,napxo,2
              iposc=iposc+1
#ifndef CR
              call postpr(ia) !Postprocess particle ia (and ia+1 if ntwin=2)
#endif
#ifdef CR
              write(93,*) 'Calling POSTPR nnuml=',nnuml
              endfile (93,iostat=ierro)
              backspace (93,iostat=ierro)
              call postpr(ia,nnuml)
#endif
  480      continue
          if(iposc.ge.1) call sumpos
        endif
        goto 520 !Done postprocessing
        
  490   if(ipos.eq.1) then !GOTO here if(napx.le.0.or.imc.le.0) (skipping tracking)
          ndafi2=ndafi
          do 500 ia=1,(2*ndafi2),2
            if(ia.gt.ndafi) goto 510
#ifndef CR
            call postpr(ia)
#endif
#ifdef CR
            write(93,*) 'Calling POSTPR nnuml=',nnuml
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
            call postpr(ia,nnuml)
#endif
  500     continue
  510     if(ndafi.ge.1) call sumpos
        endif
#endif

 520  continue !Finished postprocessing (POST in fort.3)
      
!     start fma
      if(fma_flag) then
        write(lout,*)'Calling FMA_POSTPR'
        call fma_postpr
      endif
!--HPLOTTING END
      if(ipos.eq.1.and.                                                 &
     &(idis.ne.0.or.icow.ne.0.or.istw.ne.0.or.iffw.ne.0)) then
        call igmeta(999,0)
        call hplend
      endif
#endif

#ifdef FLUKA
!     A.Mereghetti, for the FLUKA Team
!     last modified: 28-05-2014
!     collect a couple of goto statements, sending code flow
!       to different plotting points, which are not actually
!       inserted
!     inserted in main code by the 'fluka' compilation flag
 490  continue
 520  continue
  call fluka_close
#endif
      time3=0.
      call timex(time3)
! Note that crpoint no longer destroys time2
      posttime=time3-time2
#ifdef DEBUG
      write(lout,*) 'BUG:',time3,time2,pretime,trtime,posttime
#ifdef CR
      write(93,*)   'BUG:',time3,time2,pretime,trtime,posttime
#endif
#endif
! and now get grand total including post-processing
      tottime=(pretime+trtime)+posttime
      write(lout,10290) pretime
#ifdef CR
! and TRY a FIX for napxto
!     if (nnuml.ne.numl) then
!       napxto=0
!       write(lout,*) 'numl=',numl,' nnuml=',nnuml
! We may have stopped because of numlmax
!       do ia=1,napxo
!         if (numxv(ia).eq.numl) then
! assumed stable
!     write(lout,*) 'ia=',ia,nnuml
!           napxto=napxto+nnuml
!         else
! assumed lost
!     write(lout,*) 'ia=',ia,' numxv=',numxv
!           napxto=napxto+numxv(ia)
!         endif
!       enddo 
!     endif
#endif
      write(lout,10300) napxto,trtime
      write(lout,10310) tottime
#ifdef DEBUG
!     call wda('THE END',0d0,9,9,9,9)
!     call dumpum('THE END',999,9999)
!     call dumpbin('THE END',999,9999)
!     call dumpzfz('THE END',9,9)
#endif
  ! Write all dynamically assigned file units tp file_units.dat
  call funit_dumpUnits
  if (zipf_numfiles.gt.0) then
    call zipf_dozip
  endif
#ifdef ROOT
  call RunTimeRootWrite(pretime, trtime, posttime)
  call SixTrackRootExit()
#endif
  call alloc_exit
  call closeUnits ! Must be last as it also closes fort.6
! ----------------------------------------------------------------------
!   We're done in maincr, no error :)
! ----------------------------------------------------------------------
#ifdef CR
  call abend('                                                  ')
#endif
#ifndef CR
  stop
#endif
10000 format(/t10,'TRACKING ENDED ABNORMALLY'/t10, 'PARTICLE ',i7,      &
     &' RANDOM SEED ',i8,/ t10,' MOMENTUM DEVIATION ',g12.5,            &
     &' LOST IN REVOLUTION ',i8,/ t10,'HORIZ:  AMPLITUDE = ',ES23.16,   &
     &'   APERTURE = ',f15.3/ t10,'VERT:   AMPLITUDE = ',ES23.16,       &
     &'   APERTURE = ',f15.3/)
#ifndef TILT
#ifdef CR
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
#endif
#ifndef CR
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,                        &
     &'  --  (last change: ',A10,')'//)
#endif
#endif
#ifdef TILT
#ifdef CR
10010 format(/t10,'SIXTRACR VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
#endif
#ifndef CR
10010 format(/t10,'SIXTRACK VECTOR VERSION ',A8,' (with tilt)',         &
     &'  --  (last change: ',A10,')'//)
#endif
#endif
10020 format(/t10,'UNCOUPLED AMPLITUDES AND EMITTANCES:', /t10,         &
     &'AMPLITUDE-X = ',f15.3,10x,'AMPLITUDE-Y = ',f15.3, '  MM'/t10,    &
     &'EMITTANCE-X = ',f15.3,10x,'EMITTANCE-Y = ',f15.3, '  PI*MRAD*MM')
10025 format(/t10,'Run started from binary dump file # 32')
10030 format(/t10,'STRUCTURE INPUT FILE HAS -THICK- LINEAR ',           &
     &'ELEMENTS'//)
10040 format(/t10,'STRUCTURE INPUT FILE HAS ONLY -THIN- LINEAR ',       &
     &'ELEMENTS'//)
10050 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
10060 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10070 format(/131('-'))
10080 format(/t10,'REL. MOMENTUM DEVIATION=',f19.16/ t8,                &
     &'========================================')
10090 format(/5x,'---- INITIAL COORD. OF TWIN-TRAJECTORIES'/ 15(10x,f47.&
     &33/))
10110 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/DCX / ',i4/5x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,    &
     &'/IDFOR/',i4/ 5x,'/ICLO6/',i4/ 5x,'/ITION/',i4/5x/)
10120 format(/5x,'---- CLOSED ORBIT AND DECOUPLING (1=COU,0=DECOU)'/ 5x,&
     &'/CLX /',f47.33/5x,'/CLXP/',f47.33/ 5x,'/CLY /',f47.33/5x,'/CLYP/'&
     &,f47.33/ 5x,'/CLS /',f47.33/5x,'/CLSP/',f47.33/ 5x,'/DCX / ',i4/5 &
     &x,'/DCY / ',i4/ 5x,'/IVER /',i4/ 5x,'/IDFOR/',i4/ 5x,'/ICLO6/',i4/&
     &5x,'/ITION/',i4/5x/)
10150 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10))
10160 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10170 format(/t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,     &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/)
10180 format(t5//t5,'BACK-TRACKING'/ t5, '============='//)
10190 format(t10,'TRACKING FOR CONSTANT MOMENTUM DEVIATION'// 15x,      &
     &'ACCELERATION WITH PHASE = ',f8.4/ t15,                           &
     &'       TUNE         CLO            CLOP           ',             &
     &'   BET0           ALF0           GAMMA      '//                  &
     &t10,'  X  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/                                        &
     &t10,'  Y  ',f14.10,2(1x,g15.8),1x,f15.9,1x,f15.10,f15.9/          &
     &t62,f15.9,1x,f15.10,f15.9/)
10200 format(//131('-')//t10,16('O')/t10,2('O'),12x,2('O')/t10,         &
     &'OO  TRACKING  OO', /t10,2('O'),12x,2('O')/t10,16('O')//131('-')//&
     &)
10210 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10))
10220 format(/t10,'TRACKING WITH SYNCHROTRON OSCILLATIONS'/ 15x,        &
     &'------ NO ACCELERATION ------'// t15,                            &
     &'       TUNE             CLO                CLOP           ',     &
     &'     BET0             ALF0           GAMMA      '//              &
     &t10,'  X  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  Y  ',6(1x,ES17.10)/                                        &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10)/                              &
     &t10,'  S  ',3(1x,ES17.10),3(1x,ES17.10)/                          &
     &t69,3(1x,ES17.10)/t69,3(1x,ES17.10))
10230 format(t10,'NO OPTICAL SOLUTION FOR',2x,f19.16,2x,'RELATIVE MOMENTUM DEVIATION')
10240 format(1x/5x,'PARTICLE ',i7,' STABLE - RANDOM SEED ', i8,' MOMENTUM DEVIATION ',g12.5,'REVOLUTION ',i8/)
10241 format(   5x,'PARTICLE ',i5,' STABLE - RANDOM SEED ', i8,' MOMENTUM DEVIATION ',g12.5,'REVOLUTION ',i8)
!10250 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10260 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,' MOMENTUM DEVIATION ',g12.5/)
10270 format(1x/5x,'PARTICLE ',i7,' AND ',i7,' STABLE - RANDOM SEED ',i8,' MOMENTUM DEVIATION ',g12.5,'REVOLUTION ',i8/)
10271 format(   5x,'PARTICLE ',i5,' AND ',i5,' STABLE - RANDOM SEED ',i8,' MOMENTUM DEVIATION ',g12.5,'REVOLUTION ',i8)
10280 format(10x,f47.33)
10290 format(/10x,'The Preparating Calculations took',f12.3,' second(s)',' of Computing Time')
10300 format(/10x,'For ',i12,' Turn(s)',g12.3,' second(s) of ',         &
     &'Computing Time was needed'//131('-'))
10310 format(//10x,'Total Time used: ',g12.3,' second(s)'//131('-'))
10320 format(//131('-')//t10,'DATA BLOCK FLUCTUATIONS OF MULTIPOLES'//  &
     &t10,'RANDOM STARTING NUMBER=  ',i20/ t10,                         &
     &'RANDOM NUMBERS GENERATED:',i20/ t10,'MEAN VALUE=',f15.7,         &
     &'  -   DEVIATION=',f15.7)
10330 format(/10x,'ERROR IN OPENING FILES')
10340 format(131('-'))
#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     print stable particles only (format directives)
!     inserted in main code by the 'fluka' compilation flag
10350 format(4X,I8,1X,'SURVIVING PARTICLES:')
10360 format(2(1X,A8),8(1X,A16))
10370 format(2(1X,I8),8(1X,1PE16.9))
10380 format(10x,f47.33)
#endif
end program maincr

+dk tra_thin
!!--------------------------------------------------------------------------
!!  TRACK THIN LENS PART
!!  F. SCHMIDT
!!  CHANGES FOR COLLIMATION MADE BY G. ROBERT-DEMOLAIZE, October 29th, 2004
!!--------------------------------------------------------------------------
subroutine trauthin(nthinerr)
  ! Updated to Fortran 2015 by V.K.B. Olsen, 19/11/2017
  use floatPrecision
  use end_sixtrack
  use mathlib_bouncer
  use numerical_constants
  use scatter, only : scatter_elemPointer
  use dynk, only : ldynk, dynk_isused, dynk_pretrack

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif
#ifdef COLLIMAT
  use collimation
#endif

  use crcoall
  use parpro
  use parbeam, only : beam_expflag,beam_expfile_open
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  implicit none
  integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
  real(kind=fPrec) benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
    r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
  logical lopen
+ca beamdim
  dimension nbeaux(nbb)
#ifdef COLLIMAT
!+ca collpara
+ca dbtrthin
+ca database
+ca dbcommon
!+ca dblinopt
+ca dbpencil
!+ca info
+ca dbcolcom
#endif
  save

  do i=1,npart
    nlostp(i)=i
  end do
  do i=1,nblz
    ktrack(i)=0
    strack(i)=zero
    strackc(i)=zero
    stracks(i)=zero
  end do
#include "include/beams1.f90"

      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        !BLOC
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        goto 290
        !Non-linear/NOT BLOC
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
        kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        else if(kzz.eq.12) then
          !Disabled cavity; enabled cavities have kp=6 and are handled above
          ! Note: kz=-12 are transformed into +12 in daten after reading ENDE.
          ktrack(i)=31
          goto 290
        endif
#include "include/beams21.f90"
#include "include/beamcoo.f90"
#include "include/beamr1.f90"
     &goto 42
#include "include/beamr2.f90"
#include "include/beamr3o.f90"
#include "include/beams22.f90"
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4o.f90"
            else if(ibtyp.eq.1) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4o.f90"
#include "include/beams23.f90"
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4o.f90"
            else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4o.f90"
#include "include/beams24.f90"

        ! wire
        if(kzz.eq.15) then
          ktrack(i)=45
          goto 290
        endif
        ! acdip1
        if(kzz.eq.16) then
          ktrack(i)=51
          goto 290
        else if(kzz.eq.-16) then
          ktrack(i)=52
          goto 290
        endif
        ! crab
        if(kzz.eq.23) then
          ktrack(i)=53
          goto 290
        else if(kzz.eq.-23) then
          ktrack(i)=54
          goto 290
        endif
        ! JBG RF CC Multipoles
        if(kzz.eq.26) then
          ktrack(i)=57
          goto 290
        else if(kzz.eq.-26) then
          ktrack(i)=58
          goto 290
        endif
        if(kzz.eq.27) then
          ktrack(i)=59
          goto 290
        else if(kzz.eq.-27) then
          ktrack(i)=60
          goto 290
        endif
        if(kzz.eq.28) then
          ktrack(i)=61
          goto 290
        else if(kzz.eq.-28) then
          ktrack(i)=62
          goto 290
        endif
        !electron lens (HEL)
        if(kzz.eq.29) then
          ktrack(i)=63
          goto 290
        endif
        ! SCATTER block
        if (kzz.eq.40 .and. scatter_elemPointer(ix).ne.0) then
          ! FOR NOW, ASSUME THIN SCATTER; ktrack(i)=65 RESERVED FOR THICK SCATTER
          ktrack(i)=64
          goto 290
        endif
        if(kzz.eq.22) then
          ktrack(i)=3
          goto 290
        endif
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),extalign(i,2),extalign(i,3)
        end if
        
        select case (kzz)
        case (1)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 11
#include "include/stra01.f90"
          end if
        case (2)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i)=12
#include "include/stra02.f90"
          end if
        case (3)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 13
#include "include/stra03.f90"
          end if
        case (4)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 14
#include "include/stra04.f90"
          end if
        case (5)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 15
#include "include/stra05.f90"
          end if
        case (6)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 16
#include "include/stra06.f90"
          end if
        case (7)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 17
#include "include/stra07.f90"
          end if
        case (8)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 18
#include "include/stra08.f90"
          end if
        case (9)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 19
#include "include/stra09.f90"
          end if
        case (10)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 20
#include "include/stra10.f90"
          end if
        case (11) ! Multipole block (also in initialize_element)
          r0  = ek(ix)
          nmz = nmu(ix)
          if(abs(r0).le.pieni.or.nmz.eq.0) then
            if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
              if ( dynk_isused(i) ) then
                write(lout,*) "ERROR: Element of type 11 (bez=",bez(ix),") is off in fort.2, but on in DYNK. Not implemented."
                call prror(-1)
              end if
              ktrack(i) = 31
            else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 33
#include "include/stra11.f90"
              else
                ktrack(i) = 35
#include "include/stra12.f90"
              end if
            else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 37
#include "include/stra13.f90"
              else
                ktrack(i) = 39
#include "include/stra14.f90"
              end if
            end if
          else
            if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
              ktrack(i) = 32
            else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 34
#include "include/stra11.f90"
              else
                ktrack(i) = 36
#include "include/stra12.f90"
              end if
            else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
              if(abs(dki(ix,3)).gt.pieni) then
                ktrack(i) = 38
#include "include/stra13.f90"
              else
                ktrack(i) = 40
#include "include/stra14.f90"
              end if
            end if
          end if
          if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
          if(mout2.eq.1) then
            benkcc = ed(ix)*benkc(irm(ix))
            r0a    = one
            r000   = r0*r00(irm(ix))
            
            do j=1,mmul
              fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
              fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
              r0a=r0a*r000
            end do
            
            write(9,'(a16)') bez(ix)
            write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
            write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
            write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
            write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
            write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
            write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
            write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
            write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
            
            do j=1,20
              fake(1,j)=zero
              fake(2,j)=zero
            end do
          end if
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 290
        case (24) ! DIPEDGE ELEMENT
#include "include/stra2dpe.f90"
          ktrack(i) = 55
        case (25) ! Solenoid
#include "include/solenoid.f90"
          ktrack(i) = 56
          
        !----------------
        !--Negative KZZ--
        !----------------
        case (-1)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 21
#include "include/stra01.f90"
          end if
        case (-2)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 22
#include "include/stra02.f90"
          end if
        case (-3)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 23
#include "include/stra03.f90"
          end if
        case (-4)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 24
#include "include/stra04.f90"
          end if
        case (-5)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 25
#include "include/stra05.f90"
          end if
        case (-6)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 26
#include "include/stra06.f90"
          end if
        case (-7)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 27
#include "include/stra07.f90"
          end if
        case (-8)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 28
#include "include/stra08.f90"
          end if
        case (-9)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 29
#include "include/stra09.f90"
          end if
        case (-10)
          if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
            ktrack(i) = 31
          else
            ktrack(i) = 30
#include "include/stra10.f90"
          end if
        case default
          ktrack(i)=31
        end select
        
  290 continue
      do j=1,napx
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
      end do
      nwri=nwr(3)
      if(nwri.eq.0) nwri=(numl+numlr)+1                                  !hr01

!     A.Mereghetti, for the FLUKA Team
!     K.Sjobak, BE-ABP-HSS
!     last modified: 24-02-2015
!     save original kicks
!     always in main code
      if (ldynk) call dynk_pretrack

#ifdef COLLIMAT
      if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then
#endif
#ifndef COLLIMAT
      if(idp.eq.0.or.ition.eq.0) then
#endif
        write(lout,*) ''
        write(lout,*) 'Calling thin4d subroutine'
        write(lout,*) ''
        call thin4d(nthinerr)
      else
#ifdef COLLIMAT
        if (idp.eq.0.or.ition.eq.0) then
           write(lout,*) ""
           write(lout,*) "******* WARNING *******"
           write(lout,*) "Calling 6D tracking due to collimation!"
           write(lout,*) "Would normally have called thin4d"
           write(lout,*) ""
        endif
#endif

        hsy(3)=(c1m3*hsy(3))*real(ition,fPrec)                            !hr01
        do 310 jj=1,nele
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*                    &
     &     real(itionc(jj),fPrec)     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(lout,"(a)") "TRACKING> ERROR thin6dua no longer supported. Please use DYNK instead."
          call prror(-1)
        else
#ifdef COLLIMAT
          call collimate_init()
!================================================================================
!Ralph make loop over 1e6/napx, a read xv(1,j) etc
!Du solltest zur Sicherheit dies resetten bevor Du in thin6d gehst
!Im Falle von Teilchenverluste werden n mlich pstop und nnumxv umgesetzt
!      do 80 i=1,npart
!        pstop(i)=.false.
!        nnumxv(i)=numl
!   80 numxv(i)=numl
!================================================================================
          do j = 1, int(mynp/napx00)
            write(lout,*) 'Sample number ', j, int(mynp/napx00)

            call collimate_start_sample(j)

            write(lout,*) ''
            write(lout,*) 'Calling thin6d subroutine'
            write(lout,*) ''
            call thin6d(nthinerr)

            call collimate_end_sample(j)

          end do
#endif
#ifndef COLLIMAT
          write(lout,*) ''
          write(lout,*) 'Calling thin6d subroutine'
          write(lout,*) ''
          call thin6d(nthinerr)
#endif
        endif !end if(abs(phas).ge.pieni) then
      endif !end if((idp.eq.0.or.ition.eq.0) .and. .not.do_coll) then ... else
#ifdef COLLIMAT
      call collimate_exit()
#endif
  return
      
end subroutine trauthin

!>
!!  TRACK THIN LENS 4D
!!  F. SCHMIDT
!<
subroutine thin4d(nthinerr)
  ! Replaced computed goto with select case. VKBO 27/11/2017
  
  use floatPrecision
  use end_sixtrack
  use string_tools
  use physical_constants
  use numerical_constants
  use mathlib_bouncer
  use dynk, only : ldynk, dynk_apply
  use dump, only : dump_linesFirst, dump_lines, ldumpfront
  use aperture
  
#ifdef FLUKA
  ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
  ! last modified: 17-07-2013
  ! import mod_fluka
  ! inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif

  use mod_hions

  use postprocessing, only : writebin
  use crcoall
  use parpro
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  use bdex, only : bdex_enable
  use aperture
  use elens
  use wire
  
  implicit none

  real(kind=fPrec) pz
  integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
  real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,crxb,crzb,dpsv3,pux,&
          r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
  integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
  real(kind=fPrec) e0fo,e0o,xv1j,xv2j
  real(kind=fPrec) acdipamp, qd, acphase, acdipamp2,acdipamp1, crabamp, crabfreq, kcrab
  real(kind=fPrec) RTWO !RTWO=x^2+y^2
  real(kind=fPrec) NNORM_, NNORM
  real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi
logical llost
  
+ca beamdim

#ifdef CR
+ca crco
#endif

  dimension dpsv3(npart)

  real(kind=fPrec) :: rrelens,frrelens,r1elens,xelens,yelens

  save
!-----------------------------------------------------------------------
  nthinerr=0

  ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
  ! last modified: 24-11-2016
  ! initialise variables for back-tracking particles
  if (lbacktracking) call aperture_backTrackingInit

#ifdef FLUKA
  ! A.Mereghetti, for the FLUKA Team
  ! last modified: 14-06-2014
  ! initialise napxto
  ! inserted in main code by the 'fluka' compilation flag
  napxto = 0
#endif

#ifdef CR
  if (restart) then
    call crstart
    write(93,*) 'THIN4D SIXTRACR restart numlcr',numlcr,'numl',numl
  end if
! and now reset numl to do only numlmax turns
  nnuml=min((numlcr/numlmax+1)*numlmax,numl)
  write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
  if (nnuml.ne.numl) then
    do j=1,napx
      if (numxv(j).eq.numl) numxv(j)=nnuml
      if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
    end do
  end if
  do 640, n=numlcr,nnuml
#endif
#ifndef CR
  do 640 n=1,numl !loop over turns
#endif
#ifdef BOINC
    ! call boinc_sixtrack_progress(n,numl)
    call boinc_fraction_done(dble(n)/dble(numl))
    continue
    ! call graphic_progress(n,numl)
#endif
    numx=n-1

#ifndef FLUKA
    if(mod(numx,nwri).eq.0) call writebin(nthinerr)
    if(nthinerr.ne.0) return
#endif

#ifdef CR
    ! does not call CRPOINT if restart=.true.
    ! (and note that writebin does nothing if restart=.true.
    if(mod(numx,numlcp).eq.0) call callcrp()
    restart=.false.
#endif

    ! A.Mereghetti, for the FLUKA Team
    ! last modified: 03-09-2014
    ! apply dynamic kicks
    ! always in main code
    if ( ldynk ) then
      call dynk_apply(n)
    end if
    call dump_linesFirst(n)
        
    ! loop over structure elements, single element: name + type + parameter,
    ! structure element = order of single elements/blocks
    do 630 i=1,iu
      ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
      ! as no dependency on ix in this case.
      ix=ic(i)-nblo ! ix = index of single element
!Should this be inside "if ktrack .ne. 1"? (time)

      if (ldumpfront) then
        call dump_lines(n,i,ix)
      end if

#ifdef FLUKA
      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! is the current entry an instance of a FLUKA element?
      ! inserted in main code by the 'fluka' compilation flag
      if (fluka_enable) then
        if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                !      be SINGLE ELEMENTs
          if(fluka_type(ix).ne.FLUKA_NONE) then
            if(fluka_type(ix).eq.FLUKA_ELEMENT) then
              call kernel_fluka_element( n, i, ix )
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 620
            else if(fluka_type(ix).eq.FLUKA_ENTRY) then
              fluka_inside = .true.
              call kernel_fluka_entrance( n, i, ix )
              goto 625
            else if(fluka_type(ix).eq.FLUKA_EXIT) then
              fluka_inside = .false.
              call kernel_fluka_exit( n, i, ix )
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 620
            end if
          end if
        end if
        if(fluka_inside) then
          if(fluka_debug) then
            write(lout,*) '[Fluka] Skipping lattice element at ', i
            write(fluka_log_unit,*) '# Skipping lattice element at ', i
          end if
          goto 630
        end if
      end if
#endif

          if (bdex_enable) then
             write(lout,*) "BDEX> BDEX only available for thin6d"
             call prror(-1)
          endif

      select case (ktrack(i))
      case (1)
        stracki=strack(i) 
        if(iexact.eq.0) then ! exact drift?
          do j=1,napx
            xv(1,j)=xv(1,j)+stracki*yv(1,j)
            xv(2,j)=xv(2,j)+stracki*yv(2,j)
          end do
        else
          do j=1,napx
            xv(1,j)=xv(1,j)*c1m3
            xv(2,j)=xv(2,j)*c1m3
            yv(1,j)=yv(1,j)*c1m3
            yv(2,j)=yv(2,j)*c1m3
            pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
            xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
            xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
            xv(1,j)=xv(1,j)*c1e3
            xv(2,j)=xv(2,j)*c1e3
            yv(1,j)=yv(1,j)*c1e3
            yv(2,j)=yv(2,j)*c1e3
          enddo
        end if
        ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
        ! last modified: 07-03-2018
        ! store old particle coordinates
        if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
        goto 630
      case (3)
        irrtr=imtr(ix)
        do j=1,napx
            !The values are stored in the temp vector which are used for the multiplication.
          temptr(1)=xv(1,j)
          temptr(2)=yv(1,j)/moidpsv(j)
          temptr(3)=xv(2,j)
          temptr(4)=yv(2,j)/moidpsv(j)
          temptr(5)=sigmv(j)
          temptr(6)=((mtc(j)*ejv(j)-e0)/e0f)*c1e3*(e0/e0f)
          ! Adding the closed orbit. The previous values are stored in the temptr vector.   
          xv(1,j)  = cotr(irrtr,1)
          yv(1,j)  = cotr(irrtr,2)
          xv(2,j)  = cotr(irrtr,3)
          yv(2,j)  = cotr(irrtr,4)
          sigmv(j) = cotr(irrtr,5)
          pttemp   = cotr(irrtr,6)

          ! Multiplying the arbitrary matrix to the coordinates. 
          do kxxa=1,6
            xv(1,j)   =  xv(1,j)+temptr(kxxa)*rrtr(irrtr,1,kxxa)
            yv(1,j)   =  yv(1,j)+temptr(kxxa)*rrtr(irrtr,2,kxxa) 
            xv(2,j)   =  xv(2,j)+temptr(kxxa)*rrtr(irrtr,3,kxxa) 
            yv(2,j)   =  yv(2,j)+temptr(kxxa)*rrtr(irrtr,4,kxxa) 
            sigmv(j)  =  sigmv(j)+temptr(kxxa)*rrtr(irrtr,5,kxxa)        
            pttemp    =  pttemp+temptr(kxxa)*rrtr(irrtr,6,kxxa)        
          enddo
          ! Transforming back to the tracked coordinates of Sixtrack...
          ejv(j)  = (e0f*pttemp/(c1e3*(e0/e0f))+e0)/mtc(j)
          

          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)

          
          ! We have to go back to angles after we updated the energy. 
          yv(j,1) = yv(j,1)*mtc(j)/(one+dpsv(j))
          yv(j,2) = yv(j,2)*mtc(j)/(one+dpsv(j))
          !yv(j,1) = yv(j,1)*moidpsv(j)
          !yv(j,2) = yv(j,2)*moidpsv(j)
        enddo
      goto 620
      case (2,4,5,6,7,8,9,10)
        goto 630
      case (11) ! HORIZONTAL DIPOLE
        do j=1,napx
#include "include/kickv01h.f90"
        end do
        goto 620
      case (12) ! NORMAL QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (13) ! NORMAL SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (14) ! NORMAL OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (15) ! NORMAL DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (16) ! NORMAL DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (17) ! NORMAL 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (18) ! NORMAL 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (19) ! NORMAL 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (20) ! NORMAL 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 620
      case (21) ! VERTICAL DIPOLE
        do j=1,napx
#include "include/kickv01v.f90"
        end do
        goto 620
      case (22) ! SKEW QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (23) ! SKEW SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (24) ! SKEW OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (25) ! SKEW DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (26) ! SKEW DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (27) ! SKEW 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (28) ! SKEW 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (29) ! SKEW 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (30) ! SKEW 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 620
      case (31)
        goto 620
      case (32)
        goto 390
      case (33)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
        end do
        goto 620
      case (34)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
        end do
        goto 390
      case (35)
        do j=1,napx
#include "include/mul4v02.f90"
        end do
        goto 620
      case (36)
        do j=1,napx
#include "include/mul4v02.f90"
        end do
        goto 390
      case (37)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
        end do
        goto 620
      case (38)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
        end do
        goto 390
      case (39)
        do j=1,napx
#include "include/mul4v04.f90"
        end do
        goto 620
      case (40)
        do j=1,napx
#include "include/mul4v04.f90"
        end do
        goto 390
      case (41)
        goto 680
      case (42)
        if(ibtyp.eq.0) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4.f90"
        end if
        goto 620
      case (43)
        if(ibtyp.eq.0) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4.f90"
        end if
        goto 620
      case (44,46,47,48,49,50,57,58,59,60,61,62)
        goto 630
      case (45) ! Wire
#include "include/wirekick.f90"
        goto 620
      case (51)
        xory=1
#include "include/acdipkick.f90"
        goto 620
      case (52)
        xory=2
#include "include/acdipkick.f90"
        goto 620
      case (53)
        xory=1
#include "include/crabkick.f90"
        goto 620
      case (54)
        xory=2
#include "include/crabkick.f90"
        goto 620
      case (55) ! DIPEDGE ELEMENT
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvdpe.f90"
        end do
        goto 620
      case (56) ! Solenoid
        do j=1,napx
#include "include/kickvso1.f90"
        end do
        goto 620
      case (63) ! Elens
        do j=1,napx
#include "include/kickelens.f90"
        end do
        goto 620
      end select
      goto 630

390   r0=ek(ix)
      nmz=nmu(ix)
      if(nmz.ge.2) then
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v05.f90"
          do k=3,nmz
#include "include/mul4v06.f90"
          end do
#include "include/mul4v07.f90"
        end do
      else
        do j=1,napx
#include "include/mul4v08.f90"
        end do
      end if
      goto 620

680   continue
      do 690 j=1,napx
#include "include/beamco.f90"
#include "include/beamr1.f90"
     &goto 690
#include "include/beamr2.f90"
#include "include/beamr3.f90"
690   continue
      goto 620
        
!----------------------------
620 continue

      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! on-line aperture check
      ! always in main code
      call lostpart( n, i, ix, llost, nthinerr )
      ! stop tracking if no particle survives to this element
      if(nthinerr.ne.0) return
      ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
      ! last modified: 07-03-2018
      ! store infos of last aperture marker
      if ( lbacktracking.and.kape(ix).ne.0 ) call aperture_saveLastMarker(i,ix)

625 continue
    if (.not. ldumpfront) then
      call dump_lines(n,i,ix)
    end if

630 continue

    if(nthinerr.ne.0) return
    if(ntwin.ne.2) call dist1
#ifndef FLUKA
    if(mod(n,nwr(4)).eq.0) call write6(n)
#endif

#ifdef FLUKA
  ! A.Mereghetti, for the FLUKA Team
  ! last modified: 14-06-2014
  ! increase napxto, to get an estimation of particles*turns
  ! inserted in main code by the 'fluka' compilation flag
  napxto = napxto + napx
#endif

  640 continue
  
  return
  
end subroutine thin4d

!>
!!  TRACK THIN LENS 6D
!!  F. SCHMIDT
!<
subroutine thin6d(nthinerr)
  ! Replaced computed gotos with select case, VKBO 27/11/2017
  use floatPrecision
  use end_sixtrack
  use string_tools
  use physical_constants
  use numerical_constants
  use mathlib_bouncer

  use bdex, only : bdex_elementAction, bdex_track, bdex_enable
  use scatter, only : scatter_thin, scatter_debug
  use dynk, only : ldynk, dynk_apply
  use dump, only : dump_linesFirst, dump_lines, ldumpfront
  use aperture

#ifdef BEAMGAS
! <b>Additions/modifications:</b>
! - YIL: Added call to beamGas subroutine if element name starts with 
!   'press' or 'PRESS' (only for first turn)
! - YIL: Added call to beamGasInit just after readcollimator
#endif

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif

  use mod_hions

#ifdef COLLIMAT
  use collimation
#endif

  use postprocessing, only : writebin
  use crcoall
  use parpro
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  use aperture
  use elens
  use wire
  implicit none

  real(kind=fPrec) pz
  integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr,dotrack
  real(kind=fPrec) c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,crxb,crzb,&
          dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
  integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
  real(kind=fPrec) e0fo,e0o,xv1j,xv2j
  real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,acdipamp1,crabamp,crabfreq,crabamp2,crabamp3,crabamp4,kcrab
  real(kind=fPrec) RTWO !RTWO=x^2+y^2
  real(kind=fPrec) NNORM_, NNORM
  real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi
logical llost
  

+ca beamdim

#ifdef COLLIMAT
!+ca collpara
+ca dbcommon
+ca dbthin6d
+ca database
!+ca dblinopt
+ca dbpencil
!+ca info
+ca dbcolcom
#endif

#ifdef CR
+ca crco
#endif
  dimension dpsv3(npart)

  real(kind=fPrec) :: rrelens,frrelens,r1elens,xelens,yelens
  save

#ifdef FAST
  c5m4=5.0e-4_fPrec
#endif
  nthinerr=0

  ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
  ! last modified: 24-11-2016
  ! initialise variables for back-tracking particles
  if (lbacktracking) call aperture_backTrackingInit

#ifdef FLUKA
  ! A.Mereghetti, for the FLUKA Team
  ! last modified: 14-06-2014
  ! initialise napxto
  ! inserted in main code by the 'fluka' compilation flag
  napxto = 0
#endif

! This is the loop over turns: label 660
#ifdef CR
  if (restart) then
    call crstart
    write(93,*) 'THIN6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
  end if
  ! and now reset numl to do only numlmax turns
  nnuml=min((numlcr/numlmax+1)*numlmax,numl)
  write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
  ! and reset [n]numxv unless particle is lost
  ! TRYing Eric (and removing postpr fixes).
  if (nnuml.ne.numl) then
    do j=1,napx
      if (numxv(j).eq.numl) numxv(j)=nnuml
      if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
    end do
  end if
  
  do 660 n=numlcr,nnuml ! Loop over turns, CR version
#endif
#ifndef CR
  do 660 n=1,numl       ! Loop over turns
#endif
#ifdef BOINC
    ! call boinc_sixtrack_progress(n,numl)
    call boinc_fraction_done(dble(n)/dble(numl))
    continue
    ! call graphic_progress(n,numl)
#endif
#ifdef COLLIMAT
    call collimate_start_turn(n)
#endif
    numx=n-1

#ifndef FLUKA
    if(mod(numx,nwri).eq.0) call writebin(nthinerr)
    if(nthinerr.ne.0) return
#endif

#ifdef CR
    ! does not call CRPOINT if restart=.true.
    ! (and note that writebin does nothing if restart=.true.
    if(mod(numx,numlcp).eq.0) call callcrp()
    restart=.false.
#endif
    
    ! A.Mereghetti, for the FLUKA Team
    ! last modified: 03-09-2014
    ! apply dynamic kicks
    ! always in main code
    if ( ldynk ) then
      call dynk_apply(n)
    end if

    call dump_linesFirst(n)

!! This is the loop over each element: label 650
    do 650 i=1,iu !Loop over elements
#ifdef COLLIMAT
      call collimate_start_element(i)
#endif
      ! No if(ktrack(i).eq.1) - a BLOC - is needed in thin tracking,
      ! as no dependency on ix in this case.
      ix=ic(i)-nblo

#ifdef BEAMGAS
!YIL Call beamGas subroutine whenever a pressure-element is found
! should be faster/safer to first check the turn then do the name search
      if( iturn.eq.1 ) then
        if (bez(myix)(1:5).eq.'PRESS' .or.  bez(myix)(1:5).eq.'press' ) then
          call beamGas(myix, secondary,totals,myenom,ipart)
        end if
      end if
#endif

!Should this be inside "if ktrack .ne. 1"? (time)
      
      if (ldumpfront) then
        call dump_lines(n,i,ix)
      end if
      
#ifdef FLUKA
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         is the current entry an instance of a FLUKA element?
!         inserted in main code by the 'fluka' compilation flag
      if (fluka_enable) then
        if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                !      be SINGLE ELEMENTs
          if(fluka_type(ix).ne.FLUKA_NONE) then
            if(fluka_type(ix).eq.FLUKA_ELEMENT) then
              call kernel_fluka_element( n, i, ix )
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 640
            else if(fluka_type(ix).eq.FLUKA_ENTRY) then
              fluka_inside = .true.
              call kernel_fluka_entrance( n, i, ix )
              goto 645
            else if(fluka_type(ix).eq.FLUKA_EXIT) then
              fluka_inside = .false.
              call kernel_fluka_exit( n, i, ix )
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 640
            end if
          end if
        end if
        if(fluka_inside) then
          if(fluka_debug) then
            write(lout,*) '[Fluka] Skipping lattice element at ', i
            write(fluka_log_unit,*) '# Skipping lattice element at ', i
          end if
          goto 650
        end if
      end if
#endif

#ifndef COLLIMAT
!---------count:44
      ! JBG RF CC Multipoles
      ! JBG adding CC multipoles elements in tracking. ONLY in thin6d!!!
      !     JBG 755 -RF quad, 756 RF Sext, 757 RF Oct
      dotrack = ktrack(i)
#ifdef DEBUG
!         if (n.eq.1) then
!           write (93,*) 'ktrack(i)=',ktrack(i)
!           endfile (93,iostat=ierro)
!           backspace (93,iostat=ierro)
!         endif
#endif

!          if( bdex_enable .and. kz(ix).eq.0 .and. bdex_elementAction(ix).ne.0 ) then
!             call bdex_track(i,ix,n)
!          end if
#endif
#ifdef COLLIMAT
      dotrack = myktrack
#endif

      select case(dotrack)
      case (1)
        stracki=strack(i)
#ifdef COLLIMAT

!==========================================
!Ralph drift length is stracki
!bez(ix) is name of drift
        totals=totals+stracki
!          write(*,*) 'ralph> Drift, total length: ', stracki,totals

!________________________________________________________________________
!++  If we have a collimator then...
!
!Feb2006
!GRD (June 2005) 'COL' option is for RHIC collimators
!
!     SR (17-01-2006): Special assignment to the TCS.TCDQ for B1 and B4,
!     using the new naming as in V6.500.
!     Note that this must be in the loop "if TCSG"!!
!
!     SR, 17-01-2006: Review the TCT assignments because the MADX names
!     have changes (TCTH.L -> TCTH.4L)
!
! JULY 2008 added changes (V6.503) for names in TCTV -> TCTVA and TCTVB 
! both namings before and after V6.503 can be used 
!
        if (do_coll.and.(bez(myix)(1:2).eq.'TC'  &
                    .or. bez(myix)(1:2).eq.'tc'  &
                    .or. bez(myix)(1:2).eq.'TD'  &
                    .or. bez(myix)(1:2).eq.'td'  &
                    .or. bez(myix)(1:3).eq.'COL' &
                    .or. bez(myix)(1:3).eq.'col')) then

          call collimate_start_collimator(stracki)

!++ For known collimators
          if(found) then
            call collimate_do_collimator(stracki)
            call collimate_end_collimator()
          end if ! end of check for 'found'
!------------------------------------------------------------------
!++  Here leave the known collimator IF loop...
!_______________________________________________________________________
!++  If it is just a drift...
          else
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
#ifdef FAST
              sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
#else
              sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt(c1e6+yv(1,j)*yv(1,j)+yv(2,j)*yv(2,j)))
#endif
              xj     = (xv(1,j)-torbx(ie))/c1e3
              xpj    = (yv(1,j)-torbxp(ie))/c1e3
              yj     = (xv(2,j)-torby(ie))/c1e3
              ypj    = (yv(2,j)-torbyp(ie))/c1e3
              pj     = ejv(j)/c1e3

              if(firstrun) then
                if (iturn.eq.1.and.j.eq.1) then
                  sum_ax(ie)=zero
                  sum_ay(ie)=zero
                end if
              end if

              gammax = (one + talphax(ie)**2)/tbetax(ie)
              gammay = (one + talphay(ie)**2)/tbetay(ie)

              if (part_abs_pos(j).eq.0 .and. part_abs_turn(j).eq.0) then
                nspx    = sqrt(abs(gammax*(xj)**2 + two*talphax(ie)*xj*xpj + tbetax(ie)*xpj**2)/myemitx0_collgap)
                nspy    = sqrt(abs(gammay*(yj)**2 + two*talphay(ie)*yj*ypj + tbetay(ie)*ypj**2)/myemity0_collgap)
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
              else
                nspx = zero
                nspy = zero
              end if
              sampl(ie)    = totals
              ename(ie)    = bez(myix)(1:max_name_len)
            end do
          endif
!GRD END OF THE CHANGES FOR COLLIMATION STUDIES, BACK TO NORMAL SIXTRACK STUFF
#endif
#ifndef COLLIMAT
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
#ifdef FAST
              sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)**2+yv(2,j)**2)*c5m4))
#else
              sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*sqrt((c1e6+yv(1,j)**2)+yv(2,j)**2))
#endif
            end do
          else
            ! EXACT DRIFT
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              sigmv(j)=sigmv(j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              sigmv(j)=sigmv(j)+stracki*(one-(rvv(j)/pz))
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
              sigmv(j)=sigmv(j)*c1e3
            enddo
          end if
#endif
          ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
          ! last modified: 07-03-2018
          ! store old particle coordinates
          ! NB: end up here in case of collimators too, but not in
          !     in case of an aperture marker or other null-length non-active
          !     elements, thanks to trauthin/trauthck and
          !     if(abs(strack(i)).le.pieni) ktrack(i)=31
          if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
          goto 650

      case (2)
        do j=1,napx
          ejf0v(j)=ejfv(j)
          if(abs(dppoff).gt.pieni) then 
            sigmv(j)=sigmv(j)-sigmoff(i)
          endif
          if(kz(ix).eq.12) then
            ejv(j)=ejv(j)+(ed(ix)*sin_mb(hsyc(ix)*sigmv(j)+phasc(ix)))*nzz(j)
          else
            ejv(j)=ejv(j)+(hsy(1)*sin_mb(hsy(3)*sigmv(j)))*nzz(j)
          endif
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)                               !hr01
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j) = (ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
!          dpsv(j)=(ejfv(j)-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          omoidpsv(j)=c1e3*((one-mtc(j))*oidpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)                           !hr01
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
        end do
        if(n.eq.1) write(98,'(1p,6(2x,e25.18))') (xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
        goto 640
      case (3)
        irrtr=imtr(ix)
        do j=1,napx
            !The values are stored in the temp vector which are used for the multiplication.
          temptr(1)=xv(1,j)
          temptr(2)=yv(1,j)/moidpsv(j)
          temptr(3)=xv(2,j)
          temptr(4)=yv(2,j)/moidpsv(j)
          temptr(5)=sigmv(j)
          temptr(6)=((mtc(j)*ejv(j)-e0)/e0f)*c1e3*(e0/e0f)
          ! Adding the closed orbit. The previous values are stored in the temptr vector.   
          xv(1,j)  = cotr(irrtr,1)
          yv(1,j)  = cotr(irrtr,2)
          xv(2,j)  = cotr(irrtr,3)
          yv(2,j)  = cotr(irrtr,4)
          sigmv(j) = cotr(irrtr,5)
          pttemp   = cotr(irrtr,6)

          ! Multiplying the arbitrary matrix to the coordinates. 
          do kxxa=1,6
            xv(1,j)   =  xv(1,j)+temptr(kxxa)*rrtr(irrtr,1,kxxa)
            yv(1,j)   =  yv(1,j)+temptr(kxxa)*rrtr(irrtr,2,kxxa) 
            xv(2,j)   =  xv(2,j)+temptr(kxxa)*rrtr(irrtr,3,kxxa) 
            yv(2,j)   =  yv(2,j)+temptr(kxxa)*rrtr(irrtr,4,kxxa) 
            sigmv(j)  =  sigmv(j)+temptr(kxxa)*rrtr(irrtr,5,kxxa)        
            pttemp    =  pttemp+temptr(kxxa)*rrtr(irrtr,6,kxxa)        
          enddo
          ! Transforming back to the tracked coordinates of Sixtrack...
          ejv(j)  = (e0f*pttemp/(c1e3*(e0/e0f))+e0)/mtc(j)
          

          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)

          
          ! We have to go back to angles after we updated the energy. 
          yv(j,1) = yv(j,1)*mtc(j)/(one+dpsv(j))
          yv(j,2) = yv(j,2)*mtc(j)/(one+dpsv(j))
          !yv(j,1) = yv(j,1)*moidpsv(j)
          !yv(j,2) = yv(j,2)*moidpsv(j)
        enddo
        goto 640
      case (4,5,6,7,8,9,10)
        goto 650
      case (11) ! HORIZONTAL DIPOLE
        do j=1,napx
#include "include/kickv01h.f90"
        end do
        goto 640
      case (12) ! NORMAL QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (13) ! NORMAL SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (14) ! NORMAL OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (15) ! NORMAL DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (16) ! NORMAL DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (17) ! NORMAL 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (18) ! NORMAL 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (19) ! NORMAL 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (20) ! NORMAL 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 640
      case (21) ! VERTICAL DIPOLE
        do j=1,napx
#include "include/kickv01v.f90"
        end do
        goto 640
      case (22) ! SKEW QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (23) ! SKEW SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (24) ! SKEW OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (25) ! SKEW DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (26) ! SKEW DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (27) ! SKEW 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (28) ! SKEW 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (29) ! SKEW 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (30) ! SKEW 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 640
      case (31)
        goto 640
      case (32)
        goto 410
      case (33)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
#include "include/mul6v01.f90"
        end do
        goto 640
      case (34)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
#include "include/mul6v01.f90"
        end do
        goto 410
      case (35)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v02.f90"
#include "include/mul6v01.f90"
        end do
        goto 640
      case (36)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v02.f90"
#include "include/mul6v01.f90"
        end do
        goto 410
      case (37)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
#include "include/mul6v02.f90"
        end do
        goto 640
      case (38)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
#include "include/mul6v02.f90"
        end do
        goto 410
      case (39)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v04.f90"
#include "include/mul6v02.f90"
        end do
        goto 640
      case (40)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v04.f90"
#include "include/mul6v02.f90"
        end do
        goto 410
      case (41) ! 4D BB kick
        do 690 j=1,napx
#include "include/beamco.f90"
#include "include/beamr1.f90"
       &goto 690 !The radius was too small -> Skip
#include "include/beamr2.f90"
#include "include/beamr3.f90"
690     continue
        goto 640
      case (42)
        if(ibtyp.eq.0) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then ! fast kick
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4.f90"
        end if
        goto 640
      case (43)
        if(ibtyp.eq.0) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4.f90"
        end if
        goto 640
      case (44)
#include "include/beam6d.f90"
        goto 640
      case (45) ! Wire
#include "include/wirekick.f90"
        goto 640
      case (46,47,48,49,50)
        goto 650
      case (51)
        xory=1
#include "include/acdipkick.f90"
        goto 640
      case (52)
        xory=2
#include "include/acdipkick.f90"
        goto 640
      case (53)
        xory=1
#include "include/crabkick.f90"
        goto 640
      case (54)
        xory=2
#include "include/crabkick.f90"
        goto 640
      case (55) ! DIPEDGE ELEMENT
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvdpe.f90"
        end do
        goto 640
      case (56) ! Solenoid
        do j=1,napx
#include "include/kickvso1.f90"
#include "include/kickvso2.f90"
        end do
        goto 640
      case (57) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp2 = ed(ix)*nzz(j)
          kcrab=(((sigmv(j)/(clight*(e0f/e0)))*crabfreq)*two)*pi + crabph2(ix)
#include "include/alignva.f90"
          yv(1,j)=yv(1,j) + ((crabamp2*crkve)*moidpsv(j))*cos_mb(kcrab)
          yv(2,j)=yv(2,j) - ((crabamp2*cikve)*moidpsv(j))*cos_mb(kcrab)
          ejv(j)=ejv(j) - ((((half*(crabamp2))*(crkve**2-cikve**2))*(((crabfreq*two)*pi)/clight))*c1m3)*(sin_mb(kcrab)*e0f)
          ejf0v(j)=ejfv(j)
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640
      case (58) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp2 = ed(ix)*nzz(j)
          kcrab=(((sigmv(j)/(clight*(e0f/e0)))*crabfreq)*two)*pi + crabph2(ix)
#include "include/alignva.f90"
          yv(2,j)=yv(2,j) + ((crabamp2*crkve)*moidpsv(j))*cos_mb(kcrab)
          yv(1,j)=yv(1,j) + ((crabamp2*cikve)*moidpsv(j))*cos_mb(kcrab)
          ejv(j)=ejv(j) - ((((crabamp2)*(cikve*crkve))*(((crabfreq*two)*pi)/clight))*c1m3)*(sin_mb(kcrab)*e0f)
          ejf0v(j)=ejfv(j)
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640
      case (59) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp3 = ed(ix)*nzz(j)
          kcrab=((sigmv(j)*crabfreq)/(clight*(e0f/e0)))*(two*pi)+crabph3(ix)
#include "include/alignva.f90"
          yv(1,j)=yv(1,j)+(((crabamp3*moidpsv(j))*c1m3)*(crkve**2-cikve**2))*cos_mb(kcrab)
          yv(2,j)=yv(2,j)-((two*(((crabamp3*crkve)*cikve)*moidpsv(j)))*c1m3)*cos_mb(kcrab)
          ejv(j)=ejv(j)-(((((one/three)*(crabamp3))*(crkve**3-(three*cikve**2)*crkve))&
                *(((crabfreq*two)*pi)/clight)*c1m6)*sin_mb(kcrab))*e0f
          ejf0v(j)=ejfv(j)
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640 
      case (60) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp3 = ed(ix)*nzz(j)
          kcrab=(((sigmv(j)/(clight*(e0f/e0)))*crabfreq)*two)*pi + crabph3(ix)
#include "include/alignva.f90"
          yv(2,j)=yv(2,j)-(((crabamp3*moidpsv(j))*c1m3)*((cikve**2)-(crkve**2)))*cos_mb(kcrab)
          yv(1,j)=yv(1,j)+((two*(crabamp3*(crkve*(cikve*oidpsv(j)))))*c1m3)*cos_mb(kcrab)
          ejv(j)=ejv(j)+(((((one/three)*(crabamp3))*(cikve**3- &
                ((three*crkve**2)*cikve)))*(((crabfreq*two)*pi)/clight))*c1m6)*(sin_mb(kcrab)*e0f)
          ejf0v(j)=ejfv(j)
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640 
      case (61) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp4 = ed(ix)*nzz(j)
          kcrab=(((sigmv(j)/(clight*(e0f/e0)))*crabfreq)*two)*pi + crabph4(ix)
#include "include/alignva.f90"
          yv(1,j)=yv(1,j) + (((crabamp4*moidpsv(j))*(crkve**3-(three*crkve)*cikve**2))*c1m6)*cos_mb(kcrab)
          yv(2,j)=yv(2,j) - (((crabamp4*moidpsv(j))*((three*cikve)*crkve**2-cikve**3))*c1m6)*cos_mb(kcrab)
          ejv(j)=ejv(j) - ((((0.25_fPrec*(crabamp4))*(crkve**4-(six*crkve**2)*cikve**2+cikve**4))&
                *(((crabfreq*two)*pi)/clight))*c1m9)*(sin_mb(kcrab)*e0f)
        ejf0v(j)=ejfv(j)
        ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
        rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
        oidpsv(j)=one/(one+dpsv(j))
        moidpsv(j)=mtc(j)/(one+dpsv(j))
        dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
        yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
        yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
        if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640
      case (62) ! JBG RF CC Multipoles
        xory=1
        pi=four*atan_mb(one)
        crabfreq=ek(ix)*c1e3
        do j=1,napx
          crabamp4 = ed(ix)*nzz(j)
          kcrab=(((sigmv(j)/(clight*(e0f/e0)))*crabfreq)*two)*pi + crabph4(ix)
#include "include/alignva.f90"
          yv(1,j)=yv(1,j) + (((crabamp4*moidpsv(j))*(cikve**3-(three*cikve)*crkve**2))*c1m6)*cos_mb(kcrab)
          yv(2,j)=yv(2,j) + (((crabamp4*moidpsv(j))*((three*crkve)*cikve**2-crkve**3))*c1m6)*cos_mb(kcrab)
          ejv(j)=ejv(j) - ((((crabamp4)*((crkve**3*cikve)-(cikve**3*crkve)))*(((crabfreq*two)*pi)/clight))*c1m9)*(sin_mb(kcrab)*e0f)
          ejf0v(j)=ejfv(j)
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
          if(ithick.eq.1) call envarsv(dpsv,moidpsv,rvv,ekv)
        end do
        goto 640
      case (63) ! Elens
        do j=1,napx
#include "include/kickelens.f90"
        end do
        goto 640
      case (64) ! Scatter (thin)
        !Thin scattering
        ! It is already checked that scatter_elemPointer != 0
        call scatter_thin(i, ix,n)
        goto 640
      case (65) ! Scatter (thick)
        !Thick scattering
        if (scatter_debug) then
          write(lout,*) "SCATTER> In scat_tck, ix=",ix, "bez='"//trim(bez(ix))//"' napx=",napx, "turn=",n
        endif
        !     TODO
        goto 640
      case default
        write (lout,*) "WARNING: Non-handled element in thin6d()!",  &
                       " i=", i, "ix=", ix, "myktrack=",  dotrack,   &
                       " bez(ix)='", bez(ix),"' SKIPPED"
      end select
      goto 650

410   r0=ek(ix)
      nmz=nmu(ix)
      if(nmz.ge.2) then
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v05.f90"
          do k=3,nmz
#include "include/mul4v06.f90"
          end do
#include "include/mul4v07.f90"
        end do
      else
        do j=1,napx
#include "include/mul4v08.f90"
        end do
      end if

#ifdef COLLIMAT
! end of the loop over element type (myktrack and ktrack(i))
#endif
640   continue
!GRD UPGRADE JANUARY 2005
#ifdef COLLIMAT
      call collimate_end_element
#endif
!GRD END OF UPGRADE

      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! on-line aperture check
      ! always in main code
      call lostpart( n, i, ix, llost, nthinerr )
      ! stop tracking if no particle survives to this element
      if(nthinerr.ne.0) return
      ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
      ! last modified: 07-03-2018
      ! store infos of last aperture marker
      if ( lbacktracking.and.kape(ix).ne.0 ) call aperture_saveLastMarker(i,ix)

645   continue

      if (.not. ldumpfront) then
        call dump_lines(n,i,ix)
      end if

650 continue !END loop over structure elements

#ifdef COLLIMAT
    call collimate_end_turn
#endif

    if(nthinerr.ne.0) return

#ifndef COLLIMAT
    if(ntwin.ne.2) call dist1
#ifndef FLUKA
    if(mod(n,nwr(4)).eq.0) call write6(n)
#endif
#endif

#ifdef FLUKA
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     increase napxto, to get an estimation of particles*turns
!     inserted in main code by the 'fluka' compilation flag
    napxto = napxto + napx
#endif

#ifdef COLLIMAT
!GRD HERE WE SET THE FLAG FOR INITIALIZATION TO FALSE AFTER TURN 1
  firstrun = .false.
#endif

660 continue !END loop over turns

#ifdef COLLIMAT
  close(99)
  close(53)

#endif
  
  return
  
end subroutine thin6d

subroutine callcrp()
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
#ifdef CR
+ca crco
#endif
      integer ia,ia2,ie,nthinerr
#ifdef CR
      integer ncalls
#endif
#ifdef BOINC
      integer timech
#endif
#ifdef CR
      data ncalls /0/
#endif
      save
!-----------------------------------------------------------------------
#ifdef CR
      ncalls=ncalls+1 
      write(91,*,iostat=ierro,err=11) numx,numl
      rewind 91
      if (restart) then
        write(93,*) 'CALLCRP/CRPOINT bailing out'
        write(93,*) 'numl, nnuml, numx, numlcr ',numl,nnuml,numx,numlcr
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        return
      else
#ifndef DEBUG
        if (ncalls.le.20.or.numx.ge.nnuml-20) then
#endif
        write(93,*) 'CALLCRP numl, nnuml, numlcr, numx, nwri, numlcp '
        write(93,*) numl,nnuml,numlcr,numx,nwri,numlcp
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
      endif
#ifdef BOINC
      if (checkp) then
! Now ALWAYS checkpoint
! NO, re-instated at user request
        call boinc_time_to_checkpoint(timech)
        if (timech.ne.0) then
          call crpoint
          call boinc_checkpoint_completed()
        endif
      endif
#endif
#ifndef BOINC
      if (checkp) call crpoint
#endif
      return
   11 write(lout,*)                                                     &
     &'*** ERROR ***,PROBLEMS WRITING TO FILE # : 91',ierro
      write(lout,*)'SIXTRACR WRITEBIN IO ERROR on Unit 91'
      call prror(-1)
#endif
      return
end subroutine callcrp

      subroutine dist1
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer ia,ib2,ib3,ie
      real(kind=fPrec) dam1
      save
!-----------------------------------------------------------------------
      do 20 ia=1,napx,2
        if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.     &
     &(mod(nlostp(ia),2).ne.0)) then
          ie=ia+1
          dam(ia)=zero
          dam(ie)=zero
          xau(1,1)= xv(1,ia)
          xau(1,2)= yv(1,ia)
          xau(1,3)= xv(2,ia)
          xau(1,4)= yv(2,ia)
          xau(1,5)=sigmv(ia)
          xau(1,6)= dpsv(ia)
          xau(2,1)= xv(1,ie)
          xau(2,2)= yv(1,ie)
          xau(2,3)= xv(2,ie)
          xau(2,4)= yv(2,ie)
          xau(2,5)=sigmv(ie)
          xau(2,6)= dpsv(ie)
          cloau(1)= clo6v(1,ia)
          cloau(2)=clop6v(1,ia)
          cloau(3)= clo6v(2,ia)
          cloau(4)=clop6v(2,ia)
          cloau(5)= clo6v(3,ia)
          cloau(6)=clop6v(3,ia)
          di0au(1)= di0xs(ia)
          di0au(2)=dip0xs(ia)
          di0au(3)= di0zs(ia)
          di0au(4)=dip0zs(ia)

          do ib2=1,6
            do ib3=1,6
              tau(ib2,ib3)=tasau(ia,ib2,ib3)
            end do
          end do

          call distance(xau,cloau,di0au,tau,dam1)
          dam(ia)=dam1
          dam(ie)=dam1
        endif
   20 continue
      return
      end subroutine dist1

subroutine write6(n)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer ia,ia2,id,ie,ig,n
      save
!-----------------------------------------------------------------------
      id=0
      do 10 ia=1,napxo,2
        ig=ia+1
        ia2=ig/2
#ifndef CR
        endfile (91-ia2,iostat=ierro)
        backspace (91-ia2,iostat=ierro)
#endif
!-- PARTICLES STABLE
        if(.not.pstop(ia).and..not.pstop(ig)) then
          write(lout,10000) ia,nms(ia)*izu0,dp0v(ia),n
          id=id+1
          ie=id+1
          write(lout,10010)                                             &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          id=id+1

!-- FIRST PARTICLES LOST
        else if(pstop(ia).and..not.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)

!-- SECOND PARTICLES LOST
        else if(.not.pstop(ia).and.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejv(id),ejvl(ig)

!-- BOTH PARTICLES LOST
        else if(pstop(ia).and.pstop(ig)) then
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejvl(ia),ejvl(ig)
        endif
   10 continue
#ifndef CR
      if(ierro.ne.0) then
         write(lout,*) 'ERROR from write6: fort.12 has ',               &
     &        'corrupted output probably due to lost particles'
#ifdef DEBUG
!        call dumpbin(' write6',0,0)                                     !hr09
#endif
         call prror(-1)
      endif
#endif
      endfile (12,iostat=ierro)
      backspace (12,iostat=ierro)
#ifdef CR
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
#endif
      return
10000 format(1x/5x,'PARTICLE ',i7,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10010 format(10x,f47.33)
end subroutine write6


+dk tra_thck
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
subroutine trauthck(nthinerr)
  ! Rewritten to remove computed gotos by V.K.B.Olsen on 20/11/2017
  use floatPrecision
  use end_sixtrack
  use mathlib_bouncer
  use numerical_constants
  use dynk, only : ldynk, dynk_isused, dynk_pretrack

#ifdef FLUKA
! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
! last modified: 17-07-2013
! import mod_fluka
! inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif

  use crcoall
  use parpro
  use parbeam, only : beam_expflag,beam_expfile_open
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  implicit none

  integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
  real(kind=fPrec) benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
+ca beamdim
  dimension nbeaux(nbb)
#ifdef COLLIMAT
+ca database
#endif
  save

#ifdef COLLIMAT
  if (do_coll) then
     write(lout,*) "Error: in trauthck and do_coll is TRUE"
     write(lout,*) "Collimation is not supported for thick tracking"
     call prror(-1)
  endif
#endif

  do i=1,npart
    nlostp(i)=i
  end do
  do i=1,nblz
    ktrack(i)=0
    strack(i)=zero
    strackc(i)=zero
    stracks(i)=zero
  end do
#include "include/beams1.f90"
  do 290 i=1,iu
    if(mout2.eq.1.and.i.eq.1) call write4
    ix=ic(i)
    if(ix.le.nblo) then
      !BLOC
      ktrack(i)=1
      do jb=1,mel(ix)
        jx=mtyp(ix,jb)
        strack(i)=strack(i)+el(jx)
      end do
      if(abs(strack(i)).le.pieni) ktrack(i)=31
      !Non-linear/NOT BLOC
      goto 290
    end if
    ix=ix-nblo
    kpz=abs(kp(ix))
    if(kpz.eq.6) then
      ktrack(i)=2
      goto 290
    end if
    kzz=kz(ix)
    if(kzz.eq.0) then
      ktrack(i)=31
      goto 290
    else if(kzz.eq.12) then
      ! Disabled cavity; enabled cavities have kp=6 and are handled above
      ! Note: kz=-12 is transformed into +12 in daten after reading ENDE.
      ktrack(i)=31
      goto 290
    end if
#include "include/beams21.f90"
#include "include/beamcoo.f90"
#include "include/beamr1.f90"
     &goto 42
#include "include/beamr2.f90"
#include "include/beamr3o.f90"
#include "include/beams22.f90"
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4o.f90"
    else if(ibtyp.eq.1) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4o.f90"
#include "include/beams23.f90"
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4o.f90"
    else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamcoo.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4o.f90"
#include "include/beams24.f90"
    ! wire
    if(kzz.eq.15) then
      ktrack(i)=45
      goto 290
    endif
    !electron lens (HEL)
    if(kzz.eq.29) then
      ktrack(i)=63
      goto 290
    endif
    ! acdip1
    if(kzz.eq.16) then
      ktrack(i)=51
      goto 290
    else if(kzz.eq.-16) then
      ktrack(i)=52
      goto 290
    endif
    ! crab
    if(kzz.eq.23) then
      ktrack(i)=53
      goto 290
    else if(kzz.eq.-23) then
      ktrack(i)=54
      goto 290
    endif
    ! JBG RF CC Multipoles
    if(kzz.eq.26) then
      ktrack(i)=57
      goto 290
    else if(kzz.eq.-26) then
      ktrack(i)=58
      goto 290
    endif
    if(kzz.eq.27) then
      ktrack(i)=59
      goto 290
    else if(kzz.eq.-27) then
      ktrack(i)=60
      goto 290
    endif
    if(kzz.eq.28) then
      ktrack(i)=61
      goto 290
    else if(kzz.eq.-28) then
      ktrack(i)=62
      goto 290
    endif
    if(kzz.eq.22) then
      ktrack(i)=3
      goto 290
    endif
    if(mout2.eq.1.and.icextal(i).ne.0) then
      write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),extalign(i,2),extalign(i,3)
    end if
    
    select case (kzz)
    case (1)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 11
#include "include/stra01.f90"
      end if
    case (2)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 12
#include "include/stra02.f90"
      end if
    case (3)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) =31 
      else
        ktrack(i) = 13
#include "include/stra03.f90"
      end if
    case (4)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 14
#include "include/stra04.f90"
      end if
    case (5)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 15
#include "include/stra05.f90"
      end if
    case (6)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 16
#include "include/stra06.f90"
      end if
    case (7)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 17
#include "include/stra07.f90"
      end if
    case (8)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 18
#include "include/stra08.f90"
      end if
    case (9)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 19
#include "include/stra09.f90"
      end if
    case (10)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 20
#include "include/stra10.f90"
      end if
    case (11) ! Multipole block (also in initialize_element)
      r0=ek(ix)
      nmz=nmu(ix)
      if(abs(r0).le.pieni.or.nmz.eq.0) then
        if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
          if ( dynk_isused(i) ) then
            write(lout,*) "ERROR: Element of type 11 (bez=",bez(ix),") is off in fort.2, but on in DYNK. Not implemented."
            call prror(-1)
          end if
          ktrack(i)=31
        else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
            ktrack(i)=33
#include "include/stra11.f90"
          else
            ktrack(i)=35
#include "include/stra12.f90"
          end if
        else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
            ktrack(i)=37
#include "include/stra13.f90"
          else
            ktrack(i)=39
#include "include/stra14.f90"
          end if
        end if
      else
        if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
          ktrack(i)=32
        else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
            ktrack(i)=34
#include "include/stra11.f90"
          else
            ktrack(i)=36
#include "include/stra12.f90"
          end if
        else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
            ktrack(i)=38
#include "include/stra13.f90"
          else
            ktrack(i)=40
#include "include/stra14.f90"
          end if
        end if
      end if
      if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
      if(mout2.eq.1) then
        benkcc=ed(ix)*benkc(irm(ix))
        r0a=one
        r000=r0*r00(irm(ix))
        do j=1,mmul
          fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
          fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
          r0a=r0a*r000
        end do
        
        write(9,'(a16)') bez(ix)
        write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
        write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
        write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
        write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
        write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
        write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
        write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
        write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
        write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
        write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
        write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
        write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
        write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
        write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
          
        do j=1,20
          fake(1,j)=zero
          fake(2,j)=zero
        end do
      end if
    case (12,13,14,15,16,17,18,19,20,21,22,23)
      goto 290
    case (24) ! DIPEDGE ELEMENT
#include "include/stra2dpe.f90"
      ktrack(i) = 55
    case (25) ! Solenoid
#include "include/solenoid.f90"
      ktrack(i) = 56
    
    !----------------
    !--Negative KZZ--
    !----------------
    case (-1)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 21
#include "include/stra01.f90"
      end if
    case (-2)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 22
#include "include/stra02.f90"
      end if
    case (-3)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 23
#include "include/stra03.f90"
      end if
    case (-4)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 24
#include "include/stra04.f90"
      end if
    case (-5)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 25
#include "include/stra05.f90"
      end if
    case (-6)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 26
#include "include/stra06.f90"
      end if
    case (-7)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 27
#include "include/stra07.f90"
      end if
    case (-8)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 28
#include "include/stra08.f90"
      end if
    case (-9)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 29
#include "include/stra09.f90"
      end if
    case (-10)
      if(abs(smiv(1,i)).le.pieni .and. .not.dynk_isused(i)) then
        ktrack(i) = 31
      else
        ktrack(i) = 30
#include "include/stra10.f90"
      end if
    
    case default
      ktrack(i) = 31
    end select
290 continue ! Label is still needed as it is referenced in some of the ca blocks
  
  do j=1,napx
    dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  end do
  nwri=nwr(3)
  if(nwri.eq.0) nwri=numl+numlr+1
    ! A.Mereghetti, for the FLUKA Team
    ! last modified: 17-07-2013
    ! save original kicks
    ! always in main code
    if (ldynk) call dynk_pretrack

    if(idp.eq.0.or.ition.eq.0) then
      write(lout,*) ''
      write(lout,*) 'Calling thck4d subroutine'
      write(lout,*) ''
      call thck4d(nthinerr)
    else
      hsy(3)=(c1m3*hsy(3))*real(ition,fPrec)                                 !hr01

      do jj=1,nele
        if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*real(itionc(jj),fPrec)     !hr01
      end do

      if(abs(phas).ge.pieni) then
        write(lout,"(a)") "TRACKING> ERROR thck6dua no longer supported. Please use DYNK instead."
        call prror(-1)
      else
        write(lout,*) ''
        write(lout,*) 'Calling thck6d subroutine'
        write(lout,*) ''
        call thck6d(nthinerr)
      end if
    end if
    
  return
end subroutine trauthck

!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 4D
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
subroutine thck4d(nthinerr)
  ! Replaced computed goto with select case, VKBO 27/11/2017
  use floatPrecision
  use end_sixtrack
  use string_tools
  use physical_constants
  use mathlib_bouncer
  use numerical_constants

  use bdex, only : bdex_enable
  use dynk, only : ldynk, dynk_apply
  use dump, only : dump_linesFirst, dump_lines, ldumpfront
  use aperture
      
#ifdef FLUKA
  ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
  ! last modified: 17-07-2013
  ! import mod_fluka
  ! inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif

  use mod_hions
  use postprocessing, only : writebin
  use crcoall
  use parpro
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  use elens
  use wire
  implicit none

  integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
  real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,crxb,crzb,dpsv3,pux,puxve,&
                   puxve1,puxve2,puzve1,puzve2,puzve,r0,r2b,rb,rho2b,rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
  integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
  real(kind=fPrec) e0fo,e0o,xv1j,xv2j
  real(kind=fPrec) acdipamp, qd, acphase, acdipamp2,acdipamp1,crabamp,crabfreq,kcrab
  real(kind=fPrec) RTWO !RTWO=x^2+y^2
  real(kind=fPrec) NNORM_, NNORM
  real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi
logical llost
  
+ca beamdim
#ifdef CR
+ca crco
#endif
  dimension dpsv3(npart)
  real(kind=fPrec) :: rrelens,frrelens,r1elens,xelens,yelens

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
  logical recompute_linear_matrices
#endif

  save

  nthinerr=0
  idz1=idz(1)
  idz2=idz(2)

  ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
  ! last modified: 24-11-2016
  ! initialise variables for back-tracking particles
  if (lbacktracking) call aperture_backTrackingInit

#ifdef FLUKA

!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
  napxto = 0
#endif

#ifdef CR
  if (restart) then
    call crstart
    write(93,*) 'THCK4D ','SIXTRACR restart numlcr',numlcr,'numl',numl
    ! and now reset numl to do only numlmax turns
  end if
  nnuml=min((numlcr/numlmax+1)*numlmax,numl)
  write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
  ! and reset [n]numxv unless particle is lost
  ! TRYing Eric (and removing postpr fixes).
  if (nnuml.ne.numl) then
    do j=1,napx
      if (numxv(j).eq.numl) numxv(j)=nnuml
      if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
    end do
  end if
  do 490 n=numlcr,nnuml
#endif
#ifndef CR
  do 490 n=1,numl
#endif
#ifdef BOINC
!   call boinc_sixtrack_progress(n,numl)
    call boinc_fraction_done(dble(n)/dble(numl))
    continue
!   call graphic_progress(n,numl)
#endif
  numx=n-1

#ifndef FLUKA
    if(mod(numx,nwri).eq.0) call writebin(nthinerr)
    if(nthinerr.ne.0) return
#endif

#ifdef CR
    !  does not call CRPOINT if restart=.true.
    !  (and note that writebin does nothing if restart=.true.
    if(mod(numx,numlcp).eq.0) call callcrp()
    restart=.false.
#endif

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
    if ( ldynk ) then
      call dynk_apply(n)
    end if

    call dump_linesFirst(n)

    do 480 i=1,iu
      if(ktrack(i).eq.1) then
        ix=ic(i)
      else
        ix=ic(i)-nblo
      
        if (ldumpfront) then
          write (lout,*) "DUMP/FRONT not yet supported on thick elements "// &
                         "due to lack of test cases. Please contact developers!"
          call prror(-1)
!+ca dumplines
        end if
      
      end if

#ifdef FLUKA
!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 17-07-2013
!           is the current entry an instance of a FLUKA element?
!           inserted in main code by the 'fluka' compilation flag
      if (fluka_enable) then
        if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must
                                !      be SINGLE ELEMENTs
          if(fluka_type(ix).ne.FLUKA_NONE) then
            if(fluka_type(ix).eq.FLUKA_ELEMENT) then
              call kernel_fluka_element( n, i, ix )
!                   re-compute transport matrices of linear elements,
!                      according to momentum of surviving/new particles
              recompute_linear_matrices = .true.
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 470
            else if(fluka_type(ix).eq.FLUKA_ENTRY) then
              fluka_inside = .true.
              call kernel_fluka_entrance( n, i, ix )
              goto 475
            else if(fluka_type(ix).eq.FLUKA_EXIT) then
              fluka_inside = .false.
              call kernel_fluka_exit( n, i, ix )
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              ! re-compute transport matrices of linear elements,
              !    according to momentum of surviving/new particles
              recompute_linear_matrices = .true.
              goto 470
            end if
          end if
        end if
        if(fluka_inside) then
          if(fluka_debug) then
            write(lout,*) '[Fluka] Skipping lattice element at ',i
            write(fluka_log_unit,*) '# Skipping lattice element at ', i
          end if
          goto 480
        end if
      end if
#endif

            if (bdex_enable) then
               !TODO - if you have a test case, please contact developers!
               write(lout,*) "BDEX> BDEX only available for thin6d"
               call prror(-1)
            endif

!----------count=43
      select case (ktrack(i))
      case (1)
        if (lbacktracking) then
          jmel=mel(ix)
          do jb=1,jmel
            jx=mtyp(ix,jb)
            do j=1,napx
#include "include/thcklin.f90"
            end do
          end do
        else 
          do j=1,napx
            puxve=xv(1,j)
            puzve=yv(1,j)
            xv(1,j)=bl1v(1,1,j,ix)*puxve+bl1v(2,1,j,ix)*puzve+((real(idz1,fPrec)*bl1v(5,1,j,ix))*dpsv(j))*c1e3 !hr01
            yv(1,j)=bl1v(3,1,j,ix)*puxve+bl1v(4,1,j,ix)*puzve+((real(idz1,fPrec)*bl1v(6,1,j,ix))*dpsv(j))*c1e3 !hr01
            puxve=xv(2,j)
            puzve=yv(2,j)
            xv(2,j)=bl1v(1,2,j,ix)*puxve+bl1v(2,2,j,ix)*puzve+((real(idz2,fPrec)*bl1v(5,2,j,ix))*dpsv(j))*c1e3 !hr01
            yv(2,j)=bl1v(3,2,j,ix)*puxve+bl1v(4,2,j,ix)*puzve+((real(idz2,fPrec)*bl1v(6,2,j,ix))*dpsv(j))*c1e3 !hr01
          end do
        end if 
        goto 480
      case (2)
        goto 480
      case (3)
        irrtr=imtr(ix)
        do j=1,napx
          temptr(1)=xv(1,j)
          temptr(2)=yv(1,j)
          temptr(3)=xv(2,j)
          temptr(4)=yv(2,j)

          xv(1,j)  = cotr(irrtr,1)
          yv(1,j)  = cotr(irrtr,2)
          xv(2,j)  = cotr(irrtr,3)
          yv(2,j)  = cotr(irrtr,4)

          do kxxa=1,6
            xv(1,j)   =  xv(1,j)+temptr(kxxa)*rrtr(irrtr,1,kxxa)
            yv(1,j)   =  yv(1,j)+temptr(kxxa)*rrtr(irrtr,2,kxxa) 
            xv(2,j)   =  xv(2,j)+temptr(kxxa)*rrtr(irrtr,3,kxxa) 
            yv(2,j)   =  yv(2,j)+temptr(kxxa)*rrtr(irrtr,4,kxxa)      
          enddo
        enddo
        goto 470
      case (4,5,6,7,8,9,10)
        goto 480
      case (11) ! HORIZONTAL DIPOLE
        do j=1,napx
#include "include/kickv01h.f90"
        end do
        goto 470
      case (12) ! NORMAL QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (13) ! NORMAL SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (14) ! NORMAL OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (15) ! NORMAL DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (16) ! NORMAL DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (17) ! NORMAL 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (18) ! NORMAL 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (19) ! NORMAL 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (20) ! NORMAL 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 470
      case (21) ! VERTICAL DIPOLE
        do j=1,napx
#include "include/kickv01v.f90"
        end do
        goto 470
      case (22) ! SKEW QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (23) ! SKEW SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (24) ! SKEW OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (25) ! SKEW DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (26) ! SKEW DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (27) ! SKEW 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (28) ! SKEW 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (29) ! SKEW 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (30) ! SKEW 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 470
      case (31)
        goto 470
      case (32)
        goto 240
      case (33)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
        end do
        goto 470
      case (34)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
        end do
        goto 240
      case (35)
        do j=1,napx
#include "include/mul4v02.f90"
        end do
        goto 470
      case (36)
        do j=1,napx
#include "include/mul4v02.f90"
        end do
        goto 240
      case (37)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
        end do
        goto 470
      case (38)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
        end do
        goto 240
      case (39)
        do j=1,napx
#include "include/mul4v04.f90"
        end do
        goto 470
      case (40)
        do j=1,napx
#include "include/mul4v04.f90"
        end do
        goto 240
      case (41)
        do 690 j=1,napx
#include "include/beamco.f90"
#include "include/beamr1.f90"
     &goto 690
#include "include/beamr2.f90"
#include "include/beamr3.f90"
690     continue
        goto 470
      case (42)
        if(ibtyp.eq.0) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4.f90"
        end if
        goto 470
      case (43)
        if(ibtyp.eq.0) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4.f90"
        end if
        goto 470
      case (44,46,47,48,49,50,57,58,59,60,61,62)
        goto 480
      case (45) ! Wire
#include "include/wirekick.f90"
        goto 470
      case (51)
        xory=1
#include "include/acdipkick.f90"
        goto 470
      case (52)
        xory=2
#include "include/acdipkick.f90"
        goto 470
      case (53)
        xory=1
#include "include/crabkick.f90"
        goto 470
      case (54)
        xory=2
#include "include/crabkick.f90"
        goto 470
      case (55) ! DIPEDGE ELEMENT
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvdpe.f90"
        end do
        goto 470
      case (56) ! Solenoid
        do j=1,napx
#include "include/kickvso1.f90"
        end do
        goto 470
      case (63) ! Elens
        do j=1,napx
#include "include/kickelens.f90"
        end do
        goto 470
      end select
      goto 480

240   r0=ek(ix)
      nmz=nmu(ix)
      if(nmz.ge.2) then
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v05.f90"
          do k=3,nmz
#include "include/mul4v06.f90"
          end do
#include "include/mul4v07.f90"
        end do
      else
        do j=1,napx
#include "include/mul4v08.f90"
        end do
      end if
      goto 470

!----------------------------

470   continue

      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! on-line aperture check
      ! always in main code
      call lostpart( n, i, ix, llost, nthinerr )
      ! stop tracking if no particle survives to this element
      if(nthinerr.ne.0) return
      ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
      ! last modified: 07-03-2018
      ! store infos of last aperture marker
      if ( lbacktracking.and.kape(ix).ne.0 ) call aperture_saveLastMarker(i,ix)

#ifdef FLUKA
      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! re-compute transport matrices of linear elements
      ! inserted in main code by the 'fluka' compilation flag
      if ( recompute_linear_matrices ) then
        ! after a FLUKA element: additional particles may have been generated
        call envarsv(dpsv,moidpsv,rvv,ekv)
        recompute_linear_matrices = .false.
      else if ( llost ) then
        ! after any other element: no additional particles, thus update only momentum-dependent matrix elements
        call synuthck
      else
        goto 475
      end if
      ! recompute matrices of BLOCKs
      call blocksv
#endif
#ifndef FLUKA
      if(llost) then
        call synuthck
      end if
#endif

475   continue

      if (.not. ldumpfront) then
        call dump_lines(n,i,ix)
      endif

480 continue

    if(nthinerr.ne.0) return
    if(ntwin.ne.2) call dist1
#ifndef FLUKA
    if(mod(n,nwr(4)).eq.0) call write6(n)
#endif

#ifdef FLUKA
    ! A.Mereghetti, for the FLUKA Team
    ! last modified: 14-06-2014
    ! increase napxto, to get an estimation of particles*turns
    ! inserted in main code by the 'fluka' compilation flag
    napxto = napxto + napx
#endif

490 continue

  return

end subroutine thck4d

!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 6D
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
subroutine thck6d(nthinerr)
  ! Replaced computed goto with select case, VKBO 28/11/2017
  use floatPrecision
  use end_sixtrack
  use string_tools
  use physical_constants
  use mathlib_bouncer
  use numerical_constants
  use bdex, only : bdex_enable
  use dynk, only : ldynk, dynk_apply
  use dump, only : dump_linesFirst, dump_lines, ldumpfront
  use aperture
      
#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     import mod_fluka
!     inserted in main code by the 'fluka' compilation flag
  use mod_fluka
#endif

  use mod_hions
  use postprocessing, only : writebin
  use crcoall
  use parpro
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  use aperture
  use elens
  use wire
  
  implicit none

  integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
  real(kind=fPrec) cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,crxb,crzb,dpsv3,&
                   pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,rb,rho2b,rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
  integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
  real(kind=fPrec) e0fo,e0o,xv1j,xv2j
  real(kind=fPrec) acdipamp, qd, acphase,acdipamp2,acdipamp1, crabamp, crabfreq, kcrab
  real(kind=fPrec) RTWO !RTWO=x^2+y^2
  real(kind=fPrec) NNORM_, NNORM
  real(kind=fPrec) l,cur,dx,dy,tx,ty,embl,chi,xi,yi,dxi,dyi
logical llost
  
+ca beamdim
#ifdef CR
+ca crco
#endif
  dimension dpsv3(npart)
  real(kind=fPrec) :: rrelens,frrelens,r1elens,xelens,yelens

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
  logical recompute_linear_matrices
#endif

  save
#ifdef DEBUG
!-----------------------------------------------------------------------
!===================================================================
! Eric beginthck6dstart
!===================================================================
#endif
  nthinerr=0
  idz1=idz(1)
  idz2=idz(2)

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     force re-computation of transport matrices of linear elements
!     inserted in main code by the 'fluka' compilation flag
  recompute_linear_matrices = .false.
#endif

  ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
  ! last modified: 24-11-2016
  ! initialise variables for back-tracking particles
  if (lbacktracking) call aperture_backTrackingInit

#ifdef FLUKA
!     A.Mereghetti, for the FLUKA Team
!     last modified: 14-06-2014
!     initialise napxto
!     inserted in main code by the 'fluka' compilation flag
  napxto = 0
#endif

! Now the outer loop over turns
#ifdef CR
  if (restart) then
    call crstart
    write(93,*) 'THCK6D ','SIXTRACR restart numlcr',numlcr,'numl',numl
! and now reset numl to do only numlmax turns
  end if
  nnuml=min((numlcr/numlmax+1)*numlmax,numl)
  write (93,*) 'numlmax=',numlmax,' DO ',numlcr,nnuml
! and reset [n]numxv unless particle is lost
! TRYing Eric (and removing postpr fixes).
  if (nnuml.ne.numl) then
    do j=1,napx
      if (numxv(j).eq.numl) numxv(j)=nnuml
      if (nnumxv(j).eq.numl) nnumxv(j)=nnuml
    end do
  end if
  do 510 n=numlcr,nnuml
#endif
#ifndef CR
  do 510 n=1,numl
#endif
! To do a dump and abend
#ifdef BOINC
!   call boinc_sixtrack_progress(n,numl)
    call boinc_fraction_done(dble(n)/dble(numl))
    continue
!   call graphic_progress(n,numl)
#endif
    numx=n-1

#ifndef FLUKA
    if(mod(numx,nwri).eq.0) call writebin(nthinerr)
    if(nthinerr.ne.0) return
#endif

#ifdef CR
!  does not call CRPOINT if restart=.true.
!  (and note that writebin does nothing if restart=.true.
    if(mod(numx,numlcp).eq.0) call callcrp()
    restart=.false.
#endif

!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
    if ( ldynk ) then
      call dynk_apply(n)
    end if
    call dump_linesFirst(n)

#ifdef DEBUG
! Now comes the loop over elements do 500/501
    do 501 i=1,iu
#else
    do 500 i=1,iu
#endif
#ifdef DEBUG
!===================================================================
!===================================================================
! Eric endthck6dstart
! Nothing should be changed in the rest of this loop
!===================================================================
!===================================================================
#endif
      if(ktrack(i).eq.1) then
        ix=ic(i)
      else
        ix=ic(i)-nblo
      end if

      if (ldumpfront) then
        write (lout,*) "DUMP/FRONT not yet supported on thick elements "// &
                       "due to lack of test cases. Please contact developers!"
        call prror(-1)
!+ca dumplines
      end if

#ifdef FLUKA

!           A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!           last modified: 17-07-2013
!           is the current entry an instance of a FLUKA element?
!           inserted in main code by the 'fluka' compilation flag
      if (fluka_enable) then
        if(ktrack(i).ne.1) then ! Skip BLOCs, FLUKA elements must be SINGLE ELEMENTs
          if(fluka_type(ix).ne.FLUKA_NONE) then
            if(fluka_type(ix).eq.FLUKA_ELEMENT) then
              call kernel_fluka_element( n, i, ix )
              ! Re-compute transport matrices of linear elements, according to momentum of surviving/new particles
              recompute_linear_matrices = .true.
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 490
            else if(fluka_type(ix).eq.FLUKA_ENTRY) then
              fluka_inside = .true.
              call kernel_fluka_entrance( n, i, ix )
              goto 495
            else if(fluka_type(ix).eq.FLUKA_EXIT) then
              fluka_inside = .false.
              call kernel_fluka_exit( n, i, ix )
              ! Re-compute transport matrices of linear elements, according to momentum of surviving/new particles
              recompute_linear_matrices = .true.
              ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
              ! last modified: 07-03-2018
              ! store old particle coordinates
              if (lbacktracking) call aperture_saveLastCoordinates(i,ix,0)
              goto 490
            end if
          end if
        end if
        if(fluka_inside) then
          if(fluka_debug) then
            write(lout,*) '[Fluka] Skipping lattice element at ',i
            write(fluka_log_unit,*) '# Skipping lattice element at ', i
          end if
          goto 500
        end if
      end if
#endif

#ifdef DEBUG
!     if (i.ge.673) then
!     call warr('xv12,i,ktrack ',xv(1,2),i,ktrack(i),0,0)
!     endif
!     if (i.eq.676) stop
#endif

            if (bdex_enable) then
               !TODO - if you have a test case, please contact developers!
               write(lout,*) "BDEX> BDEX only available for thin6d"
               call prror(-1)
            endif

!----------count 44
!----------count 54! Eric
      select case (ktrack(i))
      case (1)
        jmel=mel(ix)
        do jb=1,jmel
          jx=mtyp(ix,jb)
          do j=1,napx
#include "include/thcklin.f90"
          end do
        end do
        goto 500
      case (2)
        do j=1,napx
          ejf0v(j)=ejfv(j)
          if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
          if(kz(ix).eq.12) then
            ejv(j)=ejv(j)+(ed(ix)*sin_mb(hsyc(ix)*sigmv(j)+phasc(ix)))*nzz(j)
          else
            ejv(j)=ejv(j)+(hsy(1)*sin_mb(hsy(3)*sigmv(j)))*nzz(j)
          end if
          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)                             !hr01
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          omoidpsv(j)=c1e3*((one-mtc(j))*oidpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
          yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
          yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                         !hr01
        end do
        if(n.eq.1) write(98,'(1p,6(2x,e25.18))') (xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
#ifdef CR
        ! write(93,*) 'ERIC loop at 40 calling synuthck!!!'
        ! endfile (93,iostat=ierro)
        ! backspace (93,iostat=ierro)
#endif
        call synuthck
        goto 490
      case (3)
        irrtr=imtr(ix)
        do j=1,napx
            !The values are stored in the temp vector which are used for the multiplication.
          temptr(1)=xv(1,j)
          temptr(2)=yv(1,j)/moidpsv(j)
          temptr(3)=xv(2,j)
          temptr(4)=yv(2,j)/moidpsv(j)
          temptr(5)=sigmv(j)
          temptr(6)=((mtc(j)*ejv(j)-e0)/e0f)*c1e3*(e0/e0f)
          ! Adding the closed orbit. The previous values are stored in the temptr vector.   
          xv(1,j)  = cotr(irrtr,1)
          yv(1,j)  = cotr(irrtr,2)
          xv(2,j)  = cotr(irrtr,3)
          yv(2,j)  = cotr(irrtr,4)
          sigmv(j) = cotr(irrtr,5)
          pttemp   = cotr(irrtr,6)

          ! Multiplying the arbitrary matrix to the coordinates. 
          do kxxa=1,6
            xv(1,j)   =  xv(1,j)+temptr(kxxa)*rrtr(irrtr,1,kxxa)
            yv(1,j)   =  yv(1,j)+temptr(kxxa)*rrtr(irrtr,2,kxxa) 
            xv(2,j)   =  xv(2,j)+temptr(kxxa)*rrtr(irrtr,3,kxxa) 
            yv(2,j)   =  yv(2,j)+temptr(kxxa)*rrtr(irrtr,4,kxxa) 
            sigmv(j)  =  sigmv(j)+temptr(kxxa)*rrtr(irrtr,5,kxxa)        
            pttemp    =  pttemp+temptr(kxxa)*rrtr(irrtr,6,kxxa)        
          enddo
          ! Transforming back to the tracked coordinates of Sixtrack...
          ejv(j)  = (e0f*pttemp/(c1e3*(e0/e0f))+e0)/mtc(j)
          

          ejfv(j)=sqrt(ejv(j)**2-nucm(j)**2)
          rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
          dpsv(j)=(ejfv(j)*(nucm0/nucm(j))-e0f)/e0f
          oidpsv(j)=one/(one+dpsv(j))
          moidpsv(j)=mtc(j)/(one+dpsv(j))
          dpsv1(j)=(dpsv(j)*c1e3)*moidpsv(j)

          
          ! We have to go back to angles after we updated the energy. 
          yv(j,1) = yv(j,1)*mtc(j)/(one+dpsv(j))
          yv(j,2) = yv(j,2)*mtc(j)/(one+dpsv(j))
          !yv(j,1) = yv(j,1)*moidpsv(j)
          !yv(j,2) = yv(j,2)*moidpsv(j)
        enddo
        goto 490
      case (4,5,6,7,8,9,10)
        goto 500
      case (11) ! HORIZONTAL DIPOLE
        do j=1,napx
#include "include/kickv01h.f90"
        end do
        goto 490
      case (12) ! NORMAL QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (13) ! NORMAL SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (14) ! NORMAL OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (15) ! NORMAL DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (16) ! NORMAL DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (17) ! NORMAL 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (18) ! NORMAL 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (19) ! NORMAL 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (20) ! NORMAL 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxh.f90"
        end do
        goto 490
      case (21) ! VERTICAL DIPOLE
        do j=1,napx
#include "include/kickv01v.f90"
        end do
        goto 490
      case (22) ! SKEW QUADRUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (23) ! SKEW SEXTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (24) ! SKEW OCTUPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (25) ! SKEW DECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (26) ! SKEW DODECAPOLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (27) ! SKEW 14-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (28) ! SKEW 16-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (29) ! SKEW 18-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (30) ! SKEW 20-POLE
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvho.f90"
#include "include/kickvxxv.f90"
        end do
        goto 490
      case (31)
        goto 490
      case (32)
        goto 260
      case (33)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
#include "include/mul6v01.f90"
        end do
        goto 490
      case (34)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v01.f90"
#include "include/mul6v01.f90"
        end do
        goto 260
      case (35)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v02.f90"
#include "include/mul6v01.f90"
        end do
        goto 490
      case (36)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v02.f90"
#include "include/mul6v01.f90"
        end do
        goto 260
      case (37)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
#include "include/mul6v02.f90"
        end do
        goto 490
      case (38)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v03.f90"
#include "include/mul6v02.f90"
        end do
        goto 260
      case (39)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v04.f90"
#include "include/mul6v02.f90"
        end do
        goto 490
      case (40)
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v04.f90"
#include "include/mul6v02.f90"
        end do
        goto 260
      case (41)
        do 690 j=1,napx
#include "include/beamco.f90"
#include "include/beamr1.f90"
     &goto 690
#include "include/beamr2.f90"
#include "include/beamr3.f90"
690     continue
        goto 490
      case (42)
        if(ibtyp.eq.0) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam12.f90"
#include "include/beama3.f90"
#include "include/beam13.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam11.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf1.f90"
#include "include/beama4.f90"
        end if
        goto 490
      case (43)
        if(ibtyp.eq.0) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beam22.f90"
#include "include/beama3.f90"
#include "include/beam23.f90"
#include "include/beama4.f90"
        else if(ibtyp.eq.1) then
#include "include/beam21.f90"
#include "include/beama1.f90"
#include "include/beamco.f90"
#include "include/beama2.f90"
#include "include/beama3.f90"
#include "include/beamwzf2.f90"
#include "include/beama4.f90"
        end if
        goto 490
      case (44)
#include "include/beam6d.f90"
        goto 490
      case (45) ! Wire
#include "include/wirekick.f90"
        goto 490
      case (46,47,48,49,50,57,58,59,60,61,62)
        goto 500
      case (51)
        xory=1
#include "include/acdipkick.f90"
        goto 490
      case (52)
        xory=2
#include "include/acdipkick.f90"
        goto 490
      case (53)
        xory=1
#include "include/crabkick.f90"
        goto 490
      case (54)
        xory=2
#include "include/crabkick.f90"
        goto 490
      case (55) ! DIPEDGE ELEMENT
        do j=1,napx
#include "include/alignva.f90"
#include "include/kickvdpe.f90"
        end do
        goto 490
      case (56) ! Solenoid
        do j=1,napx
#include "include/kickvso1.f90"
#include "include/kickvso2.f90"
        end do
        goto 490
      case (63) ! Elens
        do j=1,napx
#include "include/kickelens.f90"
        end do
        goto 490
      end select
      goto 500

260   r0=ek(ix)
      nmz=nmu(ix)
      if(nmz.ge.2) then
        do j=1,napx
#include "include/alignvb.f90"
#include "include/mul4v05.f90"
          do k=3,nmz
#include "include/mul4v06.f90"
          end do
#include "include/mul4v07.f90"
        end do
      else
        do j=1,napx
#include "include/mul4v08.f90"
        end do
      end if
      goto 490

490   continue

      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! on-line aperture check
      ! always in main code
      call lostpart( n, i, ix, llost, nthinerr )
      ! stop tracking if no particle survives to this element
      if(nthinerr.ne.0) return
      ! A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
      ! last modified: 07-03-2018
      ! store infos of last aperture marker
      if ( lbacktracking.and.kape(ix).ne.0 ) call aperture_saveLastMarker(i,ix)

#ifdef FLUKA
      ! A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
      ! last modified: 17-07-2013
      ! re-compute transport matrices of linear elements
      ! inserted in main code by the 'fluka' compilation flag
      if ( recompute_linear_matrices ) then
        ! after a FLUKA element: additional particles may have been generated
        call envarsv(dpsv,moidpsv,rvv,ekv)
        recompute_linear_matrices = .false.
      else if ( llost ) then
        ! after any other element: no additional particles, thus update only momentum-dependent matrix elements
        call synuthck
      end if
#endif
#ifndef FLUKA
      if(llost) then
        call synuthck
      end if
#endif

495   continue

      if (.not. ldumpfront) then
        call dump_lines(n,i,ix)
      end if

#ifdef DEBUG
500 continue
    ! if (n.ge.990) then
    !   write(99,*) 'after element i, ktrack ',i,ktrack(i), xv(1,1),xv(2,1),yv(1,1),yv(2,1),&
    !     sigmv(1),ejv(1),ejfv(1),rvv(1),dpsv(1),oidpsv(1),dpsv1(1)
    !   endfile (99,iostat=ierro)
    !   backspace (99,iostat=ierro)
    ! end if
501 continue
#endif
#ifndef DEBUG
500 continue
#endif
! End of loop over elements

!===================================================================
!===================================================================
! Eric beginthck6dend
!===================================================================
!===================================================================

    if(nthinerr.ne.0) return
    if(ntwin.ne.2) call dist1
#ifndef FLUKA
    if(mod(n,nwr(4)).eq.0) call write6(n)
#endif

#ifdef FLUKA
    ! A.Mereghetti, for the FLUKA Team
    ! last modified: 14-06-2014
    ! increase napxto, to get an estimation of particles*turns
    ! inserted in main code by the 'fluka' compilation flag
    napxto = napxto + napx
#endif

510 continue
! end loop over turns

!===================================================================
!===================================================================
! Eric endthck6dend
!===================================================================
!===================================================================
  return

end subroutine thck6d

subroutine synuthck
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use numerical_constants
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer ih1,ih2,j,kz1,l
      real(kind=fPrec) fokm
      save
!---------------------------------------  SUBROUTINE 'ENVARS' IN-LINE
#ifdef CR
#ifdef DEBUG
!       write(93,*) 'ERIC synuthck called!!!'
!       write(93,*) 'ERIC il= ',il
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
#endif
      sythckcr=.true.
#endif
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
   10 continue
      do 160 l=1,il
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
!       goto 160
!Eric
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
        if (kz1.eq.1) then
          goto 20
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
        elseif (kz1.eq.2.or.kz1.eq.5) then
   40     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.2) then
            ih1=1
            ih2=2
          else
!  RECTANGULAR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 50 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            fok1(j)=(tan_mb(fok(j)*half))/rho(j)
            si(j)=sin_mb(fok(j))
            co(j)=cos_mb(fok(j))
            al(2,ih1,j,l)=rho(j)*si(j)
      al(5,ih1,j,l)=((-one*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr01
      al(6,ih1,j,l)=((-one*dpsv(j))*((two*tan_mb(fok(j)*half))/dpsq(j)))&!hr01
     &*c1e3                                                              !hr01
            sm1(j)=cos_mb(fok(j))
            sm2(j)=sin_mb(fok(j))*rho(j)
            sm3(j)=-sin_mb(fok(j))/rho(j)
            sm12(j)=el(l)-sm1(j)*sm2(j)
            sm23(j)=sm2(j)*sm3(j)
         as3(j)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr01
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr01
            as4(j)=((-one*rvv(j))*sm23(j))/c2e3                          !hr01
            as6(j)=((-one*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3            !hr01
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
         as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))* &!hr01
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr01
            as(3,ih1,j,l)=as3(j)
            as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                    !hr01
            as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/(c4e3*rho(j)**2)+     &!hr01
     &as6(j)*fok1(j)**2+fok1(j)*as4(j)                                   !hr01
            as(6,ih1,j,l)=as6(j)
!--VERTIKAL
            g(j)=tan_mb(fok(j)*half)/rho(j)
            gl(j)=el(l)*g(j)
            al(1,ih2,j,l)=one-gl(j)
            al(3,ih2,j,l)=(-one*g(j))*(two-gl(j))                        !hr01
            al(4,ih2,j,l)=al(1,ih2,j,l)
            as6(j)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3                    !hr01
            as(4,ih2,j,l)=((-one*two)*as6(j))*fok1(j)                    !hr01
            as(5,ih2,j,l)=(as6(j)*fok1(j))*fok1(j)                       !hr01
            as(6,ih2,j,l)=as6(j)
   50     continue
          goto 160
        elseif (kz1.eq.4.or.kz1.eq.6) then
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.4) then
            ih1=1
            ih2=2
          else
!  SECTOR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 70 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            si(j)=sin_mb(fok(j))
            co(j)=cos_mb(fok(j))
            rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                         !hr01
            siq(j)=si(j)/dpsq(j)
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=rho(j)*si(j)
            al(3,ih1,j,l)=(-one*si(j))/rho(j)                            !hr01
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-one*dpsv(j))*rhoc(j))*c1e3                  !hr01
            al(6,ih1,j,l)=((-one*dpsv(j))*siq(j))*c1e3                   !hr01
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
      as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/(two*rho(j)*dpsq(j)))*      &!hr01
     &sm12(j)-dpd(j)*siq(j))                                             !hr01
      as(3,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*    &!hr01
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr01
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr01
            as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/((c4e3*rho(j))*rho(j)) !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr01
     &c4e3
!--VERTIKAL
            as(6,ih2,j,l)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3             !hr01
   70     continue
          goto 160
        elseif (kz1.eq.3) then
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
            fok(j)=ekv(j,l)*oidpsv(j)
            aek(j)=abs(fok(j))
            hi(j)=sqrt(aek(j))
            fi(j)=el(l)*hi(j)
            if(fok(j).le.zero) then
              al(1,1,j,l)=cos_mb(fi(j))
              hi1(j)=sin_mb(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hi1(j)/hi(j)
              endif
              al(3,1,j,l)=-hi1(j)*hi(j)
              al(4,1,j,l)=al(1,1,j,l)
              as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
              as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
           as(5,1,j,l)=(((-one*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
       as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3  !hr01
!--DEFOCUSSING
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,2,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hs(j)/hi(j)
              endif
              al(3,2,j,l)=hs(j)*hi(j)
              al(4,2,j,l)=hc(j)
              as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
              as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr01
            else
              al(1,2,j,l)=cos_mb(fi(j))
              hi1(j)=sin_mb(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hi1(j)/hi(j)
              endif
              al(3,2,j,l)=(-one*hi1(j))*hi(j)                            !hr01
              al(4,2,j,l)=al(1,2,j,l)
              as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
              as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
           as(5,2,j,l)=(((-one*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3 !hr01
!--DEFOCUSSING
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,1,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hs(j)/hi(j)
              endif
              al(3,1,j,l)=hs(j)*hi(j)
              al(4,1,j,l)=hc(j)
              as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
              as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
        as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3 !hr01
            endif
   90     continue
          goto 160
        elseif (kz1.eq.7.or.kz1.eq.8) then
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100     if(kz1.eq.7) then
            do 110 j=1,napx
              fokqv(j)=ekv(j,l)
  110       continue
            ih1=1
            ih2=2
          else
!  COMBINED FUNCTION MAGNET VERTICAL
            do 120 j=1,napx
              fokqv(j)=-ekv(j,l)
  120       continue
            ih1=2
            ih2=1
          endif
          do 130 j=1,napx
            wf(j)=ed(l)/dpsq(j)
            fok(j)=fokqv(j)/dpd(j)-wf(j)**2                              !hr01
            afok(j)=abs(fok(j))
            hi(j)=sqrt(afok(j))
            fi(j)=hi(j)*el(l)
            if(afok(j).le.pieni) then
              as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                     !hr01
              as(6,2,j,l)=as(6,1,j,l)
              as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
            endif
            if(fok(j).lt.(-one*pieni)) then                              !hr06
              si(j)=sin_mb(fi(j))
              co(j)=cos_mb(fi(j))
              wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                      !hr01
              al(1,ih1,j,l)=co(j)
              al(2,ih1,j,l)=si(j)/hi(j)
              al(3,ih1,j,l)=(-one*si(j))*hi(j)                           !hr01
              al(4,ih1,j,l)=co(j)
              al(5,ih1,j,l)=((-one*wfa(j))*dpsv(j))*c1e3                 !hr01
              al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                                &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3    !hr06
           as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=(-one*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr01
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr01
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr01
              as(5,ih1,j,l)=(((-one*rvv(j))*sm12(j))*afok(j))/c4e3       !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih2,j,l)=hc(j)
              if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
              al(3,ih2,j,l)=hs(j)*hi(j)
              al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr01
            as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
!--DEFOCUSSING
            if(fok(j).gt.pieni) then
              hp(j)=exp_mb(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih1,j,l)=hc(j)
              al(2,ih1,j,l)=hs(j)/hi(j)
              al(3,ih1,j,l)=hs(j)*hi(j)
              al(4,ih1,j,l)=hc(j)
              wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)               !hr01
              wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                      !hr01
              al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                       !hr01
              al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
              as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*      &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*  &!hr06
     &(one-rvv(j)))*c1e3                                                 !hr06
           as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
      as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))* ed(l))  &!hr01
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr01
              as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                 !hr01
              as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3              !hr01
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              si(j)=sin_mb(fi(j))
              co(j)=cos_mb(fi(j))
              al(1,ih2,j,l)=co(j)
              al(2,ih2,j,l)=si(j)/hi(j)
              al(3,ih2,j,l)=(-one*si(j))*hi(j)                           !hr01
              al(4,ih2,j,l)=co(j)
        as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3 !hr01
      as(5,ih2,j,l)=(((-one*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr01
     &*aek(j))/c4e3                                                      !hr01
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
  130     continue
          goto 160
        elseif (kz1.eq.9) then
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140     do 150 j=1,napx
            rhoi(j)=ed(l)/dpsq(j)
            fok(j)=rhoi(j)*tan_mb((el(l)*rhoi(j))*half)                  !hr01
            al(3,1,j,l)=fok(j)
            al(3,2,j,l)=-fok(j)
  150     continue
          goto 160
        else
!Eric
! Is really an error but old code went to 160
          goto 160
        endif
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                         !hr01
          as(6,2,j,l)=as(6,1,j,l)
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr01
   30   continue
  160 continue
!---------------------------------------  END OF 'ENVARS' (2)
      return
      end subroutine synuthck

+dk envarsv
subroutine envarsv(dpsv,oidpsv,rvv,ekv)
!-----------------------------------------------------------------------
!  CALCULATION OF : MOMENTUM-DEPENDING ELEMENT-MATRICES AND
!                   CHANGE OF PATH LENGTHS FOR EACH PARTICLE.
!  CAUTION:
!          A SPECIAL VERSION FOR VECTORIZATION - AUGUST   1994
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer

      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      use mod_commond

      use mod_alloc

      implicit none
      integer ih1,ih2,j,kz1,l,l1,l2

      !Local version of variables normally found in mod_commonmn
      real(kind=fPrec) aek,afok,as3,as4,as6,co,dpd,dpsq,dpsv,fi,    &
           fok,fok1,fokqv,g,gl,hc,hi,hi1,hm,hp,hs,oidpsv,rho,rhoc,rhoi, &
           rvv,si,siq,sm1,sm12,sm2,sm23,sm3,wf,wfa,wfhi

      real(kind=fPrec), allocatable, intent(inout) :: ekv(:,:) !(npart,nele)

      dimension fokqv(npart),dpsv(npart)
      dimension rvv(npart),oidpsv(npart)
      dimension dpd(npart),dpsq(npart),fok(npart),rho(npart)
      dimension fok1(npart),si(npart),co(npart),g(npart),gl(npart)
      dimension sm1(npart),sm2(npart),sm3(npart),sm12(npart)
      dimension as3(npart),as4(npart),as6(npart),sm23(npart)
      dimension rhoc(npart),siq(npart),aek(npart),afok(npart)
      dimension hp(npart),hm(npart),hc(npart),hs(npart),wf(npart)
      dimension wfa(npart),wfhi(npart),rhoi(npart)
      dimension hi(npart),fi(npart),hi1(npart)
      
      real(kind=fPrec) fokm
      
!-----------------------------------------------------------------------
      save
!-----------------------------------------------------------------------

      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
   10 continue
      do 160 l=1,il
        do l1=1,6
          do j=1,napx
            do l2=1,2
              al(l1,l2,j,l)=zero
              as(l1,l2,j,l)=zero
            enddo
          enddo
        enddo
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
        if (kz1.eq.1) goto 20
        if (kz1.eq.2) goto 40
        if (kz1.eq.3) goto 80
        if (kz1.eq.4) goto 60
        if (kz1.eq.5) goto 40
        if (kz1.eq.6) goto 60
        if (kz1.eq.7) goto 100
        if (kz1.eq.8) goto 100
        if (kz1.eq.9) goto 140
        goto 160
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
          al(1,1,j,l)=one
          al(1,2,j,l)=one
          al(2,1,j,l)=el(l)
          al(2,2,j,l)=el(l)
          al(3,1,j,l)=zero
          al(3,2,j,l)=zero
          al(4,1,j,l)=one
          al(4,2,j,l)=one
          as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                         !hr06
          as(6,2,j,l)=as(6,1,j,l)
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr06
   30   continue
        goto 160
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   40   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.2) then
          ih1=1
          ih2=2
        else
!  RECTANGULAR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 50 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          fok1(j)=(tan_mb(fok(j)*half))/rho(j)
          si(j)=sin_mb(fok(j))
          co(j)=cos_mb(fok(j))
          al(1,ih1,j,l)=one
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=zero
          al(4,ih1,j,l)=one
      al(5,ih1,j,l)=((-one*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr06
      al(6,ih1,j,l)=((-one*dpsv(j))*((two*tan_mb(fok(j)*half))/dpsq(j)))&!hr06
     &*c1e3                                                              !hr06
          sm1(j)=cos_mb(fok(j))
          sm2(j)=sin_mb(fok(j))*rho(j)
          sm3(j)=(-one*sin_mb(fok(j)))/rho(j)                            !hr06
          sm12(j)=el(l)-sm1(j)*sm2(j)
          sm23(j)=sm2(j)*sm3(j)
         as3(j)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-&!hr06
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                     !hr06
          as4(j)=((-one*rvv(j))*sm23(j))/c2e3                            !hr06
          as6(j)=((-one*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3              !hr06
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/            &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
      as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*    &!hr06
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr06
          as(3,ih1,j,l)=as3(j)
          as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                      !hr06
          as(5,ih1,j,l)=(as6(j)*fok1(j)**2                              &!hr06
     &-(rvv(j)*sm12(j))/(c4e3*rho(j)**2))+fok1(j)*as4(j)                 !hr06
          as(6,ih1,j,l)=as6(j)
!--VERTIKAL
          g(j)=tan_mb(fok(j)*half)/rho(j)
          gl(j)=el(l)*g(j)
          al(1,ih2,j,l)=one-gl(j)
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=(-one*g(j))*(two-gl(j))                          !hr06
          al(4,ih2,j,l)=al(1,ih2,j,l)
          as6(j)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3                      !hr06
          as(4,ih2,j,l)=((-one*two)*as6(j))*fok1(j)                      !hr06
          as(5,ih2,j,l)=as6(j)*fok1(j)**2                                !hr06
          as(6,ih2,j,l)=as6(j)
   50   continue
        goto 160
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60   fokm=el(l)*ed(l)
        if(abs(fokm).le.pieni) goto 20
        if(kz1.eq.4) then
          ih1=1
          ih2=2
        else
!  SECTOR MAGNET VERTICAL
          ih1=2
          ih2=1
        endif
        do 70 j=1,napx
          fok(j)=fokm/dpsq(j)
          rho(j)=(one/ed(l))*dpsq(j)
          si(j)=sin_mb(fok(j))
          co(j)=cos_mb(fok(j))
          rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                           !hr06
          siq(j)=si(j)/dpsq(j)
          al(1,ih1,j,l)=co(j)
          al(2,ih1,j,l)=rho(j)*si(j)
          al(3,ih1,j,l)=(-one*si(j))/rho(j)                              !hr06
          al(4,ih1,j,l)=co(j)
          al(5,ih1,j,l)=((-one*dpsv(j))*rhoc(j))*c1e3                    !hr06
          al(6,ih1,j,l)=((-one*dpsv(j))*siq(j))*c1e3                     !hr06
          sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
          sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
       as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/           &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
       as(2,ih1,j,l)=(-one*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))*   &!hr06
     &sm12(j)-dpd(j)*siq(j))                                             !hr06
         as(3,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))* &!hr06
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr06
          as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                     !hr06
          as(5,ih1,j,l)=((-one*rvv(j))*sm12(j))/(c4e3*rho(j)**2)         !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr06
     &c4e3                                                               !hr06
!--VERTIKAL
          al(1,ih2,j,l)=one
          al(2,ih2,j,l)=el(l)
          al(3,ih2,j,l)=zero
          al(4,ih2,j,l)=one
          as(6,ih2,j,l)=((-one*rvv(j))*al(2,ih2,j,l))/c2e3               !hr06
   70   continue
        goto 160
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
          fok(j)=ekv(j,l)*oidpsv(j)
          aek(j)=abs(fok(j))
          hi(j)=sqrt(aek(j))
          fi(j)=el(l)*hi(j)
          if(fok(j).le.zero) then
            al(1,1,j,l)=cos_mb(fi(j))
            hi1(j)=sin_mb(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hi1(j)/hi(j)
            endif
            al(3,1,j,l)=(-one*hi1(j))*hi(j)                              !hr06
            al(4,1,j,l)=al(1,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=(((-one*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,2,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hs(j)/hi(j)
            endif
            al(3,2,j,l)=hs(j)*hi(j)
            al(4,2,j,l)=hc(j)
            as(4,2,j,l)=((-one*rvv(j))*al(2,2,j,l)*al(3,2,j,l))/c2e3     !hr06
          as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
          else
            al(1,2,j,l)=cos_mb(fi(j))
            hi1(j)=sin_mb(fi(j))
            if(abs(hi(j)).le.pieni) then
              al(2,2,j,l)=el(l)
            else
              al(2,2,j,l)=hi1(j)/hi(j)
            endif
            al(3,2,j,l)=(-one*hi1(j))*hi(j)                              !hr06
            al(4,2,j,l)=al(1,2,j,l)
            as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
            as(4,2,j,l)=(((-one*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3   !hr06
          as(5,2,j,l)=(((-one*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))* &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,2,j,l)=((-one*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr06
!--DEFOCUSSING
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,1,j,l)=hc(j)
            if(abs(hi(j)).le.pieni) then
              al(2,1,j,l)=el(l)
            else
              al(2,1,j,l)=hs(j)/hi(j)
            endif
            al(3,1,j,l)=hs(j)*hi(j)
            al(4,1,j,l)=hc(j)
            as(4,1,j,l)=(((-one*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3   !hr06
          as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*aek(j)) &!hr06
     &/c4e3                                                              !hr06
      as(6,1,j,l)=((-one*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3   !hr06
          endif
   90   continue
        goto 160
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100   if(kz1.eq.7) then
          do 110 j=1,napx
            fokqv(j)=ekv(j,l)
  110     continue
          ih1=1
          ih2=2
        else
!  COMBINED FUNCTION MAGNET VERTICAL
          do 120 j=1,napx
            fokqv(j)=-one*ekv(j,l)                                       !hr06
  120     continue
          ih1=2
          ih2=1
        endif
        do 130 j=1,napx
          wf(j)=ed(l)/dpsq(j)
          fok(j)=fokqv(j)/dpd(j)-wf(j)**2                                !hr06
          afok(j)=abs(fok(j))
          hi(j)=sqrt(afok(j))
          fi(j)=hi(j)*el(l)
          if(afok(j).le.pieni) then
            al(1,1,j,l)=one
            al(1,2,j,l)=one
            al(2,1,j,l)=el(l)
            al(2,2,j,l)=el(l)
            al(3,1,j,l)=zero
            al(3,2,j,l)=zero
            al(4,1,j,l)=one
            al(4,2,j,l)=one
            as(6,1,j,l)=((-one*rvv(j))*el(l))/c2e3                       !hr06
            as(6,2,j,l)=as(6,1,j,l)
            as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                        !hr06
          endif
          if(fok(j).lt.(-one*pieni)) then                                !hr06
            si(j)=sin_mb(fi(j))
            co(j)=cos_mb(fi(j))
            wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                        !hr06
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=si(j)/hi(j)
            al(3,ih1,j,l)=(-one*si(j))*hi(j)                             !hr06
            al(4,ih1,j,l)=co(j)
            al(5,ih1,j,l)=((-one*wfa(j))*dpsv(j))*c1e3                   !hr06
            al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                          &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3   !hr06
      as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*     &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
      as(3,ih1,j,l)=(-one*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr06
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr06
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=(((-one*rvv(j))*sm12(j))*afok(j))/c4e3         !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih2,j,l)=hc(j)
            al(2,ih2,j,l)=el(l)
            if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
            al(3,ih2,j,l)=hs(j)*hi(j)
            al(4,ih2,j,l)=hc(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
          as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*  &!hr06
     &aek(j))/c4e3                                                       !hr06
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
!--DEFOCUSSING
          if(fok(j).gt.pieni) then
            hp(j)=exp_mb(fi(j))
            hm(j)=one/hp(j)
            hc(j)=(hp(j)+hm(j))*half
            hs(j)=(hp(j)-hm(j))*half
            al(1,ih1,j,l)=hc(j)
            al(2,ih1,j,l)=hs(j)/hi(j)
            al(3,ih1,j,l)=hs(j)*hi(j)
            al(4,ih1,j,l)=hc(j)
            wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)                 !hr06
            wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                        !hr06
            al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                         !hr06
            al(6,ih1,j,l)=((-one*wfhi(j))*dpsv(j))*c1e3                  !hr06
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
            as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*sm12(j) &
     &+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*         &
     &(one-rvv(j)))*c1e3
          as(2,ih1,j,l)=(-one*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))* &!hr06
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr06
        as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))*ed(l)) &!hr06
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr06
            as(4,ih1,j,l)=((-one*rvv(j))*sm23(j))/c2e3                   !hr06
            as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3                !hr06
      as(6,ih1,j,l)=((-one*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr06
     &/c4e3                                                              !hr06
            aek(j)=abs(ekv(j,l)/dpd(j))
            hi(j)=sqrt(aek(j))
            fi(j)=hi(j)*el(l)
            si(j)=sin_mb(fi(j))
            co(j)=cos_mb(fi(j))
            al(1,ih2,j,l)=co(j)
            al(2,ih2,j,l)=si(j)/hi(j)
            al(3,ih2,j,l)=(-one*si(j))*hi(j)                             !hr06
            al(4,ih2,j,l)=co(j)
      as(4,ih2,j,l)=(((-one*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr06
      as(5,ih2,j,l)=(((-one*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr06
     &*aek(j))/c4e3                                                      !hr06
      as(6,ih2,j,l)=((-one*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr06
     &/c4e3                                                              !hr06
          endif
  130   continue
        goto 160
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140   do 150 j=1,napx
          rhoi(j)=ed(l)/dpsq(j)
          fok(j)=rhoi(j)*tan_mb((el(l)*rhoi(j))*half)                    !hr06
          al(1,1,j,l)=one
          al(2,1,j,l)=zero
          al(3,1,j,l)=fok(j)
          al(4,1,j,l)=one
          al(1,2,j,l)=one
          al(2,2,j,l)=zero
          al(3,2,j,l)=-fok(j)
          al(4,2,j,l)=one
  150   continue
  160 continue

      return
end subroutine envarsv



+dk comnul
!-----------------------------------------------------------------------
!  SUBROUTINE TO SET THE ALL COMMON VARIABLES TO ZERO
!-----------------------------------------------------------------------
subroutine comnul
  
  use floatPrecision
  use numerical_constants
  use mathlib_bouncer
  use parpro
  use parbeam, only : beam_expflag,beam_expfile_open
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  
  use aperture
  use elens
  use wire
  use scatter,     only : scatter_comnul
  use dynk,        only : dynk_comnul
  use fma,         only : fma_comnul
  use dump,        only : dump_comnul
  use zipf,        only : zipf_comnul
  use bdex,        only : bdex_comnul
#ifdef COLLIMAT
  use collimation, only : collimation_comnul
#endif
#ifdef HDF5
  use hdf5_output, only : h5_comnul
#endif
  
  implicit none
  
  integer i,i1,i2,i3,i4,j
+ca commd1da
  
  save
  
  ncorru  = 0     ! mod_common
  ncorrep = 0     ! mod_common
  ierro   = 0     ! mod_common
  iu      = 0     ! mod_common
  ilin    = 0     ! mod_common
  iqmodc  = 0     ! mod_common
  ichromc = 0     ! mod_common
  ilinc   = 0     ! mod_common
  iprint  = 0     ! mod_common
  
  ! TRACKING BLOCK
  ! Line 1
  numl    = 0     ! mod_common
  numlr   = 0     ! mod_common
  napx    = 0     ! mod_common
  amp0    = zero  ! mod_common
  amp(:)  = zero  ! mod_commont
  ird     = 0     ! mod_common
  imc     = 0     ! mod_common
  niu(1)  = 0     ! mod_common
  niu(2)  = 0     ! mod_common
  numlcp  = 0     ! mod_common
  numlmax = 0     ! mod_common
  ! Line 2
  idz(:)  = 0     ! mod_commons
  idfor   = 0     ! mod_common
  irew    = 0     ! mod_common
  iclo6   = 0     ! mod_common
  iclo6r  = 0     ! mod_common
  ! Line 3
  nde(:)  = 0     ! mod_common
  nwr(:)  = 0     ! mod_common
  ntwin   = 0     ! mod_common
  ibidu   = 0     ! mod_common
  iexact  = 0     ! mod_common
  
  ! SINGLE ELEMENT BLOCK
  ithick  = 0     ! mod_common
  il      = 0     ! mod_common
  
  ! BLOC DEFINITONS BLOCK
  mper    = 0     ! mod_common
  mblo    = 0     ! mod_common
  mbloz   = 0     ! mod_common
  
  ! STRUCTURE INPUT BLOCK
  kanf    = 0     ! mod_common
  
  ! INITIAL COORDINATES BLOCK
  itra     = 0    ! mod_commons
  chi0     = zero ! mod_commons
  chid     = zero ! mod_commons
  rat      = zero ! mod_common
  iver     = 0    ! mod_common
  exz(:,:) = zero ! mod_commons
  e0       = zero ! mod_common
  ej(:)    = zero ! mod_common

  ! DIFFERENTIAL ALGEBRA BLOCK
  idp     = 0     ! mod_common
  
  ! RANDOM NUMBERS VARIABLES
  iorg    = 0     ! mod_common
  
  ! ITERATION ERRORS BLOCK
  itco    = 0     ! mod_common
  itcro   = 0     ! mod_common
  itqv    = 0     ! mod_common
  
  ! CHROMATICITY ADJUSTMENT BLOCK
  ichrom  = 0     ! mod_common
  
  ! TUNE ADJUSTMENT BLOCK
  iqmod   = 0     ! mod_common
  iqmod6  = 0     ! mod_common
  
  ! LINEAR OPTICS BLOCK
  ntco    = 0     ! mod_common
  nt      = 0     ! mod_common
  
  ! ORBIT CORRECTION BLOCK
  iclo    = 0     ! mod_common
  
  ! COMBINATION OF ELEMENTS BLOCK
  icoe    = 0     ! mod_common
  
  ! SEARCH BLOCK
  ise     = 0     ! mod_common
  mesa    = 0     ! mod_common
  mp      = 0     ! mod_common
  m21     = 0     ! mod_common
  m22     = 0     ! mod_common
  m23     = 0     ! mod_common
  ise1    = 0     ! mod_common
  ise2    = 0     ! mod_common
  ise3    = 0     ! mod_common
  
  ! SUBRESONANCE CALCULATION BLOCK
  isub    = 0     ! mod_common
  nta     = 0     ! mod_common
  nte     = 0     ! mod_common
  ipt     = 0     ! mod_common
  
  ! RESONANCE COMPENSATION BLOCK
  irmod2  = 0     ! mod_common
  nre     = 0     ! mod_common
  
  ! TODO
      nur=0
      nch=0
      nqc=0
      npp=0
      ipos=0
      iconv=0
      imad=0
      nstart=0
      nstop=0
      iskip=1
      iav=0
      iwg=0
      ivox=0
      ivoz=0
      ires=0
      ifh=0
      idis=0
      icow=0
      istw=0
      iffw=0
      idial=0
      nord=0
      nvar=0
      nvar2=0
      ndimf=0
      nordf=0
      nvarf=0
      nord1=1
      nsix=0
      nvar2=0
      ncor=0
      idptr=0
      nbeam=0
      ibb6d=0
      ibeco=1
      ibtyp=0
      lhc=1
      ibbc=0
!-----------------------------------------------------------------------
      inorm=0
      imod1=0
      imod2=0
!-----------------------------------------------------------------------
      icorr=0
      nctype=0
      namp=0
      nmom=0
      nmom1=0
      nmom2=0
      weig1=zero
      weig2=zero
      dpmax=zero
!--DA-------------------------------------------------------------------
      dpda_da=0
      dpda1_da=0
      sigmda_da=0
      ej1_da=0
      ejf1_da=0
      rv_da=0
!-----------------------------------------------------------------------
      pi=zero
      pi2=zero
      pisqrt=zero
      rad=zero
      dp1=zero
      qs=zero
      crad=zero
      dppoff=zero
      tlen=zero
      pma=zero
      phas0=zero
      phas=zero
      ition=0
      dpscor=one
      sigcor=one
      benki=zero
      dma=zero
      dmap=zero
      dkq=zero
      dqq=zero
      de0=zero
      ded=zero
      dsi=zero
      dech=zero
      dsm0=zero
      qxt=zero
      qzt=zero
      eui=zero
      euii=zero
      tam1=zero
      tam2=zero
      totl=zero
      dphix=zero
      dphiz=zero
      qx0=zero
      qz0=zero
      dres=zero
      dfft=zero
      preda=zero
      partnum=zero
      emitx=zero
      emity=zero
      emitz=zero
      gammar=one
      sigz=zero
      sige=zero
      damp=zero
      ampt=zero
!-----------------------------------------------------------------------
      tlim=0.
      time0=0.
      time1=0.
!-----------------------------------------------------------------------
      do 10 i=1,2
        is(i)=0
        bet0(i)=zero
        alf0(i)=zero
        clo(i)=zero
        clop(i)=zero
        aper(i)=c1e3
        di0(i)=zero
        dip0(i)=zero
        cro(i)=zero
        sigma0(i)=zero
        qwsk(i)=zero
        betx(i)=zero
        betz(i)=zero
        alfx(i)=zero
        alfz(i)=zero
   10 continue

      do 20 i=1,3
        iq(i)=0
        hsy(i)=zero
        qw0(i)=zero
        clo6(i)=zero
        clop6(i)=zero
        clon(i)=zero
        wxys(i)=zero
        do i1=1,3
          corr(i,i1)=zero
        enddo
   20 continue

      corr(1,1)=zero
      corr(1,2)=zero
      chromc(1)=9.999999e23_fPrec
      chromc(2)=9.999999e23_fPrec

      do 40 i=1,5
        ipr(i)=0
        nrr(i)=0
        nu(i)=0
        toptit(i)=' '
   40 continue

      do 50 i=1,6
        nskew(i)=0
   50 continue

      do 60 i=1,10
        dtr(i)=zero
        coel(i)=' '
   60 continue

      do 70 i=1,12
        ire(i)=0
   70 continue

      do 80 i=1,nper
        msym(i)=0
   80 continue

      do i=1,6
        do j=1,6
          ta(i,j)=zero
        end do
      end do


      do i1=1,9
        do i2=1,18
          do i3=1,10
            do i4=1,5
              rtc(i1,i2,i3,i4)=zero
              rts(i1,i2,i3,i4)=zero
            end do
          end do
        end do
      end do

!--NUMBER OF PARTICLES--------------------------------------------------
      do i=1,npart
        do i1=1,6
          do i2=1,6
            tasau(i,i1,i2)=zero
          enddo
        enddo
      enddo

!--NUMBER OF ELEMENTS---------------------------------------------------
      do i=1,nele
        kz(i)=0
        kp(i)=0
        irm(i)=0
        imtr(i)=0
        nmu(i)=0
        kpa(i)=0
        isea(i)=0
        ncororb(i)=0
        iratioe(i)=0
        itionc(i)=0
        dki(i,1)=zero
        dki(i,2)=zero
        dki(i,3)=zero
        ed(i)=zero
        el(i)=zero
        ek(i)=zero
        sm(i)=zero
        xpl(i)=zero
        xrms(i)=zero
        zpl(i)=zero
        zrms(i)=zero
        benkc(i)=zero
        r00(i)=zero
        ratioe(i)=one
        hsyc(i)=zero
        phasc(i)=zero
        ptnfac(i)=zero
        acdipph(i)=zero
        crabph(i)=zero
        crabph2(i)=zero
        crabph3(i)=zero
        crabph4(i)=zero
        bez(i)=' '
        bezl(i)=' '
        do i3=1,2
          do i4=1,6
            a(i,i3,i4)=zero
          end do
        end do

        do 130 i1=1,mmul
          bk0(i,i1)=zero
          ak0(i,i1)=zero
          bka(i,i1)=zero
          aka(i,i1)=zero
  130   continue

        do 140 i1=1,3
          bezr(i1,i)=' '
  140   continue

        do i1=1,18
          parbe(i,i1)=zero
        enddo
      end do

!     From the FLUKA version
      do i=1,nele
         call SELNUL(i)
      end do

!--NUMBER OF BLOCKS-----------------------------------------------------
      do i=1,nblo
        mel(i)=0
        mstr(i)=0
        elbe(i)=zero
        bezb(i)=' '

        do i1=1,2
          do i2=1,6
            bl1(i,i1,i2)=zero
            bl2(i,i1,i2)=zero
          end do
        end do

        do j=1,nelb
          mtyp(i,j)=0
        end do
      end do

!--# OF STRUCTURE ELEMENTS----------------------------------------------
      do i=1,nblz
        ic(i)=0
        mzu(i)=0
        icext(i)=0
        icextal(i)=0
        extalign(i,1)=zero
        extalign(i,2)=zero
        extalign(i,3)=zero
        sigmoff(i)=zero
        tiltc(i)=one
        tilts(i)=zero

!--Beam-Beam------------------------------------------------------------
        imbb(i)=0               !Mapping from a STRUCTURE ELEMENT (here: index i)
                                ! to the beam-beam tables (arrays with size nbb)
!--Other stuff (not beam-beam)...
        do j=1,40
          exterr(i,j)=zero
          xsi(i)=zero
          zsi(i)=zero
          smi(i)=zero
          smizf(i)=zero

          do i1=1,mmul
            aai(i,i1)=zero
            bbi(i,i1)=zero
          end do

          do i3=1,mmul
            do i2=1,nmac
              aaiv(i3,i2,i)=zero
              bbiv(i3,i2,i)=zero
            end do
          end do

        end do
      end do

!-- BEAM-EXP------------------------------------------------------------
      beam_expflag = 0
      beam_expfile_open = .false.

!-- RANDOM NUMBERS-------------------------------------------------------
      do 200 i=1,nzfz
        zfz(i)=zero
  200 continue
!--# OF TRAJECTORIES----------------------------------------------------
      do 220 i=1,mpa
        rvf(i)=one
        sigm(i)=zero
        dps(i)=zero
        ejf(i)=zero
        do 210 i1=1,2
          x(i,i1)=zero
          y(i,i1)=zero
  210   continue
  220 continue

!--COMBINATION OF ELEMENTS----------------------------------------------
      do i1=1,20
        icomb0(i1)=0
        do i=1,ncom
          icomb(i,i1)=0
          ratio(i,i1)=zero
        end do
      end do

!--PAW------------------------------------------------------------------
      do i=1,nplo
        hmal(i)=0.0
      end do

!--TROMBONES------------------------------------------------------------
      do i=1,ntr
        do i1=1,6
          cotr(i,i1)=zero
          do i2=1,6
            rrtr(i,i1,i2)=zero
          end do
        end do
      end do

!--Beam-Beam------------------------------------------------------------
      do i=1,nbb
        do j=1,2
          sigman(j,i)=zero
          sigman2(j,i)=zero
          sigmanq(j,i)=zero
        end do

        do j=1,6
          clobeam(j,i)=zero
          beamoff(j,i)=zero
        end do

        do j=1,12
          bbcu(i,j)=zero
        end do

        bbcu(i,11)=one
      end do

!--DA-------------------------------------------------------------------
      do i1=1,2
        xx_da(i1)=0
        yy_da(i1)=0
        do i2=1,6
          alda_da(i1,i2)=0
          asda_da(i1,i2)=0
          aldaq_da(i1,i2)=0
          asdaq_da(i1,i2)=0
        end do
      end do

      do i=1,mcor
        smida_da(i)=0
      enddo

!--CADCUM---------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     initialise common
!     always in main code
      do i=0,nblz+1
         dcum(i)=zero
      end do

!--DUMP BEAM POPULATION-------------------------------------------------
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     K.Sjobak, BE-ABP/HSS
!     last modified: 03-09-2015
!     initialise common
!     always in main code
      call dump_comnul
      
!--FMA ANALYSIS---------------------------------------------------------
!     M. Fitterer, FNAL
!     last modified: 2016
      call fma_comnul
      
    !1) --ELEN - ELECTRON LENS---------------------------------------------------------
!     M. Fitterer (FNAL), A. Mereghetti
!     last modified: 09-02-2018
!     always in main code
!     elensparam - used for tracking (parameters of single element)
      do i=1,nele
         ielens(i) = 0
      end do
      melens=0
      do i=1,nelens
        elens_type(i)          = 0
        elens_theta_r2(i)      = zero
        elens_r2(i)            = zero
        elens_r1(i)            = zero
        elens_offset_x(i)      = zero
        elens_offset_y(i)      = zero
        elens_sig(i)           = zero
        elens_geo_norm(i)      = zero
        elens_len(i)           = zero
        elens_I(i)             = zero
        elens_Ek(i)            = zero
        elens_lThetaR2(i)      = .false.
        elens_iCheby(i)        = 0
        elens_cheby_angle(i)   = zero
      end do
!     table with coefficients of chebyshev polynominals
      do i=1,nelens_cheby_tables
         do j=1,16
            elens_cheby_filename(i)(j:j)=' '
         end do
         do i1=0,elens_cheby_order
            do i2=0,elens_cheby_order
               elens_cheby_coeffs(i1,i2,i)=zero
            end do
         end do
         elens_cheby_refCurr(i)=zero
         elens_cheby_refBeta(i)=zero
         elens_cheby_refRadius(i)=zero
      end do
!2) --WIRE - WIRE ELEMENT---------------------------------------------------------
!     M. Fitterer (FNAL), A. Patapenka (NIU)
!     last modified: 22-12-2016
!     wireparam - used for tracking (parameters of single element)
      do i=1,nele
        wire_flagco(i)  = 0
        wire_current(i) = 0
        wire_lint(i)    = 0
        wire_lphys(i)   = 0
        wire_dispx(i)   = 0
        wire_dispy(i)   = 0
        wire_tiltx(i)   = 0
        wire_tilty(i)   = 0
      end do

! 2) loop over structure elements
      do i=1,nblz
        wire_num(i)=0
      end do

! 3) loop over number of wires
      do i=1,wire_max
        do j=1,6
          wire_clo(j,i)=zero
        end do
      end do

!--APERTURE-------------------------------------------------------------
!     P.G.Ortega and A.Mereghetti, for the FLUKA Team
!     last modified: 02-03-2018
!     initialise common
!     always in main code
      call aperture_comnul

!--DYNAMIC KICKS--------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     initialise common
!     always in main code
!     - general-purpose variables
      call dynk_comnul
!--ZIPF-----------------------------------------------------------------
      call zipf_comnul
!--SCATTER--------------------------------------------------------------
      call scatter_comnul
!--HDF5-----------------------------------------------------------------
#ifdef HDF5
      call h5_comnul
#endif
!--COLLIMATION----------------------------------------------------------
#ifdef COLLIMAT
      call collimation_comnul
#endif
!--BDEX-----------------------------------------------------------------
      call bdex_comnul
!-----------------------------------------------------------------------
      return
end subroutine comnul

subroutine SELNUL( iel )
!-----------------------------------------------------------------------
!     A.Mereghetti, 2016-03-14
!     initialise a single element to empty
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use parpro
      use mod_common
      use mod_commons
      use aperture
      implicit none

!     local variables
      integer iel, i1, i3, i4

      kz(iel)=0
      kp(iel)=0
      irm(iel)=0
      imtr(iel)=0
      nmu(iel)=0
      kpa(iel)=0
      isea(iel)=0
      ncororb(iel)=0
      iratioe(iel)=0
      itionc(iel)=0
      dki(iel,1)=zero
      dki(iel,2)=zero
      dki(iel,3)=zero
      ed(iel)=zero
      el(iel)=zero
      ek(iel)=zero
      sm(iel)=zero
      xpl(iel)=zero
      xrms(iel)=zero
      zpl(iel)=zero
      zrms(iel)=zero
      benkc(iel)=zero
      r00(iel)=zero
      
      ratioe(iel)=one
      hsyc(iel)=zero
      phasc(iel)=zero
      ptnfac(iel)=zero
!      wirel(iel)=zero
      acdipph(iel)=zero
      crabph(iel)=zero
      crabph2(iel)=zero
      crabph3(iel)=zero
      crabph4(iel)=zero
      bez(iel)=' '
      bezl(iel)=' '

      do i3=1,2
        do i4=1,6
          a(iel,i3,i4)=zero
        end do
      end do

      do i1=1,mmul
         bk0(iel,i1)=zero
         ak0(iel,i1)=zero
         bka(iel,i1)=zero
         aka(iel,i1)=zero
      end do

      do i1=1,3
         bezr(i1,iel)=' '
      end do

      ! JBG increasing parbe to dimension 5
      do i1=1,5
         parbe(iel,i1)=zero
      end do

      call aperture_nul(iel)
      
      return
end subroutine SELNUL

subroutine STRNUL( iel )
!-----------------------------------------------------------------------
!     A.Mereghetti, 2016-03-14
!     initialise an element in lattice structure to empty
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use parpro
      use mod_common
      use mod_commonmn
      implicit none
      
!     local variables
      integer iel, i1, i2, i3, j

      ic(iel)=0
      mzu(iel)=0
      icext(iel)=0
      icextal(iel)=0
      extalign(iel,1)=zero
      extalign(iel,2)=zero
      extalign(iel,3)=zero
      sigmoff(iel)=zero
      tiltc(iel)=one
      tilts(iel)=zero

!--Beam-Beam------------------------------------------------------------
      imbb(iel)=0
      do j=1,40
         exterr(iel,j)=zero
      enddo
      xsi(iel)=zero
      zsi(iel)=zero
      smi(iel)=zero
      smizf(iel)=zero
      do i1=1,mmul
         aai(iel,i1)=zero
         bbi(iel,i1)=zero
      enddo
      do i3=1,mmul
         do i2=1,nmac
            aaiv(i3,i2,iel)=zero
            bbiv(i3,i2,iel)=zero
         enddo
      enddo
      return
end subroutine STRNUL

integer function INEELS( iEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     Insert a New Empty Element in Lattice Structure
!     interface variables:
!     - iEl: index in lattice structure where to insert the element
!     always in main code
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      use mod_commont
      use mod_commonmn
      implicit none

!     interface variables
      integer iEl

!     temporary variables
      integer i,ii,iInsert

      if ( iu.gt.nblz-3) then
         write(lout,*)'ERROR: not enough space for adding element in lattice structure!'
         write(lout,*)'       please, increase nblz and recompile!'
         call prror(-1)
      end if
      iu=iu+1
      if ( iEl.eq.0 ) then
!        append
         iInsert=iu
      elseif ( iEl .lt. 0 ) then
         iInsert=iu+iEl
      else
         iInsert=iEl
      end if
      if ( iInsert.le.iu ) then
!     shift by one all lattice elements, to make room for the new
!        starting marker
         do i=iu,iInsert+1,-1
            ic(i)=ic(i-1)
            icext(i)=icext(i-1)
            icextal(i)=icextal(i-1)
            extalign(i,1)=extalign(i-1,1)
            extalign(i,2)=extalign(i-1,2)
            extalign(i,3)=extalign(i-1,3)
            do ii=1,40
               exterr(i,ii)=exterr(i-1,ii)
            enddo
            dcum(i)=dcum(i-1)
         enddo
      endif

!     initialise element to empty
      call STRNUL(iInsert)
!     update dcum of added element
      dcum(iInsert)=dcum(iInsert-1)
!     return iu
      INEELS=iu
end function INEELS

integer function INEESE()
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     Insert a New Empty Element (empty) in SINGLE ELEMENTS
!     for the moment, it only appends the new single element
!     always in main code
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants
  use crcoall

  use parpro
  use parpro_scale
  use mod_common
  use mod_commont
  use mod_commonmn
  implicit none

  il=il+1
  if( il.gt.nele-2 ) then
    call expand_arrays(nele+50, npart, nblz, nblo )
    if (ithick.eq.1) then
      call expand_thickarrays(nele, npart, nblz, nblo )
    end if
  end if

! initialise element to empty
  call SELNUL(il)

! returned variable
  INEESE=il

end function INEESE

integer function check_SE_unique( iEl, ixEl )
!-----------------------------------------------------------------------
!     by A.Mereghetti
!     last modified: 01-12-2016
!     check that a given entry in the sequence is unique
!     interface variables:
!     - iEl:  index in lattice structure to be checked
!     - ixEl: index in array of SINGLE ELEMENTs of the element to be checked
!     always in main code
!-----------------------------------------------------------------------
  use floatPrecision
  use numerical_constants

  use parpro
  use mod_common
  use mod_commont
  use mod_commonmn
  implicit none

! interface variables
  integer iEl, ixEl

! temporary variables
  integer i,ix

  check_SE_unique=-1

  do i=1,iu
    ix=ic(i)-nblo
    if(ix.gt.0) then
!     SINGLE ELEMENT 
      if( i.ne.iEl .and. ix.eq.ixEl ) then
        check_SE_unique=i
        exit
      end if
    end if
  end do

  return
      
end function check_SE_unique

subroutine find_entry_at_s( sLoc, llast, iEl, ixEl, lfound )
!-----------------------------------------------------------------------
!     by A.Mereghetti (CERN, BE/ABP-HSS), 2018-03-22
!     find the element at location sLoc
!     interface variables:
!     - sLoc: s-coordinate where element should be
!     - iEl:  index in lattice structure of found element
!     - ixEl: index in array of SINGLE ELEMENTs of found element
!     - llast: if true, return last lens at sLoc
!     always in main code
!-----------------------------------------------------------------------
  use floatPrecision
  use mod_common     ! for iu, tlen, ic
  use parpro   
  use crcoall
  use end_sixtrack
  implicit none

! interface variables
  integer iEl, ixEl
  real(kind=fPrec) sLoc
  logical llast, lfound

! temporary variables
  integer i, iDelta, iCheck, iMax, iStep
  logical lSlide

  iEl=-1
  ixEl=-1

  if (sLoc.gt.tlen.or.sLoc.lt.zero) then
     write(lout,'(a,f11.4,a,f11.4,a)')&
 &         "requested s-location: ",sLoc," is not inside accelerator range: [0:",tlen,"]"
     call prror(-1)
  endif

  ! fast search
  iCheck=iu
  iDelta=iu
  do while(iDelta.gt.1.or.iCheck.gt.0.or.iCheck.lt.iu)
     if (dcum(iCheck).eq.sLoc) exit
     iDelta=nint(real(iDelta/2))
     if (dcum(iCheck).lt.sLoc) then
        iCheck=iCheck+iDelta
     else
        iCheck=iCheck-iDelta
     endif
  end do

  ! finalise search
  if (dcum(iCheck).lt.sLoc.or.(dcum(iCheck).eq.sLoc.and.llast)) then
     iMax=iu
     iStep=1
     lslide=llast
  else
     iMax=1
     iStep=-1
     lSlide=.not.llast
  endif
  do i=iCheck,iMax,iStep
     if (dcum(i).lt.sLoc) continue
     if (dcum(i).gt.sLoc) then
        if (iEl.eq.-1) iEl=i
     else
        iEl=i
        if (lSlide) continue
     endif
     exit
  enddo
  
  if (lfound) then
     ixEl=ic(iEl)-nblo
     if (ixEl.lt.0) ixEl=ic(iEl) ! drift
  else
     write(lout,'(a,f11.4,a,f11.4,a)')&
 &         "s-location: ",sLoc," was not found in acclerator range: [0:",tlen,"]"
     write(lout,*)"this is actually embarassing..."
  endif
  return
      
end subroutine find_entry_at_s

+dk distance
subroutine distance(x,clo,di0,t,dam)
!-----------------------------------------------------------------------
!  CALCULATION OF DISTANCE IN PHASE SPACE FOR POST-PROCESSING
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common, only : dpscor,sigcor,icode,idam,its6d
      implicit none
      integer i,ii,iq,j,jq
      real(kind=fPrec) clo,cx,dam,di0,phi,pi,sx,t,x,x1
      dimension x(2,6),x1(2,6),clo(6),di0(4),t(6,6),phi(3)
      save
!-----------------------------------------------------------------------
      pi=four*atan_mb(one)
      if(icode.ge.4.and.its6d.eq.0) then
        do i=1,2
          do j=1,4
            x(i,j)=x(i,j)-di0(j)*x(i,6)
          end do
        end do
      endif

      do 60 i=1,2
        do 20 j=1,6
          x(i,j)=x(i,j)-clo(j)
   20   continue

        if(its6d.eq.1) then
          x(i,2)=x(i,2)/((one+x(i,6))+clo(6))                            !hr06
          x(i,4)=x(i,4)/((one+x(i,6))+clo(6))                            !hr06
        endif

        do 40 iq=1,6
          x1(i,iq)=zero
          do 30 jq=1,6
            x1(i,iq)=x1(i,iq)+t(jq,iq)*x(i,jq)
   30     continue
   40   continue

        do 50 j=1,6
          x(i,j)=x1(i,j)
   50   continue

   60 continue

      do 70 i=1,2
        x(i,5)=x(i,5)*sigcor
        x(i,6)=x(i,6)*dpscor
   70 continue

      do 80 i=1,3
        ii=2*i
        sx=x(2,ii-1)*x(1,ii)-x(1,ii-1)*x(2,ii)
        cx=x(1,ii-1)*x(2,ii-1)+x(1,ii)*x(2,ii)
        if(abs(sx).gt.c1m15.or.abs(cx).gt.c1m15) then
          phi(i)=atan2_mb(sx,cx)
        else
          phi(i)=zero
        endif
   80 continue
      dam=sqrt((phi(1)**2+phi(2)**2+phi(3)**2)/real(idam,fPrec))/pi            !hr06
!-----------------------------------------------------------------------
      return
end subroutine distance

+dk anfb
      subroutine anfb(tas)
!-----------------------------------------------------------------------
!  CALCULATION OF INITIAL COORDINATES
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,ii,jj,l,ll
      real(kind=fPrec) bet0s1,bet0x2,bet0z2,chi,co,dchi,dpsic,dsign,si, &
     &tas,tas56,x1,x11,x13,x2
      dimension tas(6,6),x1(6),x2(6)
      save
!-----------------------------------------------------------------------
      write(lout,10030)
      if(itra.eq.0) goto 60
      tas56=tas(5,6)*c1m3
      bet0x2=tas(1,3)**2+tas(1,4)**2                                     !hr08
      bet0z2=tas(3,1)**2+tas(3,2)**2                                     !hr08
      bet0s1=tas(5,5)**2+tas56**2                                        !hr08
      dsign=one
      if(tas(3,3).lt.-one*pieni) rat=-one*rat                            !hr08
      if(rat.lt.-one*pieni) dsign=-one*one
      x11=amp(1)/(sqrt(bet0(1))+sqrt(abs(rat)*bet0x2))
      x13=(x11*dsign)*sqrt(abs(rat))                                     !hr08
      amp(2)=(dsign*real(1-iver,fPrec))*                                &!hr08
     &(abs(x11)*sqrt(bet0z2)+abs(x13)*sqrt(bet0(2)))                     !hr08
      x1(5)=zero
      if(iclo6.eq.1.or.iclo6.eq.2) then
        x1(6)=(dp1-clop6(3))*sqrt(bet0s1)
      else
        x1(6)=dp1*sqrt(bet0s1)
      endif
      chi=chi0*rad
      dchi=chid*rad
      do 50 i=1,itra
        si=sin_mb(chi)
        co=cos_mb(chi)
        x1(1)=x11*co
        x1(2)=x11*si
        x1(3)=x13*co
        x1(4)=x13*si
        do 20 ii=1,6
          x2(ii)=zero
          do 10 jj=1,6
            x2(ii)=x2(ii)+tas(ii,jj)*x1(jj)
   10     continue
   20   continue
        if(iclo6.eq.1.or.iclo6.eq.2) then
          x2(2)=x2(2)/((one+x2(6))+clop6(3))                             !hr08
          x2(4)=x2(4)/((one+x2(6))+clop6(3))                             !hr08
        endif
        if(abs(bet0s1).le.pieni) x2(6)=dp1
        if(iver.eq.1) then
          x2(3)=zero
          x2(4)=zero
        endif
        do 30 l=1,2
          ll=(l-1)*2
          x(i,l)=x2(1+ll)+exz(i,1+ll)
          y(i,l)=x2(2+ll)+exz(i,2+ll)
   30   continue
        sigm(i)=x2(5)+exz(i,5)
        dps(i)=x2(6)
        dpsic=dps(i)+clop6(3)
        if(idp.eq.1.and.abs(ition).eq.1.and.iclo6.eq.0) then
          do 40 l=1,2
            x(i,l)=x(i,l)+di0(l)*dpsic
            y(i,l)=y(i,l)+dip0(l)*dpsic
   40     continue
        endif
        chi=chi+dchi
   50 continue
      write(lout,10000) itra,amp,chi0,chid
      write(lout,10010) x(1,1), y(1,1), x(1,2), y(1,2), sigm(1), dps(1), x(2,1), y(2,1), x(2,2), y(2,2), sigm(2), dps(2)
      return
   60 itra=2
      do 80 i=1,itra
        sigm(i)=exz(i,5)
        dps(i)=exz(i,6)
        do 70 l=1,2
          ll=(l-1)*2
          x(i,l)=exz(i,1+ll)
          y(i,l)=exz(i,2+ll)
   70   continue
   80 continue
      write(lout,10020)
      write(lout,10010) x(1,1), y(1,1), x(1,2), y(1,2), sigm(1), dps(1), x(2,1), y(2,1), x(2,2), y(2,2), sigm(2), dps(2)
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY ANFB ----/ITRA/',i3,' /AMP/ ',f8.3,2x,f8.3, &
     &' /CHI0,CHID/  ',f6.1,2x,f6.1)
10010 format(/5x,'---- TWIN-TRAJECTORIES NO CL.ORBIT ADDED'/ 5x,'/X1  /'&
     &,f47.33/5x,'/XP1 /',f47.33/ 5x,'/Y1  /',f47.33/5x,'/YP1 /',f47.33/&
     &5x,'/SIG1/',f47.33/5x,'/DP1 /',f47.33/ 5x,'/X2  /',f47.33/5x,     &
     &'/XP2 /',f47.33/ 5x,'/Y2  /',f47.33/5x,'/YP2 /',f47.33/ 5x,       &
     &'/SIG2/',f47.33/5x,'/DP2 /',f47.33/)
10020 format(t5,'---- ENTRY ANFB ----/COORDINATE-INPUT')
10030 format(//131('-')//t10,27('O')/t10,2('O'),23x,2('O')/t10,         &
     &'OO  INITIAL COORDINATES  OO'/ t10,2('O'),23x,2('O')/t10,27('O')  &
     &//131('-')//)
      end

+dk betalf
      subroutine betalf(dpp,qw)
!-----------------------------------------------------------------------
!  CALCULATION OF : OPT. PARAMETERS AT THE STARTING POSITION:
!                   BETA-, ALFA-FUNCTIONS, Q-VALUES
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,j
      real(kind=fPrec) am,det,detb,detc,dpp,egwg1,egwg2,f0,f1,f2,fak1,  &
     &fak2,qw,rca1,rca2,rclam1,rclam2,rcw1(4),rcw2(4),rn1,rn2,spa,spd,  &
     &sqrn,yca1,yca2,yclam1,yclam2,ycw1(4),ycw2(4)
      dimension am(4,4)
      dimension qw(2)
      save
!-----------------------------------------------------------------------
      ierro=0
      call matrix(dpp,am)
!--CALCULATION OF EIGENVALUES
   10 spa=am(1,1)+am(2,2)
      spd=am(3,3)+am(4,4)
      det=(am(1,3)+am(4,2))*(am(2,4)+am(3,1))                           &
     &-(am(1,4)-am(3,2))*(am(2,3)-am(4,1))
      f0=spa-spd
      f1=spa+spd
      f2=f0**2+four*det                                                  !hr06
      if(f2 .lt. zero) goto 160
      f2=sqrt(f2)
      if(f0.lt.zero) goto 30                                              !hr06
      if(f0.ge.zero) goto 20                                              !hr06
   20 egwg1=(f1+f2)*half
      egwg2=(f1-f2)*half
      goto 40
   30 egwg1=(f1-f2)*half
      egwg2=(f1+f2)*half
   40 continue
      f1=egwg1**2-four                                                   !hr06
      f2=egwg2**2-four                                                   !hr06
      rca1=f1
      yca1=zero
      rca2=f2
      yca2=zero
      if (rca1.ge.0) then
        rca1=sqrt(rca1)
      else
        yca1=sqrt(-one*rca1)                                             !hr06
        rca1=zero
      endif
      if (rca2.ge.0) then
        rca2=sqrt(rca2)
      else
        yca2=sqrt(-one*rca2)                                             !hr06
        rca2=zero
      endif
      rclam1=(egwg1+rca1)*half
      yclam1=yca1*half
      rclam2=(egwg2+rca2)*half
      yclam2=yca2*half
      if(egwg1**2 .ge. four) goto 160                                    !hr06
      if(egwg2**2 .ge. four) goto 160                                    !hr06
   50 continue
      detb=am(1,3)*am(2,4)-am(1,4)*am(2,3)
      detc=am(3,1)*am(4,2)-am(3,2)*am(4,1)
      fak1=spd-egwg1
      if(abs(fak1).gt.pieni) then
        rcw1(1)=am(1,2)-(am(1,3)*am(3,2)+am(1,4)*am(4,2))/fak1           !hr06
        ycw1(1)=zero
        rcw1(2)=((am(1,3)*am(3,1)+am(1,4)*am(4,1))+detb)/fak1-(am(1,1)  &!hr06
     &-rclam1)                                                           !hr06
        ycw1(2)=yclam1
      rcw1(3)=-one*((am(3,1)+am(2,4))*rcw1(1)+(am(3,2)-am(1,4))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(3)=-one*((am(3,1)+am(2,4))*ycw1(1)+(am(3,2)-am(1,4))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      rcw1(4)=-one*((am(4,1)-am(2,3))*rcw1(1)+(am(4,2)+am(1,3))*rcw1(2))&!hr06
     &/fak1                                                              !hr06
      ycw1(4)=-one*((am(4,1)-am(2,3))*ycw1(1)+(am(4,2)+am(1,3))*ycw1(2))&!hr06
     &/fak1                                                              !hr06
      else
        rcw1(1)=am(1,2)
        ycw1(1)=zero
        rcw1(2)=rclam1-am(1,1)                                           !hr06
        ycw1(2)=yclam1
        rcw1(3)=zero
        ycw1(3)=zero
        rcw1(4)=zero
        ycw1(4)=zero
      endif
      fak2=spa-egwg2
      if(abs(fak2).gt.pieni) then
        rcw2(3)=am(3,4)-(am(3,1)*am(1,4)+am(3,2)*am(2,4))/fak2           !hr06
        ycw2(3)=zero
        rcw2(4)=((am(3,1)*am(1,3)+am(3,2)*am(2,3))+detc)/fak2-(am(3,3)  &!hr06
     &-rclam2)                                                           !hr06
        ycw2(4)=yclam2
      rcw2(1)=-one*((am(1,3)+am(4,2))*rcw2(3)+(am(1,4)-am(3,2))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(1)=-one*((am(1,3)+am(4,2))*ycw2(3)+(am(1,4)-am(3,2))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      rcw2(2)=-one*((am(2,3)-am(4,1))*rcw2(3)+(am(2,4)+am(3,1))*rcw2(4))&!hr06
     &/fak2                                                              !hr06
      ycw2(2)=-one*((am(2,3)-am(4,1))*ycw2(3)+(am(2,4)+am(3,1))*ycw2(4))&!hr06
     &/fak2                                                              !hr06
      else
        rcw2(3)=am(3,4)
        ycw2(3)=zero
        rcw2(4)=rclam2-am(3,3)                                           !hr06
        ycw2(4)=yclam2
        rcw2(1)=zero
        ycw2(1)=zero
        rcw2(2)=zero
        ycw2(2)=zero
      endif

!--LEAVING COMPLEX NUMBERS
      do 60 i=1,4
        ta(i,1)=rcw1(i)
        ta(i,3)=rcw2(i)
        ta(i,2)=ycw1(i)
        ta(i,4)=ycw2(i)
   60 continue

!--NORMALISATION OF EIGENVALUES
      rn1=((ta(1,1)*ta(2,2)-ta(2,1)*ta(1,2))                            &!hr06
     &+ta(3,1)*ta(4,2))-ta(4,1)*ta(3,2)                                  !hr06
      if(rn1.lt.zero) goto 70                                             !hr06
      if(rn1.eq.zero) goto 160                                            !hr06
      if(rn1.gt.zero) goto 90                                             !hr06
   70 yclam1=-one*yclam1                                                 !hr06

      do i=1,4
        ta(i,2)=-one*ta(i,2)                                               !hr06
      end do

   90 sqrn=sqrt(abs(rn1))

      do i=1,4
        ta(i,1)=ta(i,1)/sqrn
        ta(i,2)=ta(i,2)/sqrn
      end do

      rn2=((ta(1,3)*ta(2,4)-ta(2,3)*ta(1,4))                            &!hr06
     &+ta(3,3)*ta(4,4))-ta(4,3)*ta(3,4)                                  !hr06
      if(rn2.lt.zero) goto 110                                           !hr06
      if(rn2.eq.zero) goto 160                                           !hr06
      if(rn2.gt.zero) goto 130                                           !hr06
  110 yclam2=-one*yclam2                                                 !hr06

      do i=1,4
        ta(i,4)=-one*ta(i,4)                                               !hr06
      end do

  130 sqrn=sqrt(abs(rn2))

      do i=1,4
        ta(i,3)=ta(i,3)/sqrn
        ta(i,4)=ta(i,4)/sqrn
      end do

      qw(1)= atan_mb(yclam1/(one+rclam1))/pi
      qw(2)= atan_mb(yclam2/(one+rclam2))/pi

!-----------------------------------------------------------------------
!  OPTICAL PARAMETERS AT THE STARTING POINT
!-----------------------------------------------------------------------
      betx(1)=ta(1,1)**2+ta(1,2)**2                                      !hr06
      alfx(1)=-one*(ta(1,1)*ta(2,1)+ta(1,2)*ta(2,2))                     !hr06
      betx(2)=ta(1,3)**2+ta(1,4)**2                                      !hr06
      alfx(2)=-one*(ta(1,3)*ta(2,3)+ta(1,4)*ta(2,4))                     !hr06
      betz(1)=ta(3,1)**2+ta(3,2)**2                                      !hr06
      alfz(1)=-one*(ta(3,1)*ta(4,1)+ta(3,2)*ta(4,2))                     !hr06
      betz(2)=ta(3,3)**2+ta(3,4)**2                                      !hr06
      alfz(2)=-one*(ta(3,3)*ta(4,3)+ta(3,4)*ta(4,4))                     !hr06
      bet0(1)=betx(1)
      alf0(1)=alfx(1)
      bet0(2)=betz(2)
      alf0(2)=alfz(2)

      if(ta(1,1).lt.-pieni) then
        do i=1,4
          do j=1,4
            ta(i,j)=-one*ta(i,j)
          end do
        end do
      endif

      return
!-----------------------------------------------------------------------
  160 ierro=1
      return
      end
+dk blocksv
subroutine blocksv
  use floatPrecision
  use numerical_constants

  use parpro
  use mod_common
  use mod_commonmn
  use mod_commons
  use mod_commont
  use mod_commond
  implicit none

      integer n, ia, ikk, j, jm, k, lkk, mkk
      real(kind=fPrec) dpoff
!     integer i,itiono,i1,i2,i3,ia,ia2,iar,iation,ib,ib0,ib1,ib2,ib3,id,&
!    &idate,ie,ig,ii,ikk,im,imonth,iposc,irecuin,itime,ix,izu,j,j2,jj,  &
!    &jm,k,kpz,kzz,l,lkk,ll,m,mkk,napxto,ncorruo,ncrr,nd,nd2,ndafi2,    &
!    &nerror,nlino,nlinoo,nmz,nthinerr
!     double precision alf0s1,alf0s2,alf0s3,alf0x2,alf0x3,alf0z2,alf0z3,&
!    &amp00,bet0s1,bet0s2,bet0s3,bet0x2,bet0x3,bet0z2,bet0z3,chi,coc,   &
!    &dam1,dchi,ddp1,dp0,dp00,dp10,dpoff,dpsic,dps0,dsign,gam0s1,gam0s2,&
!    &gam0s3,gam0x1,gam0x2,gam0x3,gam0z1,gam0z2,gam0z3,phag,r0,r0a,rat0,&
!    &rdev,rmean,rsqsum,rsum,sic,tasia56,tasiar16,tasiar26,tasiar36,    &
!    &tasiar46,tasiar56,tasiar61,tasiar62,tasiar63,tasiar64,tasiar65,   &
!    &taus,x11,x13

  save

#ifdef FLUKA
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 11-06-2014
!     entirely re-initialise to 0.0 hv(...) and bl1v(...) arrays
!     inserted in main code by the 'fluka' compilation flag
      do ia=1,npart
        do k=1,nblo
          do lkk=1,2
            do mkk=1,6
              hv(mkk,lkk,ia,k)=zero
              bl1v(mkk,lkk,ia,k)=zero
            end do
          end do
        end do
      end do
#endif
      do 440 k=1,mblo
        jm=mel(k)
        ikk=mtyp(k,1)
        do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(mkk,lkk,ia,1)=al(mkk,lkk,ia,ikk)
              if(mkk.eq.5.or.mkk.eq.6) then
                hv(mkk,lkk,ia,1)=hv(mkk,lkk,ia,1)/dpoff
              end if
            end do
          end do
        end do
        if(jm.eq.1) goto 410
        do j=2,jm
          ikk=mtyp(k,j)
          do lkk=1,2
            do ia=1,napx
              dpoff=dpsv(ia)*c1e3
              if(abs(dpoff).le.pieni) dpoff=one
              hv(1,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(2,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(2,lkk,ia,ikk)
              hv(3,lkk,ia,j)=hv(1,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(3,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
              hv(4,lkk,ia,j)=hv(2,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(4,   &
     &lkk,ia,j-1)*al(4,lkk,ia,ikk)
!hr05         hv(5,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(2,lkk,ia,ikk)+al(5,lkk,ia,ikk)/dpoff
              hv(5,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(1,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(2,lkk,ia,ikk))+al(5,lkk,ia,ikk)/dpoff               !hr05
!hr05         hv(6,lkk,ia,j)=hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,   &
!hr05&lkk,ia,j-1)*al(4,lkk,ia,ikk)+al(6,lkk,ia,ikk)/dpoff
              hv(6,lkk,ia,j)=(hv(5,lkk,ia,j-1)*al(3,lkk,ia,ikk)+ hv(6,  &!hr05
     &lkk,ia,j-1)*al(4,lkk,ia,ikk))+al(6,lkk,ia,ikk)/dpoff               !hr05
            end do
          end do
        end do
  410   do lkk=1,2
          do mkk=1,6
            do ia=1,napx
              bl1v(mkk,lkk,ia,k)=hv(mkk,lkk,ia,jm)
            end do
          end do
        end do
  440 continue
      end
+dk block
      subroutine block
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,j,jm,k,l,m,n
      real(kind=fPrec) g,h
      dimension h(nblo,2,6),g(nblo,2,6)
      save
!-----------------------------------------------------------------------
      do k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)

        do l=1,2
          do m=1,6
            h(1,l,m)=a(i,l,m)
            g(1,l,m)=a(n,l,m)
          end do
        end do

        if(jm.eq.1) goto 40

        do j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do l=1,2
            h(j,l,1)=h(j-1,l,1)*a(i,l,1)+h(j-1,l,3)*a(i,l,2)
            h(j,l,2)=h(j-1,l,2)*a(i,l,1)+h(j-1,l,4)*a(i,l,2)
            h(j,l,3)=h(j-1,l,1)*a(i,l,3)+h(j-1,l,3)*a(i,l,4)
            h(j,l,4)=h(j-1,l,2)*a(i,l,3)+h(j-1,l,4)*a(i,l,4)
            g(j,l,1)=g(j-1,l,1)*a(n,l,1)+g(j-1,l,3)*a(n,l,2)
            g(j,l,2)=g(j-1,l,2)*a(n,l,1)+g(j-1,l,4)*a(n,l,2)
            g(j,l,3)=g(j-1,l,1)*a(n,l,3)+g(j-1,l,3)*a(n,l,4)
            g(j,l,4)=g(j-1,l,2)*a(n,l,3)+g(j-1,l,4)*a(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*a(i,l,1)+h(j-1,l,6)*a(i,l,2))+a(i,l,5)  !hr06
            h(j,l,6)=(h(j-1,l,5)*a(i,l,3)+h(j-1,l,6)*a(i,l,4))+a(i,l,6)  !hr06
            g(j,l,5)=(g(j-1,l,5)*a(n,l,1)+g(j-1,l,6)*a(n,l,2))+a(n,l,5)  !hr06
            g(j,l,6)=(g(j-1,l,5)*a(n,l,3)+g(j-1,l,6)*a(n,l,4))+a(n,l,6)  !hr06
          end do
        end do

   40   do l=1,2
          do m=1,6
            bl1(k,l,m)=h(jm,l,m)
            bl2(k,l,m)=g(jm,l,m)
          end do
        end do

      end do

      return
      end

+dk blockdis
      subroutine blockdis(aeg,bl1eg,bl2eg)
!-----------------------------------------------------------------------
!  COMBINATION OF LINEAR ELEMENTS TO ONE MATRIX, USED FOR DISPERSION
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,j,jm,k,l,m,n
      real(kind=fPrec) aeg,bl1eg,bl2eg,g,h
      dimension h(nblo,2,6),g(nblo,2,6)
      dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
      save
!-----------------------------------------------------------------------
      do k=1,mblo
        jm=mel(k)
        i=mtyp(k,1)
        n=mtyp(k,jm)

        do l=1,2
          do m=1,6
            h(1,l,m)=aeg(i,l,m)
            g(1,l,m)=aeg(n,l,m)
          end do
         end do

        if(jm.eq.1) goto 40

        do j=2,jm
          i=mtyp(k,j)
          n=mtyp(k,jm-j+1)
          do l=1,2
            h(j,l,1)=h(j-1,l,1)*aeg(i,l,1)+h(j-1,l,3)*aeg(i,l,2)
            h(j,l,2)=h(j-1,l,2)*aeg(i,l,1)+h(j-1,l,4)*aeg(i,l,2)
            h(j,l,3)=h(j-1,l,1)*aeg(i,l,3)+h(j-1,l,3)*aeg(i,l,4)
            h(j,l,4)=h(j-1,l,2)*aeg(i,l,3)+h(j-1,l,4)*aeg(i,l,4)
            g(j,l,1)=g(j-1,l,1)*aeg(n,l,1)+g(j-1,l,3)*aeg(n,l,2)
            g(j,l,2)=g(j-1,l,2)*aeg(n,l,1)+g(j-1,l,4)*aeg(n,l,2)
            g(j,l,3)=g(j-1,l,1)*aeg(n,l,3)+g(j-1,l,3)*aeg(n,l,4)
            g(j,l,4)=g(j-1,l,2)*aeg(n,l,3)+g(j-1,l,4)*aeg(n,l,4)
            h(j,l,5)=(h(j-1,l,5)*aeg(i,l,1)+h(j-1,l,6)*aeg(i,l,2))+aeg  &!hr06
     &(i,l,5)                                                            !hr06
            h(j,l,6)=(h(j-1,l,5)*aeg(i,l,3)+h(j-1,l,6)*aeg(i,l,4))+aeg  &!hr06
     &(i,l,6)                                                            !hr06
            g(j,l,5)=(g(j-1,l,5)*aeg(n,l,1)+g(j-1,l,6)*aeg(n,l,2))+aeg  &!hr06
     &(n,l,5)                                                            !hr06
            g(j,l,6)=(g(j-1,l,5)*aeg(n,l,3)+g(j-1,l,6)*aeg(n,l,4))+aeg  &!hr06
     &(n,l,6)                                                            !hr06
          end do
        end do

   40   do l=1,2
          do m=1,6
            bl1eg(k,l,m)=h(jm,l,m)
            bl2eg(k,l,m)=g(jm,l,m)
          end do
        end do

      end do

      return
      end

+dk chroma
subroutine chroma
!-----------------------------------------------------------------------
!  CALCULATION OF CHROMATICITY FROM 5 ENERGIE-VALUES
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,ii,isl,j,jj,l,n
      real(kind=fPrec) cor,coro,cro0,de2,det,dm,dpp,dsm,ox,oz,qwc,sens,sm0,su2,suxy,suzy,xi,zi
      dimension dsm(2,4),sens(2,4),xi(2),zi(2),dm(2),sm0(2)
      dimension qwc(3),cro0(2)
      save
!-----------------------------------------------------------------------
      cor=zero
      coro=1.0e38_fPrec

      do i=1,2
        do j=1,4
          dsm(i,j)=zero
          sens(i,j)=zero
        end do
      end do

      do i=1,2
        xi(i)=zero
        zi(i)=zero
        dm(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        cro0(i)=zero
      end do

      qwc(3)=zero
      write(lout,10010)
      dsm(1,2)=dsm0
      dsm(2,3)=dsm0
      de2=de0*half
      do 90 jj=1,itcro
        do 80 ii=1,4
          su2=zero
          suxy=zero
          suzy=zero
          do 30 l=1,2
            isl=is(l)
            if(kz(isl).ne.3) call prror(11)
            ed(isl)=ed(isl)+dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   30     continue
          do 40 n=1,5
            dpp=de2*real(3-n,fPrec)                                            !hr06
            call clorb(dpp)
            if(ierro.gt.0) call prror(12)
            call phasad(dpp,qwc)
            if(ierro.gt.0) call prror(13)
            ox=qwc(1)
            oz=qwc(2)
            su2=su2+dpp**2                                               !hr06
            suxy=suxy+ox*dpp
            suzy=suzy+oz*dpp
   40     continue
          do 50 l=1,2
            isl=is(l)
            ed(isl)=ed(isl)-dsm(l,ii)
            if(kp(isl).eq.5) call combel(isl)
   50     continue
          sens(1,ii)=suxy/su2
          sens(2,ii)=suzy/su2
          if(ii.ne.3) goto 80

!--COMPENSATION OF CHROMATICITY
          do l=1,2
            cro0(l)=sens(l,1)-cro(l)
            xi(l)=(sens(1,l+1)-sens(1,1))/dsm0
            zi(l)=(sens(2,l+1)-sens(2,1))/dsm0
          end do

          cor=sqrt(cro0(1)**2+cro0(2)**2)                                !hr06
          if(jj.eq.1.or.cor.lt.coro) then
            coro=cor
            det=xi(1)*zi(2)-zi(1)*xi(2)
            dm(1)=(cro0(2)*xi(2)-cro0(1)*zi(2))/det                      !hr06
            dm(2)=(cro0(1)*zi(1)-cro0(2)*xi(1))/det                      !hr06

            do l=1,2
              sm0(l)=ed(is(l))
              isl=is(l)
              ed(isl)=ed(isl)+dm(l)
              if(kp(isl).eq.5) call combel(isl)
            end do
          else
            write(lout,10035)
            return
          endif
   80   continue
        write(lout,10020) sens(1,1),sens(1,4),sens(2,1),sens(2,4)
        chromc(1)=sens(1,4)*c1m3
        chromc(2)=sens(2,4)*c1m3
        write(lout,10030) sm0(1),ed(is(1)),bez(is(1)), sm0(2),ed(is(2)),&
     &bez(is(2))
        write(lout,10040) xi,zi
        write(lout,10010)
        if(abs(sens(1,4)-cro(1)).lt.dech.and.abs(sens(2,4)-cro(2))      &
     &.lt.dech) return
   90 continue
      write(lout,10000) itcro
!-----------------------------------------------------------------------
      return
10000 format(/131('-')//t10,'CHROMATICITY CORRECTION'/t10,              &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(/131('-')//t10,'DATA BLOCK CHROMATICITY CORRECTION'/t10,   &
     &'CHROMATICITIES         BEFORE           AFTER CORRECTION'/t10,   &
     &'HORIZONTAL       ',d17.10,7x,d17.10/ t10,'VERTICAL         ',d17.&
     &10,7x,d17.10/)
10040 format(t10,'SEXTUPOLE SENSITIVITIES    XI/M1 XI/M2 YI/M1 YI/M2  ',&
     &4d15.8)
10030 format(t10,'SEXTUP.STRENGTHS ',g17.10,7x,g17.10,'   INDEX   ',a16/&
     &t10,'                 ',g17.10,7x,g17.10,'           ',a16)
10035 format(/t5,'---- NO Improvement in last Step ----'/)
end subroutine chroma

      subroutine chromda
!-----------------------------------------------------------------------
!  CHROMATICITY CORRECTION VIA DA
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer icht,iq1,iq2,ix,ncorr,ncorruo,nd,nd2
      real(kind=fPrec) cor,coro,dps0,dq1,dq2,edcor1,edcor2,qw,qwc
      dimension qw(2),qwc(3)
      save
!-----------------------------------------------------------------------
      write(lout,10000)
      nd=2
      nd2=4
      dps(1)=dp1+dppoff
      ncorruo=ncorru
      ncorru=1
      call clorb(dp1)
      call betalf(dp1,qw)
      call phasad(dp1,qwc)
      if(nbeam.ge.1) then
#include "include/beamcou.f90"
#ifdef DEBUG
!     call dumpbin('abeamcou2',3,33)
!     call abend('after beam coupling                               ')
#endif
      endif
      ncorru=ncorruo
      iq1=is(1)
      iq2=is(2)
      edcor(1)=ed(iq1)
      edcor(2)=ed(iq2)
      edcor1=edcor(1)
      edcor2=edcor(2)
      coro=1e38_fPrec
      cor=0
      ncorr=0
      do ncorr=1,itcro+1
        ichromc=2
        call mydaini(1,1,nd2,nd,nd2,1)
        ichromc=1
        call mydaini(2,4,7,2,5,1)
        dq1=corr(1,1)-cro(1)*c1m3
        dq2=corr(1,2)-cro(2)*c1m3
        if(ncorr.eq.1) cor=c1e3*sqrt(dq1**2+dq2**2)                      !hr06
        if(cor.gt.dech) then
          cor=c1e3*sqrt(dq1**2+dq2**2)                                   !hr06
          if(ncorr.eq.1.or.cor.lt.coro) then
            coro=cor
            ed(iq1)=(ed(iq1)-corr(2,1)*dq1)-corr(2,2)*dq2                !hr06
            ed(iq2)=(ed(iq2)-corr(3,1)*dq1)-corr(3,2)*dq2                !hr06
            do icht=1,iu
              ix=ic(icht)
              if(ix.gt.nblo) then
                ix=ix-nblo
                if(ix.eq.iq1.or.iratioe(ix).eq.iq1) then
                  smi(icht)=ed(iq1)*ratioe(ix)+smizf(icht)
                else if(ix.eq.iq2.or.iratioe(ix).eq.iq2) then
                  smi(icht)=ed(iq2)*ratioe(ix)+smizf(icht)
                endif
              endif
            enddo
            edcor(1)=ed(iq1)
            edcor(2)=ed(iq2)
            if(ncorr.eq.1) then
              write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            else
              write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),           &
     &corr(1,2)*c1e3,ncorr-1,cor
              write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2), &
     &bez(iq2)
            endif
          else
            write(lout,10040) ncorr-1
            goto 1
          endif
        else
          write(lout,10050) ncorr-1
          goto 1
        endif
      enddo
 1    continue
      chromc(1)=corr(1,1)
      chromc(2)=corr(1,2)
      if(ncorr.eq.itcro+1) write(lout,10060) itcro
      if(ncorr.eq.1) then
        write(lout,10010) cro(1),corr(1,1)*c1e3,cro(2),                 &
     &corr(1,2)*c1e3,ncorr-1,cor
      else
        write(lout,10020) cro(1),corr(1,1)*c1e3,cro(2),corr(1,2)*c1e3,  &
     &ncorr-1,cor
      endif
      write(lout,10030) edcor1,ed(iq1),bez(iq1),edcor2,ed(iq2),bez(iq2)
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING DA CHROMATICITY CORRECTION'/)
10010 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        BEFORE CORRECTION'/ t10,   &
     &'HORIZONTAL'     ,15x,G21.14,1x,G21.14/ t10,                      &
     &'VERTICAL'       ,17x,G21.14,1x,G21.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10020 format(/131('-')/t10,                                             &
     &'CHROMATICITY'   ,18x,'THEORET.        AFTER CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G21.14,1x,G21.14/ t10,                      &
     &'VERTICAL'       ,17x,G21.14,1x,G21.14// t10,                     &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10030 format(t10,'SEXTUPOLE STRENGTH',5x,g17.10,2x,g17.10,'   TYP     ',&
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
10040 format(/t5,'---- NO IMPROVEMENT OF DA CHROMATICITY CORRECTION ',  &
     &'IN ITERATION: ',i4/)
10050 format(t5/t10,'DA CHROMATICITY CORRECTION SUCCESSFUL IN ',        &
     &'ITERATION: ',i4/)
10060 format(/t10,'DA CHROMATICITY CORRECTION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
      end

+dk clorb
      subroutine clorb(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT   'CLO(2),CLOP(2)'
!-----------------------------------------------------------------------
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer ierr,ii,l,ll
      real(kind=fPrec) am,cor,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,  &
     &dy,x0,x1,y0,y1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
      save ! Saving DPP?
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=c1e6
        dy(l)=c1e6
   10 continue
      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) return
      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &goto 50

        do l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
         y0(l)=y(1,l)
        end do

        call matrix(dpp,am)
        if(ierro.ne.0) return
        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=(two-am(ll-1,ll-1))-am(ll,ll)                              !hr06
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue
   40 continue
      if(ncorru.ne.1) write(lout,10000) itco
   50 cor=c1e3*sqrt(dcx**2+dcz**2)                                       !hr06
      if(iout.eq.1.and.ncorru.ne.1) then
        write(lout,10010) dpp,clo(1),clop(1),clo(2),clop(2),ii,cor
#ifdef DEBUG
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('dpp',dpp,0,0,0,0)
!     call warr('clo(1)',clo(1),0,0,0,0)
!     call warr('clop(1)',clop(1),0,0,0,0)
!     call warr('clo(2)',clo(2),0,0,0,0)
!     call warr('clop(2)',clop(2),0,0,0,0)
!     call warr('ii',0d0,ii,0,0,0)
!     call warr('cor',cor,0,0,0,0)
#endif
      endif
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(t5,'---- ENTRY CLORB ----/DPP=',f8.5,' /CLOX/', 2f10.5,    &
     &' /CLOY/',2f10.5,' /ITERAT.=',i3,'/ ACCURACY=',d13.6)
      end

+dk clor6
      subroutine clorda(nn,idummy,am)
!-----------------------------------------------------------------------
!  CALCULATION OF THE SIX-DIMENSIONAL CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use matrix_inv
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer i,i4,icheck,ii,j,j4,k,l,ll,nd2,nn
      real(kind=fPrec) am,cloc,cor,coro,dc,dd,dlo,xx
      integer idummy(nn)
      character(len=6) chp(3),chd(3)
      dimension xx(6),dlo(6),cloc(6),dd(6),dc(6),am(nn,nn)
      integer nerror
      save
!-----------------------------------------------------------------------
      nd2=2*ndimf
      write(lout,10010) nd2
      do l=1,nd2
        xx(l)=zero
        cloc(l)=zero
        dd(l)=zero
        dc(l)=zero
        dlo(l)=zero
        do i=1,nd2
          am(l,i)=zero
        enddo
      enddo
      chp(1)=' CLOX '
      chp(2)=' CLOY '
      chp(3)=' CLOS '
      chd(1)='  D-X '
      chd(2)='  D-Y '
      chd(3)='  D-S '
      cor=zero
      coro=1e38_fPrec
      ii=0
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          cloc(ll-1)=clo6(l)
          cloc(ll)=clop6(l)
        enddo
        cloc(5)=clo6(3)
        cloc(6)=clop6(3)
        if(abs(dppoff).gt.pieni) cloc(6)=dppoff
      else
        do l=1,ndimf
          ll=2*l
          cloc(ll-1)=clo(l)
          cloc(ll)=clop(l)
        enddo
        do l=ndimf+1,3
          ll=2*l
          cloc(ll-1)=zero
          cloc(ll)=zero
        enddo
        cloc(6)=dps(1)
      endif
      do 80 ii=1,itco
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
#ifdef DEBUG
!       write(*,*) 'Calling UMLAUDA from clorda'
!       call warr('cloc5',cloc(5),0,0,0,0)
!       call warr('cloc6',cloc(6),0,0,0,0)
#endif
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
#ifdef DEBUG
!       call warr('ambef',am(i4,j4),i4,j4,0,0)
#endif
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
#ifdef DEBUG
!       do i4=1,nd2
!         do j4=1,nd2
!     call warr('amaft',am(i4,j4),i4,j4,0,0)
!         enddo
!       enddo
#endif
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dd(l)=cloc(l)-xx(l)
          dc(l)=abs(dd(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
#ifdef DEBUG
!       call warr('ddl',dd(l),l,1,0,0)
!       call warr('dcl',dc(l),l,1,0,0)
#endif
        enddo
        icheck=0
        do l=1,ndimf
          ll=2*l
          if(dc(ll-1).gt.dma) icheck=1
          if(dc(ll).gt.dmap) icheck=1
        enddo
        if(icheck.eq.0) goto 90
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
#ifdef DEBUG
!     call warr('corl ll',cor,l,ll,1,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,1,0)
#endif
          cor=cor+dc(ll-1)**2                                            !hr06
#ifdef DEBUG
!         call warr('acor',cor,l,ll,1,0)
#endif
        enddo
        cor=sqrt(cor)
#ifdef DEBUG
!       call warr('vital',0d0,ii,0,0,0)
!       call warr('corlll',cor,l,ll,1,0)
!       call warr('coro',coro,l,ll,1,0)
#endif
        if(ii.eq.1.or.cor.lt.coro) then
#ifdef DEBUG
!       call warr('cor',cor,2,0,0,0)
!       call warr('coro',coro,2,0,0,0)
#endif
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          if(ii.ne.itco) then
            write(lout,10030)
            do l=1,ndimf
              ll=2*l
              write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
            enddo
            write(lout,10080) ii,cor
          endif
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
 80   continue
      write(lout,10000) itco
      ii=itco
 90   continue
      if(ii.ne.itco) then
        do k=1,nd2
          dlo(k)=zero
          do j=1,nd2
            dlo(k)=am(k,j)*dd(j)+dlo(k)
          enddo
          if(abs(dppoff).gt.pieni) dlo(6)=zero
        enddo
        write(lout,10020)
        cor=zero
        do l=1,ndimf
          ll=2*l
          write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
#ifdef DEBUG
!     call warr('corl ll',cor,l,ll,2,0)
!     call warr('dcll*2',dc(ll-1)**2,l,ll,2,0)
#endif
          cor=cor+dc(ll-1)**2                                            !hr06
#ifdef DEBUG
!         call warr('acor',cor,l,ll,2,0)
#endif
        enddo
        cor=sqrt(cor)
#ifdef DEBUG
!       call warr('cor',cor,3,0,0,0)
!       call warr('coro',coro,3,0,0,0)
#endif
        if(cor.lt.coro) then
          coro=cor
          do l=1,nd2
            cloc(l)=cloc(l)+dlo(l)
          enddo
          write(lout,10030)
          do l=1,ndimf
            ll=2*l
            write(lout,10060) chp(l),cloc(ll-1),cloc(ll)
          enddo
          write(lout,10080) ii,cor
        else
          write(lout,10040) nd2,ii
          goto 91
        endif
        do l=1,2
          ll=2*l
          x(1,l)=cloc(ll-1)
          y(1,l)=cloc(ll)
        enddo
        sigm(1)=cloc(5)
        dps(1)=cloc(6)
        call umlauda
        do i4=1,nd2
          do j4=1,nd2
            am(i4,j4)=aml6(i4,j4)
          enddo
        enddo
        call dinv(nd2,am,nd2,idummy,nerror)
        if(nerror.ne.0) write(lout,*) ' ATTENTION, MATRIX SINGULAR '
        if(ndimf.eq.3) then
          do l=1,2
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          xx(5)=sigm(1)
          xx(6)=dps(1)
        else
          do l=1,ndimf
            ll=2*l
            xx(ll-1)=x(1,l)
            xx(ll)=y(1,l)
          enddo
          do l=ndimf+1,3
            ll=2*l
            xx(ll-1)=zero
            xx(ll)=zero
          enddo
        endif
        do l=1,nd2
          dc(l)=abs(cloc(l)-xx(l))
          if(l.eq.5) dc(5)=dc(5)*c1m2
        enddo
      endif
      write(lout,10050) nd2,ii
      cor=zero
      do l=1,ndimf
        ll=2*l
        write(lout,10070) chp(l),cloc(ll-1),cloc(ll),                   &
     &chd(l),dc(ll-1),dc(ll)
        cor=cor+dc(ll-1)**2                                              !hr06
      enddo
      cor=sqrt(cor)
      write(lout,10080) ii,cor
 91   continue
      if(ndimf.eq.3) then
        do l=1,2
          ll=2*l
          clo6(l)=cloc(ll-1)
          clop6(l)=cloc(ll)
        enddo
        clo6(3)=cloc(5)
        clop6(3)=cloc(6)
      else
        do l=1,ndimf
          ll=2*l
          clo(l)=cloc(ll-1)
          clop(l)=cloc(ll)
        enddo
      endif
#ifdef DEBUG
!     call warr('end clorda',cloc(1),1,0,0,0)
!     call warr('end cloc(2)',cloc(2),2,0,0,0)
!     call warr('end cloc(3)',cloc(3),3,0,0,0)
!     call warr('end cloc(4)',cloc(4),4,0,0,0)
!     call warr('end cloc(5)',cloc(5),5,0,0,0)
!     call warr('end cloc(6)',cloc(6),6,0,0,0)
!     call warr('clo(1)',clo(1),1,0,0,0)
!     call warr('clo(2)',clo(2),2,0,0,0)
!     call warr('clop(1)',clop(1),1,0,0,0)
!     call warr('clop(2)',clop(2),2,0,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
#endif
!-----------------------------------------------------------------------
      return
10000 format(t10,'DA CLOSED ORBIT CALCULATION'/ t10,                    &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-')/t10,'ENTERING ',i1,                              &
     &'-D DA CLOSED ORBIT CALCULATION'/)
10020 format(5x,'---- closed orbit before correction----')
10030 format(5x,'---- after DA correction----')
10040 format(/5x,'NO IMPROVEMENT OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10050 format(t5,'SUCCESSFULL END OF ',i1,'-D DA CLOSED ORBIT ',         &
     &'CALCULATION IN ITERATION: ',i4/)
10060 format(5x,a6,1p,2(1x,g16.9))
10070 format(5x,a6,1p,2(1x,g16.9)/5x,a6,1p,2(1x,g16.9))
10080 format(5x,' ITERAT.=',i3,' ACCURACY=',d13.6/)
      end

+dk mydaini
subroutine mydaini(ncase,nnord,nnvar,nndim,nnvar2,nnord1)
!-----------------------------------------------------------------------
!  CALCULATION OF THE 4-DIMENSIONAL CLOSED ORBIT INCLUDING DELTA
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common, only : ichromc,ilinc,iqmodc
      use mod_commond
      use mod_lie_dab, only : iscrda
      implicit none
      integer idummy,ncase,ndimfo,ndpt,nis,nndim,nnord,nnord1,nnvar,nnvar2,nord1o,nordo,nvar2o,nvaro
      real(kind=fPrec) am
      dimension am(6,6),idummy(6)
      save
!-----------------------------------------------------------------------
      if(nndim.lt.2.or.nndim.gt.3) call prror(95)
!--------------------
      nordo=nord
      nvaro=nvar
      ndimfo=ndimf
      nvar2o=nvar2
      nord1o=nord1
!--------------------
      nord=nnord
      nvar=nnvar
      ndimf=nndim
      nvar2=nnvar2
      nord1=nnord1
!--------------------
      ndpt=0
      nis=0
!--------------------
      call daeps(preda)
      call idprset(-102)
      call lieinit(nord,nvar,ndimf,ndpt,0,nis)
#ifdef DEBUG
!     call dumpbin('alieinit',1,11)
!     call abend('alieinit in mydaini                               ')
#endif
      write(lout,10000) nord,nvar,ndimf
      call daall(iscrda,100,'$$IS      ',nord,nvar)
!--closed orbit
#ifdef DEBUG
!     write(*,*) 'ncase=',ncase,' if 1 call clorda'
#endif
      if(ncase.eq.1) call clorda(2*ndimf,idummy,am)
#ifdef DEBUG
!     call dumpbin('aclorda',1,11)
!     call abend('aclorda                                           ')
#endif
!--tune variation
#ifdef DEBUG
!     write(*,*) 'ncase=',ncase,' if 2 call umlauda'
#endif
      if(ncase.eq.2) call umlauda
#ifdef DEBUG
!     if(ncase.eq.2) then
!     call dumpbin('aumlauda',7,77)
!     call abend('aumlauda                                          ')
!     endif
#endif
      iqmodc=0
      ichromc=0
      ilinc=0
      call dadal(iscrda,100)
!--------------------
      nord=nordo
      nvar=nvaro
      nvar2=nvar2o
      ndimf=ndimfo
      nord1=nord1o
!-----------------------------------------------------------------------
10000 format(/131('-')/10x,'DA INITIALIZATION: ORDER = ',i2,            &
     &', # of VARIABLES = ',i2,', DIMENSION = ',i2/)
      return
end subroutine mydaini

+dk clorb2
subroutine clorb2(dpp)
!-----------------------------------------------------------------------
!  CALCULATION OF THE CLOSED ORBIT - NO WRITEOUT
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer ierr,ii,l,ll
      real(kind=fPrec) am,dclo,dclop,dcx,dcxp,dcz,dczp,det,dpp,dx,dy,x0,x1,y0,y1
      dimension x1(2),y1(2),x0(2),y0(2)
      dimension dclo(2),dclop(2)
      dimension dx(2),dy(2),am(4,4)
      save
!-----------------------------------------------------------------------
      ierro=0
      do 10 l=1,2
        clo(l)=dpp*di0(l)
        clop(l)=dpp*dip0(l)
        dx(l)=c1e6                                                        !hr06
        dy(l)=c1e6                                                        !hr06
   10 continue

      call envar(dpp)
      call umlauf(dpp,1,ierr)
      ierro=ierr
      if(ierro.ne.0) call prror(36)

      do 40 ii=1,itco
        dcx=abs(dx(1))
        dcxp=abs(dy(1))
        dcz=abs(dx(2))
        dczp=abs(dy(2))
        if(dcx.le.dma.and.dcz.le.dma.and.dcxp.le.dmap.and.dczp.le.dmap) &
     &return

        do l=1,2
          x(1,l)=clo(l)
          y(1,l)=clop(l)
          x0(l)=x(1,l)
          y0(l)=y(1,l)
        end do

        call matrix(dpp,am)

        if(ierro.ne.0) call prror(36)

        do 30 l=1,2
          ll=2*l
          x1(l)=x(1,l)
          y1(l)=y(1,l)
          det=two-am(ll-1,ll-1)-am(ll,ll)
          dx(l)=x0(l)-x1(l)
          dy(l)=y0(l)-y1(l)
          dclo(l)=(dx(l)*(am(ll,ll)-one)-dy(l)*am(ll-1,ll))/det
          dclop(l)=(dy(l)*(am(ll-1,ll-1)-one)-dx(l)*am(ll,ll-1))/det
          clo(l)=clo(l)+dclo(l)
          clop(l)=clop(l)+dclop(l)
   30   continue

   40 continue
!-----------------------------------------------------------------------
      return
end subroutine clorb2

+dk combel
subroutine combel(iql)
!-----------------------------------------------------------------------
!  COMBINATION OF ELEMENTS
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer ico,ico0,iql,j,m
      save
!-----------------------------------------------------------------------
      do 20 j=1,icoe
        ico0=icomb0(j)
        if(iql.ne.ico0) goto 20
        do 10 m=1,20
          ico=icomb(j,m)
          if(ico.eq.0) goto 10
          if(kz(ico0).ne.kz(ico)) call prror(14)
          if(abs(el(ico0)).gt.pieni) then
            if(abs(el(ico)).gt.pieni) then
              ek(ico)=ek(ico0)*ratio(j,m)
            else
              ed(ico)=ek(ico0)*ratio(j,m)
            endif
          endif
          if(abs(el(ico0)).le.pieni) then
            if(abs(el(ico)).le.pieni) then
              ed(ico)=ed(ico0)*ratio(j,m)
            else
              ek(ico)=ed(ico0)*ratio(j,m)
            endif
          endif
   10   continue
   20 continue
!-----------------------------------------------------------------------
      return
end subroutine combel

+dk envar
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!  Rewritten from computed goto to select case 16/11/2017, VKBO
!-----------------------------------------------------------------------
subroutine envar(dpp)
    
    use floatPrecision
    use numerical_constants
    use mathlib_bouncer
    
    use parpro
    use mod_common
    use mod_commons
    use mod_commont
    implicit none
    integer i,ih,kz1,l,ll
    real(kind=fPrec) afok,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
    
    save
    
    dpd  = one+dpp
    dpsq = sqrt(dpd)
    do i=1,il
        do ll=1,6
            do l=1,2
                a(i,l,ll)=zero
            end do
        end do
        if (abs(el(i)).le.pieni) then ! NONLINEAR INSERTION
            sm(i)=ed(i)
            cycle
        end if
        
        kz1 = kz(i)+1
        select case(kz1)
        case (1) ! DRIFTLENGTH
            do l=1,2
                a(i,l,1) = one
                a(i,l,2) = el(i)
                a(i,l,3) = zero
                a(i,l,4) = one
            end do
            
        case (2, 4, 5, 6)
            ! 2: RECTANGULAR MAGNET 
            ! 4: SEKTORMAGNET
            ! 5: RECTANGULAR MAGNET VERTICAL
            ! 6: SEKTORMAGNET VERTICAL
            fok = el(i)*ed(i)/dpsq
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            rho = (one/ed(i))*dpsq
            si  = sin_mb(fok)
            co  = cos_mb(fok)
            g   = tan_mb(fok*half)/rho
            gl  = el(i)*g
            select case (kz1)
            case (2)
                ! HORIZONTAL
                a(i,1,1) = one
                a(i,1,2) = rho*si
                a(i,1,3) = zero
                a(i,1,4) = one
                a(i,1,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                a(i,1,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                a(i,2,1) = one-gl
                a(i,2,2) = el(i)
                a(i,2,3) = (-one*g)*(two-gl) ! hr06
                a(i,2,4) = a(i,2,1)
            case (4)
                ! HORIZONTAL
                a(i,1,1) = co
                a(i,1,2) = rho*si
                a(i,1,3) = (-one*si)/rho              ! hr06
                a(i,1,4) = co
                a(i,1,5) = ((-one*rho)*(one-co))/dpsq ! hr06
                a(i,1,6) = (-one*si)/dpsq             ! hr06
                ! VERTICAL
                a(i,2,1) = one
                a(i,2,2) = el(i)
                a(i,2,3) = zero
                a(i,2,4) = one
            case (5)
                ! HORIZONTAL
                a(i,2,1) = one
                a(i,2,2) = rho*si
                a(i,2,3) = zero
                a(i,2,4) = one
                a(i,2,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                a(i,2,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTIKAL
                a(i,1,1) = one-gl
                a(i,1,2) = el(i)
                a(i,1,3) = (-one*g)*(two-gl) ! hr06
                a(i,1,4) = a(i,1,1)
            case (6)
                ! HORIZONTAL
                a(i,2,1) = co
                a(i,2,2) = rho*si
                a(i,2,3) = (-one*si)/rho              ! hr06
                a(i,2,4) = co
                a(i,2,5) = ((-one*rho)*(one-co))/dpsq ! hr06
                a(i,2,6) = (-one*si)/dpsq             ! hr06
                ! VERTIKAL
                a(i,1,1) = one
                a(i,1,2) = el(i)
                a(i,1,3) = zero
                a(i,1,4) = one
            end select
            
        case (3) ! QUADRUPOLE
            fok=ek(i)/(one+dpp)
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            ih = 0
            hi = sqrt(abs(fok))
            fi = el(i)*hi
            if(fok.gt.zero) goto 110
    100     ih = ih+1
            a(i,ih,1) = cos_mb(fi)
            hi1 = sin_mb(fi)
            a(i,ih,2) = hi1/hi
            a(i,ih,3) = (-one*hi1)*hi  ! hr06
            a(i,ih,4) = a(i,ih,1)
            if(ih.eq.2) cycle
            !--DEFOCUSSING
    110     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = hs/hi
            a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            if(ih.eq.1) goto 100
            
        case (7, 8)
            ! 7: COMBINED FUNCTION MAGNET HORIZONTAL
            ! 8: COMBINED FUNCTION MAGNET VERTICAL
            if (kz1.eq.7) then
                ih   = 0
                fokq = ek(i)
            else
                ih   = 1
                fokq = -one*ek(i) ! hr06
            end if
            wf  = ed(i)/dpsq
            fok = fokq/dpd-wf**2  ! hr06
            if(abs(fok).le.pieni) then
                do l=1,2
                    a(i,l,1) = one
                    a(i,l,2) = el(i)
                    a(i,l,3) = zero
                    a(i,l,4) = one
                end do
                cycle
            end if
            afok = abs(fok)
            hi   = sqrt(afok)
            fi   = hi*el(i)
            if(fok.gt.zero) goto 160
    140     ih = ih+1
            si = sin_mb(fi)
            co = cos_mb(fi)
            a(i,ih,1) = co
            a(i,ih,2) = si/hi
            a(i,ih,3) = (-one*si)*hi                     ! hr06
            a(i,ih,4) = co
            a(i,ih,5) = (((-one*wf)/afok)*(one-co))/dpsq ! hr06
            a(i,ih,6) = (((-one*wf)/hi)*si)/dpsq         ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = el(i)
            if(abs(hi).le.pieni) goto 150
            a(i,ih,2) = hs/hi
    150     a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            cycle
            ! DEFOCUSSING
    160     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            a(i,ih,1) = hc
            a(i,ih,2) = hs/hi
            a(i,ih,3) = hs*hi
            a(i,ih,4) = hc
            a(i,ih,5) = ((wf/afok)*(one-hc))/dpsq ! hr06
            a(i,ih,6) = (((-one*wf)/hi)*hs)/dpsq  ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            si = sin_mb(fi)
            co = cos_mb(fi)
            a(i,ih,1) = co
            a(i,ih,2) = si/hi
            a(i,ih,3) = (-one*si)*hi ! hr06
            a(i,ih,4) = co
            
        case (9) ! EDGE FOCUSSING
            rhoi = ed(i)/dpsq
            fok  = rhoi*tan_mb((el(i)*rhoi)*half) ! hr06
            a(i,1,1) = one
            a(i,1,2) = zero
            a(i,1,3) = fok
            a(i,1,4) = one
            a(i,2,1) = one
            a(i,2,2) = zero
            a(i,2,3) = -one*fok ! hr06
            a(i,2,4) = one
            
        end select
    end do
    call block
    return
    
end subroutine envar

+dk envardis
!-----------------------------------------------------------------------
!  CALCULATION OF ELEMENT MATRICES
!  Rewritten from computed goto to select case 16/11/2017, VKBO
!-----------------------------------------------------------------------
subroutine envardis(dpp,aeg,bl1eg,bl2eg)
    
    use floatPrecision
    use numerical_constants
    use mathlib_bouncer
    
    use parpro
    use mod_common
    use mod_commons
    use mod_commont
    implicit none
    integer i,ih,kz1,l,ll
    real(kind=fPrec) aeg,afok,bl1eg,bl2eg,co,dpd,dpp,dpsq,fi,fok,fokq,g,gl,hc,hi,hi1,hm,hp,hs,rho,rhoi,si,wf
    dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
    save
    
    dpd  = one+dpp
    dpsq = sqrt(dpd)
    do i=1,il
        do ll=1,6
            do l=1,2
              aeg(i,l,ll) = zero
            end do
        end do
        if(abs(el(i)).le.pieni) cycle
        kz1 = kz(i)+1
        select case (kz1)
        case (1)
            do l=1,2
                aeg(i,l,1) = one
                aeg(i,l,2) = el(i)
                aeg(i,l,3) = zero
                aeg(i,l,4) = one
            end do
            
        case (2, 4, 5, 6)
            ! 2: RECTANGULAR MAGNET
            ! 4: SEKTORMAGNET
            ! 5: RECTANGULAR MAGNET VERTICAL
            ! 6: SEKTORMAGNET VERTICAL
            fok = el(i)*ed(i)/dpsq
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
            end if
            rho = (one/ed(i))*dpsq
            si  = sin_mb(fok)
            co  = cos_mb(fok)
            select case (kz1)
            case (2)
                ! HORIZONTAL
                aeg(i,1,1) = one
                aeg(i,1,2) = rho*si
                aeg(i,1,3) = zero
                aeg(i,1,4) = one
                aeg(i,1,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                aeg(i,1,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                g  = tan_mb(fok*half)/rho
                gl = el(i)*g
                aeg(i,2,1) = one-gl
                aeg(i,2,2) = el(i)
                aeg(i,2,3) = (-one*g)*(two-gl)                  ! hr06
                aeg(i,2,4) = aeg(i,2,1)
            case (4)
                ! HORIZONTAL
                aeg(i,1,1)=co
                aeg(i,1,2)=rho*si
                aeg(i,1,3)=(-one*si)/rho                        ! hr06
                aeg(i,1,4)=co
                aeg(i,1,5)=((-one*rho)*(one-co))/dpsq           ! hr06
                aeg(i,1,6)=(-one*si)/dpsq                       ! hr06
                ! VERTICAL
                aeg(i,2,1)=one
                aeg(i,2,2)=el(i)
                aeg(i,2,3)=zero
                aeg(i,2,4)=one
            case (5)
                ! HORIZONTAL
                aeg(i,2,1) = one
                aeg(i,2,2) = rho*si
                aeg(i,2,3) = zero
                aeg(i,2,4) = one
                aeg(i,2,5) = ((-one*rho)*(one-co))/dpsq         ! hr06
                aeg(i,2,6) = ((-one*two)*tan_mb(fok*half))/dpsq ! hr06
                ! VERTICAL
                g  = tan_mb(fok*half)/rho
                gl = el(i)*g
                aeg(i,1,1) = one-gl
                aeg(i,1,2) = el(i)
                aeg(i,1,3) = (-one*g)*(two-gl)                  ! hr06
                aeg(i,1,4) = aeg(i,1,1)
            case (6)
                ! HORIZONTAL
                aeg(i,2,1)=co
                aeg(i,2,2)=rho*si
                aeg(i,2,3)=(-one*si)/rho                        ! hr06
                aeg(i,2,4)=co
                aeg(i,2,5)=((-one*rho)*(one-co))/dpsq           ! hr06
                aeg(i,2,6)=(-one*si)/dpsq                       ! hr06
                ! VERTICAL
                aeg(i,1,1)=one
                aeg(i,1,2)=el(i)
                aeg(i,1,3)=zero
                aeg(i,1,4)=one
            end select
            
        case (3) ! QUADRUPOLE
            ! FOCUSSING
            fok = ek(i)/(one+dpp)
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
                cycle
            end if
            ih = 0
            hi = sqrt(abs(fok))
            fi = el(i)*hi
            if(fok.gt.zero) goto 110
    100     ih = ih+1
            aeg(i,ih,1) = cos_mb(fi)
            hi1 = sin_mb(fi)
            aeg(i,ih,2) = hi1/hi
            aeg(i,ih,3) = (-one*hi1)*hi ! hr06
            aeg(i,ih,4) = aeg(i,ih,1)
            if(ih.eq.2) cycle
            ! DEFOCUSSING
    110     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = hs/hi
            aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            if(ih.eq.1) goto 100
            
        case (7, 8)
            ! 7: COMBINED FUNCTION MAGNET HORIZONTAL
            ! 8: COMBINED FUNCTION MAGNET VERTICAL
            if (kz1.eq.7) then
                ih   = 0
                fokq = ek(i)
            else
                ih   = 1
                fokq = -one*ek(i)      ! hr06
            end if
            wf  = ed(i)/dpsq
            fok = fokq/dpd-wf**2       ! hr06
            if(abs(fok).le.pieni) then
                do l=1,2
                    aeg(i,l,1) = one
                    aeg(i,l,2) = el(i)
                    aeg(i,l,3) = zero
                    aeg(i,l,4) = one
                end do
                cycle
            end if
            afok = abs(fok)
            hi   = sqrt(afok)
            fi   = hi*el(i)
            if(fok.gt.zero) goto 160
    140     ih = ih+1
            si = sin_mb(fi)
            co = cos_mb(fi)
            aeg(i,ih,1) = co
            aeg(i,ih,2) = si/hi
            aeg(i,ih,3) = (-one*si)*hi                      ! hr06
            aeg(i,ih,4) = co
            aeg(i,ih,5) = (((-one*wf)/afok)*(one-co))/dpsq  ! hr06
            aeg(i,ih,6) = (((-one*wf)/hi)*si)/dpsq          ! hr06
            ih = ih+1
            if(ih.gt.2) ih=1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = el(i)
            if(abs(hi).le.pieni) goto 150
            aeg(i,ih,2) = hs/hi
    150     aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            ! DEFOCUSSING
    160     ih = ih+1
            hp = exp_mb(fi)
            hm = one/hp
            hc = (hp+hm)*half
            hs = (hp-hm)*half
            aeg(i,ih,1) = hc
            aeg(i,ih,2) = hs/hi
            aeg(i,ih,3) = hs*hi
            aeg(i,ih,4) = hc
            aeg(i,ih,5) = ((wf/afok)*(one-hc))/dpsq ! hr06
            aeg(i,ih,6) = (((-one*wf)/hi)*hs)/dpsq  ! hr06
            ih = ih+1
            if(ih.gt.2) ih = 1
            hi = sqrt(abs(ek(i)/dpd))
            fi = hi*el(i)
            si = sin_mb(fi)
            co = cos_mb(fi)
            aeg(i,ih,1) = co
            aeg(i,ih,2) = si/hi
            aeg(i,ih,3) = (-one*si)*hi              ! hr06
            aeg(i,ih,4) = co
            
        case (9) ! EDGE FOCUSSING
            rhoi = ed(i)/dpsq
            fok  = rhoi*tan_mb((el(i)*rhoi)*half) ! hr06
            aeg(i,1,1) = one
            aeg(i,1,2) = zero
            aeg(i,1,3) = fok
            aeg(i,1,4) = one
            aeg(i,2,1) = one
            aeg(i,2,2) = zero
            aeg(i,2,3) = -one*fok
            aeg(i,2,4) = one
            
        end select
    end do
    call blockdis(aeg,bl1eg,bl2eg)
    return
    
end subroutine envardis

+dk cadcum
      subroutine cadcum
!
!-----------------------------------------------------------------------
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 13-06-2014
!     calculate dcum, as done in linopt and when parsing BLOCs (daten):
!         lengths of thick lens elements are taken on the curvilinear
!         reference system; thus, no difference between the length
!         of SBENDs and the one of RBENDs, as they are both the ARC one;
!     for future needs:
!                ds=two/ed(ix)*asin(el(ix)*ed(ix)/two)
!     always in main code
!-----------------------------------------------------------------------
!
      use floatPrecision
      use numerical_constants
      use crcoall
      use parpro
      use mod_common
      implicit none

      save

!     temporary variables
      real(kind=fPrec) tmpdcum, ds
      integer ientry, jentry, kentry, ix

      write(lout,*)''
      write(lout,10010)
      write(lout,*)''
      write(lout,*)' CALL TO CADCUM'
      write(lout,*)''

!     initialise cumulative length
      tmpdcum=zero

!     loop all over the entries in the accelerator structure
      do ientry=1,iu
        ix=ic(ientry)
        if(ix.gt.nblo) then
!         SINGLE ELEMENT
          ix=ix-nblo
          if ( el(ix).gt.zero ) tmpdcum=tmpdcum+el(ix)
        else
!         BLOC: iterate over elements
          do jentry=1,mel(ix)
            kentry=mtyp(ix,jentry)
            if( el(kentry).gt.zero ) tmpdcum=tmpdcum+el(kentry)
          enddo
        endif
!       assign value of dcum
        dcum(ientry)=tmpdcum
!     go to next entry in the acclerator structure
      enddo

!     assign the last value to the closing MARKER:
      dcum(iu+1)=tmpdcum

      if ( print_dcum ) then
!       a useful printout
        write(lout,10030)'ientry','ix','name            ','dcum [m]'
        write(lout,10020) 0,-1,'START           ',dcum(0)
        do ientry=1,iu
          ix=ic(ientry)
          if(ix.gt.nblo) then
!            SINGLE ELEMENT
             ix=ix-nblo
             write(lout,10020) ientry,ix,bez(ix),dcum(ientry)
          else
!            BLOC
             write(lout,10020) ientry,ix,bezb(ix),dcum(ientry)
          endif
        enddo
        write(lout,10020) iu+1,-1,'END            ',dcum(iu+1)
        write(lout,*)     ''
      else                      ! Anyway print the total machine length
         write(lout,'(1x,a,1x,f17.10,1x,a)')                            &
     &        "Machine length was", dcum(iu+1),"[m]"
      endif

!     au revoir:
      return

10010 format(132('-'))
10020 format(2(1x,i6),1x,a16,1x,f12.5)
10030 format(2(1x,a6),1x,a16,1x,a12)
      end subroutine
!
+dk linopt
!-----------------------------------------------------------------------
!  LINEAR PARAMETERS AT THE POSITION OF EVERY ELEMENT OR BLOCK
!-----------------------------------------------------------------------
subroutine linopt(dpp)
  
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  
#ifdef ROOT
  use root_output
#endif

#ifdef HDF5
  use hdf5_output
  use hdf5_linopt
#endif

#ifdef COLLIMAT
  use collimation
#endif
  
  implicit none
  
  integer i,iiii,im,ium,ix,izu,j,jj,jk,jm,k,kpz,kzz,l,l1,ll,nmz,nr,dj
  real(kind=fPrec) aa,aeg,alfa,bb,benkr,beta,bexi,bezii,bl1eg,bl2eg,ci,cikve,clo0,clop0,cr,crkve, &
    crkveuk,di00,dip00,dphi,dpp,dpp1,dppi,dpr,dyy1,dyy2,ekk,etl,phi,phibf,pie,puf,qu,qv,qw,qwc,r0,&
    r0a,t,xl,xs,zl,zs,quz,qvz
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
#endif
  character(len=max_name_len) idum
  
#ifdef COLLIMAT
!+ca collpara
!+ca dblinopt
#endif
  
  dimension t(6,4)
  dimension beta(2),alfa(2),phibf(2),phi(2)
  dimension clo0(2),clop0(2),di00(2),dip00(2),qw(2),qwc(3)
  dimension aa(mmul),bb(mmul),dpr(6)
  dimension cr(mmul),ci(mmul)
  dimension aeg(nele,2,6),bl1eg(nblo,2,6),bl2eg(nblo,2,6)
  data dpr/6*zero/
  save
!-----------------------------------------------------------------------
  
      nhmoni=0
      nvmoni=0
      nhcorr=0
      nvcorr=0
      ium=6
      pie=two*pi

      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10000)
      endif

      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phibf(i)=zero
        phi(i)=zero
        clo0(i)=zero
        clop0(i)=zero
        di00(i)=zero
        dip00(i)=zero
        qw(i)=zero
        qwc(i)=zero
      end do

      qwc(3)=zero

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      etl=zero
      dpr(1)=dpp*c1e3
      dpr(6)=one
      dpp1=dpp+ded
      call clorb(dpp1)

      do l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
      end do

      call clorb(dpp)

      do l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
        t(6,ll-1)=di0(l)
        t(6,ll)=dip0(l)
      end do

      if(ncorru.eq.0) then
        write(lout,10010)
        write(lout,10050) (di0(l),dip0(l),l=1,2)
      endif

      call betalf(dpp,qw)
      call phasad(dpp,qwc)

      if(ierro.ne.0) call prror(22+ierro)
      if(ncorru.eq.0) write(lout,10040) dpp,qwc(1),qwc(2)

      call envar(dpp)

      if(ithick.eq.1) call envardis(dpp1,aeg,bl1eg,bl2eg)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

      if(ncorru.eq.0) then
        write(lout,10010)
        if(iprint.eq.1) write(lout,10030)
        write(lout,10020)
        write(lout,10010)
      endif

!--START OF THE MACHINE
      idum='START'
      nr=0
#ifndef COLLIMAT
      call writelin(nr,idum,etl,phi,t,1,.false.)
#else
      call writelin(nr,idum,etl,phi,t,1,.false.,0)
#endif
      if(ntco.ne.0) then
        if(mod(nr,ntco).eq.0) call cpltwis(idum,t,etl,phi)
      endif

#ifdef ROOT
      if(root_flag .and. root_Optics.eq.1) then
        call OpticsRootWrite()
      end if
#endif

!--STRUCTURE ELEMENT LOOP
      if(nt.le.0.or.nt.gt.iu) nt=iu
      izu=0
#ifdef HDF5
      if(h5_writeOptics) call h5lin_init
#endif
      
      STRUCTLOOP: do k=1,nt
        ix=ic(k)
        if(ix.gt.nblo) goto 220 !Not a BLOCK
        if(ithick.eq.1.and.iprint.eq.1) goto 160

        jj=0 !initial idx
        dj=1 !step
        
        if (ix.le.0) then
           ix=-1*ix             !hr13
           jj=mel(ix)+1         !initial idx
           dj=-1                !step
        endif
        jm=mel(ix)
!-- Loop over elements inside the block
        do 150 j=1,jm
          jj=jj+dj       ! Subelement index of current sub=element
          jk=mtyp(ix,jj) ! Single-element index of the current sub-element
          if(ithick.eq.1.and.kz(jk).ne.0) goto 120
          if(ithick.eq.0.and.kz(jk).ne.0) then
            etl=etl+el(jk)
            
!c$$$            nr=nr+1
!c$$$+if .not.collimat.and..not.bnlelens
!c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
!c$$$+ei
!c$$$+if collimat.or.bnlelens
!c$$$            call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
!c$$$+ei
!c$$$            if(ntco.ne.0) then
!c$$$              if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl,phi)
!c$$$            endif
            
            write(lout,*) "ERROR in LINOPT:"
            write(lout,*) "In block ", bezb(ix),                        &
     &           "found a thick non-drift element",                     &
     &           bez(jk), "while ithick=1. This should not be possible!"
            call prror(-1)
            cycle STRUCTLOOP
          endif

!--IN BLOCK: PURE DRIFTLENGTH (above: If ITHICK=1 and kz!=0, goto 120->MAGNETELEMENT)
          etl=etl+el(jk)

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
            if((-one*dphi).gt.pieni) dphi=dphi+pi                        !hr06
            phi(l)=phi(l)+dphi/pie
          end do

          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
#else
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
#ifdef ROOT
      if(root_flag .and. root_Optics.eq.1) then
        call OpticsRootWrite()
      end if
#endif

          goto 150

!--IN BLOCK: MAGNETELEMENT
  120     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif

            puf=t(6,ll-1)
         t(6,ll-1)=(((((aeg(jk,l,1)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,2)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,5)*dpp1*c1e3)- a(jk,l,1)*t          &!hr06
     &(1,ll-1))-a(jk,l,2)*t(1,ll))- a(jk,l,5)*dpr(1))/ded                !hr06
           t(6,ll)=(((((aeg(jk,l,3)*(t(1,ll-1)+puf*ded)+ aeg(jk,l,4)*(t &!hr06
     &(1,ll)+t(6,ll)*ded))+aeg(jk,l,6)*dpp1*c1e3)- a(jk,l,3)*t          &!hr06
     &(1,ll-1))-a(jk,l,4)*t(1,ll))- a(jk,l,6)*dpr(1))/ded                !hr06

            do i=1,ium-1
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo

          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)                                         !hr06
            endif

            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
          
          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.)
#else
          call writelin(nr,bez(jk),etl,phi,t,ix,.true.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(jk),t,etl, phi)
          endif
#ifdef ROOT
          if(root_flag .and. root_Optics.eq.1) then
            call OpticsRootWrite()
          end if
#endif
          
  150   continue !End of loop over elements inside block

        nr=nr+1
#ifndef COLLIMAT
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
#else
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
#endif
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
#ifdef ROOT
        if(root_flag .and. root_Optics.eq.1) then
          call OpticsRootWrite()
        end if
#endif

        cycle STRUCTLOOP

!--BETACALCULATION FOR SERIES OF BLOCKS (ix.ge.nblo.and.ithick.eq.1.and.iprint.eq.1)
  160   continue !if ithick=1 and iprint=1:
        if(ix.le.0) goto 190
!--REGULAR RUN THROUGH BLOCKS
        etl=etl+elbe(ix)

        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif

          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl1eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,5)*dpp1*c1e3)- bl1(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,2)*t(1,ll))- bl1(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl1eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl1eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl1eg(ix,l,6)*dpp1*c1e3)- bl1(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl1(ix,l,4)*t(1,ll))- bl1(ix,l,6)*dpr(1))/ded            !hr06

          do i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl1(ix,l,1)*puf+bl1(ix,l,2)*t(i,ll))+dpr(i)*bl1  &!hr06
     &(ix,l,5)                                                           !hr06
        t(i,ll)=(bl1(ix,l,3)*puf+bl1(ix,l,4)*t(i,ll))+dpr(i)*bl1(ix,l,6) !hr06
          end do
        end do

        do l=1,2
          ll=2*l
          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
            dphi=-one*phibf(l)                                           !hr06
          endif
          if(-one*dphi.gt.pieni) dphi=dphi+pi                            !hr06
          phi(l)=phi(l)+dphi/pie
        end do

        nr=nr+1
#ifndef COLLIMAT
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
#else
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
#endif
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
#ifdef ROOT
        if(root_flag .and. root_Optics.eq.1) then
          call OpticsRootWrite()
        end if
#endif
        
        cycle STRUCTLOOP

!--REVERSE RUN THROUGH BLOCKS (ix.le.0)
  190   ix=-ix
        etl=etl+elbe(ix)
        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
          else
            phibf(l)=zero
          endif

          puf=t(6,ll-1)
      t(6,ll-1)=(((((bl2eg(ix,l,1)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,2)*(t&!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,5)*dpp1*c1e3)- bl2(ix,l,1)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,2)*t(1,ll))- bl2(ix,l,5)*dpr(1))/ded            !hr06
      t(6,ll)=(((((bl2eg(ix,l,3)*(t(1,ll-1)+puf*ded)+ bl2eg(ix,l,4)*(t  &!hr06
     &(1,ll)+t(6,ll)*ded))+ bl2eg(ix,l,6)*dpp1*c1e3)- bl2(ix,l,3)*t     &!hr06
     &(1,ll-1))-bl2(ix,l,4)*t(1,ll))- bl2(ix,l,6)*dpr(1))/ded            !hr06

          do i=1,ium-1
            puf=t(i,ll-1)
            t(i,ll-1)=(bl2(ix,l,1)*puf+bl2(ix,l,2)*t(i,ll))+dpr(i)*bl2  &!hr06
     &(ix,l,5)                                                           !hr06
        t(i,ll)=(bl2(ix,l,3)*puf+bl2(ix,l,4)*t(i,ll))+dpr(i)*bl2(ix,l,6) !hr06
          end do
        end do

        do l=1,2
          ll=2*l

          if(abs(t(ll,ll-1)).gt.pieni) then
            dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
          else
            dphi=-phibf(l)
          endif

          if(-one*dphi.gt.pieni) dphi=dphi+pi                            !hr06
          phi(l)=phi(l)+dphi/pie
        end do

        nr=nr+1
#ifndef COLLIMAT
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.)
#else
        call writelin(nr,bezb(ix),etl,phi,t,ix,.true.,k)
#endif
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bezb(ix),t,etl,phi)
        endif
#ifdef ROOT
        if(root_flag .and. root_Optics.eq.1) then
          call OpticsRootWrite()
        end if
#endif
        
        cycle STRUCTLOOP

!--NOT A BLOCK / Nonlinear insertion
  220   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        kzz=kz(ix)

 ! Cavity
#ifndef COLLIMAT
        if(kpz.eq.6) then
#else
        if(abs(kzz).eq.12) then
#endif
          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
#ifdef ROOT
          if(root_flag .and. root_Optics.eq.1) then
            call OpticsRootWrite()
          end if
#endif

          cycle STRUCTLOOP
        endif
        
        !Beam Beam element .and. fort.3 has BB block
        if(kzz.eq.20.and.nbeam.ge.1) then
          nbeam=k
          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
#ifdef ROOT
          if(root_flag .and. root_Optics.eq.1) then
            call OpticsRootWrite()
          end if
#endif
          cycle STRUCTLOOP
        endif
        ! if kzz==22, starts a do over l; Update t matrix
        if(kzz == 22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            end if
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+t(i,ll)*rrtr(imtr(ix),ll-1,ll))+dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+t(i,ll)*rrtr(imtr(ix),ll,ll))+dpr(i)*rrtr(imtr(ix),ll,6)
            end do
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
            if(abs(t(ll,ll-1)) > pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            end if
            if(-one*dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi/pie
          enddo
        endif

!+if collimat.or.bnlelens
        ! Marker, beam-beam, phase-trombone, crab cavity (incl. multipole), or wire
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22                           &
     &     .or.abs(kzz).eq.23.or.abs(kzz).eq.26                         &
     &     .or.abs(kzz).eq.27.or.abs(kzz).eq.28                         &
     &     .or.abs(kzz).eq.15) then
          
          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
#ifdef ROOT
          if(root_flag .and. root_Optics.eq.1) then
            call OpticsRootWrite()
          end if
#endif
          cycle STRUCTLOOP
        endif
!+ei
!+if .not.collimat.and..not.bnlelens
!        ! Marker, beam-beam or phase-trombone -> next element
!        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) then
!           cycle STRUCTLOOP
!        endif
!        ! Wire -> next element
!        if(abs(kzz).eq.15) then
!           cycle STRUCTLOOP
!        endif
!        ! RF CC Multipoles -> next element
!        if (abs(kzz).eq.23.or.abs(kzz).eq.26.or.                        &
!     &       abs(kzz).eq.27.or.abs(kzz).eq.28) then
!           cycle STRUCTLOOP
!        endif
!+ei
      
        ! Update the matrix etc. for supported blocks
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignl.f90"

      if (kzz .ge. 0) then
        select case(kzz)

        case (1)
!--HORIZONTAL DIPOLE
           ekk=ekk*c1e3
#include "include/kickl01h.f90"
#include "include/kickq01h.f90"
!--NORMAL QUADRUPOLE
        case(2)
#include "include/kicklxxh.f90"
#include "include/kickq02h.f90"
!--   NORMAL SEXTUPOLE
        case(3)
           ekk=ekk*c1m3
#include "include/kickq03h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL OCTUPOLE
        case(4)
           ekk=ekk*c1m6
#include "include/kicksho.f90"
#include "include/kickq04h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL DECAPOLE
        case(5)
           ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq05h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL DODECAPOLE
        case(6)
           ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq06h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL 14-POLE
        case(7)
           ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq07h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL 16-POLE
        case(8)
           ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq08h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL 18-POLE
        case(9)
           ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq09h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--NORMAL 20-POLE
        case(10)
           ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq10h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
!--Multipole block
        case(11)
        r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl01.f90"
#include "include/multl08.f90"
            do 340 i=2,ium
#include "include/multl02.f90"
  340       continue
          else
#include "include/multl03.f90"
#include "include/multl09.f90"
          endif
        endif
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl04.f90"
#include "include/multl10.f90"
            do 350 i=2,ium
#include "include/multl05.f90"
  350       continue
          else
#include "include/multl06.f90"
#include "include/multl11.f90"
          endif
        endif
        if(abs(r0).le.pieni) then
           cycle STRUCTLOOP
        endif
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          
          nr=nr+1
#ifndef COLLIMAT
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
          call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
          if(ntco.ne.0) then
            if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
          endif
#ifdef ROOT
          if(root_flag .and. root_Optics.eq.1) then
            call OpticsRootWrite()
          end if
#endif

          cycle STRUCTLOOP
        endif
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do 360 l=1,nmz
#include "include/multl07a.f90"
  360   continue
        if(nmz.ge.2) then
#include "include/multl07b.f90"
          do 365 l=3,nmz
#include "include/multl07c.f90"
  365     continue
        else
#include "include/multl07d.f90"
        endif
#ifdef TILT
#include "include/multl07e.f90"
#endif
        izu=izu+2*mmul-2*nmz

!--Skipped elements
        case(12,13,14,15,16,17,18,19,20,21,22,23)
           cycle STRUCTLOOP
        
!--DIPEDGE ELEMENT
        case(24)
#include "include/kickldpe.f90"
#include "include/kickqdpe.f90"
!--solenoid
        case(25)
#include "include/kicklso1.f90"
#include "include/kickqso1.f90"

!--Skipped elements
        case(26,27,28)
           cycle STRUCTLOOP
           
!--Unrecognized element (incl. cav with kp.ne.6 for non-collimat/bnlelens)
        case default
           nr=nr+1
#ifndef COLLIMAT
           call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
           call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
           if(ntco.ne.0) then
              if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
           endif
#ifdef ROOT
           if(root_flag .and. root_Optics.eq.1) then
             call OpticsRootWrite()
           end if
#endif
           cycle STRUCTLOOP
        end select


!--SKEW ELEMENTS
        else if(kzz .lt. 0) then
           kzz=-kzz             !Make it positive
           select case(kzz)
           case(1)
!--VERTICAL DIPOLE
              ekk=ekk*c1e3
#include "include/kickl01v.f90"
#include "include/kickq01v.f90"
!--SKEW QUADRUPOLE
           case(2)
#include "include/kicklxxv.f90"
#include "include/kickq02v.f90"
!--SKEW SEXTUPOLE
           case(3)
              ekk=ekk*c1m3
#include "include/kickq03v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW OCTUPOLE
           case(4)
              ekk=ekk*c1m6
#include "include/kicksho.f90"
#include "include/kickq04v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW DECAPOLE
           case(5)
              ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq05v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW DODECAPOLE
           case(6)
              ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq06v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW 14-POLE
           case(7)
              ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq07v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW 16-POLE
           case(8)
              ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq08v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW 18-POLE
           case(9)
              ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq09v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
!--SKEW 20-POLE
           case(10)
              ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq10v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"

!     Unrecognized skew element (including kzz=-12,kp.ne.6 for non-collimat/bnlelens)
           case default
              nr=nr+1
#ifndef COLLIMAT
              call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
              call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
              if(ntco.ne.0) then
                 if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
              endif
#ifdef ROOT
              if(root_flag .and. root_Optics.eq.1) then
                call OpticsRootWrite()
              end if
#endif
              cycle STRUCTLOOP
           end select
        endif
      
        !Done processing an element: go here!
        t(6,2)=t(6,2)-dyy1/(one+dpp)
        t(6,4)=t(6,4)-dyy2/(one+dpp)
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
!Contains elseif statements
#include "include/phas1so1.f90"
#include "include/phas2so1.f90"
#include "include/phas3so1.f90"
          else
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          endif
        end do
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        if(ncorru.eq.0) then
           if(kz(ix).eq.11) then
              if(abs(aa(2)).gt.pieni.and.nmz.gt.1) then
                 write(34,10070) etl,bez(ix),-2,aa(2),bexi,bezii,phi
              endif
              do iiii=3,nmz
                 if(abs(bb(iiii)).gt.pieni) then
                    write(34,10070)                                      &
     &                   etl,bez(ix),iiii,bb(iiii),bexi,bezii,phi
                 endif
                 if(abs(aa(iiii)).gt.pieni) then
                    write(34,10070)                                      &
     &                   etl,bez(ix),-iiii,aa(iiii),bexi,bezii,phi
                 endif
              enddo
           elseif(abs(ekk).gt.pieni.and.abs(kz(ix)).ge.3) then
              write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
           elseif(abs(ekk).gt.pieni.and.kz(ix).eq.-2) then
              write(34,10070) etl,bez(ix),kz(ix),ekk,bexi,bezii,phi
           endif
        endif
        
        nr=nr+1
#ifndef COLLIMAT
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.)
#else
        call writelin(nr,bez(ix),etl,phi,t,ix,.false.,k)
#endif
        if(ntco.ne.0) then
          if(mod(nr,ntco).eq.0) call cpltwis(bez(ix),t,etl,phi)
        endif
#ifdef ROOT
        if(root_flag .and. root_Optics.eq.1) then
          call OpticsRootWrite()
        end if
#endif
        
      end do STRUCTLOOP ! END LOOP OVER ELEMENTS
      
#ifdef HDF5
      if(h5_writeOptics) call h5lin_saveData
#endif
      
      call clorb(ded)
      do 510 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  510 continue
      call clorb(zero)
      do 520 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  520 continue
      iiii=100
      idum='END'
      bexi=t(2,1)**2+t(3,1)**2                                           !hr06
      bezii=t(4,3)**2+t(5,3)**2                                          !hr06
      if(ncorru.eq.0) write(34,10070) etl,idum,iiii,zero,bexi,bezii,phi
      if(ncorru.eq.0)                                                   &
     &write(lout,10060)
!-----------------------------------------------------------------------
      return
10000 format(t5 ,'---- ENTRY LINOPT ----')
10010 format(132('-'))
10020 format('  NR     TYP      L-TOTAL    P     PHI          ',        &
     &'BETA         ALFA         GAMMA        DIS        DISP         ',&
     &'CLO        CLOP'/ 1x,                                            &
     &'                    (M)           (2*PI)        ',               &
     &'(M)          (RAD)         (M)         (M)        (RAD)        ',&
     &'(MM)       (MRAD)')
10030 format('  LINEAR OPTICS CALCULATION WITH PRINTOUT ',              &
     &'AFTER EACH BLOCK'/                                               &
     &'   A T T E N T I O N : BETATRON PHASE CALCULATION MIGHT BE WRONG'&
     &,' BY A MULTIPLE OF 0.5 FOR EACH LARGE BLOCK'/)
10040 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7/)
10050 format(t8,'  PLANE          DISP(MM)                 DISP(MRAD)'/ &
     &t6,'      X  ',2(f20.12,6x)/t10,'  Y  ',2(f20.12,6x)/)
10060 format(//131('-')//)
10070 format(1x,1pg21.14,1x,a,1x,i4,5(1x,1pg21.14))
end subroutine linopt

!-----------------------------------------------------------------------
!  WRITE OUT LINEAR OPTICS PARAMETERS
!-----------------------------------------------------------------------
#ifndef COLLIMAT
subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC)
#else
subroutine writelin(nr,typ,tl,p1,t,ixwl,isBLOC,ielem)
#endif
  use floatPrecision
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  use parpro
  use mod_common
  use mod_commons
  use mod_commont

#ifdef ROOT
  use iso_c_binding, only: C_NULL_CHAR
  use root_output
#endif

#ifdef HDF5
  use hdf5_output
  use hdf5_linopt
#endif

#ifdef COLLIMAT
  use collimation
#endif
  
  implicit none
  
  integer i,iwrite,ixwl,l,ll,nr
  real(kind=fPrec) al1,al2,b1,b2,c,cp,d,dp,g1,g2,p1,t,tl
  character(len=max_name_len) typ
  ! isBLOC.eq.TRUE if ixwl currently refers to a BLOC index, FALSE if it is a SINGLE ELEMENT index
  logical isBLOC
  dimension p1(2),t(6,4),b1(2),b2(2),al1(2),al2(2),g1(2),g2(2)
  dimension d(2),dp(2),c(2),cp(2)
#ifdef COLLIMAT
!+ca collpara
!+ca dblinopt
  integer ielem
#endif

#ifdef HDF5
    real(kind=fPrec) hdf5Data(17)
#endif
  
  save
!-----------------------------------------------------------------------
  iwrite=0
  if(nlin.eq.0) then
    iwrite=1
  else
    do i=1,nlin
      if(typ.eq.bezl(i)) iwrite=1
    end do
  end if
  if(iwrite.eq.1) then
    do l=1,2
      ll=2*l
      b1(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                            !hr06
      b2(l)=t(6-ll,ll-1)**2+t(7-ll,ll-1)**2                          !hr06
      al1(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))      !hr06
      al2(l)=-one*(t(6-ll,ll-1)*t(6-ll,ll)+t(7-ll,ll-1)*t(7-ll,ll))  !hr06
      g1(l)=t(ll,ll)**2+t(ll+1,ll)**2                                !hr06
      g2(l)=t(6-ll,ll)**2+t(7-ll,ll)**2                              !hr06
      d(l)=t(6,ll-1)*c1m3
      dp(l)=t(6,ll)*c1m3
      c(l)=t(1,ll-1)
      cp(l)=t(1,ll)
    end do
    
#ifdef ROOT
    if(root_flag .and. root_Optics.eq.1) then
      call OpticsRootWriteLin(nr, typ // C_NULL_CHAR,len(typ),tl,c(1),cp(1),c(2),cp(2),&
        b1(1),b1(2),al1(1),al1(2),d(1),d(2),dp(1),dp(2))
    end if
#endif
#ifdef HDF5
  if(h5_writeOptics) then
      hdf5Data(:) = (/tl,&
        p1(1),b1(1),al1(1),g1(1),d(1),dp(1),c(1),cp(1),&
        p1(2),b1(2),al1(2),g1(2),d(2),dp(2),c(2),cp(2)/)
      call h5lin_writeLine(nr, typ, hdf5Data)
    end if
#endif
  
#if defined(COLLIMAT)
      tbetax(max(ielem,1))  = b1(1)
      tbetay(max(ielem,1))  = b1(2)
      talphax(max(ielem,1)) = al1(1)
      talphay(max(ielem,1)) = al1(2)
      torbx(max(ielem,1))   = c(1)
      torbxp(max(ielem,1))  = cp(1)
      torby(max(ielem,1))   = c(2)
      torbyp(max(ielem,1))  = cp(2)
      tdispx(max(ielem,1))  = d(1)
      tdispy(max(ielem,1))  = d(2)
#endif
    if(ncorru == 0) then
      if(iquiet == 0) then
        write(lout,10000) nr,typ(:8),tl,p1(1),b1(1),al1(1),g1(1),d(1),dp(1),c(1),cp(1)
        write(lout,10010) b2(1),al2(1),g2(1)
        write(lout,10030) typ(9:16)
        write(lout,10020) p1(2),b1(2),al1(2),g1(2),d(2),dp(2),c(2),cp(2)
        write(lout,10010) b2(2),al2(2),g2(2)
        write(lout,10040)
      end if
    else
      if(.not.isBLOC) then
        if(kp(ixwl).eq.3) then
          nhmoni=nhmoni+1
          betam(nhmoni,1)=b1(1)
          pam(nhmoni,1)=(p1(1)*two)*pi
          bclorb(nhmoni,1)=c(1)
        else if(kp(ixwl).eq.4) then
          nhcorr=nhcorr+1
          betac(nhcorr,1)=b1(1)
          pac(nhcorr,1)=(p1(1)*two)*pi
        else if(kp(ixwl).eq.-3) then
          nvmoni=nvmoni+1
          betam(nvmoni,2)=b1(2)
          pam(nvmoni,2)=(p1(2)*two)*pi
          bclorb(nvmoni,2)=c(2)
        else if(kp(ixwl).eq.-4) then
          nvcorr=nvcorr+1
          betac(nvcorr,2)=b1(2)
          pac(nvcorr,2)=(p1(2)*two)*pi
        end if
      end if
    end if
  end if
!-----------------------------------------------------------------------
  return
10010 format('|',6x,'|',8x,'|',12x,'|',1x,'|',12x,'|',f12.6,'|', f13.7,'|',f11.6,'|',11x,'|',11x,'|',11x,'|',11x,'|')
10020 format('|',6x,'|',8x,'|',12x,'|','Y','|',f12.7,'|',f12.6,'|', f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10040 format(132('-'))
10000 format('|',i6,'|',a8,'|',f12.5,'|','X','|',f12.7,'|',f12.6,'|',f13.7,'|',f11.6,'|',f11.7,'|',f11.7,'|',f11.7,'|',f11.7,'|')
10030 format('|',6x,'|',a8,'|',12x,'|',102('-'))
end subroutine writelin

subroutine cpltwis(typ,t,etl,phi)
!-----------------------------------------------------------------------
!  CALCULATES COUPLED TWISS PARAMETERS AROUND THE RING AND ALSO THE
!  ANGLE OF THE MAJOR AXIS OF A ELLIPSE IN THE X-Y PROJECTION WITH
!  THE X-AXIS. THE 4-D ELLIPSOID IS GIVEN BY THE BOUNDARY OF A
!  DISTRIBUTION OF PARTICLES WITH MAXIMUM EMITANCE OF MODE I AND II,
!  EUI AND EUII RESPECTIVELY.
!  BINARY PRINT ON FILE 11 OF 22 VALUES :
!  POSITION [M],
!  BET(1-4), ALF(1-4), GAM(1-4), COOR-PHI(1-4), COOR-PRIME-PHI(1-4),
!  COUUANGL
!-----------------------------------------------------------------------
      use floatPrecision
#ifdef ROOT
      use root_output
#endif
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,iwrite
      real(kind=fPrec) alxi,alxii,alzi,alzii,bexi,bexii,bezi,bezii,     &
     &couuang,etl,gaxi,gaxii,gazi,gazii,phi,phxi,phxii,phxpi,phxpii,    &
     &phzi,phzii,phzpi,phzpii,t
      character(len=max_name_len) typ
      dimension t(6,4),phi(2)
      save
!-----------------------------------------------------------------------
      iwrite=0
      if(nlin.eq.0) then
        iwrite=1
      else
        do 10 i=1,nlin
          if(typ.eq.bezl(i)) iwrite=1
   10   continue
      endif
      if(iwrite.eq.1) then
        bexi=t(2,1)**2+t(3,1)**2                                         !hr06
        bexii=t(4,1)**2+t(5,1)**2                                        !hr06
        bezi=t(2,3)**2+t(3,3)**2                                         !hr06
        bezii=t(4,3)**2+t(5,3)**2                                        !hr06
        alxi=-one*(t(2,1)*t(2,2)+t(3,1)*t(3,2))                          !hr06
        alxii=-one*(t(4,1)*t(4,2)+t(5,1)*t(5,2))                         !hr06
        alzi=-one*(t(2,3)*t(2,4)+t(3,3)*t(3,4))                          !hr06
        alzii=-one*(t(4,3)*t(4,4)+t(5,3)*t(5,4))                         !hr06
        gaxi=t(2,2)**2+t(3,2)**2                                         !hr06
        gaxii=t(4,2)**2+t(5,2)**2                                        !hr06
        gazi=t(2,4)**2+t(3,4)**2                                         !hr06
        gazii=t(4,4)**2+t(5,4)**2                                        !hr06
        if(abs(t(2,1)).gt.pieni) phxi=atan2_mb(t(3,1),t(2,1))
        if(abs(t(4,1)).gt.pieni) phxii=atan2_mb(t(5,1),t(4,1))
        if(abs(t(4,1)).gt.pieni) phxii=atan2_mb(t(5,1),t(4,1))
        if(abs(t(2,3)).gt.pieni) phzi=atan2_mb(t(3,3),t(2,3))
        if(abs(t(4,3)).gt.pieni) phzii=atan2_mb(t(5,3),t(4,3))
        if(abs(t(2,2)).gt.pieni) phxpi=atan2_mb(t(3,2),t(2,2))
        if(abs(t(4,2)).gt.pieni) phxpii=atan2_mb(t(5,2),t(4,2))
        if(abs(t(2,4)).gt.pieni) phzpi=atan2_mb(t(3,4),t(2,4))
        if(abs(t(4,4)).gt.pieni) phzpii=atan2_mb(t(5,4),t(4,4))
        if(abs(t(2,1)).le.pieni) phxi=pi*half
        if(abs(t(4,1)).le.pieni) then
          if(bexii.gt.pieni) phxii=pi*half
          if(bexii.le.pieni) phxii=zero
        endif
        if(abs(t(2,3)).le.pieni) then
          if(bezi.gt.pieni) phzi=pi*half
          if(bezi.le.pieni) phzi=zero
        endif
        if(abs(t(4,3)).le.pieni) phzii=pi*half
        if(abs(t(2,2)).le.pieni) phxpi=pi*half
        if(abs(t(4,2)).le.pieni) then
          if(gaxii.gt.pieni) phxpii=pi*half
          if(gaxii.le.pieni) phxpii=zero
        endif
        if(abs(t(2,4)).le.pieni) then
          if(gazi.gt.pieni) phzpi=pi*half
          if(gazi.le.pieni) phzpi=zero
        endif
        if(abs(t(4,4)).le.pieni) phzpii=pi*half
        if(abs(eui*(bexi-bezi)+euii*(bexii-bezii)).gt.pieni) then
          couuang=half*atan_mb((two*((eui*sqrt(bexi*bezi))*             &!hr06
     &cos_mb(phxi-phzi)+                                                &!hr06
     &(euii*sqrt(bexii*bezii))*cos_mb(phxii-phzii)))/ (eui*(bexi-bezi)  &!hr06
     &+euii*(bexii-bezii)))                                              !hr06
        else
          couuang=zero
        endif
        write(11,*) typ,etl,phi,bexi,bexii,bezi,bezii, alxi,alxii,alzi, &
     &alzii, gaxi,gaxii,gazi,gazii,phxi,phxii,phzi,phzii, phxpi,        &
     &phxpii,phzpi,phzpii,couuang,t(6,1),t(6,2),t(6,3),t(6,4),t(1,1),   &
     &t(1,2),t(1,3),t(1,4)

#ifdef ROOT
      if(root_flag .and. root_Optics.eq.1) then
        call OpticsRootWriteCpl(phi(1), phi(2),bexi,bexii,bezi,bezii,       &
 &                                  alxi,alxii,alzi,alzii,       &
 &                                  gaxi,gaxii,gazi,gazii,       &
 &                                  phxi,phxii,phzi,phzii,       &
 &                                  phxpi,phxpii,phzpi,phzpii,   &
 &                                  couuang,                     &
 &                                  t(6,1),t(6,2),t(6,3),t(6,4), &
 &                                  t(1,1),t(1,2),t(1,3),t(1,4))
      end if
#endif

      endif
      return
end subroutine cpltwis

+dk loesd
subroutine loesd (rmat, vec,dimakt,dimtot,kod)
!-----------------------------------------------------------------------
!  SOLUTION OF A SYSTEM OF LINEAR EQUATIONS
!  VEC1 = VEC2 * RMAT , WITH VEC2 AS RESULT
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      implicit none
      integer ik,indi,j,jk,jy,k,kk,kod,l,n,n1,dimtot,dimakt
      real(kind=fPrec) emax,eps,r,rmat,vec
      dimension rmat(dimtot,dimakt),vec(dimakt)
      data eps /1e-20_fPrec/
      save
!-----------------------------------------------------------------------
      kod=1
      do j=1,dimakt
        emax=zero
        do 10 ik=j,dimakt
          if(abs(emax).gt.abs(rmat(j,ik)) .or.emax.ne.emax) goto 10
          emax=rmat(j,ik)
          indi=ik
   10   continue
        if(abs(emax).lt.eps) then
          write(lout,*) '  ****   ERROR IN LOESD   **** '
          return
        endif

   20   do l=j,dimakt
          r=rmat(l,j)
          rmat(l,j)=rmat(l,indi)
          rmat(l,indi)=r
          rmat(l,j)=rmat(l,j)/emax
        end do

        r=vec(indi)
        vec(indi)=vec(j)
        vec(j)=r/emax
        if(j.eq.dimakt) goto 60
        jy=j+1

        do jk=jy,dimakt
          r=rmat(j,jk)

          do kk=jy,dimakt
            rmat(kk,jk)= rmat(kk,jk)-r*rmat(kk,j)
          end do
          vec(jk)=vec(jk)-vec(j)*r
        end do
      end do

   60 n=dimakt
      n1=dimakt-1

      do j=1,n1
        do k=1,j
          vec(n-j)=vec(n-j)-rmat(n-k+1,n-j)*vec(n-k+1)
        end do
      end do

      kod = 0
      return
end subroutine loesd

+dk matrix
subroutine matrix(dpp,am)
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,ierr,l
      real(kind=fPrec) am,dpp
      dimension am(4,4)
      save
!-----------------------------------------------------------------------
      do i=2,5
        do l=1,2
           x(i,l)=zero
           y(i,l)=zero
        end do
      end do

      x(2,1)=one
      y(3,1)=one
      x(4,2)=one
      y(5,2)=one

      do l=1,2
        x(1,l)=clo(l)
        y(1,l)=clop(l)
      end do

      call umlauf(dpp,5,ierr)
      ierro=ierr

      do i=1,4
        am(1,i)=x(i+1,1)
        am(2,i)=y(i+1,1)
        am(3,i)=x(i+1,2)
        am(4,i)=y(i+1,2)
      end do
!-----------------------------------------------------------------------
      return
end subroutine matrix

+dk orbit
subroutine corrorb
!-----------------------------------------------------------------------
!  CORRECTION OF CLOSED ORBIT FIRST (MOST EFFECTIV CORRECTOR STRATEGY
!  USING MICADO), THEN
!  SCALING OF DIPOLE-ERRORS FOR RMS-VALUES OF THE CLOSED ORBIT
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,icflag,ihflag,ii,ij,im,iprinto,ivflag,j,k,kpz,kzz,l,nlino,ntcoo,nto,nx
      real(kind=fPrec) ar(nmon1,ncor1)
      real(kind=fPrec) b(nmon1),orbr(nmon1),xinc(ncor1)
      real(kind=fPrec) rmsx,ptpx,rmsz,ptpz,rzero,rzero1
      real(kind=fPrec) clo0,clop0,hfac,qwc1,vfac
      character(len=max_name_len) bezlo(nele)
      dimension clo0(2),clop0(2)
      dimension qwc1(3),nx(ncor1)
      save
!-----------------------------------------------------------------------
      rzero=zero
      rzero1=zero
      do l=1,2
        clo0(l)=zero
        clop0(l)=zero
        di0(l)=zero
       dip0(l)=zero
      end do

      call clorb(ded)
      if(ierro.gt.0) call prror(4)

      do l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
      end do

      call clorb(zero)
      if(ierro.gt.0) call prror(5)

      do l=1,2
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
      end do

      do l=1,ncor1
        xinc(l)=zero
        nx(l)=0
      end do

      if(iclo.eq.0) return

!-- ORBIT CORRECTION
      ihflag=0
      ivflag=0
      icflag=0

      write(lout,*)
      write(lout,10000)

      if(ncorru.eq.0) then
        call prror(84)
      else
        if(ncorrep.le.0) then
          write(lout,10010) ncorru,sigma0(1),sigma0(2)
        else
          write(lout,10020) ncorru,ncorrep
        endif
      endif

      write(lout,*)

!-- SAVE OLD 'LINOPT' SETTINGS
      iprinto=iprint
      nto=nt
      ntcoo=ntco

      do i=1,nlin
        bezlo(i)=bezl(i)
      end do

      nlino=nlin

!-- PUT MONITORS AND CORRECTORS INTO LINOPT SETTINGS
!-- GET TWISS PARAMETERS AND DISTORTED ORBIT BACK
      iprint=0
      ntco=0
      nlin=0

      do i=1,il
        if(kp(i).eq.3.or.kp(i).eq.4.or. kp(i).eq.-3.or.kp(i).eq.-4) bezl&
     &(i)=bez(i)
        nlin=nlin+1
      end do

      call linopt(zero)
      call phasad(zero,qwc1)

!-- CHECK SOME CONDITIONS
      write(lout,10100) nhmoni,nhcorr,nvmoni,nvcorr
      if(nhmoni.gt.nmon1) then
        write(lout,10070) nhmoni,nmon1
        return
      endif
      if(nvmoni.gt.nmon1) then
        write(lout,10070) nvmoni,nmon1
        return
      endif
      if(nhcorr.gt.ncor1) then
        write(lout,10080) nhcorr,ncor1
        return
      endif
      if(nvcorr.gt.ncor1) then
        write(lout,10080) nvcorr,ncor1
        return
      endif
      if(nhmoni.lt.nhcorr.or.nvmoni.lt.nvcorr) write(lout,10090)

      write(lout,*)
      call orbinit

!-- CORRECT BOTH PLANES
      if(ncorrep.eq.0) then
        icflag=1
        ncorrep=itco
      endif
      do 110 ii=1,ncorrep

!-- HORIZONTAL PLANE FIRST
        do i=1,nhmoni
          b(i)=bclorb(i,1)
          do j=1,nhcorr
      ar(i,j)=((sqrt(betam(i,1)*betac(j,1))*cos_mb(abs(pam(i,1)-pac     &!hr06
     &(j,1))-qwc1(1)*pi))*c1e3)/(two*sin_mb(qwc1(1)*pi))                 !hr06
          end do
        end do

        call calrms(b,nhmoni,rmsx,ptpx)

!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nhmoni,nhcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

!-- VERTICAL PLANE HERE
        do i=1,nvmoni
          b(i)=bclorb(i,2)                                               !hr06
          do j=1,nvcorr
      ar(i,j)=((sqrt(betam(i,2)*betac(j,2))*cos_mb(abs(pam(i,2)-pac     &!hr06
     &(j,2))-qwc1(2)*pi))*c1e3)/(two*sin_mb(qwc1(2)*pi))                 !hr06
          end do
        end do

        call calrms(b,nvmoni,rmsz,ptpz)
        write(lout,10030) ii-1,rmsx,rmsz
        write(lout,10040) ii-1,ptpx,ptpz
        if(icflag.eq.1.and.sigma0(1).gt.rmsx.and.ihflag.eq.0) then
          write(lout,10110)
          ihflag=1
        endif
        if(icflag.eq.1.and.sigma0(2).gt.rmsz.and.ivflag.eq.0) then
          write(lout,10120)
          ivflag=1
        endif

        if(ihflag.eq.0) then
          write(lout,*)

          do ij=1,ncorru/10
            write(lout,10050) (nx(10*(ij-1)+k), k=1,10)
          end do

          if(mod(ncorru,10).gt.0) then
            write(lout,10050) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,1)
        endif

!-- MICADO WITH HOUSEHOLDER TRANSFORMATION
        call htls(ar,b,nvmoni,nvcorr,xinc,nx,orbr,ncorru,rzero,rzero1)

        if(ivflag.eq.0) then
          write(lout,*)
          do 100 ij=1,ncorru/10
            write(lout,10060) (nx(10*(ij-1)+k), k=1,10)
  100     continue

          if(mod(ncorru,10).gt.0) then
            write(lout,10060) (nx(10*(ij-1)+k), k=1,mod(ncorru,10))
          endif
          call putorb(xinc,nx,2)
        endif

        if(ihflag.eq.1.and.ivflag.eq.1) goto 140
        call linopt(zero)
        call phasad(zero,qwc1)
  110 continue

!-- GET LAST VALUES AFTER CORRECTION
      do 120 i=1,nhmoni
        b(i)=bclorb(i,1)                                                 !hr06
  120 continue

      call calrms(b,nhmoni,rmsx,ptpx)

      do 130 i=1,nvmoni
        b(i)=bclorb(i,2)                                                 !hr06
  130 continue

      call calrms(b,nvmoni,rmsz,ptpz)
      write(lout,10030) ncorrep,rmsx,rmsz
      write(lout,10040) ncorrep,ptpx,ptpz
      write(lout,*)

  140 continue
      if((ii-1).eq.itco) write(lout,10130) itco

!-- SCALE TO DESIRED RMS VALUE IF IT IS GREATER THAN ZERO
      if(sigma0(1).gt.pieni.or.sigma0(2).gt.pieni) then
        do 180 ii=1,itco
          write(lout,10140)
          hfac=sigma0(1)/rmsx                                            !hr06
          vfac=sigma0(2)/rmsz                                            !hr06
          do 150 i=1,il
            kzz=kz(i)
            kpz=kp(i)
            if(kzz.eq.1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*hfac
              ek(i)=ek(i)*hfac
            endif
            if(kzz.eq.-1.and.el(i).lt.pieni) then
              ed(i)=ed(i)*vfac
              ek(i)=ek(i)*vfac
            endif
            if(kzz.eq.11) then
              im=irm(i)
              ak0(im,1)=ak0(im,1)*vfac
              aka(im,1)=aka(im,1)*vfac
              bk0(im,1)=bk0(im,1)*hfac
              bka(im,1)=bka(im,1)*hfac
            endif
  150     continue
          call linopt(zero)

          do 160 i=1,nhmoni
            b(i)=bclorb(i,1)                                             !hr06
  160     continue

          call calrms(b,nhmoni,rmsx,ptpx)

          do 170 i=1,nvmoni
            b(i)=bclorb(i,2)                                             !hr06
  170     continue

          call calrms(b,nvmoni,rmsz,ptpz)

          write(lout,10150) ii,rmsx,rmsz
          write(lout,10160) ii,ptpx,ptpz
          write(lout,*)
          if(abs(real(rmsx,fPrec)-sigma0(1)).lt.dsi.and.                      &!hr06
     &       abs(real(rmsz,fPrec)-sigma0(2)).lt.dsi)                          &!hr06
     &goto 190
  180   continue
      endif

      if((ii-1).eq.itco) write(lout,10130) itco
  190 continue

!-- WRITE OUT ADJUSTED CLOSED ORBIT
      do 200 i=1,nhmoni
        write(28,*) i,bclorb(i,1)
  200 continue

      do 210 i=1,nhmoni
        write(29,*) i,bclorb(i,2)
  210 continue

!-- CHANGE BACK TO OLD 'LINOPT' SETTINGS
      iprint=iprinto
      nt=nto
      ntco=ntcoo
      nlin=nlino

      do 220 i=1,nlin
        bezl(i)=bezlo(i)
  220 continue

      ncorru=0
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ORBIT CORRECTION WITH MOST EFFCTIVE CORRECTOR ',  &
     &'STRATEGY ----')
10010 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS UNTIL',/, &
     &t5,'       HOR. RMS SMALLER THAN ',f6.3,' MM',/, t5,              &
     &'       VER. RMS SMALLER THAN ',f6.3,' MM')
10020 format(t5,'     ORBIT CORRECTION WITH ',i4,' CORRECTORS AND ',i4, &
     &' ITERATIONS.')
10030 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-RMS: ',f6.3, &
     &' VER.-RMS: ',f6.3)
10040 format(t5,'---- CORRECTION ITERATION NO. ',i4,' HOR.-PTP: ',f6.3, &
     &' VER.-PTP: ',f6.3)
10050 format(t5,'     HORIZONTAL CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10060 format(t5,'     VERTICAL   CORRECTORS USED:', i4,i4,i4,i4,i4,i4,  &
     &i4,i4,i4,i4)
10070 format(/,t5,'ERROR: NUMBER OF MONITORS TOO BIG.',/                &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10080 format(/,t5,'ERROR: NUMBER OF CORRECTORS TOO BIG.',/              &
     &'    THERE ARE ',i4,' MONITORS SET, BUT ONLY ',i4, ' ALLOWED.',/  &
     &'    NO CORRECTION DONE.',/)
10090 format(/,t5,'WARNING: NUMBER OF MONITORS IS SMALLER THAN NUMBER', &
     &' OF CORRECTORS.',/ '    NUMERICAL PROBLEMS MIGHT BE ENCOUNTERED.'&
     &)
10100 format(/,t5,'NUMBER OF HOR. MONITORS: ',i4,                       &
     &'  NUMBER OF HOR. CORRECTORS: ',i4,/, t5,                         &
     &'NUMBER OF VER. MONITORS: ',i4, '  NUMBER OF VER. CORRECTORS: ',  &
     &i4)
10110 format(t10,'HORIZONTAL RMS GOAL REACHED')
10120 format(t10,'VERTICAL RMS GOAL REACHED')
10130 format(t10,'MAXIMUM NUMBER OF ITERATIONS ACHIVED: ',i4,/ ,t10,    &
     &'INCREASE ITCO TO INCREASE THE NUMBER OF ' ,                      &
     &'CLOSED ORBIT ITERATIONS',/)
10140 format(t5,'---- ORBIT SCALING USING ALL POSSIBLE ELEMENTS ')
10150 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-RMS: ',f6.3,    &
     &' VER.-RMS: ',f6.3)
10160 format(t5,'---- SCALING ITERATION NO. ',i4,' HOR.-PTP: ',f6.3,    &
     &' VER.-PTP: ',f6.3)
end subroutine corrorb

      subroutine putorb(xinc,nx,npflag)
!-----------------------------------------------------------------------
!  PUT ORBIT CHANGES FROM MICADO TO THE GIVEN ORBIT CORRECTORS
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none

      integer i,im,ix,izu,j,k,kcorr,kcorru,kpz,kzz,nmz,npflag,nx
      real(kind=fPrec) xinc(ncor1)
      real(kind=fPrec) ckicknew,ckickold,r0,r0a
      dimension nx(ncor1)
      save
!-----------------------------------------------------------------------
      kcorru=0
      kcorr=0
      izu=0

      do 60 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 60
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 60
        if(kzz.eq.15) goto 60
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if(kpz.eq.4.and.kzz.eq.1.and.npflag.eq.1.or.                    &
     &kpz.eq.-4.and.kzz.eq.-1.and.npflag.eq.2) then
          kcorr=kcorr+1
          do 10 j=1,ncorru
            if(nx(j).eq.kcorr) then
              kcorru=kcorru+1
              ckickold=sm(ix)+zfz(izu)*ek(ix)
              zfz(izu)=zfz(izu)+real(xinc(j),fPrec)/ek(ix)                     !hr06
              ckicknew=sm(ix)+zfz(izu)*ek(ix)
              write(lout,10000) kcorru,kcorr,bez(ix), ckickold*c1e3,    &
     &ckicknew*c1e3
            endif
   10     continue
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 60
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 60
          endif
          im=irm(ix)
          r0a=one
          do 50 k=1,nmz
            izu=izu+1
            if(kpz.eq.-4.and.npflag.eq.2.and.k.eq.1) then
              kcorr=kcorr+1
              do 30, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k))/r0a
           zfz(izu)=zfz(izu)+(c1e3*(real(xinc(j),fPrec)/(r0a*ed(ix))-ak0&!hr06
     &(im,k)))/aka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(ak0(im,k)+zfz(izu)* aka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   30         continue
            endif
            izu=izu+1
            if(kpz.eq.4.and.npflag.eq.1.and.k.eq.1) then
              kcorr=kcorr+1
              do 40, j=1,ncorru
                if(nx(j).eq.kcorr) then
                  kcorru=kcorru+1
                  ckickold=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
           zfz(izu)=zfz(izu)+(c1e3*(real(xinc(j),fPrec)/(r0a*ed(ix))-bk0&!hr06
     &(im,k)))/bka(im,k)                                                 !hr06
                  ckicknew=(ed(ix)*(bk0(im,k)+zfz(izu)* bka(im,k)))/r0a  !hr06
                  write(lout,10000) kcorru,kcorr,bez(ix), ckickold,     &
     &ckicknew
                endif
   40         continue
            endif
   50     continue
          izu=izu+2*mmul-2*nmz
        endif
   60 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,i4,i4,' ',a16,'  OLD: ',d14.7,' MRAD   NEW: ' ,d14.7,   &
     &' MRAD')
      end

      subroutine orbinit
!-----------------------------------------------------------------------
!  INITIALIZES THE RANDOM NUMBER OF NOT SET CORRCTORS
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,im,ix,izu,kpz,kzz,nmz
      real(kind=fPrec) r0
      save
!-----------------------------------------------------------------------
      izu=0
      do 10 i=1,iu
        ix=ic(i)
        if(ix.le.nblo) goto 10
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 10
        if(kzz.eq.15) goto 10
        if(iorg.lt.0) mzu(i)=izu
        izu=mzu(i)+1
        if((kpz.eq.4.and.kzz.eq.1).or.(kpz.eq.-4.and.kzz.eq.-1)) then
          zfz(izu)=zero
          ek(ix)=one
          ncororb(ix)=1
        endif
        izu=izu+2

        if(kzz.eq.11) then
          r0=ek(ix)
          if(abs(r0).le.pieni) goto 10
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 10
          endif
          im=irm(ix)

          izu=izu+1
          if(kpz.eq.-4) then
            zfz(izu)=zero
            aka(im,1)=one
          endif
          izu=izu+1
          if(kpz.eq.4) then
            zfz(izu)=zero
            bka(im,1)=one
          endif
          izu=izu+2*mmul-2
        endif
   10 continue
      return
      end

subroutine htls(a,b,m,n,x,ipiv,r,iter,rms,ptp)
!*********************************************************************
!     Subroutine HTLS to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     DIMENSION OF ARRAY RHO SHOULD BE 3*NCOR1                       *
!     M    - NUMBER OF AVAILABLE MONITORS                            *
!     N    - NUMBERR OF AVAILABLE INDEPENDENT CORRECTORS             *
!     ITER - NUMBER OF CORRECTORS TO BE USED                         *
!     RMS  - RMS VALUE TO CORRECT FOR                                *
!     PTP  - PEAK TO PEAK VALUE TO CORRECT FOR                       *
!*********************************************************************
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      implicit none
      integer i,iii,ij1,ip,ipiv,iter,j,j1,k,k2,k3,ki,kk,kpiv,m,n,ncor1, &
     &nmon1
      real(kind=fPrec) a,b,piv,pivt,ptop,r,rho,rmss,x,xiter,xptp,xrms
      real(kind=fPrec) rms,ptp
      real(kind=fPrec) g,h,sig,beta
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),x(ncor1),ipiv(ncor1),r(nmon1)
      dimension rho(3*ncor1),xiter(ncor1),xrms(ncor1),xptp(ncor1)
      dimension rmss(ncor1),ptop(ncor1)
      save
!-----------------------------------------------------------------------

! --- calcul du premier pivot

!============================
      beta=zero

      do ij1=1,500
        rho(ij1)=zero
      end do

      k2=n + 1
      piv=zero

      do k=1,n
        ipiv(k)=k
        h=zero                                                           !hr06
        g=zero                                                           !hr06

        do i=1,m
          h=h+a(i,k)*a(i,k)
          g=g+a(i,k)*b(i)
        end do

        rho(k)=h
        rho(k2) = g
        pivt = g**2/h                                                    !hr06
        if(pivt-piv.le.0) goto 40
        if(pivt-piv.gt.0) goto 30
   30   piv = pivt

        kpiv=k
        k2 = k2 + 1
   40   continue
      end do

! --- boucle pour chaque iteration

      do 150 k=1,iter
        if(kpiv.eq.k)goto 60

! --- on echange les K et KPIV si KPIV plus grand que K
        h=rho(k)
        rho(k)=rho(kpiv)
        rho(kpiv)=h
        k2=n+k
        k3=n+kpiv
        g = rho(k2)
        rho(k2) = rho(k3)
        rho(k3) = g
        do i=1,m
          h=a(i,k)
          a(i,k)=a(i,kpiv)
          a(i,kpiv)=h
        end do

! --- calcul de beta,sigma et uk dans htul
   60   continue
        call htul(a,m,n,k,sig,beta)

! --- on garde SIGMA dans RHO(N+K)
        j=n+k
        rho(j)=-one*sig                                                  !hr06
        ip=ipiv(kpiv)
        ipiv(kpiv)=ipiv(k)
        ipiv(k)=ip
        if(k.eq.n) goto 70

! --- transformation de A dans HTAL
        call htal(a,m,n,k,beta)

! --- transformation de B dans HTBL
   70   continue
        call htbl(a,b,m,n,k,beta)

! --- recherche du pivot (K+1)
!=============================

        rho(k)=sqrt(piv)
        if(k.eq.n) goto 90
        piv=zero                                                          !hr06
        kpiv = k + 1
        j1 = kpiv
        k2=n + j1

        do j=j1,n
          h=rho(j)-(a(k,j))*(a(k,j))

          if(h.lt.c1m7) then
            write(lout,*)
            write(lout,*) 'CORRECTION PROCESS ABORTED.'
            write(lout,*) 'DIVISION BY ZERO EXPECTED.'
            write(lout,*) 'PROBABLY TWO CORRECTORS TOO CLOSE.'
            write(lout,10000) ' SUSPECTED CORRECTOR: ',j
            write(lout,'(a)') "Error '777' in subroutine htls"
            call prror(-1)
          endif

          rho(j)=h
          g=rho(k2)-(a(k,j))*(b(k))
          rho(k2) = g
          pivt = g**2/h                                                  !hr06
          if(pivt.lt.piv)goto 80
          kpiv=j
          piv=pivt
          k2 = k2 + 1
   80     continue
        end do

! --- calcul des X
   90   x(k)=b(k)/rho(n+k)
        if(k.eq.1)goto 120
        do i=2,k
          kk=k-i+1
          x(kk)=b(kk)
          ki=kk+1
          do j=ki,k
            x(kk)=x(kk)-a(kk,j)*x(j)
          end do
          x(kk)=x(kk)/rho(n+kk)
        end do
  120   continue

! --- save residual orbit and inverse sign of corrections (convention!)
        do iii= 1,m
          r(iii) = b(iii)
        end do
        do iii= 1,k
          x(iii) =-one*x(iii)                                           !hr06
        end do

! --- calcul du vecteur residuel dans HTRL
!=========================================

!     transform orbit R back to "normal space"
        call htrl(a,r,m,n,k,rho)
        call calrms(r,m,rmss(k),ptop(k))
        xiter(k+1) = k
        xrms(k+1) = rmss(k)
        xptp(k+1) = ptop(k)

        if(ptop(k).le.ptp)goto 160
        if(rmss(k).le.rms)goto 160
  150 continue
      return

! --- correction is already good enough:
!=======================================

  160 ptp=ptop(k)
      rms=rmss(k)
10000 format(a,i4)
end subroutine htls
  
      subroutine htal(a,m,n,k,beta)
!*********************************************************************
!     Subroutine HTAL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of matrix A
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer j,k,k1,m,n,nc,ncor1,nmon1
      real(kind=fPrec) a,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------

      nc=n-k

      do j=1,nc
        h=zero                                                          !hr06

        do k1=k,m
          h=h+a(k1,k)*a(k1,k+j)
        end do

        h=beta*h
        do k1=k,m
          a(k1,k+j)=a(k1,k+j)-a(k1,k)*h
        end do
      end do

      end
      subroutine htbl(a,b,m,n,k,beta)
!*********************************************************************
!     Subroutine HTBL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     Householder transform of vector B
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer

      implicit none

      integer k,k1,m,n,ncor1,nmon1
      real(kind=fPrec) a,b,beta,h
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1)
      save
!-----------------------------------------------------------------------

      h=zero                                                           !hr06

      do k1=k,m
        h=h+a(k1,k)*b(k1)
      end do

      h=beta*h

      do k1=k,m
        b(k1)=b(k1)-a(k1,k)*h
      end do

      end

      subroutine htrl(a,b,m,n,k,rho)
!*********************************************************************
!     Subroutine HTRL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate residual orbit vector
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,k,kk,kl,kn,lv,m,n,ncor1,nmon1
      real(kind=fPrec) a,b,beta,rho
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1),b(nmon1),rho(3*ncor1)
      save
!-----------------------------------------------------------------------

      do i= 1,k,1
        b(i)= zero                                                       !hr06
      end do

      do kk=1,k
        lv=m-k+kk
        kn=n+k-kk+1
        kl=k-kk+1

        beta=-one/(rho(kn)*a(kl,kl))                                     !hr06
        call htbl(a,b,m,n,kl,beta)
      end do

      end

      subroutine htul(a,m,n,k,sig,beta)
!*********************************************************************
!     Subroutine HTUL to make Householder transform                  *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculate vector U
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,k,m,n,ncor1,nmon1
      real(kind=fPrec) a,beta,h,sig
      parameter (nmon1 = 600)
      parameter (ncor1 = 600)
      dimension a(nmon1,ncor1)
      save
!-----------------------------------------------------------------------
      sig=zero                                                          !hr06

      do i=k,m
        sig=sig+a(i,k)* a(i,k)
      end do

      sig=sqrt(sig)
!     on choisit le signe correct pour SIG:
      h=a(k,k)
      if(h.lt.zero)sig=-one*sig                                          !hr06
      beta=h + sig
      a(k,k)=beta
      beta=one/(sig*beta)                                                !hr06
      end

      subroutine calrms(r,m,rms,ptp)
!*********************************************************************
!     Subroutine CALRMS to calculate rms                             *
!                                                                    *
!     Authors:     many                Date:  17.09.1989             *
!                                                                    *
!     calculates rms and p.to.p value of R(1) .... R(M)
!*********************************************************************
      use floatPrecision
  use numerical_constants
      use mathlib_bouncer
      implicit none
      integer i,imax,imin,m,maxmin
      real(kind=fPrec) ave,ptp,r,rms,xave,xrms
      dimension r(m)
      save
!-----------------------------------------------------------------------
      xave = zero
      xrms = zero

      do i=1,m
        xave = xave + r(i)
        xrms = xrms + r(i)**2                                            !hr06
      end do

      ave = xave / real(m,fPrec)
      rms = xrms / real(m,fPrec)

      imax=maxmin(r(1),m,1)
      imin=maxmin(r(1),m,0)
      ptp=r(imax)-r(imin)
      rms=sqrt(rms)
      return
      end

      function maxmin (a,n,m)
!-----------------------------------------------------------------------
!     if M=0, MAXMIN=lowest index of minimum element in A
!     if M=1, MAXMIN=lowest index of maximun element in A
!     if N<1, MAXMIN=1
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      implicit none
      integer i,m,maxmin,n
      real(kind=fPrec) a,curent
      dimension a(n)
      save
!-----------------------------------------------------------------------
      maxmin=1
      if (n.lt.1) return
      curent=a(1)

      do i=2,n
        if ((m.eq.0).and.(a(i).ge.curent)) goto 10
        if ((m.eq.1).and.(a(i).le.curent)) goto 10
        curent=a(i)
        maxmin=i
   10   continue
      end do

      return
      end

+dk ord
subroutine ord
!-----------------------------------------------------------------------
!  ORGANISATION OF NONLINEAR ELEMENTS AND RANDOM NUMBERS
!  reserving places in zfz:
!  - 1+2 for misalignment (h/v - DISP block / fort.8 / fort.30);
!  - 2xmmul for multipole errors (fort.16);
!  mapping also position of errors for a given element in lattice
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,inz,iran,ix,izu,j,jra,jra3,kpz,kzz,kzz1,kzz2,nra1
      dimension jra(nele,5),iran(nele),inz(nele)
      save
!-----------------------------------------------------------------------
      ! initialisation
      do i=1,nele
        iran(i)=0
        inz(i)=0
        do j=1,5
          jra(i,j)=0
        end do
      end do

!--ORGANISATION OF RANDOM NUMBERS
      if(niu(1).lt.0) niu(1)=iabs(niu(1))
      if(niu(2).lt.0) niu(2)=iabs(niu(2))
      if(niu(1).eq.0) niu(1)=1
      if(niu(2).eq.0) niu(2)=iu
      if(niu(1).gt.iu) niu(1)=1
      if(niu(2).gt.iu) niu(2)=iu
      izu=0
      nra1=nran
      iorg=iorg-1
      if(iorg.ge.0) then
        if(iorg.eq.0) then !iorg == 0
          do i=1,iu
            ix=ic(i)
            ! skip blocks:
            if(ix.le.nblo) cycle
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            ! skip RF cavity, inactive non-linear elements, BB lenses, phase-trombones, wires
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) cycle
            !  map position of errors for present element in lattice structure
            mzu(i)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
            if(izu.gt.nzfz) then
              write(lout,*) "ERROR in ORD: nzfz was too small"
              call prror(-1)
            endif
          end do
        else ! iorg.gt.0
          do i=1,iorg
            do j=1,il
              if(bez(j).eq.bezr(1,i)) then
                jra(i,1)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22) call prror(31)
                jra(i,2)=kz(j)
              endif
              if(bez(j).eq.bezr(2,i)) then
                jra(i,3)=j
                if(kz(j).eq.0.or.kz(j).eq.20.or.kz(j).eq.22) call prror(31)
                jra(i,4)=kz(j)
              endif
            end do
            kzz1=jra(i,2)
            kzz2=jra(i,4)
            if(kzz1.ne.0.and.kzz2.eq.0) then
              jra(i,5)=nra1
              nra1=nra1+mran*3
              if(kzz1.eq.11.and.abs(ek(jra(i,1))).gt.pieni) nra1=nra1+mran*2*mmul
              if(nra1.gt.nzfz) call prror(32)
            endif
            if(kzz1.eq.11.and.(kzz2.ne.11.and.kzz2.ne.0)) call prror(33)
          end do
          do i=1,iu
            ix=ic(i)
            ! skip blocks:
            if(ix.le.nblo) cycle
            ix=ix-nblo
            kpz=kp(ix)
            kzz=kz(ix)
            ! skip RF cavity, inactive non-linear elements, BB lenses, phase-trombones, wires
            if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) cycle
            do j=1,iorg
              if(bez(ix).eq.bezr(1,j)) goto 90
            end do
            goto 100
   90       jra3=jra(j,3)
            if(jra3.ne.0) then
              ! map position of errors for present element in lattice structure
              mzu(i)=iran(jra3)
              iran(ix)=mzu(i)
            else
              inz(j)=inz(j)+1
              if(inz(j).gt.mran) call prror(34)
              ! map position of errors for present element in lattice structure
              mzu(i)=jra(j,5)
              iran(ix)=mzu(i)
              jra(j,5)=jra(j,5)+3
              if(jra(j,2).eq.11) jra(j,5)=jra(j,5)+2*mmul
            endif
            cycle
            ! map position of errors for present element in lattice structure
  100       mzu(i)=izu
            iran(ix)=izu
            izu=izu+3
            if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
            if(izu.gt.nran) call prror(30)
          end do
        endif
      else !iorg < 0 (in case of no ORGA block in fort.3)
        do i=1,iu
          ix=ic(i)
          ! skip blocks:
          if(ix.le.nblo) cycle
          ix=ix-nblo
          kpz=kp(ix)
          kzz=kz(ix)
          ! skip RF cavity, inactive non-linear elements, BB lenses, phase-trombones, wires
          if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) cycle
          izu=izu+3
          if(kzz.eq.11.and.abs(ek(ix)).gt.pieni) izu=izu+2*mmul
          ! why just checking? shouldn't we map on mzu(i)?
          if(izu.gt.nran) call prror(30)
          if(izu.gt.nzfz) then
            write(lout,*) "ERROR in ORD: nzfz was too small"
            call prror(-1)
          endif
        end do
      endif
      
!     misalignments
      izu=0
      do i=1,iu
        ix=ic(i)
        ! skip blocks:
        if(ix.le.nblo) cycle
        ix=ix-nblo
        kpz=kp(ix)
        kzz=kz(ix)
        ! skip RF cavity, inactive non-linear elements, BB lenses, phase-trombones, wires
        if(kpz.eq.6.or.kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22.or.kzz.eq.15) cycle
        if(icextal(i).ne.0) then
          izu=izu+2
          xrms(ix)=one
          zrms(ix)=one
          zfz(izu)=extalign(i,1)
          izu=izu+1
          zfz(izu)=extalign(i,2)
          tiltc(i)=cos_mb(extalign(i,3)*c1m3)
          tilts(i)=sin_mb(extalign(i,3)*c1m3)
        else
          izu=izu+3
        endif
        if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.icext(i).ne.0) then
          do j=1,mmul
            izu=izu+1
            zfz(izu)=exterr(i,20+j)
            izu=izu+1
            zfz(izu)=exterr(i,j)
          end do
        else if(kzz.eq.11.and.abs(ek(ix)).gt.pieni.and.icext(i).eq.0) then
          izu=izu+2*mmul
        endif
      end do
      return
end subroutine ord

subroutine orglat
!-----------------------------------------------------------------------
!  ORGANISATION OF LATTICE SEQUENCE
!  A.Mereghetti, last modified 2016-03-14
!  extract pieces of code about lattice structure from original ord
!     subroutine
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,icext1,icextal1,ihi,ii,ilf,ilfr,ix,izu,j,kanf1,kpz,kzz
      real(kind=fPrec) extalig1,exterr1
      dimension ilf(nblz),ilfr(nblz)
      dimension exterr1(nblz,40),extalig1(nblz,3),icext1(nblz),icextal1(nblz)
      save
!-----------------------------------------------------------------------
      if(mper.gt.1) then
        do i=2,mper
          do j=1,mbloz
            ii=(i-1)*mbloz+j
            ihi=j
            if(msym(i).lt.0) ihi=mbloz-j+1
            ic(ii)=msym(i)*ic(ihi)
            if(ic(ii).lt.-nblo) ic(ii)=-ic(ii)
          end do
        end do
      end if
      
      ! set iu
      iu=mper*mbloz

      ! "GO" was not the first structure element -> Reshuffle the structure
      if(kanf.ne.1) then
        write(*,*) ' -> reshuffling lattice structure following' &
     &//' existence of GO keyword not in first position of lattice definition!'

!        initialise some temporary variables
         do i=1,nblz
            ilf(i)=0
            ilfr(i)=0
            icext1(i)=0
            icextal1(i)=0
            do ii=1,3
               extalig1(i,ii)=zero
            enddo
            do ii=1,40
               exterr1(i,ii)=zero
            enddo
        enddo

        !--Re-saving of the starting point (UMSPEICHERUNG AUF DEN STARTPUNKT)
        kanf1=kanf-1
        do i=1,kanf1
          if(iorg.ge.0) ilfr(i)=mzu(i)
          ilf(i)=ic(i)
          icext1(i)=icext(i)
          icextal1(i)=icextal(i)
          extalig1(i,1)=extalign(i,1)
          extalig1(i,2)=extalign(i,2)
          extalig1(i,3)=extalign(i,3)
          do ii=1,40
            exterr1(i,ii)=exterr(i,ii)
          end do
        end do
        do i=kanf,iu
          if(iorg.ge.0) mzu(i-kanf1)=mzu(i)
          ic(i-kanf1)=ic(i)
          icext(i-kanf1)=icext(i)
          icextal(i-kanf1)=icextal(i)
          extalign(i-kanf1,1)=extalign(i,1)
          extalign(i-kanf1,2)=extalign(i,2)
          extalign(i-kanf1,3)=extalign(i,3)
          do ii=1,40
            exterr(i-kanf1,ii)=exterr(i,ii)
          end do
        end do
        do i=1,kanf1
          if(iorg.ge.0) mzu(iu-kanf1+i)=ilfr(i)
          ic(iu-kanf1+i)=ilf(i)
          icext(iu-kanf1+i)=icext1(i)
          icextal(iu-kanf1+i)=icextal1(i)
          extalign(iu-kanf1+i,1)=extalig1(i,1)
          extalign(iu-kanf1+i,2)=extalig1(i,2)
          extalign(iu-kanf1+i,3)=extalig1(i,3)
          do ii=1,40
            exterr(iu-kanf1+i,ii)=exterr1(i,ii)
          end do
        end do
      endif
      
      return
end subroutine orglat

+dk phasad
!-----------------------------------------------------------------------
!  ADDITIONAL ADJUSTMENT OF THE X-PHASEADVANCE BETWEEN 2 POSITIONS
!-----------------------------------------------------------------------
subroutine phasad(dpp,qwc)
  ! Rewritten to remove computed gotos by V.K.B.Olsen on 20/11/2017
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  integer i,ikpv,im,ium,ix,izu,j,jj,jk,jm,k,kpv,kpz,kzz,l,l1,ll,nmz,dj
  real(kind=fPrec) aa,alfa,bb,benkr,beta,ci,cikve,cr,crkve,crkveuk,dphi,dpp,dppi,dpr,&
                   dyy1,dyy2,ekk,phi,phibf,pie,puf,qu,qv,qw,qwc,qxsa,qxse,r0,r0a,t,xl,xs,zl,zs,quz,qvz
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
#endif
  dimension t(5,4)
  dimension beta(2),alfa(2),phi(2),phibf(2)
  dimension qw(2),qwc(3)
  dimension aa(mmul),bb(mmul),dpr(5)
  dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
!GRD
      qxsa = zero
      qxse = zero
!GRD
      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        qwc(i)=zero
      end do

      qwc(3)=zero

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      pie=two*pi
      ikpv=0
      dpr(1)=dpp*c1e3
      call clorb(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)
#ifdef DEBUG
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aenvarqmod',88,R88
!     call abend('aenvarqmod                                        ')
#endif

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 450 k=1,iu
        ix=ic(k)
        if(ix.gt.nblo) goto 140
        jj=0
        dj=1
        if(ix.gt.0) goto 70
        ix=-ix
        jj=mel(ix)+1
        dj=-1
   70   jm=mel(ix)

!--BLOCKELEMENTLOOP
        do 130 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 100
          if(ithick.eq.0.and.kz(jk).ne.0) goto 450

!--PURE DRIFTLENGTH
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif

            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif

            if(-one*dphi.gt.pieni) dphi=dphi+pi                          !hr06
            phi(l)=phi(l)+dphi/pie
          end do

          goto 130
!--MAGNETELEMENT
  100     continue
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)                                         !hr06
            endif
            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi/pie
          enddo
  130   continue
        goto 450
!--NL-INSERTION
  140   ix=ix-nblo
        qu=zero
        qv=zero
        dyy1=zero
        dyy2=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 450
        kzz=kz(ix)
        kpv=kpa(ix)
        if(kpv.ne.1) goto 150
        qxsa=phi(1)
  150   if(kpv.ne.2.or.ikpv.eq.1) goto 160
        qxse=phi(1)
        ikpv=1
  160   continue
        if(kzz == 22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            end if
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+t(i,ll)*rrtr(imtr(ix),ll-1,ll))+dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+t(i,ll)*rrtr(imtr(ix),ll,ll))+dpr(i)*rrtr(imtr(ix),ll,6)
            end do
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            if(abs(t(ll,ll-1)) > pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            end if
            if(-one*dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi/pie
          end do
        end if
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 450
        if(kzz.eq.15) goto 450
! JBG RF CC Multipoles to 450
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 450
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignl.f90"
#ifdef DEBUG
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('kzz',0d0,kzz,0,0,0)
!     call dumpbin('bkzz      ',77 777)
!     call abend('bkzz                                              ')
#endif
      select case (kzz)
      case (1) ! HORIZONTAL DIPOLE
        ekk=ekk*c1e3
#include "include/kickl01h.f90"
#include "include/kickq01h.f90"
        goto 420
      case (2) ! NORMAL QUADRUPOLE
#include "include/kicklxxh.f90"
#include "include/kickq02h.f90"
        goto 420
      case (3) ! NORMAL SEXTUPOLE
        ekk=ekk*c1m3
#include "include/kickq03h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (4) ! NORMAL OCTUPOLE
        ekk=ekk*c1m6
#include "include/kicksho.f90"
#include "include/kickq04h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (5) ! NORMAL DECAPOLE
        ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq05h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (6) ! NORMAL DODECAPOLE
        ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq06h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (7) ! NORMAL 14-POLE
        ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq07h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (8) ! NORMAL 16-POLE
        ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq08h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (9) ! NORMAL 18-POLE
        ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq09h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (10) ! NORMAL 20-POLE
        ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq10h.f90"
#include "include/kicksho.f90"
#include "include/kicklxxh.f90"
        goto 420
      case (11)
        r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl01.f90"
            do i=2,ium
#include "include/multl02.f90"
            end do
          else
#include "include/multl03.f90"
          end if
        end if
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl04.f90"
            do i=2,ium
#include "include/multl05.f90"
            end do
          else
#include "include/multl06.f90"
          end if
        end if
        if(abs(r0).le.pieni) goto 450
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 450
        end if
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        do l=1,nmz
#include "include/multl07a.f90"
        end do
        if(nmz.ge.2) then
#include "include/multl07b.f90"
          do l=3,nmz
#include "include/multl07c.f90"
          end do
        else
#include "include/multl07d.f90"
        end if
#ifdef TILT
#include "include/multl07e.f90"
#endif
        izu=izu+2*mmul-2*nmz
        goto 420
      case (12,13,14,15,16,17,18,19,20,21,22,23)
        goto 450
      case (24) ! DIPEDGE ELEMENT
#include "include/kickldpe.f90"
#include "include/kickqdpe.f90"
        goto 420
      case (25) ! Solenoid
#include "include/kicklso1.f90"
#include "include/kickqso1.f90"
        goto 420
      case (26,27,28)
        goto 450
        
      !-----------------
      !--SKEW ELEMENTS--
      !------------------
      case (-1)  ! VERTICAL DIPOLE
        ekk=ekk*c1e3
#include "include/kickl01v.f90"
#include "include/kickq01v.f90"
        goto 420
      case (-2)  ! SKEW QUADRUPOLE
#include "include/kicklxxv.f90"
#include "include/kickq02v.f90"
        goto 420
      case (-3)  ! SKEW SEXTUPOLE
        ekk=ekk*c1m3
#include "include/kickq03v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-4)  ! SKEW OCTUPOLE
        ekk=ekk*c1m6
#include "include/kicksho.f90"
#include "include/kickq04v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-5)  ! SKEW DECAPOLE
        ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq05v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-6)  ! SKEW DODECAPOLE
        ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq06v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-7)  ! SKEW 14-POLE
        ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq07v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-8)  ! SKEW 16-POLE
        ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq08v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-9)  ! SKEW 18-POLE
        ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq09v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
        goto 420
      case (-10) ! SKEW 20-POLE
        ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kickq10v.f90"
#include "include/kicksho.f90"
#include "include/kicklxxv.f90"
      case default
        goto 450
      end select
      goto 450
    
  420 continue
      t(1,2)=t(1,2)+dyy1
      t(1,4)=t(1,4)+dyy2
      do i=2,ium
        if(kzz.eq.24) then
          t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
#include "include/phas1so1.f90"
#include "include/phas2so1.f90"
#include "include/phas3so1.f90"
        else
          t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
        end if
      end do
      
      do l=1,2
        ll=2*l
        alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))       !hr06
      end do

  450 continue
      qwc(1)=phi(1)
      qwc(2)=phi(2)
      if(qxse.ge.qxsa) then
        qwc(3)=qxse-qxsa
      else
        qwc(3)=(phi(1)+qxse)-qxsa                                        !hr06
      endif
#ifdef DEBUG
!     call warr('qw',qw(1),1,0,0,0)
!     call warr('qw',qw(2),2,0,0,0)
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call dumpbin('aphasad',97,997)
!     call abend('aphasad                                           ')
#endif
!-----------------------------------------------------------------------
  return
end subroutine phasad

+dk qmod
subroutine qmod0
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES PLUS AN ADDITIONAL ADJUSTMENT OF A
!  X-PHASEADVANCE BETWEEN 2 POSITIONS IN THE MACHINE
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,ierr,ii,iq1,iq2,iq3,iql,j,l,n,nite
      real(kind=fPrec) a11,a12,a13,a21,a22,a23,a31,a32,a33,aa,aa1,bb,   &
     &dpp,dq1,dq2,dq3,qwc,qx,qz,sens,sm0,sqx,sqxh,sqz
      dimension sens(3,5),aa(3,3),bb(3),qx(3),qz(3),sm0(3),qwc(3)
      dimension aa1(2,2)
      save
!-----------------------------------------------------------------------
      do i=1,3
        bb(i)=zero
        qx(i)=zero
        qz(i)=zero
        sm0(i)=zero
        qwc(i)=zero
        do j=1,3
          aa(i,j)=zero
        end do
      end do

      do i=1,3
        do j=1,5
          sens(i,j)=zero
        end do
      end do

      do i=1,2
        do j=1,2
          aa1(i,j)=zero
        end do
      end do

      write(lout,10010)
      sqx=zero
      sqz=zero
      sqxh=zero
      dpp=zero
      iq1=iq(1)
      iq2=iq(2)
      if(kz(iq1).ne.2.or.kz(iq2).ne.2) call prror(8)

      if (abs(el(iq1)).le.pieni.or.abs(el(iq2)).le.pieni) then
        sm0(1)=ed(iq1)
        sm0(2)=ed(iq2)
      else
        sm0(1)=ek(iq1)
        sm0(2)=ek(iq2)
      endif

      if(kp(iq1).eq.5) call combel(iq1)
      if(kp(iq2).eq.5) call combel(iq2)
      sens(1,1)=qw0(1)
      sens(2,1)=qw0(2)

      if(abs(qw0(3)).gt.pieni) then
        iq3=iq(3)
        if(kz(iq3).ne.2) call prror(8)
        if (abs(el(iq3)).le.pieni) then
          sm0(3)=ed(iq3)
        else
          sm0(3)=ek(iq3)
        endif
        if(kp(iq3).eq.5) call combel(iq3)
        nite=3
      else
        nite=2
      endif

      call clorb(dpp)
      if(ierro.gt.0) call prror(9)
      call phasad(dpp,qwc)
      sens(1,5)=qwc(1)
      sens(2,5)=qwc(2)
      if(nite.eq.3) then
        sens(3,1)=qw0(3)
        sens(3,5)=qwc(3)
        write(lout,10100)
        write(lout,10120) qwc,qw0
      else
        write(lout,10110)
        write(lout,10130) qwc(1),qwc(2),qw0(1),qw0(2)
      endif
      do 60 ii=1,itqv
        do 40 n=1,nite
          iql=iq(n)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)+dkq
          else
            ek(iql)=ek(iql)+dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
          call clorb(dpp)
          if(ierro.gt.0) call prror(9)
          call phasad(dpp,qwc)
          sens(1,n+1)=qwc(1)
          sens(2,n+1)=qwc(2)
          if(nite.eq.3) then
            sens(3,n+1)=qwc(3)
            write(lout,10140) ii,n,qwc
          else
            write(lout,10150) ii,n,qwc(1),qwc(2)
          endif
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-dkq
          else
            ek(iql)=ek(iql)-dkq
          endif
          if(kp(iql).eq.5) call combel(iql)
   40   continue
!--Q-VALUE ADJUSTMENT
        aa1(1,1)=(sens(1,2)-sens(1,5))/dkq
        aa1(1,2)=(sens(2,2)-sens(2,5))/dkq
        aa1(2,1)=(sens(1,3)-sens(1,5))/dkq
        aa1(2,2)=(sens(2,3)-sens(2,5))/dkq
        a11=aa1(1,1)
        a12=aa1(1,2)
        a21=aa1(2,1)
        a22=aa1(2,2)
        bb(1)=sens(1,5)-sens(1,1)
        bb(2)=sens(2,5)-sens(2,1)
        sqx=sqx+abs(bb(1))
        sqz=sqz+abs(bb(2))
        if(nite.eq.3) then
          aa(1,1)=a11
          aa(1,2)=a12
          aa(1,3)=(sens(3,2)-sens(3,5))/dkq
          aa(2,1)=a21
          aa(2,2)=a22
          aa(2,3)=(sens(3,3)-sens(3,5))/dkq
          aa(3,1)=(sens(1,4)-sens(1,5))/dkq
          aa(3,2)=(sens(2,4)-sens(2,5))/dkq
          aa(3,3)=(sens(3,4)-sens(3,5))/dkq
          a13=aa(1,3)
          a23=aa(2,3)
          a31=aa(3,1)
          a32=aa(3,2)
          a33=aa(3,3)
          bb(3)=sens(3,5)-sens(3,1)
          sqxh=sqxh+abs(bb(3))
          call loesd(aa,bb,nite,nite,ierr)
        else
          call loesd(aa1,bb,nite,nite,ierr)
        endif
        if(ierr.eq.1) call prror(35)
        do 50 l=1,nite
          iql=iq(l)
          if (abs(el(iql)).le.pieni) then
            ed(iql)=ed(iql)-bb(l)
          else
            ek(iql)=ek(iql)-bb(l)
          endif
          if(kp(iql).eq.5) call combel(iql)
   50   continue
        call clorb(dpp)
        if(ierro.gt.0) call prror(9)
        call phasad(dpp,qwc)
        sens(1,5)=qwc(1)
        sens(2,5)=qwc(2)
        if(nite.eq.3) then
          sens(3,5)=qwc(3)
          write(lout,10020) qw0(1),qwc(1),qw0(2),qwc(2),qw0(3),qwc(3)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10040) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2),sm0(3),ed(iq3),bez(iq3)
          else
            write(lout,10040) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2),sm0(3),ek(iq3),bez(iq3)
          endif
          write(lout,10080) sqx,sqz,sqxh
          write(lout,10060) a11,a12,a13,a21,a22,a23,a31,a32,a33
        else
          write(lout,10030) qw0(1),qwc(1),qw0(2),qwc(2)
          if (abs(el(iq1)).le.pieni) then
            write(lout,10050) sm0(1),ed(iq1),bez(iq1),sm0(2),ed(iq2),bez&
     &(iq2)
          else
            write(lout,10050) sm0(1),ek(iq1),bez(iq1),sm0(2),ek(iq2),bez&
     &(iq2)
          endif
          write(lout,10090) sqx,sqz
          write(lout,10070) a11,a12,a21,a22
        endif
        if (abs(el(iq(1))).le.pieni) then
          sm0(1)=ed(iq(1))
          sm0(2)=ed(iq(2))
        else
          sm0(1)=ek(iq(1))
          sm0(2)=ek(iq(2))
        endif
        dq1=abs(qwc(1)-qw0(1))
        dq2=abs(qwc(2)-qw0(2))
        if(nite.eq.3) then
          if (abs(el(iq(3))).le.pieni) then
            sm0(3)=ed(iq(3))
          else
            sm0(3)=ek(iq(3))
          endif
          dq3=abs(qwc(3)-qw0(3))
          if(dq1.lt.dqq.and.dq2.lt.dqq.and.dq3.lt.dqq) return
        else
          if(dq1.lt.dqq.and.dq2.lt.dqq) return
        endif
   60 continue
      write(lout,10000) itqv
!-----------------------------------------------------------------------
      return
10000 format(t5/t10,'TUNE ADJUSTMENT'/ t10,                             &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10010 format(/131('-'))
10020 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.     AFTER CORRECTION'/ t10,       &
     &'HORIZONTAL'     ,17x,g17.10,2x,g17.10/ t10,                      &
     &'VERTICAL'       ,19x,g17.10,2x,g17.10/ t10,                      &
     &'PART-HORIZONTAL',12x,g17.10,2x,g17.10/)
10030 format(//131('-')//t10,'DATA BLOCK TUNE-VARIATION' / /t10,        &
     &'TUNE'           ,26x,'THEORET.      AFTER CORRECTION'/ t10,      &
     &'HORIZONTAL'     ,17x,g17.10,2x,g17.10/ t10,                      &
     &'VERTICAL'       ,19x,g17.10,2x,g17.10/)
10060 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY',14x,   &
     &'D-QXH'/29x,'QF   ',d15.8,3x,d15.8,3x,d15.8/29x,                  &
     &'QD   ',d15.8,3x,d15.8,3x,d15.8/29x,                              &
     &'QF2  ',d15.8,3x,d15.8,3x,d15.8//131('-')//)
10070 format(t10,'QUADRUPOLE SENSITIVITIES',6x,'D-QX',14x,'D-QY', /29x, &
     &'QF   ',d15.8,3x,d15.8/29x,'QD   ',d15.8,3x,d15.8 //131('-')//)
10080 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7,  &
     &'   QXH =',f10.7)
10090 format(t10,'TOTAL TUNE SHIFT',10x,'QX =',f10.7,'    QY =',f10.7)
10100 format(t5,'---- QMOD FOR SPLIT-Q-VALUES ENTRY ---- ',             &
     &'(ZERO MOMENTUM-DEVIATION)')
10110 format(t5,'---- QMOD ENTRY ---- (ZERO MOMENTUM-DEVIATION)')
10120 format(t10,'START-QX-QY-QXH',3f12.7,' END-QX-QY-QXH',3f12.7)
10130 format(t10,'START-QX-QY',2f12.7,' END-QX-QY',2f12.7)
10140 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY-QXH',3f12.7)
10150 format(t10,'ITER=',i3,'/QUAD=',i3,'/QX-QY',2f12.7)
10040 format(t10,'QUADRU.STRENGTHS',7x,g17.10,2x,g17.10,'   TYP     ',  &
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
10050 format(t10,'QUADRU.STRENGTHS',7x,g17.10,2x,g17.10,'   TYP     ',  &
     &a16/t10,                  23x,g17.10,2x,g17.10,'           ',     &
     &a16)
end subroutine qmod0

      subroutine qmodda(mm,qwc)
!-----------------------------------------------------------------------
!  ADJUSTMENT OF THE Q-VALUES VIA DA
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      use mod_commond
      implicit none
      integer i,intwq,ix,mm,ncorr,ncorruo,ncrr,nd,nd2,ndh
      real(kind=fPrec) cor,coro,dq1,dq2,dps0,edcor1,edcor2,qwc
      dimension intwq(3),qwc(3)
      save
!-----------------------------------------------------------------------
#ifdef DEBUG
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
#endif
      ncorruo=ncorru
      ncorru=1
      nd2=2*mm
      ndh=nd2+2
      intwq(1)=int(qwc(1))
      intwq(2)=int(qwc(2))
      intwq(3)=0
#ifdef DEBUG
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!sqmodda
!     write(*,*) 'qmodda called!'
!     call dumpbin('sqmodda',80,800)
!     call abend('sqmodda                                           ')
!     write(*,*) 'mm=',mm
#endif
      dq1=zero
      dq2=zero
      if(iqmod6.eq.1) then
        if(el(iq(1)).le.pieni) then
          edcor(1)=ed(iq(1))
        else
          edcor(1)=ek(iq(1))
        endif
        if(el(iq(2)).le.pieni) then
          edcor(2)=ed(iq(2))
        else
          edcor(2)=ek(iq(2))
        endif
        edcor1=edcor(1)
        edcor2=edcor(2)
#ifdef DEBUG
!       call warr('edcor1',edcor1,1,0,0,0)
!       call warr('edcor2',edcor2,2,0,0,0)
#endif
        cor=zero
        coro=1.0e38_fPrec
      endif
      do ncorr=1,itqv+1
        if(nbeam.ge.1) then
          nd=mm
#include "include/beamcou.f90"
        endif
        if(iqmod6.eq.1) write(lout,10080) nd2
        if(iqmod6.ne.1) write(lout,10090) nd2
        if(mm.eq.2) then
          write(lout,10010) clo(1),clop(1)
          write(lout,10010) clo(2),clop(2)
        elseif(mm.eq.3) then
          write(lout,10010) clo6(1),clop6(1)
          write(lout,10010) clo6(2),clop6(2)
          write(lout,10010) clo6(3),clop6(3)
        endif
        iqmodc=2
#ifdef DEBUG
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('bdaini',96,996)
!     call abend('before daini                                      ')
#endif
        call mydaini(1,1,nd2,mm,nd2,1)
#ifdef DEBUG
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call warr('clo6(1)',clo6(1),1,0,0,0)
!     call warr('clo6(2)',clo6(2),2,0,0,0)
!     call warr('clo6(3)',clo6(3),3,0,0,0)
!     call warr('clop6(1)',clop6(1),1,0,0,0)
!     call warr('clop6(2)',clop6(2),2,0,0,0)
!     call warr('clop6(3)',clop6(3),3,0,0,0)
!     call dumpbin('adaini',96,996)
!     call abend('after  daini                                      ')
#endif
        if(iqmod6.eq.1) then
          write(lout,10000) nd2
          iqmodc=1
          call mydaini(2,3,ndh,mm,nd2,1)
#ifdef DEBUG
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',99,999)
!     call abend('after  daini                                      ')
#endif
          do i=1,mm
            qwc(i)=real(intwq(i),fPrec)+corr(1,i)                              !hr06
          enddo
          dq1=qwc(1)-qw0(1)
          dq2=qwc(2)-qw0(2)
          if(ncorr.eq.1) cor=sqrt(dq1**2+dq2**2)                         !hr06
          if(abs(dq1).gt.dqq.or.abs(dq2).gt.dqq) then
            cor=sqrt(dq1**2+dq2**2)                                      !hr06
            if(ncorr.eq.1.or.cor.lt.coro) then
              coro=cor
              if(el(iq(1)).le.pieni) then
                ed(iq(1))=(ed(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              else
                ek(iq(1))=(ek(iq(1))-corr(2,1)*dq1)-corr(2,2)*dq2        !hr06
              endif
              if(el(iq(2)).le.pieni) then
                ed(iq(2))=(ed(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              else
                ek(iq(2))=(ek(iq(2))-corr(3,1)*dq1)-corr(3,2)*dq2        !hr06
              endif
              do ncrr=1,iu
                ix=ic(ncrr)
                if(ix.gt.nblo) then
                  ix=ix-nblo
                  if(ix.eq.iq(1).or.iratioe(ix).eq.iq(1)) then
                    smi(ncrr)=ed(iq(1))*ratioe(ix)+smizf(ncrr)
                  else if(ix.eq.iq(2).or.iratioe(ix).eq.iq(2)) then
                    smi(ncrr)=ed(iq(2))*ratioe(ix)+smizf(ncrr)
                  endif
                endif
              enddo
              if(el(iq(1)).le.pieni) then
                edcor(1)=ed(iq(1))
              else
                edcor(1)=ek(iq(1))
              endif
              if(el(iq(2)).le.pieni) then
                edcor(2)=ed(iq(2))
              else
                edcor(2)=ek(iq(2))
              endif
              if(ncorr.eq.1) then
                write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              else
                write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),      &
     &ncorr-1,                                                          &
     &cor
              endif
              if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
                write(lout,10040) edcor1,ed(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ed(iq(2)),bez(iq(2))
              else
                write(lout,10040) edcor1,ek(iq(1)),bez(iq(1)),edcor2,   &
     &ek(iq(2)),bez(iq(2))
              endif
            else
              write(lout,10050) nd2,ncorr-1
              goto 1
            endif
          else
            write(lout,10060) nd2,ncorr-1
            goto 1
          endif
        else
          iqmodc=3
          call mydaini(2,2,nd2,mm,nd2,1)
          do i=1,mm
            qwc(i)=real(intwq(i),fPrec)+wxys(i)                                !hr06
          enddo
#ifdef DEBUG
!     call warr('qwc',qwc(1),1,0,0,0)
!     call warr('qwc',qwc(2),2,0,0,0)
!     call warr('qwc',qwc(3),3,0,0,0)
!     call warr('intwq',0d0,intwq(1),1,0,0)
!     call warr('intwq',0d0,intwq(2),2,0,0)
!     call warr('intwq',0d0,intwq(3),3,0,0)
!     call dumpbin('adaini',98,998)
!     call abend('after  daini 98                                   ')
#endif
          goto 1
        endif
      enddo
 1    continue
      if(iqmod6.eq.1) then
        do ncrr=1,iu
          ix=ic(ncrr)
          if(ix.le.nblo) then
            if(iratioe(ix).eq.iq(1)) ek(ix)=ek(iq(1))*ratioe(ix)
            if(iratioe(ix).eq.iq(2)) ek(ix)=ek(iq(2))*ratioe(ix)
          endif
        enddo
        iqmodc=3
        call mydaini(2,2,nd2,mm,nd2,1)
        do i=1,mm
          qwc(i)=real(intwq(i),fPrec)+wxys(i)                                  !hr06
        enddo
        if(ncorr.eq.itqv+1) write(lout,10070) nd2,itqv
        if(ncorr.eq.1) then
          write(lout,10020) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        else
          write(lout,10030) nd2,qw0(1),qwc(1),qw0(2),qwc(2),ncorr-1,cor
        endif
        if(el(iq(1)).le.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).le.pieni.and.el(iq(2)).gt.pieni) then
          write(lout,10040)edcor1,ed(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        elseif(el(iq(1)).gt.pieni.and.el(iq(2)).le.pieni) then
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ed(iq(2)),&
     &bez(iq(2))
        else
          write(lout,10040)edcor1,ek(iq(1)),bez(iq(1)),edcor2,ek(iq(2)),&
     &bez(iq(2))
        endif
      endif
      ncorru=ncorruo
#ifdef DEBUG
!     call dumpbin('end qmodda',7,999)
!     call abend('end qmodda 7 999                                  ')
#endif
!-----------------------------------------------------------------------
10000 format(/131('-')/t10,'ENTERING ',i1,'D DA TUNE-VARIATION')
10010 format(1x,f47.33/1x,f47.33)
10020 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       BEFORE CORRECTION'/ t10,    &
     &'HORIZONTAL'     ,15x,G21.14,G21.14/ t10,                         &
     &'VERTICAL'       ,17x,G21.14,G21.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10030 format(/131('-')/t10,i1,'D DA TUNE-VARIATION'/t10,                &
     &'TUNE'           ,26x,'THEORET.       AFTER CORRECTION'/ t10,     &
     &'HORIZONTAL'     ,15x,G21.14,G21.14/ t10,                         &
     &'VERTICAL'       ,17x,G21.14,G21.14// t10,                        &
     &'ITERATION:'     ,21x,i3/ t10,                                    &
     &'ACCURACY:'      ,17x,g17.10/)
10040 format(t10,'QUADRUPOLE STRENGTH',6x,g17.10,4x,g17.10,'   TYP     '&
     &,a16/t10,                  25x,g17.10,4x,g17.10,'           ',    &
     &a16)
10050 format(/t5,'---- NO IMPROVEMENT OF ',i1,'D DA TUNE-VARIATION ',   &
     &'IN ITERATION: ',i4/)
10060 format(/t10,i1,'D DA TUNE-VARIATION SUCCESSFUL IN ITERATION: ',   &
     &i4/)
10070 format(/t10,i1,'D DA TUNE-VARIATION'/ t10,                        &
     &'MAXIMUM NUMBER OF ITERATIONS ACHIEVED--->',2x,i4/ t10,           &
     &'PROCEDURE MAY NOT HAVE CONVERGED')
10080 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA')
10090 format(/t10,'Initial ',i1,'-D DA CLOSED ORBIT IN QMODDA (NO ',    &
     &'TUNE ADJUSTEMENT)')
      end

+dk umlauf
!-----------------------------------------------------------------------
!     ONE TURN-TRANSFORMATION (INCLUDING QUADRUPOLE CONTRIBUTIONS)
!-----------------------------------------------------------------------
subroutine umlauf(dpp,ium,ierr)
  ! Rewritten to remove computed gotos by V.K.B.Olsen on 23/11/2017
  use floatPrecision
  use end_sixtrack
  use mathlib_bouncer
  use numerical_constants
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  integer i,ierr,im,ium,ix,izu,j,k,kpz,kx,kzz,l,ll,l1,nmz
  real(kind=fPrec) aa,bb,benkr,ci,cikve,cr,crkve,crkveuk,dpp,dpr,dyy1,dyy2,ekk,puf,qu,qv,quz,qvz,r0,r0a,xl,xs,zl,zs
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltsk
#endif
  dimension aa(mmul),bb(mmul),dpr(5)
  dimension cr(mmul),ci(mmul)
  save
  
  do i=1,mmul
    aa(i)=zero
    bb(i)=zero
    cr(i)=zero
    ci(i)=zero
  end do
  do i=1,5
    dpr(i)=zero
  end do
  ierr=0
  dpr(1)=dpp*c1e3
  izu=0
  do 350 k=1,iu
    ix=ic(k)
    if(ix.gt.nblo) goto 60
    if(ix.le.0) goto 40
    
    do j=1,ium
      do kx=1,2
        if(ithick.eq.1) then
          puf=x(j,kx)
          x(j,kx)=(bl1(ix,kx,1)*puf+bl1(ix,kx,2)*y(j,kx))+dpr(j)*bl1(ix,kx,5) !hr06
          y(j,kx)=(bl1(ix,kx,3)*puf+bl1(ix,kx,4)*y(j,kx))+dpr(j)*bl1(ix,kx,6) !hr06
        else
          x(j,kx)=x(j,kx)+bl1(ix,kx,2)*y(j,kx)
        end if
      end do
    end do
    goto 350

40  ix=-ix
    do j=1,ium
      do kx=1,2
        if(ithick.eq.1) then
          puf=x(j,kx)
          x(j,kx)=(bl2(ix,kx,1)*puf+bl2(ix,kx,2)*y(j,kx))+dpr(j)*bl2(ix,kx,5) !hr06
          y(j,kx)=(bl2(ix,kx,3)*puf+bl2(ix,kx,4)*y(j,kx))+dpr(j)*bl2(ix,kx,6) !hr06
        else
          x(j,kx)=x(j,kx)+bl2(ix,kx,2)*y(j,kx)
        end if
      end do
    end do
    
    goto 350

60  ix=ix-nblo
    qu=zero
    qv=zero
    dyy1=zero
    dyy2=zero
    kpz=kp(ix)
    if(kpz.eq.6) goto 350
    kzz=kz(ix)
    if(abs(x(1,1)).lt.aper(1).and.abs(x(1,2)).lt.aper(2)) goto 70
    ierr=1
    call prror(101)
    return

70  continue
    if(kzz.eq.22) then
      do j=1,ium
        do kx=1,2
          ll=kx*2
          puf=x(j,kx)
          x(j,kx)=((cotr(imtr(ix),ll-1)+rrtr(imtr(ix),ll-1,ll-1)*puf)+rrtr(imtr(ix),ll-1,ll)*y(j,kx))+dpr(j)*rrtr(imtr(ix),ll-1,6)
          y(j,kx)=((cotr(imtr(ix),ll)+rrtr(imtr(ix),ll,ll-1)*puf)+rrtr(imtr(ix),ll,ll)*y(j,kx))+dpr(j)*rrtr(imtr(ix),ll,6)
        end do
      end do
    end if
    if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 350
    if(kzz.eq.15) goto 350
! JBG RF CC Multipoles to 350
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) write(*,*)'out'
!        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 350
    if(iorg.lt.0) mzu(k)=izu
    izu=mzu(k)+1
    ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
    izu=izu+1
    xs=xpl(ix)+zfz(izu)*xrms(ix)
    izu=izu+1
    zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignu.f90"

    select case (kzz)
    case (1) ! HORIZONTAL DIPOLE
      ekk=ekk*c1e3
#include "include/kicku01h.f90"
      goto 350
    case (2) ! NORMAL QUADRUPOLE
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
#include "include/kickq02h.f90"
      goto 330
    case (3) ! NORMAL SEXTUPOLE
      ekk=ekk*c1m3
      if(ium.ne.1) then
#include "include/kickq03h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (4) ! NORMAL OCTUPOLE
      ekk=ekk*c1m6
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq04h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (5) ! NORMAL DECAPOLE
      ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq05h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (6) ! NORMAL DODECAPOLE
      ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq06h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (7) ! NORMAL 14-POLE
      ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq07h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (8) ! NORMAL 16-POLE
      ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq08h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (9) ! NORMAL 18-POLE
      ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq09h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (10) ! NORMAL 20-POLE
      ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq10h.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxh.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (11)
      r0=ek(ix)
      if(abs(dki(ix,1)).gt.pieni) then
        if(abs(dki(ix,3)).gt.pieni) then
#include "include/multu01.f90"
          do j=2,ium
#include "include/multu02.f90"
          end do
        else
#include "include/multu03.f90"
        end if
      end if
      if(abs(dki(ix,2)).gt.pieni) then
        if(abs(dki(ix,3)).gt.pieni) then
#include "include/multu04.f90"
          do j=2,ium
#include "include/multu05.f90"
          end do
        else
#include "include/multu06.f90"
        end if
      end if
      if(abs(r0).le.pieni) goto 350
      nmz=nmu(ix)
      if(nmz.eq.0) then
        izu=izu+2*mmul
        goto 350
      end if
      im=irm(ix)
      r0a=one
      benkr=ed(ix)/(one+dpp)
      do l=1,nmz
#include "include/multl07a.f90"
      end do
      if(nmz.ge.2) then
#include "include/multl07b.f90"
        do l=3,nmz
#include "include/multl07c.f90"
        end do
      else
#include "include/multl07d.f90"
      end if
#ifdef TILT
#include "include/multl07e.f90"
#endif
      izu=izu+2*mmul-2*nmz
      y(1,1)=y(1,1)+dyy1
      y(1,2)=y(1,2)+dyy2
      if(ium.eq.1) goto 350
      goto 330
    case (12,13,14,15,16,17,18,19,20,21,22,23)
      goto 350
    case (24) ! DIPEDGE ELEMENT
#include "include/kickudpe.f90"
      if(ium.eq.1) goto 350
#include "include/kickqdpe.f90"
      goto 330
    case (25) ! Solenoid
#include "include/kickuso1.f90"
      if(ium.eq.1) goto 350
#include "include/kickqso1.f90"
      goto 330
    case (26,27,28)
      goto 350
    
    !-----------------
    !--SKEW ELEMENTS--
    !------------------
    case (-1) ! VERTICAL DIPOLE
      ekk=ekk*c1e3
#include "include/kicku01v.f90"
      goto 350
    case (-2) ! SKEW QUADRUPOLE
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
#include "include/kickq02v.f90"
      goto 330
    case (-3) ! SKEW SEXTUPOLE
      ekk=ekk*c1m3
      if(ium.ne.1) then
#include "include/kickq03v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-4) ! SKEW OCTUPOLE
      ekk=ekk*c1m6
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq04v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-5) ! SKEW DECAPOLE
      ekk=ekk*c1m9
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq05v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-6) ! SKEW DODECAPOLE
      ekk=ekk*c1m12
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq06v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-7) ! SKEW 14-POLE
      ekk=ekk*c1m15
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq07v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-8) ! SKEW 16-POLE
      ekk=ekk*c1m18
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq08v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-9) ! SKEW 18-POLE
      ekk=ekk*c1m21
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq09v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      goto 330
    case (-10) ! SKEW 20-POLE
      ekk=ekk*c1m24
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
#include "include/kicksho.f90"
      if(ium.ne.1) then
#include "include/kickq10v.f90"
      end if
#include "include/kicksho.f90"
#include "include/kickuxxv.f90"
      if(ium.eq.1) goto 350
      
    case default
      goto 350
    end select
    goto 350
330 continue
    do j=2,ium
      if(kzz.eq.24) then
        y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
        y(j,2)=(y(j,2)-x(j,2)*quz)-qvz*x(j,1)                        !hr06
      elseif(kzz.eq.25) then
        crkve=y(j,1)-(x(j,1)*qu)*qv                                  !hr06
        cikve=y(j,2)-(x(j,2)*qu)*qv                                  !hr06
        y(j,1)=crkve*cos_mb(qv)+cikve*sin_mb(qv)                     !hr09
        y(j,2)=cikve*cos_mb(qv)-crkve*sin_mb(qv)                     !hr09
        crkve=x(j,1)*cos_mb(qv)+x(j,2)*sin_mb(qv)                    !hr09
        cikve=x(j,2)*cos_mb(qv)-x(j,1)*sin_mb(qv)                    !hr09
        x(j,1)=crkve 
        x(j,2)=cikve 
      else
        y(j,1)=(y(j,1)+x(j,1)*qu)-qv*x(j,2)                          !hr06
        y(j,2)=(y(j,2)-x(j,2)*qu)-qv*x(j,1)                          !hr06
      endif
    end do
350 continue

  return
  
end subroutine umlauf

+dk resex
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR RMOD
!-----------------------------------------------------------------------
subroutine resex(dpp)
  ! Modified for Fortran 2015 by V.K.B. Olsen on 19/11/2017
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  integer i,i1,i2,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jl,jm,k,k1,kpz,kzz,l,l1,l2,ll,lmin,m2,m4,m6,min,&
          mm,mpe,mx,n,n2,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
  real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,chy,ci,cikve,cr,crkve,cxzi,cxzr,&
          cxzyi,cxzyr,cxzyrr,del,dphi,dpp,dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,&
          phy,pie,puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,vdt1,vdt2,vdt3,xl,&
          xs,zl,zs,quz,qvz
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,tiltck5,tiltckuk,tiltsk,&
          tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
#endif
  dimension t(5,4)
  dimension beta(2),alfa(2),phi(2),phibf(2)
  dimension qw(2)
  dimension aa(mmul),bb(mmul),dpr(5)
  dimension nnf(10),ep(2)
  dimension ab1(10),ab2(10),re(10,18),ip(10,18)
  dimension b(10,10),nz2(9),e(10,10)
  dimension chy(9,18),shy(9,18),min(5)
  dimension cr(mmul),ci(mmul)
      save
      
      ium=5
      do i=1,ium
        dpr(i)=zero
      end do

      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
      end do

      do i=1,10
        nnf(i)=0
        do j=1,18
          ip(i,j)=0
          re(i,j)=zero
        end do
      end do

      do i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
      end do

      do i=1,9
        nz2(i)=0
        do j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do k=1,10
            do ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
            end do
            do l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
              min(l)=0
            end do
          end do
        end do
      end do
      
      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3

      call clorb(dpp)
      call betalf(dpp,qw)

      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
         t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
         end do
      end do

!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 770 k=1,iu

        do k1=1,10
          ab1(k1)=zero
          ab2(k1)=zero
        end do

        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 770
!--PURE DRIFTLENGTH
          etl=etl+el(jk)

          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif
            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif
            if(-one*dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          end do

          goto 200
!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            endif
            if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 770
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 770
        kzz=kz(ix)
        if(kzz == 22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            end if
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+t(i,ll)*rrtr(imtr(ix),ll-1,ll))+dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+t(i,ll)*rrtr(imtr(ix),ll,ll))+dpr(i)*rrtr(imtr(ix),ll,6)
            end do
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            if(abs(t(ll,ll-1)) > pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            end if
            if(-one*dphi.gt.pieni) dphi=dphi+pi
                        phi(l)=phi(l)+dphi
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 770
        if(kzz.eq.15) goto 770
! JBG RF CC Multipoles to 770
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 770
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 770
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignl.f90"
        
        select case (kzz)
        case (1)  ! HORIZONTAL DIPOLE
          ekk=ekk*c1e3
#include "include/kicka01h.f90"
        case (2)  ! NORMAL QUADRUPOLE
#include "include/kicka02h.f90"
        case (3)  ! NORMAL SEXTUPOLE
          ekk=ekk*c1m3
#include "include/kicka03h.f90"
        case (4)  ! NORMAL OCTUPOLE
          ekk=ekk*c1m6
#include "include/kicka04h.f90"
        case (5)  ! NORMAL DECAPOLE
          ekk=ekk*c1m9
#include "include/kicka05h.f90"
        case (6)  ! NORMAL DODECAPOLE
          ekk=ekk*c1m12
#include "include/kicka06h.f90"
        case (7)  ! NORMAL 14-POLE
          ekk=ekk*c1m15
#include "include/kicka07h.f90"
        case (8)  ! NORMAL 16-POLE
          ekk=ekk*c1m18
#include "include/kicka08h.f90"
        case (9)  ! NORMAL 18-POLE
          ekk=ekk*c1m21
#include "include/kicka09h.f90"
        case (10) ! NORMAL 20-POLE
          ekk=ekk*c1m24
#include "include/kicka10h.f90"
        case (11)
          r0 = ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl01.f90"
              do i=2,ium
#include "include/multl02.f90"
              end do
            else
#include "include/multl03.f90"
            end if
          end if
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl04.f90"
              do i=2,ium
#include "include/multl05.f90"
              end do
            else
#include "include/multl06.f90"
            end if
          end if
          mpe = 9
          mx  = 0
          if(abs(r0).le.pieni) goto 770
          nmz = nmu(ix)
          if(nmz.eq.0) then
            izu = izu+2*mmul
            goto 770
          end if
          im    = irm(ix)
          r0a   = one
          benkr = ed(ix)/(one+dpp)
          cr(1) = one
          cr(2) = xl
          ci(2) = zl
          cxzyr = xl
          cxzyi = zl
          cxzr  = cxzyr
          cxzi  = cxzyi
          dyy1  = zero
          dyy2  = zero
          qu    = zero
          qv    = zero
          lmin  = 3
          if(nmz.eq.1) lmin=2
          do l=lmin,mmul
            cr(l)=zero
            ci(l)=zero
          end do
          do l=1,nmz
#include "include/multl13.f90"
          end do
#ifdef TILT
#include "include/multl07e.f90"
#endif
          izu = izu+2*mmul-2*nmz
          goto 480
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 480
        case (24) ! DIPEDGE ELEMENT
#include "include/kickadpe.f90"
        case (25) ! Solenoid
#include "include/kickaso1.f90"
        case (26,27,28)
          goto 480
        
        !-----------------
        !--SKEW ELEMENTS--
        !-----------------
        case (-1)  ! VERTICAL DIPOLE
          ekk=ekk*c1e3
#include "include/kicka01v.f90"
        case (-2)  ! SKEW QUADRUPOLE
#include "include/kicka02v.f90"
        case (-3)  ! SKEW SEXTUPOLE
          ekk=ekk*c1m3
#include "include/kicka03v.f90"
        case (-4)  ! SKEW OCTUPOLE
          ekk=ekk*c1m6
#include "include/kicka04v.f90"
        case (-5)  ! SKEW DECAPOLE
          ekk=ekk*c1m9
#include "include/kicka05v.f90"
        case (-6)  ! SKEW DODECAPOLE
          ekk=ekk*c1m12
#include "include/kicka06v.f90"
        case (-7)  ! SKEW 14-POLE
          ekk=ekk*c1m15
#include "include/kicka07v.f90"
        case (-8)  ! SKEW 16-POLE
          ekk=ekk*c1m18
#include "include/kicka08v.f90"
        case (-9)  ! SKEW 18-POLE
          ekk=ekk*c1m21
#include "include/kicka09v.f90"
        case (-10) ! SKEW 20-POLE
          ekk=ekk*c1m24
#include "include/kicka10v.f90"
        end select
        goto 770
  480   continue
        t(1,2)=t(1,2)+dyy1
        t(1,4)=t(1,4)+dyy2
        do 490 i=2,ium
          if(kzz.eq.24) then
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
#include "include/phas1so1.f90"
#include "include/phas2so1.f90"
#include "include/phas3so1.f90"
          else
            t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
            t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
          endif
  490   continue
        do l=1,2
          ll=2*l
          alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
        end do
        if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 770
        if(mpe.lt.nta) goto 770
        if(mpe.gt.nte) mpe=nte
        if(nta.gt.2) goto 520
        if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 520

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do l=2,nmz
          l1=l-1
          ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
        end do

  520   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 540
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 670
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 540

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  540   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 560
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 670
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 560

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  560   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 580
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 670
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  580   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 600
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 670
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  600   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 620
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 670
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 620

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  620   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 640
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 670
        if(mx.eq.6.or.mx.eq.7) goto 640
!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  640   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 670
        if(mx.eq.7) goto 660
!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  660   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  670   do 700 np=1,mpe
          n2e=2*np
          do 690 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                   !hr06
            ipt=0

            do ii=1,nre
              if(n2.eq.nrr(ii)) ipt=ipr(ii)
            end do

            ip(np,nv)=int(re1+half)+ipt
            if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-real(ip(np,nv),fPrec)                          !hr06
            res=re(np,nv)/radi
           chy(np,nv)=cos_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*phi(2))-res*etl) !hr06
           shy(np,nv)=sin_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*phi(2))-res*etl) !hr06
  690     continue
  700   continue
        do 760 np=nta,mpe
          np2=np
          nkk=0
  710     nkk=nkk+1
          n2e=2*np2
          do 750 i=1,nkk
            do 740 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=real(nn2,fPrec)*half                                    !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 720
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 730
  720         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  730         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  740       continue
  750     continue
          np2=np2-2
          if(np2.ge.1) goto 710
  760   continue
  770 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 810 np=nta,nte
        vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)                            !hr06
        np2=np
        nkk=0
  780   nkk=nkk+1
        n2e=2*np2
        do 800 i=1,nkk
          do 790 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
      vdt2=(vdt1*e(nv1,nv2))/real(((nnf(nf1)*nnf(i))*nnf(nf3))*nnf(nf4),fPrec) !hr06
            vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                         !hr06
            if(n2.ge.0) vdt3=real(n2*nv21,fPrec)*ea+real(nn1*nv11,fPrec)*eb    !hr06
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  790     continue
  800   continue
        np2=np2-2
        if(np2.ge.1) goto 780
  810 continue
      if(nur.eq.0) goto 840

      do 830 j=1,nur
        jk=j*2
        do i=1,nur
          jl=nu(i)-npp-jk
          if(jl.eq.0) min(j)=1
          if(jl.eq.0) goto 830
        end do
  830 continue

  840 m2=npp+2
      m4=npp+4
      m6=npp+6
      do 850 i=1,nre
        i2=2*i
        i1=i2-1
        n=nrr(i)+npp
        dtr(i1)=rtc(npp,n,npp,1)+(min(1)*(rtc(npp,n,m2,2)-              &!hr06
     &rtc(npp,n,m2,1))+min(2)*((rtc(npp,n,m4,1)-rtc(npp,n,m4,2))+rtc    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rtc(npp,n,m6,2)-rtc(npp,n,m6,1))-rtc     &!hr06
     &(npp,n,m6,3))+ rtc(npp,n,m6,4))                                    !hr06
        dtr(i2)=rts(npp,n,npp,1)+(min(1)*(rts(npp,n,m2,2)-              &!hr06
     &rts(npp,n,m2,1))+min(2)*((rts(npp,n,m4,1)-rts(npp,n,m4,2))+rts    &!hr06
     &(npp,n,m4,3)))+min(3)*(((rts(npp,n,m6,2)-rts(npp,n,m6,1))-rts     &!hr06
     &(npp,n,m6,3))+rts(npp,n,m6,4))                                     !hr06
  850 continue
  return
end subroutine resex

+dk rmod
subroutine rmod(dppr)
!-----------------------------------------------------------------------
!  CALCULATION OF THE STRENGTH OF CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  integer i,i1,i2,ierr,irr,j,j1,j2,j3,j4,jj1,jj2,jjr,k,n,no,ntao,nteo
  real(kind=fPrec) aa,bb,d1,de2,dpp,dppr,dsm,ox,oz,qwc,se11,se12,se2,sen,sen15,sen16,sen17,sen18,sn,ss
      dimension aa(10,10),bb(10),dsm(10),sn(10),sen(10),ss(10)
      dimension qwc(3),d1(10),irr(12)
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=npp
      nte=npp
      dpp=dppr

      do i=1,10
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero

        do j=1,10
          aa(i,j)=zero
        end do
      end do

      do i=1,12
        irr(i)=0
      end do

      do i=1,3
        qwc(i)=zero
      end do

      k=1
      jj1=0
      jj2=0
      jjr=2*nre
      de2=de0*half
      if(nre.eq.0) goto 50
      write(lout,10000)
      write(lout,10010) npp,totl,qxt,qzt,tam1
      call resex(dpp)
      do 40 i=1,nre
        i2=2*i
        i1=i2-1
        irr(i1)=ire(i1)
        irr(i2)=ire(i2)
        sn(i1)=ed(irr(i1))
        sn(i2)=ed(irr(i2))
        dsm(i1)=dsm0
        dsm(i2)=dsm0
        write(lout,10020) i,nrr(i),ipr(i)
        sen(i1)=dtr(i1)
        bb(i1)=sen(i1)
        sen(i2)=dtr(i2)
        bb(i2)=sen(i2)
        ss(i1)=sen(i1)
        ss(i2)=sen(i2)
   40 continue
      j2=jjr
   50 if(nur.eq.0) goto 70
      write(lout,10030) nur
      do 60 i=1,nur
        write(lout,10040) nu(i),i
   60 continue
   70 if(nch.eq.0) goto 90
      write(lout,10050)
      j1=j2+1
      j2=j2+2
      irr(j1)=ire(7)
      irr(j2)=ire(8)
      sn(j1)=ed(irr(j1))
      sn(j2)=ed(irr(j2))
      dsm(j1)=dsm0
      dsm(j2)=dsm0
      se2=zero
      se11=zero
      se12=zero
      do 80 n=1,5
        dpp=de2*real(3-n,fPrec)                                                !hr06
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ox=qwc(1)
        oz=qwc(2)
        se2=se2+dpp*dpp
        se11=se11+ox*dpp
        se12=se12+oz*dpp
   80 continue
      sen(j1)=se11/se2
      sen(j2)=se12/se2
      bb(j1)=sen(j1)
      bb(j2)=sen(j2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
   90 if(nqc.eq.0) goto 100
      write(lout,10060)
      j1=j2+1
      j2=j2+2
      jj1=j1
      jj2=j2
      irr(j1)=ire(9)
      irr(j2)=ire(10)
      if (abs(el(irr(j1))).le.pieni.or.abs(el(irr(j2))).le.pieni) then
        sn(j1)=ed(irr(j1))
        sn(j2)=ed(irr(j2))
      else
        sn(j1)=ek(irr(j1))
        sn(j2)=ek(irr(j2))
      endif
      dsm(j1)=dkq
      dsm(j2)=dkq
      dpp=zero
      call clorb2(dpp)
      call phasad(dpp,qwc)
      sen(j1)=qwc(1)
      sen(j2)=qwc(2)
      bb(j1)=sen(j1)-qw0(1)
      bb(j2)=sen(j2)-qw0(2)
      ss(j1)=sen(j1)
      ss(j2)=sen(j2)
  100 do 330 no=1,itcro
        do 160 i=1,j2
          if(i.ne.jj1.and.i.ne.jj2) ed(irr(i))=ed(irr(i))+dsm(i)
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))+dsm(i)
            else
              ek(irr(i))=ek(irr(i))+dsm(i)
            endif
          endif
          if(kp(irr(i)).eq.5) call combel(irr(i))
          if(nre.eq.0) goto 120
          call resex(dpp)
          do 110 j=1,jjr
            aa(i,j)=(dtr(j)-ss(j))/dsm(i)
  110     continue
  120     if(nch.eq.0) goto 140
          j3=jjr+1
          j4=jjr+2
          se2=zero
          se11=zero
          se12=zero
          do 130 n=1,5
            dpp=de2*real(3-n,fPrec)                                            !hr06
            call clorb2(dpp)
            call phasad(dpp,qwc)
            ox=qwc(1)
            oz=qwc(2)
            se2=se2+dpp*dpp
            se11=se11+ox*dpp
            se12=se12+oz*dpp
  130     continue
          sen15=se11/se2
          sen16=se12/se2
          aa(i,j3)=(sen15-ss(j3))/dsm(i)
          aa(i,j4)=(sen16-ss(j4))/dsm(i)
  140     if(nqc.eq.0) goto 150
          dpp=zero
          call clorb2(dpp)
          call phasad(dpp,qwc)
          sen17=qwc(1)
          sen18=qwc(2)
          aa(i,j1)=(sen17-ss(j1))/dsm(i)
          aa(i,j2)=(sen18-ss(j2))/dsm(i)
  150     continue
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-dsm(i)
            else
              ek(irr(i))=ek(irr(i))-dsm(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-dsm(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  160   continue
        call loesd(aa,bb,j2,10,ierr)
        if(ierr.eq.1) call prror(38)
        do 170 i=1,j2
          if(i.eq.jj1.or.i.eq.jj2) then
            if (abs(el(irr(i))).le.pieni) then
              ed(irr(i))=ed(irr(i))-bb(i)
            else
              ek(irr(i))=ek(irr(i))-bb(i)
            endif
          endif
          if(i.ne.jj1.and.i.ne.jj2)ed(irr(i))=ed(irr(i))-bb(i)
          if(kp(irr(i)).eq.5) call combel(irr(i))
  170   continue
        if(nre.eq.0) goto 190
        call resex(dpp)

        do i=1,jjr
          ss(i)=dtr(i)
          d1(i)=abs(ss(i))
        end do

  190   if(nch.eq.0) goto 210
        se2=zero
        se11=zero
        se12=zero
        do 200 n=1,5
          dpp=de2*real(3-n,fPrec)                                              !hr06
          call clorb2(dpp)
          call phasad(dpp,qwc)
          ox=qwc(1)
          oz=qwc(2)
          se2=se2+dpp*dpp
          se11=se11+ox*dpp
          se12=se12+oz*dpp
  200   continue
        ss(j3)=se11/se2
        ss(j4)=se12/se2
        d1(j3)=abs(ss(j3))
        d1(j4)=abs(ss(j4))
  210   if(nqc.eq.0) goto 220
        dpp=zero
        call clorb2(dpp)
        call phasad(dpp,qwc)
        ss(j1)=qwc(1)
        ss(j2)=qwc(2)
        d1(j1)=abs(qwc(1)-qw0(1))
        d1(j2)=abs(qwc(2)-qw0(2))
  220   write(lout,10070)
        if(nre.eq.0) goto 270
        write(lout,10080) no,nrr(1),sen(1),ss(1),sen(2),ss(2)
        if(nre.eq.1) goto 240

        do i=2,nre
          i2=2*i
          i1=i2-1
          write(lout,10090) nrr(i),sen(i1),ss(i1),sen(i2),ss(i2)
        end do

  240   write(lout,10100)
        write(lout,10110)bez(irr(1)),sn(1),ed(irr(1)),bez(irr(2)),sn(2),&
     &ed(irr(2))
        if(nre.eq.1) goto 260

        do i=2,nre
          i2=2*i
          i1=i2-1
        write(lout,10110)bez(irr(i1)),sn(i1),ed(irr(i1)),bez(irr(i2)),sn&
     &(i2), ed(irr(i2))
        end do

  260   write(lout,10070)
  270   if(nch.eq.0) goto 280
        write(lout,10120) sen(j3),ss(j3),sen(j4),ss(j4)
        write(lout,10110)bez(irr(j3)),sn(j3),ed(irr(j3)),bez(irr(j4)),sn&
     &(j4), ed(irr(j4))
        write(lout,10070)
  280   if(nqc.eq.0) goto 290
        write(lout,10130) qw0(1),qwc(1),qw0(2),qwc(2)
        if (abs(el(irr(j1))).le.pieni) then
          write(lout,10140) sn(j1),ed(irr(j1)),irr(j1),sn(j2),          &
     &ed(irr(j2)),                                                      &
     &irr(j2)
        else
          write(lout,10140) sn(j1),ek(irr(j1)),irr(j1),sn(j2),          &
     &ek(irr(j2)),                                                      &
     &irr(j2)
        endif

  290   do i=1,j2
          if(d1(i).gt.dsi) goto 310
        end do

        nta=ntao
        nte=nteo
        return

  310   do i=1,j2
          bb(i)=ss(i)
        end do

        if(nqc.eq.1) bb(j1)=bb(j1)-qw0(1)
        if(nqc.eq.1) bb(j2)=bb(j2)-qw0(2)
  330 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY RMOD ----')
10010 format(/10x,'N=',i1,' IS THE ORDER OF RESONACE, THAT WILL BE',    &
     &' COMPENSATED'// 10x,'L=',f15.6,'; QX=',f10.5,'; QY=',f10.5,      &
     &'; AMAX=',f10.5)
10020 format(/10x,i1,' RESONANCE; NY=',i2,';CHANGE OF P=',i2)
10030 format(/10x,'NUMBER OF SUBRESONANCES THAT ARE CONSIDERED IS ',i2)
10040 format(/10x,'NU=',i2,' IS THE ',i1,' SUBRESONANCE-MULTIPOLE-ORDER'&
     &,i2)
10050 format(/10x,'CHROMATICITY IS COMPENSATED')
10060 format(/10x,'Q-VALUES ARE ADJUSTED')
10070 format(131('-'))
10080 format(/10x,'RESONANCE-CORRECTION     ITERATION #',i2// 15x,      &
     &'DRIVING-TERM',13x,'BEFORE         AFTER     COMPENSATION'// 10x, &
     &'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,'SIN-COMPONENT  ',2g15.5/&
     &)
10090 format(10x,'NY=',i2,'  COS-COMPONENT  ',2g15.5/ 17x,              &
     &'SIN-COMPONENT  ',2g15.5/)
10100 format(10x,'  ELEMENT NAME'/)
10130 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10140 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10120 format(10x,'CHROMATICITY-CORRECTION'/ 15x,'CHROMATICITY',13x,     &
     &'BEFORE         AFTER     COMPENSATION'// 19x,'HORIZONTAL   ',2g15&
     &.5/ 19x,'VERTICAL     ',2g15.5/ 10x,'   SEXTUPOLE'/)
10110 format(14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,g17.10)
end subroutine rmod

+dk search
      subroutine search(dpp)
!-----------------------------------------------------------------------
!  FINDING THE BEST POSITIONS FOR CORRECTION-ELEMENTS
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,id,n21,n22,n23,ntao,nteo
      real(kind=fPrec) b,c,c1,c2,c3,d,dpp,e,f,g,s1,s2,s3
      character(len=max_name_len) ref
      save
!-----------------------------------------------------------------------
      ntao=nta
      nteo=nte
      nta=mp
      nte=mp
      ref='REFERENCE       '
      id=0
      write(lout,10010)
      write(lout,10000)
      write(lout,10010)
      write(lout,10020) mp
      write(lout,10010)
      write(lout,10030) m21,ise1,m22,ise2,m23,ise3
      write(lout,10010)
      write(lout,10040)
      write(lout,10010)
      n21=m21+mp
      n22=m22+mp
      n23=m23+mp
      ipt=ise1
      call subsea(dpp)
      c1=rtc(mp,n21,mp,1)
      s1=rts(mp,n21,mp,1)
      ipt=ise2
      call subsea(dpp)
      c2=rtc(mp,n22,mp,1)
      s2=rts(mp,n22,mp,1)
      ipt=ise3
      call subsea(dpp)
      c3=rtc(mp,n23,mp,1)
      s3=rts(mp,n23,mp,1)
      write(lout,10050) ref,id,c1,s1,c2,s2,c3,s3
      do 10 i=1,mesa
        ed(isea(i))=ed(isea(i))+dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
        ipt=ise1
        call subsea(dpp)
        b=rtc(mp,n21,mp,1)-c1
        c=rts(mp,n21,mp,1)-s1
        ipt=ise2
        call subsea(dpp)
        d=rtc(mp,n22,mp,1)-c2
        e=rts(mp,n22,mp,1)-s2
        ipt=ise3
        call subsea(dpp)
        f=rtc(mp,n23,mp,1)-c3
        g=rts(mp,n23,mp,1)-s3
        write(lout,10050) bez(isea(i)),i,b,c,d,e,f,g
        ed(isea(i))=ed(isea(i))-dsm0
        if(kp(isea(i)).eq.5) call combel(isea(i))
   10 continue
      nta=ntao
      nte=nteo
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY SEARCH ----')
10010 format(1x ,131('-'))
10020 format(10x,///'RESONANCES OF ORDER',i4,'  ARE CONSIDERED'//)
10030 format(24x ,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|',6x,'NY =',i4,    &
     &';D-P= ',i4,7x,'|',6x,'NY =',i4,';D-P= ',i4,7x, '|')
10040 format(1x,'ELEMENT          | POS |',6x,'COS',13x,'SIN',6x,'|',   &
     &6x,'COS',13x,'SIN',6x,'|', 6x,'COS',13x,'SIN',6x,'|')
10050 format(1x,a16,1x,'|',i3,'  |',g15.5,'|',g15.5,'|',g15.5,'|',      &
     &g15.5,'|',g15.5,'|',g15.5,'|')
      end

+dk subre
!-----------------------------------------------------------------------
!  CALCULATION OF RESONANCE- AND SUBRESONANCE-DRIVINGTERMS
!-----------------------------------------------------------------------
subroutine subre(dpp)
  ! Rewritten to remove computed gotos by V.K.B.Olsen on 23/11/2017
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  use crcoall
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  
  integer i,ii,ik,im,ip,ipc,ipcc,ipl,ium,iv,ix,izu,j,jj,jk,jm,k,k1,kpz,kzz,l,l1,l2,ll,lmin,min1,min2,&
          mis,mm,mpe,mx,n2,n22,n2e,nf1,nf3,nf4,nkk,nmz,nn1,nn2,nnf,np,np2,nph,nr,ns,ntx,nv,nv1,nv11,&
          nv2,nv21,nz2,dj
  real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,cc_r,chy,ci,cikve,clo0,clop0,cr,crkve,&
          cxzi,cxzr,cxzyi,cxzyr,cxzyrr,del,dfac,dphi,dpp,dpp1,dppi,dpr,dt,dtu,dtup,dyy1,dyy2,e,ea,eb,&
          ekk,ekko,ep,etl,gerad,gtu1,gtu2,phi,phibf,phy,pie,puf,qu,qv,qw,qwc,r0,r0a,radi,rc,re,re1,res,&
          rn2,rs,sb1,sb2,sdel,sdel2,sea,seb,shy,ss,t,vdt1,vdt2,vdt3,vdt4,xl,xs,zl,zs,quz,qvz
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,tiltck5,tiltck6,tiltck8,tiltck10,&
          tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5,tiltsk6,tiltsk8,tiltsk10
#endif
      dimension t(6,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension clo0(2),clop0(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),qwc(3),dpr(6)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension dfac(10),dtu(2,5),dtup(2,5,0:4,0:4)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
      ipl=1
      gtu1=zero
      gtu2=zero
      dfac(1)=one
      dfac(2)=one
      dfac(3)=two
      dfac(4)=six                                                        !hr13
      dfac(5)=24.0                                                       !hr13
      dfac(6)=120.0_fPrec                                                !hr13
      dfac(7)=720.0_fPrec                                                !hr13
      dfac(8)=5040.0_fPrec                                               !hr13
      dfac(9)=40320.0_fPrec                                              !hr13
      dfac(10)=362880.0_fPrec                                            !hr13
      if(ipt.eq.1) ipl=3

      do 940 ipcc=1,ipl
        ipc=ipcc-ipl+1
        if(ipt.eq.0) ipc=0
        btc=zero
        bts=zero
        phy=zero
        dt=zero
        del=zero
        ns=0
        ik=0

        do i=1,ium
          dpr(i)=zero
        end do

        do i=1,ium
          do j=1,4
            t(i,j)=zero
          end do
        end do

        do i=1,2
          beta(i)=zero
          alfa(i)=zero
          phi(i)=zero
          phibf(i)=zero
          qw(i)=zero
          qwc(i)=zero
          clo0(i)=zero
          clop0(i)=zero
          ep(i)=zero
        end do

        qwc(3)=zero
        do i=1,10
          nnf(i)=0
          do j=1,18
            re(i,j)=zero
            ip(i,j)=0
          end do
        end do

        do i=1,mmul
          aa(i)=zero
          bb(i)=zero
          cr(i)=zero
          ci(i)=zero
        end do

        do i=1,2
          do j=1,5
            dtu(i,j)=zero
          end do
        end do

        do i=1,5
          do j=0,4
            do k=0,4
              dtup(1,i,j,k)=zero
              dtup(2,i,j,k)=zero
            end do
          end do
        end do

        do 120 i=1,9
          nz2(i)=0
          do 110 j=1,18
            chy(i,j)=zero
            shy(i,j)=zero
            do 100 k=1,10
              do 80 ii=1,10
                e(k,ii)=zero
                b(k,ii)=zero
   80         continue
              do 90 l=1,5
                rtc(i,j,k,l)=zero
                rts(i,j,k,l)=zero
   90         continue
  100       continue
  110     continue
  120   continue

        write(lout,10030)
        write(lout,10020)
        pie=two*pi
        etl=zero
        radi=totl/pie
        nr=0
        dpr(1)=dpp*c1e3
        dpr(6)=c1e3
        dpp1=dpp+ded

        call clorb(dpp1)

        do l=1,2
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        call clorb(dpp)

        do l=1,2
          di0(l)=(clo0(l)-clo(l))/ded
          dip0(l)=(clop0(l)-clop(l))/ded
        end do

        write(lout,10030)
        write(lout,10120) (di0(l),dip0(l),l=1,2)
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        if(ierro.ne.0) call prror(22+ierro)
        write(lout,10070) dpp,qwc(1),qwc(2)
        call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
        do l=1,2
          ll=2*l
          alfa(l)=alf0(l)
          beta(l)=bet0(l)
          t(1,ll-1)=clo(l)
          t(1,ll)=clop(l)
          clo0(l)=clo(l)
          clop0(l)=clop(l)
        end do

        do i=1,4
          do j=1,4
            t(i+1,j)=ta(j,i)
            t(i+1,j)=ta(j,i)
          end do
        end do

        write(lout,10030)
        write(lout,10040)
        write(lout,10030)
        write(lout,10010) nr,'START   ',zero,zero,(beta(l),alfa(l),phi(l),&
                          di0(l),dip0(l),clo0(l),clop0(l),l=1,2)

!--EP=EMITTANCE IN PI*MM*MRAD
        ep(1)=tam1**2/beta(1)                                            !hr06
        ep(2)=tam2**2/beta(2)                                            !hr06
        write(lout,10050) tam1,ep(1),tam2,ep(2)
        write(lout,10030)

!--SINGLE TURN BLOCKLOOP
        izu=0
        do 790 k=1,iu
          do k1=1,10
            ab1(k1)=zero
            ab2(k1)=zero
          end do

          ix=ic(k)
          if(ix.gt.nblo) goto 250
          jj=0
          dj=1
          if(ix.gt.0) goto 180
          ix=-1*ix
          jj=mel(ix)+1
          dj=-1
  180     jm=mel(ix)

!--SINGLE TURN BLOCKLOOP
          do 240 j=1,jm
            jj=jj+dj
            jk=mtyp(ix,jj)
            if(ithick.eq.1.and.kz(jk).ne.0) goto 210
            if(ithick.eq.0.and.kz(jk).ne.0) goto 790

!--PURE DRIFTLENGTH
            etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=pi2
              endif
              do i=1,ium
                t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
              end do
            end do

            do l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)

              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=pi2-phibf(l)
              endif

              if(-one*dphi.gt.pieni) dphi=dphi+pi                        !hr06
              phi(l)=phi(l)+dphi/pie
            end do

            nr=nr+1
            goto 240

!--MAGNETELEMENT
  210       continue
            if(kz(jk).ne.8) etl=etl+el(jk)
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=zero
              endif
              do i=1,ium
                puf=t(i,ll-1)
                t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5)
                t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6) !hr06
              enddo
            enddo
            do l=1,2
              ll=2*l
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                      !hr06
              alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll)) !hr06
              clo0(l)=t(1,ll-1)
              clop0(l)=t(1,ll)
              if(abs(t(ll,ll-1)).gt.pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=-phibf(l)
              endif
              if(kz(jk).ne.8.and.-dphi.gt.pieni) dphi=dphi+pi
              phi(l)=phi(l)+dphi/pie
            enddo
            nr=nr+1
  240     continue
          goto 790

!--NL-INSERTION
  250     ix=ix-nblo
          qu=zero
          qv=zero
          kpz=kp(ix)
          if(kpz.eq.6) goto 790
          kzz=kz(ix)
          if(kzz == 22) then
            do l=1,2
              ll=2*l
              if(abs(t(ll,ll-1)).gt.pieni) then
                phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
              else
                phibf(l)=zero
              end if
              do i=1,ium
                puf=t(i,ll-1)
                t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+t(i,ll)*rrtr(imtr(ix),ll-1,ll))+dpr(i)*rrtr(imtr(ix),ll-1,6)
                t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+t(i,ll)*rrtr(imtr(ix),ll,ll))+dpr(i)*rrtr(imtr(ix),ll,6)
              end do
              t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
              t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
              beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2
              alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
              if(abs(t(ll,ll-1)) > pieni) then
                dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
              else
                dphi=-one*phibf(l)
              end if
              if(-one*dphi.gt.pieni) dphi=dphi+pi
                          phi(l)=phi(l)+dphi
          enddo
        endif
          clo0(1)=t(1,1)
          clop0(1)=t(1,2)
          clo0(2)=t(2,3)
          clop0(2)=t(2,4)
          if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 790
          if(kzz.eq.15) goto 790
! JBG RF CC Multipoles to 790
          if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 790
          if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 790
          dyy1=zero
          dyy2=zero
          if(iorg.lt.0) mzu(k)=izu
          izu=mzu(k)+1
          ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
          izu=izu+1
          xs=xpl(ix)+zfz(izu)*xrms(ix)
          izu=izu+1
          zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignl.f90"

        select case (kzz)
        case (1) ! HORIZONTAL DIPOLE
          ekk=ekk*c1e3
#include "include/kicka01h.f90"
        case (2) ! NORMAL QUADRUPOLE
#include "include/kicka02h.f90"
        case (3) ! NORMAL SEXTUPOLE
          ekk=ekk*c1m3
#include "include/kicka03h.f90"
        case (4) ! NORMAL OCTUPOLE
          ekk=ekk*c1m6
#include "include/kicka04h.f90"
          call detune(2,ekk,ep,beta,dtu,dtup,dfac)
        case (5) ! NORMAL DECAPOLE
          ekk=ekk*c1m9
#include "include/kicka05h.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
        case (6) ! NORMAL DODECAPOLE
          ekk=ekk*c1m12
#include "include/kicka06h.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ekk,ep,beta,dtu,dtup,dfac)
        case (7) ! NORMAL 14-POLE
          ekk=ekk*c1m15
#include "include/kicka07h.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
        case (8) ! NORMAL 16-POLE
          ekk=ekk*c1m18
#include "include/kicka08h.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ekk,ep,beta,dtu,dtup,dfac)
        case (9) ! NORMAL 18-POLE
          ekk=ekk*c1m21
#include "include/kicka09h.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
        case (10) ! NORMAL 20-POLE
          ekk=ekk*c1m24
#include "include/kicka10h.f90"
#include "include/kispa10h.f90"
        case (11)
          r0=ek(ix)
          if(abs(dki(ix,1)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl01.f90"
              do i=2,ium
#include "include/multl02.f90"
              end do
            else
#include "include/multl03.f90"
            end if
          end if
          if(abs(dki(ix,2)).gt.pieni) then
            if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl04.f90"
              do i=2,ium
#include "include/multl05.f90"
              end do
            else
#include "include/multl06.f90"
            end if
          end if
          mpe=9
          mx=0
          if(abs(r0).le.pieni) goto 790
          nmz=nmu(ix)
          if(nmz.eq.0) then
            izu=izu+2*mmul
            goto 790
          end if
          im=irm(ix)
          r0a=one
          benkr=ed(ix)/(one+dpp)
          cr(1)=one
          cr(2)=xl
          ci(2)=zl
          cxzyr=xl
          cxzyi=zl
          cxzr=cxzyr
          cxzi=cxzyi
          dyy1=zero
          dyy2=zero
          qu=zero
          qv=zero
          lmin=3
          if(nmz.eq.1) lmin=2
          do l=lmin,mmul
            aa(l)=zero
            bb(l)=zero
            cr(l)=zero
            ci(l)=zero
          end do
          do l=1,nmz
#include "include/multl13.f90"
          end do
#ifdef TILT
#include "include/multl07e.f90"
#endif
          izu=izu+2*mmul-2*nmz
          do iv=2,5
#include "include/multl12.f90"
          end do
        case (12,13,14,15,16,17,18,19,20,21,22,23)
          goto 790
        case (24) ! DIPEDGE ELEMENT
#include "include/kickadpe.f90"
        case (25) ! Solenoid
#include "include/kickaso1.f90"
        case (26,27,28)
          goto 790
        
        !-----------------
        !--SKEW ELEMENTS--
        !-----------------
        case (-1) ! VERTICAL DIPOLE
          ekk=ekk*c1e3
#include "include/kicka01v.f90"
        case (-2) ! SKEW QUADRUPOLE
#include "include/kicka02v.f90"
        case (-3) ! SKEW SEXTUPOLE
          ekk=ekk*c1m3
#include "include/kicka03v.f90"
        case (-4) ! SKEW OCTUPOLE
          ekk=ekk*c1m6
#include "include/kicka04v.f90"
        case (-5) ! SKEW DECAPOLE
          ekk=ekk*c1m9
#include "include/kicka05v.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
        case (-6) ! SKEW DODECAPOLE
          ekk=ekk*c1m12
#include "include/kicka06v.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
        case (-7) ! SKEW 14-POLE
          ekk=ekk*c1m15
#include "include/kicka07v.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
        case (-8) ! SKEW 16-POLE
          ekk=ekk*c1m18
#include "include/kicka08v.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
        case (-9) ! SKEW 18-POLE
          ekk=ekk*c1m21
#include "include/kicka09v.f90"
          call detune(2,ab1(4),ep,beta,dtu,dtup,dfac)
          call detune(3,ab1(6),ep,beta,dtu,dtup,dfac)
          call detune(4,ab1(8),ep,beta,dtu,dtup,dfac)
        case (-10) ! SKEW 20-POLE
          ekk=ekk*c1m24
#include "include/kicka10v.f90"
#include "include/kispa10v.f90"
        case default
          goto 790
        end select

          t(1,2)=t(1,2)+dyy1
          t(1,4)=t(1,4)+dyy2
          do i=2,ium
            if(kzz.eq.24) then
              t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
              t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
#include "include/phas1so1.f90"
#include "include/phas2so1.f90"
#include "include/phas3so1.f90"
            else
              t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
              t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
            end if
          end do

          do l=1,2
            ll=2*l
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            clop0(l)=t(1,ll)
          end do
          
          if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 790
          if(mpe.lt.nta) goto 790
          if(mpe.gt.nte) mpe=nte
          if(nta.gt.2) goto 550
          if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or. mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 550

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          do l=2,nmz
            l1=l-1
            ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          end do

  550     b1=beta(1)
          b2=beta(2)
          sb1=sqrt(b1)
          sb2=sqrt(b2)
          b(3,1)=b1
          b(1,3)=b2
          b(2,2)=sb1*sb2
          if(nta.gt.3) goto 570
          if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 700
          if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx .eq.6.or.mx.eq.7) goto 570

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=3,nmz
            l1=l-2
            ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))           !hr06
            ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))           !hr06
            l2=l2*l/l1
          end do

  570     b(4,1)=b1*sb1
          b(1,4)=b2*sb2
          b(3,2)=b1*sb2
          b(2,3)=b2*sb1
          if(nta.gt.4) goto 590
          if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 700
          if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx .eq.7) goto 590

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=4,nmz
            l1=l-3
            ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))     !hr06
            ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))     !hr06
            l2=l2*l/l1
          end do

  590     b(5,1)=b1**2                                                   !hr06
          b(1,5)=b2**2                                                   !hr06
          b(4,2)=b(3,2)*sb1
          b(2,4)=b(2,3)*sb2
          b(3,3)=b1*b2
          if(nta.gt.5) goto 610
          if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 700
          if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 610

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=5,nmz
            l1=l-4
            ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  610     b(6,1)=b(5,1)*sb1
          b(1,6)=b(1,5)*sb2
          b(5,2)=b(4,2)*sb1
          b(2,5)=b(2,4)*sb2
          b(4,3)=b(4,2)*sb2
          b(3,4)=b(2,4)*sb1
          if(nta.gt.6) goto 630
          if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 700
          if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 630

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=6,nmz
            l1=l-5
            ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  630     b(7,1)=b(6,1)*sb1
          b(1,7)=b(1,6)*sb2
          b(6,2)=b(5,2)*sb1
          b(2,6)=b(2,5)*sb2
          b(5,3)=b(5,2)*sb2
          b(3,5)=b(2,5)*sb1
          b(4,4)=b(3,4)*sb1
          if(nta.gt.7) goto 650
          if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 700
          if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 650

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=7,nmz
            l1=l-6
            ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  650     b(8,1)=b(7,1)*sb1
          b(1,8)=b(1,7)*sb2
          b(7,2)=b(7,1)*sb2
          b(2,7)=b(1,7)*sb1
          b(6,3)=b(5,3)*sb1
          b(3,6)=b(3,5)*sb2
          b(5,4)=b(4,4)*sb1
          b(4,5)=b(4,4)*sb2
          if(nta.gt.8) goto 670
          if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 700
          if(mx.eq.6.or.mx.eq.7) goto 670

!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
          l2=1
          do l=8,nmz
            l1=l-7
            ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))    !hr06
            ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))    !hr06
            l2=l2*l/l1
          end do

  670     b(9,1)=b(8,1)*sb1
          b(1,9)=b(1,8)*sb2
          b(8,2)=b(8,1)*sb2
          b(2,8)=b(1,8)*sb1
          b(7,3)=b(7,2)*sb2
          b(3,7)=b(2,7)*sb1
          b(6,4)=b(6,3)*sb2
          b(4,6)=b(3,6)*sb1
          b(5,5)=b(4,5)*sb1
          if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 700
          if(mx.eq.7) goto 690

!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
          l2=1
          do l=9,nmz
            l1=l-8
            ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))     !hr06
            ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))     !hr06
            l2=l2*l/l1
          end do

  690     b(10,1)=b(9,1)*sb1
          b(1,10)=b(1,9)*sb2
          b(9,2)=b(9,1)*sb2
          b(2,9)=b(1,9)*sb1
          b(8,3)=b(8,2)*sb2
          b(3,8)=b(2,8)*sb1
          b(4,7)=b(3,7)*sb1
          b(7,4)=b(7,3)*sb2
          b(5,6)=b(4,6)*sb1
          b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  700     do 720 np=1,mpe
            n2e=2*np
            do 710 nv=1,n2e
              n2=nv-np
              nn2=abs(n2)
              nn1=np-nn2
              re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                             !hr06
              ip(np,nv)=int(re1+half)+ipc
              if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipc
!--RE=DISTANCE FROM THE RESONANCE
              re(np,nv)=re1-real(ip(np,nv),fPrec)
              res=re(np,nv)/radi
          chy(np,nv)=cos_mb((real(nn1,fPrec)*pie*phi(1)+real(n2,fPrec)*pie*phi(2))-res*etl) !hr06
          shy(np,nv)=sin_mb((real(nn1,fPrec)*pie*phi(1)+real(n2,fPrec)*pie*phi(2))-res*etl) !hr06
  710       continue
  720     continue
          do 780 np=nta,mpe
            np2=np
            nkk=0
  730       nkk=nkk+1
            n2e=2*np2
            do 770 i=1,nkk
              do 760 nv=1,n2e
                nn2=abs(nv-np2)
                nv1=np2-nn2+(i-1)*2+1
                nv2=np-nv1+2
                rn2=real(nn2,fPrec)*half                                            !hr06
!--EVENESS OF N2
                mm=0
                gerad=rn2-aint(rn2)
                if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
                if (mm.eq.0) goto 740
                btc=ab1(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab1(np)*b(nv1,nv2)*shy(np2,nv)
                goto 750
  740           btc=ab2(np)*b(nv1,nv2)*chy(np2,nv)
                bts=ab2(np)*b(nv1,nv2)*shy(np2,nv)
  750           rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
                rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  760         continue
  770       continue
            np2=np2-2
            if(np2.ge.1) goto 730
  780     continue
          nr=nr+1
  790   continue
        nnf(1)=1
        nnf(2)=1
        nnf(3)=2
        nz2(2)=2
        sea=sqrt(ep(1))
        seb=sqrt(ep(2))
        ea=ep(1)
        eb=ep(2)
        e(3,1)=one/eb
        e(1,3)=one/ea
        e(2,2)=(one/seb)/sea                                             !hr06
        nnf(4)=6
        nz2(3)=4
        e(4,1)=sea/eb
        e(1,4)=seb/ea
        e(3,2)=one/seb
        e(2,3)=one/sea
        nnf(5)=24
        nz2(4)=8
        e(5,1)=ea/eb
        e(1,5)=eb/ea
        e(4,2)=sea/seb
        e(2,4)=seb/sea
        e(3,3)=one
        nnf(6)=120
        nz2(5)=16
        e(6,1)=e(5,1)*sea
        e(1,6)=e(1,5)*seb
        e(5,2)=ea/seb
        e(2,5)=eb/sea
        e(4,3)=sea
        e(3,4)=seb
        nnf(7)=720
        nz2(6)=32
        e(7,1)=e(6,1)*sea
        e(1,7)=e(1,6)*seb
        e(6,2)=e(5,2)*sea
        e(2,6)=e(2,5)*seb
        e(5,3)=ea
        e(3,5)=eb
        e(4,4)=sea*seb
        nnf(8)=5040
        nz2(7)=64
        e(8,1)=e(7,1)*sea
        e(1,8)=e(1,7)*seb
        e(7,2)=e(6,2)*sea
        e(2,7)=e(2,6)*seb
        e(6,3)=ea*sea
        e(3,6)=eb*seb
        e(5,4)=ea*seb
        e(4,5)=sea*eb
        nnf(9)=40320
        nz2(8)=128
        e(9,1)=e(8,1)*sea
        e(1,9)=e(1,8)*seb
        e(8,2)=e(7,2)*sea
        e(2,8)=e(2,7)*seb
        e(7,3)=ea**2                                                     !hr06
        e(3,7)=eb**2                                                     !hr06
        e(6,4)=e(5,4)*sea
        e(4,6)=e(4,5)*seb
        e(5,5)=ea*eb
        nnf(10)=362880
        nz2(9)=256
        e(10,1)=e(9,1)*sea
        e(1,10)=e(1,9)*seb
        e(9,2)=e(8,2)*sea
        e(2,9)=e(2,8)*seb
        e(8,3)=e(7,3)*sea
        e(3,8)=e(3,7)*seb
        e(7,4)=e(6,4)*sea
        e(4,7)=e(4,6)*seb
        e(6,5)=e(5,5)*sea
        e(5,6)=e(5,5)*seb
        write(lout,10000)
        write(lout,10030)
        write(lout,10010)nr,'END     ',etl,zero,(beta(l),alfa(l),phi(l),di0(l),dip0(l),clo0(l),clop0(l),l=1,2)
        write(lout,10030)
        write(lout,10110) etl,qwc(1),qwc(2)
        write(lout,10030)
        do 800 iv=2,5
          gtu1=gtu1+dtu(1,iv)
          gtu2=gtu2+dtu(2,iv)
  800   continue
        write(lout,10150) dtu(1,2),dtu(1,3),dtu(1,4),dtu(1,5),gtu1, dtu (2,2),dtu(2,3),dtu(2,4),dtu(2,5),gtu2

        do i=1,2
          do j=1,5
            do l=0,4
              do k=0,4
                if(i.eq.2.and.j.eq.1.and.k.eq.1.and.l.eq.1) write (lout,10160)
                if(abs(dtup(i,j,k,l)).gt.pieni) write(lout,'(10X,G17.10,3X,I2,2X,I2)') dtup(i,j,k,l),k,l
              end do
            end do
          end do
        end do

        write(lout,10060)
        write(lout,10030)
        do 880 np=nta,nte
          write(lout,10080) np
          write(lout,10030)
          vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)               !hr06
          np2=np
          nkk=0
          write(lout,10090) np
          goto 830
  820     write(lout,10100) np,np2
  830     nkk=nkk+1
          n2e=2*np2
          do 850 i=1,nkk
            do 840 nv=1,n2e
              n2=nv-np2
              nn2=abs(n2)
              nn1=np2-nn2
              nv1=(nn1+(i-1)*2)+1                                        !hr06
              nv2=(np-nv1)+2                                             !hr06
              nv11=nv1-1
              nv21=nv2-1
              nf1=nn1+i
              nf3=nkk-i+1
              nf4=nf3+nn2
              vdt2=vdt1*e(nv1,nv2)/real(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4),fPrec) !hr06
              vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                 !hr06
              vdt4=vdt3
              if(n2.ge.0) vdt3=real(n2*nv21,fPrec)*ea + real(nn1*nv11,fPrec)*eb  !hr06
              rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
              rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  840       continue
  850     continue
          do 870 nv=1,n2e
            mis=1
            rc=zero
            rs=zero
            do 860 i=1,nkk
              rc=rc+real(mis,fPrec)*rtc(np2,nv,np,i)                     !hr06
              rs=rs+real(mis,fPrec)*rts(np2,nv,np,i)                     !hr06
              mis=-mis
  860       continue
            sdel2=sqrt(rc**2+rs**2)                                      !hr06
            n22=nv-np2
            write(lout,10140) n22,ip(np2,nv),ipc,rc,rs,re(np2,nv),sdel2
  870     continue
          np2=np2-2
          if(np2.ge.1) goto 820
  880   continue
        ntx=nte-2
        write(lout,10130)
        do 930 np=1,nte
          write(lout,10090) np
          n2e=2*np
          do 920 nv=1,n2e
            n2=nv-np
            nkk=2
            nph=np+2
            min1=-1
  890       min2=min1
            do 900 i=1,nkk
             rtc(np,nv,np,1)=rtc(np,nv,np,1)+real(min2,fPrec)*rtc(np,nv,nph,i) !hr06
             rts(np,nv,np,1)=rts(np,nv,np,1)+real(min2,fPrec)*rts(np,nv,nph,i) !hr06
              min2=-min2
  900       continue
            nph=nph+2
            if(nph.gt.nte) goto 910
            nkk=nkk+1
            min1=-min1
            goto 890
  910       cc_r=rtc(np,nv,np,1)
            ss=rts(np,nv,np,1)
            sdel=sqrt(cc_r**2+ss**2)                                       !hr06
            write(lout,10140) n2,ip(np,nv),ipc,cc_r,ss,re(np,nv),sdel
  920     continue
  930   continue
  940 continue
      call clorb(ded)
      do 950 l=1,2
        clo0(l)=clo(l)
        clop0(l)=clop(l)
  950 continue
      call clorb(zero)
      do 960 l=1,2
        ll=2*l
        di0(l)=(clo0(l)-clo(l))/ded
        dip0(l)=(clop0(l)-clop(l))/ded
  960 continue
!-----------------------------------------------------------------------
      return
10000 format(1x,i4,27x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x, &
     &f6.3,1x,f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6.3,1x,f6.2,1x,f6.3)
10020 format(t5,'---- ENTRY SUBRES ----')
10030 format(131('-'))
10040 format('  NR  TYP      L-TOTAL  LENGTH   BETAH  ALFAH  ',         &
     &' PHIH   DISH  DISPH   CLOH  CLOPH',                              &
     &'   BETAV  ALFAV   PHIV   DISV  DISPV   CLOV  CLOPV'/ 1x,         &
     &'                 (M)      (M)     (M)           ',               &
     &'(QE)   (M)   (RAD)   (MM) (MRAD)',                               &
     &'    (M)           (QE)   (M)   (RAD)   (MM) (MRAD)')
10050 format(//7x,'INIT. X-AMPLITUDE=',g15.8,'X-EMITTANCE=',g15.8,/40x, &
     &/7x,'INIT. Y-AMPLITUDE=',g15.8,'Y-EMITTANCE=',g15.8,              &
     &'UNITS ARE (PI X MM X MRAD)'//)
10060 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x)
10070 format(/10x,'RELATIVE ENERGY DEVIATION  ',t40,f10.7/ 10x,         &
     &'TUNES -HORIZONTAL',t40,f10.7/ 10x,'      -VERTICAL  ',t40,f10.7)
10080 format(/10x,'RESONANCE EXCITING MULTIPOLE-ORDER = ',i2)
10090 format(//20x,'RESONANCE-ORDER =',i2/20x,100('-')/ 20x,'| NY |',   &
     &'   P  | D-P |',2x,'DRIVING-COS ',3x,'|', 2x,'DRIVING-SIN ',3x,'|'&
     &, 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10100 format(//20x,'RESONANCE-ORDER =',i2,5x,'SUBRESONANCE-ORDER = ',i2,&
     &/20x,100('-')/ 20x,'| NY |','   P  | D-P |',2x,'DRIVING-COS ',3x, &
     &'|', 2x,'DRIVING-SIN ',3x,'|', 8x,'E',8x,'|',5x,'DELTA-E',5x,'|')
10110 format(/10x,'PRECISE LENGTH OF THE MACHINE : ',f43.33/ /10x,      &
     &'   PRECISE HORIZONTAL Q-VALUE : ',f43.33/ /10x,                  &
     &'     PRECISE VERTICAL Q-VALUE : ',f43.33/)
10120 format(t8,'  PLANE     DISP(MM)     DISP(MRAD)   '/ t6,'      X  '&
     &,2(f12.3,3x)/t10,'  Y  ',2(f12.3,3x)/)
10130 format(//10x,'E=NX*QX+NY*QY-P',//10x,'CLOSESET P-VALUE CHANGED ', &
     &'BY D-P',//10x,'DELTA-E STANDS FOR THE RESONANCE-WIDTH' //10x,    &
     &'!!!! ALL SUBRESONANCES ARE INCLUDED !!!! ')
10140 format(20x,'| ',i2,' | ',i4,' | ',i3,' |', g16.8,' |',g16.8,' |', &
     &g16.8,' |',g16.8,' |')
10150 format(/10x,'NONLINEAR DETUNING  '// 10x,'CHANGE IN QX'/ 10x,     &
     &' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ 10x,' 8. ORDER ',f15&
     &.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  ',f15.12/ 10x,       &
     &'CHANGE IN QY'/ 10x,' 4. ORDER ',f15.12/ 10x,' 6. ORDER ',f15.12/ &
     &10x,' 8. ORDER ',f15.12/ 10x,'10. ORDER ',f15.12/ 10x,'   TOTAL  '&
     &,f15.12// 10x,'DETUNING ORDER BY ORDER'// 10x,                    &
     &'Qx - COEFFICIENT   Ex  EY'/ 10x,'-------------------------')
10160 format(/ 10x,'Qy - COEFFICIENT   Ex  Ey'/ 10x,                    &
     &'-------------------------')
10010 format(1x,i4,1x,a8,1x,f8.2,1x,f7.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.&
     &2,1x,f6.3,1x,f6.2,1x,f6.3,1x, f7.2,1x,f6.2,1x,f6.2,1x,f6.2,1x,f6. &
     &3,1x,f6.2,1x,f6.3)
end subroutine subre 

      subroutine detune(iv,ekk,ep,beta,dtu,dtup,dfac)
!-----------------------------------------------------------------------
!  USED FOR SUBRE - CALCULATES DETUNING
!-----------------------------------------------------------------------
      use floatPrecision
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      implicit none
      integer iv,iv2,iv3,iv4,iv5,iv6
      real(kind=fPrec) beta,dfac,dtu,dtu1,dtu2,dtup,ekk,ep,pi,vor,vtu1, &
     &vtu2
      dimension dfac(10),dtu(2,5),ep(2),beta(2),dtup(2,5,0:4,0:4)
      save
!-----------------------------------------------------------------------
      if(iv.lt.2) then
        write(lout,*)
        write(lout,*) '       ***** ERROR IN DETUNE *****'
        write(lout,*)
        write(lout,*) '       IV LESS THAN 2, NO DETUNING POSSIBLE'
        write(lout,*)
        return
      endif
      pi=four*atan_mb(one)
      iv2=2*iv
      iv3=iv+1
!      vtu1=(((-one*ekk)*(half**iv2))*dfac(iv2))/pi                       !hr06
      vtu1=(((-one*ekk)*exp_mb(real(iv2,fPrec)*log_mb(half)))*          &
     &dfac(iv2))/pi    !hr13
      dtu1=zero
      dtu2=zero
      do 10 iv4=1,iv3
        iv5=iv4-1
        iv6=iv-iv5
        vor=one
        if(mod(iv6,2).ne.0) vor=-one                                 !hr06
!        vtu2=vor/(dfac(iv5+1)**2)/(dfac(iv6+1)**2)*(beta(1)**iv5)* (beta&
!     &(2)**iv6)
        vtu2=(((vor/(dfac(iv5+1)**2))/(dfac(iv6+1)**2))*                &!hr13
     &exp_mb(real(iv5,fPrec)*log_mb(beta(1))))*                         &!hr13
     &exp_mb(real(iv6,fPrec)*log_mb(beta(2)))                            !hr13
        if(iv5.ne.0) then
!          dtu1=dtu1+((vtu2*dble(iv5))*(ep(1)**(iv5-1)))*(ep(2)**iv6)    !hr06
         dtu1=dtu1+((vtu2*real(iv5,fPrec))*exp_mb(real(iv5-1,fPrec)*    &
     &log_mb(ep(1))))*exp_mb(real(iv6,fPrec)*log_mb(ep(2)))                           !hr13
         dtup(1,iv,iv5-1,iv6)=dtup(1,iv,iv5-1,iv6)+                     &
     &(vtu2*real(iv5,fPrec))*vtu1 !hr06
        endif
        if(iv6.ne.0) then
!          dtu2=dtu2+((vtu2*dble(iv6))*(ep(1)**iv5))*(ep(2)**(iv6-1))     !hr06
          dtu2=dtu2+((vtu2*real(iv6,fPrec))*exp_mb(real(iv5,fPrec)*     &
     &log_mb(ep(1))))*exp_mb(real(iv6-1,fPrec)*log_mb(ep(2)))                  !hr13
         dtup(2,iv,iv5,iv6-1)=dtup(2,iv,iv5,iv6-1)+                     &
     &(vtu2*real(iv6,fPrec))*vtu1 !hr06
        endif
   10 continue
      dtu(1,iv)=dtu(1,iv)+vtu1*dtu1
      dtu(2,iv)=dtu(2,iv)+vtu1*dtu2
      return
      end

+dk subsea
!-----------------------------------------------------------------------
!  CALCULATION OF DRIVINGTERMS OF RESONANCES INCLUDING SUBRESONANCE
!  USED FOR SEARCH
!-----------------------------------------------------------------------
subroutine subsea(dpp)
  ! Rewritten to remove computed gotos by V.K.B.Olsen on 23/11/2017
  use floatPrecision
  use end_sixtrack
  use numerical_constants
  use mathlib_bouncer
  use parpro
  use mod_common
  use mod_commons
  use mod_commont
  implicit none
  integer i,ii,ik,im,ip,ium,ix,izu,j,jj,jk,jm,k,k1,kpz,kzz,l,l1,l2,ll,lmin,mm,mpe,mx,n2,n2e,nf1,nf3,&
          nf4,nkk,nmz,nn1,nn2,nnf,np,np2,ns,nv,nv1,nv11,nv2,nv21,nz2,dj
  real(kind=fPrec) aa,ab1,ab2,alfa,b,b1,b2,bb,benkr,beta,btc,bts,chy,ci,cikve,cr,crkve,cxzi,cxzr,&
          cxzyi,cxzyr,cxzyrr,del,dphi,dpp,dppi,dpr,dt,dyy1,dyy2,e,ea,eb,ekk,ep,etl,gerad,phi,phibf,&
          phy,pie,puf,qu,qv,qw,r0,r0a,radi,re,re1,res,rn2,sb1,sb2,sea,seb,shy,t,vdt1,vdt2,vdt3,xl,xs,zl,zs,quz,qvz
#ifdef TILT
  real(kind=fPrec) dyy11,qu1,tiltck,tiltck1,tiltck2,tiltck3,tiltck4,tiltck5,tiltckuk,tiltsk,tiltsk1,tiltsk2,tiltsk3,tiltsk4,tiltsk5
#endif
      dimension t(5,4)
      dimension beta(2),alfa(2),phi(2),phibf(2)
      dimension aa(mmul),bb(mmul)
      dimension qw(2),dpr(5)
      dimension nnf(10),ep(2)
      dimension ab1(10),ab2(10),re(10,18),ip(10,18)
      dimension b(10,10),nz2(9),e(10,10)
      dimension chy(9,18),shy(9,18)
      dimension cr(mmul),ci(mmul)
      save
!-----------------------------------------------------------------------
      ium=5
      do 10 i=1,ium
        dpr(i)=zero
   10 continue
      do i=1,ium
        do j=1,4
          t(i,j)=zero
        end do
      end do

      do 30 i=1,2
        beta(i)=zero
        alfa(i)=zero
        phi(i)=zero
        phibf(i)=zero
        qw(i)=zero
        ep(i)=zero
   30 continue

      do i=1,10
        nnf(i)=0
        do j=1,18
          ip(i,j)=0
          re(i,j)=zero
        end do
      end do

      do 50 i=1,mmul
        aa(i)=zero
        bb(i)=zero
        cr(i)=zero
        ci(i)=zero
   50 continue

      do 100 i=1,9
        nz2(i)=0
        do 90 j=1,18
          chy(i,j)=zero
          shy(i,j)=zero
          do 80 k=1,10
            do 60 ii=1,10
              e(k,ii)=zero
              b(k,ii)=zero
   60       continue
            do 70 l=1,5
              rtc(i,j,k,l)=zero
              rts(i,j,k,l)=zero
   70       continue
   80     continue
   90   continue
  100 continue

      btc=zero
      bts=zero
      phy=zero
      dt=zero
      del=zero
      ns=0
      ik=0
      pie=two*pi
      etl=zero
      radi=totl/pie
      dpr(1)=dpp*c1e3
      call clorb2(dpp)
      call betalf(dpp,qw)
      if(ierro.ne.0) call prror(22+ierro)
      call envar(dpp)

!--STARTVALUES OF THE TRAJECTORIES
      do l=1,2
        ll=2*l
        alfa(l)=alf0(l)
        beta(l)=bet0(l)
        t(1,ll-1)=clo(l)
        t(1,ll)=clop(l)
      end do

      do i=1,4
        do j=1,4
          t(i+1,j)=ta(j,i)
          t(i+1,j)=ta(j,i)
        end do
      end do

!--EP=EMITTANCE IN PI*MM*MRAD
      ep(1)=tam1**2/beta(1)                                              !hr06
      ep(2)=tam2**2/beta(2)                                              !hr06

!--SINGLE TURN BLOCKLOOP
      izu=0
      do 740 k=1,iu
        do k1=1,10
          ab1(k1)=zero
          ab2(k1)=zero
        end do

        ix=ic(k)
        if(ix.gt.nblo) goto 210
        jj=0
        dj=1
        if(ix.gt.0) goto 140
        ix=-ix
        jj=mel(ix)+1
        dj=-1
  140   jm=mel(ix)
!--BLOCKELEMENTLOOP
        do 200 j=1,jm
          jj=jj+dj
          jk=mtyp(ix,jj)
          if(ithick.eq.1.and.kz(jk).ne.0) goto 170
          if(ithick.eq.0.and.kz(jk).ne.0) goto 740

!--PURE DRIFTLENGTH
          etl=etl+el(jk)
          do l=1,2
            ll=2*l

            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=pi2
            endif

            do i=1,ium
              t(i,ll-1)=t(i,ll-1)+t(i,ll)*(el(jk))
            end do
          end do

          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06

            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=pi2-phibf(l)
            endif

            if(-one*dphi.gt.pieni) dphi=dphi+pi                          !hr06
            phi(l)=phi(l)+dphi
          end do

          goto 200

!--MAGNETELEMENT
  170     continue
          if(kz(jk).ne.8) etl=etl+el(jk)
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            endif
            do i=1,ium
              puf=t(i,ll-1)
            t(i,ll-1)=(puf*a(jk,l,1)+t(i,ll)*a(jk,l,2))+dpr(i)*a(jk,l,5) !hr06
            t(i,ll)=(puf*a(jk,l,3)+t(i,ll)*a(jk,l,4))+dpr(i)*a(jk,l,6)   !hr06
            enddo
          enddo
          do l=1,2
            ll=2*l
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2                        !hr06
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))   !hr06
            if(abs(t(ll,ll-1)).gt.pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-phibf(l)
            endif
            if(kz(jk).ne.8.and.-one*dphi.gt.pieni) dphi=dphi+pi          !hr06
            phi(l)=phi(l)+dphi
          enddo
  200   continue
        goto 740
!--NL-INSERTION
  210   ix=ix-nblo
        qu=zero
        qv=zero
        kpz=kp(ix)
        if(kpz.eq.6) goto 740
        kzz=kz(ix)
        if(kzz == 22) then
          do l=1,2
            ll=2*l
            if(abs(t(ll,ll-1)).gt.pieni) then
              phibf(l)=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))
            else
              phibf(l)=zero
            end if
            do i=1,ium
              puf=t(i,ll-1)
              t(i,ll-1)=(puf*rrtr(imtr(ix),ll-1,ll-1)+t(i,ll)*rrtr(imtr(ix),ll-1,ll))+dpr(i)*rrtr(imtr(ix),ll-1,6)
              t(i,ll)=(puf*rrtr(imtr(ix),ll,ll-1)+t(i,ll)*rrtr(imtr(ix),ll,ll))+dpr(i)*rrtr(imtr(ix),ll,6)
            end do
            t(1,ll-1)=t(1,ll-1)+cotr(imtr(ix),ll-1)
            t(1,ll)=t(1,ll)+cotr(imtr(ix),ll)
            beta(l)=t(ll,ll-1)**2+t(ll+1,ll-1)**2
            alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))
            if(abs(t(ll,ll-1)) > pieni) then
              dphi=atan_mb(t(ll+1,ll-1)/t(ll,ll-1))-phibf(l)
            else
              dphi=-one*phibf(l)
            end if
            if(-one*dphi.gt.pieni) dphi=dphi+pi
                        phi(l)=phi(l)+dphi
          enddo
        endif
        if(kzz.eq.0.or.kzz.eq.20.or.kzz.eq.22) goto 740
        if(kzz.eq.15) goto 740
! JBG RF CC Multipoles to 740
        if(kzz.eq.26.or.kzz.eq.27.or.kzz.eq.28) goto 740
        if(kzz.eq.-26.or.kzz.eq.-27.or.kzz.eq.-28) goto 740 
        dyy1=zero
        dyy2=zero
        if(iorg.lt.0) mzu(k)=izu
        izu=mzu(k)+1
        ekk=(sm(ix)+zfz(izu)*ek(ix))/(one+dpp)
        izu=izu+1
        xs=xpl(ix)+zfz(izu)*xrms(ix)
        izu=izu+1
        zs=zpl(ix)+zfz(izu)*zrms(ix)
#include "include/alignl.f90"
      
      select case (kzz)
      case (1) ! HORIZONTAL DIPOLE
        ekk=ekk*c1e3
#include "include/kicka01h.f90"
      case (2) ! NORMAL QUADRUPOLE
#include "include/kicka02h.f90"
      case (3) ! NORMAL SEXTUPOLE
        ekk=ekk*c1m3
#include "include/kicka03h.f90"
      case (4) ! NORMAL OCTUPOLE
        ekk=ekk*c1m6
#include "include/kicka04h.f90"
      case (5) ! NORMAL DECAPOLE
        ekk=ekk*c1m9
#include "include/kicka05h.f90"
      case (6) ! NORMAL DODECAPOLE
        ekk=ekk*c1m12
#include "include/kicka06h.f90"
      case (7) ! NORMAL 14-POLE
        ekk=ekk*c1m15
#include "include/kicka07h.f90"
      case (8) ! NORMAL 16-POLE
        ekk=ekk*c1m18
#include "include/kicka08h.f90"
      case (9) ! NORMAL 18-POLE
        ekk=ekk*c1m21
#include "include/kicka09h.f90"
      case (10) ! NORMAL 20-POLE
        ekk=ekk*c1m24
#include "include/kicka10h.f90"
      case (11)
        r0=ek(ix)
        if(abs(dki(ix,1)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl01.f90"
            do i=2,ium
#include "include/multl02.f90"
            end do
          else
#include "include/multl03.f90"
          end if
        end if
        if(abs(dki(ix,2)).gt.pieni) then
          if(abs(dki(ix,3)).gt.pieni) then
#include "include/multl04.f90"
            do i=2,ium
#include "include/multl05.f90"
            end do
          else
#include "include/multl06.f90"
          end if
        end if
        mpe=9
        mx=0
        if(abs(r0).le.pieni) goto 740
        nmz=nmu(ix)
        if(nmz.eq.0) then
          izu=izu+2*mmul
          goto 740
        end if
        im=irm(ix)
        r0a=one
        benkr=ed(ix)/(one+dpp)
        cr(1)=one
        cr(2)=xl
        ci(2)=zl
        cxzyr=xl
        cxzyi=zl
        cxzr=cxzyr
        cxzi=cxzyi
        dyy1=zero
        dyy2=zero
        qu=zero
        qv=zero
        lmin=3
        if(nmz.eq.1) lmin=2
        
        do l=lmin,mmul
          cr(l)=zero
          ci(l)=zero
        end do
        
        do l=1,nmz
#include "include/multl13.f90"
        end do
#ifdef TILT
#include "include/multl07e.f90"
#endif
        izu=(izu+2*mmul)-2*nmz                                           !hr06
      case (12,13,14,15,16,17,18,19,20,21,22,23)
        goto 740
      case (24) ! DIPEDGE ELEMENT
#include "include/kickadpe.f90"
      case (25) ! Solenoid
#include "include/kickaso1.f90"
      case (26,27,28)
        goto 740
        
        !-----------------
        !--SKEW ELEMENTS--
        !------------------
      case (-1) ! VERTICAL DIPOLE
        ekk=ekk*c1e3
#include "include/kicka01v.f90"
      case (-2) ! SKEW QUADRUPOLE
#include "include/kicka02v.f90"
      case (-3) ! SKEW SEXTUPOLE
        ekk=ekk*c1m3
#include "include/kicka03v.f90"
      case (-4) ! SKEW OCTUPOLE
        ekk=ekk*c1m6
#include "include/kicka04v.f90"
      case (-5) ! SKEW DECAPOLE
        ekk=ekk*c1m9
#include "include/kicka05v.f90"
      case (-6) ! SKEW DODECAPOLE
        ekk=ekk*c1m12
#include "include/kicka06v.f90"
      case (-7) ! SKEW 14-POLE
        ekk=ekk*c1m15
#include "include/kicka07v.f90"
      case (-8) ! SKEW 16-POLE
        ekk=ekk*c1m18
#include "include/kicka08v.f90"
      case (-9) ! SKEW 18-POLE
        ekk=ekk*c1m21
#include "include/kicka09v.f90"
      case (-10) ! SKEW 20-POLE
        ekk=ekk*c1m24
#include "include/kicka10v.f90"
        
      case default
        goto 740
      end select
      
      t(1,2)=t(1,2)+dyy1
      t(1,4)=t(1,4)+dyy2
      do i=2,ium
        if(kzz.eq.24) then
          t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          t(i,4)=(t(i,4)-t(i,3)*quz)-qvz*t(i,1)                        !hr06
#include "include/phas1so1.f90"
#include "include/phas2so1.f90"
#include "include/phas3so1.f90"
        else
          t(i,2)=(t(i,2)+t(i,1)*qu)-qv*t(i,3)                          !hr06
          t(i,4)=(t(i,4)-t(i,3)*qu)-qv*t(i,1)                          !hr06
        end if
      end do
      do l=1,2
        ll=2*l
        alfa(l)=-one*(t(ll,ll-1)*t(ll,ll)+t(ll+1,ll-1)*t(ll+1,ll))     !hr06
      end do
      if(mpe.gt.9.or.(mpe.eq.9.and.nmz.le.1)) goto 740
      if(mpe.lt.nta) goto 740
      if(mpe.gt.nte) mpe=nte
      if(nta.gt.2) goto 500
      if(mx.eq.-1.or.mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 500

!-----------------------------------------------------------------------
!  SKEW-QUADRUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        do l=2,nmz
          l1=l-1
          ab2(2)=ab2(2)+real(l1,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))               !hr06
        end do

  500   b1=beta(1)
        b2=beta(2)
        sb1=sqrt(b1)
        sb2=sqrt(b2)
        b(3,1)=b1
        b(1,3)=b2
        b(2,2)=sb1*sb2
        if(nta.gt.3) goto 520
        if(mpe.eq.2.or.(mpe.eq.9.and.nmz.le.2)) goto 650
        if(mx.eq.1.or.mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq&
     &.6.or.mx.eq.7) goto 520

!-----------------------------------------------------------------------
!  REGULAR-SEXTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=3,nmz
          l1=l-2
          ab1(3)=ab1(3)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(3)=ab2(3)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  520   b(4,1)=b1*sb1
        b(1,4)=b2*sb2
        b(3,2)=b1*sb2
        b(2,3)=b2*sb1
        if(nta.gt.4) goto 540
        if(mpe.eq.3.or.(mpe.eq.9.and.nmz.le.3)) goto 650
        if(mx.eq.2.or.mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq&
     &.7) goto 540

!-----------------------------------------------------------------------
!  REGULAR-OCTUPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=4,nmz
          l1=l-3
          ab1(4)=ab1(4)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(4)=ab2(4)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  540   b(5,1)=b1**2                                                     !hr06
        b(1,5)=b2**2                                                     !hr06
        b(4,2)=b(3,2)*sb1
        b(2,4)=b(2,3)*sb2
        b(3,3)=b1*b2
        if(nta.gt.5) goto 560
        if(mpe.eq.4.or.(mpe.eq.9.and.nmz.le.4)) goto 650
        if(mx.eq.3.or.mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7)        &
     &goto 560

!-----------------------------------------------------------------------
!  REGULAR-DEKAPOLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=5,nmz
          l1=l-4
          ab1(5)=ab1(5)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(5)=ab2(5)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  560   b(6,1)=b(5,1)*sb1
        b(1,6)=b(1,5)*sb2
        b(5,2)=b(4,2)*sb1
        b(2,5)=b(2,4)*sb2
        b(4,3)=b(4,2)*sb2
        b(3,4)=b(2,4)*sb1
        if(nta.gt.6) goto 580
        if(mpe.eq.5.or.(mpe.eq.9.and.nmz.le.5)) goto 650
        if(mx.eq.4 .or.mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 580

!-----------------------------------------------------------------------
!  REGULAR-12-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=6,nmz
          l1=l-5
          ab1(6)=ab1(6)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(6)=ab2(6)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  580   b(7,1)=b(6,1)*sb1
        b(1,7)=b(1,6)*sb2
        b(6,2)=b(5,2)*sb1
        b(2,6)=b(2,5)*sb2
        b(5,3)=b(5,2)*sb2
        b(3,5)=b(2,5)*sb1
        b(4,4)=b(3,4)*sb1
        if(nta.gt.7) goto 600
        if(mpe.eq.6.or.(mpe.eq.9.and.nmz.le.6)) goto 650
        if(mx.eq.5.or.mx.eq.6.or.mx.eq.7) goto 600

!-----------------------------------------------------------------------
!  REGULAR-14-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=7,nmz
          l1=l-6
          ab1(7)=ab1(7)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(7)=ab2(7)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  600   b(8,1)=b(7,1)*sb1
        b(1,8)=b(1,7)*sb2
        b(7,2)=b(7,1)*sb2
        b(2,7)=b(1,7)*sb1
        b(6,3)=b(5,3)*sb1
        b(3,6)=b(3,5)*sb2
        b(5,4)=b(4,4)*sb1
        b(4,5)=b(4,4)*sb2
        if(nta.gt.8) goto 620
        if(mpe.eq.7.or.(mpe.eq.9.and.nmz.le.7)) goto 650
        if(mx.eq.6.or.mx.eq.7) goto 620

!-----------------------------------------------------------------------
!  REGULAR-16-POLE;MULTIPOLES UP TO 9-TH ORDER
!-----------------------------------------------------------------------
        l2=1
        do l=8,nmz
          l1=l-7
          ab1(8)=ab1(8)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(8)=ab2(8)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
          l2=l2*l/l1
        end do

  620   b(9,1)=b(8,1)*sb1
        b(1,9)=b(1,8)*sb2
        b(8,2)=b(8,1)*sb2
        b(2,8)=b(1,8)*sb1
        b(7,3)=b(7,2)*sb2
        b(3,7)=b(2,7)*sb1
        b(6,4)=b(6,3)*sb2
        b(4,6)=b(3,6)*sb1
        b(5,5)=b(4,5)*sb1
        if(mpe.eq.8.or.(mpe.eq.9.and.nmz.le.8)) goto 650
        if(mx.eq.7) goto 640

!-----------------------------------------------------------------------
!  REGULAR-18-POLE
!-----------------------------------------------------------------------
        l2=1
        do l=9,nmz
          l1=l-8
          ab1(9)=ab1(9)+real(l2,fPrec)*(aa(l)*ci(l1)+bb(l)*cr(l1))             !hr06
          ab2(9)=ab2(9)+real(l2,fPrec)*(aa(l)*cr(l1)-bb(l)*ci(l1))             !hr06
         l2=l2*l/l1
        end do

  640   b(10,1)=b(9,1)*sb1
        b(1,10)=b(1,9)*sb2
        b(9,2)=b(9,1)*sb2
        b(2,9)=b(1,9)*sb1
        b(8,3)=b(8,2)*sb2
        b(3,8)=b(2,8)*sb1
        b(4,7)=b(3,7)*sb1
        b(7,4)=b(7,3)*sb2
        b(5,6)=b(4,6)*sb1
        b(6,5)=b(6,4)*sb2
!-----------------------------------------------------------------------
  650   do 670 np=1,mpe
          n2e=2*np
          do 660 nv=1,n2e
            n2=nv-np
            nn2=abs(n2)
            nn1=np-nn2
            re1=real(nn1,fPrec)*qxt+real(n2,fPrec)*qzt                               !hr06
            ip(np,nv)=int(re1+half)+ipt
            if(-one*re1.gt.pieni) ip(np,nv)=-int(abs(re1)+half)-ipt      !hr06
!--RE=DISTANCE FROM THE RESONANCE
            re(np,nv)=re1-real(ip(np,nv),fPrec)                          !hr06
            res=re(np,nv)/radi
           chy(np,nv)=cos_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*    &
     &phi(2))-res*etl) !hr06
           shy(np,nv)=sin_mb((real(nn1,fPrec)*phi(1)+real(n2,fPrec)*    &
     &phi(2))-res*etl) !hr06
  660     continue
  670   continue
        do 730 np=nta,mpe
          np2=np
          nkk=0
  680     nkk=nkk+1
          n2e=2*np2
          do 720 i=1,nkk
            do 710 nv=1,n2e
              nn2=abs(nv-np2)
              nv1=np2-nn2+(i-1)*2+1
              nv2=np-nv1+2
              rn2=real(nn2,fPrec)*half                                   !hr06
!--EVENESS OF N2
              mm=0
              gerad=rn2-aint(rn2)
              if(abs(gerad).le.pieni) mm=1
!--MM=0 =>N2 UNEVEN, MM=1 => N2 EVEN
              if (mm.eq.0) goto 690
              btc=(ab1(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab1(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
              goto 700
  690         btc=(ab2(np)*b(nv1,nv2))*chy(np2,nv)                       !hr06
              bts=(ab2(np)*b(nv1,nv2))*shy(np2,nv)                       !hr06
  700         rtc(np2,nv,np,i)=rtc(np2,nv,np,i)+btc
              rts(np2,nv,np,i)=rts(np2,nv,np,i)+bts
  710       continue
  720     continue
          np2=np2-2
          if(np2.ge.1) goto 680
  730   continue
  740 continue
      nnf(1)=1
      nnf(2)=1
      nnf(3)=2
      nz2(2)=2
      sea=sqrt(ep(1))
      seb=sqrt(ep(2))
      ea=ep(1)
      eb=ep(2)
      e(3,1)=one/eb
      e(1,3)=one/ea
      e(2,2)=(one/seb)/sea                                               !hr06
      nnf(4)=6
      nz2(3)=4
      e(4,1)=sea/eb
      e(1,4)=seb/ea
      e(3,2)=one/seb
      e(2,3)=one/sea
      nnf(5)=24
      nz2(4)=8
      e(5,1)=ea/eb
      e(1,5)=eb/ea
      e(4,2)=sea/seb
      e(2,4)=seb/sea
      e(3,3)=one
      nnf(6)=120
      nz2(5)=16
      e(6,1)=e(5,1)*sea
      e(1,6)=e(1,5)*seb
      e(5,2)=ea/seb
      e(2,5)=eb/sea
      e(4,3)=sea
      e(3,4)=seb
      nnf(7)=720
      nz2(6)=32
      e(7,1)=e(6,1)*sea
      e(1,7)=e(1,6)*seb
      e(6,2)=e(5,2)*sea
      e(2,6)=e(2,5)*seb
      e(5,3)=ea
      e(3,5)=eb
      e(4,4)=sea*seb
      nnf(8)=5040
      nz2(7)=64
      e(8,1)=e(7,1)*sea
      e(1,8)=e(1,7)*seb
      e(7,2)=e(6,2)*sea
      e(2,7)=e(2,6)*seb
      e(6,3)=ea*sea
      e(3,6)=eb*seb
      e(5,4)=ea*seb
      e(4,5)=sea*eb
      nnf(9)=40320
      nz2(8)=128
      e(9,1)=e(8,1)*sea
      e(1,9)=e(1,8)*seb
      e(8,2)=e(7,2)*sea
      e(2,8)=e(2,7)*seb
      e(7,3)=ea**2                                                       !hr06
      e(3,7)=eb**2                                                       !hr06
      e(6,4)=e(5,4)*sea
      e(4,6)=e(4,5)*seb
      e(5,5)=ea*eb
      nnf(10)=362880
      nz2(9)=256
      e(10,1)=e(9,1)*sea
      e(1,10)=e(1,9)*seb
      e(9,2)=e(8,2)*sea
      e(2,9)=e(2,8)*seb
      e(8,3)=e(7,3)*sea
      e(3,8)=e(3,7)*seb
      e(7,4)=e(6,4)*sea
      e(4,7)=e(4,6)*seb
      e(6,5)=e(5,5)*sea
      e(5,6)=e(5,5)*seb
      do 780 np=nta,nte
        vdt1=real(nnf(np),fPrec)/(real(nz2(np),fPrec)*pi)                            !hr06
        np2=np
        nkk=0
  750   nkk=nkk+1
        n2e=2*np2
        do 770 i=1,nkk
          do 760 nv=1,n2e
            n2=nv-np2
            nn2=abs(n2)
            nn1=np2-nn2
            nv1=nn1+(i-1)*2+1
            nv2=np-nv1+2
            nv11=nv1-1
            nv21=nv2-1
            nf1=nn1+i
            nf3=nkk-i+1
            nf4=nf3+nn2
            vdt2=vdt1*e(nv1,nv2)/                                       &
     &real(nnf(nf1)*nnf(i)*nnf(nf3)*nnf(nf4),fPrec) !hr06
            vdt3=real(nn2,fPrec)*ea+real(nn1,fPrec)*eb                               !hr06
            if(n2.ge.0) then
              vdt3=real(n2*nv21,fPrec)*ea+real(nn1*nv11,fPrec)*eb          !hr06
            end if
            rtc(np2,nv,np,i)=rtc(np2,nv,np,i)*vdt2*vdt3
            rts(np2,nv,np,i)=rts(np2,nv,np,i)*vdt2*vdt3
  760     continue
  770   continue
        np2=np2-2
        if(np2.ge.1) goto 750
  780 continue
  
  return

end subroutine subsea

+dk decoup
subroutine decoup
!-----------------------------------------------------------------------
!  DECOUPLING USING MATRIX ELEMENTS
!
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use mathlib_bouncer
      use crcoall
      use parpro
      use mod_common
      use mod_commons
      use mod_commont
      implicit none
      integer i,ierr,j,no
      real(kind=fPrec) aa,bb,d1,dpp,dsm,qw,qwc,sen,sn,ss
      dimension aa(6,6),bb(6),dsm(6),sn(6),sen(6),ss(6)
      dimension qwc(3),qw(2),d1(6)
      save
!-----------------------------------------------------------------------
      do i=1,6
        bb(i)=zero
        dsm(i)=zero
        sn(i)=zero
        sen(i)=zero
        ss(i)=zero
        d1(i)=zero

        do j=1,6
          aa(i,j)=zero
        end do
      end do

      do 20 i=1,3
        qwc(i)=zero
   20 continue
      dpp=zero
      write(lout,10000)
      call betalf(dpp,qw)
      call phasad(dpp,qwc)
      sen(1)=ta(3,1)
      sen(2)=ta(3,2)
      sen(3)=ta(4,1)
      sen(4)=ta(4,2)
      if(iskew.eq.1) then
        sen(5)=qwc(1)
        sen(6)=qwc(2)
      endif
      do 30 i=1,6
        if(iskew.eq.2.and.i.gt.4) goto 30
        if(i.le.4) then
          sn(i)=ed(nskew(i))
          dsm(i)=dsm0
          bb(i)=sen(i)
        else
          if (abs(el(nskew(i))).le.pieni) then
            sn(i)=ed(nskew(i))
          else
            sn(i)=ek(nskew(i))
          endif
          dsm(i)=dkq
          bb(i)=sen(i)-qwsk(i-4)
        endif
        ss(i)=sen(i)
   30 continue
      do 100 no=1,itcro
        do 40 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 40
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))+dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))+dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))+dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
          call betalf(dpp,qw)
          call phasad(dpp,qwc)
          aa(i,1)=(ta(3,1)-ss(1))/dsm(i)
          aa(i,2)=(ta(3,2)-ss(2))/dsm(i)
          aa(i,3)=(ta(4,1)-ss(3))/dsm(i)
          aa(i,4)=(ta(4,2)-ss(4))/dsm(i)
          if(iskew.eq.1) then
            aa(i,5)=(qwc(1)-ss(5))/dsm(i)
            aa(i,6)=(qwc(2)-ss(6))/dsm(i)
          endif
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-dsm(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-dsm(i)
            else
              ek(nskew(i))=ek(nskew(i))-dsm(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   40   continue
        if(iskew.eq.1) then
          call loesd(aa,bb,6,6,ierr)
        else if(iskew.eq.2) then
          call loesd(aa,bb,4,4,ierr)
        endif
        if(ierr.eq.1) call prror(64)
        do 50 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 50
          if(i.le.4) then
            ed(nskew(i))=ed(nskew(i))-bb(i)
          else
            if (abs(el(nskew(i))).le.pieni) then
              ed(nskew(i))=ed(nskew(i))-bb(i)
            else
              ek(nskew(i))=ek(nskew(i))-bb(i)
            endif
          endif
          if(kp(nskew(i)).eq.5) call combel(nskew(i))
   50   continue
        call betalf(dpp,qw)
        call phasad(dpp,qwc)
        ss(1)=ta(3,1)
        ss(2)=ta(3,2)
        ss(3)=ta(4,1)
        ss(4)=ta(4,2)
        if(iskew.eq.1) then
          ss(5)=qwc(1)
          ss(6)=qwc(2)
        endif
        write(lout,10010)
        write(lout,10020) no,sen(1),ss(1),sen(2),ss(2),sen(3),ss(3), sen&
     &(4),ss(4)
        write(lout,10030) bez(nskew(1)),sn(1),ed(nskew(1)),             &
     &bez(nskew(2)),sn                                                  &
     &(2),ed(nskew(2)),bez(nskew(3)),sn(3),ed(nskew(3)), bez            &
     &(nskew(4)),sn(4),ed(nskew(4))
        if(iskew.eq.1) then
          write(lout,10010)
          write(lout,10040) qwsk(1),qwc(1),qwsk(2),qwc(2)
          if (abs(el(nskew(5))).le.pieni) then
            write(lout,10060) sn(5),ed(nskew(5)),nskew(5),sn(6),ed      &
     &(nskew(6)), nskew(6)
          else
            write(lout,10060) sn(5),ek(nskew(5)),nskew(5),sn(6),ek      &
     &(nskew(6)), nskew(6)
          endif
        else if(iskew.eq.2) then
          write(lout,10010)
          write(lout,10050) qwc(1),qwc(2)
        endif
        do 60 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 60
          if(i.le.4) then
            d1(i)=abs(ss(i))
          else
            d1(i)=abs(ss(i)-qwsk(i-4))
          endif
   60   continue
        do 70 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 70
          if(d1(i).gt.dsi) goto 80
   70   continue
        return
   80   do 90 i=1,6
          if(iskew.eq.2.and.i.gt.4) goto 90
          if(i.le.4) then
            bb(i)=ss(i)
          else
            bb(i)=ss(i)-qwsk(i-4)
          endif
   90   continue
  100 continue
!-----------------------------------------------------------------------
      return
10000 format(t5,'---- ENTRY DECOUP ----')
10010 format(131('-'))
10020 format(/10x,'DECOUPLING ROUTINE  ITERATION #',i2// 30x,           &
     &'BEFORE         AFTER     DECOUPLING'// 17x,'   M(3,1)      ',2g15&
     &.5/ 17x,'   M(3,2)      ',2g15.5/ 17x,'   M(4,1)      ',2g15.5/ 17&
     &x,'   M(4,2)      ',2g15.5// 5x,'SKEW QUDRUPOLE STRENGTHS')
10040 format(10x,'Q-VARIATION' / 10x,                                   &
     &'Q-VALUE            THEORET.        AFTER     COMPENSATION'/ 10x, &
     &'HORIZONTAL     ',2g15.7/ 10x,'VERTICAL       ',2g15.7/)
10050 format(10x,'CURRENT TUNE' / 10x,'Q-VALUE'/ 10x,'HORIZONTAL     ', &
     &g15.7/ 10x,'VERTICAL       ',g15.7/)
10060 format(10x,'QUADRU.STRENGTH',2g15.8,'   INDEX ',i3/ 10x,          &
     &'               ',2g15.8,'         ',i3)
10030 format(14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,          &
     &g17.10/14x,a16,2x,g17.10,1x,g17.10/14x,a16,2x,g17.10,1x,g17.10)
end subroutine decoup

+dk utils ! Various utility functions

subroutine invert_tas(fma_tas_inv,fma_tas)
!-----------------------------------------------------------------------*
!  FMA                                                                  *
!  M.Fitterer & R. De Maria & K.Sjobak, BE-ABP/HSS                      *
!  last modified: 04-01-2016                                            *
!  purpose: invert the matrix of eigenvecors tas                        *
!           (code copied from postpr only that ta is here fma_tas)      *
!           x(normalized)=fma_tas^-1 x=fma_tas_inv x                    *
!           note: inversion method copied from subroutine postpr        *
!-----------------------------------------------------------------------*
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use matrix_inv
      use mod_commont
      use crcoall
      implicit none
      
      integer :: i,j            !iterators
      real(kind=fPrec), dimension(6,6), intent(inout) :: fma_tas !tas = normalisation matrix
      real(kind=fPrec), dimension(6,6), intent(out) :: fma_tas_inv !inverse of tas
      integer ierro                   !error messages
!     dummy variables
      real(kind=fPrec), dimension(6,6) :: tdummy !dummy variable for transposing the matrix
      integer, dimension(6) :: idummy !for matrix inversion
!     units: [mm,mrad,mm,mrad,mm,1]
!     invert matrix
!     - set values close to 1 equal to 1
      do i=1,6
         do j=1,6
            fma_tas_inv(i,j)=fma_tas(j,i)
         enddo
      enddo
      
      if(abs(fma_tas_inv(1,1)).le.pieni.and.abs(fma_tas_inv(2,2)).le.   &
     &pieni) then
        fma_tas_inv(1,1)=one
        fma_tas_inv(2,2)=one
      endif
      if(abs(fma_tas_inv(3,3)).le.pieni.and.abs(fma_tas_inv(4,4)).le.   &
     &pieni) then
        fma_tas_inv(3,3)=one
        fma_tas_inv(4,4)=one
      endif
      if(abs(fma_tas_inv(5,5)).le.pieni.and.abs(fma_tas_inv(6,6)).le.   &
     &pieni) then
        fma_tas_inv(5,5)=one
        fma_tas_inv(6,6)=one
      endif
      
!     - invert: dinv returns the transposed matrix
      call dinv(6,fma_tas_inv,6,idummy,ierro)
      if (ierro.ne.0) then
         write(lout,*) "Error in INVERT_TAS - Matrix inversion failed!"
         write(lout,*) "Subroutine DINV returned ierro=",ierro
         call prror(-1)
      endif
      
!     - transpose fma_tas_inv
      tdummy=fma_tas_inv
      do i=1,6
        do j=1,6
          fma_tas_inv(i,j)=tdummy(j,i)
        enddo
      enddo
end subroutine invert_tas

+dk sumpos
      subroutine sumpos
!-----------------------------------------------------------------------
!  SUBROUTINE TO SUMMARIZE THE RESULTS OF THE POSTPROCESSING
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      use parpro
      implicit none
      integer i,ierro,j
      real(kind=fPrec) d,dlost
      character(len=4) ch
      dimension d(60)
#ifdef CRLIBM
!     integer nchars
!     parameter (nchars=160)
      character(len=1601) ch1
      ! MAXF be kept in sync with value in function fround
      integer maxf,nofields
      parameter (maxf=30)
      parameter (nofields=60)
      character(len=maxf) fields(nofields)
      integer errno,nfields,nunit,lineno,nf
      real(kind=fPrec) fround
      data lineno /0/
#endif
      save
!-----------------------------------------------------------------------
      rewind 10
      do 10 i=1,1000
        ch=' '
#ifndef CRLIBM
        read(10,*,end=20,iostat=ierro) (d(j),j=1,60)
#endif
#ifdef CRLIBM
        read(10,'(A1600)',end=20,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
!       write (*,*) 'ch1:'//ch1//':'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
!       write (*,*) ':'//fields(1)//':'
!       write (*,*) ':'//fields(2)//':'
!       write (*,*) ':'//fields(3)//':'
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
#endif
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
        if(i.eq.1) write(lout,10000)
        if(abs(d(2)).gt.pieni) ch='LOST'
        if(d(22).ge.d(23)) then
          dlost=d(23)
        else
          dlost=d(22)
        endif
        write(lout,10010) nint(dlost),d(3),d(5),d(7),d(9),d(10),d(11),  &
     &d(12),nint(d(16)),nint(d(18)),d(19),d(21),ch,d(4),d(6),d(8),      &
     &d(13),nint(d(17)),d(20),d(25),d(14),d(15)
   10 continue
   20 rewind 10
#ifdef CRLIBM
      lineno=0
#endif
      write(lout,10020)
      do 30 i=1,1000
#ifndef CRLIBM
        read(10,*,end=40,iostat=ierro) (d(j),j=1,60)
#endif
#ifdef CRLIBM
        read(10,'(A1600)',end=40,iostat=ierro) ch1
        lineno=lineno+1
        ch1(1601:1601)='/'
        call splitfld(errno,10,lineno,nofields,nf,ch1,fields)
        do j=1,60
          if (nf.gt.0) then
            d(j)=fround(errno,fields,j)
!           write (*,*) 'd(j)',j,d(j)
            nf=nf-1
          endif
        enddo
#endif
        if(ierro.gt.0) then
          write(lout,*) '**ERROR**'
          write(lout,*) 'CORRUPTED INPUT FILE FOR SUMMARY OF THE',      &
     &' POSTPROCESSING ERROR # : ',ierro
          return
        endif
! Now we are using 60 for CPU in seconds
! But note that dnms is now found in word 59.
! and we always print the maximum DMMAC as NMAC
! or zero which should really be OK I think.
! N.B. If particle is lost nms is 0, so we set mmac to zero too 
      d(60)=real(nmac,fPrec)
      if (nint(d(59)).eq.0) d(60)=zero
      write(lout,10030) i,nint(d(59)),nint(d(60)),                      &
     &nint(d(59))*nint(d(24))
   30 continue
   40 continue
      write(lout,10040)
!-----------------------------------------------------------------------
      return
10000 format(/131('-')/t10,'SUMMARY OF THE POSTPROCESSING' //t1,128(    &
     &'-'), /t1,'|',8x,'|',11x,'|',11x,'|',12x,'|',11x,                 &
     &'|NORMALIZED | SLOPE  |',14x,'|',10x,'|',21x,'|', /t1,            &
     &'|  TURN  |   LINEAR  |   BETA-   | AMPLITUDES | MOMENTUM  |',    &
     &'PHASESPACE | OF THE |  NONLINEAR   |  NEAREST |',7x,'SMEAR OF',6x&
     &,'|', /t1,                                                        &
     &'| NUMBER |   TUNES   | FUNCTIONS |            | DEVIATION |',    &
     &' DISTANCE  |DISTANCE|  DETUNING    | RESONANCE|   THE EMITTANCES'&
     &  ,4x,'|',/t1,128('-'), /t1,                                      &
     &'|        |           |     [M]   |     [MM]   |           |',    &
     &'           |        |              |     |ORD.|',                &
     &'    [%]  |      [%]  |'/t1,128('-'))
10010 format(t1,'|',i8,'|X ',f9.5,'|X ',f9.4,'|X ',f10.6,'|',d11.4, '|',&
     &d11.4,'|',f8.4,'|X ',d12.5,'|X ',i3,'| ',i2,' |X ', f7.3,'|X+Y ', &
     &f7.3,'|' /t1,'|  ',a4,'  |Y ',f9.5,'|Y ',f9.4,'|Y ',f10.6,'|',11x,&
     &'|',11x,'|',8x,'|+/- ',d10.3,'|Y ',i3,'|    |Y ', f7.3,'|    ',7x,&
     &'|' /t1,'|',8x,'|QS ',f8.6,'|  ',9x,'|  ',10x,'|',11x, '|',11x,'|'&
     &,8x,'|Y ',d12.5,'|  ',3x,'|    |  ', 7x,'|    ',7x,'|' /t1,'|',8x,&
     &'|  ',9x,'|  ',9x,'|  ',10x,'|',11x, '|',11x,'|',8x,'|+/- ',d10.3,&
     &'|  ',3x,'|    |  ', 7x,'|    ',7x,'|'/t1,128('-'))
10020 format(/131('-')/t10,'RANDOM SETS USED' //                        &
     &'  CASE  |  # OF RANDOM SET  |  MAX. POSSIBLE SETS   |    ',      &
     &' SEED'/65('-'))
10030 format(3x,i2,13x,i2,19x,i2,13x,i8)
10040 format(65('-')//131('-'))
      end
      
+dk beam6d
subroutine beamint(np,track,param,sigzs,bcu,ibb,ne,ibtyp,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants

      use crcoall
      use parpro
      use parbeam, only : beam_expflag,beam_expfile_open
      implicit none

      integer ibb,ibbc,ibtyp,ne,np,nsli
      real(kind=fPrec) alpha,bcu,calpha,cphi,f,param,phi,salpha,sigzs,  &
     &sphi,tphi,track,star,phi2,cphi2,sphi2,tphi2
      dimension track(6,npart)
      dimension param(nele,18),bcu(nbb,12)
      dimension star(3,mbea)
      save
!-----------------------------------------------------------------------
      if (beam_expflag .eq. 0) then
         phi=param(ne,1)
         nsli=param(ne,2)
         alpha=param(ne,3)
         f=param(ne,4)/real(nsli,fPrec)
         phi2=param(ne,18)
      else if(beam_expflag .eq. 1) then
         alpha=param(ne,3)
         phi=param(ne,1)
         nsli=param(ne,2)
         !sepax=param(ne,4)     !Not actually used anywhere?
         !sepay=param(ne,5)     !Not actually used anywhere?
         f=param(ne,4)/real(nsli,fPrec)
         phi2=phi               !Note - phi2 is not a free parameter anymore
      else
         write(lout,'(a)') "ERROR in subroutine beamint"
         write(lout,'(a)') "beam_expflag was", beam_expflag
         write(lout,'(a)') " expected 0 or 1. This is a BUG!"
         call prror(-1)
      endif

      sphi=sin_mb(phi)
      sphi2=sin_mb(phi2)
      cphi=cos_mb(phi)
      cphi2=cos_mb(phi2)
      tphi=tan_mb(phi)
      tphi2=tan_mb(phi2)
      salpha=sin_mb(alpha)
      calpha=cos_mb(alpha)
!     define slices
      call stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
      call boost(np,sphi,cphi,tphi,salpha,calpha,track)
      call sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
      call boosti(np,sphi,cphi,tphi,salpha,calpha,track)
      return
end subroutine beamint

subroutine boost(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOST Boost Operation ********************************************
!    P,Q,E are all normalized by P0
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      implicit none

      integer i,np
      real(kind=fPrec) calpha,cphi,h,h1x,h1y,h1z,hd1,salpha,sphi,tphi,  &
     &track,x1,y1
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h=(track(6,i)+one)-sqrt(((one+track(6,i))**2-                   &!hr06
     &track(2,i)**2)-track(4,i)**2)                                      !hr06
        track(6,i)=((track(6,i)-(calpha*tphi)*track(2,i))               &!hr06
     &-(track(4,i)*salpha)*tphi)+h*tphi**2                               !hr06
        track(2,i)=(track(2,i)-(tphi*h)*calpha)/cphi                     !hr06
        track(4,i)=(track(4,i)-(tphi*h)*salpha)/cphi                     !hr06
        hd1=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/hd1
        h1y=track(4,i)/hd1
        h1z=one-(one+track(6,i))/hd1
        x1=((calpha*tphi)*track(5,i)+(one+(calpha*sphi)*h1x)*track(1,i))&!hr06
     &+((track(3,i)*salpha)*sphi)*h1x                                    !hr06
        y1=((salpha*tphi)*track(5,i)+(one+(salpha*sphi)*h1y)*track(3,i))&!hr06
     &+((track(1,i)*calpha)*sphi)*h1y                                    !hr06
        track(5,i)=track(5,i)/cphi+h1z*((sphi*calpha)*track(1,i)        &!hr06
     &+(sphi*salpha)*track(3,i))                                         !hr06
        track(1,i)=x1
        track(3,i)=y1
 1000 continue
      return
      end

      subroutine sbc(np,star,cphi,cphi2,nsli,f,ibtyp,ibb,bcu,track,ibbc)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!**SBC ***Synchro-Beam for headon collision**********************
!  call BBF  (table) disabled
!****************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      implicit none

      integer i,ibb,ibbc,ibbc1,ibtyp,jsli,np,nsli
      real(kind=fPrec) bbf0,bbfx,bbfy,bbgx,bbgy,bcu,costh,costhp,cphi,  &
     &dum,f,s,sepx,sepx0,sepy,sepy0,sfac,sinth,sinthp,sp,star,sx,       &
     &sy,track,cphi2
      dimension track(6,npart),bcu(nbb,12)
      dimension star(3,mbea),dum(13)
      save
!-----------------------------------------------------------------------
      do 2000 jsli=1,nsli
        do 1000 i=1,np
          s=(track(5,i)-star(3,jsli))*half
          !write(*,*)'JBG - cphi2',cphi2
          sp=s/cphi2 
          dum(1)=(bcu(ibb,1)+(two*bcu(ibb,4))*sp)+bcu(ibb,6)*sp**2       !hr06
          dum(2)=(bcu(ibb,2)+(two*bcu(ibb,9))*sp)+bcu(ibb,10)*sp**2      !hr06
          dum(3)=(bcu(ibb,3)+(bcu(ibb,5)+bcu(ibb,7))*sp)+               &!hr06
     &bcu(ibb,8)*sp**2                                                   !hr06
          dum(4)=dum(1)-dum(2)
          dum(5)=dum(4)**2+four*dum(3)**2                                !hr06
          if(ibbc.eq.1.and.(abs(dum(4)).gt.pieni.and.                   &
     &abs(dum(5)).gt.pieni)) then
            ibbc1=1
            dum(5)=sqrt(dum(5))
         else
            ibbc1=0
          endif
        !JBG New set of canonical set of variables at the Col point (CP)
          sepx0=(track(1,i)+track(2,i)*s)-star(1,jsli)                   !hr06
          sepy0=(track(3,i)+track(4,i)*s)-star(2,jsli)                   !hr06
          if(ibbc1.eq.1) then
            sfac=one
            if(dum(4).lt.zero) sfac=-one*one                             !hr06
            dum(6)=(sfac*dum(4))/dum(5)                                  !hr06
            dum(7)=dum(1)+dum(2)
            costh=half*(one+dum(6))
            if(abs(costh).gt.pieni) then
              costh=sqrt(costh)
            else
              costh=zero
            endif
            sinth=half*(one-dum(6))
            if(abs(sinth).gt.pieni) then
              sinth=(sfac)*sqrt(sinth)                              !hr06
            else
              sinth=zero
            endif
            if(dum(3).lt.zero) sinth=-one*sinth                          !hr06
            sy=sfac*dum(5)
            sx=(dum(7)+sy)*half
            sy=(dum(7)-sy)*half
            sepx=sepx0*costh+sepy0*sinth
            sepy=sepy0*costh-sepx0*sinth                                 !hr06
          else
            sx=dum(1)
            sy=dum(2)
            sepx=sepx0
            sepy=sepy0
          endif
          if(sx.gt.sy) then
            call bbf(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy,ibtyp)
          else
            call bbf(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx,ibtyp)
          endif
          bbfx=f*bbfx
          bbfy=f*bbfy
          bbgx=f*bbgx
          bbgy=f*bbgy
          if(ibbc1.eq.1) then
            dum(8)=two*((bcu(ibb,4)-bcu(ibb,9))+                        &!hr06
     &(bcu(ibb,6)-bcu(ibb,10))*sp)                                       !hr06
            dum(9)=(bcu(ibb,5)+bcu(ibb,7))+(two*bcu(ibb,8))*sp           !hr06
            dum(10)=(((dum(4)*dum(8)+(four*dum(3))*dum(9))/             &!hr06
     &dum(5))/dum(5))/dum(5)                                             !hr06
            dum(11)=sfac*(dum(8)/dum(5)-dum(4)*dum(10))
            dum(12)=(bcu(ibb,4)+bcu(ibb,9))+(bcu(ibb,6)+bcu(ibb,10))*sp  !hr06
      dum(13)=(sfac*((dum(4)*dum(8))*half+(two*dum(3))*dum(9)))/dum(5)   !hr06
            if(abs(costh).gt.pieni) then
              costhp=(dum(11)/four)/costh                                !hr06
            else
              costhp=zero
            endif
            if(abs(sinth).gt.pieni) then
              sinthp=((-one*dum(11))/four)/sinth                         !hr06
            else
              sinthp=zero
            endif
            track(6,i)=track(6,i)-                                      &!hr06
     &((((bbfx*(costhp*sepx0+sinthp*sepy0)+                             &!hr06
     &bbfy*(costhp*sepy0-sinthp*sepx0))+                                &!hr06
     &bbgx*(dum(12)+dum(13)))+bbgy*(dum(12)-dum(13)))/                  &!hr06
     &cphi)*half                                                         !hr06
            bbf0=bbfx
            bbfx=bbf0*costh-bbfy*sinth
            bbfy=bbf0*sinth+bbfy*costh
          else
            track(6,i)=track(6,i)-                                      &
     &(bbgx*(bcu(ibb,4)+bcu(ibb,6)*sp)+                                 &
     &bbgy*(bcu(ibb,9)+bcu(ibb,10)*sp))/cphi
          endif
          track(6,i)=track(6,i)-(bbfx*(track(2,i)-bbfx*half)+           &
     &bbfy*(track(4,i)-bbfy*half))*half
          track(1,i)=track(1,i)+s*bbfx
          track(2,i)=track(2,i)-bbfx
          track(3,i)=track(3,i)+s*bbfy
          track(4,i)=track(4,i)-bbfy
 1000   continue
 2000 continue
      return
      end

      subroutine boosti(np,sphi,cphi,tphi,salpha,calpha,track)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
! BOOSTI **************inverse boost *****************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      implicit none

      integer i,np
      real(kind=fPrec) calpha,cphi,det,h1,h1d,h1x,h1y,h1z,salpha,sphi,  &
     &tphi,track,x1,y1,z1
      dimension track(6,npart)
      save
!-----------------------------------------------------------------------
      do 1000 i=1,np
        h1d=sqrt(((one+track(6,i))**2-track(2,i)**2)-track(4,i)**2)      !hr06
        h1x=track(2,i)/h1d
        h1y=track(4,i)/h1d
        h1z=one-(one+track(6,i))/h1d
        h1=((track(6,i)+one)-sqrt(((one+track(6,i))**2-                 &!hr06
     &track(2,i)**2)-track(4,i)**2))*cphi**2                             !hr06
        det=one/cphi+tphi*((h1x*calpha+h1y*salpha)-h1z*sphi)             !hr06
        x1= (track(1,i)*(one/cphi+(salpha*(h1y-(h1z*salpha)*sphi))*tphi)&!hr06
     &+((track(3,i)*salpha)*tphi)*((h1z*calpha)*sphi-h1x))              &!hr06
     &-(track(5,i)*((calpha+((h1y*calpha)*salpha)*sphi)                 &!hr06
     &-(h1x*salpha**2)*sphi))*tphi                                       !hr06
        y1= (((track(1,i)*calpha)*tphi)*((h1z*salpha)*sphi-h1y)         &!hr06
     &+track(3,i)*(one/cphi+(calpha*(h1x-(h1z*calpha)*sphi))*tphi))     &!hr06
     &-(track(5,i)*(salpha-(h1y*calpha**2)*sphi                         &!hr06
     &+((h1x*calpha)*salpha)*sphi))*tphi                                 !hr06
        z1= (track(5,i)*((one+(h1x*calpha)*sphi)+(h1y*salpha)*sphi)     &!hr06
     &-((track(1,i)*h1z)*calpha)*sphi)-((track(3,i)*h1z)*salpha)*sphi    !hr06
        track(1,i)=x1/det
        track(3,i)=y1/det
        track(5,i)=z1/det
        track(6,i)=(track(6,i)+(calpha*sphi)*track(2,i))                &!hr06
     &+(salpha*sphi)*track(4,i)                                          !hr06
        track(2,i)=(track(2,i)*cphi+(calpha*tphi)*h1)                    !hr06
        track(4,i)=(track(4,i)*cphi+(salpha*tphi)*h1)                    !hr06
 1000 continue
      return
      end

      subroutine bbf(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy,ibtyp)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!-----------------------------------------------------------------------
!**BBF   without using table ******************************************
! gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
! beam-beam kicks except for the kinematical term (nr_e/\gamma)
! SIGXX is \Sigma
!**********************************************************************
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      implicit none

      integer ibtyp
      real(kind=fPrec) arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,     &
     &comfac,comfac2,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,sigyy, &
     &sqrpi2,wx1,wx2,wy1,wy2,x,xxyy
      data sqrpi2/3.544907701811032_fPrec/
      save
!-----------------------------------------------------------------------
      if(sigxx.eq.sigyy) then
        x=sepx**2+sepy**2
        xxyy=sigxx+sigyy
        const=zero
        if(abs(xxyy).gt.pieni) const=x/xxyy
        expfac=exp_mb(-one*const)                                        !hr06
        bbfx=zero
        bbfy=zero
        bbgx=zero
        bbgy=zero
        if(abs(x).gt.pieni) then
          bbfx=((two*sepx)*(one-expfac))/x                             !hr06
          bbfy=((two*sepy)*(one-expfac))/x                             !hr06
          comfac=sepy*bbfy-sepx*bbfx                                     !hr06
          comfac2=(abs(sigxx)+abs(sigyy))**2
          bbgx=(comfac+(((four*sepx**2)*const)/x)*expfac)/(two*x)         !hr06
          bbgy=((((four*sepy**2)*const)/x)*expfac-comfac)/(two*x)         !hr06
        endif
      else
        x=sepx**2/sigxx+sepy**2/sigyy
        fac2=two*abs(sigxx-sigyy)
        fac=sqrt(fac2)
        const=sqrpi2/fac
        sigxy=sqrt(sigxx/sigyy)
        arg1x=abs(sepx/fac)
        arg1y=abs(sepy/fac)
        if(ibtyp.eq.0) call errf(arg1x,arg1y,wy1,wx1)
        if(ibtyp.eq.1) call wzsub(arg1x,arg1y,wy1,wx1)
        if(x.lt.c1e2) then
          expfac=exp_mb(-half*x)                                        !hr06
          arg2x=arg1x/sigxy
          arg2y=arg1y*sigxy
          if(ibtyp.eq.0) call errf(arg2x,arg2y,wy2,wx2)
          if(ibtyp.eq.1) call wzsub(arg2x,arg2y,wy2,wx2)
          bbfx=const*(wx1-expfac*wx2)
          bbfy=const*(wy1-expfac*wy2)
          if(sepx.lt.0) bbfx=-one*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-one*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-one*(comfac+two*(expfac/sigxy -one)))/fac2              !hr06
          bbgy= (comfac+two*(expfac*sigxy -one))/fac2                    !hr06
        else
          bbfx=const*wx1
          bbfy=const*wy1
          if(sepx.lt.0) bbfx=-one*bbfx                                   !hr06
          if(sepy.lt.0) bbfy=-one*bbfy                                   !hr06
          comfac=sepx*bbfx+sepy*bbfy
          bbgx=(-one*(comfac-two))/fac2                                  !hr06
          bbgy= -one*bbgx                                                !hr06
        endif
      endif
      return
      end

      subroutine stsld(star,cphi2,sphi2,sigzs,nsli,calpha,salpha)
!-----------------------------------------------------------------------
!
!   Hirata's 6d beam-beam from BBC
!   SIXTRACK version courtesy Peter Leunissen
!   January 1999
!
!*******STSLD*********************************************************
!   makes longitudinal position of the strong slice for all slices
!*********************************************************************
!-----------------------------------------------------------------------
      use floatPrecision
      use mathlib_bouncer
      use numerical_constants
      use parpro
      implicit none
      integer i,nsli

      real(kind=fPrec) bord,bord1,border,calpha,cphi,cphi2,gauinv,pi,   &
     &salpha,sigz,sigzs,sphi,sphi2,star,yy
      dimension star(3,mbea)
!-----------------------------------------------------------------------
      data border /eight/
      save
!-----------------------------------------------------------------------
      pi=four*atan_mb(one)
      sigz=sigzs/cphi2
! DEFINE `STARRED' COORDINATES
!  BORD is longitudinal border star(3,mbea) is the barycenter of region
!  divided two borders.
      bord=+border
      do 101 i=nsli,1,-1
        yy=(one/real(nsli,fPrec))*real(i-1,fPrec)                        !hr06
        if(i.ne.1) bord1=gauinv(yy)                                      !hr06
        if(i.eq.1) bord1=-one*border                                     !hr06
        star(3,i)=(((exp_mb((-one*bord**2)*half)-                       &!hr06
     &exp_mb((-one*bord1**2)*half))/sqrt(two*pi))*real(nsli,fPrec))*sigz !hr06
        bord=bord1
        !JBG When doing slicing phi=0 for crab crossing
        ! star(1,i)=0.
        ! star(2,i)=0. 
        !JBG When doing slicing phi2 different tiltings of the strong beam
        star(1,i)=(star(3,i)*sphi2)*calpha
        star(2,i)=(star(3,i)*sphi2)*salpha  
        !star(1,i)=(star(3,i)*sphi)*calpha                                !hr06
        !star(2,i)=(star(3,i)*sphi)*salpha                                !hr06
 101  continue
      return
      end

function gauinv(p0)
!GAUINV***********************************************
!  INVERSE OF (INTEGRATED) NORMAL DISTRIBUTION FUNCTION
!              1         X= Y
!     P(Y)=-----------* INTEGRAL EXP(-X**2/2) DX
!          SQRT(2*PI)    X= -INF
!     IF P(Y)=P0, THEN GAUINV(P0)=Y.
!        0 < P0 < 1 ,   -INF < Y < +INF
!  IF THIS ROUTINE IS USED TO CONVERT UNIFORM RANDOM NUMBERS TO
!  GAUSSIAN, MAXIMUM RELATIVE ERROR IN THE DISTRIBUTION FUNCTION
!  DP/DX=EXP(-X**2/2)/SQRT(2*PI) IS LESS THAN 0.640E-3 EVERYWHERE
!  IN THE RANGE  2**(-31) < P0 < 1-2**31.  (MINIMAX APPROXIMATION)
      use floatPrecision
      use end_sixtrack
      use mathlib_bouncer
      use numerical_constants
      use crcoall
      implicit none
      real(kind=fPrec) a0,a1,a2,a3,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d0,d1, &
     &d2,d3,d4,e0,e1,e2,e3,e4,f0,f1,f2,gauinv,p,p0,p1,p2,pp1,q,qq2,qq3, &
     &qq4,qq5,t
!-----------------------------------------------------------------------
      data pp1/0.334624883253_fPrec/, qq2/0.090230446775_fPrec/,        &
     &qq3/0.049905685242_fPrec/, qq4/0.027852994157_fPrec/,             &
     &qq5/0.015645650215_fPrec/
      data a3/ 4.5585614e+01_fPrec/, a2/ 2.1635544_fPrec/,              &
     &a1/ 2.7724523_fPrec/, a0/ 2.5050240_fPrec/,                       &
     &b4/ 4.0314354e+02_fPrec/, b3/-2.7713713e+02_fPrec/,               &
     &b2/ 7.9731883e+01_fPrec/,                                         &
     &b1/-1.4946512e+01_fPrec/, b0/ 2.2157257_fPrec/,                   &
     &c4/ 4.1394487e+03_fPrec/, c3/-1.5585873e+03_fPrec/,               &
     &c2/ 2.4648581e+02_fPrec/,                                         &
     &c1/-2.4719139e+01_fPrec/, c0/ 2.4335936_fPrec/,                   &
     &d4/ 4.0895693e+04_fPrec/, d3/-8.5400893e+03_fPrec/,               &
     &d2/ 7.4942805e+02_fPrec/,                                         &
     &d1/-4.1028898e+01_fPrec/, d0/ 2.6346872_fPrec/,                   &
     &e4/ 3.9399134e+05_fPrec/, e3/-4.6004775e+04_fPrec/,               &
     &e2/ 2.2566998e+03_fPrec/,                                         &
     &e1/-6.8317697e+01_fPrec/, e0/ 2.8224654_fPrec/
      data f0/-8.1807613e-02_fPrec/, f1/-2.8358733_fPrec/,              &
     &f2/ 1.4902469_fPrec/
      save
!-----------------------------------------------------------------------
      p=p0-half
      p1=abs(p)
      if(p1.ge.pp1) goto 120
      p2=p**2
      gauinv=(((a3*p2+a2)*p2+a1)*p2+a0)*p
      return
 120  q=half-p1
      if(q.le.qq2) goto 140
      gauinv=(((b4*q+b3)*q+b2)*q+b1)*q+b0
      goto 200
 140  if(q.le.qq3) goto 150
      gauinv=(((c4*q+c3)*q+c2)*q+c1)*q+c0
      goto 200
 150  if(q.le.qq4) goto 160
      gauinv=(((d4*q+d3)*q+d2)*q+d1)*q+d0
      goto 200
 160  if(q.le.qq5) goto 170
      gauinv=(((e4*q+e3)*q+e2)*q+e1)*q+e0
      goto 200
 170  if(q.le.zero) goto 900
      t=sqrt(-two*log_mb(q))
      gauinv=(t+f0)+f1/(f2+t)                                            !hr06
 200  if(p.lt.zero) gauinv=-one*gauinv                                    !hr06
      return
 900  write(lout,910) p0
 910  format(' (FUNC.GAUINV) INVALID INPUT ARGUMENT ',1pd20.13)
      call prror(-1)
end function gauinv

+dk checkpt
subroutine crcheck
!     Thus subroutine checks if the C/R files fort.95 and fort.96 exists,
!     and if so tries to load them into the cr* variables.
!     This routine also repositions the output files for
!     fort.90..91-napx/2 or STF, DUMP, and DYNK (dynksets.dat).
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crstart.
      use floatPrecision
      use end_sixtrack
      use string_tools
      use numerical_constants
      use dynk, only : ldynk, ldynkfiledisable,                         &
           dynk_crcheck_readdata, dynk_crcheck_positionFiles

      use dump, only : dump_crcheck_readdata, dump_crcheck_positionFiles
      
      use scatter, only : scatter_active, scatter_crcheck_readdata,     &
     &     scatter_crcheck_positionFiles
      
      use, intrinsic :: iso_fortran_env, only : int32

      use crcoall
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      use mod_hions
      implicit none
+ca crco
#include "version.f90"
      integer i,j,k,l,m,ia
      integer lstring,myia,mybinrecs,binrecs94

      !DANGER: IF THE LENGTH OF THE RECORDS IN WRITEBIN(_HEADER)CHANGES,
      ! THESE ARRAYS MUST BE UPDATED
      integer(int32) hbuff,tbuff
      dimension hbuff(253),tbuff(35)
      
      logical lopen,lerror


#ifdef BOINC
      character(len=256) filename
#endif
      save
      restart=.false.
      read95=.false.
      read96=.false.
!     Some log entries to fort.93
      write(93,*)                                                       &
     &'SIXTRACR CRCHECK CALLED lout=',lout,'restart',restart,           &
     &'rerun',rerun,'checkp',checkp
      flush(93)
#ifdef DEBUG
                   !call system('../crcheck >> crlog')
#endif
!--   We are not checkpoint/restart or we have no restart files
      if (.not.checkp) goto 605
      if (.not.fort95.and..not.fort96) goto 605
!--   If we do we must have a fort.6 as they were created by CRPOINT
! NOT TRUE anymore??? We might be NOT rerun but using a Sixin.zip
#ifndef BOINC
      if (.not.rerun) then
        write(lout,*)                                                   &
     &'SIXTRACR CRCHECK *** ERROR *** ',                                &
     &'Found fort.95/fort.96 but NO fort.6'
        write(lout,*) 'SIXTRACR CRCHECK failure'
        call prror(-1)
      endif
#endif
!--   Check at least one restart file is readable
       write(93,*)                                                      &
     &'SIXTRACR CRCHECK checking fort.95/96'
       flush(93)
      if (fort95) then
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 1 VERSION'
        flush(93)
        
        rewind 95
        
        read(95,err=100,end=100)                                        &
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))   &
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.95 was written by "//    &
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//                            &
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."

           flush(93)

           goto 100
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 2'
        flush(93)
        
        read(95,err=100,end=100)                                        &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 3'
        flush(93)
        read(95,err=100,end=100)                                        &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)

      write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 5 DUMP'
      flush(93)
      call dump_crcheck_readdata(95,lerror)
      if (lerror) goto 100
      
      write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 5.5 HION'
      flush(93)
      call hions_crcheck_readdata(95,lerror)
      if (lerror) goto 100

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.95 Record 6 DYNK'
         flush(93)
         call dynk_crcheck_readdata(95,lerror)
         if (lerror) goto 100
      endif

      if(scatter_active) then
         write(93,*) "SIXTRACR CRCHECK reading fort.95 Record 7 SCATTER"
         flush(93)
         call scatter_crcheck_readdata(95,lerror)
         if (lerror) goto 100
      endif
      
!ERIC new extended checkpoint for synuthck
      if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.95
! We will re-read them in crstart to be sure they are restored correctly
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 8 extended vars fort.95',      &
     &' crnapxo=',crnapxo
          flush(93)
          read(95,end=100,err=100,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (95,iostat=ierro)
          write(93,*) 'CRCHECK read fort.95 EXTENDED OK'
          flush(93)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK leaving fort.95 for CRSTART EXTENDED'
          flush(93)
        endif
        read95=.true.
        goto 103
      endif
  100 if (.not.read95) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 95'
        flush(93)
      endif
      if (fort96) then
        write(93,*) 'CRCHECK trying fort.96 instead'
        flush(93)
        
        rewind 96

        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 1 VERSION'
        flush(93)

        read(96,err=101,end=101)                                        &
     &       cr_version,cr_moddate
        if ((cr_version .ne. version) .or. (cr_moddate .ne. moddate))   &
     &       then
           write(93,*) "SIXTRACR CRCHECK: fort.96 was written by "//    &
     &          "SixTrack version=", cr_version, "moddate=",cr_moddate
           write(93,*) "This is SixTrack "//                            &
     &          "version=",version,"moddate=",moddate
           write(93,*) "Version mismatch; giving up on this file."
           
           flush(93)
           
           goto 101
        endif
        
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 2'
        flush(93)
        read(96,err=101,end=101,iostat=ierro)                           &
     &crnumlcr,                                                         &
     &crnuml,                                                           &
     &crsixrecs,                                                        &
     &crbinrec,                                                         &
     &crbnlrec,                                                         &
     &crbllrec,                                                         &
     &crsythck,                                                         &
     &cril,                                                             &
     &crtime3,                                                          &
     &crnapxo,                                                          &
     &crnapx,                                                           &
     &cre0
        write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 3'
        flush(93)
      read(96,err=101,end=101,iostat=ierro)                             &
     &(crbinrecs(j),j=1,(crnapxo+1)/2),                                 &
     &(crnumxv(j),j=1,crnapxo),                                         &
     &(crnnumxv(j),j=1,crnapxo),                                        &
     &(crnlostp(j),j=1,crnapxo),                                        &
     &(crpstop(j),j=1,crnapxo),                                         &
     &(crxv(1,j),j=1,crnapxo),                                          &
     &(cryv(1,j),j=1,crnapxo),                                          &
     &(crxv(2,j),j=1,crnapxo),                                          &
     &(cryv(2,j),j=1,crnapxo),                                          &
     &(crsigmv(j),j=1,crnapxo),                                         &
     &(crdpsv(j),j=1,crnapxo),                                          &
     &(crdpsv1(j),j=1,crnapxo),                                         &
     &(crejv(j),j=1,crnapxo),                                           &
     &(crejfv(j),j=1,crnapxo),                                          &
     &(craperv(j,1),j=1,crnapxo),                                       &
     &(craperv(j,2),j=1,crnapxo),                                       &
     &(crxvl(1,j),j=1,crnapxo),                                         &
     &(crxvl(2,j),j=1,crnapxo),                                         &
     &(cryvl(1,j),j=1,crnapxo),                                         &
     &(cryvl(2,j),j=1,crnapxo),                                         &
     &(crdpsvl(j),j=1,crnapxo),                                         &
     &(crejvl(j),j=1,crnapxo),                                          &
     &(crsigmvl(j),j=1,crnapxo)

      write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 5 DUMP'
      flush(93)
      call dump_crcheck_readdata(96,lerror)
      if (lerror) goto 100

      if (ldynk) then
         write(93,*) 'SIXTRACR CRCHECK reading fort.96 Record 6 DYNK'
         flush(93)
         call dynk_crcheck_readdata(96,lerror)
         if (lerror) goto 101
      endif

      if(scatter_active) then
         write(93,*) "SIXTRACR CRCHECK reading fort.96 Record 7 SCATTER"
         flush(93)
         call scatter_crcheck_readdata(96,lerror)
         if (lerror) goto 101
      endif

!ERIC new extended checkpoint for synuthck
        if (crsythck) then
!ERICVARS
! and make sure we can read the extended vars before leaving fort.96
! We will re-read them in crstart to be sure they are correct
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK verifying Record 8 extended vars fort.96,',     &
     &' crnapxo=',crnapxo
          flush(93)
          write(93,*) 'CRCHECK verifying extended vars fort.96'
          flush(93)
          read(96,end=101,err=101,iostat=ierro)                         &
     &((((al(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &((((as(k,m,j,l),l=1,il),j=1,crnapxo),m=1,2),k=1,6),               &
     &(aek(j),j=1,crnapxo),                                             &
     &(afok(j),j=1,crnapxo),                                            &
     &(as3(j),j=1,crnapxo),                                             &
     &(as4(j),j=1,crnapxo),                                             &
     &(as6(j),j=1,crnapxo),                                             &
     &(co(j),j=1,crnapxo),                                              &
     &(dpd(j),j=1,crnapxo),                                             &
     &(dpsq(j),j=1,crnapxo),                                            &
     &(fi(j),j=1,crnapxo),                                              &
     &(fok(j),j=1,crnapxo),                                             &
     &(fok1(j),j=1,crnapxo),                                            &
     &(fokqv(j),j=1,crnapxo),                                           &
     &(g(j),j=1,crnapxo),                                               &
     &(gl(j),j=1,crnapxo),                                              &
     &(hc(j),j=1,crnapxo),                                              &
     &(hi(j),j=1,crnapxo),                                              &
     &(hi1(j),j=1,crnapxo),                                             &
     &(hm(j),j=1,crnapxo),                                              &
     &(hp(j),j=1,crnapxo),                                              &
     &(hs(j),j=1,crnapxo),                                              &
     &(rho(j),j=1,crnapxo),                                             &
     &(rhoc(j),j=1,crnapxo),                                            &
     &(rhoi(j),j=1,crnapxo),                                            &
     &(si(j),j=1,crnapxo),                                              &
     &(siq(j),j=1,crnapxo),                                             &
     &(sm1(j),j=1,crnapxo),                                             &
     &(sm12(j),j=1,crnapxo),                                            &
     &(sm2(j),j=1,crnapxo),                                             &
     &(sm23(j),j=1,crnapxo),                                            &
     &(sm3(j),j=1,crnapxo),                                             &
     &(wf(j),j=1,crnapxo),                                              &
     &(wfa(j),j=1,crnapxo),                                             &
     &(wfhi(j),j=1,crnapxo)
          backspace (96,iostat=ierro)
          write(93,*) 'SIXTRACR CRCHECK read fort.96 EXTENDED OK'
          flush(93)
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK, leaving fort.96 for CRSTART EXTENDED'
          flush(93)
        endif
        read96=.true.
        goto 103
      endif
  101 if (.not.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK, COULD NOT READ CHECKPOINT FILE 96'
        flush(93)
      endif
  103 continue
      
!--   If we have successfully read either fort.95 or fort.96
!--   we need to handle lost particles and ntwin .ne. 2
!--   Otherwise we just continue with checkpointing as requested
      if (read95.or.read96) then
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK read95',read95,'read96',read96,                 &
     &'crnapxo',crnapxo,'crbinrec',crbinrec,'napx',napx,                &
     &'sixrecs',sixrecs,'crsixrecs',crsixrecs,'crbnlrec',crbnlrec,      &
     &'crbllrec',crbllrec
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK crbinrecs ',                                    &
     &(crbinrecs(j),j=1,(crnapxo+1)/2)
        flush(93)
        
!--   First we position fort.6 to last checkpoint
        do j=1,crsixrecs
           read(6,'(a1024)',end=604,err=106,iostat=ierro) arecord
           sixrecs=sixrecs+1
        end do
        !This is not a FLUSH!
        endfile (6,iostat=ierro)
  604   backspace (6,iostat=ierro)
#ifdef DEBUG
                   !call system('../crcheck >> crlog')
#endif
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK found fort.6 sixrecs=',sixrecs
        flush(93)

!--   We may be re-running with a DIFFERENT number of turns (numl)
! Eric fix this later by reading numl for fort.90
        if (numl.ne.crnuml) then
          if (numl.lt.crnumlcr) then
            write(lout,*)                                               &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            write(93,*)                                                 &
     &'SIXTRACR CRCHECK *** ERROR *** New numl .lt. crnumlcr',          &
     &numl,crnumlcr
            flush(93)
            write(lout,*) 'SIXTRACR CRCHECK numl .lt. crnumlcr'
            call prror(-1)
          endif
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-sets numl in binary file headers from ',     &
     &crnuml,' to ',numl
          flush(93)

!--   Reposition binary files fort.90 etc. / singletrackfile.dat
          ! fort.94 = temp file where the data from fort.90 etc. is copied to and then back
#ifdef BOINC
          call boincrf('fort.94',filename)
          open(94,file=filename,form='unformatted',status='unknown')
#endif
#ifndef BOINC
          open(94,file='fort.94',form='unformatted',status='unknown')
#endif
#ifndef STF
          do ia=1,crnapxo/2,1
            ! First, copy crbinrecs(ia) records of data from fort.91-ia to fort.94
            mybinrecs=0
            binrecs94=0
            myia=91-ia
            !Copy header into integer array hbuff
            read(91-ia,err=105,end=105,iostat=ierro) hbuff
            mybinrecs=mybinrecs+1
            hbuff(51)=numl ! Reset the number of turns (not very elegant)
            write(94,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data
            do j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(91-ia,err=105,end=105,iostat=ierro)                &
     &(tbuff(k),k=1,17)
                write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(91-ia,err=105,end=105,iostat=ierro) tbuff
                write(94,err=105,iostat=ierro) tbuff
              endif
              mybinrecs=mybinrecs+1
            end do ! END "do j=2,crbinrecs(ia)"
            
            ! Second, copy crbinrecs(ia) records of data from fort.94 to fort.91-ia
            rewind 94
            rewind 91-ia
            !Copy header
            read(94,err=105,end=105,iostat=ierro) hbuff
            binrecs94=binrecs94+1
            write(91-ia,err=105,iostat=ierro) hbuff
            ! Copy particle tracking data into integer array tbuff
            do j=2,crbinrecs(ia)
              if(ntwin.ne.2) then
                read(94,err=105,end=105,iostat=ierro)                   &
     &(tbuff(k),k=1,17)
                write(91-ia,err=105,iostat=ierro) (tbuff(k),k=1,17)
              else
                read(94,err=105,end=105,iostat=ierro) tbuff
                write(91-ia,err=105,iostat=ierro) tbuff
              endif
              binrecs94=binrecs94+1
            end do ! END "j=2,crbinrecs(ia)"
            !This is not a FLUSH!
            endfile (91-ia,iostat=ierro)
            backspace (91-ia,iostat=ierro)
            rewind 94
         end do ! END "do ia=1,crnapxo/2,1"
#endif
#ifdef STF
          ! First, copy crbinrecs(ia)*(crnapx/2) records of data from singletrackfile.dat to fort.94
          mybinrecs=0
          !Copy headers
          do ia=1,crnapxo/2,1
             read(90,err=105,end=105,iostat=ierro) hbuff
             mybinrecs=mybinrecs+1
             hbuff(51)=numl ! Reset the number of turns (not very elegant)
             write(94,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(90,err=105,end=105,iostat=ierro)                &
     &                  (tbuff(k),k=1,17)
                   write(94,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(90,err=105,end=105,iostat=ierro) tbuff
                   write(94,err=105,iostat=ierro) tbuff
                endif
                mybinrecs=mybinrecs+1
             end do
          end do
          
          ! Second, copy crbinrecs(ia)*(crnapx/2) records of data from fort.94 to singletrackfile.dat
          rewind 94
          rewind 90
          binrecs94=0
          ! Copy header
          do ia=1,crnapxo/2,1
             read(94,err=105,end=105,iostat=ierro) hbuff
             binrecs94=binrecs94+1
             write(90,err=105,iostat=ierro) hbuff
          end do
          ! Copy particle tracking data
          do ia=1,crnapxo/2,1
             do j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                   read(94,err=105,end=105,iostat=ierro)                &
     &                  (tbuff(k),k=1,17)
                   write(90,err=105,iostat=ierro) (tbuff(k),k=1,17)
                else
                   read(94,err=105,end=105,iostat=ierro) tbuff
                   write(90,err=105,iostat=ierro) tbuff
                endif
                binrecs94=binrecs94+1
             enddo
          end do
          !This is not a FLUSH!
          endfile   (90,iostat=ierro)
          backspace (90,iostat=ierro)
#endif
          close(94)
        else !ELSE for "if(nnuml.ne.crnuml) then" -> here we treat nnuml.eq.crnuml, i.e. the number of turns have not been changed
!--  Now with the new array crbinrecs we can ignore files which are
!--  basically finished because a particle has been lost.......
!--  Just check crbinrecs against crbinrec
#ifndef STF
          ! Binary files have been rewritten; now re-position
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK re-positioning binary files'
          do ia=1,crnapxo/2,1
            myia=91-ia
            if (crbinrecs(ia).ge.crbinrec) then
              mybinrecs=0
              read(91-ia,err=102,end=102,iostat=ierro) hbuff
              do 11 j=2,crbinrecs(ia)
                if(ntwin.ne.2) then
                  read(91-ia,err=102,end=102,iostat=ierro)              &
     &(tbuff(k),k=1,17)
                else
                  read(91-ia,err=102,end=102,iostat=ierro) tbuff
                endif
              mybinrecs=mybinrecs+1
   11         continue
              !This is not a FLUSH!
              endfile (91-ia,iostat=ierro)
              backspace (91-ia,iostat=ierro)
             else ! Number of ecords written to this file < general number of records written
                  ! => Particle has been lost before last checkpoint, no need to reposition.
              write(93,*)                                               &
     &'SIXTRACR CRCHECK ignoring IA ',ia,' Unit ',myia
            endif
         end do ! END "do ia=1,crnapxo/2,1"
#endif
#ifdef STF
      mybinrecs=0
      ! Reposition headers
      do ia=1,crnapxo/2,1
         read(90,err=102,end=102,iostat=ierro) hbuff
         mybinrecs=mybinrecs+1
      end do
      !Reposition track records
      do ia=1,crnapxo/2,1
         do j=2,crbinrecs(ia)
            if(ntwin.ne.2) then !ntwin=1
               read(90,err=102,end=102,iostat=ierro)                    &
     &              (tbuff(k),k=1,17)
            else                !ntwin=2
               read(90,err=102,end=102,iostat=ierro) tbuff
            endif
            mybinrecs=mybinrecs+1
         end do
      enddo
#endif
      endif ! END "if (numl.ne.crnuml) then" and END else
      
      !reposition dynksets.dat
      if (ldynk .and.(.not.ldynkfiledisable) ) then
         write(93,*) "SIXTRACR CRCHECK REPOSITIONING dynksets.dat"
         flush(93)
         call dynk_crcheck_positionFiles
      endif !END if (ldynk .and.(.not.ldynkfiledisable) )
      
      !Reposition files for DUMP
      write(93,*) "SIXTRACR CRCHECK REPOSITIONING DUMP files"
      flush(93)
      call dump_crcheck_positionFiles
      
      if(scatter_active) then
         write(93,*)                                                    &
     &        "SIXTRACR CRCHECK REPOSITIONING scatter_log.txt"
         flush(93)
         call scatter_crcheck_positionFiles
         
      endif
      
!--     Set up flag for tracking routines to call CRSTART
        restart=.true.
        write(lout,'(a80)')                                                   &
     &runtim
        !Flush or truncate?
        endfile (lout,iostat=ierro)
        backspace (lout,iostat=ierro)
#ifdef DEBUG
                   !call system('../crcheck >> crlog')
#endif
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK restart=TRUE',' crnumlcr=',crnumlcr
        flush(93)
        return
      endif
      
      goto 605                  !Should not end up here -> checkpoint failed.
                                ! Start simulation over!

!--   Just abort if we cannot re-position/copy the binary files,
#ifndef STF
  102 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING fort.',      &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      write(lout,*) 'SIXTRACR CRCHECK failure positioning binary files'
      call prror(-1)
#endif
#ifdef STF
  102 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS RE-READING ',           &
     &'singletrackfile.dat for ia=',ia,' IOSTAT=',ierro
      write(lout,*)                                                     &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia)
      write(lout,*)'SIXTRACR CRCHECK failure positioning binary files'
      call prror(-1)
#endif
#ifndef STF
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING fort.',         &
     &myia,' IOSTAT=',ierro
      write(lout,*)'Unit',myia,                                         &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      write(lout,*)'SIXTRACR CRCHECK failure copying binary files'
      call prror(-1)
#endif
#ifdef STF
  105 write(lout,*)
      write(lout,*)                                                     &
     &'SIXTRACR CRCHECK *** ERROR ***, PROBLEMS COPYING particle pair', &
     &ia,' IOSTAT=',ierro, ' from/to singletrackfile.dat'
      write(lout,*)                                                     &
     &' mybinrecs',mybinrecs,' Expected crbinrecs=',crbinrecs(ia),      &
     &' binrecs94=',binrecs94
      write(lout,*)
      write(lout,*)'SIXTRACR CRCHECK failure copying binary files'
      call prror(-1)
#endif
!--  We are not checkpointing or we have no checkpoints
!--  or we have no readable checkpoint
!--  If not checkpointing we can just give up on lout and use
!--  fort.6. We don't need to count records at all
  605 write(93,*)                                                       &
     &'SIXTRACR CRCHECK no restart possible checkp=',checkp
      flush(93)
      if (.not.checkp) then
        if (rerun) then
!--   we nevertheless have an existing fort.6
!--   we will just overwrite it for now and delete
!--   92 to avoid abend copying it again
          write(93,*)                                                   &
     &'SIXTRACR CRCHECK overwriting fort.6'
          flush(93)
        endif
!--   and just use fort.6 from now on
        write(93,*)                                                     &
     &'SIXTRACR CRCHECK giving up on LOUT'
        flush(93)
#ifdef DEBUG
                   !call system('../crcheck >> crlog')
#endif
!--   Copy the lout to fort.6 (the file, not output_unit)
!     It seems that FORTRAN will open the file automatically?
!     There are no open(unit=6) etc. calls anywhere...
        rewind lout
    3   read(lout,'(a1024)',end=1,err=107,iostat=ierro) arecord
        lstring=1024
        do i=1024,2,-1
          lstring=i
          if (arecord(i:i).ne.' ')goto 2
          lstring=lstring-1
        enddo
    2   write(6,'(a)') arecord(1:lstring)
        goto 3
        !Not a flush?
    1   endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        !This is not a FLUSH!
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
#ifdef DEBUG
                   !call system('../crcheck >> crlog')
#endif
        lout=6
      endif
      return
 106  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.6, iostat=',ierro
      write(93,*)                                                       &
     &'sixrecs=',sixrecs,' crsixrecs=',crsixrecs
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.6'
      call prror(-1)
 107  write(93,*)                                                       &
     &'SIXTRACR CRCHECK *** ERROR *** reading fort.92, iostat=',ierro
      flush(93)
      write(lout,*)'SIXTRACR CRCHECK failure positioning fort.92'
      call prror(-1)
end subroutine crcheck

subroutine crpoint
!     This subroutine writes the checkpoint data to fort.95/96,
!     and copies the new output from the temporary (lout/fort.92) output file into fort.6.
!     
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutine crcheck and crstart.
      use floatPrecision
      use end_sixtrack
      use numerical_constants

      use dynk, only : ldynk,dynk_getvalue,dynk_fSets_cr,dynk_cSets_unique,dynk_nSets_unique,dynkfilepos,dynk_crpoint

      use dump, only : dump_crpoint
      
      use scatter, only : scatter_active, scatter_crpoint
      
      use crcoall
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond
      use mod_hions
      implicit none

#include "version.f90"
+ca crco
      integer i,j,l,k,m
      integer lstring,osixrecs,ncalls
      logical lerror
#ifdef BOINC
      character(len=256) filename
#endif
      data ncalls /0/
      save
!     call system('echo "CPSTART `date`" >> crtimes')
#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.nnuml-20) then
#endif
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED numlmax=',numlmax,' numlcp=',numlcp
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED lout=',lout,' numx=',numx,'numl',numl
        write(93,*)                                                     &
     &'SIXTRACR CRPOINT CALLED binrec/sixrec ',binrec,sixrecs
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
#ifndef DEBUG
      endif
#endif
      ncalls=ncalls+1
      if (restart) then
        restart=.false.
        return
      endif
!--   We need to copy fort.92 (lout) to fort.6 (sixrecs)
!--   (if it exists and we are not already using fort.6)
#ifdef DEBUG
                   !call system('../crpoint >> crlog')
#endif
      osixrecs=sixrecs
      rewind lout
    3 read(lout,'(a1024)',end=1,err=101,iostat=ierro) arecord
      lstring=1024
      do i=1024,2,-1
        lstring=i
        if (arecord(i:i).ne.' ') goto 2
        lstring=lstring-1
      enddo
    2 write(6,'(a)',err=102,iostat=ierro) arecord(1:lstring)
      sixrecs=sixrecs+1
      goto 3
    1 if (sixrecs.ne.osixrecs) then
        endfile (6,iostat=ierro)
        backspace (6,iostat=ierro)
        rewind lout
        endfile (lout,iostat=ierro)
        close(lout)
#ifdef DEBUG
                   !call system('../crpoint >> crlog')
#endif
#ifdef BOINC
        call boincrf('fort.92',filename)
        open(lout,file=filename,form='formatted',status='unknown')
#endif
#ifndef BOINC
        open(lout,file='fort.92',form='formatted',status='unknown')
#endif
#ifndef DEBUG
        if (ncalls.le.5.or.numx.ge.numl) then
#endif
          write(93,*)                                                   &
     &'SIXTRACR CRPOINT copied lout=',lout,'sixrecs=',sixrecs
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
      else
        rewind lout
      endif
      call timex(time3)
! Hope this is correct
! Maybe not!!!! this should be accumulative over multiple C/Rs
      time3=(time3-time1)+crtime3
      crnumlcr=numx+1

      if (ldynk) then ! Store current settings of elements affected by DYNK
#ifndef DEBUG
         if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
            write(93,*) 'SIXTRACR CRPOINT filling dynk_fSets_cr'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
#ifndef DEBUG
         endif
#endif
         do j=1,dynk_nSets_unique
            dynk_fSets_cr(j) =                                          &
     &           dynk_getvalue(dynk_cSets_unique(j,1),                  &
     &                         dynk_cSets_unique(j,2))
         end do

!c$$$         write (93,*) "Contents: (dynk_nSets_unique=",
!c$$$     &        dynk_nSets_unique,")"
!c$$$         do j=1,dynk_nSets_unique
!c$$$            write(93,*) dynk_cSets_unique(j,1),dynk_cSets_unique(j,2),
!c$$$     &                  dynk_fSets_cr(j)
!c$$$         enddo
!c$$$         write(93,*) "DONE"
!c$$$         endfile (93,iostat=ierro)
!c$$$         backspace (93,iostat=ierro)
      end if

#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
        write(93,*) 'SIXTRACR CRPOINT writing fort.95'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
#ifndef DEBUG
      endif
#endif
      rewind 95
      write(95,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(95,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(95,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (95,iostat=ierro)
      backspace (95,iostat=ierro)

#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.95'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
#ifndef DEBUG
      endif
#endif
      call dump_crpoint(95, lerror,ierro)
      if (lerror) then
         goto 100
      endif
      
#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
        write(93,*) 'SIXTRACR CRPOINT writing HION vars fort.95'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
#ifndef DEBUG
      end if
#endif
      call hions_crpoint(95,lerror,ierro)
      if (lerror) then
        goto 100
      end if
      
      if (ldynk) then
#ifndef DEBUG
        if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
        call dynk_crpoint(95,lerror,ierro)
        if (lerror) goto 100
      endif
      
      if (scatter_active) then
#ifndef DEBUG
         if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
            write(93,*) 'SIXTRACR CRPOINT writing SCATTER vars fort.95'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
#ifndef DEBUG
         endif
#endif
         call scatter_crpoint(95,lerror,ierro)
         if (lerror) goto 100
      endif
      
      if (sythckcr) then
#ifndef DEBUG
        if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
!ERIC new extended checkpoint for synuthck
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.95'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
        if(ithick.eq.1) then
#ifndef DEBUG
          if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//      &
     & ' for THICK to fort.95'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
#ifndef DEBUG
          endif
#endif
          write(95,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile (95,iostat=ierro)
          backspace (95,iostat=ierro)
        endif
        
        write(95,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
        
        endfile (95,iostat=ierro)
        backspace (95,iostat=ierro)
      endif

!--   and finally a second checkpoint copy, or maybe not!
!--   Well, a second copy is indeed required as shown by testing
#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
        write(93,*) 'SIXTRACR CRPOINT writing fort.96'
        endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
#ifndef DEBUG
      endif
#endif
      rewind 96
      write(96,err=100,iostat=ierro)                                    &
     &     version, moddate
      write(96,err=100,iostat=ierro)                                    &
     &crnumlcr,                                                         &
     &numl,                                                             &
     &sixrecs,                                                          &
     &binrec,                                                           &
     &bnlrec,                                                           &
     &bllrec,                                                           &
     &sythckcr,                                                         &
     &il,                                                               &
     &time3,                                                            &
     &napxo,                                                            &
     &napx,                                                             &
     &e0
      write(96,err=100,iostat=ierro)                                    &
     &(binrecs(j),j=1,(napxo+1)/2),                                     &
     &(numxv(j),j=1,napxo),                                             &
     &(nnumxv(j),j=1,napxo),                                            &
     &(nlostp(j),j=1,napxo),                                            &
     &(pstop(j),j=1,napxo),                                             &
     &(xv(1,j),j=1,napxo),                                              &
     &(yv(1,j),j=1,napxo),                                              &
     &(xv(2,j),j=1,napxo),                                              &
     &(yv(2,j),j=1,napxo),                                              &
     &(sigmv(j),j=1,napxo),                                             &
     &(dpsv(j),j=1,napxo),                                              &
     &(dpsv1(j),j=1,napxo),                                             &
     &(ejv(j),j=1,napxo),                                               &
     &(ejfv(j),j=1,napxo),                                              &
     &(aperv(j,1),j=1,napxo),                                           &
     &(aperv(j,2),j=1,napxo),                                           &
     &(xvl(1,j),j=1,napxo),                                             &
     &(xvl(2,j),j=1,napxo),                                             &
     &(yvl(1,j),j=1,napxo),                                             &
     &(yvl(2,j),j=1,napxo),                                             &
     &(dpsvl(j),j=1,napxo),                                             &
     &(ejvl(j),j=1,napxo),                                              &
     &(sigmvl(j),j=1,napxo)
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)

#ifndef DEBUG
      if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
         write(93,*) 'SIXTRACR CRPOINT writing DUMP vars fort.96'
         endfile (93,iostat=ierro)
         backspace (93,iostat=ierro)
#ifndef DEBUG
      endif
#endif
      call dump_crpoint(95, lerror,ierro)
      if (lerror) then
         goto 100
      endif

      if (ldynk) then
#ifndef DEBUG
        if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
          write(93,*) 'SIXTRACR CRPOINT writing DYNK vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
        call dynk_crpoint(96,lerror,ierro)
        if (lerror) goto 100
      endif
      
      if (scatter_active) then
#ifndef DEBUG
         if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
            write(93,*) 'SIXTRACR CRPOINT writing SCATTER vars fort.96'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
#ifndef DEBUG
         endif
#endif
         call scatter_crpoint(96,lerror,ierro)
         if (lerror) goto 100
      endif
      
      if (sythckcr) then
!ERIC new extended checkpoint for synuthck
#ifndef DEBUG
        if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
          write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars fort.96'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
#ifndef DEBUG
        endif
#endif
        if (ithick.eq.1) then
#ifndef DEBUG
          if (ncalls.le.20.or.numx.ge.numl-20) then
#endif
            write(93,*) 'SIXTRACR CRPOINT writing EXTENDED vars'//      &
     & ' for THICK to fort.96'
            endfile (93,iostat=ierro)
            backspace (93,iostat=ierro)
#ifndef DEBUG
          endif
#endif
          write(96,err=100,iostat=ierro)                                &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endfile   (96,iostat=ierro)
          backspace (96,iostat=ierro)
        endif
        
        write(96,err=100,iostat=ierro)                                  &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)

      endif
      endfile (96,iostat=ierro)
      backspace (96,iostat=ierro)
#ifdef DEBUG
                   !call system('../crpoint >> crlog')
#endif
#ifdef DEBUG
!ERIC
!     call dump('1st Checkpoint',numx,i)
!     call abend('SIXTRACR CHECKPOINT written                       ')
#endif
!     call system('echo "CPEND   `date`" >> crtimes')
  104 return
  100 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing checkpt file,iostat=',    &
     &ierro
      goto 103
  101 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** reading lout fort.92,iostat=',    &
     &ierro
      goto 103
  102 write(93,*)                                                       &
     &'SIXTRACR CRPOINT *** ERROR *** writing fort.6,iostat=',          &
     &ierro
  103 endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      write(lout,*)'SIXTRACR CHECKPOINT I/O Error'
      call prror(-1)
end subroutine crpoint

subroutine crstart
!     If we are restarting (restart is TRUE), this routine is called
!     in the beginning of the tracking loops.
!     It is used to copy the cr* variables to the normal variables,
!     e.g. crnapx -> napx etc.
!
!     The file fort.93 is used as a log file for the checkpoint/restarting.
!     
!     See also subroutines crpoint and crcheck.
      use floatPrecision
      use end_sixtrack
      use numerical_constants
      use dynk, only : ldynk, dynk_crstart

      use scatter, only: scatter_active, scatter_crstart
      
      use crcoall
      use parpro
      use mod_common
      use mod_commonmn
      use mod_commons
      use mod_commont
      use mod_commond

      use mod_alloc
      use mod_hions

      implicit none
+ca crco

      real(kind=fPrec) dynk_newValue

      integer j,l,k,m,i
      character(len=256) filename
      save
      write(93,*)                                                       &
     &'SIXTRACR CRSTART called crnumlcr',crnumlcr
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      numlcr=crnumlcr
!--   We do NOT reset numl so that a run can be extended for
!--   for more turns from the last checkpoint
!--   but we need to worry about numxv, nnumxv
      binrec=crbinrec
      bnlrec=crbnlrec
      bllrec=crbllrec
      sythckcr=crsythck
! the crtime3 is required (crtime0/1 removed)
      napxo=crnapxo
      napx=crnapx
      e0=cre0
      e0f=sqrt(e0**2-nucm0**2)                                             !hr08
      write(93,*) 'CRSTART doing binrecs'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,(napxo+1)/2
        binrecs(j)=crbinrecs(j)
      enddo
      write(93,*) 'CRSTART doing normal NPART vars'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
      do j=1,napxo
        numxv(j)=crnumxv(j)
        nnumxv(j)=crnnumxv(j)
        nlostp(j)=crnlostp(j)
        pstop(j)=crpstop(j)
        xv(1,j)=crxv(1,j)
        yv(1,j)=cryv(1,j)
        xv(2,j)=crxv(2,j)
        yv(2,j)=cryv(2,j)
        sigmv(j)=crsigmv(j)
        dpsv(j)=crdpsv(j)
        dpsv1(j)=crdpsv1(j)
! TEMPORARY? fix for crabamp/multipole problem
!       oidpsv(j)=croidpsv(j)
        oidpsv(j)=one/(one+dpsv(j))
        moidpsv(j)=mtc(j)/(one+dpsv(j))
        omoidpsv(j)=c1e3*((one-mtc(j))*oidpsv(j))
        ejv(j)=crejv(j)
        ejfv(j)=crejfv(j)
        rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
        aperv(j,1)=craperv(j,1)
        aperv(j,2)=craperv(j,2)
        xvl(1,j)=crxvl(1,j)
        xvl(2,j)=crxvl(2,j)
        yvl(1,j)=cryvl(1,j)
        yvl(2,j)=cryvl(2,j)
        dpsvl(j)=crdpsvl(j)
        ejvl(j)=crejvl(j)
        sigmvl(j)=crsigmvl(j)
        if (.not.pstop(j)) then
          numxv(j)=numl
          nnumxv(j)=numl
        endif
      enddo
!ERIC new extended checkpoint for synuthck
      
      if (ldynk) then
         call dynk_crstart
      endif

      if (scatter_active) then
         call scatter_crstart
      endif
      
      call hions_crstart
      
      if (crsythck) then
!ERICVARS now read the extended vars from fort.95/96.
        if (cril.ne.il) then
          write(lout,*)                                                 &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          write(93,*)                                                   &
     &' SIXTRACR CRSTART Problem as cril/il are different',             &
     &' cril=',cril,' il=',il
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          write(lout,*)                                                 &
     &         'SIXTRACR CRSTART Problem wih cril/il extended C/R'
          call prror(-1)
        endif
!ERICVARS now read the extended vars from fort.95/96.
#ifdef DEBUG
! Commented out code for multiple records
!       write(93,*) 'CRSTART DEBUG DUMP'
!       call dump('Before xcrstart',0,0)
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       write(93,*) 'CRSTART reading EXTENDED vars'
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
!       if (read95) then
!         i=1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(aek(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(afok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as4(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(as6(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(co(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpd(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(dpsq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fok1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(fokqv(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(g(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(gl(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hi1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hm(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hp(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(hs(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rho(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoc(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(rhoi(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(si(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(siq(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm1(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm12(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm2(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm23(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(sm3(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wf(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfa(j),j=1,napxo)
!         i=i+1
!         read(95,end=100,err=100,iostat=ierro)                         &
!    &(wfhi(j),j=1,napxo)
!         go to 102
!       endif
#endif
        if (read95) then
          if (ithick.eq.1) then
            read(95,end=100,err=100,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          
          read(95,end=100,err=100,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)
          write(93,*) 'CRSTART read fort.95 EXTENDED OK'
          endfile (93,iostat=ierro)
          backspace (93,iostat=ierro)
          go to 102
        endif
        if (read96) then
          if (ithick.eq.1) then
            read(96,end=101,err=101,iostat=ierro)                       &
     &((((al(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6),                 &
     &((((as(k,m,j,l),l=1,il),j=1,napxo),m=1,2),k=1,6)
          endif
          read(96,end=101,err=101,iostat=ierro)                         &
     &(aek(j),j=1,napxo),                                               &
     &(afok(j),j=1,napxo),                                              &
     &(as3(j),j=1,napxo),                                               &
     &(as4(j),j=1,napxo),                                               &
     &(as6(j),j=1,napxo),                                               &
     &(co(j),j=1,napxo),                                                &
     &(dpd(j),j=1,napxo),                                               &
     &(dpsq(j),j=1,napxo),                                              &
     &(fi(j),j=1,napxo),                                                &
     &(fok(j),j=1,napxo),                                               &
     &(fok1(j),j=1,napxo),                                              &
     &(fokqv(j),j=1,napxo),                                             &
     &(g(j),j=1,napxo),                                                 &
     &(gl(j),j=1,napxo),                                                &
     &(hc(j),j=1,napxo),                                                &
     &(hi(j),j=1,napxo),                                                &
     &(hi1(j),j=1,napxo),                                               &
     &(hm(j),j=1,napxo),                                                &
     &(hp(j),j=1,napxo),                                                &
     &(hs(j),j=1,napxo),                                                &
     &(rho(j),j=1,napxo),                                               &
     &(rhoc(j),j=1,napxo),                                              &
     &(rhoi(j),j=1,napxo),                                              &
     &(si(j),j=1,napxo),                                                &
     &(siq(j),j=1,napxo),                                               &
     &(sm1(j),j=1,napxo),                                               &
     &(sm12(j),j=1,napxo),                                              &
     &(sm2(j),j=1,napxo),                                               &
     &(sm23(j),j=1,napxo),                                              &
     &(sm3(j),j=1,napxo),                                               &
     &(wf(j),j=1,napxo),                                                &
     &(wfa(j),j=1,napxo),                                               &
     &(wfhi(j),j=1,napxo)

      write(93,*) 'CRSTART read fort.96 EXTENDED OK'
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
          go to 102
        endif
  100   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 95 (extended)',  &
     &' iostat=',ierro
#ifdef DEBUG
! Multiple record debug code commented out
!       write(93,*) 'CRSTART This was the ith READ, I=',i
!       endfile (93,iostat=ierro)
!       backspace (93,iostat=ierro)
#endif
        go to 103
  101   write(93,*)                                                     &
     &'SIXTRACR CRSTART COULD NOT READ CHECKPOINT FILE 96 (extended)',  &
     &' iostat=',ierro
  103   endfile (93,iostat=ierro)
        backspace (93,iostat=ierro)
        write(lout,*)'SIXTRACR CRSTART Problem with extended checkpoint'
        call prror(-1)
      endif
  102 write(93,*)                                                       &
     &'SIXTRACR CRSTART six/crsix/bin recs',sixrecs,crsixrecs,binrec
      endfile (93,iostat=ierro)
      backspace (93,iostat=ierro)
#ifdef DEBUG
                   !call system('../crstart >> crlog')
#endif
!--   Just throw away our fort.92 stuff.
      rewind lout
      endfile (lout,iostat=ierro)
      close(lout)
#ifdef DEBUG
                   !call system('../crstart >> crlog')
#endif
#ifdef BOINC
      call boincrf('fort.92',filename)
      open(lout,file=filename,form='formatted',status='unknown')
#endif
#ifndef BOINC
      open(lout,file='fort.92',form='formatted',status='unknown')
#endif
! but also add the rerun message
      write(lout,'(a80)')                                                     &
     &runtim
      runtim(1:20)='SIXTRACR restarted: '
      write(lout,'(a80)')                                                     &
     &runtim
      endfile (lout,iostat=ierro)
      backspace (lout,iostat=ierro)
#ifdef DEBUG
                   !call system('../crstart >> crlog')
#endif
      return
  606 backspace (6,iostat=ierro)
      write(lout,*)                                                     &
     &' SIXTRACR CRSTART Problem re-positioning fort.6: sixrecs',       &
     &sixrecs,'crsixrecs',crsixrecs
      write(lout,*)'SIXTRACR CRSTART Problem fort.6'
      call prror(-1)
end subroutine crstart

+dk aux
!      logical function isnan(arg1,arg2)
logical function myisnan(arg1,arg2)
      use floatPrecision
      use mathlib_bouncer
      implicit none
      real(kind=fPrec) arg1,arg2
!      isnan=.false.
!      if(arg1.ne.arg2) isnan=.true.
      myisnan=.false.
      if(arg1.ne.arg2) myisnan=.true.
end function myisnan

subroutine datime(nd,nt)
      implicit none
! Fill common slate for usage by hmachi call as per z007 writeup.        !hr08
      common /slate/ isl(40)                                             !hr08

      integer isl                                                        !hr08
!
!-    call datime (nd,nt)   returns integer date   nd = yymmdd
!-                                  integer time   nt =   hhmm
!     integer nd,nt,mm(3),nn(3)
!     call idate (mm(1),mm(2),mm(3))
!     call itime (nn)
      character(len=8) date
      character(len=10) time
      character(len=5) zone
      integer values(8),mm(3),nd,nt
      save
      call date_and_time(date,time,zone,values)
      mm(3)=mod(values(1),100)
!     mm(3) = mod (mm(3),100)
      mm(2)=values(3)
      mm(1)=values(2)
      isl(1)= mm(3)                                                      !hr08
      isl(2)= mm(2)                                                      !hr08
      isl(3)= mm(1)                                                      !hr08
      isl(4)= values(5)                                                  !hr08
      isl(5)= values(6)                                                  !hr08
      isl(6)= 0                                                          !hr08
      nd = (mm(3)*100+mm(1))*100 + mm(2)
!     nt =            nn(1) *100 + nn(2)
      nt=values(5)*100+values(6)
      return
end subroutine datime

subroutine timest(r1)
  use mod_common, only : timestart
  implicit none
  real r1
  logical start
  data start /.false./
  save
  if (.not.start) then
    start=.true.
    call cpu_time(timestart)
  endif
  return
end subroutine timest

subroutine timex(r1)
  use mod_common, only : timestart
  implicit none
  real r1,timenow
  save
  call timest(0.0)
  call cpu_time(timenow)
  r1=timenow-timestart
  return
end subroutine timex
