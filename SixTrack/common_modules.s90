!     This file contains modules with variables that are used in all
!     parts of the code, such as lout and crlibm functions, accelerator structure,
!     particle arrays etc.

+dk crcoall
module crcoall
  !     Standard output unit
  !     For CR version, this is the "buffer file" fort.92;
  !     Otherwise write directly to "*" aka iso_fortran_env::output_unit (usually unit 6)
  implicit none
  
  integer lout
  save lout
end module crcoall
    
+dk fPrec
module floatPrecision
  use, intrinsic :: iso_fortran_env, only : real32, real64, real128
  
  implicit none
  
+if 32bitm
  integer, parameter :: fPrec = real32
+ei
+if 64bitm
  integer, parameter :: fPrec = real64
+ei
+if 128bitm
  integer, parameter :: fPrec = real128
+ei

end module floatPrecision

+dk physical_constants

module physical_constants
 ! Shared module for general physical constants.
 ! See: http://pdg.lbl.gov/2017/reviews/rpp2016-rev-phys-constants.pdf
 ! some values are not updated to ensure numerical compatability with older studies

  use floatPrecision
  
  implicit none
  
+if .not.fluka
  ! proton mass (MeV)
  real(kind=fPrec), parameter :: pmap = 938.271998_fPrec   !old
  ! real(kind=fPrec), parameter :: pmap = 938.2720813_fPrec  !2017

  ! electron mass (MeV) from PDG, 2002
  real(kind=fPrec), parameter :: pmae = 0.510998902_fPrec   !old
  ! real(kind=fPrec), parameter :: pmae = 0.5109989461_fPrec  !2017
+ei
+if fluka
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 08-12-2014
!     synch masses of proton and electron to values used by FLUKA
!     inserted in main code by the 'fluka' compilation flag
!     real(kind=fPrec), parameter :: pmap = 0.938272046e3_fPrec ! PDG 2014, Fluka-2011-dev
      real(kind=fPrec), parameter :: pmap = 0.938272310e3_fPrec ! PDG 20xx, Fluka-2011-pro
      real(kind=fPrec), parameter :: pmae = 0.510998928_fPrec   ! PDG 2014, Fluka-2011-dev
+ei

  ! classical electron radius
  real(kind=fPrec), parameter :: crade = 2.817940285e-15_fPrec    !old
  ! real(kind=fPrec), parameter :: crade = 2.8179403227e-15_fPrec   !2017
  
  ! speed of light
  real(kind=fPrec), parameter :: clight = 2.99792458e8_fPrec !exact

  ! Avogadro constant
  ! real(kind=fPrec), parameter :: fnavo=6.02214129e23_fPrec   !old
  real(kind=fPrec), parameter :: fnavo=6.022140857e23_fPrec  !2017

  ! Planck constant
  real(kind=fPrec), parameter :: planck=6.626070040e-34_fPrec

  ! Vacuum permittivity
  real(kind=fPrec), parameter :: eps0=8.854187817e-12_fPrec
  
end module physical_constants

+dk numerical_constants
module numerical_constants
  ! Shared module for numerical constants,
  ! to ensure that the same values (including round-off)
  ! is used throughout the program.
  
  use floatPrecision
  
  implicit none
  
  ! real(kind=fPrec), parameter :: eulergamma = 0.577215664901532860606512090082402431042159335939923598805_fPrec
  ! real(kind=fPrec), parameter :: pi         = 3.141592653589793238462643383279502884197169399375105820974_fPrec
  
  real(kind=fPrec), parameter :: pieni = 1e-38_fPrec

  real(kind=fPrec), parameter :: zero  = 0.0_fPrec
  real(kind=fPrec), parameter :: half  = 0.5_fPrec
  real(kind=fPrec), parameter :: one   = 1.0_fPrec
  real(kind=fPrec), parameter :: two   = 2.0_fPrec
  real(kind=fPrec), parameter :: three = 3.0_fPrec
  real(kind=fPrec), parameter :: four  = 4.0_fPrec
  real(kind=fPrec), parameter :: five  = 5.0_fPrec
  real(kind=fPrec), parameter :: six   = 6.0_fPrec
  real(kind=fPrec), parameter :: seven = 7.0_fPrec
  real(kind=fPrec), parameter :: eight = 8.0_fPrec
  real(kind=fPrec), parameter :: nine  = 9.0_fPrec

  real(kind=fPrec), parameter :: c1e1   = 1.0e1_fPrec
  real(kind=fPrec), parameter :: c1e2   = 1.0e2_fPrec
  real(kind=fPrec), parameter :: c1e3   = 1.0e3_fPrec
  real(kind=fPrec), parameter :: c1e4   = 1.0e4_fPrec
  real(kind=fPrec), parameter :: c1e5   = 1.0e5_fPrec
  real(kind=fPrec), parameter :: c1e6   = 1.0e6_fPrec
  real(kind=fPrec), parameter :: c1e7   = 1.0e7_fPrec
  real(kind=fPrec), parameter :: c1e8   = 1.0e8_fPrec
  real(kind=fPrec), parameter :: c1e9   = 1.0e9_fPrec
  real(kind=fPrec), parameter :: c1e10  = 1.0e10_fPrec
  real(kind=fPrec), parameter :: c1e12  = 1.0e12_fPrec
  real(kind=fPrec), parameter :: c1e13  = 1.0e13_fPrec
  real(kind=fPrec), parameter :: c1e15  = 1.0e15_fPrec
  real(kind=fPrec), parameter :: c1e16  = 1.0e16_fPrec

  real(kind=fPrec), parameter :: c2e3   = 2.0e3_fPrec
  real(kind=fPrec), parameter :: c4e3   = 4.0e3_fPrec
  real(kind=fPrec), parameter :: c180e0 = 180.0_fPrec

  real(kind=fPrec), parameter :: c1m1  = 1.0e-1_fPrec
  real(kind=fPrec), parameter :: c1m2  = 1.0e-2_fPrec
  real(kind=fPrec), parameter :: c1m3  = 1.0e-3_fPrec
  real(kind=fPrec), parameter :: c1m4  = 1.0e-4_fPrec
  real(kind=fPrec), parameter :: c1m5  = 1.0e-5_fPrec
  real(kind=fPrec), parameter :: c1m6  = 1.0e-6_fPrec
  real(kind=fPrec), parameter :: c1m7  = 1.0e-7_fPrec
  real(kind=fPrec), parameter :: c1m8  = 1.0e-8_fPrec
  real(kind=fPrec), parameter :: c1m9  = 1.0e-9_fPrec
  real(kind=fPrec), parameter :: c1m10 = 1.0e-10_fPrec
  real(kind=fPrec), parameter :: c1m12 = 1.0e-12_fPrec
  real(kind=fPrec), parameter :: c1m13 = 1.0e-13_fPrec
  real(kind=fPrec), parameter :: c1m15 = 1.0e-15_fPrec
  real(kind=fPrec), parameter :: c1m18 = 1.0e-18_fPrec
  real(kind=fPrec), parameter :: c1m21 = 1.0e-21_fPrec
  real(kind=fPrec), parameter :: c1m24 = 1.0e-24_fPrec
  real(kind=fPrec), parameter :: c1m36 = 1.0e-36_fPrec
  real(kind=fPrec), parameter :: c1m38 = 1.0e-38_fPrec

end module numerical_constants

+dk parpro
module parpro
  ! Shared module defining the sizes of key arrays
  ! This is (will be) the "access point" for resizing
  ! the size of the accelerator, the number of particles, etc.
  
  implicit none
  
  integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1, &
       nelb,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran, &
       nrco,ntr,nzfz

  !Maximum length of element names
  integer, parameter :: max_name_len = 48

  !Max number of particles
+if .not.bignpart.and..not.hugenpart
  parameter(npart = 64,nmac = 1)
+ei
+if bignpart.and..not.hugenpart
  !See also:
  ! - subroutine wzsubv
  parameter(npart = 2048,nmac = 1)
+ei
+if hugenpart.and..not.bignpart
  !See also:
  ! - subroutine wzsubv
  parameter(npart = 65536,nmac = 1)
+ei

  integer, parameter :: nele_initial = 6000 !Must be at least 1
  integer :: nele = -1
  
!Note: nzfz should be = 3*nblz+2*mmul*#MULTIPOLES,
! where #MULTIPOLES are the max number of multipoles in the lattice (up to nblz)
! For now, scale the number of multipoles (from nzfz) as is done in the "no-flag" version:
! 6000/20000 -> 30% multipoles
+if .not.collimat
+if bignblz
  parameter(nblo=2500,nper=16,nelb=140,nblz=200000,        &
       nzfz = 3000000,mmul = 20) !up to 60'000 multipoles
+ei
+if hugenblz
  parameter(nblo=2500,nper=16,nelb=280,nblz=400000,        &
       nzfz = 6000000,mmul = 20) !up to 120'000 multipoles -> 48MB/nzfz-array (20%)
+ei
+if .not.bignblz.and..not.hugenblz
  parameter(nblo=2500,nper=16,nelb=140,nblz=20000,         &
       nzfz = 300000,mmul = 20) !up to 6'000 multipoles
+ei
+ei ! / not collimat
+if collimat
+if beamgas
  parameter(nblo=10000,nper=16,nelb=140,nblz=200000,     &
       nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / beamgas
+if .not.beamgas
+if bignblz
  parameter(nblo=2500,nper=16,nelb=140,nblz=200000,        &
       nzfz = 1920000,mmul = 11) !up to 60'000 multipoles
+ei ! / bignblz
+if hugenblz
  parameter(nblo=2500,nper=16,nelb=140,nblz=400000,        &
       nzfz = 3840000,mmul = 11) !up to 120'000 multipoles (20%)
+ei ! / hugenblz
+if .not.bignblz.and..not.hugenblz
  parameter(nblo=2500,nper=16,nelb=140,nblz=15000,         &
       nzfz = 144000,mmul = 11) !up to 4500 multipoles
+ei ! / not bignblz
+ei ! / not beamgas
+ei ! / collimat


  parameter(nran = 2000000,ncom = 100, mran = 500, mpa = 6, nrco = 5, nema = 15)
  parameter(mcor = 10,mcop = mcor+6, mbea = 99)
  parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
  parameter(nmon1 = 600,ncor1 = 600)
  parameter(ntr = 20)
  
  ! Beam-beam lenses
+if .not.bignblz.and..not.hugenblz
  parameter(nbb = 350)
+ei
+if bignblz.or.hugenblz
  parameter(nbb = 500)
+ei

end module parpro

+dk parpro_scale
module parpro_scale
  ! Module for scaling array sizes defined in parpro
  ! by telling various other module to rescale their arrays;
  ! It is split off from parpro as a separate module
  ! in order to avoid circular dependencies.
  use parpro

  use mod_common,   only : mod_common_allocate_arrays,   mod_common_expand_arrays
  use mod_commonmn, only : mod_commonmn_allocate_arrays, mod_commonmn_expand_arrays
  use mod_commons,  only : mod_commons_allocate_arrays,  mod_commons_expand_arrays
  use mod_commond2, only : mod_commond2_allocate_arrays, mod_commond2_expand_arrays
  use aperture,     only : aperture_allocate_arrays,     aperture_expand_arrays
  use elens,        only : elens_allocate_arrays,        elens_expand_arrays
  use dump,         only : dump_allocate_arrays,         dump_expand_arrays
  use scatter,      only : scatter_allocate_arrays,      scatter_expand_arrays
  use bdex,         only : bdex_allocate_arrays,         bdex_expand_arrays
  use dynk,         only : dynk_allocate_arrays,         dynk_expand_arrays
  use wire,         only : wire_allocate_arrays,         wire_expand_arrays

  implicit none
contains

  subroutine allocate_arrays
    ! Allocate arrays scaling with the main memory parameters nele, npart, etc.
    implicit none

    !Set nele etc.
    nele = nele_initial

    !Call subroutines to actually allocate
    call mod_common_allocate_arrays
    call mod_commonmn_allocate_arrays
    call mod_commons_allocate_arrays
    call mod_commond2_allocate_arrays
    call aperture_allocate_arrays
    call elens_allocate_arrays
    call dump_allocate_arrays
    call scatter_allocate_arrays
    call bdex_allocate_arrays
    call dynk_allocate_arrays
    call wire_allocate_arrays

  end subroutine allocate_arrays

  subroutine expand_arrays(nele_request, npart_request, nblz_request)
    ! Change the allocation of the arrays scaling with the main memry parameter nele, npart, etc.
    implicit none
    integer, intent(in) :: nele_request, npart_request, nblz_request
    integer             :: nele_new, npart_new, nblz_new

    !Decide how much to actually expand -- set nele_new etc. based on some heuristic

    !Call sub-subroutines to actually expand
    call mod_common_expand_arrays(nele_new)
    call mod_commonmn_expand_arrays(nele_new)
    call mod_commons_expand_arrays(nele_new)
    call mod_commond2_expand_arrays(nele_new)
    call aperture_expand_arrays(nele_new)
    call elens_expand_arrays(nele_new)
    call dump_expand_arrays(nele_new)
    call scatter_expand_arrays(nele_new)
    call bdex_expand_arrays(nele_new)
    call dynk_expand_arrays(nele_new)
    call wire_expand_arrays(nele_new)

    !Update nele etc.
    nele = nele_new

  end subroutine expand_arrays

+if vvector
  subroutine allocate_thickarrays
    ! Kicks off the allocation of the thick tracking arrays
    use mod_commonmn, only : mod_commonmn_allocate_thickarrays
    use mod_commons,  only : mod_commons_allocate_thickarrays
    implicit none

    call mod_commonmn_allocate_thickarrays
    call mod_commons_allocate_thickarrays

  end subroutine allocate_thickarrays
+ei

end module parpro_scale

+dk mod_common
module mod_common
  use parpro
  use floatPrecision
  use mod_alloc
  use numerical_constants
  
  implicit none

+if time
  !To be deleted
  real(kind=fPrec) tcnst35,exterr35,zfz35
  integer icext35
  common/rand35/exterr35(nblz,40),icext35(nblz),zfz35(nzfz),        &
       tcnst35(nblz)
+ei

  ! common /erro/
  integer, save :: ierro
  character(len=max_name_len), save :: erbez
  
  ! common /kons/
  real(kind=fPrec), save :: pi,pi2,pisqrt,rad
  
  ! common /str/
  integer, save :: il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
  
  ! common /ell/
  real(kind=fPrec), allocatable, save :: ed(:),el(:),ek(:),sm(:) ! (nele)
  integer, allocatable, save :: kz(:),kp(:)  ! (nele)
  
  ! common /bbb/
  real(kind=fPrec), allocatable, save :: bbbx(:), bbby(:), bbbs(:) ! (nele)
  
  ! common /pla/
  real(kind=fPrec), allocatable, save :: xpl(:),xrms(:),zpl(:),zrms(:) ! (nele)
  
  !common /str2/
  integer, save :: mel(nblo),mtyp(nblo,nelb),mstr(nblo)

  ! common /mat/
  real(kind=fPrec), allocatable, save :: a(:,:,:) !(nele,2,6)
  real(kind=fPrec), save :: bl1(nblo,2,6),bl2(nblo,2,6)
  
  ! common /syos2/
  real(kind=fPrec), save :: rvf(mpa)
  
  ! common /tra1/
  real(kind=fPrec), save :: rat
  integer, save :: idfor, napx, napxo, numl, niu(2), numlr, nde(2), nwr(4), &
       ird, imc, irew, ntwin, iclo6, iclo6r, iver, ibidu, numlcp, numlmax, nnuml
  
  ! common /syn/
  real(kind=fPrec), save :: qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3), &
       crad,dppoff,sigmoff(nblz),tlen
  real(kind=fPrec), allocatable, save ::  hsyc(:), phasc(:) !(nele)
  integer, save :: iicav,ition,idp,ncy,ixcav
  integer, allocatable, save :: itionc(:) !(nele)
  
  ! common /corcom/
  real(kind=fPrec), save :: dpscor,sigcor
  integer, save :: icode,idam,its6d

  ! common /multi/
  real(kind=fPrec), allocatable, save :: bk0(:,:),ak0(:,:), bka(:,:),aka(:,:) !(nele,mmul)

  ! common /mult1/
  real(kind=fPrec), save :: benki
  real(kind=fPrec), allocatable, save :: benkc(:),r00(:) !(nele)
  integer, allocatable, save :: irm(:),nmu(:) !(nele)
  
  ! common /rand0/
  real(kind=fPrec), save :: zfz(nzfz)
  integer, save :: iorg,mzu(nblz),izu0,mmac,mcut
  character(len=max_name_len), allocatable, save :: bezr(:,:) !(3,nele)
  
  ! common /rand1/
  real(kind=fPrec), save :: exterr(nblz,40),extalign(nblz,3),tiltc(nblz),tilts(nblz)
  integer, save :: mout2,icext(nblz),icextal(nblz)
  
  ! common /beo/
  real(kind=fPrec), save :: aper(2),di0(2),dip0(2),ta(6,6)
  
  ! common /clo/
  real(kind=fPrec), save :: dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0
  integer, save :: itco,itcro,itqv,iout
  
  ! common /qmodi/
  real(kind=fPrec), save :: qw0(3),amp0
  integer, save :: iq(3),iqmod,iqmod6
  integer, allocatable, save :: kpa(:) !(nele)
  
  ! common /linop/
  character(len=max_name_len), allocatable, save :: bez(:), bezb(:), bezl(:) !(nele)
  real(kind=fPrec),  save :: elbe(nblo),eui,euii
  integer, save :: ilin,nt,iprint,ntco,nlin
  
  ! common /cororb/
  real(kind=fPrec), save :: betam(nmon1,2),pam(nmon1,2),betac(ncor1,2), &
       pac(ncor1,2),bclorb(nmon1,2)
  integer, save :: nhmoni,nhcorr,nvmoni,nvcorr
  integer, allocatable, save :: ncororb(:) !nele
  
  ! common /clos/
  real(kind=fPrec), save :: sigma0(2)
  integer, save :: iclo, ncorru,ncorrep
  
  ! common /combin/
  real(kind=fPrec), save :: ratio(ncom,20)
  real(kind=fPrec), allocatable, save :: ratioe(:) !(nele)
  integer, save :: icomb0(20),icomb(ncom,20),icoe
  integer, allocatable, save :: iratioe(:) !(nele)
  
  ! common/seacom/m21,m22,m23
  integer, save :: ise,ise1,ise2,ise3,mesa,mp,m21,m22,m23
  integer, allocatable, save :: isea(:) !(nele)
  
  ! common /subres/
  real(kind=fPrec), save :: qxt,qzt,tam1,tam2,totl
  integer, save :: isub,nta,nte,ipt
  
  ! common /secom/
  real(kind=fPrec), save :: rtc(9,18,10,5),rts(9,18,10,5)
  integer, save :: ire(12),ipr(5),irmod2
  
  ! common /secom1/
  real(kind=fPrec), save :: dtr(10)
  integer, save :: nre,nur,nch,nqc,npp,nrr(5),nu(5)
  
  ! common /postr/
  real(kind=fPrec), save :: dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2
  integer, save :: nstart,nstop,iskip,iconv,imad
  
  ! common /posti1/
  integer, save :: ipos,iav,iwg,ivox,ivoz,ires,ifh
  character(len=80), save :: toptit(5) !DANGER: If the len changes, CRCHECK will break.
  
  ! common /posti2/
  integer, save :: kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
  
  ! common /skew/
  real(kind=fPrec), save :: qwsk(2),betx(2),betz(2),alfx(2),alfz(2)
  integer, save :: iskew,nskew(6)
  
  ! common /pawc/
  real, save :: hmal(nplo)
  
  ! common /tit/
  character (len=80), save :: sixtit,commen !DANGER: If the len changes, CRCHECK will break.
  integer, save :: ithick
  
  ! common/co6d/
  real(kind=fPrec), save :: clo6(3),clop6(3)
  
  ! common /dkic/
  real(kind=fPrec), allocatable, save :: dki(:,:) !(nele,3)

  ! common /beam/
  real(kind=fPrec), save :: sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb), &
       clobeam(6,nbb),beamoff(6,nbb),track6d(6,npart),    &
       sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar
  real(kind=fPrec), allocatable, save :: parbe(:,:) !(nele,18)
  real(kind=fPrec), allocatable, save :: ptnfac(:) !(nele)
  integer, save :: nbeam,ibbc,ibeco,ibtyp,lhc
  
  ! common/trom/
  real(kind=fPrec), save :: cotr(ntr,6),rrtr(ntr,6,6)
  integer, allocatable, save ::  imtr(:) !(nele)
  
  ! common /bb6d/
  real(kind=fPrec), save :: bbcu(nbb,12)
  integer, save :: ibb6d,imbb(nblz)
  
  ! common /acdipco/
  real(kind=fPrec), allocatable, save :: acdipph(:) !(nele)
  integer, allocatable, save :: nturn1(:), nturn2(:), nturn3(:), nturn4(:) !(nele)
  
  ! common /crabco/
  real(kind=fPrec), allocatable, save :: crabph(:),crabph2(:),crabph3(:),crabph4(:) !(nele)
contains

  subroutine mod_common_allocate_arrays
    use crcoall

    implicit none

    integer stat

!    allocate(ed(nele),el(nele),ek(nele),sm(nele), STAT=stat)
!    if (stat.ne.0) goto 42

    call alloc(ed,nele,zero,'ed')
    call alloc(el,nele,zero,'el')
    call alloc(ek,nele,zero,'ek')
    call alloc(sm,nele,zero,'sm')

!    allocate(kz(nele),kp(nele), STAT=stat)
!    if (stat.ne.0) goto 42

    call alloc(kz,nele,0,'kz')
    call alloc(kp,nele,0,'kp')

!    allocate(bbbx(nele),bbby(nele),bbbs(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(bbbx,nele,zero,'bbbx')
    call alloc(bbby,nele,zero,'bbby')
    call alloc(bbbs,nele,zero,'bbbs')

!    allocate(xpl(nele),xrms(nele),zpl(nele),zrms(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(xpl,nele,zero,'xpl')
    call alloc(zpl,nele,zero,'zpl')
    call alloc(xrms,nele,zero,'xrms')
    call alloc(zrms,nele,zero,'zrms')

!    allocate(a(nele,2,6), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(a,nele,2,6,zero,'a')

!    allocate(hsyc(nele),phasc(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(hsyc,nele,zero,'hsyc')
    call alloc(phasc,nele,zero,'phasc')

!    allocate(itionc(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(itionc,nele,0,'itionc')

!    allocate(bk0(nele,mmul),ak0(nele,mmul), bka(nele,mmul),aka(nele,mmul), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(bk0,nele,mmul,zero,'bk0')
    call alloc(ak0,nele,mmul,zero,'ak0')
    call alloc(bka,nele,mmul,zero,'bka')
    call alloc(aka,nele,mmul,zero,'aka')

!    allocate(benkc(nele),r00(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(benkc,nele,zero,'benkc')
    call alloc(r00,nele,zero,'r00')

!    allocate(irm(nele),nmu(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(irm,nele,0,'irm')
    call alloc(nmu,nele,0,'nmu')

    allocate(bezr(3,nele), STAT=stat)
    if (stat.ne.0) goto 42
!    call alloc(bezr,3,nele,'','bezr')

!    allocate(kpa(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(kpa,nele,0,'kpa')

    allocate(bez(nele),bezb(nele),bezl(nele), STAT=stat)
    if (stat.ne.0) goto 42
!    call alloc(bez,nele,0,'bez')
!    call alloc(bezb,nele,0,'bezb')
!    call alloc(bezl,nele,0,'bezl')

!    allocate(ncororb(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(ncororb,nele,0,'ncororb')

!    allocate(ratioe(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(ratioe,nele,zero,'ratioe')

!    allocate(iratioe(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(iratioe,nele,0,'iratioe')

!    allocate(isea(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(isea,nele,0,'isea')

!    allocate(dki(nele,3), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(dki,nele,3,zero,'dki')

!    allocate(parbe(nele,18), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(parbe,nele,18,zero,'parbe')

!    allocate(ptnfac(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(ptnfac,nele,zero,'ptnfac')

!    allocate(imtr(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(imtr,nele,0,'imtr')

!    allocate(acdipph(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(acdipph,nele,zero,'acdipph')

!    allocate(nturn1(nele), nturn2(nele), nturn3(nele), nturn4(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(nturn1,nele,0,'nturn1')
    call alloc(nturn2,nele,0,'nturn2')
    call alloc(nturn3,nele,0,'nturn3')
    call alloc(nturn4,nele,0,'nturn4')

!    allocate(crabph(nele),crabph2(nele),crabph3(nele),crabph4(nele), STAT=stat)
!    if (stat.ne.0) goto 42
    call alloc(crabph,nele,zero,'crabph')
    call alloc(crabph2,nele,zero,'crabph2')
    call alloc(crabph3,nele,zero,'crabph3')
    call alloc(crabph4,nele,zero,'crabph4')

    !TODO: Certain "COMNUL" functionality should probably be done here as well.

    return !Finished successfully
    
42  continue
    write(lout,'(A,I8,1x,A)') "ERROR in SUBROUTINE MOD_COMMON_ALLOCATE_ARRAYS; stat=", stat
    call prror(-1)

  end subroutine mod_common_allocate_arrays

  subroutine mod_common_expand_arrays(nele_new)
    implicit none
    integer, intent(in) :: nele_new
    integer stat

    !TODO: Do the thing. This will be long and fugly
    call resize(ed,nele_new,zero,'ed')
    call resize(el,nele_new,zero,'el')
    call resize(ek,nele_new,zero,'ek')
    call resize(sm,nele_new,zero,'sm')
    call resize(kz,nele_new,0,'kz')
    call resize(kp,nele_new,0,'kp')
    call resize(bbbx,nele_new,zero,'bbbx')
    call resize(bbby,nele_new,zero,'bbby')
    call resize(bbbs,nele_new,zero,'bbbs')
    call resize(xpl,nele_new,zero,'xpl')
    call resize(zpl,nele_new,zero,'zpl')
    call resize(xrms,nele_new,zero,'xrms')
    call resize(zrms,nele_new,zero,'zrms')
    call resize(a,nele_new,2,6,zero,'a')
    call resize(hsyc,nele_new,zero,'hsyc')
    call resize(phasc,nele_new,zero,'phasc')
    call resize(itionc,nele_new,0,'itionc')
    call resize(bk0,nele_new,mmul,zero,'bk0')
    call resize(ak0,nele_new,mmul,zero,'ak0')
    call resize(bka,nele_new,mmul,zero,'bka')
    call resize(aka,nele_new,mmul,zero,'aka')
    call resize(benkc,nele_new,zero,'benkc')
    call resize(r00,nele_new,zero,'r00')
    call resize(irm,nele_new,0,'irm')
    call resize(nmu,nele_new,0,'nmu')

!    allocate(bezr(3,nele), STAT=stat)
!    if (stat.ne.0) goto 42
!    call alloc(bezr,3,nele,'','bezr')

    call resize(kpa,nele_new,0,'kpa')

!    allocate(bez(nele),bezb(nele),bezl(nele), STAT=stat)
!    if (stat.ne.0) goto 42
!    call alloc(bez,nele,0,'bez')
!    call alloc(bezb,nele,0,'bezb')
!    call alloc(bezl,nele,0,'bezl')

    call resize(ncororb,nele_new,0,'ncororb')
    call resize(ratioe,nele_new,zero,'ratioe')
    call resize(iratioe,nele_new,0,'iratioe')
    call resize(isea,nele_new,0,'isea')
    call resize(dki,nele_new,3,zero,'dki')
    call resize(parbe,nele_new,18,zero,'parbe')
    call resize(ptnfac,nele_new,zero,'ptnfac')
    call resize(imtr,nele_new,0,'imtr')
    call resize(acdipph,nele_new,zero,'acdipph')
    call resize(nturn1,nele_new,0,'nturn1')
    call resize(nturn2,nele_new,0,'nturn2')
    call resize(nturn3,nele_new,0,'nturn3')
    call resize(nturn4,nele_new,0,'nturn4')
    call resize(crabph,nele_new,zero,'crabph')
    call resize(crabph2,nele_new,zero,'crabph2')
    call resize(crabph3,nele_new,zero,'crabph3')
    call resize(crabph4,nele_new,zero,'crabph4')

    !Note: One should probably here check the allocation status of the arrays, i.e. that they all actually are allocated...
    
  end subroutine mod_common_expand_arrays
end module mod_common

+dk mod_commonmn
module mod_commonmn
  use parpro
  use floatPrecision
  
  implicit none
  
+if time
  !To be deleted
  real(kind=fPrec) aaiv35,bbiv35
  common/timemain/aaiv35(mmul,nmac,nblz),bbiv35(mmul,nmac,nblz)
+ei

  ! common /main1/
  real(kind=fPrec), allocatable, save :: ekv(:,:) !(npart,nele)
  real(kind=fPrec), save :: fokqv(npart),aaiv(mmul,nmac,nblz),           &
       bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
       xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
       clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
       yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
       dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
       xlv(npart),zlv(npart),rvv(npart),                                 &
+if rvet
       rvet(npart),                                                      &
+ei
       ejf0v(npart)
  integer, save :: numxv(npart),nms(npart),nlostp(npart)
  logical, save :: pstop(npart)
  
  ! common /main2/
  real(kind=fPrec), save :: dpd(npart),dpsq(npart),fok(npart),rho(npart),&
       fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
       sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
       as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
       afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
       wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
       xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
       sigmvl(npart),aperv(npart,2),clov(2,npart),                       &
       clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
  integer, save :: iv(npart),ixv(npart)
  
  !common /main3/
  real(kind=fPrec), save :: clo6v(3,npart),clop6v(3,npart),              &
       tas(npart,6,6),qwcs(npart,3),di0xs(npart),                        &
       di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
       di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
  real(kind=fPrec), allocatable, save :: hv(:,:,:,:),bl1v(:,:,:,:) !(6,2,npart,nblo)

contains
  subroutine mod_commonmn_allocate_arrays
    implicit none
  end subroutine mod_commonmn_allocate_arrays

  subroutine mod_commonmn_expand_arrays(nele_new)
    implicit none
    integer, intent(in) :: nele_new
    integer stat

  end subroutine mod_commonmn_expand_arrays
+if vvector
  subroutine mod_commonmn_allocate_thickarrays
    use numerical_constants, only : zero
    use crcoall
    implicit none
    
    integer i1,i2,i3,i
    integer stat
    
    write(lout,*) "MOD_COMMONMN_ALLOCATE_THICKARRAYS: npart/nele/nblo=", npart, nele, nblo
    
    allocate(ekv(npart,nele), hv(6,2,npart,nblo), bl1v(6,2,npart,nblo), STAT = stat)
    if (stat.ne.0) then
       write(lout,*) "ERROR in mod_commonmn_allocate_thickarrays(); stat=",stat
       call prror(-1)
    endif
    
    !ZERO the newly allocated arrays
    do i=1,npart
       do i1=1,nblo
          do i2=1,2
             do i3=1,6
                hv(i3,i2,i,i1)=zero
                bl1v(i3,i2,i,i1)=zero
             end do
          end do
       end do
    end do
    
  end subroutine mod_commonmn_allocate_thickarrays
+ei
end module mod_commonmn

+dk mod_commons
module mod_commons
  use floatPrecision
  use parpro
  implicit none
  
+if vvector
  ! common /syos/
  real(kind=fPrec), allocatable, save :: as(:,:,:,:),al(:,:,:,:) !(6,2,npart,nele)
  real(kind=fPrec), save :: sigm(mpa),dps(mpa)
  integer, save :: idz(2)
  
  ! common /anf/
  real(kind=fPrec), save :: chi0,chid,exz(2,6),dp1
  integer, save :: itra
+ei
+if .not.vvector
  ! common /syos/
  real(kind=fPrec), save :: as(6,2,2,nele),at(6,2,2,nele),a2(6,2,2,nele),al(6,2,2,nele),sigm(mpa),dps(mpa)
  integer, save :: idz(2)
  
  ! common /anf/
  real(kind=fPrec), save :: chi0,chid,exz(2,6),dp1
  integer, save :: itra
+ei

contains

  subroutine mod_commons_allocate_arrays
    implicit none
  end subroutine mod_commons_allocate_arrays

  subroutine mod_commons_expand_arrays(nele_new)
    implicit none
    integer, intent(in) :: nele_new
    integer stat

  end subroutine mod_commons_expand_arrays
  
+if vvector
  subroutine mod_commons_allocate_thickarrays
    !Subroutine for initial allocation of the big thick tracking arrays 'al' and 'as'
    use numerical_constants, only : zero
    use crcoall
    implicit none
    
    integer stat
    integer i1,i3,i4,i
    
    write(lout,*) "MOD_COMMONS_ALLOCATE_THICKARRAYS: npart/nele=", npart, nele
    
    allocate(al(6,2,npart,nele), as(6,2,npart,nele), STAT = stat)
    if (stat.ne.0) then
       write(lout,*) "ERROR in mod_commons_allocate_thickarrays(); stat=",stat
       call prror(-1)
    endif
    
    !ZERO the newly allocated arrays
    do i=1,nele
       do i3=1,2
          do i4=1,6
             do i1=1,npart
                al(i4,i3,i1,i)=zero
                as(i4,i3,i1,i)=zero
             end do
          end do
       end do
    end do
    
  end subroutine mod_commons_allocate_thickarrays
+ei
end module mod_commons

module mod_commond2
  use floatPrecision
  use parpro, only : nele, nema
  use crcoall
  implicit none

  !Note: These only to be neccessary for thick4d?
  real(kind=fPrec), allocatable, save :: ald6(:,:,:,:), asd6(:,:,:,:) !(nele,2,6,nema)

contains
  subroutine mod_commond2_allocate_arrays
    implicit none
    integer stat

    allocate(ald6(nele,2,6,nema), asd6(nele,2,6,nema), STAT=stat)
    if (stat.ne.0) then
       write(lout,'(A,I8)') "ERROR in SUBROUTINE mod_commond2_allocate_arrays; stat=", stat
       call prror(-1)
    endif
    
  end subroutine mod_commond2_allocate_arrays

  subroutine mod_commond2_expand_arrays(nele_new)
    implicit none
    integer, intent(in) :: nele_new
    integer stat

    !TODO...
    
  end subroutine mod_commond2_expand_arrays
  
end module mod_commond2
