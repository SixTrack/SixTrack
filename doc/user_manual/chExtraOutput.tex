
\chapter{Extra Output Files} \label{ExtraOutput}

For some studies, extra output from the simulation is desired.
How to do this is described below.

% ================================================================================================================================ %
\section{Dumping of Beam Population} \label{sec:DUMP}

The \texttt{DUMP} block allows the beam population (i.e.\ the position in phase-space for all the particles) to be written to file.\index{DUMP}\index{beam population}
This can be done in any \texttt{SINGLE ELEMENTS} which are directly mentioned in the \texttt{STRUCTURE INPUT} part of \texttt{fort.2} (\texttt{BLOC}s cannot be used).
The particles are dumped just after the kick is applied, and how often to dump (every turn, every second turn, etc.) is user-selectable.
Please note that each single element can only be selected once; however it is possible to overcome this limitation by placing multiple markers with different names in the same position in the sequence (by editing \texttt{fort.2}).

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \textbf{Keyword}    & \texttt{DUMP} \\
    \textbf{Data lines} & Variable, one for each element for which dump is active. \\
    \textbf{Format}     & \texttt{element\_name frequency unit format (filename) (first last)} \\
                        & or \texttt{HIGH} \\
                        & or \texttt{FRONT}
\end{tabular}

\paragraph{Format Description}~

\bigskip
\begin{longtabu}{@{}llp{0.65\linewidth}}
    \texttt{element\_name} & char    & One of the \textit{single elements}, or \texttt{ALL} to dump at the exit of all single elements, or \texttt{StartDUMP} to dump at the injection point. Note that if \texttt{ALL} or \texttt{StartDUMP} is in use, these cannot be used as single element names. \\
    \texttt{frequency}     & integer & How often the beam population should be dumped in number of turns. \\
    \texttt{unit}          & integer & This value is ignored. Unit numbers are now assigned automatically. \\
    \texttt{format}        & integer & A switch specifying the output format. See table~(\ref{tab:dumpformat}). \\
    \texttt{filename}      & char    & The name of the file to write to. The filename may be shared between different \texttt{DUMP} outputs, as long as they have the same format and \texttt{element\_name} is not \texttt{ALL}. This argument may be omitted (unless \texttt{first} and \texttt{last} are present, if so, then \texttt{filename} must also be present), and if so the output file is named dump\_\texttt{element\_name}. \\
    \texttt{first}         & integer & The first turn where this dump should be active. This argument may be omitted if \texttt{last} is also omitted, and if so it defaults to turn 1. \\
    \texttt{last}          & integer & The last turn where this dump should be active, --1 meaning ``untill the end of the simulation''. This argument may be omitted if \texttt{first} is also omitted, and if so it defaults to -1. \\
    \texttt{HIGH}          & keyword & If present anywhere in the \texttt{DUMP} block, this triggers high-precission output, meaning more digits in the output files. \\
    \texttt{FRONT}         & keyword & If present anywhere in the \texttt{DUMP} block, this keyword triggers the DUMPed particles to be dumped in front of the element, i.e.\ before the kick. This works for all elements, including \texttt{BLOC}s, when combined with the \texttt{ALL} as \texttt{element\ name}. Note that \texttt{FRONT} is not yet supported for thick tracking, and trying to use this combination will produce a run-time error.
\end{longtabu}

\paragraph{Conventions}~

The following table show a summary of the quantities used in describing the output format. The units are declared explicitly for each dump. 

\bigskip
\begin{longtabu}{@{}llllp{0.65\linewidth}}
    \textbf{short name} & \textbf{variable} & \textbf{unit} &
    \textbf{symbol} & \textbf{description} \\
    \texttt{x} & \texttt{xv(1,j)} &[mm] & $x$& horizontal position\\
    \texttt{y} & \texttt{xv(2,j)} &[mm] & $y$& vertical position\\
    \texttt{xp} & \texttt{yv(1,j)} &[mrad] & $P_x/P\approx x'(s)$&  approximated horizontal angle\\
    \texttt{yp} & \texttt{yv(2,j)} &[mrad]& $P_y/P\approx y'(s)$&  approximated vertical angle\\
    \texttt{sigma} & \texttt{sigmv(j)} &[MeV] & $s-\beta_0 c t $& longitudinal offset (previously sometimes called \texttt{z})\\
    \texttt{psigma} & n/a &  & $ p_\sigma=\frac{E-E_0}{\beta_0 P_0 c}$& canonical conjugate of $\sigma$ \\
    \texttt{delta} & \texttt{dpsv(j)} &  & $ \delta=\frac{P-P_0}{P_0}$& canonical conjugate of $\sigma$ \\
    \texttt{rvv}   & \texttt{rvv(j)} & [1]& $r_v=\beta_0/\beta$ &velocity ratio \\
    \texttt{rpp}   & \texttt{oidpsv(j)} & [1]& $r_p=P_0/P$ &momentum ratio \\
    \texttt{zeta} &  n/a & & $\zeta=r_v(s-\beta_0 c t) $& longitudinal offset conjugate with $\delta$\\
    \texttt{mass}  & \texttt{nucm(j)} & [MeV/c$^2$] & $m$ &mass \\
    \texttt{mtc}  & \texttt{mtc(j)} & [1] & $q/q_0 \cdot m_0/m $ & mass to charge ratio\\
    \texttt{P} & \texttt{ejvf(j)} &[MeV/c] & $Pc$& momentum \\
    \texttt{E} & \texttt{ejv(j)} &[MeV] & $E$& energy \\
    \texttt{E0} & \texttt{e0} &[MeV] & $E_0$& reference energy \\
    \texttt{P0} & \texttt{e0f} &[MeV/c] & $P_0$& reference momentum \\
\end{longtabu}

\begin{center}
    \begin{longtable}{|p{1.8cm}|p{13.8cm}|}
        \caption{The following formats, set by the \texttt{format} option, are accepted:}
        \label{tab:dumpformat} \\*
        \hline
        \rowcolor{blue!30}
        \#/Pos & Description \\*
        \endfirsthead

        \hline
        \rowcolor{blue!30}
        \#/Pos & Description \\*
        \endhead

        \rowcolor{gray!15}
        \multicolumn{2}{|c|}{(The table continues on the next page)}\\*
        \hline
        \endfoot

        \hline
        \endlastfoot

        \hline
        %Format 0
        \rowcolor{blue!15}
        \texttt{0} & General format \\
        \hline
        Header & No header.\\
        \hline
        Lines  & \texttt{turn structure\_element\_idx single\_element\_idx single\_element\_name s x[m] xp[rad] y[m] yp[rad] P[GeV/c] (E-E0)[eV] t[s]}\\
        \hline
        %Format 1
        \rowcolor{blue!15}
        \texttt{1} & Format for aperture check \\
        \hline
        Header & \texttt{\# particleID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] (E-E0)/E0[1] ktrack} \\
        \hline
        Lines  & \texttt{particleID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] (E-E0)/E0 ktrack} \\
        \hline
        %Format 2
        \rowcolor{blue!15}
        \texttt{2} & Modified format for aperture check \\
        \hline
        Header \#1 & (single element)\\ & \texttt{\# DUMP format \#2, bez=\textcolor{blue!90}{bez(i)}, number of particles=\textcolor{blue!90}{napx}, dump period=\textcolor{blue!90}{ndumpt(i)}, first turn=\textcolor{blue!90}{dumpfirst(i)}, last turn=\textcolor{blue!90}{dumplast(i)}, HIGH=\textcolor{blue!90}{T/F}, FRONT=\textcolor{blue!90}{T/F}} \\
        \hline
        Header \#1 & (all elements)\\ & \texttt{\# DUMP format \#2, ALL ELEMENTS, number of particles=\textcolor{blue!90}{napx}, dump period=\textcolor{blue!90}{ndumpt(i)}, first turn=\textcolor{blue!90}{dumpfirst(i)}, last turn=\textcolor{blue!90}{dumplast(i)}, HIGH=\textcolor{blue!90}{T/F}, FRONT=\textcolor{blue!90}{T/F}}\vspace{1mm} \\
           & Here \textcolor{blue!90}{bez} is the name of the SINGLE ELEMENT, and \textcolor{blue!90}{napx} the number of particles being tracked, \textcolor{blue!90}{ndumpt(i)} the dump frequency as described above, and \textcolor{blue!90}{dumpfirst(i)} and \textcolor{blue!90}{dumplast(i)} the first and last turn as descirbed below.\vspace{1mm} \\
           & \texttt{HIGH} and \texttt{FRONT} is normally false, unless this (global) option is active, as described below.\\
        \hline
        Header \#2 & \texttt{\# particleID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] sigma[mm] (E-E0)/E0[1] ktrack}\vspace{1mm} \\
           & If there are multiple single elements attached to the file, the headers are repeated.\\
        \hline
        Lines & As described in the header, one per particle and per turn. \\
        \hline
        %Format 3
        \rowcolor{blue!15}
        \texttt{3} & Modified format for aperture check (Binary) \\
        \hline
        Header & No header.\vspace{1mm}\\
               & A number of Fortran records describing which elements are used and the current dump period is added one per relevant line in the \texttt{DUMP} block.\\ \hline
        Lines  & \texttt{particleID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] sigma[mm] (E-E0)/E0 ktrack} \\
               & The Fortran code \texttt{SixTest/readDump3/readDump3.f90} can be used to convert these files into the Format 2 (sans headers). \\ \hline
            \hline
        %Format 4
        \rowcolor{blue!15}
        \texttt{4} & Beam means \\
        \hline
        Header \#1 & Same as for Format 2. \\
        \hline
        Header \#2 & \texttt{\# napx turn s[m] <x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <sigma>[mm] <(E-E0)/E0>[1]}\vspace{1mm} \\
                   & If there are multiple single elements attached to the file, the headers are repeated.\\
        \hline
        Lines      & As described in the header; one per turn. \\
        \hline
        %Format 5
        \rowcolor{blue!15}
        \texttt{5} & Beam mean and sigma \\
        \hline
        Header \#1 & The same as for format 2.\\
        \hline
        Header \#2 & \texttt{\# napx turn s[m] <x>[mm] <xp>[mrad] <y>[mm] <yp>[mrad] <sigma>[mm] <(E-E0)/E0>[1] <x\^{}2> <x*xp> <x*y> <x*yp> <x*sigma> <x*(E-E0)/E0> <xp\^{}2> <xp*y> <xp*yp> <xp*sigma> <xp*(E-E0)/E0> <y\^{}2> <y*yp> <y*sigma> <y*(E-E0)/E0> <yp\^{}2> <yp*sigma> <yp*(E-E0)/E0> <sigma\^{}2> <sigma*(E-E0)/E0> <((E-E0)/E0)\^{}2>}\vspace{1mm} \\
                   & If there are multiple single elements attached to the file, the headers are repeated. A number of lines describing which elements are used and the current dump period is added one per relevant line in DUMP block.\\
        \hline
        Lines      & As described in the header; one per turn. For the ``product'' quantities, the units are the product of the units of the ``normal'' ones. \\
        \hline
        %Format 6
        \rowcolor{blue!15}
        \texttt{6} & Beam mean and sigma (canonical) \\
        \hline
        Header \#1 & The same as for format 2.\\
        \hline
        Header \#2 & \texttt{\# napx turn s[m] <x>[m] <px>[1] <y>[m] <py>[m] <sigma>[m] <psigma>[1] <x\^{}2> <x*px> <x*y> <x*py> <x*sigma> <x*psigma> <px\^{}2> <px*y> <px*py> <px*sigma> <px*psigma> <y\^{}2> <y*py> <y*sigma> <y*psigma> <py\^{}2> <py*sigma> <py*psigma> <sigma\^{}2> <sigma*psigma> <psigma\^{}2>}\vspace{1mm}\\
                   & If there are multiple single elements attached to the file, the headers are repeated. A number of lines describing which elements are used and the current dump period is added one per relevant line in \texttt{DUMP} block.\\
        \hline
        Lines      & As described in the header; one per turn. For the ``product'' quantities, the units are the product of the units of the ``normal'' ones. Note that $p_\sigma = \Delta E / \left(\beta_0 P_0 c\right)$. For more details, see the physics manual~\cite{sixphys}. \\
        \hline
        %Format 7
        \rowcolor{blue!15}
        \texttt{7} & Normalized coordinates\\
        \hline
        & Dumps the particle trajectories in normalised coordinates. If the coordinates are dumped at the start of the sequence (\texttt{StartDUMP}), the normalization matrix as used for the initialization of the particle amplitudes is used. This means, that if 4D optics are chosen, the 4D matrix is used, if 6D optics is chosen, the matrix obtained from the 6D optics calculation is chosen. For every other element except \texttt{StartDUMP}, the 6D optics are used independent of the tracking method chosen. In this case the 6D optics needs to be run and the following lines have to be inserted in \texttt{fort.3}:
        \bigskip
        \begin{cverbatim}
DUMP
element_name_1 1 unit_1 7 filename_1 first_turn_1 last_turn_1
...
NEXT
LINE
ELEMENT  0 2 1 emit_1 emit_2
NEXT
        \end{cverbatim}
        \bigskip
        If there are multiple single elements attached to the file, the headers are repeated.\\
        \hline
        Header \#1 & The same as for format 2.\\
        \hline
        Header \#2 & Closed orbit  $x$,$x_p$,$y$,$y_p$,$\sigma$,$\delta$, units are $[\rm mm,mrad,mm,mrad,1]$.\\
        \hline
        Header \#3 & Matrix of eigenvectors (\texttt{tamatrix}). Eigenvectors are normalized, rotated and ordered as in the Ripken formalism and described in the SixTrack physics manual, Chapter ``Optics Calculation''. The matrix \texttt{tamatrix} is in canonical variables $x$,$p_x$,$y$,$p_y$,$\zeta$,$\delta$, units are $[\rm mm,mrad,mm,mrad,1]$. \\
        \hline
        Header \#4 & Inverse of ta-matrix \texttt{inv(tamatrix)} used for normalization where
        \begin{equation}
            z_{\rm norm}=\texttt{inv(tamatrix)}\cdot z
        \end{equation}
        Matrix \texttt{inv(tamatrix)} and $z$ is given in canonical variables $x$,$p_x$,$y$,$p_y$,$\zeta$,$\delta$, units are $[\rm mm,mrad,mm,mrad,1]$.\\
        \hline
        Header \#5 & Header with units of normalized particle coordinates:\\
                   & \texttt{\# particleID turn s[m] nx[1.e-3 sqrt(m)] npx[1.e-3 sqrt(m)] ny[1.e-3 sqrt(m)] npy[1.e-3 sqrt(m)] nsigma[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] ktrack} \\
        \hline
        Lines      & As described in the header, one per particle and per turn.\\
        \hline
        %Format 8
        \rowcolor{blue!15}
        \texttt{8} & Normalized coordinate (binary)\\
        \hline
        Header  & No header.\vspace{1mm} \\
                & A number of Fortran records describing which elements are used and the current dump period is added one per relevant line in DUMP block. Format 8 is format 7 without header and in binary format.\\
        \hline
        Lines   & \texttt{\# particleID turn s[m] nx[1.e-3 sqrt(m)] npx[1.e-3 sqrt(m)] ny[1.e-3 sqrt(m)] npy[1.e-3 sqrt(m)] nsigma[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] ktrack}\vspace{1mm} \\
                & The Fortran code \texttt{SixTest/readDump3/readDump3.f90} can be used to convert these files into the Format 2 (sans headers). \\
        \hline
        %Format 9
        \rowcolor{blue!15}
        \texttt{9} & Beam mean and sigma (normalized coordinates) \\
        \hline
        Header \#1 & The same as for format 2.\\
        \hline
        Header \#2 & \texttt{\# napx turn s[m] <nx>[1.e-3 sqrt(m)] <npx>[1.e-3 sqrt(m)] <ny>[1.e-3 sqrt(m)] <npy>[1.e-3 sqrt(m)] <nsigma>[1.e-3 sqrt(m)] <npsigma>[1.e-3 sqrt(m)] <nx\^{}2> <nx*npx> <nx*ny> <nx*npy> <nx*nsigma> <nx*npsigma> <npx\^{}2> <npx*ny> <npx*npy> <npx*nsigma> <npx*npsigma> <ny\^{}2> <ny*npy> <ny*nsigma> <ny*npsigma> <npy\^{}2> <npy*nsigma> <npy*npsigma> <nsigma\^{}2> <nsigma*npsigma> <npsigma\^{}2>}\vspace{1mm}\\
                   & If there are multiple single elements attached to the file, the headers are repeated. A number of lines describing which elements are used and the current dump period is added one per relevant line in \texttt{DUMP} block.\\
        \hline
        %Format 101
        \rowcolor{blue!15}
        \texttt{101} & Binary format for debugging (format not stable) \\
        \hline
        Header & No header.\vspace{1mm}\\
               & A number of Fortran records describing which elements are used and the current dump period is added one per relevant line in the \texttt{DUMP} block.\\
        \hline
        Lines  & \texttt{particleID turn s[m] x[mm] xp[mrad] y[mm] yp[mrad] z[mm] (E-E0)/E0 ktrack E[MeV] P[MeV/c] delta(j)[1] rpp[1] rvv[1] nucm[MeV] mtc[1] e0[MeV] e0f[MeV/c] } \\
       \end{longtable}
\end{center}

\paragraph{Examples}~
\begin{cverbatim}
DUMP
/ALL 1 663 2
/CRAB5 1 659 0
ip1 1 660 2 IP1_DUMP.dat
ip5 1 662 2
mqml.10l4.b1..1 1 661 2 MQ_DUMP.dat
NEXT
\end{cverbatim}

% ================================================================================================================================ %
\section{FMA Analysis} \label{sec:FMA}

The FMA block generates the basic files needed for frequency map analysis (FMA).\index{frequency map analysis}\index{FMA}
Explicitly, it returns one output file with calculated tunes and amplitudes for the files specified in the \texttt{DUMP} block, see Sec.~\ref{sec:DUMP}.
For the calculation of the tunes ($Q_1$, $Q_2$ and $Q_3$) in normalized phase space, the normalization matrix is extracted from the \texttt{LINE} block (linear optics calculation in 6D, \ref{LinOpt}).
In case the particles are dumped at the beginning of the sequence (\texttt{StartDUMP}), the closed orbit and normalization matrix used also for the initialization of the particles is used.
In this case, the \texttt{LINE} block is not needed.
The tunes $Q_1$, $Q_2$ and $Q_3$ are then calculated with the routine specified in the \texttt{FMA} block either in physical coordinates ($x$,$x'$,$y$,$y'$,$z$,$dE/E$) or normalized phase space coordinates and dumped to the file \texttt{fma\_sixtrack} together with the minimum, maximum and average normalized particle amplitudes and phases.

To use normalised coordinates for the FMA analysis is always possible in case of 6D tracking (remember to put the \texttt{LINE} block for other elements than the start of the sequence). In case of 4D tracking, the following limitations apply:
\begin{itemize}
    \item The FMA analysis is only implemented for the start of the sequence (\texttt{StartDUMP}). For other elements the normalization matrix would need to be obtained from the \texttt{LINE} block, which has not been checked in case of 4D optics.
    \item 4D tracking with scan in energy is disabled as in this case the normalization matrix would need to be saved for each element and particle, which requires a huge amount of memory breaking other parts of the code.
\end{itemize}
In general it is also recommended to already normalize the coordinates in DUMP as this is faster than in FMA.

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \textbf{Keyword}    & \texttt{FMA} \\
    \textbf{Data lines} & Variable, one for each file with particle amplitudes and tune calculation method, and one for each flag given. \\
    \textbf{Format}     & \texttt{filename\_1 method\_1 (fma\_flag\_norm\_1 (fma\_first\_turn fma\_last\_turn))}\\
                        & OR \texttt{NoNormDUMP}\\
\end{tabular}

\bigskip
The \texttt{FMA} block has to be proceeded by the \texttt{LINE} block (calculation of the normalization matrix) and the \texttt{DUMP} block (dump particle coordinates).
\begin{cverbatim}
DUMP
element_name_1 1 unit_1 2 filename_1 first_turn_1 last_turn_1
element_name_2 1 unit_2 2 filename_2 first_turn_2 last_turn_2
NEXT
LINE
ELEMENT  0 2 1 emit_1 emit_2
NEXT
FMA
filename_1 method_1 fma_flag_norm_1 fma_first_turn_1 fma_last_turn_1
filename_2 method_2 fma_flag_norm_2 fma_first_turn_2 fma_last_turn_2
NEXT
\end{cverbatim}
For the \texttt{DUMP} block (Sec.~\ref{sec:DUMP}) the frequency has to be 1 (dump every turn) and the file format has to be 2 or 3.
For the linear optics calculation \ref{LinOpt}, the optics needs to be calculated at each element (mode ELEMENT), the number-of-blocks is then 0 and 6D linear optics calculation is required (\texttt{ilin = 2}) in order to decouple the 6D motion.

\paragraph{Format Description}~

\bigskip
\begin{longtabu}{@{}p{2.8cm}p{0.75\linewidth}}
    \texttt{filename} & One of the output files specified in the \texttt{FMA} block preceding \texttt{DUMP} block. \\
    \texttt{method}   & Method used to calculate the tune\index{tune}. Available methods are: \texttt{TUNELASK, TUNEFIT, TUNENEWT1, TUNEABT, TUNEABT2, TUNEFFT, TUNEFFTI, TUNENEWT, TUNEAPA, NAFF}. A short description of the different methods is given in Table~\ref{fma:tab:1}. \\
    \texttt{fma\_flag\_norm} & Optional flag for calculating the tunes with physical ($x$,$x_p$,$y$,$y_p$,$\zeta$,$\delta$) or normalized coordinates in case physical coordinates are used in DUMP. The default is using normalized coordinates (\texttt{fma\_flag\_norm = 1}). For using physical coordinates explicitly set (\texttt{fma\_flag\_norm = 0}). See \textbf{Description} for the conditions under which normalization is available. \\
    \texttt{fma\_first\_turn, fma\_last\_turn} & Turns used for FMA analysis. As the \texttt{DUMP} files are used as input for the FMA analysis \texttt{fma\_first\_turn} must be larger \texttt{first\_turn} in the \texttt{DUMP} block and  \texttt{fma\_last\_turn} must be smaller than \texttt{last\_turn} in the \texttt{DUMP} block. If \texttt{fma\_last\_turn = -1} the last turn number in the dump file is taken as the last turn number, including the last turn tracked if the \texttt{last} setting of the dump equals -1. By default, \texttt{FMA} will use the same turns as for the \texttt{DUMP}. \\
    \texttt{NoNormDUMP} & A flag for disabling the \texttt{NORM\_filename*} output files. This saves disk space and speeds up the calculation of the FMA. If used, the flag should be alone on a one line of the FMA input block in \texttt{fort.3}. Note that the capitalization must be correct for the flag to be recognized.
\end{longtabu}

\paragraph{Output file format}~\\

The \texttt{FMA} block returns the output files \texttt{NORM\_filename*} containing the normalized phase space coordinates, where \texttt{filename} are the filenames specified in the \texttt{DUMP} block, and the file \texttt{fma\_sixtrack} containing the initial, average, minimum and maximum amplitudes and the calculated tunes for each specified filename and method.
The structure of the \texttt{NORM\_filename*} is described in Table~\ref{fma:tab:2} and of the \texttt{fma\_sixtrack} in Table~\ref{fma:tab:3}.

\begin{table}[H]
\begin{center}
    \caption{Available tune calculation methods in SixTrack.}
    \label{fma:tab:1}
    \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \rowcolor{blue!30}
    \textbf{Library} & \textbf{Method} & \textbf{Description} \\
    \hline
    \texttt{PLATO} \cite{plato1,plato2}
    & \texttt{TUNELASK} & Compute the tune\index{tune} of a 2d map by means of laskar method. A first indication of the position of the tune is obtained by means of a FFT. Refinement is obtained through a newton procedure.\\
    \cline{2-3}
    & \texttt{TUNEFIT} & Computes the tune using a modified apa algorithm. The first step consists of taking the average of the tune computed with the APA method, then a best fit is performed.\\
    \cline{2-3}
    & \texttt{TUNENEWT1} & Computes the tune using a discrete version of laskar method. It includes a newton method for the search of the frequency.\\
    \cline{2-3}
    & \texttt{TUNENEWT} & Computes the tune using a discrete version of laskar method. It includes a newton method for the search of the frequency.\\
    \cline{2-3}
    & \texttt{TUNEABT} & Computes the tune using FFT\index{FFT} interpolated method.\\
    \cline{2-3}
    & \texttt{TUNEABT2} & Computes the tune using the interpolated FFT method with hanning filter.\\
    \cline{2-3}
    & \texttt{TUNEFFT} & Computes the tune as the FFT on a two dimensional plane, given n iterates of a map. The FFT is performed over the maximum mft which satifies $2^{\rm mft} <= n$, where the maximum number of iterates is fixed in the parameter n.\\
    \cline{2-3}
    & \texttt{TUNEFFTI} & Computes the tune as the FFT on a two dimensional plane, given n iterates of a map. The FFT is performed over the maximum mft which satifies $2^{\rm mft} <= n$. Then, the FFT is interpolated fitting the three points around the maximum using a Gaussian. The tune is computed as the maximum of the Gaussian.\\
    \cline{2-3}
    & \texttt{TUNEAPA} & Computes the tune as the average phase advance on a two dimensional plane, given n iterates of a map. \\
    \hline
    \texttt{NAFF} \cite{NAFFpaper, NAFFpaper2}
    & \texttt{NAFF} & Computes the tune using the laskar method. The first estimation of the tune is obtained with an FFT and the precise value is determined by maximizing the Fourier integral. A Hann window of first and second order for the transverse and longitudinal motion are used respectively\index{NAFF}. \\
    \hline
    \end{tabularx}
\end{center}
\end{table}

\begin{table}[H]
\begin{center}
    \caption{Format of the \texttt{NORM} files}\label{fma:tab:2}
    \begin{tabularx}{\textwidth}{|c|c|X|}
        \hline
        \rowcolor{blue!30}
        \textbf{Line Number} & \textbf{Type} & \textbf{Description} \\
        \hline
        1 & Header & Closed orbit  $x$,$x'$,$y$,$y'$,$z$,$dE/E$, units are $[\rm mm,mrad,mm,mrad,1]$. \\
        \hline
        2--38 & Header & Matrix of eigenvectors (\texttt{tamatrix}). Eigenvectors are normalized, rotated and ordered as in the Ripken formalism. The matrix \texttt{tamatrix} is in canonical variables $x$,$p_x$,$y$,$p_y$,$\zeta$,$\delta$, units are $[\rm mm,mrad,mm,mrad,1]$. \\
        \hline
        39--75 & Header & Inverse of ta-matrix \texttt{inv(tamatrix)} used for normalization where \hbox{$z_{\rm norm}=\rm{ta}\cdot z$}. Matrix \texttt{inv(tamatrix)} is given in canonical variables $x$,$p_x$,$y$,$p_y$,$\zeta$,$\delta$, units are $[\rm mm,mrad,mm,mrad,1]$.\\
        \hline
        76 & Header & Header with units:\\
        &  & \texttt{\# id turn pos[m] nx[1.e-3 sqrt(m)] npx[1.e-3 sqrt(m)] ny[1.e-3 sqrt(m)] npy[1.e-3 sqrt(m)] nsig[1.e-3 sqrt(m)] ndp/p[1.e-3 sqrt(m)] kt} \\
        \hline
        77--EOF & Lines & See header in line 76: \texttt{particle id, turn number position s[m], normalized coordinates $[10^{-3} \sqrt{\rm m}]$, ktrack} (type of element)\\
        \hline
    \end{tabularx}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
    \caption{Format of the fma\_sixtrack file}\label{fma:tab:3}
    \begin{tabularx}{\textwidth}{|c|c|X|}
        \hline
        \rowcolor{blue!30}
        \textbf{Line Number} & \textbf{Type} & \textbf{Description} \\
        \hline
        1--2 & Header & Header with units and description:\\
             &        & \texttt{\# eps0*,eps2*,eps3* all in 1.e-6*m, phi* [rad]} \\
             &        & \texttt{\# inputfile method id q1 q2 q3 eps1\_min eps2\_min eps3\_min eps1\_max eps2\_max eps3\_max eps1\_avg eps2\_avg eps3\_avg eps1\_0 eps2\_0 eps3\_0 phi1\_0 phi2\_0 phi3\_0 norm\_flag first\_turn last\_turn}\\
        \hline
        3--EOF & Lines & See header in line 1-2: The lines are ordered as particles 1-npart for (inputfile1,method1), then  particles 1-npart for (inputfile2,method2), etc.. The minimum (min), maximum (max) and average (avg) are taken over the number of turns in the inputfile (fiel specified in the FMA and DUMP block). Units are $\mu \rm m$ for \texttt{eps*} and rad for \texttt{phi*}, where \texttt{phi*} is the angle in the normalized phase space coordinates.\\
        \hline
    \end{tabularx}
\end{center}
\end{table}

\paragraph{Example}~\\

An input block to compare the tunes at element IP3 calculated over the interval $[1,4096]$ and $[5905,10000]$, and using the method \texttt{TUNELASK} would look like:
\begin{cverbatim}
DUMP
IP3 1 1030 2 IP3_DUMP_1 1 4096
IP3..1 1 1031 2 IP3_DUMP_2 5905 10000
IP3..2 1 1032 2 IP3_DUMP_3 1 4096
IP3..3 1 1033 2 IP3_DUMP_4 5905 10000
NEXT
LINE
ELEMENT  0 2 1 3.75 3.75
NEXT
FMA
IP3_DUMP_1 TUNELASK
IP3_DUMP_2 TUNELASK 1 512 1024
IP3_DUMP_3 TUNELASK 0
IP3_DUMP_4 TUNELASK 0 512 1024
NEXT
\end{cverbatim}
where for \texttt{IP3\_DUMP\_1} and \texttt{IP3\_DUMP\_2} the tunes are calculated using normalized coordinates (default) and for \texttt{IP3\_DUMP\_3} and \texttt{IP3\_DUMP\_4} the physical coordinates are used (\texttt{fma\_norm\_flag = 0}).
For \texttt{IP3\_DUMP\_2} and \texttt{IP3\_DUMP\_4} the turns from 512 to 1024 are used for the FMA analysis. This is particularly useful for detecting the maximum diffusion in tunes by taking the maximum over difference over several moving windows.

Note that all element names have to be different due to a limitation in DUMP module. This means practically, that one needs to insert additional markers (here \texttt{IP3..1} etc.) in the SixDesk \cite{sixdesk1,sixdesk2} mask file prior to the SixTrack run. It is important to install the additional markers after cycling the machine if the machine is cycled at the location of the additional (e.g. \texttt{IP3}), as they are installed in front of the element given in the from statement in the cycle command.

% ================================================================================================================================ %
\section{File Hash} \label{sec:HASH}

The hash module can optionally compute the MD5 digest of a selected set of output files listed in a \texttt{HASH} block\index{HASH}\index{md5}.
The hash values are written to the output file \texttt{hash.md5}.
The hash values are computed just before the \texttt{ZIPF} file compression routine is called, so the hash file can be included in the final archive.

During initialisation, the module will perform a self test to ensure it generates valid md5 hashes according to the RFC1321 standard.
If this is not achieved, the module is disabled, and the \texttt{hash.md5} file contains an error message instead.

The primary purpose of this module is for validation of results for BOINC and the test suite.

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \textbf{Keyword}    & \texttt{HASH} \\
    \textbf{Data lines} & Variable, one for each file to be hashed. \\
\end{tabular}

\paragraph{Usage}~\\

The module accepts a single keyword, \texttt{MD5SUM}, followed by a file name, followed by either ``text'' or ``binary''.
This can be repeated multiple times.
The ``text'' flag is used on Windows to strip carriage returns from the file before hashing.
If the md5sum tool is installed on the user's computer, the results can be validated with the command:
\begin{cverbatim}
md5sum -c hash.md5
\end{cverbatim}
    
\paragraph{Example}~
\begin{cverbatim}
HASH
  MD5SUM final_state.dat text
  MD5SUM fort.10         text
NEXT
\end{cverbatim}

% ================================================================================================================================ %
\section{ZIPFile Combined and Compressed Output} \label{sec:ZIPF}

In order to retrieve extra simulation output such as \texttt{DUMP} or \texttt{FMA} from BOINC, it is necessary to pack the output files into a single file with a special name that will be retrieved.\index{zip}\index{ZIPF}\index{ZLIB}
This can be achieved with the \texttt{ZIPF} block, which packs the listed files into a compressed archive at the end of the simulation.
The \texttt{ZIPF} block can always be present in \texttt{fort.3}, but if SixTrack was not built with either the \texttt{LIBARCHIVE} or \texttt{ZLIB} option, no archive file will be produced.

The \texttt{ZIPF} block can take two optional arguments, otherwise everything else is interpreted as a file name to be packed into the archive file.
Multiple file names can be specified on a single line, and are separated by a space character.
If the file name contains a space, it must be wrapped in single or double quotes.

Note that if one of the files do not exist at the end of the simulation, it will be silently skipped and not included in the archive.

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \textbf{Keyword}    & \texttt{ZIPF} \\
    \textbf{Data lines} & Variable, see below. \\
\end{tabular}

\paragraph{Archive Name} \texttt{OUTFILE}\\

This keyword can be used to set the file name of the archive file.
If this keyword is omitted, the archive file will be named ``Sixout.zip''.

\paragraph{Compression Level} \texttt{ZIPLEVEL}\\

This keyword can be used to set the compression level.
A value of 0 will just pack the files, and not compress them.
A value of 9 is the highest level of compression, and also the slowest,
The default value is 3.

\paragraph{Example}~
\begin{cverbatim}
ZIPF
    OUTFILE Sixout.zip
    ZIPLEVEL 3
    fma_sixtrack IP3_DUMP_1 fort.90
NEXT
\end{cverbatim}

% ================================================================================================================================ %
\section{HDF5 Output} \label{sec:HDF5}

The \texttt{HDF5} block allows for writing certain outputs to a HDF5 file instead of regular text or binary files.\index{HDF5}
HDF5 files can be easily read and manipulated with for instance MATLAB or Python.
MATLAB has native support, while Python support is available through h5py.

The SixTrack HDF5 option is enabled through the \texttt{HDF5} compiler flag, and controlled via the \texttt{HDF5} block.

\bigskip
\noindent Note: SixTrack HDF5 support is experimental.

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \textbf{Keyword}    & \texttt{HDF5} \\
    \textbf{Data lines} & Variable, see below. \\
    \textbf{Format}     & This module uses a keyword, value format. See below.
\end{tabular}

\bigskip

\paragraph{Debugging} \texttt{DEBUG}\\

This statement switches on extra ``debugging'' output for the \texttt{HDF5} module.
This can be useful if debugging the code or if debugging the input.

\paragraph{Precision} \texttt{SINGLE}, \texttt{DOUBLE}\\

The precision of float numbers for the file. If omitted, the value defaults to \texttt{DOUBLE}.

The output precision is independent of the internal precision of SixTrack set at compile time.
If necessary, the float values will be converted on the fly.
Quad precision is currently not available.

The precision of integers is the same as the internal Fortran precision defined by the compiler.
Generally, this is 32 bits.

\paragraph{Output File} \texttt{FILE filename truncate}\\

The name of the file to write to.
Spaces are allowed as long as quote marks are used.
The truncate flag is optional, either \texttt{.true.} or \texttt{.false.}.
If true, any existing file will be truncated.
If false, any existing file will throw an error.
Default value is \texttt{.false.}.
If truncation is disabled, and the file exists, the root group must be unique for the current run.
This allows the option to write multiple simulation runs to the same file with different root groups.

\paragraph{Root Group} \texttt{ROOT groupname}\\

The name of the root group (folder) for where to write the simulation data.
The default value is ``/'', that is, all data is written into block specific groups at the root of the file.
Setting root group allows several runs to use the same output file as long as the root group is unique.

For further information on how HDF5 uses groups and datasets, see the HDF5 manual \cite{h5_doc}.

\paragraph{Chunking} \texttt{CHUNK chunksize}\\

HDF5 files written by SixTrack uses data chunking.
Chunking allows for writing data into related block.
For instance, for \texttt{DUMP}, the chunck size is hard coded to the nuber of particles.
This can improve read performance as the particle data will then be written in a single chunk per turn.
For non-predictable outputs, like log files, a default chunk value can be set.
The chunk size should be close to the number of entries expected to be written per turn.
If none is specified, the defualt value is $10$.

For further information on HDF5 chunking, see the HDF5 manual \cite{h5_doc}.

\paragraph{Compression} \texttt{GZIP level}\\

The level of compression to use for data chunks written to the HDF5 file.\index{zip}\index{gzip}
Allowed values are $-1$ to disable gzip compression, and $0$ to $9$ for none to maximum compression.

\bigskip
\begin{tabular}{@{}llp{0.7\linewidth}}
    \texttt{0}   & No compression \\
    \texttt{1}   & Best compression speed; least compression \\
    \texttt{2-8} & Compression improves; speed degrades \\
    \texttt{9}   & Best compression ratio; slowest speed
\end{tabular}

\bigskip
Note that $0$ does not turn off use of the gzip, it just instructs the filter to perform no action.\
To disable GZIP, either ommit the line, or set the level to $-1$.
For more detail, see the HDF5 manual~\cite{h5_doc}.

\paragraph{Enable HDF5} \texttt{ENABLE blockname}\\

HDF5 output needs to be specifically enabled for the blocks where it is to be used instead of ASCII or binary data dumps.
The \texttt{blockname} takes the four first characters of the block for which to enable HDF5.
An further characters are ignored, but may be used for clarity like for othe rblock declarations.
In other words, \texttt{ENABLE SCAT} and \texttt{ENABLE SCATTER} are equally valid.

HDF5 output is currently available only for \texttt{SCATTER}, \texttt{DUMP}, \texttt{APERTURE} and \texttt{COLLIMATION}.

\paragraph{Write Flag} \texttt{WRITE type}\\

Certain special outputs are possible through the \texttt{WRITE} flag:
\begin{description}
    \item[\texttt{OPTICS}] Dumps the linear optics to the root group of the file.
    \item[\texttt{TRACKS2}] Writes the collimation tracks2 output to the root group of the file.
\end{description}

\paragraph{Example:}~\\

The following is an example of a valid \texttt{HDF5} block:

\begin{cverbatim}
HDF5
    DEBUG
    DOUBLE
    GZIP 1
    CHUNK 50
    FILE data.hdf5 .true.
    ROOT test
    ENABLE SCATTER
    ENABLE DUMP
    WRITE OPTICS
NEXT
\end{cverbatim}

% ================================================================================================================================ %
\section{Simulation Meta Data and Timing Output} \label{sec:METATIME}

SixTrack produces two text files containing meta data and timing data for the last run simulation.
Both these files are in a fixed column width format, making them straightforward to parse with other tools.

\paragraph{META:}~
\index{Meta Data}
The file \texttt{sim\_meta.dat} contains information about the SixTrack executable such as version information, build details and execution time.
The file also contains initial values and values calculated during tracking that may be useful for further post-processing.

\paragraph{TIME:}~
\index{Timing Data}
The file \texttt{sim\_time.dat} contains information about the execution time of the last SixTrack run.
There are a number of time stamp at key points during execution written to the file.
In addition, the total tracking time is extracted, and various averages computed based on number of particles, turns or the size of the lattice.
